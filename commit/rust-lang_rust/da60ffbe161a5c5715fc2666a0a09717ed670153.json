{"sha": "da60ffbe161a5c5715fc2666a0a09717ed670153", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNjBmZmJlMTYxYTVjNTcxNWZjMjY2NmEwYTA5NzE3ZWQ2NzAxNTM=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-29T01:50:31Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-30T17:43:25Z"}, "message": "Move query definitions over to the proc macro", "tree": {"sha": "d4b49e01a3dd3aa25be01eb5d4ab21b778ab9709", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4b49e01a3dd3aa25be01eb5d4ab21b778ab9709"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da60ffbe161a5c5715fc2666a0a09717ed670153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da60ffbe161a5c5715fc2666a0a09717ed670153", "html_url": "https://github.com/rust-lang/rust/commit/da60ffbe161a5c5715fc2666a0a09717ed670153", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da60ffbe161a5c5715fc2666a0a09717ed670153/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b170cd5402069d886210a307adedd2444a0ec21", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b170cd5402069d886210a307adedd2444a0ec21", "html_url": "https://github.com/rust-lang/rust/commit/0b170cd5402069d886210a307adedd2444a0ec21"}], "stats": {"total": 2978, "additions": 957, "deletions": 2021}, "files": [{"sha": "e5bf9a27ab0500b40d1b5bde87e152e07b72d3ff", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 9, "deletions": 202, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=da60ffbe161a5c5715fc2666a0a09717ed670153", "patch": "@@ -65,8 +65,7 @@ use crate::traits::query::{\n     CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalPredicateGoal,\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal,\n };\n-use crate::ty::{TyCtxt, FnSig, Instance, InstanceDef,\n-         ParamEnv, ParamEnvAnd, Predicate, PolyFnSig, PolyTraitRef, Ty};\n+use crate::ty::{self, TyCtxt, ParamEnvAnd, Ty};\n use crate::ty::subst::SubstsRef;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n@@ -432,211 +431,13 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     // Represents metadata from an extern crate.\n     [eval_always] CrateMetadata(CrateNum),\n \n-    // Represents different phases in the compiler.\n-    [] RegionScopeTree(DefId),\n-    [eval_always] Coherence,\n-    [eval_always] CoherenceInherentImplOverlapCheck,\n-    [] CoherenceCheckTrait(DefId),\n-    [eval_always] PrivacyAccessLevels(CrateNum),\n-    [eval_always] CheckPrivateInPublic(CrateNum),\n-    [eval_always] Analysis(CrateNum),\n-\n-    // Represents the MIR for a fn; also used as the task node for\n-    // things read/modify that MIR.\n-    [] MirShim { instance_def: InstanceDef<'tcx> },\n-\n-    [] BorrowCheckKrate,\n-    [] BorrowCheck(DefId),\n-    [] MirBorrowCheck(DefId),\n-    [] UnsafetyCheckResult(DefId),\n-    [] UnsafeDeriveOnReprPacked(DefId),\n-\n-    [] LintMod(DefId),\n-    [] CheckModAttrs(DefId),\n-    [] CheckModLoops(DefId),\n-    [] CheckModUnstableApiUsage(DefId),\n-    [] CheckModItemTypes(DefId),\n-    [] CheckModPrivacy(DefId),\n-    [] CheckModIntrinsics(DefId),\n-    [] CheckModLiveness(DefId),\n-    [] CheckModImplWf(DefId),\n-    [] CollectModItemTypes(DefId),\n-\n-    [] Reachability,\n-    [] CrateVariances,\n-\n-    // Nodes representing bits of computed IR in the tcx. Each shared\n-    // table in the tcx (or elsewhere) maps to one of these\n-    // nodes.\n-    [] AssociatedItems(DefId),\n-    [] ExplicitPredicatesOfItem(DefId),\n-    [] PredicatesDefinedOnItem(DefId),\n-    [] InferredOutlivesOf(DefId),\n-    [] InferredOutlivesCrate(CrateNum),\n-    [] SuperPredicatesOfItem(DefId),\n-    [] TraitDefOfItem(DefId),\n-    [] AdtDefOfItem(DefId),\n-    [] ImplTraitRef(DefId),\n-    [] ImplPolarity(DefId),\n-    [] Issue33140SelfTy(DefId),\n-    [] FnSignature(DefId),\n-    [] CoerceUnsizedInfo(DefId),\n-\n-    [] ItemVarianceConstraints(DefId),\n-    [] ItemVariances(DefId),\n-    [] IsConstFn(DefId),\n-    [] IsPromotableConstFn(DefId),\n-    [] IsForeignItem(DefId),\n-    [] TypeParamPredicates { item_id: DefId, param_id: DefId },\n-    [] SizedConstraint(DefId),\n-    [] DtorckConstraint(DefId),\n-    [] AdtDestructor(DefId),\n-    [] AssociatedItemDefIds(DefId),\n-    [eval_always] InherentImpls(DefId),\n-    [] TypeckBodiesKrate,\n-    [] TypeckTables(DefId),\n-    [] UsedTraitImports(DefId),\n-    [] HasTypeckTables(DefId),\n-    [] ConstEval { param_env: ParamEnvAnd<'tcx, GlobalId<'tcx>> },\n-    [] ConstEvalRaw { param_env: ParamEnvAnd<'tcx, GlobalId<'tcx>> },\n-    [] CheckMatch(DefId),\n-    [] SymbolName { instance: Instance<'tcx> },\n-    [] SpecializationGraph(DefId),\n-    [] ObjectSafety(DefId),\n-    [] FulfillObligation { param_env: ParamEnv<'tcx>, trait_ref: PolyTraitRef<'tcx> },\n-    [] VtableMethods { trait_ref: PolyTraitRef<'tcx> },\n-\n-    [] IsCopy { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n-    [] IsSized { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n-    [] IsFreeze { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n-    [] NeedsDrop { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n-    [] Layout { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n-\n-    // The set of impls for a given trait.\n-    [] TraitImpls(DefId),\n-\n     [eval_always] AllLocalTraitImpls,\n \n     [anon] TraitSelect,\n \n-    [] ParamEnv(DefId),\n-    [] DescribeDef(DefId),\n-\n-    // FIXME(mw): DefSpans are not really inputs since they are derived from\n-    // HIR. But at the moment HIR hashing still contains some hacks that allow\n-    // to make type debuginfo to be source location independent. Declaring\n-    // DefSpan an input makes sure that changes to these are always detected\n-    // regardless of HIR hashing.\n-    [eval_always] DefSpan(DefId),\n-    [] LookupStability(DefId),\n-    [] LookupDeprecationEntry(DefId),\n-    [] ConstIsRvaluePromotableToStatic(DefId),\n-    [] RvaluePromotableMap(DefId),\n-    [] ImplParent(DefId),\n-    [] TraitOfItem(DefId),\n-    [] IsReachableNonGeneric(DefId),\n-    [] IsUnreachableLocalDefinition(DefId),\n-    [] IsMirAvailable(DefId),\n-    [] ItemAttrs(DefId),\n-    [] CodegenFnAttrs(DefId),\n-    [] FnArgNames(DefId),\n-    [] RenderedConst(DefId),\n-    [] DylibDepFormats(CrateNum),\n-    [] IsCompilerBuiltins(CrateNum),\n-    [] HasGlobalAllocator(CrateNum),\n-    [] HasPanicHandler(CrateNum),\n-    [eval_always] ExternCrate(DefId),\n-    [] Specializes { impl1: DefId, impl2: DefId },\n-    [eval_always] InScopeTraits(DefIndex),\n-    [eval_always] ModuleExports(DefId),\n-    [] IsSanitizerRuntime(CrateNum),\n-    [] IsProfilerRuntime(CrateNum),\n-    [] GetPanicStrategy(CrateNum),\n-    [] IsNoBuiltins(CrateNum),\n-    [] ImplDefaultness(DefId),\n-    [] CheckItemWellFormed(DefId),\n-    [] CheckTraitItemWellFormed(DefId),\n-    [] CheckImplItemWellFormed(DefId),\n-    [] ReachableNonGenerics(CrateNum),\n-    [] EntryFn(CrateNum),\n-    [] PluginRegistrarFn(CrateNum),\n-    [] ProcMacroDeclsStatic(CrateNum),\n-    [eval_always] CrateDisambiguator(CrateNum),\n-    [eval_always] CrateHash(CrateNum),\n-    [eval_always] OriginalCrateName(CrateNum),\n-    [eval_always] ExtraFileName(CrateNum),\n-\n-    [] ImplementationsOfTrait { krate: CrateNum, trait_id: DefId },\n-    [] AllTraitImplementations(CrateNum),\n-\n-    [] DllimportForeignItems(CrateNum),\n-    [] IsDllimportForeignItem(DefId),\n-    [] IsStaticallyIncludedForeignItem(DefId),\n-    [] NativeLibraryKind(DefId),\n-    [eval_always] LinkArgs,\n-\n-    [] ResolveLifetimes(CrateNum),\n-    [] NamedRegion(DefIndex),\n-    [] IsLateBound(DefIndex),\n-    [] ObjectLifetimeDefaults(DefIndex),\n-\n-    [] Visibility(DefId),\n-    [eval_always] DepKind(CrateNum),\n-    [eval_always] CrateName(CrateNum),\n-    [] ItemChildren(DefId),\n-    [] ExternModStmtCnum(DefId),\n-    [eval_always] GetLibFeatures,\n-    [] DefinedLibFeatures(CrateNum),\n-    [eval_always] GetLangItems,\n-    [] DefinedLangItems(CrateNum),\n-    [] MissingLangItems(CrateNum),\n-    [] VisibleParentMap,\n-    [eval_always] MissingExternCrateItem(CrateNum),\n-    [eval_always] UsedCrateSource(CrateNum),\n-    [eval_always] PostorderCnums,\n-\n-    [eval_always] Freevars(DefId),\n-    [eval_always] MaybeUnusedTraitImport(DefId),\n-    [eval_always] MaybeUnusedExternCrates,\n-    [eval_always] NamesImportedByGlobUse(DefId),\n-    [eval_always] StabilityIndex,\n-    [eval_always] AllTraits,\n-    [eval_always] AllCrateNums,\n-    [] ExportedSymbols(CrateNum),\n-    [eval_always] CollectAndPartitionMonoItems,\n-    [] IsCodegenedItem(DefId),\n-    [] CodegenUnit(InternedString),\n-    [] BackendOptimizationLevel(CrateNum),\n     [] CompileCodegenUnit(InternedString),\n-    [eval_always] OutputFilenames,\n-    [] NormalizeProjectionTy(CanonicalProjectionGoal<'tcx>),\n-    [] NormalizeTyAfterErasingRegions(ParamEnvAnd<'tcx, Ty<'tcx>>),\n-    [] ImpliedOutlivesBounds(CanonicalTyGoal<'tcx>),\n-    [] DropckOutlives(CanonicalTyGoal<'tcx>),\n-    [] EvaluateObligation(CanonicalPredicateGoal<'tcx>),\n-    [] EvaluateGoal(traits::ChalkCanonicalGoal<'tcx>),\n-    [] TypeOpAscribeUserType(CanonicalTypeOpAscribeUserTypeGoal<'tcx>),\n-    [] TypeOpEq(CanonicalTypeOpEqGoal<'tcx>),\n-    [] TypeOpSubtype(CanonicalTypeOpSubtypeGoal<'tcx>),\n-    [] TypeOpProvePredicate(CanonicalTypeOpProvePredicateGoal<'tcx>),\n-    [] TypeOpNormalizeTy(CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>),\n-    [] TypeOpNormalizePredicate(CanonicalTypeOpNormalizeGoal<'tcx, Predicate<'tcx>>),\n-    [] TypeOpNormalizePolyFnSig(CanonicalTypeOpNormalizeGoal<'tcx, PolyFnSig<'tcx>>),\n-    [] TypeOpNormalizeFnSig(CanonicalTypeOpNormalizeGoal<'tcx, FnSig<'tcx>>),\n-\n-    [] SubstituteNormalizeAndTestPredicates { key: (DefId, SubstsRef<'tcx>) },\n-    [] MethodAutoderefSteps(CanonicalTyGoal<'tcx>),\n-\n-    [eval_always] TargetFeaturesWhitelist,\n-\n-    [] InstanceDefSizeEstimate { instance_def: InstanceDef<'tcx> },\n-\n-    [eval_always] Features,\n-\n-    [] ForeignModules(CrateNum),\n-\n-    [] UpstreamMonomorphizations(CrateNum),\n-    [] UpstreamMonomorphizationsFor(DefId),\n+\n+    [eval_always] Analysis(CrateNum),\n ]);\n \n pub trait RecoverKey<'tcx>: Sized {\n@@ -655,6 +456,12 @@ impl RecoverKey<'tcx> for DefId {\n     }\n }\n \n+impl RecoverKey<'tcx> for DefIndex {\n+    fn recover(tcx: TyCtxt<'_, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx).map(|id| id.index)\n+    }\n+}\n+\n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n "}, {"sha": "8896f9f9728814e4b1ac4562e3fa0e438d3335b7", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 920, "deletions": 2, "changes": 922, "blob_url": "https://github.com/rust-lang/rust/blob/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=da60ffbe161a5c5715fc2666a0a09717ed670153", "patch": "@@ -1,10 +1,21 @@\n use crate::ty::query::QueryDescription;\n use crate::ty::query::queries;\n-use crate::ty::{self, Ty, TyCtxt};\n-use crate::hir::def_id::{DefId, CrateNum};\n+use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::subst::SubstsRef;\n use crate::dep_graph::SerializedDepNodeIndex;\n+use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n+use crate::mir::interpret::GlobalId;\n use crate::traits;\n+use crate::traits::query::{\n+    CanonicalPredicateGoal, CanonicalProjectionGoal,\n+    CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n+    CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n+    CanonicalTypeOpNormalizeGoal,\n+};\n+\n use std::borrow::Cow;\n+use syntax_pos::symbol::InternedString;\n+\n \n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n@@ -148,4 +159,911 @@ rustc_queries! {\n             desc { \"wasm import module map\" }\n         }\n     }\n+\n+    Other {\n+        /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n+        /// predicates (where-clauses) directly defined on it. This is\n+        /// equal to the `explicit_predicates_of` predicates plus the\n+        /// `inferred_outlives_of` predicates.\n+        query predicates_defined_on(_: DefId)\n+            -> Lrc<ty::GenericPredicates<'tcx>> {}\n+\n+        /// Returns the predicates written explicit by the user.\n+        query explicit_predicates_of(_: DefId)\n+            -> Lrc<ty::GenericPredicates<'tcx>> {}\n+\n+        /// Returns the inferred outlives predicates (e.g., for `struct\n+        /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n+        query inferred_outlives_of(_: DefId) -> Lrc<Vec<ty::Predicate<'tcx>>> {}\n+\n+        /// Maps from the `DefId` of a trait to the list of\n+        /// super-predicates. This is a subset of the full list of\n+        /// predicates. We store these in a separate map because we must\n+        /// evaluate them even during type conversion, often before the\n+        /// full predicates are available (note that supertraits have\n+        /// additional acyclicity requirements).\n+        query super_predicates_of(key: DefId) -> Lrc<ty::GenericPredicates<'tcx>> {\n+            desc { |tcx| \"computing the supertraits of `{}`\", tcx.def_path_str(key) }\n+        }\n+\n+        /// To avoid cycles within the predicates of a single item we compute\n+        /// per-type-parameter predicates for resolving `T::AssocTy`.\n+        query type_param_predicates(key: (DefId, DefId))\n+            -> Lrc<ty::GenericPredicates<'tcx>> {\n+            no_force\n+            desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n+                let id = tcx.hir().as_local_hir_id(key.1).unwrap();\n+                tcx.hir().ty_param_name(id)\n+            }}\n+        }\n+\n+        query trait_def(_: DefId) -> &'tcx ty::TraitDef {}\n+        query adt_def(_: DefId) -> &'tcx ty::AdtDef {}\n+        query adt_destructor(_: DefId) -> Option<ty::Destructor> {}\n+\n+        // The cycle error here should be reported as an error by `check_representable`.\n+        // We consider the type as Sized in the meanwhile to avoid\n+        // further errors (done in impl Value for AdtSizedConstraint).\n+        // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n+        // in case we accidentally otherwise don't emit an error.\n+        query adt_sized_constraint(\n+            _: DefId\n+        ) -> AdtSizedConstraint<'tcx> {\n+            cycle_delay_bug\n+        }\n+\n+        query adt_dtorck_constraint(\n+            _: DefId\n+        ) -> Result<DtorckConstraint<'tcx>, NoSolution> {}\n+\n+        /// True if this is a const fn, use the `is_const_fn` to know whether your crate actually\n+        /// sees it as const fn (e.g., the const-fn-ness might be unstable and you might not have\n+        /// the feature gate active)\n+        ///\n+        /// **Do not call this function manually.** It is only meant to cache the base data for the\n+        /// `is_const_fn` function.\n+        query is_const_fn_raw(key: DefId) -> bool {\n+            desc { |tcx| \"checking if item is const fn: `{}`\", tcx.def_path_str(key) }\n+        }\n+\n+        /// Returns true if calls to the function may be promoted\n+        ///\n+        /// This is either because the function is e.g., a tuple-struct or tuple-variant\n+        /// constructor, or because it has the `#[rustc_promotable]` attribute. The attribute should\n+        /// be removed in the future in favour of some form of check which figures out whether the\n+        /// function does not inspect the bits of any of its arguments (so is essentially just a\n+        /// constructor function).\n+        query is_promotable_const_fn(_: DefId) -> bool {}\n+\n+        /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n+        query is_foreign_item(_: DefId) -> bool {}\n+\n+        /// Get a map with the variance of every item; use `item_variance`\n+        /// instead.\n+        query crate_variances(_: CrateNum) -> Lrc<ty::CrateVariancesMap> {\n+            desc { \"computing the variances for items in this crate\" }\n+        }\n+\n+        /// Maps from def-id of a type or region parameter to its\n+        /// (inferred) variance.\n+        query variances_of(_: DefId) -> Lrc<Vec<ty::Variance>> {}\n+    }\n+\n+    TypeChecking {\n+        /// Maps from def-id of a type to its (inferred) outlives.\n+        query inferred_outlives_crate(_: CrateNum)\n+            -> Lrc<ty::CratePredicatesMap<'tcx>> {\n+            desc { \"computing the inferred outlives predicates for items in this crate\" }\n+        }\n+    }\n+\n+    Other {\n+        /// Maps from an impl/trait def-id to a list of the def-ids of its items\n+        query associated_item_def_ids(_: DefId) -> Lrc<Vec<DefId>> {}\n+\n+        /// Maps from a trait item to the trait item \"descriptor\"\n+        query associated_item(_: DefId) -> ty::AssociatedItem {}\n+\n+        query impl_trait_ref(_: DefId) -> Option<ty::TraitRef<'tcx>> {}\n+        query impl_polarity(_: DefId) -> hir::ImplPolarity {}\n+\n+        query issue33140_self_ty(_: DefId) -> Option<ty::Ty<'tcx>> {}\n+    }\n+\n+    TypeChecking {\n+        /// Maps a DefId of a type to a list of its inherent impls.\n+        /// Contains implementations of methods that are inherent to a type.\n+        /// Methods in these implementations don't need to be exported.\n+        query inherent_impls(_: DefId) -> Lrc<Vec<DefId>> {\n+            eval_always\n+        }\n+    }\n+\n+    TypeChecking {\n+        /// The result of unsafety-checking this `DefId`.\n+        query unsafety_check_result(_: DefId) -> mir::UnsafetyCheckResult {}\n+\n+        /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n+        query unsafe_derive_on_repr_packed(_: DefId) -> () {}\n+\n+        /// The signature of functions and closures.\n+        query fn_sig(_: DefId) -> ty::PolyFnSig<'tcx> {}\n+    }\n+\n+    Other {\n+        query lint_mod(key: DefId) -> () {\n+            desc { |tcx| \"linting {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        /// Checks the attributes in the module\n+        query check_mod_attrs(key: DefId) -> () {\n+            desc { |tcx| \"checking attributes in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_unstable_api_usage(key: DefId) -> () {\n+            desc { |tcx| \"checking for unstable API usage in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        /// Checks the loops in the module\n+        query check_mod_loops(key: DefId) -> () {\n+            desc { |tcx| \"checking loops in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_item_types(key: DefId) -> () {\n+            desc { |tcx| \"checking item types in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_privacy(key: DefId) -> () {\n+            desc { |tcx| \"checking privacy in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_intrinsics(key: DefId) -> () {\n+            desc { |tcx| \"checking intrinsics in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_liveness(key: DefId) -> () {\n+            desc { |tcx| \"checking liveness of variables in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query check_mod_impl_wf(key: DefId) -> () {\n+            desc { |tcx| \"checking that impls are well-formed in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        query collect_mod_item_types(key: DefId) -> () {\n+            desc { |tcx| \"collecting item types in {}\", key.describe_as_module(tcx) }\n+        }\n+\n+        /// Caches CoerceUnsized kinds for impls on custom types.\n+        query coerce_unsized_info(_: DefId)\n+            -> ty::adjustment::CoerceUnsizedInfo {}\n+    }\n+\n+    TypeChecking {\n+        query typeck_item_bodies(_: CrateNum) -> () {\n+            desc { \"type-checking all item bodies\" }\n+        }\n+\n+        query typeck_tables_of(key: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n+            cache { key.is_local() }\n+            load_cached(tcx, id) {\n+                let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n+                    .queries.on_disk_cache\n+                    .try_load_query_result(tcx, id);\n+\n+                typeck_tables.map(|tables| tcx.alloc_tables(tables))\n+            }\n+        }\n+    }\n+\n+    Other {\n+        query used_trait_imports(_: DefId) -> Lrc<DefIdSet> {}\n+    }\n+\n+    TypeChecking {\n+        query has_typeck_tables(_: DefId) -> bool {}\n+\n+        query coherent_trait(def_id: DefId) -> () {\n+            no_force\n+            desc { |tcx| \"coherence checking all impls of trait `{}`\", tcx.def_path_str(def_id) }\n+        }\n+    }\n+\n+    BorrowChecking {\n+        query borrowck(_: DefId) -> Lrc<BorrowCheckResult> {}\n+\n+        /// Borrow checks the function body. If this is a closure, returns\n+        /// additional requirements that the closure's creator must verify.\n+        query mir_borrowck(_: DefId) -> mir::BorrowCheckResult<'tcx> {}\n+    }\n+\n+    TypeChecking {\n+        /// Gets a complete map from all types to their inherent impls.\n+        /// Not meant to be used directly outside of coherence.\n+        /// (Defined only for `LOCAL_CRATE`.)\n+        query crate_inherent_impls(k: CrateNum)\n+            -> Lrc<CrateInherentImpls> {\n+            eval_always\n+            desc { \"all inherent impls defined in crate `{:?}`\", k }\n+        }\n+\n+        /// Checks all types in the crate for overlap in their inherent impls. Reports errors.\n+        /// Not meant to be used directly outside of coherence.\n+        /// (Defined only for `LOCAL_CRATE`.)\n+        query crate_inherent_impls_overlap_check(_: CrateNum)\n+            -> () {\n+            eval_always\n+            desc { \"check for overlap between inherent impls defined in this crate\" }\n+        }\n+    }\n+\n+    Other {\n+        /// Evaluate a constant without running sanity checks\n+        ///\n+        /// **Do not use this** outside const eval. Const eval uses this to break query cycles\n+        /// during validation. Please add a comment to every use site explaining why using\n+        /// `const_eval` isn't sufficient\n+        query const_eval_raw(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n+            -> ConstEvalRawResult<'tcx> {\n+            no_force\n+            desc { |tcx|\n+                \"const-evaluating `{}`\",\n+                tcx.def_path_str(key.value.instance.def.def_id())\n+            }\n+            cache { true }\n+            load_cached(tcx, id) {\n+                tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n+            }\n+        }\n+\n+        /// Results of evaluating const items or constants embedded in\n+        /// other items (such as enum variant explicit discriminants).\n+        query const_eval(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n+            -> ConstEvalResult<'tcx> {\n+            no_force\n+            desc { |tcx|\n+                \"const-evaluating + checking `{}`\",\n+                tcx.def_path_str(key.value.instance.def.def_id())\n+            }\n+            cache { true }\n+            load_cached(tcx, id) {\n+                tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n+            }\n+        }\n+    }\n+\n+    TypeChecking {\n+        query check_match(_: DefId) -> () {}\n+\n+        /// Performs part of the privacy check and computes \"access levels\".\n+        query privacy_access_levels(_: CrateNum) -> Lrc<AccessLevels> {\n+            eval_always\n+            desc { \"privacy access levels\" }\n+        }\n+        query check_private_in_public(_: CrateNum) -> () {\n+            eval_always\n+            desc { \"checking for private elements in public interfaces\" }\n+        }\n+    }\n+\n+    Other {\n+        query reachable_set(_: CrateNum) -> ReachableSet {\n+            desc { \"reachability\" }\n+        }\n+\n+        /// Per-body `region::ScopeTree`. The `DefId` should be the owner `DefId` for the body;\n+        /// in the case of closures, this will be redirected to the enclosing function.\n+        query region_scope_tree(_: DefId) -> Lrc<region::ScopeTree> {}\n+\n+        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx> {\n+            no_force\n+            desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n+        }\n+\n+        query symbol_name(key: ty::Instance<'tcx>) -> ty::SymbolName {\n+            no_force\n+            desc { \"computing the symbol for `{}`\", key }\n+            cache { true }\n+        }\n+\n+        query describe_def(_: DefId) -> Option<Def> {}\n+        query def_span(_: DefId) -> Span {\n+            // FIXME(mw): DefSpans are not really inputs since they are derived from\n+            // HIR. But at the moment HIR hashing still contains some hacks that allow\n+            // to make type debuginfo to be source location independent. Declaring\n+            // DefSpan an input makes sure that changes to these are always detected\n+            // regardless of HIR hashing.\n+            eval_always\n+        }\n+        query lookup_stability(_: DefId) -> Option<&'tcx attr::Stability> {}\n+        query lookup_deprecation_entry(_: DefId) -> Option<DeprecationEntry> {}\n+        query item_attrs(_: DefId) -> Lrc<[ast::Attribute]> {}\n+    }\n+\n+    Codegen {\n+        query codegen_fn_attrs(_: DefId) -> CodegenFnAttrs {}\n+    }\n+\n+    Other {\n+        query fn_arg_names(_: DefId) -> Vec<ast::Name> {}\n+        /// Gets the rendered value of the specified constant or associated constant.\n+        /// Used by rustdoc.\n+        query rendered_const(_: DefId) -> String {}\n+        query impl_parent(_: DefId) -> Option<DefId> {}\n+    }\n+\n+    TypeChecking {\n+        query trait_of_item(_: DefId) -> Option<DefId> {}\n+        query const_is_rvalue_promotable_to_static(key: DefId) -> bool {\n+            desc { |tcx|\n+                \"const checking if rvalue is promotable to static `{}`\",\n+                tcx.def_path_str(key)\n+            }\n+            cache { true }\n+        }\n+        query rvalue_promotable_map(key: DefId) -> Lrc<ItemLocalSet> {\n+            desc { |tcx|\n+                \"checking which parts of `{}` are promotable to static\",\n+                tcx.def_path_str(key)\n+            }\n+        }\n+    }\n+\n+    Codegen {\n+        query is_mir_available(key: DefId) -> bool {\n+            desc { |tcx| \"checking if item has mir available: `{}`\", tcx.def_path_str(key) }\n+        }\n+    }\n+\n+    Other {\n+        query vtable_methods(key: ty::PolyTraitRef<'tcx>)\n+                            -> Lrc<Vec<Option<(DefId, SubstsRef<'tcx>)>>> {\n+            no_force\n+            desc { |tcx| \"finding all methods for trait {}\", tcx.def_path_str(key.def_id()) }\n+        }\n+    }\n+\n+    Codegen {\n+        query codegen_fulfill_obligation(\n+            key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n+        ) -> Vtable<'tcx, ()> {\n+            no_force\n+            cache { true }\n+            desc { |tcx|\n+                \"checking if `{}` fulfills its obligations\",\n+                tcx.def_path_str(key.1.def_id())\n+            }\n+        }\n+    }\n+\n+    TypeChecking {\n+        query trait_impls_of(key: DefId) -> Lrc<ty::trait_def::TraitImpls> {\n+            desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(key) }\n+        }\n+        query specialization_graph_of(_: DefId)\n+            -> Lrc<specialization_graph::Graph> {}\n+        query is_object_safe(key: DefId) -> bool {\n+            desc { |tcx| \"determine object safety of trait `{}`\", tcx.def_path_str(key) }\n+        }\n+\n+        /// Gets the ParameterEnvironment for a given item; this environment\n+        /// will be in \"user-facing\" mode, meaning that it is suitabe for\n+        /// type-checking etc, and it does not normalize specializable\n+        /// associated types. This is almost always what you want,\n+        /// unless you are doing MIR optimizations, in which case you\n+        /// might want to use `reveal_all()` method to change modes.\n+        query param_env(_: DefId) -> ty::ParamEnv<'tcx> {}\n+\n+        /// Trait selection queries. These are best used by invoking `ty.is_copy_modulo_regions()`,\n+        /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n+        query is_copy_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+            no_force\n+            desc { \"computing whether `{}` is `Copy`\", env.value }\n+        }\n+        query is_sized_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+            no_force\n+            desc { \"computing whether `{}` is `Sized`\", env.value }\n+        }\n+        query is_freeze_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+            no_force\n+            desc { \"computing whether `{}` is freeze\", env.value }\n+        }\n+\n+        // The cycle error here should be reported as an error by `check_representable`.\n+        // We consider the type as not needing drop in the meanwhile to avoid\n+        // further errors (done in impl Value for NeedsDrop).\n+        // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n+        // in case we accidentally otherwise don't emit an error.\n+        query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n+            cycle_delay_bug\n+            no_force\n+            desc { \"computing whether `{}` needs drop\", env.value }\n+        }\n+\n+        query layout_raw(\n+            env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n+        ) -> Result<&'tcx ty::layout::LayoutDetails, ty::layout::LayoutError<'tcx>> {\n+            no_force\n+            desc { \"computing layout of `{}`\", env.value }\n+        }\n+    }\n+\n+    Other {\n+        query dylib_dependency_formats(_: CrateNum)\n+                                        -> Lrc<Vec<(CrateNum, LinkagePreference)>> {\n+            desc { \"dylib dependency formats of crate\" }\n+        }\n+    }\n+\n+    Codegen {\n+        query is_compiler_builtins(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"checking if the crate is_compiler_builtins\" }\n+        }\n+        query has_global_allocator(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"checking if the crate has_global_allocator\" }\n+        }\n+        query has_panic_handler(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"checking if the crate has_panic_handler\" }\n+        }\n+        query is_sanitizer_runtime(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"query a crate is #![sanitizer_runtime]\" }\n+        }\n+        query is_profiler_runtime(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"query a crate is #![profiler_runtime]\" }\n+        }\n+        query panic_strategy(_: CrateNum) -> PanicStrategy {\n+            fatal_cycle\n+            desc { \"query a crate's configured panic strategy\" }\n+        }\n+        query is_no_builtins(_: CrateNum) -> bool {\n+            fatal_cycle\n+            desc { \"test whether a crate has #![no_builtins]\" }\n+        }\n+\n+        query extern_crate(_: DefId) -> Lrc<Option<ExternCrate>> {\n+            eval_always\n+            desc { \"getting crate's ExternCrateData\" }\n+        }\n+    }\n+\n+    TypeChecking {\n+        query specializes(_: (DefId, DefId)) -> bool {\n+            no_force\n+            desc { \"computing whether impls specialize one another\" }\n+        }\n+        query in_scope_traits_map(_: DefIndex)\n+            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<StableVec<TraitCandidate>>>>> {\n+            eval_always\n+            desc { \"traits in scope at a block\" }\n+        }\n+    }\n+\n+    Other {\n+        query module_exports(_: DefId) -> Option<Lrc<Vec<Export>>> {\n+            eval_always\n+        }\n+    }\n+\n+    TypeChecking {\n+        query impl_defaultness(_: DefId) -> hir::Defaultness {}\n+\n+        query check_item_well_formed(_: DefId) -> () {}\n+        query check_trait_item_well_formed(_: DefId) -> () {}\n+        query check_impl_item_well_formed(_: DefId) -> () {}\n+    }\n+\n+    Linking {\n+        // The DefIds of all non-generic functions and statics in the given crate\n+        // that can be reached from outside the crate.\n+        //\n+        // We expect this items to be available for being linked to.\n+        //\n+        // This query can also be called for LOCAL_CRATE. In this case it will\n+        // compute which items will be reachable to other crates, taking into account\n+        // the kind of crate that is currently compiled. Crates with only a\n+        // C interface have fewer reachable things.\n+        //\n+        // Does not include external symbols that don't have a corresponding DefId,\n+        // like the compiler-generated `main` function and so on.\n+        query reachable_non_generics(_: CrateNum)\n+            -> Lrc<DefIdMap<SymbolExportLevel>> {\n+            desc { \"looking up the exported symbols of a crate\" }\n+        }\n+        query is_reachable_non_generic(_: DefId) -> bool {}\n+        query is_unreachable_local_definition(_: DefId) -> bool {}\n+    }\n+\n+    Codegen {\n+        query upstream_monomorphizations(\n+            k: CrateNum\n+        ) -> Lrc<DefIdMap<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>>> {\n+            desc { \"collecting available upstream monomorphizations `{:?}`\", k }\n+        }\n+        query upstream_monomorphizations_for(_: DefId)\n+            -> Option<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>> {}\n+    }\n+\n+    Other {\n+        query foreign_modules(_: CrateNum) -> Lrc<Vec<ForeignModule>> {\n+            desc { \"looking up the foreign modules of a linked crate\" }\n+        }\n+\n+        /// Identifies the entry-point (e.g., the `main` function) for a given\n+        /// crate, returning `None` if there is no entry point (such as for library crates).\n+        query entry_fn(_: CrateNum) -> Option<(DefId, EntryFnType)> {\n+            desc { \"looking up the entry function of a crate\" }\n+        }\n+        query plugin_registrar_fn(_: CrateNum) -> Option<DefId> {\n+            desc { \"looking up the plugin registrar for a crate\" }\n+        }\n+        query proc_macro_decls_static(_: CrateNum) -> Option<DefId> {\n+            desc { \"looking up the derive registrar for a crate\" }\n+        }\n+        query crate_disambiguator(_: CrateNum) -> CrateDisambiguator {\n+            eval_always\n+            desc { \"looking up the disambiguator a crate\" }\n+        }\n+        query crate_hash(_: CrateNum) -> Svh {\n+            eval_always\n+            desc { \"looking up the hash a crate\" }\n+        }\n+        query original_crate_name(_: CrateNum) -> Symbol {\n+            eval_always\n+            desc { \"looking up the original name a crate\" }\n+        }\n+        query extra_filename(_: CrateNum) -> String {\n+            eval_always\n+            desc { \"looking up the extra filename for a crate\" }\n+        }\n+    }\n+\n+    TypeChecking {\n+        query implementations_of_trait(_: (CrateNum, DefId))\n+            -> Lrc<Vec<DefId>> {\n+            no_force\n+            desc { \"looking up implementations of a trait in a crate\" }\n+        }\n+        query all_trait_implementations(_: CrateNum)\n+            -> Lrc<Vec<DefId>> {\n+            desc { \"looking up all (?) trait implementations\" }\n+        }\n+    }\n+\n+    Other {\n+        query dllimport_foreign_items(_: CrateNum)\n+            -> Lrc<FxHashSet<DefId>> {\n+            desc { \"dllimport_foreign_items\" }\n+        }\n+        query is_dllimport_foreign_item(_: DefId) -> bool {}\n+        query is_statically_included_foreign_item(_: DefId) -> bool {}\n+        query native_library_kind(_: DefId)\n+            -> Option<NativeLibraryKind> {}\n+    }\n+\n+    Linking {\n+        query link_args(_: CrateNum) -> Lrc<Vec<String>> {\n+            eval_always\n+            desc { \"looking up link arguments for a crate\" }\n+        }\n+    }\n+\n+    BorrowChecking {\n+        // Lifetime resolution. See `middle::resolve_lifetimes`.\n+        query resolve_lifetimes(_: CrateNum) -> Lrc<ResolveLifetimes> {\n+            desc { \"resolving lifetimes\" }\n+        }\n+        query named_region_map(_: DefIndex) ->\n+            Option<Lrc<FxHashMap<ItemLocalId, Region>>> {\n+            desc { \"looking up a named region\" }\n+        }\n+        query is_late_bound_map(_: DefIndex) ->\n+            Option<Lrc<FxHashSet<ItemLocalId>>> {\n+            desc { \"testing if a region is late bound\" }\n+        }\n+        query object_lifetime_defaults_map(_: DefIndex)\n+            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>> {\n+            desc { \"looking up lifetime defaults for a region\" }\n+        }\n+    }\n+\n+    TypeChecking {\n+        query visibility(_: DefId) -> ty::Visibility {}\n+    }\n+\n+    Other {\n+        query dep_kind(_: CrateNum) -> DepKind {\n+            eval_always\n+            desc { \"fetching what a dependency looks like\" }\n+        }\n+        query crate_name(_: CrateNum) -> Symbol {\n+            eval_always\n+            desc { \"fetching what a crate is named\" }\n+        }\n+        query item_children(_: DefId) -> Lrc<Vec<Export>> {}\n+        query extern_mod_stmt_cnum(_: DefId) -> Option<CrateNum> {}\n+\n+        query get_lib_features(_: CrateNum) -> Lrc<LibFeatures> {\n+            eval_always\n+            desc { \"calculating the lib features map\" }\n+        }\n+        query defined_lib_features(_: CrateNum)\n+            -> Lrc<Vec<(Symbol, Option<Symbol>)>> {\n+            desc { \"calculating the lib features defined in a crate\" }\n+        }\n+        query get_lang_items(_: CrateNum) -> Lrc<LanguageItems> {\n+            eval_always\n+            desc { \"calculating the lang items map\" }\n+        }\n+        query defined_lang_items(_: CrateNum) -> Lrc<Vec<(DefId, usize)>> {\n+            desc { \"calculating the lang items defined in a crate\" }\n+        }\n+        query missing_lang_items(_: CrateNum) -> Lrc<Vec<LangItem>> {\n+            desc { \"calculating the missing lang items in a crate\" }\n+        }\n+        query visible_parent_map(_: CrateNum)\n+            -> Lrc<DefIdMap<DefId>> {\n+            desc { \"calculating the visible parent map\" }\n+        }\n+        query missing_extern_crate_item(_: CrateNum) -> bool {\n+            eval_always\n+            desc { \"seeing if we're missing an `extern crate` item for this crate\" }\n+        }\n+        query used_crate_source(_: CrateNum) -> Lrc<CrateSource> {\n+            eval_always\n+            desc { \"looking at the source for a crate\" }\n+        }\n+        query postorder_cnums(_: CrateNum) -> Lrc<Vec<CrateNum>> {\n+            eval_always\n+            desc { \"generating a postorder list of CrateNums\" }\n+        }\n+\n+        query freevars(_: DefId) -> Option<Lrc<Vec<hir::Freevar>>> {\n+            eval_always\n+        }\n+        query maybe_unused_trait_import(_: DefId) -> bool {\n+            eval_always\n+        }\n+        query maybe_unused_extern_crates(_: CrateNum)\n+            -> Lrc<Vec<(DefId, Span)>> {\n+            eval_always\n+            desc { \"looking up all possibly unused extern crates\" }\n+        }\n+        query names_imported_by_glob_use(_: DefId)\n+            -> Lrc<FxHashSet<ast::Name>> {\n+            eval_always\n+        }\n+\n+        query stability_index(_: CrateNum) -> Lrc<stability::Index<'tcx>> {\n+            eval_always\n+            desc { \"calculating the stability index for the local crate\" }\n+        }\n+        query all_crate_nums(_: CrateNum) -> Lrc<Vec<CrateNum>> {\n+            eval_always\n+            desc { \"fetching all foreign CrateNum instances\" }\n+        }\n+\n+        /// A vector of every trait accessible in the whole crate\n+        /// (i.e., including those from subcrates). This is used only for\n+        /// error reporting.\n+        query all_traits(_: CrateNum) -> Lrc<Vec<DefId>> {\n+            desc { \"fetching all foreign and local traits\" }\n+        }\n+    }\n+\n+    Linking {\n+        query exported_symbols(_: CrateNum)\n+            -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>> {\n+            desc { \"exported_symbols\" }\n+        }\n+    }\n+\n+    Codegen {\n+        query collect_and_partition_mono_items(_: CrateNum)\n+            -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>) {\n+            eval_always\n+            desc { \"collect_and_partition_mono_items\" }\n+        }\n+        query is_codegened_item(_: DefId) -> bool {}\n+        query codegen_unit(_: InternedString) -> Arc<CodegenUnit<'tcx>> {\n+            no_force\n+            desc { \"codegen_unit\" }\n+        }\n+        query backend_optimization_level(_: CrateNum) -> OptLevel {\n+            desc { \"optimization level used by backend\" }\n+        }\n+    }\n+\n+    Other {\n+        query output_filenames(_: CrateNum) -> Arc<OutputFilenames> {\n+            eval_always\n+            desc { \"output_filenames\" }\n+        }\n+    }\n+\n+    TypeChecking {\n+        /// Do not call this query directly: invoke `normalize` instead.\n+        query normalize_projection_ty(\n+            goal: CanonicalProjectionGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n+        query normalize_ty_after_erasing_regions(\n+            goal: ParamEnvAnd<'tcx, Ty<'tcx>>\n+        ) -> Ty<'tcx> {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        query implied_outlives_bounds(\n+            goal: CanonicalTyGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"computing implied outlives bounds for `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: invoke `infcx.at().dropck_outlives()` instead.\n+        query dropck_outlives(\n+            goal: CanonicalTyGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"computing dropck types for `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: invoke `infcx.predicate_may_hold()` or\n+        /// `infcx.predicate_must_hold()` instead.\n+        query evaluate_obligation(\n+            goal: CanonicalPredicateGoal<'tcx>\n+        ) -> Result<traits::EvaluationResult, traits::OverflowError> {\n+            no_force\n+            desc { \"evaluating trait selection obligation `{}`\", goal.value.value }\n+        }\n+\n+        query evaluate_goal(\n+            goal: traits::ChalkCanonicalGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution\n+        > {\n+            no_force\n+            desc { \"evaluating trait selection obligation `{}`\", goal.value.goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Eq` type-op\n+        query type_op_ascribe_user_type(\n+            goal: CanonicalTypeOpAscribeUserTypeGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"evaluating `type_op_ascribe_user_type` `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Eq` type-op\n+        query type_op_eq(\n+            goal: CanonicalTypeOpEqGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"evaluating `type_op_eq` `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Subtype` type-op\n+        query type_op_subtype(\n+            goal: CanonicalTypeOpSubtypeGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"evaluating `type_op_subtype` `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `ProvePredicate` type-op\n+        query type_op_prove_predicate(\n+            goal: CanonicalTypeOpProvePredicateGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"evaluating `type_op_prove_predicate` `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        query type_op_normalize_ty(\n+            goal: CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, Ty<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        query type_op_normalize_predicate(\n+            goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::Predicate<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        query type_op_normalize_poly_fn_sig(\n+            goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::PolyFnSig<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        query type_op_normalize_fn_sig(\n+            goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::FnSig<'tcx>>>>,\n+            NoSolution,\n+        > {\n+            no_force\n+            desc { \"normalizing `{:?}`\", goal }\n+        }\n+\n+        query substitute_normalize_and_test_predicates(key: (DefId, SubstsRef<'tcx>)) -> bool {\n+            no_force\n+            desc { |tcx|\n+                \"testing substituted normalized predicates:`{}`\",\n+                tcx.def_path_str(key.0)\n+            }\n+        }\n+\n+        query method_autoderef_steps(\n+            goal: CanonicalTyGoal<'tcx>\n+        ) -> MethodAutoderefStepsResult<'tcx> {\n+            no_force\n+            desc { \"computing autoderef types for `{:?}`\", goal }\n+        }\n+    }\n+\n+    Other {\n+        query target_features_whitelist(_: CrateNum) -> Lrc<FxHashMap<String, Option<String>>> {\n+            eval_always\n+            desc { \"looking up the whitelist of target features\" }\n+        }\n+\n+        // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n+        query instance_def_size_estimate(def: ty::InstanceDef<'tcx>)\n+            -> usize {\n+            no_force\n+            desc { |tcx| \"estimating size for `{}`\", tcx.def_path_str(def.def_id()) }\n+        }\n+\n+        query features_query(_: CrateNum) -> Lrc<feature_gate::Features> {\n+            eval_always\n+            desc { \"looking up enabled feature gates\" }\n+        }\n+    }\n }"}, {"sha": "73b79027972427a4ad8dcd47f7b2a2b038807b90", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 842, "changes": 844, "blob_url": "https://github.com/rust-lang/rust/blob/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=da60ffbe161a5c5715fc2666a0a09717ed670153", "patch": "@@ -1,15 +1,7 @@\n use crate::dep_graph::SerializedDepNodeIndex;\n use crate::dep_graph::DepNode;\n-use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n-use crate::mir::interpret::GlobalId;\n-use crate::traits;\n-use crate::traits::query::{\n-    CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n-    CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n-    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n-};\n-use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n-use crate::ty::subst::SubstsRef;\n+use crate::hir::def_id::{CrateNum, DefId};\n+use crate::ty::TyCtxt;\n use crate::ty::query::queries;\n use crate::ty::query::Query;\n use crate::ty::query::QueryCache;\n@@ -19,7 +11,6 @@ use crate::util::profiling::ProfileCategory;\n use std::borrow::Cow;\n use std::hash::Hash;\n use std::fmt::Debug;\n-use syntax_pos::symbol::InternedString;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::fingerprint::Fingerprint;\n use crate::ich::StableHashingContext;\n@@ -79,843 +70,12 @@ impl<'tcx, M: QueryAccessors<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_attrs<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking attributes in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_unstable_api_usage<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking for unstable API usage in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_loops<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking loops in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_item_types<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking item types in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_privacy<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking privacy in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_intrinsics<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking intrinsics in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_liveness<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking liveness of variables in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_mod_impl_wf<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"checking that impls are well-formed in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::collect_mod_item_types<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: DefId,\n-    ) -> Cow<'static, str> {\n-        format!(\"collecting item types in {}\", key.describe_as_module(tcx)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::normalize_projection_ty<'tcx> {\n-    fn describe(\n-        _tcx: TyCtxt<'_, '_, '_>,\n-        goal: CanonicalProjectionGoal<'tcx>,\n-    ) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::implied_outlives_bounds<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n-        format!(\"computing implied outlives bounds for `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::dropck_outlives<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n-        format!(\"computing dropck types for `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::normalize_ty_after_erasing_regions<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::evaluate_obligation<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalPredicateGoal<'tcx>) -> Cow<'static, str> {\n-        format!(\"evaluating trait selection obligation `{}`\", goal.value.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::evaluate_goal<'tcx> {\n-    fn describe(\n-        _tcx: TyCtxt<'_, '_, '_>,\n-        goal: traits::ChalkCanonicalGoal<'tcx>\n-    ) -> Cow<'static, str> {\n-        format!(\"evaluating trait selection obligation `{}`\", goal.value.goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_ascribe_user_type<'tcx> {\n-    fn describe(\n-        _tcx: TyCtxt<'_, '_, '_>,\n-        goal: CanonicalTypeOpAscribeUserTypeGoal<'tcx>,\n-    ) -> Cow<'static, str> {\n-        format!(\"evaluating `type_op_ascribe_user_type` `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_eq<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpEqGoal<'tcx>) -> Cow<'static, str> {\n-        format!(\"evaluating `type_op_eq` `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_subtype<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpSubtypeGoal<'tcx>)\n-                -> Cow<'static, str> {\n-        format!(\"evaluating `type_op_subtype` `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_prove_predicate<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpProvePredicateGoal<'tcx>)\n-                -> Cow<'static, str> {\n-        format!(\"evaluating `type_op_prove_predicate` `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_ty<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>,\n-                goal: CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_predicate<'tcx> {\n-    fn describe(\n-        _tcx: TyCtxt<'_, '_, '_>,\n-        goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_poly_fn_sig<'tcx> {\n-    fn describe(\n-        _tcx: TyCtxt<'_, '_, '_>,\n-        goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>,\n-    ) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_fn_sig<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>,\n-                goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>) -> Cow<'static, str> {\n-        format!(\"normalizing `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_copy_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                -> Cow<'static, str> {\n-        format!(\"computing whether `{}` is `Copy`\", env.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_sized_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                -> Cow<'static, str> {\n-        format!(\"computing whether `{}` is `Sized`\", env.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_freeze_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                -> Cow<'static, str> {\n-        format!(\"computing whether `{}` is freeze\", env.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::needs_drop_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                -> Cow<'static, str> {\n-        format!(\"computing whether `{}` needs drop\", env.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::layout_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                -> Cow<'static, str> {\n-        format!(\"computing layout of `{}`\", env.value).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::super_predicates_of<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"computing the supertraits of `{}`\",\n-                tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, (_, def_id): (DefId, DefId)) -> Cow<'static, str> {\n-        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-        format!(\"computing the bounds for type parameter `{}`\",\n-                tcx.hir().ty_param_name(id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::coherent_trait<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"coherence checking all impls of trait `{}`\",\n-                tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::upstream_monomorphizations<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> Cow<'static, str> {\n-        format!(\"collecting available upstream monomorphizations `{:?}`\", k).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_inherent_impls<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> Cow<'static, str> {\n-        format!(\"all inherent impls defined in crate `{:?}`\", k).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_inherent_impls_overlap_check<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"check for overlap between inherent impls defined in this crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_variances<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"computing the variances for items in this crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::inferred_outlives_crate<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"computing the inferred outlives predicates for items in this crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::mir_shims<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n-        format!(\"generating MIR shim for `{}`\",\n-                tcx.def_path_str(def.def_id())).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::privacy_access_levels<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"privacy access levels\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::check_private_in_public<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"checking for private elements in public interfaces\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::typeck_item_bodies<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"type-checking all item bodies\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::reachable_set<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"reachability\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::const_eval<'tcx> {\n-    fn describe(\n-        tcx: TyCtxt<'_, '_, '_>,\n-        key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-    ) -> Cow<'static, str> {\n-        format!(\n-            \"const-evaluating + checking `{}`\",\n-            tcx.def_path_str(key.value.instance.def.def_id()),\n-        ).into()\n-    }\n-\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _key: Self::Key) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: SerializedDepNodeIndex)\n-                              -> Option<Self::Value> {\n-        tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::const_eval_raw<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-        -> Cow<'static, str>\n-    {\n-        format!(\"const-evaluating `{}`\", tcx.def_path_str(key.value.instance.def.def_id())).into()\n-    }\n-\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _key: Self::Key) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: SerializedDepNodeIndex)\n-                              -> Option<Self::Value> {\n-        tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::symbol_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, instance: ty::Instance<'tcx>) -> Cow<'static, str> {\n-        format!(\"computing the symbol for `{}`\", instance).into()\n-    }\n-\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _: Self::Key) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: SerializedDepNodeIndex)\n-                              -> Option<Self::Value> {\n-        tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::describe_def<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"describe_def\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::def_span<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"def_span\")\n-    }\n-}\n-\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::lookup_stability<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"stability\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::lookup_deprecation_entry<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"deprecation\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::item_attrs<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"item_attrs\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_reachable_non_generic<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"is_reachable_non_generic\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::fn_arg_names<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"fn_arg_names\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::impl_parent<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"impl_parent\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::trait_of_item<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        bug!(\"trait_of_item\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_static<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"const checking if rvalue is promotable to static `{}`\",\n-            tcx.def_path_str(def_id)).into()\n-    }\n-\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _: Self::Key) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: SerializedDepNodeIndex)\n-                              -> Option<Self::Value> {\n-        tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::rvalue_promotable_map<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"checking which parts of `{}` are promotable to static\",\n-                tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_mir_available<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"checking if item is mir available: `{}`\",\n-                tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::codegen_fulfill_obligation<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>,\n-                key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Cow<'static, str> {\n-        format!(\"checking if `{}` fulfills its obligations\", tcx.def_path_str(key.1.def_id()))\n-            .into()\n-    }\n-\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _: Self::Key) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: SerializedDepNodeIndex)\n-                              -> Option<Self::Value> {\n-        tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::trait_impls_of<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"trait impls of `{}`\", tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_object_safe<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"determine object safety of trait `{}`\", tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_const_fn_raw<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n-        format!(\"checking if item is const fn: `{}`\", tcx.def_path_str(def_id)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::dylib_dependency_formats<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"dylib dependency formats of crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_compiler_builtins<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"checking if the crate is_compiler_builtins\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::has_global_allocator<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"checking if the crate has_global_allocator\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::has_panic_handler<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"checking if the crate has_panic_handler\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::extern_crate<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        \"getting crate's ExternCrateData\".into()\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n         \"running analysis passes on this crate\".into()\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::specializes<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (DefId, DefId)) -> Cow<'static, str> {\n-        \"computing whether impls specialize one another\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::in_scope_traits_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n-        \"traits in scope at a block\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_no_builtins<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"test whether a crate has #![no_builtins]\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::panic_strategy<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"query a crate's configured panic strategy\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_profiler_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"query a crate is #![profiler_runtime]\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_sanitizer_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"query a crate is #![sanitizer_runtime]\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::reachable_non_generics<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the exported symbols of a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::foreign_modules<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the foreign modules of a linked crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::entry_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the entry function of a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::plugin_registrar_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the plugin registrar for a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::proc_macro_decls_static<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the derive registrar for a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_disambiguator<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the disambiguator a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_hash<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the hash a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::original_crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the original name a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::extra_filename<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the extra filename for a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::implementations_of_trait<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (CrateNum, DefId)) -> Cow<'static, str> {\n-        \"looking up implementations of a trait in a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::all_trait_implementations<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up all (?) trait implementations\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::link_args<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up link arguments for a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::resolve_lifetimes<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"resolving lifetimes\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::named_region_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n-        \"looking up a named region\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::is_late_bound_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n-        \"testing if a region is late bound\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::object_lifetime_defaults_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n-        \"looking up lifetime defaults for a region\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::dep_kind<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"fetching what a dependency looks like\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"fetching what a crate is named\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::get_lib_features<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the lib features map\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::defined_lib_features<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the lib features defined in a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::get_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the lang items map\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::defined_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the lang items defined in a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::missing_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the missing lang items in a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::visible_parent_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the visible parent map\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::missing_extern_crate_item<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"seeing if we're missing an `extern crate` item for this crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::used_crate_source<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking at the source for a crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::postorder_cnums<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"generating a postorder list of CrateNums\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::maybe_unused_extern_crates<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up all possibly unused extern crates\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::stability_index<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"calculating the stability index for the local crate\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::all_traits<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"fetching all foreign and local traits\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::all_crate_nums<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"fetching all foreign CrateNum instances\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::exported_symbols<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"exported_symbols\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::collect_and_partition_mono_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"collect_and_partition_mono_items\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::codegen_unit<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: InternedString) -> Cow<'static, str> {\n-        \"codegen_unit\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::output_filenames<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"output_filenames\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::vtable_methods<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::PolyTraitRef<'tcx> ) -> Cow<'static, str> {\n-        format!(\"finding all methods for trait {}\", tcx.def_path_str(key.def_id())).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::features_query<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up enabled feature gates\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::typeck_tables_of<'tcx> {\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, def_id: Self::Key) -> bool {\n-        def_id.is_local()\n-    }\n-\n-    fn try_load_from_disk(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                          id: SerializedDepNodeIndex)\n-                          -> Option<Self::Value> {\n-        let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n-            .queries.on_disk_cache\n-            .try_load_query_result(tcx, id);\n-\n-        typeck_tables.map(|tables| tcx.alloc_tables(tables))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_predicates<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: (DefId, SubstsRef<'tcx>)) -> Cow<'static, str> {\n-        format!(\"testing substituted normalized predicates:`{}`\", tcx.def_path_str(key.0)).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::method_autoderef_steps<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n-        format!(\"computing autoderef types for `{:?}`\", goal).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::target_features_whitelist<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"looking up the whitelist of target features\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::instance_def_size_estimate<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n-        format!(\"estimating size for `{}`\", tcx.def_path_str(def.def_id())).into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::dllimport_foreign_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"dllimport_foreign_items\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::backend_optimization_level<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"optimization level used by backend\".into()\n-    }\n-}\n-\n macro_rules! impl_disk_cacheable_query(\n     ($query_name:ident, |$tcx:tt, $key:tt| $cond:expr) => {\n         impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {"}, {"sha": "c4bc35fff66b8ec11aac57b16440d8c1ff907b62", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 734, "changes": 735, "blob_url": "https://github.com/rust-lang/rust/blob/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=da60ffbe161a5c5715fc2666a0a09717ed670153", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{self, DepConstructor, DepNode};\n+use crate::dep_graph::{self, DepNode};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n use crate::hir::def::{Def, Export};\n use crate::hir::{self, TraitCandidate, ItemLocalId, CodegenFnAttrs};\n@@ -104,738 +104,5 @@ rustc_query_append! { [define_queries!][ <'tcx>\n         /// Run analysis passes on the crate\n         [] fn analysis: Analysis(CrateNum) -> Result<(), ErrorReported>,\n \n-        /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n-        /// predicates (where-clauses) directly defined on it. This is\n-        /// equal to the `explicit_predicates_of` predicates plus the\n-        /// `inferred_outlives_of` predicates.\n-        [] fn predicates_defined_on: PredicatesDefinedOnItem(DefId)\n-            -> Lrc<ty::GenericPredicates<'tcx>>,\n-\n-        /// Returns the predicates written explicit by the user.\n-        [] fn explicit_predicates_of: ExplicitPredicatesOfItem(DefId)\n-            -> Lrc<ty::GenericPredicates<'tcx>>,\n-\n-        /// Returns the inferred outlives predicates (e.g., for `struct\n-        /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n-        [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Lrc<Vec<ty::Predicate<'tcx>>>,\n-\n-        /// Maps from the `DefId` of a trait to the list of\n-        /// super-predicates. This is a subset of the full list of\n-        /// predicates. We store these in a separate map because we must\n-        /// evaluate them even during type conversion, often before the\n-        /// full predicates are available (note that supertraits have\n-        /// additional acyclicity requirements).\n-        [] fn super_predicates_of: SuperPredicatesOfItem(DefId) -> Lrc<ty::GenericPredicates<'tcx>>,\n-\n-        /// To avoid cycles within the predicates of a single item we compute\n-        /// per-type-parameter predicates for resolving `T::AssocTy`.\n-        [] fn type_param_predicates: type_param_predicates((DefId, DefId))\n-            -> Lrc<ty::GenericPredicates<'tcx>>,\n-\n-        [] fn trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n-        [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n-        [] fn adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n-\n-        // The cycle error here should be reported as an error by `check_representable`.\n-        // We consider the type as Sized in the meanwhile to avoid\n-        // further errors (done in impl Value for AdtSizedConstraint).\n-        // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n-        // in case we accidentally otherwise don't emit an error.\n-        [cycle_delay_bug] fn adt_sized_constraint: SizedConstraint(\n-            DefId\n-        ) -> AdtSizedConstraint<'tcx>,\n-\n-        [] fn adt_dtorck_constraint: DtorckConstraint(\n-            DefId\n-        ) -> Result<DtorckConstraint<'tcx>, NoSolution>,\n-\n-        /// True if this is a const fn, use the `is_const_fn` to know whether your crate actually\n-        /// sees it as const fn (e.g., the const-fn-ness might be unstable and you might not have\n-        /// the feature gate active)\n-        ///\n-        /// **Do not call this function manually.** It is only meant to cache the base data for the\n-        /// `is_const_fn` function.\n-        [] fn is_const_fn_raw: IsConstFn(DefId) -> bool,\n-\n-\n-        /// Returns true if calls to the function may be promoted\n-        ///\n-        /// This is either because the function is e.g., a tuple-struct or tuple-variant\n-        /// constructor, or because it has the `#[rustc_promotable]` attribute. The attribute should\n-        /// be removed in the future in favour of some form of check which figures out whether the\n-        /// function does not inspect the bits of any of its arguments (so is essentially just a\n-        /// constructor function).\n-        [] fn is_promotable_const_fn: IsPromotableConstFn(DefId) -> bool,\n-\n-        /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n-        [] fn is_foreign_item: IsForeignItem(DefId) -> bool,\n-\n-        /// Get a map with the variance of every item; use `item_variance`\n-        /// instead.\n-        [] fn crate_variances: crate_variances(CrateNum) -> Lrc<ty::CrateVariancesMap>,\n-\n-        /// Maps from def-id of a type or region parameter to its\n-        /// (inferred) variance.\n-        [] fn variances_of: ItemVariances(DefId) -> Lrc<Vec<ty::Variance>>,\n-    },\n-\n-    TypeChecking {\n-        /// Maps from def-id of a type to its (inferred) outlives.\n-        [] fn inferred_outlives_crate: InferredOutlivesCrate(CrateNum)\n-            -> Lrc<ty::CratePredicatesMap<'tcx>>,\n-    },\n-\n-    Other {\n-        /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-        [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Lrc<Vec<DefId>>,\n-\n-        /// Maps from a trait item to the trait item \"descriptor\"\n-        [] fn associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n-\n-        [] fn impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n-        [] fn impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n-\n-        [] fn issue33140_self_ty: Issue33140SelfTy(DefId) -> Option<ty::Ty<'tcx>>,\n-    },\n-\n-    TypeChecking {\n-        /// Maps a DefId of a type to a list of its inherent impls.\n-        /// Contains implementations of methods that are inherent to a type.\n-        /// Methods in these implementations don't need to be exported.\n-        [] fn inherent_impls: InherentImpls(DefId) -> Lrc<Vec<DefId>>,\n-    },\n-\n-    TypeChecking {\n-        /// The result of unsafety-checking this `DefId`.\n-        [] fn unsafety_check_result: UnsafetyCheckResult(DefId) -> mir::UnsafetyCheckResult,\n-\n-        /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n-        [] fn unsafe_derive_on_repr_packed: UnsafeDeriveOnReprPacked(DefId) -> (),\n-\n-        /// The signature of functions and closures.\n-        [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n-    },\n-\n-    Other {\n-        [] fn lint_mod: LintMod(DefId) -> (),\n-\n-        /// Checks the attributes in the module\n-        [] fn check_mod_attrs: CheckModAttrs(DefId) -> (),\n-\n-        [] fn check_mod_unstable_api_usage: CheckModUnstableApiUsage(DefId) -> (),\n-\n-        /// Checks the loops in the module\n-        [] fn check_mod_loops: CheckModLoops(DefId) -> (),\n-\n-        [] fn check_mod_item_types: CheckModItemTypes(DefId) -> (),\n-\n-        [] fn check_mod_privacy: CheckModPrivacy(DefId) -> (),\n-\n-        [] fn check_mod_intrinsics: CheckModIntrinsics(DefId) -> (),\n-\n-        [] fn check_mod_liveness: CheckModLiveness(DefId) -> (),\n-\n-        [] fn check_mod_impl_wf: CheckModImplWf(DefId) -> (),\n-\n-        [] fn collect_mod_item_types: CollectModItemTypes(DefId) -> (),\n-\n-        /// Caches CoerceUnsized kinds for impls on custom types.\n-        [] fn coerce_unsized_info: CoerceUnsizedInfo(DefId)\n-            -> ty::adjustment::CoerceUnsizedInfo,\n-    },\n-\n-    TypeChecking {\n-        [] fn typeck_item_bodies:\n-                typeck_item_bodies_dep_node(CrateNum) -> (),\n-\n-        [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n-    },\n-\n-    Other {\n-        [] fn used_trait_imports: UsedTraitImports(DefId) -> Lrc<DefIdSet>,\n-    },\n-\n-    TypeChecking {\n-        [] fn has_typeck_tables: HasTypeckTables(DefId) -> bool,\n-\n-        [] fn coherent_trait: CoherenceCheckTrait(DefId) -> (),\n-    },\n-\n-    BorrowChecking {\n-        [] fn borrowck: BorrowCheck(DefId) -> Lrc<BorrowCheckResult>,\n-\n-        /// Borrow checks the function body. If this is a closure, returns\n-        /// additional requirements that the closure's creator must verify.\n-        [] fn mir_borrowck: MirBorrowCheck(DefId) -> mir::BorrowCheckResult<'tcx>,\n-    },\n-\n-    TypeChecking {\n-        /// Gets a complete map from all types to their inherent impls.\n-        /// Not meant to be used directly outside of coherence.\n-        /// (Defined only for `LOCAL_CRATE`.)\n-        [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum)\n-            -> Lrc<CrateInherentImpls>,\n-\n-        /// Checks all types in the crate for overlap in their inherent impls. Reports errors.\n-        /// Not meant to be used directly outside of coherence.\n-        /// (Defined only for `LOCAL_CRATE`.)\n-        [] fn crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum)\n-            -> (),\n-    },\n-\n-    Other {\n-        /// Evaluate a constant without running sanity checks\n-        ///\n-        /// **Do not use this** outside const eval. Const eval uses this to break query cycles\n-        /// during validation. Please add a comment to every use site explaining why using\n-        /// `const_eval` isn't sufficient\n-        [] fn const_eval_raw: const_eval_raw_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-            -> ConstEvalRawResult<'tcx>,\n-\n-        /// Results of evaluating const items or constants embedded in\n-        /// other items (such as enum variant explicit discriminants).\n-        [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-            -> ConstEvalResult<'tcx>,\n-    },\n-\n-    TypeChecking {\n-        [] fn check_match: CheckMatch(DefId) -> (),\n-\n-        /// Performs part of the privacy check and computes \"access levels\".\n-        [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Lrc<AccessLevels>,\n-        [] fn check_private_in_public: CheckPrivateInPublic(CrateNum) -> (),\n-    },\n-\n-    Other {\n-        [] fn reachable_set: reachability_dep_node(CrateNum) -> ReachableSet,\n-\n-        /// Per-body `region::ScopeTree`. The `DefId` should be the owner `DefId` for the body;\n-        /// in the case of closures, this will be redirected to the enclosing function.\n-        [] fn region_scope_tree: RegionScopeTree(DefId) -> Lrc<region::ScopeTree>,\n-\n-        [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n-\n-        [] fn symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n-\n-        [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n-        [] fn def_span: DefSpan(DefId) -> Span,\n-        [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n-        [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n-        [] fn item_attrs: ItemAttrs(DefId) -> Lrc<[ast::Attribute]>,\n-    },\n-\n-    Codegen {\n-        [] fn codegen_fn_attrs: codegen_fn_attrs(DefId) -> CodegenFnAttrs,\n-    },\n-\n-    Other {\n-        [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n-        /// Gets the rendered value of the specified constant or associated constant.\n-        /// Used by rustdoc.\n-        [] fn rendered_const: RenderedConst(DefId) -> String,\n-        [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n-    },\n-\n-    TypeChecking {\n-        [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n-        [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n-        [] fn rvalue_promotable_map: RvaluePromotableMap(DefId) -> Lrc<ItemLocalSet>,\n-    },\n-\n-    Codegen {\n-        [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n-    },\n-\n-    Other {\n-        [] fn vtable_methods: vtable_methods_node(ty::PolyTraitRef<'tcx>)\n-                            -> Lrc<Vec<Option<(DefId, SubstsRef<'tcx>)>>>,\n-    },\n-\n-    Codegen {\n-        [] fn codegen_fulfill_obligation: fulfill_obligation_dep_node(\n-            (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Vtable<'tcx, ()>,\n-    },\n-\n-    TypeChecking {\n-        [] fn trait_impls_of: TraitImpls(DefId) -> Lrc<ty::trait_def::TraitImpls>,\n-        [] fn specialization_graph_of: SpecializationGraph(DefId)\n-            -> Lrc<specialization_graph::Graph>,\n-        [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n-\n-        /// Gets the ParameterEnvironment for a given item; this environment\n-        /// will be in \"user-facing\" mode, meaning that it is suitabe for\n-        /// type-checking etc, and it does not normalize specializable\n-        /// associated types. This is almost always what you want,\n-        /// unless you are doing MIR optimizations, in which case you\n-        /// might want to use `reveal_all()` method to change modes.\n-        [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n-\n-        /// Trait selection queries. These are best used by invoking `ty.is_copy_modulo_regions()`,\n-        /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n-        [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-        [] fn is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-        [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-\n-        // The cycle error here should be reported as an error by `check_representable`.\n-        // We consider the type as not needing drop in the meanwhile to avoid\n-        // further errors (done in impl Value for NeedsDrop).\n-        // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n-        // in case we accidentally otherwise don't emit an error.\n-        [cycle_delay_bug] fn needs_drop_raw: needs_drop_dep_node(\n-            ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n-        ) -> NeedsDrop,\n-\n-        [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                                    -> Result<&'tcx ty::layout::LayoutDetails,\n-                                                ty::layout::LayoutError<'tcx>>,\n-    },\n-\n-    Other {\n-        [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n-                                        -> Lrc<Vec<(CrateNum, LinkagePreference)>>,\n-    },\n-\n-    Codegen {\n-        [fatal_cycle] fn is_compiler_builtins: IsCompilerBuiltins(CrateNum) -> bool,\n-        [fatal_cycle] fn has_global_allocator: HasGlobalAllocator(CrateNum) -> bool,\n-        [fatal_cycle] fn has_panic_handler: HasPanicHandler(CrateNum) -> bool,\n-        [fatal_cycle] fn is_sanitizer_runtime: IsSanitizerRuntime(CrateNum) -> bool,\n-        [fatal_cycle] fn is_profiler_runtime: IsProfilerRuntime(CrateNum) -> bool,\n-        [fatal_cycle] fn panic_strategy: GetPanicStrategy(CrateNum) -> PanicStrategy,\n-        [fatal_cycle] fn is_no_builtins: IsNoBuiltins(CrateNum) -> bool,\n-\n-        [] fn extern_crate: ExternCrate(DefId) -> Lrc<Option<ExternCrate>>,\n-    },\n-\n-    TypeChecking {\n-        [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n-        [] fn in_scope_traits_map: InScopeTraits(DefIndex)\n-            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<StableVec<TraitCandidate>>>>>,\n-    },\n-\n-    Other {\n-        [] fn module_exports: ModuleExports(DefId) -> Option<Lrc<Vec<Export>>>,\n-    },\n-\n-    TypeChecking {\n-        [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n-\n-        [] fn check_item_well_formed: CheckItemWellFormed(DefId) -> (),\n-        [] fn check_trait_item_well_formed: CheckTraitItemWellFormed(DefId) -> (),\n-        [] fn check_impl_item_well_formed: CheckImplItemWellFormed(DefId) -> (),\n-    },\n-\n-    Linking {\n-        // The DefIds of all non-generic functions and statics in the given crate\n-        // that can be reached from outside the crate.\n-        //\n-        // We expect this items to be available for being linked to.\n-        //\n-        // This query can also be called for LOCAL_CRATE. In this case it will\n-        // compute which items will be reachable to other crates, taking into account\n-        // the kind of crate that is currently compiled. Crates with only a\n-        // C interface have fewer reachable things.\n-        //\n-        // Does not include external symbols that don't have a corresponding DefId,\n-        // like the compiler-generated `main` function and so on.\n-        [] fn reachable_non_generics: ReachableNonGenerics(CrateNum)\n-            -> Lrc<DefIdMap<SymbolExportLevel>>,\n-        [] fn is_reachable_non_generic: IsReachableNonGeneric(DefId) -> bool,\n-        [] fn is_unreachable_local_definition: IsUnreachableLocalDefinition(DefId) -> bool,\n-    },\n-\n-    Codegen {\n-        [] fn upstream_monomorphizations: UpstreamMonomorphizations(CrateNum)\n-            -> Lrc<DefIdMap<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>>>,\n-        [] fn upstream_monomorphizations_for: UpstreamMonomorphizationsFor(DefId)\n-            -> Option<Lrc<FxHashMap<SubstsRef<'tcx>, CrateNum>>>,\n-    },\n-\n-    Other {\n-        [] fn foreign_modules: ForeignModules(CrateNum) -> Lrc<Vec<ForeignModule>>,\n-\n-        /// Identifies the entry-point (e.g., the `main` function) for a given\n-        /// crate, returning `None` if there is no entry point (such as for library crates).\n-        [] fn entry_fn: EntryFn(CrateNum) -> Option<(DefId, EntryFnType)>,\n-        [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n-        [] fn proc_macro_decls_static: ProcMacroDeclsStatic(CrateNum) -> Option<DefId>,\n-        [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> CrateDisambiguator,\n-        [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n-        [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,\n-        [] fn extra_filename: ExtraFileName(CrateNum) -> String,\n-    },\n-\n-    TypeChecking {\n-        [] fn implementations_of_trait: implementations_of_trait_node((CrateNum, DefId))\n-            -> Lrc<Vec<DefId>>,\n-        [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n-            -> Lrc<Vec<DefId>>,\n-    },\n-\n-    Other {\n-        [] fn dllimport_foreign_items: DllimportForeignItems(CrateNum)\n-            -> Lrc<FxHashSet<DefId>>,\n-        [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n-        [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n-        [] fn native_library_kind: NativeLibraryKind(DefId)\n-            -> Option<NativeLibraryKind>,\n-    },\n-\n-    Linking {\n-        [] fn link_args: link_args_node(CrateNum) -> Lrc<Vec<String>>,\n-    },\n-\n-    BorrowChecking {\n-        // Lifetime resolution. See `middle::resolve_lifetimes`.\n-        [] fn resolve_lifetimes: ResolveLifetimes(CrateNum) -> Lrc<ResolveLifetimes>,\n-        [] fn named_region_map: NamedRegion(DefIndex) ->\n-            Option<Lrc<FxHashMap<ItemLocalId, Region>>>,\n-        [] fn is_late_bound_map: IsLateBound(DefIndex) ->\n-            Option<Lrc<FxHashSet<ItemLocalId>>>,\n-        [] fn object_lifetime_defaults_map: ObjectLifetimeDefaults(DefIndex)\n-            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>>,\n-    },\n-\n-    TypeChecking {\n-        [] fn visibility: Visibility(DefId) -> ty::Visibility,\n-    },\n-\n-    Other {\n-        [] fn dep_kind: DepKind(CrateNum) -> DepKind,\n-        [] fn crate_name: CrateName(CrateNum) -> Symbol,\n-        [] fn item_children: ItemChildren(DefId) -> Lrc<Vec<Export>>,\n-        [] fn extern_mod_stmt_cnum: ExternModStmtCnum(DefId) -> Option<CrateNum>,\n-\n-        [] fn get_lib_features: get_lib_features_node(CrateNum) -> Lrc<LibFeatures>,\n-        [] fn defined_lib_features: DefinedLibFeatures(CrateNum)\n-            -> Lrc<Vec<(Symbol, Option<Symbol>)>>,\n-        [] fn get_lang_items: get_lang_items_node(CrateNum) -> Lrc<LanguageItems>,\n-        [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Lrc<Vec<(DefId, usize)>>,\n-        [] fn missing_lang_items: MissingLangItems(CrateNum) -> Lrc<Vec<LangItem>>,\n-        [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n-            -> Lrc<DefIdMap<DefId>>,\n-        [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n-        [] fn used_crate_source: UsedCrateSource(CrateNum) -> Lrc<CrateSource>,\n-        [] fn postorder_cnums: postorder_cnums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n-\n-        [] fn freevars: Freevars(DefId) -> Option<Lrc<Vec<hir::Freevar>>>,\n-        [] fn maybe_unused_trait_import: MaybeUnusedTraitImport(DefId) -> bool,\n-        [] fn maybe_unused_extern_crates: maybe_unused_extern_crates_node(CrateNum)\n-            -> Lrc<Vec<(DefId, Span)>>,\n-        [] fn names_imported_by_glob_use: NamesImportedByGlobUse(DefId)\n-            -> Lrc<FxHashSet<ast::Name>>,\n-\n-        [] fn stability_index: stability_index_node(CrateNum) -> Lrc<stability::Index<'tcx>>,\n-        [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n-\n-        /// A vector of every trait accessible in the whole crate\n-        /// (i.e., including those from subcrates). This is used only for\n-        /// error reporting.\n-        [] fn all_traits: all_traits_node(CrateNum) -> Lrc<Vec<DefId>>,\n-    },\n-\n-    Linking {\n-        [] fn exported_symbols: ExportedSymbols(CrateNum)\n-            -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>>,\n-    },\n-\n-    Codegen {\n-        [] fn collect_and_partition_mono_items:\n-            collect_and_partition_mono_items_node(CrateNum)\n-            -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n-        [] fn is_codegened_item: IsCodegenedItem(DefId) -> bool,\n-        [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n-        [] fn backend_optimization_level: BackendOptimizationLevel(CrateNum) -> OptLevel,\n-    },\n-\n-    Other {\n-        [] fn output_filenames: output_filenames_node(CrateNum)\n-            -> Arc<OutputFilenames>,\n-    },\n-\n-    TypeChecking {\n-        /// Do not call this query directly: invoke `normalize` instead.\n-        [] fn normalize_projection_ty: NormalizeProjectionTy(\n-            CanonicalProjectionGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n-        [] fn normalize_ty_after_erasing_regions: NormalizeTyAfterErasingRegions(\n-            ParamEnvAnd<'tcx, Ty<'tcx>>\n-        ) -> Ty<'tcx>,\n-\n-        [] fn implied_outlives_bounds: ImpliedOutlivesBounds(\n-            CanonicalTyGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: invoke `infcx.at().dropck_outlives()` instead.\n-        [] fn dropck_outlives: DropckOutlives(\n-            CanonicalTyGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: invoke `infcx.predicate_may_hold()` or\n-        /// `infcx.predicate_must_hold()` instead.\n-        [] fn evaluate_obligation: EvaluateObligation(\n-            CanonicalPredicateGoal<'tcx>\n-        ) -> Result<traits::EvaluationResult, traits::OverflowError>,\n-\n-        [] fn evaluate_goal: EvaluateGoal(\n-            traits::ChalkCanonicalGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n-            NoSolution\n-        >,\n-\n-        /// Do not call this query directly: part of the `Eq` type-op\n-        [] fn type_op_ascribe_user_type: TypeOpAscribeUserType(\n-            CanonicalTypeOpAscribeUserTypeGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Eq` type-op\n-        [] fn type_op_eq: TypeOpEq(\n-            CanonicalTypeOpEqGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Subtype` type-op\n-        [] fn type_op_subtype: TypeOpSubtype(\n-            CanonicalTypeOpSubtypeGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `ProvePredicate` type-op\n-        [] fn type_op_prove_predicate: TypeOpProvePredicate(\n-            CanonicalTypeOpProvePredicateGoal<'tcx>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Normalize` type-op\n-        [] fn type_op_normalize_ty: TypeOpNormalizeTy(\n-            CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, Ty<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Normalize` type-op\n-        [] fn type_op_normalize_predicate: TypeOpNormalizePredicate(\n-            CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::Predicate<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Normalize` type-op\n-        [] fn type_op_normalize_poly_fn_sig: TypeOpNormalizePolyFnSig(\n-            CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::PolyFnSig<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        /// Do not call this query directly: part of the `Normalize` type-op\n-        [] fn type_op_normalize_fn_sig: TypeOpNormalizeFnSig(\n-            CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>\n-        ) -> Result<\n-            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ty::FnSig<'tcx>>>>,\n-            NoSolution,\n-        >,\n-\n-        [] fn substitute_normalize_and_test_predicates:\n-            substitute_normalize_and_test_predicates_node((DefId, SubstsRef<'tcx>)) -> bool,\n-\n-        [] fn method_autoderef_steps: MethodAutoderefSteps(\n-            CanonicalTyGoal<'tcx>\n-        ) -> MethodAutoderefStepsResult<'tcx>,\n-    },\n-\n-    Other {\n-        [] fn target_features_whitelist:\n-            target_features_whitelist_node(CrateNum) -> Lrc<FxHashMap<String, Option<String>>>,\n-\n-        // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n-        [] fn instance_def_size_estimate: instance_def_size_estimate_dep_node(ty::InstanceDef<'tcx>)\n-            -> usize,\n-\n-        [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n     },\n ]}\n-\n-//////////////////////////////////////////////////////////////////////\n-// These functions are little shims used to find the dep-node for a\n-// given query when there is not a *direct* mapping:\n-\n-\n-fn features_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::Features\n-}\n-\n-fn codegen_fn_attrs<'tcx>(id: DefId) -> DepConstructor<'tcx> {\n-    DepConstructor::CodegenFnAttrs { 0: id }\n-}\n-\n-fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n-    DepConstructor::TypeParamPredicates {\n-        item_id,\n-        param_id\n-    }\n-}\n-\n-fn fulfill_obligation_dep_node<'tcx>((param_env, trait_ref):\n-    (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> DepConstructor<'tcx> {\n-    DepConstructor::FulfillObligation {\n-        param_env,\n-        trait_ref\n-    }\n-}\n-\n-fn crate_inherent_impls_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::Coherence\n-}\n-\n-fn inherent_impls_overlap_check_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::CoherenceInherentImplOverlapCheck\n-}\n-\n-fn reachability_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::Reachability\n-}\n-\n-fn mir_shim_dep_node<'tcx>(instance_def: ty::InstanceDef<'tcx>) -> DepConstructor<'tcx> {\n-    DepConstructor::MirShim {\n-        instance_def\n-    }\n-}\n-\n-fn symbol_name_dep_node<'tcx>(instance: ty::Instance<'tcx>) -> DepConstructor<'tcx> {\n-    DepConstructor::SymbolName { instance }\n-}\n-\n-fn typeck_item_bodies_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::TypeckBodiesKrate\n-}\n-\n-fn const_eval_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-                             -> DepConstructor<'tcx> {\n-    DepConstructor::ConstEval { param_env }\n-}\n-fn const_eval_raw_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-                             -> DepConstructor<'tcx> {\n-    DepConstructor::ConstEvalRaw { param_env }\n-}\n-\n-fn crate_variances<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::CrateVariances\n-}\n-\n-fn is_copy_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::IsCopy { param_env }\n-}\n-\n-fn is_sized_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::IsSized { param_env }\n-}\n-\n-fn is_freeze_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::IsFreeze { param_env }\n-}\n-\n-fn needs_drop_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::NeedsDrop { param_env }\n-}\n-\n-fn layout_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::Layout { param_env }\n-}\n-\n-fn specializes_node<'tcx>((a, b): (DefId, DefId)) -> DepConstructor<'tcx> {\n-    DepConstructor::Specializes { impl1: a, impl2: b }\n-}\n-\n-fn implementations_of_trait_node<'tcx>((krate, trait_id): (CrateNum, DefId))\n-    -> DepConstructor<'tcx>\n-{\n-    DepConstructor::ImplementationsOfTrait { krate, trait_id }\n-}\n-\n-fn link_args_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::LinkArgs\n-}\n-\n-fn get_lib_features_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::GetLibFeatures\n-}\n-\n-fn get_lang_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::GetLangItems\n-}\n-\n-fn visible_parent_map_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::VisibleParentMap\n-}\n-\n-fn postorder_cnums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::PostorderCnums\n-}\n-\n-fn maybe_unused_extern_crates_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::MaybeUnusedExternCrates\n-}\n-\n-fn stability_index_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::StabilityIndex\n-}\n-\n-fn all_crate_nums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::AllCrateNums\n-}\n-\n-fn all_traits_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::AllTraits\n-}\n-\n-fn collect_and_partition_mono_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::CollectAndPartitionMonoItems\n-}\n-\n-fn output_filenames_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::OutputFilenames\n-}\n-\n-fn vtable_methods_node<'tcx>(trait_ref: ty::PolyTraitRef<'tcx>) -> DepConstructor<'tcx> {\n-    DepConstructor::VtableMethods{ trait_ref }\n-}\n-\n-fn substitute_normalize_and_test_predicates_node<'tcx>(key: (DefId, SubstsRef<'tcx>))\n-                                            -> DepConstructor<'tcx> {\n-    DepConstructor::SubstituteNormalizeAndTestPredicates { key }\n-}\n-\n-fn target_features_whitelist_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::TargetFeaturesWhitelist\n-}\n-\n-fn instance_def_size_estimate_dep_node<'tcx>(instance_def: ty::InstanceDef<'tcx>)\n-                                              -> DepConstructor<'tcx> {\n-    DepConstructor::InstanceDefSizeEstimate {\n-        instance_def\n-    }\n-}"}, {"sha": "a03cfd19b9165c6f17d7fb8b54594290a4847acb", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 14, "deletions": 230, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=da60ffbe161a5c5715fc2666a0a09717ed670153", "patch": "@@ -1139,12 +1139,11 @@ pub fn force_from_dep_node<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     dep_node: &DepNode\n ) -> bool {\n-    use crate::hir::def_id::LOCAL_CRATE;\n     use crate::dep_graph::RecoverKey;\n \n     // We must avoid ever having to call force_from_dep_node() for a\n-    // DepNode::CodegenUnit:\n-    // Since we cannot reconstruct the query key of a DepNode::CodegenUnit, we\n+    // DepNode::codegen_unit:\n+    // Since we cannot reconstruct the query key of a DepNode::codegen_unit, we\n     // would always end up having to evaluate the first caller of the\n     // `codegen_unit` query that *is* reconstructible. This might very well be\n     // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n@@ -1155,8 +1154,8 @@ pub fn force_from_dep_node<'tcx>(\n     // each CGU, right after partitioning. This way `try_mark_green` will always\n     // hit the cache instead of having to go through `force_from_dep_node`.\n     // This assertion makes sure, we actually keep applying the solution above.\n-    debug_assert!(dep_node.kind != DepKind::CodegenUnit,\n-                  \"calling force_from_dep_node() on DepKind::CodegenUnit\");\n+    debug_assert!(dep_node.kind != DepKind::codegen_unit,\n+                  \"calling force_from_dep_node() on DepKind::codegen_unit\");\n \n     if !dep_node.kind.can_reconstruct_query_key() {\n         return false\n@@ -1193,9 +1192,6 @@ pub fn force_from_dep_node<'tcx>(\n         ($query:ident, $key:expr) => { force_ex!(tcx, $query, $key) }\n     };\n \n-    // FIXME(#45015): We should try move this boilerplate code into a macro\n-    //                somehow.\n-\n     rustc_dep_node_force!([dep_node, tcx]\n         // These are inputs that are expected to be pre-allocated and that\n         // should therefore always be red or green already\n@@ -1210,223 +1206,11 @@ pub fn force_from_dep_node<'tcx>(\n \n         // We don't have enough information to reconstruct the query key of\n         // these\n-        DepKind::IsCopy |\n-        DepKind::IsSized |\n-        DepKind::IsFreeze |\n-        DepKind::NeedsDrop |\n-        DepKind::Layout |\n-        DepKind::ConstEval |\n-        DepKind::ConstEvalRaw |\n-        DepKind::SymbolName |\n-        DepKind::MirShim |\n-        DepKind::BorrowCheckKrate |\n-        DepKind::Specializes |\n-        DepKind::ImplementationsOfTrait |\n-        DepKind::TypeParamPredicates |\n-        DepKind::CodegenUnit |\n-        DepKind::CompileCodegenUnit |\n-        DepKind::FulfillObligation |\n-        DepKind::VtableMethods |\n-        DepKind::NormalizeProjectionTy |\n-        DepKind::NormalizeTyAfterErasingRegions |\n-        DepKind::ImpliedOutlivesBounds |\n-        DepKind::DropckOutlives |\n-        DepKind::EvaluateObligation |\n-        DepKind::EvaluateGoal |\n-        DepKind::TypeOpAscribeUserType |\n-        DepKind::TypeOpEq |\n-        DepKind::TypeOpSubtype |\n-        DepKind::TypeOpProvePredicate |\n-        DepKind::TypeOpNormalizeTy |\n-        DepKind::TypeOpNormalizePredicate |\n-        DepKind::TypeOpNormalizePolyFnSig |\n-        DepKind::TypeOpNormalizeFnSig |\n-        DepKind::SubstituteNormalizeAndTestPredicates |\n-        DepKind::MethodAutoderefSteps |\n-        DepKind::InstanceDefSizeEstimate => {\n+        DepKind::CompileCodegenUnit => {\n             bug!(\"force_from_dep_node() - Encountered {:?}\", dep_node)\n         }\n \n-        // These are not queries\n-        DepKind::CoherenceCheckTrait |\n-        DepKind::ItemVarianceConstraints => {\n-            return false\n-        }\n-\n-        DepKind::RegionScopeTree => { force!(region_scope_tree, def_id!()); }\n-\n-        DepKind::Coherence => { force!(crate_inherent_impls, LOCAL_CRATE); }\n-        DepKind::CoherenceInherentImplOverlapCheck => {\n-            force!(crate_inherent_impls_overlap_check, LOCAL_CRATE)\n-        },\n-        DepKind::PrivacyAccessLevels => { force!(privacy_access_levels, LOCAL_CRATE); }\n-        DepKind::CheckPrivateInPublic => { force!(check_private_in_public, LOCAL_CRATE); }\n-\n-        DepKind::BorrowCheck => { force!(borrowck, def_id!()); }\n-        DepKind::MirBorrowCheck => { force!(mir_borrowck, def_id!()); }\n-        DepKind::UnsafetyCheckResult => { force!(unsafety_check_result, def_id!()); }\n-        DepKind::UnsafeDeriveOnReprPacked => { force!(unsafe_derive_on_repr_packed, def_id!()); }\n-        DepKind::LintMod => { force!(lint_mod, def_id!()); }\n-        DepKind::CheckModAttrs => { force!(check_mod_attrs, def_id!()); }\n-        DepKind::CheckModLoops => { force!(check_mod_loops, def_id!()); }\n-        DepKind::CheckModUnstableApiUsage => { force!(check_mod_unstable_api_usage, def_id!()); }\n-        DepKind::CheckModItemTypes => { force!(check_mod_item_types, def_id!()); }\n-        DepKind::CheckModPrivacy => { force!(check_mod_privacy, def_id!()); }\n-        DepKind::CheckModIntrinsics => { force!(check_mod_intrinsics, def_id!()); }\n-        DepKind::CheckModLiveness => { force!(check_mod_liveness, def_id!()); }\n-        DepKind::CheckModImplWf => { force!(check_mod_impl_wf, def_id!()); }\n-        DepKind::CollectModItemTypes => { force!(collect_mod_item_types, def_id!()); }\n-        DepKind::Reachability => { force!(reachable_set, LOCAL_CRATE); }\n-        DepKind::CrateVariances => { force!(crate_variances, LOCAL_CRATE); }\n-        DepKind::AssociatedItems => { force!(associated_item, def_id!()); }\n-        DepKind::PredicatesDefinedOnItem => { force!(predicates_defined_on, def_id!()); }\n-        DepKind::ExplicitPredicatesOfItem => { force!(explicit_predicates_of, def_id!()); }\n-        DepKind::InferredOutlivesOf => { force!(inferred_outlives_of, def_id!()); }\n-        DepKind::InferredOutlivesCrate => { force!(inferred_outlives_crate, LOCAL_CRATE); }\n-        DepKind::SuperPredicatesOfItem => { force!(super_predicates_of, def_id!()); }\n-        DepKind::TraitDefOfItem => { force!(trait_def, def_id!()); }\n-        DepKind::AdtDefOfItem => { force!(adt_def, def_id!()); }\n-        DepKind::ImplTraitRef => { force!(impl_trait_ref, def_id!()); }\n-        DepKind::ImplPolarity => { force!(impl_polarity, def_id!()); }\n-        DepKind::Issue33140SelfTy => { force!(issue33140_self_ty, def_id!()); }\n-        DepKind::FnSignature => { force!(fn_sig, def_id!()); }\n-        DepKind::CoerceUnsizedInfo => { force!(coerce_unsized_info, def_id!()); }\n-        DepKind::ItemVariances => { force!(variances_of, def_id!()); }\n-        DepKind::IsConstFn => { force!(is_const_fn_raw, def_id!()); }\n-        DepKind::IsPromotableConstFn => { force!(is_promotable_const_fn, def_id!()); }\n-        DepKind::IsForeignItem => { force!(is_foreign_item, def_id!()); }\n-        DepKind::SizedConstraint => { force!(adt_sized_constraint, def_id!()); }\n-        DepKind::DtorckConstraint => { force!(adt_dtorck_constraint, def_id!()); }\n-        DepKind::AdtDestructor => { force!(adt_destructor, def_id!()); }\n-        DepKind::AssociatedItemDefIds => { force!(associated_item_def_ids, def_id!()); }\n-        DepKind::InherentImpls => { force!(inherent_impls, def_id!()); }\n-        DepKind::TypeckBodiesKrate => { force!(typeck_item_bodies, LOCAL_CRATE); }\n-        DepKind::TypeckTables => { force!(typeck_tables_of, def_id!()); }\n-        DepKind::UsedTraitImports => { force!(used_trait_imports, def_id!()); }\n-        DepKind::HasTypeckTables => { force!(has_typeck_tables, def_id!()); }\n-        DepKind::SpecializationGraph => { force!(specialization_graph_of, def_id!()); }\n-        DepKind::ObjectSafety => { force!(is_object_safe, def_id!()); }\n-        DepKind::TraitImpls => { force!(trait_impls_of, def_id!()); }\n-        DepKind::CheckMatch => { force!(check_match, def_id!()); }\n-\n-        DepKind::ParamEnv => { force!(param_env, def_id!()); }\n-        DepKind::DescribeDef => { force!(describe_def, def_id!()); }\n-        DepKind::DefSpan => { force!(def_span, def_id!()); }\n-        DepKind::LookupStability => { force!(lookup_stability, def_id!()); }\n-        DepKind::LookupDeprecationEntry => {\n-            force!(lookup_deprecation_entry, def_id!());\n-        }\n-        DepKind::ConstIsRvaluePromotableToStatic => {\n-            force!(const_is_rvalue_promotable_to_static, def_id!());\n-        }\n-        DepKind::RvaluePromotableMap => { force!(rvalue_promotable_map, def_id!()); }\n-        DepKind::ImplParent => { force!(impl_parent, def_id!()); }\n-        DepKind::TraitOfItem => { force!(trait_of_item, def_id!()); }\n-        DepKind::IsReachableNonGeneric => { force!(is_reachable_non_generic, def_id!()); }\n-        DepKind::IsUnreachableLocalDefinition => {\n-            force!(is_unreachable_local_definition, def_id!());\n-        }\n-        DepKind::IsMirAvailable => { force!(is_mir_available, def_id!()); }\n-        DepKind::ItemAttrs => { force!(item_attrs, def_id!()); }\n-        DepKind::CodegenFnAttrs => { force!(codegen_fn_attrs, def_id!()); }\n-        DepKind::FnArgNames => { force!(fn_arg_names, def_id!()); }\n-        DepKind::RenderedConst => { force!(rendered_const, def_id!()); }\n-        DepKind::DylibDepFormats => { force!(dylib_dependency_formats, krate!()); }\n-        DepKind::IsCompilerBuiltins => { force!(is_compiler_builtins, krate!()); }\n-        DepKind::HasGlobalAllocator => { force!(has_global_allocator, krate!()); }\n-        DepKind::HasPanicHandler => { force!(has_panic_handler, krate!()); }\n-        DepKind::ExternCrate => { force!(extern_crate, def_id!()); }\n-        DepKind::InScopeTraits => { force!(in_scope_traits_map, def_id!().index); }\n-        DepKind::ModuleExports => { force!(module_exports, def_id!()); }\n-        DepKind::IsSanitizerRuntime => { force!(is_sanitizer_runtime, krate!()); }\n-        DepKind::IsProfilerRuntime => { force!(is_profiler_runtime, krate!()); }\n-        DepKind::GetPanicStrategy => { force!(panic_strategy, krate!()); }\n-        DepKind::IsNoBuiltins => { force!(is_no_builtins, krate!()); }\n-        DepKind::ImplDefaultness => { force!(impl_defaultness, def_id!()); }\n-        DepKind::CheckItemWellFormed => { force!(check_item_well_formed, def_id!()); }\n-        DepKind::CheckTraitItemWellFormed => { force!(check_trait_item_well_formed, def_id!()); }\n-        DepKind::CheckImplItemWellFormed => { force!(check_impl_item_well_formed, def_id!()); }\n-        DepKind::ReachableNonGenerics => { force!(reachable_non_generics, krate!()); }\n-        DepKind::EntryFn => { force!(entry_fn, krate!()); }\n-        DepKind::PluginRegistrarFn => { force!(plugin_registrar_fn, krate!()); }\n-        DepKind::ProcMacroDeclsStatic => { force!(proc_macro_decls_static, krate!()); }\n-        DepKind::CrateDisambiguator => { force!(crate_disambiguator, krate!()); }\n-        DepKind::CrateHash => { force!(crate_hash, krate!()); }\n-        DepKind::OriginalCrateName => { force!(original_crate_name, krate!()); }\n-        DepKind::ExtraFileName => { force!(extra_filename, krate!()); }\n         DepKind::Analysis => { force!(analysis, krate!()); }\n-\n-        DepKind::AllTraitImplementations => {\n-            force!(all_trait_implementations, krate!());\n-        }\n-\n-        DepKind::DllimportForeignItems => {\n-            force!(dllimport_foreign_items, krate!());\n-        }\n-        DepKind::IsDllimportForeignItem => {\n-            force!(is_dllimport_foreign_item, def_id!());\n-        }\n-        DepKind::IsStaticallyIncludedForeignItem => {\n-            force!(is_statically_included_foreign_item, def_id!());\n-        }\n-        DepKind::NativeLibraryKind => { force!(native_library_kind, def_id!()); }\n-        DepKind::LinkArgs => { force!(link_args, LOCAL_CRATE); }\n-\n-        DepKind::ResolveLifetimes => { force!(resolve_lifetimes, krate!()); }\n-        DepKind::NamedRegion => { force!(named_region_map, def_id!().index); }\n-        DepKind::IsLateBound => { force!(is_late_bound_map, def_id!().index); }\n-        DepKind::ObjectLifetimeDefaults => {\n-            force!(object_lifetime_defaults_map, def_id!().index);\n-        }\n-\n-        DepKind::Visibility => { force!(visibility, def_id!()); }\n-        DepKind::DepKind => { force!(dep_kind, krate!()); }\n-        DepKind::CrateName => { force!(crate_name, krate!()); }\n-        DepKind::ItemChildren => { force!(item_children, def_id!()); }\n-        DepKind::ExternModStmtCnum => { force!(extern_mod_stmt_cnum, def_id!()); }\n-        DepKind::GetLibFeatures => { force!(get_lib_features, LOCAL_CRATE); }\n-        DepKind::DefinedLibFeatures => { force!(defined_lib_features, krate!()); }\n-        DepKind::GetLangItems => { force!(get_lang_items, LOCAL_CRATE); }\n-        DepKind::DefinedLangItems => { force!(defined_lang_items, krate!()); }\n-        DepKind::MissingLangItems => { force!(missing_lang_items, krate!()); }\n-        DepKind::VisibleParentMap => { force!(visible_parent_map, LOCAL_CRATE); }\n-        DepKind::MissingExternCrateItem => {\n-            force!(missing_extern_crate_item, krate!());\n-        }\n-        DepKind::UsedCrateSource => { force!(used_crate_source, krate!()); }\n-        DepKind::PostorderCnums => { force!(postorder_cnums, LOCAL_CRATE); }\n-\n-        DepKind::Freevars => { force!(freevars, def_id!()); }\n-        DepKind::MaybeUnusedTraitImport => {\n-            force!(maybe_unused_trait_import, def_id!());\n-        }\n-        DepKind::NamesImportedByGlobUse => { force!(names_imported_by_glob_use, def_id!()); }\n-        DepKind::MaybeUnusedExternCrates => { force!(maybe_unused_extern_crates, LOCAL_CRATE); }\n-        DepKind::StabilityIndex => { force!(stability_index, LOCAL_CRATE); }\n-        DepKind::AllTraits => { force!(all_traits, LOCAL_CRATE); }\n-        DepKind::AllCrateNums => { force!(all_crate_nums, LOCAL_CRATE); }\n-        DepKind::ExportedSymbols => { force!(exported_symbols, krate!()); }\n-        DepKind::CollectAndPartitionMonoItems => {\n-            force!(collect_and_partition_mono_items, LOCAL_CRATE);\n-        }\n-        DepKind::IsCodegenedItem => { force!(is_codegened_item, def_id!()); }\n-        DepKind::OutputFilenames => { force!(output_filenames, LOCAL_CRATE); }\n-\n-        DepKind::TargetFeaturesWhitelist => { force!(target_features_whitelist, LOCAL_CRATE); }\n-\n-        DepKind::Features => { force!(features_query, LOCAL_CRATE); }\n-\n-        DepKind::ForeignModules => { force!(foreign_modules, krate!()); }\n-\n-        DepKind::UpstreamMonomorphizations => {\n-            force!(upstream_monomorphizations, krate!());\n-        }\n-        DepKind::UpstreamMonomorphizationsFor => {\n-            force!(upstream_monomorphizations_for, def_id!());\n-        }\n-        DepKind::BackendOptimizationLevel => {\n-            force!(backend_optimization_level, krate!());\n-        }\n     );\n \n     true\n@@ -1479,18 +1263,18 @@ macro_rules! impl_load_from_cache {\n }\n \n impl_load_from_cache!(\n-    TypeckTables => typeck_tables_of,\n+    typeck_tables_of => typeck_tables_of,\n     optimized_mir => optimized_mir,\n-    UnsafetyCheckResult => unsafety_check_result,\n-    BorrowCheck => borrowck,\n-    MirBorrowCheck => mir_borrowck,\n+    unsafety_check_result => unsafety_check_result,\n+    borrowck => borrowck,\n+    mir_borrowck => mir_borrowck,\n     mir_const_qualif => mir_const_qualif,\n-    ConstIsRvaluePromotableToStatic => const_is_rvalue_promotable_to_static,\n-    CheckMatch => check_match,\n+    const_is_rvalue_promotable_to_static => const_is_rvalue_promotable_to_static,\n+    check_match => check_match,\n     type_of => type_of,\n     generics_of => generics_of,\n     predicates_of => predicates_of,\n-    UsedTraitImports => used_trait_imports,\n-    CodegenFnAttrs => codegen_fn_attrs,\n-    SpecializationGraph => specialization_graph_of,\n+    used_trait_imports => used_trait_imports,\n+    codegen_fn_attrs => codegen_fn_attrs,\n+    specialization_graph_of => specialization_graph_of,\n );"}, {"sha": "a772aa518671617381233ecf133ea34d8fd63ab5", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da60ffbe161a5c5715fc2666a0a09717ed670153/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=da60ffbe161a5c5715fc2666a0a09717ed670153", "patch": "@@ -42,14 +42,14 @@ const BASE_CONST: &[&str] = &[\n /// DepNodes for functions + methods\n const BASE_FN: &[&str] = &[\n     // Callers will depend on the signature of these items, so we better test\n-    label_strs::FnSignature,\n+    label_strs::fn_sig,\n     label_strs::generics_of,\n     label_strs::predicates_of,\n     label_strs::type_of,\n \n     // And a big part of compilation (that we eventually want to cache) is type inference\n     // information:\n-    label_strs::TypeckTables,\n+    label_strs::typeck_tables_of,\n ];\n \n /// DepNodes for Hir, which is pretty much everything\n@@ -61,9 +61,9 @@ const BASE_HIR: &[&str] = &[\n \n /// `impl` implementation of struct/trait\n const BASE_IMPL: &[&str] = &[\n-    label_strs::AssociatedItemDefIds,\n+    label_strs::associated_item_def_ids,\n     label_strs::generics_of,\n-    label_strs::ImplTraitRef,\n+    label_strs::impl_trait_ref,\n ];\n \n /// DepNodes for mir_built/Optimized, which is relevant in \"executable\"\n@@ -85,22 +85,22 @@ const BASE_STRUCT: &[&str] = &[\n \n /// Trait definition `DepNode`s.\n const BASE_TRAIT_DEF: &[&str] = &[\n-    label_strs::AssociatedItemDefIds,\n+    label_strs::associated_item_def_ids,\n     label_strs::generics_of,\n-    label_strs::ObjectSafety,\n+    label_strs::is_object_safe,\n     label_strs::predicates_of,\n-    label_strs::SpecializationGraph,\n-    label_strs::TraitDefOfItem,\n-    label_strs::TraitImpls,\n+    label_strs::specialization_graph_of,\n+    label_strs::trait_def,\n+    label_strs::trait_impls_of,\n ];\n \n /// Extra `DepNode`s for functions and methods.\n const EXTRA_ASSOCIATED: &[&str] = &[\n-    label_strs::AssociatedItems,\n+    label_strs::associated_item,\n ];\n \n const EXTRA_TRAIT: &[&str] = &[\n-    label_strs::TraitOfItem,\n+    label_strs::trait_of_item,\n ];\n \n // Fully Built Labels"}]}