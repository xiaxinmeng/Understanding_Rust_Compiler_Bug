{"sha": "d434688516f809cff835e76eb6cba07d23e48a2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MzQ2ODg1MTZmODA5Y2ZmODM1ZTc2ZWI2Y2JhMDdkMjNlNDhhMmQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-02T20:11:19Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-07T04:15:01Z"}, "message": "mir: build MIR for constants and static initializers.", "tree": {"sha": "d4998321b13b48726e08e2a62c56aa5c0596da4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4998321b13b48726e08e2a62c56aa5c0596da4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d434688516f809cff835e76eb6cba07d23e48a2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d434688516f809cff835e76eb6cba07d23e48a2d", "html_url": "https://github.com/rust-lang/rust/commit/d434688516f809cff835e76eb6cba07d23e48a2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d434688516f809cff835e76eb6cba07d23e48a2d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cde2f5f11639edb2f943b6caa5f3b930c0c4f214", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde2f5f11639edb2f943b6caa5f3b930c0c4f214", "html_url": "https://github.com/rust-lang/rust/commit/cde2f5f11639edb2f943b6caa5f3b930c0c4f214"}], "stats": {"total": 202, "additions": 177, "deletions": 25}, "files": [{"sha": "640ef48493a2ce819f8d23967e9e6cd2b96077b3", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 68, "deletions": 14, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d434688516f809cff835e76eb6cba07d23e48a2d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d434688516f809cff835e76eb6cba07d23e48a2d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=d434688516f809cff835e76eb6cba07d23e48a2d", "patch": "@@ -97,6 +97,31 @@ impl<'ast> DefCollector<'ast> {\n         f(self);\n         self.parent_def = parent;\n     }\n+\n+    fn visit_ast_const_integer(&mut self, expr: &'ast Expr) {\n+        // Find the node which will be used after lowering.\n+        if let ExprKind::Paren(ref inner) = expr.node {\n+            return self.visit_ast_const_integer(inner);\n+        }\n+\n+        // FIXME(eddyb) Closures should have separate\n+        // function definition IDs and expression IDs.\n+        if let ExprKind::Closure(..) = expr.node {\n+            return;\n+        }\n+\n+        self.create_def(expr.id, DefPathData::Initializer);\n+    }\n+\n+    fn visit_hir_const_integer(&mut self, expr: &'ast hir::Expr) {\n+        // FIXME(eddyb) Closures should have separate\n+        // function definition IDs and expression IDs.\n+        if let hir::ExprClosure(..) = expr.node {\n+            return;\n+        }\n+\n+        self.create_def(expr.id, DefPathData::Initializer);\n+    }\n }\n \n impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n@@ -126,14 +151,17 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n                                             DefPathData::EnumVariant(v.node.name.name));\n-\n-                        for (index, field) in v.node.data.fields().iter().enumerate() {\n-                            let name = field.ident.map(|ident| ident.name)\n-                                .unwrap_or(token::intern(&index.to_string()));\n-                            this.create_def_with_parent(Some(variant_def_index),\n-                                                        field.id,\n-                                                        DefPathData::Field(name));\n-                        }\n+                        this.with_parent(variant_def_index, |this| {\n+                            for (index, field) in v.node.data.fields().iter().enumerate() {\n+                                let name = field.ident.map(|ident| ident.name)\n+                                    .unwrap_or_else(|| token::intern(&index.to_string()));\n+                                this.create_def(field.id, DefPathData::Field(name));\n+                            }\n+\n+                            if let Some(ref expr) = v.node.disr_expr {\n+                                this.visit_ast_const_integer(expr);\n+                            }\n+                        });\n                     }\n                 }\n                 ItemKind::Struct(ref struct_def, _) => {\n@@ -221,6 +249,10 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         let parent_def = self.parent_def;\n \n+        if let ExprKind::Repeat(_, ref count) = expr.node {\n+            self.visit_ast_const_integer(count);\n+        }\n+\n         if let ExprKind::Closure(..) = expr.node {\n             let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n             self.parent_def = Some(def);\n@@ -230,6 +262,13 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         self.parent_def = parent_def;\n     }\n \n+    fn visit_ty(&mut self, ty: &'ast Ty) {\n+        if let TyKind::FixedLengthVec(_, ref length) = ty.node {\n+            self.visit_ast_const_integer(length);\n+        }\n+        visit::walk_ty(self, ty);\n+    }\n+\n     fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n     }\n@@ -276,11 +315,15 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n                             this.create_def(v.node.data.id(),\n                                             DefPathData::EnumVariant(v.node.name));\n \n-                        for field in v.node.data.fields() {\n-                            this.create_def_with_parent(Some(variant_def_index),\n-                                                        field.id,\n-                                                        DefPathData::Field(field.name));\n-                        }\n+                        this.with_parent(variant_def_index, |this| {\n+                            for field in v.node.data.fields() {\n+                                this.create_def(field.id,\n+                                                DefPathData::Field(field.name));\n+                            }\n+                            if let Some(ref expr) = v.node.disr_expr {\n+                                this.visit_hir_const_integer(expr);\n+                            }\n+                        });\n                     }\n                 }\n                 hir::ItemStruct(ref struct_def, _) => {\n@@ -365,6 +408,10 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_expr(&mut self, expr: &'ast hir::Expr) {\n         let parent_def = self.parent_def;\n \n+        if let hir::ExprRepeat(_, ref count) = expr.node {\n+            self.visit_hir_const_integer(count);\n+        }\n+\n         if let hir::ExprClosure(..) = expr.node {\n             let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n             self.parent_def = Some(def);\n@@ -374,11 +421,18 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n         self.parent_def = parent_def;\n     }\n \n+    fn visit_ty(&mut self, ty: &'ast hir::Ty) {\n+        if let hir::TyFixedLengthVec(_, ref length) = ty.node {\n+            self.visit_hir_const_integer(length);\n+        }\n+        intravisit::walk_ty(self, ty);\n+    }\n+\n     fn visit_lifetime_def(&mut self, def: &'ast hir::LifetimeDef) {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'ast hir::MacroDef) {\n         self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "174f626498b1f17ae45d25dad5fb263474d1ddc5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d434688516f809cff835e76eb6cba07d23e48a2d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d434688516f809cff835e76eb6cba07d23e48a2d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d434688516f809cff835e76eb6cba07d23e48a2d", "patch": "@@ -25,7 +25,7 @@ use middle::cstore::{self, LOCAL_CRATE};\n use hir::def::{self, Def, ExportMap};\n use hir::def_id::DefId;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n-use middle::region::{CodeExtent};\n+use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n use traits;\n use ty;\n use ty::subst::{Subst, Substs, VecPerParamSpace};\n@@ -1376,6 +1376,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n+                    hir::ItemTy(..) |\n                     hir::ItemImpl(..) |\n                     hir::ItemConst(..) |\n                     hir::ItemStatic(..) => {\n@@ -1408,6 +1409,15 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                 // This is a convenience to allow closures to work.\n                 ParameterEnvironment::for_item(cx, cx.map.get_parent(id))\n             }\n+            Some(ast_map::NodeForeignItem(item)) => {\n+                let def_id = cx.map.local_def_id(id);\n+                let scheme = cx.lookup_item_type(def_id);\n+                let predicates = cx.lookup_predicates(def_id);\n+                cx.construct_parameter_environment(item.span,\n+                                                   &scheme.generics,\n+                                                   &predicates,\n+                                                   ROOT_CODE_EXTENT)\n+            }\n             _ => {\n                 bug!(\"ParameterEnvironment::from_item(): \\\n                       `{}` is not an item\","}, {"sha": "a4f4e44b1b13998e599347b9dc0a69c94a841442", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d434688516f809cff835e76eb6cba07d23e48a2d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d434688516f809cff835e76eb6cba07d23e48a2d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=d434688516f809cff835e76eb6cba07d23e48a2d", "patch": "@@ -35,13 +35,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         let expr_ty = expr.ty.clone();\n         let temp = this.temp(expr_ty.clone());\n-        let temp_lifetime = match expr.temp_lifetime {\n-            Some(t) => t,\n-            None => {\n-                span_bug!(expr.span, \"no temp_lifetime for expr\");\n-            }\n-        };\n-        this.schedule_drop(expr.span, temp_lifetime, &temp, expr_ty);\n+        // In constants, temp_lifetime is None. We should not need to drop\n+        // anything because no values with a destructor can be created in\n+        // a constant at this time, even if the type may need dropping.\n+        if let Some(temp_lifetime) = expr.temp_lifetime {\n+            this.schedule_drop(expr.span, temp_lifetime, &temp, expr_ty);\n+        }\n \n         // Careful here not to cause an infinite cycle. If we always\n         // called `into`, then for lvalues like `x.f`, it would"}, {"sha": "89c89e6e2e376d6b678001b113b6a282256e388f", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d434688516f809cff835e76eb6cba07d23e48a2d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d434688516f809cff835e76eb6cba07d23e48a2d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=d434688516f809cff835e76eb6cba07d23e48a2d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hair::cx::Cx;\n-use rustc::middle::region::{CodeExtent, CodeExtentData};\n+use rustc::middle::region::{CodeExtent, CodeExtentData, ROOT_CODE_EXTENT};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n@@ -232,6 +232,33 @@ pub fn construct_fn<'a, 'tcx, A>(hir: Cx<'a,'tcx>,\n     builder.finish(upvar_decls, arg_decls, return_ty)\n }\n \n+pub fn construct_const<'a, 'tcx>(hir: Cx<'a,'tcx>,\n+                                 item_id: ast::NodeId,\n+                                 ast_expr: &'tcx hir::Expr)\n+                                 -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+    let tcx = hir.tcx();\n+    let span = tcx.map.span(item_id);\n+    let mut builder = Builder::new(hir, span);\n+\n+    let extent = ROOT_CODE_EXTENT;\n+    let mut block = START_BLOCK;\n+    let _ = builder.in_scope(extent, block, |builder, call_site_scope_id| {\n+        let expr = builder.hir.mirror(ast_expr);\n+        unpack!(block = builder.into(&Lvalue::ReturnPointer, block, expr));\n+\n+        let return_block = builder.return_block();\n+        builder.cfg.terminate(block, call_site_scope_id, span,\n+                              TerminatorKind::Goto { target: return_block });\n+        builder.cfg.terminate(return_block, call_site_scope_id, span,\n+                              TerminatorKind::Return);\n+\n+        return_block.unit()\n+    });\n+\n+    let ty = tcx.expr_ty_adjusted(ast_expr);\n+    builder.finish(vec![], vec![], ty::FnConverging(ty))\n+}\n+\n impl<'a,'tcx> Builder<'a,'tcx> {\n     fn new(hir: Cx<'a, 'tcx>, span: Span) -> Builder<'a, 'tcx> {\n         let mut builder = Builder {"}, {"sha": "e6b795531d93e3231c8a17aa0bfe14afde15fd98", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d434688516f809cff835e76eb6cba07d23e48a2d/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d434688516f809cff835e76eb6cba07d23e48a2d/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=d434688516f809cff835e76eb6cba07d23e48a2d", "patch": "@@ -16,8 +16,6 @@\n //! - `#[rustc_mir(graphviz=\"file.gv\")]`\n //! - `#[rustc_mir(pretty=\"file.mir\")]`\n \n-extern crate syntax;\n-\n use build;\n use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n@@ -72,9 +70,73 @@ impl<'a, 'tcx> BuildMir<'a, 'tcx> {\n \n         assert!(self.map.map.insert(id, mir).is_none())\n     }\n+\n+    fn build_const_integer(&mut self, expr: &'tcx hir::Expr) {\n+        // FIXME(eddyb) Closures should have separate\n+        // function definition IDs and expression IDs.\n+        // Type-checking should not let closures get\n+        // this far in an integer constant position.\n+        if let hir::ExprClosure(..) = expr.node {\n+            return;\n+        }\n+        self.build(expr.id, |cx| build::construct_const(cx, expr.id, expr));\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n+    // Const and static items.\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        match item.node {\n+            hir::ItemConst(_, ref expr) |\n+            hir::ItemStatic(_, _, ref expr) => {\n+                self.build(item.id, |cx| build::construct_const(cx, item.id, expr));\n+            }\n+            _ => {}\n+        }\n+        intravisit::walk_item(self, item);\n+    }\n+\n+    // Trait associated const defaults.\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n+        if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n+            self.build(item.id, |cx| build::construct_const(cx, item.id, expr));\n+        }\n+        intravisit::walk_trait_item(self, item);\n+    }\n+\n+    // Impl associated const.\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n+        if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n+            self.build(item.id, |cx| build::construct_const(cx, item.id, expr));\n+        }\n+        intravisit::walk_impl_item(self, item);\n+    }\n+\n+    // Repeat counts, i.e. [expr; constant].\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        if let hir::ExprRepeat(_, ref count) = expr.node {\n+            self.build_const_integer(count);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    // Array lengths, i.e. [T; constant].\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        if let hir::TyFixedLengthVec(_, ref length) = ty.node {\n+            self.build_const_integer(length);\n+        }\n+        intravisit::walk_ty(self, ty);\n+    }\n+\n+    // Enum variant discriminant values.\n+    fn visit_variant(&mut self, v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics, item_id: ast::NodeId) {\n+        if let Some(ref expr) = v.node.disr_expr {\n+            self.build_const_integer(expr);\n+        }\n+        intravisit::walk_variant(self, v, g, item_id);\n+    }\n+\n     fn visit_fn(&mut self,\n                 fk: intravisit::FnKind<'tcx>,\n                 decl: &'tcx hir::FnDecl,"}]}