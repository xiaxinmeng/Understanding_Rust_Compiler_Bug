{"sha": "091ba6daa0a0a528b5d9fc816529a9bb25503960", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MWJhNmRhYTBhMGE1MjhiNWQ5ZmM4MTY1MjlhOWJiMjU1MDM5NjA=", "commit": {"author": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2020-01-12T05:15:00Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2020-01-12T05:15:00Z"}, "message": "Address review comments.", "tree": {"sha": "7b99a291dc250f1646de94dd34c71e76604626b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b99a291dc250f1646de94dd34c71e76604626b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/091ba6daa0a0a528b5d9fc816529a9bb25503960", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/091ba6daa0a0a528b5d9fc816529a9bb25503960", "html_url": "https://github.com/rust-lang/rust/commit/091ba6daa0a0a528b5d9fc816529a9bb25503960", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/091ba6daa0a0a528b5d9fc816529a9bb25503960/comments", "author": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d59e9b40a3712fa29e59b17cc2a9a10549cae79f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d59e9b40a3712fa29e59b17cc2a9a10549cae79f", "html_url": "https://github.com/rust-lang/rust/commit/d59e9b40a3712fa29e59b17cc2a9a10549cae79f"}], "stats": {"total": 244, "additions": 161, "deletions": 83}, "files": [{"sha": "3524c6e9817e1ee3064ffbf0063a8477d9e95b6b", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 155, "deletions": 78, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/091ba6daa0a0a528b5d9fc816529a9bb25503960/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/091ba6daa0a0a528b5d9fc816529a9bb25503960/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=091ba6daa0a0a528b5d9fc816529a9bb25503960", "patch": "@@ -251,8 +251,8 @@ impl<T> LinkedList<T> {\n         &mut self,\n         existing_prev: Option<NonNull<Node<T>>>,\n         existing_next: Option<NonNull<Node<T>>>,\n-        splice_start: NonNull<Node<T>>,\n-        splice_end: NonNull<Node<T>>,\n+        mut splice_start: NonNull<Node<T>>,\n+        mut splice_end: NonNull<Node<T>>,\n         splice_length: usize,\n     ) {\n         // This method takes care not to create multiple mutable references to whole nodes at the same time,\n@@ -267,9 +267,7 @@ impl<T> LinkedList<T> {\n         } else {\n             self.tail = Some(splice_end);\n         }\n-        let mut splice_start = splice_start;\n         splice_start.as_mut().prev = existing_prev;\n-        let mut splice_end = splice_end;\n         splice_end.as_mut().next = existing_next;\n \n         self.len += splice_length;\n@@ -289,6 +287,41 @@ impl<T> LinkedList<T> {\n         }\n     }\n \n+    #[inline]\n+    unsafe fn split_off_before_node(\n+        &mut self,\n+        split_node: Option<NonNull<Node<T>>>,\n+        at: usize,\n+    ) -> Self {\n+        // The split node is the new head node of the second part\n+        if let Some(mut split_node) = split_node {\n+            let first_part_head;\n+            let first_part_tail;\n+            first_part_tail = split_node.as_mut().prev.take();\n+            if let Some(mut tail) = first_part_tail {\n+                tail.as_mut().next = None;\n+                first_part_head = self.head;\n+            } else {\n+                first_part_head = None;\n+            }\n+\n+            let first_part = LinkedList {\n+                head: first_part_head,\n+                tail: first_part_tail,\n+                len: at,\n+                marker: PhantomData,\n+            };\n+\n+            // Fix the head ptr of the second part\n+            self.head = Some(split_node);\n+            self.len = self.len - at;\n+\n+            first_part\n+        } else {\n+            mem::replace(self, LinkedList::new())\n+        }\n+    }\n+\n     #[inline]\n     unsafe fn split_off_after_node(\n         &mut self,\n@@ -1082,16 +1115,13 @@ impl<T> IterMut<'_, T> {\n \n /// A cursor over a `LinkedList`.\n ///\n-/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth, and can\n-/// safely mutate the list during iteration. This is because the lifetime of its yielded\n-/// references is tied to its own lifetime, instead of just the underlying list. This means\n-/// cursors cannot yield multiple elements at once.\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth.\n ///\n /// Cursors always rest between two elements in the list, and index in a logically circular way.\n /// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n /// tail of the list.\n ///\n-/// When created, cursors start at the front of the list, or the ghost element if the list is empty.\n+/// When created, cursors start at the front of the list, or the \"ghost\" non-element if the list is empty.\n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n pub struct Cursor<'a, T: 'a> {\n     index: usize,\n@@ -1117,7 +1147,7 @@ impl<T: fmt::Debug> fmt::Debug for Cursor<'_, T> {\n /// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n /// tail of the list.\n ///\n-/// When created, cursors start at the front of the list, or the ghost element if the list is empty.\n+/// When created, cursors start at the front of the list, or the \"ghost\" non-element if the list is empty.\n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n pub struct CursorMut<'a, T: 'a> {\n     index: usize,\n@@ -1133,8 +1163,11 @@ impl<T: fmt::Debug> fmt::Debug for CursorMut<'_, T> {\n }\n \n impl<'a, T> Cursor<'a, T> {\n-    /// Move to the subsequent element of the list if it exists or the empty\n-    /// element\n+    /// Moves the cursor to the next element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn move_next(&mut self) {\n         match self.current.take() {\n@@ -1152,7 +1185,11 @@ impl<'a, T> Cursor<'a, T> {\n         }\n     }\n \n-    /// Move to the previous element of the list\n+    /// Moves the cursor to the previous element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn move_prev(&mut self) {\n         match self.current.take() {\n@@ -1169,13 +1206,21 @@ impl<'a, T> Cursor<'a, T> {\n         }\n     }\n \n-    /// Get the current element\n+    /// Returns a reference to the element that the cursor is currently\n+    /// pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn current(&self) -> Option<&'a T> {\n         unsafe { self.current.map(|current| &(*current.as_ptr()).element) }\n     }\n \n-    /// Get the next element\n+    /// Returns a reference to the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this returns `None`.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn peek_next(&self) -> Option<&'a T> {\n         unsafe {\n@@ -1187,7 +1232,11 @@ impl<'a, T> Cursor<'a, T> {\n         }\n     }\n \n-    /// Get the previous element\n+    /// Returns a reference to the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this returns `None`.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn peek_prev(&self) -> Option<&'a T> {\n         unsafe {\n@@ -1201,8 +1250,11 @@ impl<'a, T> Cursor<'a, T> {\n }\n \n impl<'a, T> CursorMut<'a, T> {\n-    /// Move to the subsequent element of the list if it exists or the empty\n-    /// element\n+    /// Moves the cursor to the next element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn move_next(&mut self) {\n         match self.current.take() {\n@@ -1220,7 +1272,11 @@ impl<'a, T> CursorMut<'a, T> {\n         }\n     }\n \n-    /// Move to the previous element of the list\n+    /// Moves the cursor to the previous element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn move_prev(&mut self) {\n         match self.current.take() {\n@@ -1237,13 +1293,21 @@ impl<'a, T> CursorMut<'a, T> {\n         }\n     }\n \n-    /// Get the current element\n+    /// Returns a reference to the element that the cursor is currently\n+    /// pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn current(&mut self) -> Option<&mut T> {\n         unsafe { self.current.map(|current| &mut (*current.as_ptr()).element) }\n     }\n \n-    /// Get the next element\n+    /// Returns a reference to the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this returns `None`.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn peek_next(&mut self) -> Option<&mut T> {\n         unsafe {\n@@ -1255,7 +1319,11 @@ impl<'a, T> CursorMut<'a, T> {\n         }\n     }\n \n-    /// Get the previous element\n+    /// Returns a reference to the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this returns `None`.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn peek_prev(&mut self) -> Option<&mut T> {\n         unsafe {\n@@ -1267,7 +1335,11 @@ impl<'a, T> CursorMut<'a, T> {\n         }\n     }\n \n-    /// Get an immutable cursor at the current element\n+    /// Returns a read-only cursor pointing to the current element.\n+    ///\n+    /// The lifetime of the returned `Cursor` is bound to that of the\n+    /// `CursorMut`, which means it cannot outlive the `CursorMut` and that the\n+    /// `CursorMut` is frozen for the lifetime of the `Cursor`.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn as_cursor<'cm>(&'cm self) -> Cursor<'cm, T> {\n         Cursor { list: self.list, current: self.current, index: self.index }\n@@ -1277,121 +1349,126 @@ impl<'a, T> CursorMut<'a, T> {\n // Now the list editing operations\n \n impl<'a, T> CursorMut<'a, T> {\n-    /// Insert `item` after the cursor\n+    /// Inserts a new element into the `LinkedList` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the front of the `LinkedList`.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn insert_after(&mut self, item: T) {\n         unsafe {\n             let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n-            let (node, node_next) = match self.current {\n-                None => (None, self.list.head),\n-                Some(node) => {\n-                    let node_next = node.as_ref().next;\n-                    (Some(node), node_next)\n-                }\n+            let node_next = match self.current {\n+                None => self.list.head,\n+                Some(node) => node.as_ref().next,\n             };\n-            self.list.splice_nodes(node, node_next, spliced_node, spliced_node, 1);\n+            self.list.splice_nodes(self.current, node_next, spliced_node, spliced_node, 1);\n             if self.current.is_none() {\n-                // The ghost element's index has increased by 1.\n-                self.index += 1;\n+                // The \"ghost\" non-element's index has changed.\n+                self.index = self.list.len;\n             }\n         }\n     }\n \n-    /// Insert `item` before the cursor\n+    /// Inserts a new element into the `LinkedList` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the end of the `LinkedList`.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn insert_before(&mut self, item: T) {\n         unsafe {\n             let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n-            let (node_prev, node) = match self.current {\n-                None => (self.list.tail, None),\n-                Some(node) => {\n-                    let node_prev = node.as_ref().prev;\n-                    (node_prev, Some(node))\n-                }\n+            let node_prev = match self.current {\n+                None => self.list.tail,\n+                Some(node) => node.as_ref().prev,\n             };\n-            self.list.splice_nodes(node_prev, node, spliced_node, spliced_node, 1);\n+            self.list.splice_nodes(node_prev, self.current, spliced_node, spliced_node, 1);\n             self.index += 1;\n         }\n     }\n \n-    /// Remove and return the current item, moving the cursor to the next item\n+    /// Removes the current element from the `LinkedList`.\n+    ///\n+    /// The element that was removed is returned, and the cursor is\n+    /// moved to point to the next element in the `LinkedList`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-    pub fn remove(&mut self) -> Option<T> {\n+    pub fn remove_current(&mut self) -> Option<T> {\n         let unlinked_node = self.current?;\n         unsafe {\n             self.current = unlinked_node.as_ref().next;\n             self.list.unlink_node(unlinked_node);\n             let unlinked_node = Box::from_raw(unlinked_node.as_ptr());\n-            Some((*unlinked_node).element)\n+            Some(unlinked_node.element)\n         }\n     }\n \n-    /// Insert `list` between the current element and the next\n+    /// Inserts the elements from the given `LinkedList` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n+    /// inserted at the start of the `LinkedList`.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn splice_after(&mut self, list: LinkedList<T>) {\n         unsafe {\n             let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n                 Some(parts) => parts,\n                 _ => return,\n             };\n-            let (node, node_next) = match self.current {\n-                None => (None, self.list.head),\n-                Some(node) => {\n-                    let node_next = node.as_ref().next;\n-                    (Some(node), node_next)\n-                }\n+            let node_next = match self.current {\n+                None => self.list.head,\n+                Some(node) => node.as_ref().next,\n             };\n-            self.list.splice_nodes(node, node_next, splice_head, splice_tail, splice_len);\n+            self.list.splice_nodes(self.current, node_next, splice_head, splice_tail, splice_len);\n             if self.current.is_none() {\n-                // The ghost element's index has increased by `splice_len`.\n-                self.index += splice_len;\n+                // The \"ghost\" non-element's index has changed.\n+                self.index = self.list.len;\n             }\n         }\n     }\n \n-    /// Insert `list` between the previous element and current\n+    /// Inserts the elements from the given `LinkedList` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n+    /// inserted at the end of the `LinkedList`.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn splice_before(&mut self, list: LinkedList<T>) {\n         unsafe {\n             let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n                 Some(parts) => parts,\n                 _ => return,\n             };\n-            let (node_prev, node) = match self.current {\n-                None => (self.list.tail, None),\n-                Some(node) => {\n-                    let node_prev = node.as_ref().prev;\n-                    (node_prev, Some(node))\n-                }\n+            let node_prev = match self.current {\n+                None => self.list.tail,\n+                Some(node) => node.as_ref().prev,\n             };\n-            self.list.splice_nodes(node_prev, node, splice_head, splice_tail, splice_len);\n+            self.list.splice_nodes(node_prev, self.current, splice_head, splice_tail, splice_len);\n             self.index += splice_len;\n         }\n     }\n \n-    /// Split the list in two after the current element\n-    /// The returned list consists of all elements following the current one.\n-    // note: consuming the cursor is not necessary here, but it makes sense\n-    // given the interface\n+    /// Splits the list into two after the current element. This will return a\n+    /// new list consisting of everything after the cursor, with the original\n+    /// list retaining everything before.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n+    /// of the `LinkedList` are moved.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn split_after(self) -> LinkedList<T> {\n         let split_off_idx = if self.index == self.list.len { 0 } else { self.index + 1 };\n-        unsafe {\n-            let split_off_node = self.current;\n-            self.list.split_off_after_node(split_off_node, split_off_idx)\n-        }\n+        unsafe { self.list.split_off_after_node(self.current, split_off_idx) }\n     }\n-    /// Split the list in two before the current element\n+\n+    /// Splits the list into two before the current element. This will return a\n+    /// new list consisting of everything before the cursor, with the original\n+    /// list retaining everything after.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n+    /// of the `LinkedList` are moved.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn split_before(self) -> LinkedList<T> {\n         let split_off_idx = self.index;\n-        unsafe {\n-            let split_off_node = match self.current {\n-                Some(node) => node.as_ref().prev,\n-                None => self.list.tail,\n-            };\n-            self.list.split_off_after_node(split_off_node, split_off_idx)\n-        }\n+        unsafe { self.list.split_off_before_node(self.current, split_off_idx) }\n     }\n }\n "}, {"sha": "29eb1b4abd73259860516deaccb2e7baa4512af6", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/091ba6daa0a0a528b5d9fc816529a9bb25503960/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/091ba6daa0a0a528b5d9fc816529a9bb25503960/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=091ba6daa0a0a528b5d9fc816529a9bb25503960", "patch": "@@ -362,16 +362,16 @@ fn test_cursor_mut_insert() {\n     assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[10, 7, 1, 8, 2, 3, 4, 5, 6, 9]);\n     let mut cursor = m.cursor_mut();\n     cursor.move_prev();\n-    assert_eq!(cursor.remove(), None);\n+    assert_eq!(cursor.remove_current(), None);\n     cursor.move_next();\n     cursor.move_next();\n-    assert_eq!(cursor.remove(), Some(7));\n+    assert_eq!(cursor.remove_current(), Some(7));\n     cursor.move_prev();\n     cursor.move_prev();\n     cursor.move_prev();\n-    assert_eq!(cursor.remove(), Some(9));\n+    assert_eq!(cursor.remove_current(), Some(9));\n     cursor.move_next();\n-    assert_eq!(cursor.remove(), Some(10));\n+    assert_eq!(cursor.remove_current(), Some(10));\n     check_links(&m);\n     assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[1, 8, 2, 3, 4, 5, 6]);\n     let mut cursor = m.cursor_mut();\n@@ -389,7 +389,8 @@ fn test_cursor_mut_insert() {\n     let mut cursor = m.cursor_mut();\n     cursor.move_prev();\n     let tmp = cursor.split_before();\n-    assert_eq!(tmp.into_iter().collect::<Vec<_>>(), &[]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+    m = tmp;\n     let mut cursor = m.cursor_mut();\n     cursor.move_next();\n     cursor.move_next();"}]}