{"sha": "479eb3bd2b538c9108880d1b6cafef648a2c8b12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3OWViM2JkMmI1MzhjOTEwODg4MGQxYjZjYWZlZjY0OGEyYzhiMTI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-28T08:33:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-02T12:30:09Z"}, "message": "support for basic (non-overlapping) 2-phase borrows", "tree": {"sha": "48cf995dcd38140752ea2a3682dfb9dfe997207f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48cf995dcd38140752ea2a3682dfb9dfe997207f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/479eb3bd2b538c9108880d1b6cafef648a2c8b12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/479eb3bd2b538c9108880d1b6cafef648a2c8b12", "html_url": "https://github.com/rust-lang/rust/commit/479eb3bd2b538c9108880d1b6cafef648a2c8b12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/479eb3bd2b538c9108880d1b6cafef648a2c8b12/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "819a5bc1293ccd680c670e0bd1c92573d07bd088", "url": "https://api.github.com/repos/rust-lang/rust/commits/819a5bc1293ccd680c670e0bd1c92573d07bd088", "html_url": "https://github.com/rust-lang/rust/commit/819a5bc1293ccd680c670e0bd1c92573d07bd088"}], "stats": {"total": 105, "additions": 93, "deletions": 12}, "files": [{"sha": "165b152900316b88834947d17a27812b0fff4b16", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/479eb3bd2b538c9108880d1b6cafef648a2c8b12/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479eb3bd2b538c9108880d1b6cafef648a2c8b12/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=479eb3bd2b538c9108880d1b6cafef648a2c8b12", "patch": "@@ -525,6 +525,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn retag(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         fn_entry: bool,\n+        two_phase: bool,\n         place: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n         if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n@@ -535,7 +536,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             // uninitialized data.\n              Ok(())\n         } else {\n-            ecx.retag(fn_entry, place)\n+            ecx.retag(fn_entry, two_phase, place)\n         }\n     }\n "}, {"sha": "3ea434f00f79df4edaf9e6f598ad279d8893931c", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/479eb3bd2b538c9108880d1b6cafef648a2c8b12/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479eb3bd2b538c9108880d1b6cafef648a2c8b12/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=479eb3bd2b538c9108880d1b6cafef648a2c8b12", "patch": "@@ -8,7 +8,7 @@ use rustc::hir::{Mutability, MutMutable, MutImmutable};\n use crate::{\n     EvalResult, EvalErrorKind, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n     MemoryKind, MiriMemoryKind, RangeMap, AllocId, Allocation, AllocationExtra,\n-    Pointer, MemPlace, Scalar, Immediate, ImmTy, PlaceTy, MPlaceTy,\n+    Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n pub type Timestamp = u64;\n@@ -534,19 +534,21 @@ pub trait EvalContextExt<'tcx> {\n         size: Size,\n         fn_barrier: bool,\n         new_bor: Borrow\n-    ) -> EvalResult<'tcx, Pointer<Borrow>>;\n+    ) -> EvalResult<'tcx>;\n \n     /// Retag an indidual pointer, returning the retagged version.\n     fn retag_reference(\n         &mut self,\n         ptr: ImmTy<'tcx, Borrow>,\n         mutbl: Mutability,\n         fn_barrier: bool,\n+        two_phase: bool,\n     ) -> EvalResult<'tcx, Immediate<Borrow>>;\n \n     fn retag(\n         &mut self,\n         fn_entry: bool,\n+        two_phase: bool,\n         place: PlaceTy<'tcx, Borrow>\n     ) -> EvalResult<'tcx>;\n \n@@ -644,9 +646,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         size: Size,\n         fn_barrier: bool,\n         new_bor: Borrow\n-    ) -> EvalResult<'tcx, Pointer<Borrow>> {\n+    ) -> EvalResult<'tcx> {\n         let ptr = place.ptr.to_ptr()?;\n-        let new_ptr = Pointer::new_with_tag(ptr.alloc_id, ptr.offset, new_bor);\n         let barrier = if fn_barrier { Some(self.frame().extra) } else { None };\n         trace!(\"reborrow: Creating new reference for {:?} (pointee {}): {:?}\",\n             ptr, place.layout.ty, new_bor);\n@@ -666,14 +667,15 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n             let kind = if new_bor.is_unique() { RefKind::Unique } else { RefKind::Raw };\n             alloc.extra.reborrow(ptr, size, barrier, new_bor, kind)?;\n         }\n-        Ok(new_ptr)\n+        Ok(())\n     }\n \n     fn retag_reference(\n         &mut self,\n         val: ImmTy<'tcx, Borrow>,\n         mutbl: Mutability,\n         fn_barrier: bool,\n+        two_phase: bool,\n     ) -> EvalResult<'tcx, Immediate<Borrow>> {\n         // We want a place for where the ptr *points to*, so we get one.\n         let place = self.ref_to_mplace(val)?;\n@@ -693,16 +695,24 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         };\n \n         // Reborrow.\n-        let new_ptr = self.reborrow(place, size, fn_barrier, new_bor)?;\n+        self.reborrow(place, size, fn_barrier, new_bor)?;\n+        let new_place = place.with_tag(new_bor);\n+        // Handle two-phase borrows.\n+        if two_phase {\n+            // We immediately share it, to allow read accesses\n+            let two_phase_time = self.machine.stacked_borrows.increment_clock();\n+            let two_phase_bor = Borrow::Shr(Some(two_phase_time));\n+            self.reborrow(new_place, size, /*fn_barrier*/false, two_phase_bor)?;\n+        }\n \n-        // Return new ptr\n-        let new_place = MemPlace { ptr: Scalar::Ptr(new_ptr), ..*place };\n+        // Return new ptr.\n         Ok(new_place.to_ref())\n     }\n \n     fn retag(\n         &mut self,\n         fn_entry: bool,\n+        two_phase: bool,\n         place: PlaceTy<'tcx, Borrow>\n     ) -> EvalResult<'tcx> {\n         // Determine mutability and whether to add a barrier.\n@@ -725,19 +735,20 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         if let Some((mutbl, barrier)) = qualify(place.layout.ty, fn_entry) {\n             // fast path\n             let val = self.read_immediate(self.place_to_op(place)?)?;\n-            let val = self.retag_reference(val, mutbl, barrier)?;\n+            let val = self.retag_reference(val, mutbl, barrier, two_phase)?;\n             self.write_immediate(val, place)?;\n             return Ok(());\n         }\n         let place = self.force_allocation(place)?;\n \n-        let mut visitor = RetagVisitor { ecx: self, fn_entry };\n+        let mut visitor = RetagVisitor { ecx: self, fn_entry, two_phase };\n         visitor.visit_value(place)?;\n \n         // The actual visitor\n         struct RetagVisitor<'ecx, 'a, 'mir, 'tcx> {\n             ecx: &'ecx mut MiriEvalContext<'a, 'mir, 'tcx>,\n             fn_entry: bool,\n+            two_phase: bool,\n         }\n         impl<'ecx, 'a, 'mir, 'tcx>\n             MutValueVisitor<'a, 'mir, 'tcx, Evaluator<'tcx>>\n@@ -758,7 +769,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n                 // making it useless.\n                 if let Some((mutbl, barrier)) = qualify(place.layout.ty, self.fn_entry) {\n                     let val = self.ecx.read_immediate(place.into())?;\n-                    let val = self.ecx.retag_reference(val, mutbl, barrier)?;\n+                    let val = self.ecx.retag_reference(val, mutbl, barrier, self.two_phase)?;\n                     self.ecx.write_immediate(val, place.into())?;\n                 }\n                 Ok(())"}, {"sha": "0b2a7d53c8554c63d47197071d9bedc0d1e71b3f", "filename": "tests/run-pass/2phase.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/479eb3bd2b538c9108880d1b6cafef648a2c8b12/tests%2Frun-pass%2F2phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479eb3bd2b538c9108880d1b6cafef648a2c8b12/tests%2Frun-pass%2F2phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2F2phase.rs?ref=479eb3bd2b538c9108880d1b6cafef648a2c8b12", "patch": "@@ -0,0 +1,69 @@\n+#![feature(nll)]\n+\n+trait S: Sized {\n+    fn tpb(&mut self, _s: Self) {}\n+}\n+\n+impl S for i32 {}\n+\n+fn two_phase1() {\n+    let mut x = 3;\n+    x.tpb(x);\n+}\n+\n+fn two_phase2() {\n+    let mut v = vec![];\n+    v.push(v.len());\n+}\n+\n+/*\n+fn two_phase_overlapping1() {\n+    let mut x = vec![];\n+    let p = &x;\n+    x.push(p.len());\n+}\n+\n+fn two_phase_overlapping2() {\n+    use std::ops::AddAssign;\n+    let mut x = 1;\n+    let l = &x;\n+    x.add_assign(x + *l);\n+}\n+*/\n+\n+fn match_two_phase() {\n+    let mut x = 3;\n+    match x {\n+        ref mut y if { let _val = x; let _val = *y; true } => {},\n+        _ => (),\n+    }\n+}\n+\n+fn with_interior_mutability() {\n+    use std::cell::Cell;\n+\n+    trait Thing: Sized {\n+        fn do_the_thing(&mut self, _s: i32) {}\n+    }\n+\n+    impl<T> Thing for Cell<T> {}\n+\n+    let mut x = Cell::new(1);\n+    let l = &x;\n+    x\n+        .do_the_thing({\n+            x.set(3);\n+            l.set(4);\n+            x.get() + l.get()\n+        })\n+    ;\n+}\n+\n+fn main() {\n+    two_phase1();\n+    two_phase2();\n+    //two_phase_overlapping1();\n+    //two_phase_overlapping2();\n+    match_two_phase();\n+    with_interior_mutability();\n+}"}]}