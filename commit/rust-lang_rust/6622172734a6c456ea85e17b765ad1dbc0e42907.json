{"sha": "6622172734a6c456ea85e17b765ad1dbc0e42907", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MjIxNzI3MzRhNmM0NTZlYTg1ZTE3Yjc2NWFkMWRiYzBlNDI5MDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-29T03:42:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-29T03:42:38Z"}, "message": "Auto merge of #54278 - eddyb:spanned-generic-predicates, r=nikomatsakis\n\nrustc: keep a Span for each predicate in ty::GenericPredicates.\n\nThis should allow finer-grained diagnostics, including migration suggestions for #54090.\n(Note that I haven't changed most of the users of `predicates_of` to use the new spans)\n\nr? @nikomatsakis", "tree": {"sha": "7d3876e2e7d1e88a7ccbc4976645d9ae550d323a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d3876e2e7d1e88a7ccbc4976645d9ae550d323a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6622172734a6c456ea85e17b765ad1dbc0e42907", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6622172734a6c456ea85e17b765ad1dbc0e42907", "html_url": "https://github.com/rust-lang/rust/commit/6622172734a6c456ea85e17b765ad1dbc0e42907", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6622172734a6c456ea85e17b765ad1dbc0e42907/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0a6e43755f6e4126831f7553102350374fa99ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0a6e43755f6e4126831f7553102350374fa99ad", "html_url": "https://github.com/rust-lang/rust/commit/a0a6e43755f6e4126831f7553102350374fa99ad"}, {"sha": "7020326bea4803fe02c9a7f34c264dcf3a034c3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7020326bea4803fe02c9a7f34c264dcf3a034c3c", "html_url": "https://github.com/rust-lang/rust/commit/7020326bea4803fe02c9a7f34c264dcf3a034c3c"}], "stats": {"total": 569, "additions": 272, "deletions": 297}, "files": [{"sha": "e1db295b7e14d6e10dcfa3fd006ccbb5ff3b1403", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -297,12 +297,15 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let assoc_item = tcx.associated_item(assoc_item_def_id);\n         let trait_def_id = assoc_item.container.assert_trait();\n-        let trait_predicates = tcx.predicates_of(trait_def_id);\n+        let trait_predicates = tcx.predicates_of(trait_def_id).predicates\n+            .into_iter()\n+            .map(|(p, _)| p)\n+            .collect();\n         let identity_substs = Substs::identity_for_item(tcx, assoc_item_def_id);\n         let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n         self.collect_outlives_from_predicate_list(\n             move |ty| ty == identity_proj,\n-            traits::elaborate_predicates(tcx, trait_predicates.predicates),\n+            traits::elaborate_predicates(tcx, trait_predicates),\n         ).map(|b| b.1)\n     }\n "}, {"sha": "9e9cdc69441cd16d4617b6d9ab0bd0240860f0dc", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -96,10 +96,10 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n \n     let header = ty::ImplHeader {\n         impl_def_id,\n-        self_ty: tcx.type_of(impl_def_id),\n-        trait_ref: tcx.impl_trait_ref(impl_def_id),\n-        predicates: tcx.predicates_of(impl_def_id).predicates\n-    }.subst(tcx, impl_substs);\n+        self_ty: tcx.type_of(impl_def_id).subst(tcx, impl_substs),\n+        trait_ref: tcx.impl_trait_ref(impl_def_id).subst(tcx, impl_substs),\n+        predicates: tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs).predicates,\n+    };\n \n     let Normalized { value: mut header, obligations } =\n         traits::normalize(selcx, param_env, ObligationCause::dummy(), &header);"}, {"sha": "6b1092814a4043616ab8d119d5078c6c7c70359b", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -816,11 +816,10 @@ fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                                                       key: (DefId, &'tcx Substs<'tcx>))\n                                                       -> bool\n {\n-    use ty::subst::Subst;\n     debug!(\"substitute_normalize_and_test_predicates(key={:?})\",\n            key);\n \n-    let predicates = tcx.predicates_of(key.0).predicates.subst(tcx, key.1);\n+    let predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n     let result = normalize_and_test_predicates(tcx, predicates);\n \n     debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\","}, {"sha": "d5942e738fdd9ad6a334e9b9ed69eea92b10defd", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -179,7 +179,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         predicates\n             .predicates\n             .into_iter()\n-            .map(|predicate| predicate.subst_supertrait(self, &trait_ref))\n+            .map(|(predicate, _)| predicate.subst_supertrait(self, &trait_ref))\n             .any(|predicate| {\n                 match predicate {\n                     ty::Predicate::Trait(ref data) => {\n@@ -311,7 +311,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if self.predicates_of(method.def_id).predicates.into_iter()\n                 // A trait object can't claim to live more than the concrete type,\n                 // so outlives predicates will always hold.\n-                .filter(|p| p.to_opt_type_outlives().is_none())\n+                .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n                 .collect::<Vec<_>>()\n                 // Do a shallow visit so that `contains_illegal_self_type_reference`\n                 // may apply it's custom visiting."}, {"sha": "ab71d13ab0686d1818257c8170ed3c3d456eb439", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -3401,7 +3401,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // that order.\n         let predicates = tcx.predicates_of(def_id);\n         assert_eq!(predicates.parent, None);\n-        let mut predicates: Vec<_> = predicates.predicates.iter().flat_map(|predicate| {\n+        let mut predicates: Vec<_> = predicates.predicates.iter().flat_map(|(predicate, _)| {\n             let predicate = normalize_with_depth(self, param_env, cause.clone(), recursion_depth,\n                                                  &predicate.subst(tcx, substs));\n             predicate.obligations.into_iter().chain("}, {"sha": "bd6c2982065ef1acfc05be875a0291dc5f94d903", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -428,7 +428,7 @@ fn to_pretty_impl_header(tcx: TyCtxt, impl_def_id: DefId) -> Option<String> {\n     let mut pretty_predicates = Vec::with_capacity(\n         predicates.len() + types_without_default_bounds.len());\n \n-    for p in predicates {\n+    for (p, _) in predicates {\n         if let Some(poly_trait_ref) = p.to_opt_poly_trait_ref() {\n             if Some(poly_trait_ref.def_id()) == sized_trait {\n                 types_without_default_bounds.remove(poly_trait_ref.self_ty());"}, {"sha": "7c273fb14db54fea2502510cb86d88583328b318", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -137,7 +137,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 let mut predicates: Vec<_> =\n                     predicates.predicates\n                               .iter()\n-                              .map(|p| p.subst_supertrait(tcx, &data.to_poly_trait_ref()))\n+                              .map(|(p, _)| p.subst_supertrait(tcx, &data.to_poly_trait_ref()))\n                               .collect();\n \n                 debug!(\"super_predicates: data={:?} predicates={:?}\",\n@@ -311,7 +311,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n         self.stack.extend(\n             predicates.predicates\n                       .iter()\n-                      .filter_map(|p| p.to_opt_poly_trait_ref())\n+                      .filter_map(|(p, _)| p.to_opt_poly_trait_ref())\n                       .map(|t| t.def_id())\n                       .filter(|&super_def_id| visited.insert(super_def_id)));\n         Some(def_id)"}, {"sha": "45280402e489be43d71963999e2ce06a4d8a480e", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -109,8 +109,9 @@ pub fn encode_predicates<'tcx, E, C>(encoder: &mut E,\n {\n     predicates.parent.encode(encoder)?;\n     predicates.predicates.len().encode(encoder)?;\n-    for predicate in &predicates.predicates {\n-        encode_with_shorthand(encoder, predicate, &cache)?\n+    for (predicate, span) in &predicates.predicates {\n+        encode_with_shorthand(encoder, predicate, &cache)?;\n+        span.encode(encoder)?;\n     }\n     Ok(())\n }\n@@ -178,15 +179,16 @@ pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n         parent: Decodable::decode(decoder)?,\n         predicates: (0..decoder.read_usize()?).map(|_| {\n                 // Handle shorthands first, if we have an usize > 0x80.\n-                if decoder.positioned_at_shorthand() {\n+                let predicate = if decoder.positioned_at_shorthand() {\n                     let pos = decoder.read_usize()?;\n                     assert!(pos >= SHORTHAND_OFFSET);\n                     let shorthand = pos - SHORTHAND_OFFSET;\n \n                     decoder.with_position(shorthand, ty::Predicate::decode)\n                 } else {\n                     ty::Predicate::decode(decoder)\n-                }\n+                }?;\n+                Ok((predicate, Decodable::decode(decoder)?))\n             })\n             .collect::<Result<Vec<_>, _>>()?,\n     })"}, {"sha": "df9335e909bc5e3d3f64950a0a97aae9bae633d2", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -982,7 +982,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n #[derive(Clone, Default)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n-    pub predicates: Vec<Predicate<'tcx>>,\n+    pub predicates: Vec<(Predicate<'tcx>, Span)>,\n }\n \n impl<'tcx> serialize::UseSpecializedEncodable for GenericPredicates<'tcx> {}\n@@ -998,7 +998,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                            -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n-            predicates: self.predicates.subst(tcx, substs)\n+            predicates: self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)).collect(),\n         }\n     }\n \n@@ -1008,7 +1008,9 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         if let Some(def_id) = self.parent {\n             tcx.predicates_of(def_id).instantiate_into(tcx, instantiated, substs);\n         }\n-        instantiated.predicates.extend(self.predicates.iter().map(|p| p.subst(tcx, substs)))\n+        instantiated.predicates.extend(\n+            self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)),\n+        );\n     }\n \n     pub fn instantiate_identity(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n@@ -1023,7 +1025,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         if let Some(def_id) = self.parent {\n             tcx.predicates_of(def_id).instantiate_identity_into(tcx, instantiated);\n         }\n-        instantiated.predicates.extend(&self.predicates)\n+        instantiated.predicates.extend(self.predicates.iter().map(|&(p, _)| p))\n     }\n \n     pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -1032,7 +1034,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     {\n         assert_eq!(self.parent, None);\n         InstantiatedPredicates {\n-            predicates: self.predicates.iter().map(|pred| {\n+            predicates: self.predicates.iter().map(|(pred, _)| {\n                 pred.subst_supertrait(tcx, poly_trait_ref)\n             }).collect()\n         }\n@@ -2351,7 +2353,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     substs: tcx.mk_substs_trait(ty, &[])\n                 }).to_predicate();\n                 let predicates = tcx.predicates_of(self.did).predicates;\n-                if predicates.into_iter().any(|p| p == sized_predicate) {\n+                if predicates.into_iter().any(|(p, _)| p == sized_predicate) {\n                     vec![]\n                 } else {\n                     vec![ty]"}, {"sha": "7eda6e94dd0715f5a4cca9c7f981aa24c1385915", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1736,8 +1736,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir.local_def_id(item.id);\n             let predicates = cx.tcx.predicates_of(def_id);\n-            for predicate in &predicates.predicates {\n-                let predicate_kind_name = match *predicate {\n+            for &(predicate, span) in &predicates.predicates {\n+                let predicate_kind_name = match predicate {\n                     Trait(..) => \"Trait\",\n                     TypeOutlives(..) |\n                     RegionOutlives(..) => \"Lifetime\",\n@@ -1755,7 +1755,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n                 if predicate.is_global() {\n                     cx.span_lint(\n                         TRIVIAL_BOUNDS,\n-                        item.span,\n+                        span,\n                         &format!(\"{} bound {} does not depend on any type \\\n                                 or lifetime parameters\", predicate_kind_name, predicate),\n                     );"}, {"sha": "98420115d75d73afae9ee9bdd9b4913be9d563f3", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -15,7 +15,7 @@ pub fn is_min_const_fn(\n     let mut current = def_id;\n     loop {\n         let predicates = tcx.predicates_of(current);\n-        for predicate in &predicates.predicates {\n+        for (predicate, _) in &predicates.predicates {\n             match predicate {\n                 | Predicate::RegionOutlives(_)\n                 | Predicate::TypeOutlives(_)"}, {"sha": "1fe370b44c5bcf33cbb4ac52254b50eb78a6be8a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -434,7 +434,7 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n \n     fn predicates(&mut self) -> &mut Self {\n         let predicates = self.ev.tcx.predicates_of(self.item_def_id);\n-        for predicate in &predicates.predicates {\n+        for (predicate, _) in &predicates.predicates {\n             predicate.visit_with(self);\n             match predicate {\n                 &ty::Predicate::Trait(poly_predicate) => {\n@@ -781,7 +781,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             if self.check_trait_ref(*principal.skip_binder()) {\n                 return;\n             }\n-            for poly_predicate in projections {\n+            for (poly_predicate, _) in projections {\n                 let tcx = self.tcx;\n                 if self.check_trait_ref(poly_predicate.skip_binder().projection_ty.trait_ref(tcx)) {\n                     return;\n@@ -956,7 +956,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ty::Opaque(def_id, ..) => {\n-                for predicate in &self.tcx.predicates_of(def_id).predicates {\n+                for (predicate, _) in &self.tcx.predicates_of(def_id).predicates {\n                     let trait_ref = match *predicate {\n                         ty::Predicate::Trait(ref poly_trait_predicate) => {\n                             Some(poly_trait_predicate.skip_binder().trait_ref)\n@@ -1387,7 +1387,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n         // for the inferred outlives rules; see\n         // `src/test/ui/rfc-2093-infer-outlives/privacy.rs`.\n         let predicates = self.tcx.explicit_predicates_of(self.item_def_id);\n-        for predicate in &predicates.predicates {\n+        for (predicate, _) in &predicates.predicates {\n             predicate.visit_with(self);\n             match predicate {\n                 &ty::Predicate::Trait(poly_predicate) => {"}, {"sha": "ad724babe49fb69aa7e4e7f426876df7f21650a0", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -260,7 +260,10 @@ fn program_clauses_for_trait<'a, 'tcx>(\n \n     let clauses = iter::once(Clause::ForAll(ty::Binder::dummy(implemented_from_env)));\n \n-    let where_clauses = &tcx.predicates_defined_on(def_id).predicates;\n+    let where_clauses = &tcx.predicates_defined_on(def_id).predicates\n+        .into_iter()\n+        .map(|(wc, _)| wc.lower())\n+        .collect::<Vec<_>>();\n \n     // Rule Implied-Bound-From-Trait\n     //\n@@ -273,8 +276,8 @@ fn program_clauses_for_trait<'a, 'tcx>(\n \n     // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`, for each where clause WC\n     let implied_bound_clauses = where_clauses\n-        .into_iter()\n-        .map(|wc| wc.lower())\n+        .iter()\n+        .cloned()\n \n         // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`\n         .map(|wc| wc.map_bound(|goal| ProgramClause {\n@@ -296,8 +299,8 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     let wf_conditions = iter::once(ty::Binder::dummy(trait_pred.lower()))\n         .chain(\n             where_clauses\n-                .into_iter()\n-                .map(|wc| wc.lower())\n+                .iter()\n+                .cloned()\n                 .map(|wc| wc.map_bound(|goal| goal.into_well_formed_goal()))\n         );\n \n@@ -338,7 +341,10 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     let trait_pred = ty::TraitPredicate { trait_ref }.lower();\n \n     // `WC`\n-    let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n+    let where_clauses = tcx.predicates_of(def_id).predicates\n+        .into_iter()\n+        .map(|(wc, _)| wc.lower())\n+        .collect::<Vec<_>>();\n \n     // `Implemented(A0: Trait<A1..An>) :- WC`\n     let clause = ProgramClause {\n@@ -370,7 +376,10 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n     let ty = tcx.type_of(def_id);\n \n     // `WC`\n-    let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n+    let where_clauses = tcx.predicates_of(def_id).predicates\n+        .into_iter()\n+        .map(|(wc, _)| wc.lower())\n+        .collect::<Vec<_>>();\n \n     // `WellFormed(Ty<...>) :- WC1, ..., WCm`\n     let well_formed = ProgramClause {"}, {"sha": "057a586e9ac98a3f4ec9b8529a0524d212ea5edc", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -693,7 +693,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>,\n+        poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n         speculative: bool)\n         -> ty::PolyTraitRef<'tcx>\n     {\n@@ -716,7 +716,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             let predicate: Result<_, ErrorReported> =\n                 self.ast_type_binding_to_poly_projection_predicate(\n                     trait_ref.ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n-            predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n+            // ok to ignore Err() because ErrorReported (see above)\n+            Some((predicate.ok()?, binding.span))\n         }));\n \n         debug!(\"ast_path_to_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n@@ -727,7 +728,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     pub fn instantiate_poly_trait_ref(&self,\n         poly_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+        poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>)\n         -> ty::PolyTraitRef<'tcx>\n     {\n         self.instantiate_poly_trait_ref_inner(&poly_trait_ref.trait_ref, self_ty,\n@@ -974,7 +975,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let existential_principal = principal.map_bound(|trait_ref| {\n             self.trait_ref_to_existential(trait_ref)\n         });\n-        let existential_projections = projection_bounds.iter().map(|bound| {\n+        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n             bound.map_bound(|b| {\n                 let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n                 ty::ExistentialProjection {\n@@ -1006,7 +1007,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 .map(|item| item.def_id));\n         }\n \n-        for projection_bound in &projection_bounds {\n+        for (projection_bound, _) in &projection_bounds {\n             associated_types.remove(&projection_bound.projection_def_id());\n         }\n \n@@ -1089,7 +1090,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n \n         let bounds: Vec<_> = self.get_type_parameter_bounds(span, ty_param_def_id)\n-            .predicates.into_iter().filter_map(|p| p.to_opt_poly_trait_ref()).collect();\n+            .predicates.into_iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref()).collect();\n \n         // Check that there is exactly one way to find an associated type with the\n         // correct name.\n@@ -1701,42 +1702,41 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n // and return from functions in multiple places.\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n-    pub region_bounds: Vec<ty::Region<'tcx>>,\n-    pub implicitly_sized: bool,\n-    pub trait_bounds: Vec<ty::PolyTraitRef<'tcx>>,\n-    pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n+    pub region_bounds: Vec<(ty::Region<'tcx>, Span)>,\n+    pub implicitly_sized: Option<Span>,\n+    pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span)>,\n+    pub projection_bounds: Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n }\n \n impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n     pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, param_ty: Ty<'tcx>)\n-                      -> Vec<ty::Predicate<'tcx>>\n+                      -> Vec<(ty::Predicate<'tcx>, Span)>\n     {\n         // If it could be sized, and is, add the sized predicate\n-        let sized_predicate = if self.implicitly_sized {\n+        let sized_predicate = self.implicitly_sized.and_then(|span| {\n             tcx.lang_items().sized_trait().map(|sized| {\n                 let trait_ref = ty::TraitRef {\n                     def_id: sized,\n                     substs: tcx.mk_substs_trait(param_ty, &[])\n                 };\n-                trait_ref.to_predicate()\n+                (trait_ref.to_predicate(), span)\n             })\n-        } else {\n-            None\n-        };\n+        });\n \n         sized_predicate.into_iter().chain(\n-            self.region_bounds.iter().map(|&region_bound| {\n+            self.region_bounds.iter().map(|&(region_bound, span)| {\n                 // account for the binder being introduced below; no need to shift `param_ty`\n                 // because, at present at least, it can only refer to early-bound regions\n                 let region_bound = tcx.mk_region(ty::fold::shift_region(*region_bound, 1));\n-                ty::Binder::dummy(ty::OutlivesPredicate(param_ty, region_bound)).to_predicate()\n+                let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n+                (ty::Binder::dummy(outlives).to_predicate(), span)\n             }).chain(\n-                self.trait_bounds.iter().map(|bound_trait_ref| {\n-                    bound_trait_ref.to_predicate()\n+                self.trait_bounds.iter().map(|&(bound_trait_ref, span)| {\n+                    (bound_trait_ref.to_predicate(), span)\n                 })\n             ).chain(\n-                self.projection_bounds.iter().map(|projection| {\n-                    projection.to_predicate()\n+                self.projection_bounds.iter().map(|&(projection, span)| {\n+                    (projection.to_predicate(), span)\n                 })\n             )\n         ).collect()"}, {"sha": "b8544177bbbbeeb960cf99bfb1170976b848a232", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -212,7 +212,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     // just to look for all the predicates directly.\n \n     assert_eq!(dtor_predicates.parent, None);\n-    for predicate in &dtor_predicates.predicates {\n+    for (predicate, _) in &dtor_predicates.predicates {\n         // (We do not need to worry about deep analysis of type\n         // expressions etc because the Drop impls are already forced\n         // to take on a structure that is roughly an alpha-renaming of"}, {"sha": "a9354e12deb34c69cabba4ce3991c490d6883931", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1875,14 +1875,17 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         let index = generics.param_def_id_to_index[&def_id];\n         ty::GenericPredicates {\n             parent: None,\n-            predicates: self.param_env.caller_bounds.iter().filter(|predicate| {\n-                match **predicate {\n-                    ty::Predicate::Trait(ref data) => {\n-                        data.skip_binder().self_ty().is_param(index)\n+            predicates: self.param_env.caller_bounds.iter().filter_map(|&predicate| {\n+                match predicate {\n+                    ty::Predicate::Trait(ref data)\n+                    if data.skip_binder().self_ty().is_param(index) => {\n+                        // HACK(eddyb) should get the original `Span`.\n+                        let span = tcx.def_span(def_id);\n+                        Some((predicate, span))\n                     }\n-                    _ => false\n+                    _ => None\n                 }\n-            }).cloned().collect()\n+            }).collect()\n         }\n     }\n "}, {"sha": "cc1906d91d4c9bc438847f0c029e5f9e014e420d", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -460,7 +460,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n         }\n     });\n     // Now we build the substituted predicates.\n-    let default_obligations = predicates.predicates.iter().flat_map(|&pred| {\n+    let default_obligations = predicates.predicates.iter().flat_map(|&(pred, _)| {\n         struct CountParams { params: FxHashSet<u32> }\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n             fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n@@ -484,7 +484,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n         // or preds with multiple params.\n         if substituted_pred.references_error() || param_count.params.len() > 1 || has_region {\n             None\n-        } else if predicates.predicates.contains(&substituted_pred) {\n+        } else if predicates.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n             // Avoid duplication of predicates that contain no parameters, for example.\n             None\n         } else {\n@@ -674,10 +674,10 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                         \"check_existential_types may define. adding predicates: {:#?}\",\n                         predicates,\n                     );\n-                    for &pred in predicates.predicates.iter() {\n+                    for &(pred, _) in predicates.predicates.iter() {\n                         let substituted_pred = pred.subst(fcx.tcx, substs);\n                         // Avoid duplication of predicates that contain no parameters, for example.\n-                        if !predicates.predicates.contains(&substituted_pred) {\n+                        if !predicates.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n                             substituted_predicates.push(substituted_pred);\n                         }\n                     }\n@@ -806,7 +806,7 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         .collect();\n \n     identify_constrained_type_params(tcx,\n-                                     ty_predicates.predicates.as_slice(),\n+                                     &ty_predicates,\n                                      None,\n                                      &mut constrained_parameters);\n \n@@ -874,7 +874,10 @@ fn check_false_global_bounds<'a, 'gcx, 'tcx>(\n     let empty_env = ty::ParamEnv::empty();\n \n     let def_id = fcx.tcx.hir.local_def_id(id);\n-    let predicates = fcx.tcx.predicates_of(def_id).predicates;\n+    let predicates = fcx.tcx.predicates_of(def_id).predicates\n+        .into_iter()\n+        .map(|(p, _)| p)\n+        .collect();\n     // Check elaborated bounds\n     let implied_obligations = traits::elaborate_predicates(fcx.tcx, predicates);\n "}, {"sha": "3909e4bf86a6c22865cfbe835f9384a32f8d66e7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -56,6 +56,8 @@ use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::GenericParamKind;\n use rustc::hir::{self, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n \n+use std::iter;\n+\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n@@ -292,9 +294,10 @@ fn type_param_predicates<'a, 'tcx>(\n                 ItemKind::Trait(_, _, ref generics, ..) => {\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_node_id {\n+                        let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n                         result\n                             .predicates\n-                            .push(ty::TraitRef::identity(tcx, item_def_id).to_predicate());\n+                            .push((identity_trait_ref.to_predicate(), item.span));\n                     }\n                     generics\n                 }\n@@ -327,7 +330,7 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n         ast_generics: &hir::Generics,\n         param_id: ast::NodeId,\n         ty: Ty<'tcx>,\n-    ) -> Vec<ty::Predicate<'tcx>> {\n+    ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n         let from_ty_params = ast_generics\n             .params\n             .iter()\n@@ -705,8 +708,10 @@ fn super_predicates_of<'a, 'tcx>(\n \n     // Now require that immediate supertraits are converted,\n     // which will, in turn, reach indirect supertraits.\n-    for bound in superbounds.iter().filter_map(|p| p.to_opt_poly_trait_ref()) {\n-        tcx.at(item.span).super_predicates_of(bound.def_id());\n+    for &(pred, span) in &superbounds {\n+        if let ty::Predicate::Trait(bound) = pred {\n+            tcx.at(span).super_predicates_of(bound.def_id());\n+        }\n     }\n \n     ty::GenericPredicates {\n@@ -1584,10 +1589,10 @@ fn predicates_defined_on<'a, 'tcx>(\n     def_id: DefId,\n ) -> ty::GenericPredicates<'tcx> {\n     let explicit = tcx.explicit_predicates_of(def_id);\n-    let predicates = [\n-      &explicit.predicates[..],\n-      &tcx.inferred_outlives_of(def_id)[..],\n-    ].concat();\n+    let span = tcx.def_span(def_id);\n+    let predicates = explicit.predicates.into_iter().chain(\n+        tcx.inferred_outlives_of(def_id).iter().map(|&p| (p, span))\n+    ).collect();\n \n     ty::GenericPredicates {\n         parent: explicit.parent,\n@@ -1617,7 +1622,8 @@ fn predicates_of<'a, 'tcx>(\n         // prove that the trait applies to the types that were\n         // used, and adding the predicate into this list ensures\n         // that this is done.\n-        predicates.push(ty::TraitRef::identity(tcx, def_id).to_predicate());\n+        let span = tcx.def_span(def_id);\n+        predicates.push((ty::TraitRef::identity(tcx, def_id).to_predicate(), span));\n     }\n \n     ty::GenericPredicates { parent, predicates }\n@@ -1747,7 +1753,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n     // (see below). Recall that a default impl is not itself an impl, but rather a\n     // set of defaults that can be incorporated into another impl.\n     if let Some(trait_ref) = is_default_impl_trait {\n-        predicates.push(trait_ref.to_poly_trait_ref().to_predicate());\n+        predicates.push((trait_ref.to_poly_trait_ref().to_predicate(), tcx.def_span(def_id)));\n     }\n \n     // Collect the region predicates that were declared inline as\n@@ -1768,7 +1774,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     hir::GenericBound::Outlives(lt) => {\n                         let bound = AstConv::ast_region_to_region(&icx, &lt, None);\n                         let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound));\n-                        predicates.push(outlives.to_predicate());\n+                        predicates.push((outlives.to_predicate(), lt.span));\n                     }\n                     _ => bug!(),\n                 });\n@@ -1812,7 +1818,8 @@ fn explicit_predicates_of<'a, 'tcx>(\n                         // users who never wrote `where Type:,` themselves, to\n                         // compiler/tooling bugs from not handling WF predicates.\n                     } else {\n-                        predicates.push(ty::Predicate::WellFormed(ty));\n+                        let span = bound_pred.bounded_ty.span;\n+                        predicates.push((ty::Predicate::WellFormed(ty), span));\n                     }\n                 }\n \n@@ -1828,14 +1835,16 @@ fn explicit_predicates_of<'a, 'tcx>(\n                                 &mut projections,\n                             );\n \n-                            predicates.push(trait_ref.to_predicate());\n-                            predicates.extend(projections.iter().map(|p| p.to_predicate()));\n+                            predicates.push((trait_ref.to_predicate(), poly_trait_ref.span));\n+                            predicates.extend(projections.iter().map(|&(p, span)| {\n+                                (p.to_predicate(), span)\n+                            }));\n                         }\n \n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             let pred = ty::Binder::bind(ty::OutlivesPredicate(ty, region));\n-                            predicates.push(ty::Predicate::TypeOutlives(pred))\n+                            predicates.push((ty::Predicate::TypeOutlives(pred), lifetime.span))\n                         }\n                     }\n                 }\n@@ -1844,14 +1853,14 @@ fn explicit_predicates_of<'a, 'tcx>(\n             &hir::WherePredicate::RegionPredicate(ref region_pred) => {\n                 let r1 = AstConv::ast_region_to_region(&icx, &region_pred.lifetime, None);\n                 for bound in &region_pred.bounds {\n-                    let r2 = match bound {\n+                    let (r2, span) = match bound {\n                         hir::GenericBound::Outlives(lt) => {\n-                            AstConv::ast_region_to_region(&icx, lt, None)\n+                            (AstConv::ast_region_to_region(&icx, lt, None), lt.span)\n                         }\n                         _ => bug!(),\n                     };\n                     let pred = ty::Binder::bind(ty::OutlivesPredicate(r1, r2));\n-                    predicates.push(ty::Predicate::RegionOutlives(pred))\n+                    predicates.push((ty::Predicate::RegionOutlives(pred), span))\n                 }\n             }\n \n@@ -1940,22 +1949,25 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n \n     let mut projection_bounds = vec![];\n \n-    let mut trait_bounds: Vec<_> = trait_bounds\n-        .iter()\n-        .map(|&bound| astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds))\n-        .collect();\n+    let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n+        (astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds), bound.span)\n+    }).collect();\n \n     let region_bounds = region_bounds\n         .into_iter()\n-        .map(|r| astconv.ast_region_to_region(r, None))\n+        .map(|r| (astconv.ast_region_to_region(r, None), r.span))\n         .collect();\n \n-    trait_bounds.sort_by_key(|t| t.def_id());\n+    trait_bounds.sort_by_key(|(t, _)| t.def_id());\n \n     let implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n-        !is_unsized(astconv, ast_bounds, span)\n+        if !is_unsized(astconv, ast_bounds, span) {\n+            Some(span)\n+        } else {\n+            None\n+        }\n     } else {\n-        false\n+        None\n     };\n \n     Bounds {\n@@ -1975,21 +1987,21 @@ fn predicates_from_bound<'tcx>(\n     astconv: &dyn AstConv<'tcx, 'tcx>,\n     param_ty: Ty<'tcx>,\n     bound: &hir::GenericBound,\n-) -> Vec<ty::Predicate<'tcx>> {\n+) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n             let mut projections = Vec::new();\n             let pred = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut projections);\n-            projections\n-                .into_iter()\n-                .map(|p| p.to_predicate())\n-                .chain(Some(pred.to_predicate()))\n-                .collect()\n+            iter::once((pred.to_predicate(), tr.span)).chain(\n+                projections\n+                    .into_iter()\n+                    .map(|(p, span)| (p.to_predicate(), span))\n+            ).collect()\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::Binder::bind(ty::OutlivesPredicate(param_ty, region));\n-            vec![ty::Predicate::TypeOutlives(pred)]\n+            vec![(ty::Predicate::TypeOutlives(pred), lifetime.span)]\n         }\n         hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => vec![],\n     }"}, {"sha": "1ef599ec58f9ea716d941f5c14113a3ca8742323", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -11,6 +11,7 @@\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc::util::nodemap::FxHashSet;\n+use syntax::source_map::Span;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Parameter(pub u32);\n@@ -86,12 +87,12 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     }\n }\n \n-pub fn identify_constrained_type_params<'tcx>(tcx: TyCtxt,\n-                                              predicates: &[ty::Predicate<'tcx>],\n+pub fn identify_constrained_type_params<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                                              predicates: &ty::GenericPredicates<'tcx>,\n                                               impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                               input_parameters: &mut FxHashSet<Parameter>)\n {\n-    let mut predicates = predicates.to_owned();\n+    let mut predicates = predicates.predicates.clone();\n     setup_constraining_predicates(tcx, &mut predicates, impl_trait_ref, input_parameters);\n }\n \n@@ -137,7 +138,7 @@ pub fn identify_constrained_type_params<'tcx>(tcx: TyCtxt,\n /// by 0. I should probably pick a less tangled example, but I can't\n /// think of any.\n pub fn setup_constraining_predicates<'tcx>(tcx: TyCtxt,\n-                                           predicates: &mut [ty::Predicate<'tcx>],\n+                                           predicates: &mut [(ty::Predicate<'tcx>, Span)],\n                                            impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                            input_parameters: &mut FxHashSet<Parameter>)\n {\n@@ -169,7 +170,7 @@ pub fn setup_constraining_predicates<'tcx>(tcx: TyCtxt,\n         changed = false;\n \n         for j in i..predicates.len() {\n-            if let ty::Predicate::Projection(ref poly_projection) = predicates[j] {\n+            if let ty::Predicate::Projection(ref poly_projection) = predicates[j].0 {\n                 // Note that we can skip binder here because the impl\n                 // trait ref never contains any late-bound regions.\n                 let projection = poly_projection.skip_binder();"}, {"sha": "abb59dc9d9a3e0bc6d0f74f7dfdc3e90fd43db69", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -100,7 +100,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let mut input_parameters = ctp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n     ctp::identify_constrained_type_params(\n-        tcx, &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n+        tcx, &impl_predicates, impl_trait_ref, &mut input_parameters);\n \n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n     let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs.iter()"}, {"sha": "1de79ddf4a49f8e53445e35d1398b987cf456ed5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -392,7 +392,7 @@ pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) ->\n }\n \n pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait: &hir::TraitRef)\n-        -> (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>) {\n+        -> (ty::PolyTraitRef<'tcx>, Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>) {\n     // In case there are any projections etc, find the \"environment\"\n     // def-id that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing."}, {"sha": "75f8b78b9ecf3617c1b4e68ea3335872091efdeb", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -40,7 +40,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n             let mut required_predicates = RequiredPredicates::default();\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n-            for pred in predicates.into_iter() {\n+            for (pred, _) in predicates.into_iter() {\n                 match pred {\n                     ty::Predicate::TypeOutlives(predicate) => {\n                         let OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();"}, {"sha": "537905c3008d18d3034cead2d5f4df4283adfe69", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1571,7 +1571,9 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n             }\n         }).collect::<Vec<GenericParamDef>>();\n \n-        let mut where_predicates = preds.predicates.to_vec().clean(cx);\n+        let mut where_predicates = preds.predicates.iter()\n+            .map(|(p, _)| p.clean(cx))\n+            .collect::<Vec<_>>();\n \n         // Type parameters and have a Sized bound by default unless removed with\n         // ?Sized. Scan through the predicates and mark any type parameter with"}, {"sha": "eda522af9224597a9bdf1e3a59d137899ae323ac", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -157,7 +157,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n         return true\n     }\n     let predicates = cx.tcx.super_predicates_of(child).predicates;\n-    predicates.iter().filter_map(|pred| {\n+    predicates.iter().filter_map(|(pred, _)| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n             if pred.skip_binder().trait_ref.self_ty().is_self() {\n                 Some(pred.def_id())"}, {"sha": "1e46ce6a30f8489b0a8f9d501f5fa8fb77babb08", "filename": "src/test/ui/cycle-trait/cycle-trait-supertrait-direct.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1,8 +1,8 @@\n error[E0391]: cycle detected when computing the supertraits of `Chromosome`\n-  --> $DIR/cycle-trait-supertrait-direct.rs:13:1\n+  --> $DIR/cycle-trait-supertrait-direct.rs:13:19\n    |\n LL | trait Chromosome: Chromosome {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                   ^^^^^^^^^^\n    |\n    = note: ...which again requires computing the supertraits of `Chromosome`, completing the cycle\n "}, {"sha": "dd88a9c4d40e413261885812acd9a3d4089d11ca", "filename": "src/test/ui/cycle-trait/cycle-trait-supertrait-indirect.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1,20 +1,20 @@\n error[E0391]: cycle detected when computing the supertraits of `B`\n-  --> $DIR/cycle-trait-supertrait-indirect.rs:17:1\n+  --> $DIR/cycle-trait-supertrait-indirect.rs:17:10\n    |\n LL | trait B: C {\n-   | ^^^^^^^^^^\n+   |          ^\n    |\n note: ...which requires computing the supertraits of `C`...\n-  --> $DIR/cycle-trait-supertrait-indirect.rs:21:1\n+  --> $DIR/cycle-trait-supertrait-indirect.rs:21:10\n    |\n LL | trait C: B { }\n-   | ^^^^^^^^^^\n+   |          ^\n    = note: ...which again requires computing the supertraits of `B`, completing the cycle\n note: cycle used when computing the supertraits of `A`\n-  --> $DIR/cycle-trait-supertrait-indirect.rs:14:1\n+  --> $DIR/cycle-trait-supertrait-indirect.rs:14:10\n    |\n LL | trait A: B {\n-   | ^^^^^^^^^^\n+   |          ^\n \n error: aborting due to previous error\n "}, {"sha": "345d7b30d47b9c8906a7e4466d6f2d90c6a57b19", "filename": "src/test/ui/issues/issue-12511.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1,14 +1,14 @@\n error[E0391]: cycle detected when computing the supertraits of `t1`\n-  --> $DIR/issue-12511.rs:11:1\n+  --> $DIR/issue-12511.rs:11:12\n    |\n LL | trait t1 : t2 {\n-   | ^^^^^^^^^^^^^\n+   |            ^^\n    |\n note: ...which requires computing the supertraits of `t2`...\n-  --> $DIR/issue-12511.rs:15:1\n+  --> $DIR/issue-12511.rs:15:12\n    |\n LL | trait t2 : t1 {\n-   | ^^^^^^^^^^^^^\n+   |            ^^\n    = note: ...which again requires computing the supertraits of `t1`, completing the cycle\n \n error: aborting due to previous error"}, {"sha": "df4a6c83e50cb6fa6647f457276f332c7034c986", "filename": "src/test/ui/trivial-bounds/trivial-bounds-inconsistent-copy.stderr", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-copy.stderr?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1,41 +1,26 @@\n warning: Trait bound std::string::String: std::marker::Copy does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-copy.rs:16:1\n+  --> $DIR/trivial-bounds-inconsistent-copy.rs:16:51\n    |\n-LL | / fn copy_string(t: String) -> String where String: Copy {\n-LL | |     is_copy(&t);\n-LL | |     let x = t;\n-LL | |     drop(t);\n-LL | |     t\n-LL | | }\n-   | |_^\n+LL | fn copy_string(t: String) -> String where String: Copy {\n+   |                                                   ^^^^\n    |\n    = note: #[warn(trivial_bounds)] on by default\n \n warning: Trait bound std::string::String: std::marker::Copy does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-copy.rs:23:1\n+  --> $DIR/trivial-bounds-inconsistent-copy.rs:23:56\n    |\n-LL | / fn copy_out_string(t: &String) -> String where String: Copy {\n-LL | |     *t\n-LL | | }\n-   | |_^\n+LL | fn copy_out_string(t: &String) -> String where String: Copy {\n+   |                                                        ^^^^\n \n warning: Trait bound std::string::String: std::marker::Copy does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-copy.rs:27:1\n+  --> $DIR/trivial-bounds-inconsistent-copy.rs:27:55\n    |\n-LL | / fn copy_string_with_param<T>(x: String) where String: Copy {\n-LL | |     let y = x;\n-LL | |     let z = x;\n-LL | | }\n-   | |_^\n+LL | fn copy_string_with_param<T>(x: String) where String: Copy {\n+   |                                                       ^^^^\n \n warning: Trait bound for<'b> &'b mut i32: std::marker::Copy does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-copy.rs:33:1\n+  --> $DIR/trivial-bounds-inconsistent-copy.rs:33:76\n    |\n-LL | / fn copy_mut<'a>(t: &&'a mut i32) -> &'a mut i32 where for<'b> &'b mut i32: Copy {\n-LL | |     is_copy(t);\n-LL | |     let x = *t;\n-LL | |     drop(x);\n-LL | |     x\n-LL | | }\n-   | |_^\n+LL | fn copy_mut<'a>(t: &&'a mut i32) -> &'a mut i32 where for<'b> &'b mut i32: Copy {\n+   |                                                                            ^^^^\n "}, {"sha": "e88b71c5c5a3e2f94ed701dfceff69e5ac7b0bfd", "filename": "src/test/ui/trivial-bounds/trivial-bounds-inconsistent-projection.stderr", "status": "modified", "additions": 31, "deletions": 44, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-projection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-projection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-projection.stderr?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1,57 +1,44 @@\n warning: Trait bound B: A does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-projection.rs:29:1\n+  --> $DIR/trivial-bounds-inconsistent-projection.rs:31:8\n    |\n-LL | / fn underspecified_bound() -> u8\n-LL | | where\n-LL | |     B: A\n-LL | | {\n-LL | |     B::get_x()\n-LL | | }\n-   | |_^\n+LL |     B: A\n+   |        ^\n    |\n    = note: #[warn(trivial_bounds)] on by default\n \n warning: Trait bound B: A does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-projection.rs:36:1\n-   |\n-LL | / fn inconsistent_bound() -> i32\n-LL | | where\n-LL | |     B: A<X = i32>\n-LL | | {\n-LL | |     B::get_x()\n-LL | | }\n-   | |_^\n+  --> $DIR/trivial-bounds-inconsistent-projection.rs:38:8\n+   |\n+LL |     B: A<X = i32>\n+   |        ^^^^^^^^^^\n+\n+warning: Trait bound B: A does not depend on any type or lifetime parameters\n+  --> $DIR/trivial-bounds-inconsistent-projection.rs:45:8\n+   |\n+LL |     B: A<X = u8>\n+   |        ^^^^^^^^^\n+\n+warning: Trait bound B: A does not depend on any type or lifetime parameters\n+  --> $DIR/trivial-bounds-inconsistent-projection.rs:52:8\n+   |\n+LL |     B: A<X = i32> + A\n+   |        ^^^^^^^^^^\n \n warning: Trait bound B: A does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-projection.rs:43:1\n-   |\n-LL | / fn redundant_bound() -> u8\n-LL | | where\n-LL | |     B: A<X = u8>\n-LL | | {\n-LL | |     B::get_x()\n-LL | | }\n-   | |_^\n+  --> $DIR/trivial-bounds-inconsistent-projection.rs:52:21\n+   |\n+LL |     B: A<X = i32> + A\n+   |                     ^\n \n warning: Trait bound B: A does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-projection.rs:50:1\n-   |\n-LL | / fn inconsistent_dup_bound() -> i32\n-LL | | where\n-LL | |     B: A<X = i32> + A\n-LL | | {\n-LL | |     B::get_x()\n-LL | | }\n-   | |_^\n+  --> $DIR/trivial-bounds-inconsistent-projection.rs:59:8\n+   |\n+LL |     B: A<X = u8> + A\n+   |        ^^^^^^^^^\n \n warning: Trait bound B: A does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-projection.rs:57:1\n-   |\n-LL | / fn redundant_dup_bound() -> u8\n-LL | | where\n-LL | |     B: A<X = u8> + A\n-LL | | {\n-LL | |     B::get_x()\n-LL | | }\n-   | |_^\n+  --> $DIR/trivial-bounds-inconsistent-projection.rs:59:20\n+   |\n+LL |     B: A<X = u8> + A\n+   |                    ^\n "}, {"sha": "493646aa46f5d19c28947767fe335ac7467c50e5", "filename": "src/test/ui/trivial-bounds/trivial-bounds-inconsistent-sized.stderr", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-sized.stderr?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1,24 +1,20 @@\n warning: Trait bound str: std::marker::Sized does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-sized.rs:24:1\n+  --> $DIR/trivial-bounds-inconsistent-sized.rs:24:31\n    |\n LL | struct S(str, str) where str: Sized;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                               ^^^^^\n    |\n    = note: #[warn(trivial_bounds)] on by default\n \n warning: Trait bound for<'a> T<(dyn A + 'a)>: std::marker::Sized does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-sized.rs:26:1\n+  --> $DIR/trivial-bounds-inconsistent-sized.rs:26:45\n    |\n-LL | / fn unsized_local() where for<'a> T<A + 'a>: Sized {\n-LL | |     let x: T<A> = *(Box::new(T { x: 1 }) as Box<T<A>>);\n-LL | | }\n-   | |_^\n+LL | fn unsized_local() where for<'a> T<A + 'a>: Sized {\n+   |                                             ^^^^^\n \n warning: Trait bound str: std::marker::Sized does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-sized.rs:30:1\n+  --> $DIR/trivial-bounds-inconsistent-sized.rs:30:35\n    |\n-LL | / fn return_str() -> str where str: Sized {\n-LL | |     *\"Sized\".to_string().into_boxed_str()\n-LL | | }\n-   | |_^\n+LL | fn return_str() -> str where str: Sized {\n+   |                                   ^^^^^\n "}, {"sha": "052c45b73b9c2f724df193ccf278f8a2debbde7a", "filename": "src/test/ui/trivial-bounds/trivial-bounds-inconsistent-well-formed.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-well-formed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-well-formed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-well-formed.stderr?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1,20 +1,14 @@\n warning: Trait bound std::vec::Vec<str>: std::fmt::Debug does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-well-formed.rs:17:1\n+  --> $DIR/trivial-bounds-inconsistent-well-formed.rs:17:30\n    |\n-LL | / pub fn foo() where Vec<str>: Debug, str: Copy {\n-LL | |     let x = vec![*\"1\"];\n-LL | |     println!(\"{:?}\", x);\n-LL | | }\n-   | |_^\n+LL | pub fn foo() where Vec<str>: Debug, str: Copy {\n+   |                              ^^^^^\n    |\n    = note: #[warn(trivial_bounds)] on by default\n \n warning: Trait bound str: std::marker::Copy does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent-well-formed.rs:17:1\n+  --> $DIR/trivial-bounds-inconsistent-well-formed.rs:17:42\n    |\n-LL | / pub fn foo() where Vec<str>: Debug, str: Copy {\n-LL | |     let x = vec![*\"1\"];\n-LL | |     println!(\"{:?}\", x);\n-LL | | }\n-   | |_^\n+LL | pub fn foo() where Vec<str>: Debug, str: Copy {\n+   |                                          ^^^^\n "}, {"sha": "0cfab2fab86de3dcc8c22305c8cba50e1c68019d", "filename": "src/test/ui/trivial-bounds/trivial-bounds-inconsistent.stderr", "status": "modified", "additions": 36, "deletions": 59, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent.stderr?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1,28 +1,28 @@\n warning: Trait bound i32: Foo does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:24:1\n+  --> $DIR/trivial-bounds-inconsistent.rs:24:19\n    |\n LL | enum E where i32: Foo { V }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                   ^^^\n    |\n    = note: #[warn(trivial_bounds)] on by default\n \n warning: Trait bound i32: Foo does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:26:1\n+  --> $DIR/trivial-bounds-inconsistent.rs:26:21\n    |\n LL | struct S where i32: Foo;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     ^^^\n \n warning: Trait bound i32: Foo does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:28:1\n+  --> $DIR/trivial-bounds-inconsistent.rs:28:20\n    |\n LL | trait T where i32: Foo {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    ^^^\n \n warning: Trait bound i32: Foo does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:30:1\n+  --> $DIR/trivial-bounds-inconsistent.rs:30:20\n    |\n LL | union U where i32: Foo { f: i32 }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    ^^^\n \n warning: where clauses are not enforced in type aliases\n   --> $DIR/trivial-bounds-inconsistent.rs:32:14\n@@ -34,79 +34,56 @@ LL | type Y where i32: Foo = ();\n    = help: the clause will not be checked when the type alias is used, and should be removed\n \n warning: Trait bound i32: Foo does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:32:1\n+  --> $DIR/trivial-bounds-inconsistent.rs:32:19\n    |\n LL | type Y where i32: Foo = ();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                   ^^^\n \n warning: Trait bound i32: Foo does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:34:1\n-   |\n-LL | / impl Foo for () where i32: Foo {\n-LL | |     fn test(&self) {\n-LL | |         3i32.test();\n-LL | |         Foo::test(&4i32);\n-LL | |         generic_function(5i32);\n-LL | |     }\n-LL | | }\n-   | |_^\n+  --> $DIR/trivial-bounds-inconsistent.rs:34:28\n+   |\n+LL | impl Foo for () where i32: Foo {\n+   |                            ^^^\n \n warning: Trait bound i32: Foo does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:42:1\n-   |\n-LL | / fn f() where i32: Foo {\n-LL | |     let s = S;\n-LL | |     3i32.test();\n-LL | |     Foo::test(&4i32);\n-LL | |     generic_function(5i32);\n-LL | | }\n-   | |_^\n+  --> $DIR/trivial-bounds-inconsistent.rs:42:19\n+   |\n+LL | fn f() where i32: Foo {\n+   |                   ^^^\n \n warning: Trait bound &'static str: Foo does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:49:1\n-   |\n-LL | / fn g() where &'static str: Foo {\n-LL | |     \"Foo\".test();\n-LL | |     Foo::test(&\"Foo\");\n-LL | |     generic_function(\"Foo\");\n-LL | | }\n-   | |_^\n+  --> $DIR/trivial-bounds-inconsistent.rs:49:28\n+   |\n+LL | fn g() where &'static str: Foo {\n+   |                            ^^^\n \n warning: Trait bound str: std::marker::Sized does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:63:1\n+  --> $DIR/trivial-bounds-inconsistent.rs:63:37\n    |\n LL | struct TwoStrs(str, str) where str: Sized;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                     ^^^^^\n \n warning: Trait bound for<'a> Dst<(dyn A + 'a)>: std::marker::Sized does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:65:1\n+  --> $DIR/trivial-bounds-inconsistent.rs:65:47\n    |\n-LL | / fn unsized_local() where for<'a> Dst<A + 'a>: Sized {\n-LL | |     let x: Dst<A> = *(Box::new(Dst { x: 1 }) as Box<Dst<A>>);\n-LL | | }\n-   | |_^\n+LL | fn unsized_local() where for<'a> Dst<A + 'a>: Sized {\n+   |                                               ^^^^^\n \n warning: Trait bound str: std::marker::Sized does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:69:1\n+  --> $DIR/trivial-bounds-inconsistent.rs:69:35\n    |\n-LL | / fn return_str() -> str where str: Sized {\n-LL | |     *\"Sized\".to_string().into_boxed_str()\n-LL | | }\n-   | |_^\n+LL | fn return_str() -> str where str: Sized {\n+   |                                   ^^^^^\n \n warning: Trait bound std::string::String: std::ops::Neg does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:73:1\n+  --> $DIR/trivial-bounds-inconsistent.rs:73:46\n    |\n-LL | / fn use_op(s: String) -> String where String: ::std::ops::Neg<Output=String> {\n-LL | |     -s\n-LL | | }\n-   | |_^\n+LL | fn use_op(s: String) -> String where String: ::std::ops::Neg<Output=String> {\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: Trait bound i32: std::iter::Iterator does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-inconsistent.rs:77:1\n+  --> $DIR/trivial-bounds-inconsistent.rs:77:25\n    |\n-LL | / fn use_for() where i32: Iterator {\n-LL | |     for _ in 2i32 {}\n-LL | | }\n-   | |_^\n+LL | fn use_for() where i32: Iterator {\n+   |                         ^^^^^^^^\n "}, {"sha": "db8cbdc0932dd8cf649fffc1a6df0800034e8c7e", "filename": "src/test/ui/trivial-bounds/trivial-bounds-lint.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6622172734a6c456ea85e17b765ad1dbc0e42907/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-lint.stderr?ref=6622172734a6c456ea85e17b765ad1dbc0e42907", "patch": "@@ -1,8 +1,8 @@\n error: Trait bound i32: std::marker::Copy does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-lint.rs:15:1\n+  --> $DIR/trivial-bounds-lint.rs:15:21\n    |\n LL | struct A where i32: Copy; //~ ERROR\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     ^^^^\n    |\n note: lint level defined here\n   --> $DIR/trivial-bounds-lint.rs:13:9\n@@ -11,40 +11,40 @@ LL | #![deny(trivial_bounds)]\n    |         ^^^^^^^^^^^^^^\n \n error: Trait bound i32: X<()> does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-lint.rs:28:1\n+  --> $DIR/trivial-bounds-lint.rs:28:30\n    |\n LL | fn global_param() where i32: X<()> {} //~ ERROR\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                              ^^^^^\n \n error: Trait bound i32: Z does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-lint.rs:32:1\n+  --> $DIR/trivial-bounds-lint.rs:32:35\n    |\n LL | fn global_projection() where i32: Z<S = i32> {} //~ ERROR\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^^^^^^^^\n \n error: Lifetime bound i32 : 'static does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-lint.rs:39:1\n+  --> $DIR/trivial-bounds-lint.rs:39:34\n    |\n LL | fn global_lifetimes() where i32: 'static, &'static str: 'static {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                  ^^^^^^^\n \n error: Lifetime bound &'static str : 'static does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-lint.rs:39:1\n+  --> $DIR/trivial-bounds-lint.rs:39:57\n    |\n LL | fn global_lifetimes() where i32: 'static, &'static str: 'static {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                                         ^^^^^^^\n \n error: Lifetime bound 'static : 'static does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-lint.rs:45:1\n+  --> $DIR/trivial-bounds-lint.rs:45:37\n    |\n LL | fn global_outlives() where 'static: 'static {} //~ ERROR\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                     ^^^^^^^\n \n error: Trait bound i32: std::marker::Copy does not depend on any type or lifetime parameters\n-  --> $DIR/trivial-bounds-lint.rs:48:1\n+  --> $DIR/trivial-bounds-lint.rs:48:46\n    |\n LL | fn mixed_bounds<T: Copy>() where i32: X<T> + Copy {} //~ ERROR\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                              ^^^^\n \n error: aborting due to 7 previous errors\n "}]}