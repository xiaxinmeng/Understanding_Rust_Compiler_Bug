{"sha": "a8d32c4d1ae4b3e4276f7a97b6c6e5f95f91e67a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZDMyYzRkMWFlNGIzZTQyNzZmN2E5N2I2YzZlNWY5NWY5MWU2N2E=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-26T15:13:44Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-26T15:13:44Z"}, "message": "Merge #671\n\n671: Makre VFS slightly less super obscure r=vemoo a=matklad\n\nI've decided to better understand what we do in VFS, and this turns out to be really hard. Jugling threads and channels is one of the most unfortunately arcane bits of rust...\r\n\r\nI had some success though by flattenning the structure so that all channel & thread creation routines are on one screen. \r\n\r\nr? @vemoo \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "9e56b095a073ff3c82322302356f4d096a70afcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e56b095a073ff3c82322302356f4d096a70afcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8d32c4d1ae4b3e4276f7a97b6c6e5f95f91e67a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d32c4d1ae4b3e4276f7a97b6c6e5f95f91e67a", "html_url": "https://github.com/rust-lang/rust/commit/a8d32c4d1ae4b3e4276f7a97b6c6e5f95f91e67a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8d32c4d1ae4b3e4276f7a97b6c6e5f95f91e67a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "5af7b2f4af51291fa4a0549c549796ba0520927b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5af7b2f4af51291fa4a0549c549796ba0520927b", "html_url": "https://github.com/rust-lang/rust/commit/5af7b2f4af51291fa4a0549c549796ba0520927b"}, {"sha": "9f16892b94817d144f37dfe0081b39aacec65635", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f16892b94817d144f37dfe0081b39aacec65635", "html_url": "https://github.com/rust-lang/rust/commit/9f16892b94817d144f37dfe0081b39aacec65635"}], "stats": {"total": 617, "additions": 281, "deletions": 336}, "files": [{"sha": "d764c534aa62bea8e9f86d320cdb8317e010977a", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 215, "deletions": 56, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/a8d32c4d1ae4b3e4276f7a97b6c6e5f95f91e67a/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d32c4d1ae4b3e4276f7a97b6c6e5f95f91e67a/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=a8d32c4d1ae4b3e4276f7a97b6c6e5f95f91e67a", "patch": "@@ -1,19 +1,22 @@\n-use std::{fs, sync::Arc, thread};\n-\n-use crossbeam_channel::{Receiver, Sender};\n+use std::{\n+    fs,\n+    thread,\n+    path::{Path, PathBuf},\n+    sync::{mpsc, Arc},\n+    time::Duration,\n+};\n+use crossbeam_channel::{Receiver, Sender, unbounded, RecvError, select};\n use relative_path::RelativePathBuf;\n use thread_worker::WorkerHandle;\n use walkdir::WalkDir;\n+use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watcher};\n \n-mod watcher;\n-use watcher::Watcher;\n-\n-use crate::{RootFilter, Roots, VfsRoot};\n+use crate::{RootConfig, Roots, VfsRoot};\n \n pub(crate) enum Task {\n     AddRoot {\n         root: VfsRoot,\n-        filter: Arc<RootFilter>,\n+        config: Arc<RootConfig>,\n     },\n }\n \n@@ -39,31 +42,91 @@ pub enum TaskResult {\n     },\n }\n \n+#[derive(Debug)]\n+enum ChangeKind {\n+    Create,\n+    Write,\n+    Remove,\n+}\n+\n+const WATCHER_DELAY: Duration = Duration::from_millis(250);\n+\n pub(crate) struct Worker {\n     worker: thread_worker::Worker<Task, TaskResult>,\n     worker_handle: WorkerHandle,\n }\n \n impl Worker {\n     pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n-        let (worker, worker_handle) =\n-            thread_worker::spawn(\"vfs\", 128, move |input_receiver, output_sender| {\n-                let mut watcher = match Watcher::start(roots, output_sender.clone()) {\n-                    Ok(w) => Some(w),\n-                    Err(e) => {\n-                        log::error!(\"could not start watcher: {}\", e);\n-                        None\n+        // This is a pretty elaborate setup of threads & channels! It is\n+        // explained by the following concerns:\n+        //    * we need to burn a thread translating from notify's mpsc to\n+        //      crossbeam_channel.\n+        //    * we want to read all files from a single thread, to gurantee that\n+        //      we always get fresher versions and never go back in time.\n+        //    * we want to tear down everything neatly during shutdown.\n+        let (worker, worker_handle) = thread_worker::spawn(\n+            \"vfs\",\n+            128,\n+            // This are the channels we use to communicate with outside world.\n+            // If `input_receiver` is closed we need to tear ourselves down.\n+            // `output_sender` should not be closed unless the parent died.\n+            move |input_receiver, output_sender| {\n+                // These are `std` channels notify will send events to\n+                let (notify_sender, notify_receiver) = mpsc::channel();\n+                // These are the corresponding crossbeam channels\n+                let (watcher_sender, watcher_receiver) = unbounded();\n+\n+                let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n+                    .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n+                    .ok();\n+                // Start a silly thread to tranform between two channels\n+                let thread = thread::spawn(move || {\n+                    notify_receiver\n+                        .into_iter()\n+                        .for_each(|event| convert_notify_event(event, &watcher_sender))\n+                });\n+\n+                // Process requests from the called or notifications from\n+                // watcher until the caller says stop.\n+                loop {\n+                    select! {\n+                        // Received request from the caller. If this channel is\n+                        // closed, we should shutdown everything.\n+                        recv(input_receiver) -> t => match t {\n+                            Err(RecvError) => {\n+                                drop(input_receiver);\n+                                break\n+                            },\n+                            Ok(Task::AddRoot { root, config }) => {\n+                                watch_root(watcher.as_mut(), &output_sender, root, Arc::clone(&config));\n+                            }\n+                        },\n+                        // Watcher send us changes. If **this** channel is\n+                        // closed, the watcher has died, which indicates a bug\n+                        // -- escalate!\n+                        recv(watcher_receiver) -> event => match event {\n+                            Err(RecvError) => panic!(\"watcher is dead\"),\n+                            Ok((path, change)) => {\n+                                handle_change(watcher.as_mut(), &output_sender, &*roots, path, change);\n+                            }\n+                        },\n                     }\n-                };\n-                let res = input_receiver\n-                    .into_iter()\n-                    .filter_map(|t| handle_task(t, &mut watcher))\n-                    .try_for_each(|it| output_sender.send(it));\n-                if let Some(watcher) = watcher {\n-                    let _ = watcher.shutdown();\n                 }\n-                res.unwrap()\n-            });\n+                // Stopped the watcher\n+                drop(watcher.take());\n+                // Drain pending events: we are not inrerested in them anyways!\n+                watcher_receiver.into_iter().for_each(|_| ());\n+\n+                let res = thread.join();\n+                match &res {\n+                    Ok(()) => log::info!(\"... Watcher terminated with ok\"),\n+                    Err(_) => log::error!(\"... Watcher terminated with err\"),\n+                }\n+                res.unwrap();\n+            },\n+        );\n+\n         Worker {\n             worker,\n             worker_handle,\n@@ -84,46 +147,142 @@ impl Worker {\n     }\n }\n \n-fn handle_task(task: Task, watcher: &mut Option<Watcher>) -> Option<TaskResult> {\n-    match task {\n-        Task::AddRoot { root, filter } => {\n-            if let Some(watcher) = watcher {\n-                watcher.watch_root(&filter)\n+fn watch_root(\n+    watcher: Option<&mut RecommendedWatcher>,\n+    sender: &Sender<TaskResult>,\n+    root: VfsRoot,\n+    config: Arc<RootConfig>,\n+) {\n+    log::debug!(\"loading {} ...\", config.root.as_path().display());\n+    let files = watch_recursive(watcher, config.root.as_path(), &*config)\n+        .into_iter()\n+        .filter_map(|path| {\n+            let abs_path = path.to_path(&config.root);\n+            let text = read_to_string(&abs_path)?;\n+            Some((path, text))\n+        })\n+        .collect();\n+    sender\n+        .send(TaskResult::BulkLoadRoot { root, files })\n+        .unwrap();\n+    log::debug!(\"... loaded {}\", config.root.as_path().display());\n+}\n+\n+fn convert_notify_event(event: DebouncedEvent, sender: &Sender<(PathBuf, ChangeKind)>) {\n+    // forward relevant events only\n+    match event {\n+        DebouncedEvent::NoticeWrite(_)\n+        | DebouncedEvent::NoticeRemove(_)\n+        | DebouncedEvent::Chmod(_) => {\n+            // ignore\n+        }\n+        DebouncedEvent::Rescan => {\n+            // TODO rescan all roots\n+        }\n+        DebouncedEvent::Create(path) => {\n+            sender.send((path, ChangeKind::Create)).unwrap();\n+        }\n+        DebouncedEvent::Write(path) => {\n+            sender.send((path, ChangeKind::Write)).unwrap();\n+        }\n+        DebouncedEvent::Remove(path) => {\n+            sender.send((path, ChangeKind::Remove)).unwrap();\n+        }\n+        DebouncedEvent::Rename(src, dst) => {\n+            sender.send((src, ChangeKind::Remove)).unwrap();\n+            sender.send((dst, ChangeKind::Create)).unwrap();\n+        }\n+        DebouncedEvent::Error(err, path) => {\n+            // TODO should we reload the file contents?\n+            log::warn!(\"watcher error \\\"{}\\\", {:?}\", err, path);\n+        }\n+    }\n+}\n+\n+fn handle_change(\n+    watcher: Option<&mut RecommendedWatcher>,\n+    sender: &Sender<TaskResult>,\n+    roots: &Roots,\n+    path: PathBuf,\n+    kind: ChangeKind,\n+) {\n+    let (root, rel_path) = match roots.find(&path) {\n+        None => return,\n+        Some(it) => it,\n+    };\n+    let config = &roots[root];\n+    match kind {\n+        ChangeKind::Create => {\n+            let mut paths = Vec::new();\n+            if path.is_dir() {\n+                paths.extend(watch_recursive(watcher, &path, &config));\n+            } else {\n+                paths.push(rel_path);\n             }\n-            log::debug!(\"loading {} ...\", filter.root.as_path().display());\n-            let files = load_root(filter.as_ref());\n-            log::debug!(\"... loaded {}\", filter.root.as_path().display());\n-            Some(TaskResult::BulkLoadRoot { root, files })\n+            paths\n+                .into_iter()\n+                .filter_map(|rel_path| {\n+                    let abs_path = rel_path.to_path(&config.root);\n+                    let text = read_to_string(&abs_path)?;\n+                    Some((rel_path, text))\n+                })\n+                .try_for_each(|(path, text)| {\n+                    sender.send(TaskResult::AddSingleFile { root, path, text })\n+                })\n+                .unwrap()\n         }\n+        ChangeKind::Write => {\n+            if let Some(text) = read_to_string(&path) {\n+                sender\n+                    .send(TaskResult::ChangeSingleFile {\n+                        root,\n+                        path: rel_path,\n+                        text,\n+                    })\n+                    .unwrap();\n+            }\n+        }\n+        ChangeKind::Remove => sender\n+            .send(TaskResult::RemoveSingleFile {\n+                root,\n+                path: rel_path,\n+            })\n+            .unwrap(),\n     }\n }\n \n-fn load_root(filter: &RootFilter) -> Vec<(RelativePathBuf, String)> {\n-    let mut res = Vec::new();\n-    for entry in WalkDir::new(&filter.root)\n+fn watch_recursive(\n+    mut watcher: Option<&mut RecommendedWatcher>,\n+    dir: &Path,\n+    config: &RootConfig,\n+) -> Vec<RelativePathBuf> {\n+    let mut files = Vec::new();\n+    for entry in WalkDir::new(dir)\n         .into_iter()\n-        .filter_entry(filter.entry_filter())\n+        .filter_entry(|it| config.contains(it.path()).is_some())\n+        .filter_map(|it| it.map_err(|e| log::warn!(\"watcher error: {}\", e)).ok())\n     {\n-        let entry = match entry {\n-            Ok(entry) => entry,\n-            Err(e) => {\n-                log::warn!(\"watcher error: {}\", e);\n-                continue;\n+        if entry.file_type().is_dir() {\n+            if let Some(watcher) = &mut watcher {\n+                watch_one(watcher, entry.path());\n             }\n-        };\n-        if !entry.file_type().is_file() {\n-            continue;\n+        } else {\n+            let path = config.contains(entry.path()).unwrap();\n+            files.push(path.to_owned());\n         }\n-        let path = entry.path();\n-        let text = match fs::read_to_string(path) {\n-            Ok(text) => text,\n-            Err(e) => {\n-                log::warn!(\"watcher error: {}\", e);\n-                continue;\n-            }\n-        };\n-        let path = RelativePathBuf::from_path(path.strip_prefix(&filter.root).unwrap()).unwrap();\n-        res.push((path.to_owned(), text))\n     }\n-    res\n+    files\n+}\n+\n+fn watch_one(watcher: &mut RecommendedWatcher, dir: &Path) {\n+    match watcher.watch(dir, RecursiveMode::NonRecursive) {\n+        Ok(()) => log::debug!(\"watching \\\"{}\\\"\", dir.display()),\n+        Err(e) => log::warn!(\"could not watch \\\"{}\\\": {}\", dir.display(), e),\n+    }\n+}\n+\n+fn read_to_string(path: &Path) -> Option<String> {\n+    fs::read_to_string(&path)\n+        .map_err(|e| log::warn!(\"failed to read file {}\", e))\n+        .ok()\n }"}, {"sha": "ff6775f59402cf13c65bebf496d78109aed917f8", "filename": "crates/ra_vfs/src/io/watcher.rs", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/5af7b2f4af51291fa4a0549c549796ba0520927b/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af7b2f4af51291fa4a0549c549796ba0520927b/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs?ref=5af7b2f4af51291fa4a0549c549796ba0520927b", "patch": "@@ -1,200 +0,0 @@\n-use crate::{io, RootFilter, Roots, VfsRoot};\n-use crossbeam_channel::Sender;\n-use drop_bomb::DropBomb;\n-use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as NotifyWatcher};\n-use parking_lot::Mutex;\n-use std::{\n-    fs,\n-    path::{Path, PathBuf},\n-    sync::{mpsc, Arc},\n-    thread,\n-    time::Duration,\n-};\n-use walkdir::WalkDir;\n-\n-#[derive(Debug)]\n-enum ChangeKind {\n-    Create,\n-    Write,\n-    Remove,\n-}\n-\n-const WATCHER_DELAY: Duration = Duration::from_millis(250);\n-\n-pub(crate) struct Watcher {\n-    thread: thread::JoinHandle<()>,\n-    bomb: DropBomb,\n-    watcher: Arc<Mutex<Option<RecommendedWatcher>>>,\n-}\n-\n-impl Watcher {\n-    pub(crate) fn start(\n-        roots: Arc<Roots>,\n-        output_sender: Sender<io::TaskResult>,\n-    ) -> Result<Watcher, Box<std::error::Error>> {\n-        let (input_sender, input_receiver) = mpsc::channel();\n-        let watcher = Arc::new(Mutex::new(Some(notify::watcher(\n-            input_sender,\n-            WATCHER_DELAY,\n-        )?)));\n-        let sender = output_sender.clone();\n-        let watcher_clone = watcher.clone();\n-        let thread = thread::spawn(move || {\n-            let worker = WatcherWorker {\n-                roots,\n-                watcher: watcher_clone,\n-                sender,\n-            };\n-            input_receiver\n-                .into_iter()\n-                // forward relevant events only\n-                .try_for_each(|change| worker.handle_debounced_event(change))\n-                .unwrap()\n-        });\n-        Ok(Watcher {\n-            thread,\n-            watcher,\n-            bomb: DropBomb::new(format!(\"Watcher was not shutdown\")),\n-        })\n-    }\n-\n-    pub fn watch_root(&mut self, filter: &RootFilter) {\n-        for res in WalkDir::new(&filter.root)\n-            .into_iter()\n-            .filter_entry(filter.entry_filter())\n-        {\n-            match res {\n-                Ok(entry) => {\n-                    if entry.file_type().is_dir() {\n-                        watch_one(self.watcher.as_ref(), entry.path());\n-                    }\n-                }\n-                Err(e) => log::warn!(\"watcher error: {}\", e),\n-            }\n-        }\n-    }\n-\n-    pub fn shutdown(mut self) -> thread::Result<()> {\n-        self.bomb.defuse();\n-        drop(self.watcher.lock().take());\n-        let res = self.thread.join();\n-        match &res {\n-            Ok(()) => log::info!(\"... Watcher terminated with ok\"),\n-            Err(_) => log::error!(\"... Watcher terminated with err\"),\n-        }\n-        res\n-    }\n-}\n-\n-struct WatcherWorker {\n-    watcher: Arc<Mutex<Option<RecommendedWatcher>>>,\n-    roots: Arc<Roots>,\n-    sender: Sender<io::TaskResult>,\n-}\n-\n-impl WatcherWorker {\n-    fn handle_debounced_event(&self, ev: DebouncedEvent) -> Result<(), Box<std::error::Error>> {\n-        match ev {\n-            DebouncedEvent::NoticeWrite(_)\n-            | DebouncedEvent::NoticeRemove(_)\n-            | DebouncedEvent::Chmod(_) => {\n-                // ignore\n-            }\n-            DebouncedEvent::Rescan => {\n-                // TODO rescan all roots\n-            }\n-            DebouncedEvent::Create(path) => {\n-                self.handle_change(path, ChangeKind::Create);\n-            }\n-            DebouncedEvent::Write(path) => {\n-                self.handle_change(path, ChangeKind::Write);\n-            }\n-            DebouncedEvent::Remove(path) => {\n-                self.handle_change(path, ChangeKind::Remove);\n-            }\n-            DebouncedEvent::Rename(src, dst) => {\n-                self.handle_change(src, ChangeKind::Remove);\n-                self.handle_change(dst, ChangeKind::Create);\n-            }\n-            DebouncedEvent::Error(err, path) => {\n-                // TODO should we reload the file contents?\n-                log::warn!(\"watcher error \\\"{}\\\", {:?}\", err, path);\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    fn handle_change(&self, path: PathBuf, kind: ChangeKind) {\n-        if let Err(e) = self.try_handle_change(path, kind) {\n-            log::warn!(\"watcher error: {}\", e)\n-        }\n-    }\n-\n-    fn try_handle_change(\n-        &self,\n-        path: PathBuf,\n-        kind: ChangeKind,\n-    ) -> Result<(), Box<std::error::Error>> {\n-        let (root, rel_path) = match self.roots.find(&path) {\n-            Some(x) => x,\n-            None => return Ok(()),\n-        };\n-        match kind {\n-            ChangeKind::Create => {\n-                if path.is_dir() {\n-                    self.watch_recursive(&path, root);\n-                } else {\n-                    let text = fs::read_to_string(&path)?;\n-                    self.sender.send(io::TaskResult::AddSingleFile {\n-                        root,\n-                        path: rel_path,\n-                        text,\n-                    })?\n-                }\n-            }\n-            ChangeKind::Write => {\n-                let text = fs::read_to_string(&path)?;\n-                self.sender.send(io::TaskResult::ChangeSingleFile {\n-                    root,\n-                    path: rel_path,\n-                    text,\n-                })?\n-            }\n-            ChangeKind::Remove => self.sender.send(io::TaskResult::RemoveSingleFile {\n-                root,\n-                path: rel_path,\n-            })?,\n-        }\n-        Ok(())\n-    }\n-\n-    fn watch_recursive(&self, dir: &Path, root: VfsRoot) {\n-        let filter = &self.roots[root];\n-        for res in WalkDir::new(dir)\n-            .into_iter()\n-            .filter_entry(filter.entry_filter())\n-        {\n-            match res {\n-                Ok(entry) => {\n-                    if entry.file_type().is_dir() {\n-                        watch_one(self.watcher.as_ref(), entry.path());\n-                    } else {\n-                        // emit only for files otherwise we will cause watch_recursive to be called again with a dir that we are already watching\n-                        // emit as create because we haven't seen it yet\n-                        self.handle_change(entry.path().to_path_buf(), ChangeKind::Create);\n-                    }\n-                }\n-                Err(e) => log::warn!(\"watcher error: {}\", e),\n-            }\n-        }\n-    }\n-}\n-\n-fn watch_one(watcher: &Mutex<Option<RecommendedWatcher>>, dir: &Path) {\n-    if let Some(watcher) = watcher.lock().as_mut() {\n-        match watcher.watch(dir, RecursiveMode::NonRecursive) {\n-            Ok(()) => log::debug!(\"watching \\\"{}\\\"\", dir.display()),\n-            Err(e) => log::warn!(\"could not watch \\\"{}\\\": {}\", dir.display(), e),\n-        }\n-    }\n-}"}, {"sha": "71a3f807d52b6e13d7d52c98a6b3ddac8077e3f1", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 66, "deletions": 80, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/a8d32c4d1ae4b3e4276f7a97b6c6e5f95f91e67a/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d32c4d1ae4b3e4276f7a97b6c6e5f95f91e67a/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=a8d32c4d1ae4b3e4276f7a97b6c6e5f95f91e67a", "patch": "@@ -18,94 +18,78 @@ mod io;\n use std::{\n     cmp::Reverse,\n     fmt, fs, mem,\n-    ops::{Deref, DerefMut},\n     path::{Path, PathBuf},\n     sync::Arc,\n     thread,\n };\n \n use crossbeam_channel::Receiver;\n-use ra_arena::{impl_arena_id, Arena, RawId};\n+use ra_arena::{impl_arena_id, Arena, RawId, map::ArenaMap};\n use relative_path::{Component, RelativePath, RelativePathBuf};\n use rustc_hash::{FxHashMap, FxHashSet};\n-use walkdir::DirEntry;\n \n pub use crate::io::TaskResult as VfsTask;\n use io::{TaskResult, Worker};\n \n-/// `RootFilter` is a predicate that checks if a file can belong to a root. If\n-/// several filters match a file (nested dirs), the most nested one wins.\n-pub(crate) struct RootFilter {\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct VfsRoot(pub RawId);\n+impl_arena_id!(VfsRoot);\n+\n+/// Describes the contents of a single source root.\n+///\n+/// `RootConfig` can be thought of as a glob pattern like `src/**.rs` whihc\n+/// specifes the source root or as a function whihc takes a `PathBuf` and\n+/// returns `true` iff path belongs to the source root\n+pub(crate) struct RootConfig {\n     root: PathBuf,\n-    filter: fn(&Path, &RelativePath) -> bool,\n     excluded_dirs: Vec<PathBuf>,\n }\n \n-impl RootFilter {\n-    fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootFilter {\n-        RootFilter {\n+pub(crate) struct Roots {\n+    roots: Arena<VfsRoot, Arc<RootConfig>>,\n+}\n+\n+impl std::ops::Deref for Roots {\n+    type Target = Arena<VfsRoot, Arc<RootConfig>>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.roots\n+    }\n+}\n+\n+impl RootConfig {\n+    fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootConfig {\n+        RootConfig {\n             root,\n-            filter: default_filter,\n             excluded_dirs,\n         }\n     }\n-    /// Check if this root can contain `path`. NB: even if this returns\n-    /// true, the `path` might actually be conained in some nested root.\n-    pub(crate) fn can_contain(&self, path: &Path) -> Option<RelativePathBuf> {\n-        let rel_path = path.strip_prefix(&self.root).ok()?;\n-        let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n-        if !(self.filter)(path, rel_path.as_relative_path()) {\n+    /// Cheks if root contains a path and returns a root-relative path.\n+    pub(crate) fn contains(&self, path: &Path) -> Option<RelativePathBuf> {\n+        // First, check excluded dirs\n+        if self.excluded_dirs.iter().any(|it| path.starts_with(it)) {\n             return None;\n         }\n-        Some(rel_path)\n-    }\n-\n-    pub(crate) fn entry_filter<'a>(&'a self) -> impl FnMut(&DirEntry) -> bool + 'a {\n-        move |entry: &DirEntry| {\n-            if entry.file_type().is_dir() && self.excluded_dirs.iter().any(|it| it == entry.path())\n-            {\n-                // do not walk nested roots\n-                false\n-            } else {\n-                self.can_contain(entry.path()).is_some()\n-            }\n-        }\n-    }\n-}\n+        let rel_path = path.strip_prefix(&self.root).ok()?;\n+        let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n \n-pub(crate) fn default_filter(path: &Path, rel_path: &RelativePath) -> bool {\n-    if path.is_dir() {\n+        // Ignore some common directories.\n+        //\n+        // FIXME: don't hard-code, specify at source-root creation time using\n+        // gitignore\n         for (i, c) in rel_path.components().enumerate() {\n             if let Component::Normal(c) = c {\n-                // TODO hardcoded for now\n                 if (i == 0 && c == \"target\") || c == \".git\" || c == \"node_modules\" {\n-                    return false;\n+                    return None;\n                 }\n             }\n         }\n-        true\n-    } else {\n-        rel_path.extension() == Some(\"rs\")\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct VfsRoot(pub RawId);\n-impl_arena_id!(VfsRoot);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct VfsFile(pub RawId);\n-impl_arena_id!(VfsFile);\n \n-struct VfsFileData {\n-    root: VfsRoot,\n-    path: RelativePathBuf,\n-    is_overlayed: bool,\n-    text: Arc<String>,\n-}\n+        if path.is_file() && rel_path.extension() != Some(\"rs\") {\n+            return None;\n+        }\n \n-pub(crate) struct Roots {\n-    roots: Arena<VfsRoot, Arc<RootFilter>>,\n+        Some(rel_path)\n+    }\n }\n \n impl Roots {\n@@ -120,59 +104,61 @@ impl Roots {\n                 .map(|it| it.clone())\n                 .collect::<Vec<_>>();\n \n-            let root_filter = Arc::new(RootFilter::new(path.clone(), nested_roots));\n+            let config = Arc::new(RootConfig::new(path.clone(), nested_roots));\n \n-            roots.alloc(root_filter.clone());\n+            roots.alloc(config.clone());\n         }\n         Roots { roots }\n     }\n     pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n         self.roots\n             .iter()\n-            .find_map(|(root, data)| data.can_contain(path).map(|it| (root, it)))\n+            .find_map(|(root, data)| data.contains(path).map(|it| (root, it)))\n     }\n }\n \n-impl Deref for Roots {\n-    type Target = Arena<VfsRoot, Arc<RootFilter>>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.roots\n-    }\n-}\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct VfsFile(pub RawId);\n+impl_arena_id!(VfsFile);\n \n-impl DerefMut for Roots {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.roots\n-    }\n+struct VfsFileData {\n+    root: VfsRoot,\n+    path: RelativePathBuf,\n+    is_overlayed: bool,\n+    text: Arc<String>,\n }\n \n pub struct Vfs {\n     roots: Arc<Roots>,\n     files: Arena<VfsFile, VfsFileData>,\n-    root2files: FxHashMap<VfsRoot, FxHashSet<VfsFile>>,\n+    root2files: ArenaMap<VfsRoot, FxHashSet<VfsFile>>,\n     pending_changes: Vec<VfsChange>,\n     worker: Worker,\n }\n \n impl fmt::Debug for Vfs {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"Vfs { ... }\")\n+        f.debug_struct(\"Vfs\")\n+            .field(\"n_roots\", &self.roots.len())\n+            .field(\"n_files\", &self.files.len())\n+            .field(\"n_pending_changes\", &self.pending_changes.len())\n+            .finish()\n     }\n }\n \n impl Vfs {\n     pub fn new(roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n         let roots = Arc::new(Roots::new(roots));\n-        let worker = io::Worker::start(roots.clone());\n-        let mut root2files = FxHashMap::default();\n+        let worker = io::Worker::start(Arc::clone(&roots));\n+        let mut root2files = ArenaMap::default();\n \n-        for (root, filter) in roots.iter() {\n+        for (root, config) in roots.iter() {\n             root2files.insert(root, Default::default());\n             worker\n                 .sender()\n                 .send(io::Task::AddRoot {\n                     root,\n-                    filter: filter.clone(),\n+                    config: Arc::clone(config),\n                 })\n                 .unwrap();\n         }\n@@ -242,7 +228,7 @@ impl Vfs {\n                 let mut cur_files = Vec::new();\n                 // While we were scanning the root in the backgound, a file might have\n                 // been open in the editor, so we need to account for that.\n-                let exising = self.root2files[&root]\n+                let exising = self.root2files[root]\n                     .iter()\n                     .map(|&file| (self.files[file].path.clone(), file))\n                     .collect::<FxHashMap<_, _>>();\n@@ -384,7 +370,7 @@ impl Vfs {\n             is_overlayed,\n         };\n         let file = self.files.alloc(data);\n-        self.root2files.get_mut(&root).unwrap().insert(file);\n+        self.root2files.get_mut(root).unwrap().insert(file);\n         file\n     }\n \n@@ -399,7 +385,7 @@ impl Vfs {\n         self.files[file].text = Default::default();\n         self.files[file].path = Default::default();\n         let root = self.files[file].root;\n-        let removed = self.root2files.get_mut(&root).unwrap().remove(&file);\n+        let removed = self.root2files.get_mut(root).unwrap().remove(&file);\n         assert!(removed);\n     }\n \n@@ -410,7 +396,7 @@ impl Vfs {\n     }\n \n     fn find_file(&self, root: VfsRoot, path: &RelativePath) -> Option<VfsFile> {\n-        self.root2files[&root]\n+        self.root2files[root]\n             .iter()\n             .map(|&it| it)\n             .find(|&file| self.files[file].path == path)"}]}