{"sha": "c8151703b2bebf1a7b02bb76eb08869392c00851", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MTUxNzAzYjJiZWJmMWE3YjAyYmI3NmViMDg4NjkzOTJjMDA4NTE=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-01T13:44:18Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-01T13:44:18Z"}, "message": "Merge pull request #15 from oli-obk/step_by_step\n\n4 byte pointers + tests", "tree": {"sha": "4f306e02be53cce11728f9d11a0aa551f4513475", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f306e02be53cce11728f9d11a0aa551f4513475"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8151703b2bebf1a7b02bb76eb08869392c00851", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8151703b2bebf1a7b02bb76eb08869392c00851", "html_url": "https://github.com/rust-lang/rust/commit/c8151703b2bebf1a7b02bb76eb08869392c00851", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8151703b2bebf1a7b02bb76eb08869392c00851/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3923eeb50e80e17b4529ae2e3c269fbb682bfed", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3923eeb50e80e17b4529ae2e3c269fbb682bfed", "html_url": "https://github.com/rust-lang/rust/commit/f3923eeb50e80e17b4529ae2e3c269fbb682bfed"}, {"sha": "f910019da169a000d8b7bb0d031b4de2a0e420a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f910019da169a000d8b7bb0d031b4de2a0e420a9", "html_url": "https://github.com/rust-lang/rust/commit/f910019da169a000d8b7bb0d031b4de2a0e420a9"}], "stats": {"total": 219, "additions": 132, "deletions": 87}, "files": [{"sha": "66bbc729e15fa4addedbbb16e878df7fe874e51d", "filename": "Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8151703b2bebf1a7b02bb76eb08869392c00851/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c8151703b2bebf1a7b02bb76eb08869392c00851/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=c8151703b2bebf1a7b02bb76eb08869392c00851", "patch": "@@ -9,6 +9,10 @@ version = \"0.1.0\"\n [[bin]]\n doc = false\n name = \"miri\"\n+test = false\n+\n+[lib]\n+test = false\n \n [dependencies]\n byteorder = \"0.4.2\""}, {"sha": "7d252658ba2d69d655335474c811d157f543d056", "filename": "src/error.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c8151703b2bebf1a7b02bb76eb08869392c00851/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8151703b2bebf1a7b02bb76eb08869392c00851/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=c8151703b2bebf1a7b02bb76eb08869392c00851", "patch": "@@ -1,16 +1,24 @@\n use std::error::Error;\n use std::fmt;\n+use rustc::mir::repr as mir;\n+use memory::Pointer;\n \n #[derive(Clone, Debug)]\n pub enum EvalError {\n     DanglingPointerDeref,\n     InvalidBool,\n     InvalidDiscriminant,\n-    PointerOutOfBounds,\n+    PointerOutOfBounds {\n+        ptr: Pointer,\n+        size: usize,\n+        allocation_size: usize,\n+    },\n     ReadPointerAsBytes,\n     ReadBytesAsPointer,\n     InvalidPointerMath,\n     ReadUndefBytes,\n+    InvalidBoolOp(mir::BinOp),\n+    Unimplemented(String),\n }\n \n pub type EvalResult<T> = Result<T, EvalError>;\n@@ -24,7 +32,7 @@ impl Error for EvalError {\n                 \"invalid boolean value read\",\n             EvalError::InvalidDiscriminant =>\n                 \"invalid enum discriminant value read\",\n-            EvalError::PointerOutOfBounds =>\n+            EvalError::PointerOutOfBounds { .. } =>\n                 \"pointer offset outside bounds of allocation\",\n             EvalError::ReadPointerAsBytes =>\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n@@ -34,6 +42,9 @@ impl Error for EvalError {\n                 \"attempted to do math or a comparison on pointers into different allocations\",\n             EvalError::ReadUndefBytes =>\n                 \"attempted to read undefined bytes\",\n+            EvalError::InvalidBoolOp(_) =>\n+                \"invalid boolean operation\",\n+            EvalError::Unimplemented(ref msg) => msg,\n         }\n     }\n \n@@ -42,6 +53,12 @@ impl Error for EvalError {\n \n impl fmt::Display for EvalError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.description())\n+        match *self {\n+            EvalError::PointerOutOfBounds { ptr, size, allocation_size } => {\n+                write!(f, \"memory access of {}..{} outside bounds of allocation {} which has size {}\",\n+                       ptr.offset, ptr.offset + size, ptr.alloc_id, allocation_size)\n+            },\n+            _ => write!(f, \"{}\", self.description()),\n+        }\n     }\n }"}, {"sha": "bd8a5012b2e71d86e8aca2fa38e43045b0d094d5", "filename": "src/interpreter.rs", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c8151703b2bebf1a7b02bb76eb08869392c00851/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8151703b2bebf1a7b02bb76eb08869392c00851/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=c8151703b2bebf1a7b02bb76eb08869392c00851", "patch": "@@ -128,7 +128,11 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n             tcx: tcx,\n             mir_map: mir_map,\n             mir_cache: RefCell::new(DefIdMap()),\n-            memory: Memory::new(),\n+            memory: Memory::new(tcx.sess\n+                                   .target\n+                                   .uint_type\n+                                   .bit_width()\n+                                   .expect(\"Session::target::uint_type was usize\")/8),\n             substs_stack: Vec::new(),\n             name_stack: Vec::new(),\n         }\n@@ -392,11 +396,11 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                 TerminatorTarget::Call\n                             }\n \n-                            abi => panic!(\"can't handle function with {:?} ABI\", abi),\n+                            abi => return Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n                         }\n                     }\n \n-                    _ => panic!(\"can't handle callee of type {:?}\", func_ty),\n+                    _ => return Err(EvalError::Unimplemented(format!(\"can't handle callee of type {:?}\", func_ty))),\n                 }\n             }\n \n@@ -470,7 +474,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             }\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-                let offset = self.nonnull_offset(adt_ty, nndiscr, discrfield);\n+                let offset = self.nonnull_offset(adt_ty, nndiscr, discrfield)?;\n                 let nonnull = adt_ptr.offset(offset.bytes() as isize);\n                 self.read_nonnull_discriminant_value(nonnull, nndiscr)?\n             }\n@@ -620,7 +624,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                             self.memory.write_uint(dest, n * elem_size, dest_size)?;\n                         }\n \n-                        _ => panic!(\"unimplemented: size_of_val::<{:?}>\", ty),\n+                        _ => return Err(EvalError::Unimplemented(format!(\"unimplemented: size_of_val::<{:?}>\", ty))),\n                     }\n                 }\n             }\n@@ -631,7 +635,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             }\n             \"uninit\" => self.memory.mark_definedness(dest, dest_size, false)?,\n \n-            name => panic!(\"can't handle intrinsic: {}\", name),\n+            name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n         }\n \n         // Since we pushed no stack frame, the main loop will act\n@@ -693,7 +697,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 self.memory.write_int(dest, result, dest_size)?;\n             }\n \n-            _ => panic!(\"can't call C ABI function: {}\", link_name),\n+            _ => return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name))),\n         }\n \n         // Since we pushed no stack frame, the main loop will act\n@@ -748,7 +752,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 let ptr = self.eval_operand(operand)?;\n                 let ty = self.operand_ty(operand);\n                 let val = self.read_primval(ptr, ty)?;\n-                self.memory.write_primval(dest, primval::unary_op(un_op, val))?;\n+                self.memory.write_primval(dest, primval::unary_op(un_op, val)?)?;\n             }\n \n             Aggregate(ref kind, ref operands) => {\n@@ -809,7 +813,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                 try!(self.assign_fields(dest, offsets, operands));\n                             } else {\n                                 assert_eq!(operands.len(), 0);\n-                                let offset = self.nonnull_offset(dest_ty, nndiscr, discrfield);\n+                                let offset = self.nonnull_offset(dest_ty, nndiscr, discrfield)?;\n                                 let dest = dest.offset(offset.bytes() as isize);\n                                 try!(self.memory.write_isize(dest, 0));\n                             }\n@@ -834,8 +838,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                         }\n                     }\n \n-                    _ => panic!(\"can't handle destination layout {:?} when assigning {:?}\",\n-                                dest_layout, kind),\n+                    _ => return Err(EvalError::Unimplemented(format!(\"can't handle destination layout {:?} when assigning {:?}\", dest_layout, kind))),\n                 }\n             }\n \n@@ -904,7 +907,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                 self.memory.write_usize(len_ptr, length as u64)?;\n                             }\n \n-                            _ => panic!(\"can't handle cast: {:?}\", rvalue),\n+                            _ => return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue))),\n                         }\n                     }\n \n@@ -914,7 +917,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                         self.memory.copy(src, dest, size)?;\n                     }\n \n-                    _ => panic!(\"can't handle cast: {:?}\", rvalue),\n+                    _ => return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue))),\n                 }\n             }\n \n@@ -925,7 +928,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(())\n     }\n \n-    fn nonnull_offset(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> Size {\n+    fn nonnull_offset(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> EvalResult<Size> {\n         // Skip the constant 0 at the start meant for LLVM GEP.\n         let mut path = discrfield.iter().skip(1).map(|&i| i as usize);\n \n@@ -946,49 +949,49 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         self.field_path_offset(inner_ty, path)\n     }\n \n-    fn field_path_offset<I: Iterator<Item = usize>>(&self, mut ty: Ty<'tcx>, path: I) -> Size {\n+    fn field_path_offset<I: Iterator<Item = usize>>(&self, mut ty: Ty<'tcx>, path: I) -> EvalResult<Size> {\n         let mut offset = Size::from_bytes(0);\n \n         // Skip the initial 0 intended for LLVM GEP.\n         for field_index in path {\n-            let field_offset = self.get_field_offset(ty, field_index);\n-            ty = self.get_field_ty(ty, field_index);\n+            let field_offset = self.get_field_offset(ty, field_index)?;\n+            ty = self.get_field_ty(ty, field_index)?;\n             offset = offset.checked_add(field_offset, &self.tcx.data_layout).unwrap();\n         }\n \n-        offset\n+        Ok(offset)\n     }\n \n-    fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> Ty<'tcx> {\n+    fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<Ty<'tcx>> {\n         match ty.sty {\n             ty::TyStruct(adt_def, substs) => {\n-                adt_def.struct_variant().fields[field_index].ty(self.tcx, substs)\n+                Ok(adt_def.struct_variant().fields[field_index].ty(self.tcx, substs))\n             }\n \n             ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n             ty::TyBox(ty) => {\n                 assert_eq!(field_index, 0);\n-                ty\n+                Ok(ty)\n             }\n-            _ => panic!(\"can't handle type: {:?}\", ty),\n+            _ => Err(EvalError::Unimplemented(format!(\"can't handle type: {:?}\", ty))),\n         }\n     }\n \n-    fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> Size {\n+    fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<Size> {\n         let layout = self.type_layout(ty);\n \n         use rustc::ty::layout::Layout::*;\n         match *layout {\n             Univariant { .. } => {\n                 assert_eq!(field_index, 0);\n-                Size::from_bytes(0)\n+                Ok(Size::from_bytes(0))\n             }\n             FatPointer { .. } => {\n                 let bytes = layout::FAT_PTR_ADDR * self.memory.pointer_size;\n-                Size::from_bytes(bytes as u64)\n+                Ok(Size::from_bytes(bytes as u64))\n             }\n-            _ => panic!(\"can't handle type: {:?}, with layout: {:?}\", ty, layout),\n+            _ => Err(EvalError::Unimplemented(format!(\"can't handle type: {:?}, with layout: {:?}\", ty, layout))),\n         }\n     }\n \n@@ -1197,23 +1200,25 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n     pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<PrimVal> {\n         use syntax::ast::{IntTy, UintTy};\n-        let val = match ty.sty {\n-            ty::TyBool              => PrimVal::Bool(self.memory.read_bool(ptr)?),\n-            ty::TyInt(IntTy::I8)    => PrimVal::I8(self.memory.read_int(ptr, 1)? as i8),\n-            ty::TyInt(IntTy::I16)   => PrimVal::I16(self.memory.read_int(ptr, 2)? as i16),\n-            ty::TyInt(IntTy::I32)   => PrimVal::I32(self.memory.read_int(ptr, 4)? as i32),\n-            ty::TyInt(IntTy::I64)   => PrimVal::I64(self.memory.read_int(ptr, 8)? as i64),\n-            ty::TyUint(UintTy::U8)  => PrimVal::U8(self.memory.read_uint(ptr, 1)? as u8),\n-            ty::TyUint(UintTy::U16) => PrimVal::U16(self.memory.read_uint(ptr, 2)? as u16),\n-            ty::TyUint(UintTy::U32) => PrimVal::U32(self.memory.read_uint(ptr, 4)? as u32),\n-            ty::TyUint(UintTy::U64) => PrimVal::U64(self.memory.read_uint(ptr, 8)? as u64),\n-\n-            // TODO(solson): Pick the PrimVal dynamically.\n-            ty::TyInt(IntTy::Is)   => PrimVal::I64(self.memory.read_isize(ptr)?),\n-            ty::TyUint(UintTy::Us) => PrimVal::U64(self.memory.read_usize(ptr)?),\n-\n-            ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+        let val = match (self.memory.pointer_size, &ty.sty) {\n+            (_, &ty::TyBool)              => PrimVal::Bool(self.memory.read_bool(ptr)?),\n+            (_, &ty::TyInt(IntTy::I8))    => PrimVal::I8(self.memory.read_int(ptr, 1)? as i8),\n+            (2, &ty::TyInt(IntTy::Is)) |\n+            (_, &ty::TyInt(IntTy::I16))   => PrimVal::I16(self.memory.read_int(ptr, 2)? as i16),\n+            (4, &ty::TyInt(IntTy::Is)) |\n+            (_, &ty::TyInt(IntTy::I32))   => PrimVal::I32(self.memory.read_int(ptr, 4)? as i32),\n+            (8, &ty::TyInt(IntTy::Is)) |\n+            (_, &ty::TyInt(IntTy::I64))   => PrimVal::I64(self.memory.read_int(ptr, 8)? as i64),\n+            (_, &ty::TyUint(UintTy::U8))  => PrimVal::U8(self.memory.read_uint(ptr, 1)? as u8),\n+            (2, &ty::TyUint(UintTy::Us)) |\n+            (_, &ty::TyUint(UintTy::U16)) => PrimVal::U16(self.memory.read_uint(ptr, 2)? as u16),\n+            (4, &ty::TyUint(UintTy::Us)) |\n+            (_, &ty::TyUint(UintTy::U32)) => PrimVal::U32(self.memory.read_uint(ptr, 4)? as u32),\n+            (8, &ty::TyUint(UintTy::Us)) |\n+            (_, &ty::TyUint(UintTy::U64)) => PrimVal::U64(self.memory.read_uint(ptr, 8)? as u64),\n+\n+            (_, &ty::TyRef(_, ty::TypeAndMut { ty, .. })) |\n+            (_, &ty::TyRawPtr(ty::TypeAndMut { ty, .. })) => {\n                 if self.type_is_sized(ty) {\n                     match self.memory.read_ptr(ptr) {\n                         Ok(p) => PrimVal::AbstractPtr(p),\n@@ -1223,7 +1228,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                         Err(e) => return Err(e),\n                     }\n                 } else {\n-                    panic!(\"unimplemented: primitive read of fat pointer type: {:?}\", ty);\n+                    return Err(EvalError::Unimplemented(format!(\"unimplemented: primitive read of fat pointer type: {:?}\", ty)));\n                 }\n             }\n "}, {"sha": "728d5310f8611c96fcd7e17b23d00cb31feacfa2", "filename": "src/memory.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c8151703b2bebf1a7b02bb76eb08869392c00851/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8151703b2bebf1a7b02bb76eb08869392c00851/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=c8151703b2bebf1a7b02bb76eb08869392c00851", "patch": "@@ -49,14 +49,12 @@ pub struct Memory {\n }\n \n impl Memory {\n-    pub fn new() -> Self {\n+    // FIXME: pass tcx.data_layout (This would also allow it to use primitive type alignments to diagnose unaligned memory accesses.)\n+    pub fn new(pointer_size: usize) -> Self {\n         Memory {\n             alloc_map: HashMap::new(),\n             next_id: AllocId(0),\n-\n-            // FIXME(solson): This should work for both 4 and 8, but it currently breaks some things\n-            // when set to 4.\n-            pointer_size: 8,\n+            pointer_size: pointer_size,\n         }\n     }\n \n@@ -80,7 +78,7 @@ impl Memory {\n     pub fn reallocate(&mut self, ptr: Pointer, new_size: usize) -> EvalResult<()> {\n         if ptr.offset != 0 {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n-            panic!()\n+            return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n \n         let alloc = self.get_mut(ptr.alloc_id)?;\n@@ -90,7 +88,7 @@ impl Memory {\n             alloc.bytes.extend(iter::repeat(0).take(amount));\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n-            unimplemented!()\n+            return Err(EvalError::Unimplemented(format!(\"unimplemented allocation relocation\")));\n             // alloc.bytes.truncate(new_size);\n             // alloc.undef_mask.len = new_size;\n             // TODO: potentially remove relocations\n@@ -103,7 +101,7 @@ impl Memory {\n     pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<()> {\n         if ptr.offset != 0 {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n-            panic!()\n+            return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n \n         if self.alloc_map.remove(&ptr.alloc_id).is_none() {\n@@ -183,15 +181,23 @@ impl Memory {\n     fn get_bytes_unchecked(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if ptr.offset + size > alloc.bytes.len() {\n-            return Err(EvalError::PointerOutOfBounds);\n+            return Err(EvalError::PointerOutOfBounds {\n+                ptr: ptr,\n+                size: size,\n+                allocation_size: alloc.bytes.len(),\n+            });\n         }\n         Ok(&alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n     fn get_bytes_unchecked_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<&mut [u8]> {\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         if ptr.offset + size > alloc.bytes.len() {\n-            return Err(EvalError::PointerOutOfBounds);\n+            return Err(EvalError::PointerOutOfBounds {\n+                ptr: ptr,\n+                size: size,\n+                allocation_size: alloc.bytes.len(),\n+            });\n         }\n         Ok(&mut alloc.bytes[ptr.offset..ptr.offset + size])\n     }"}, {"sha": "0b1658739d9d6a4832abc7cbdac68af8fc546b07", "filename": "src/primval.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c8151703b2bebf1a7b02bb76eb08869392c00851/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8151703b2bebf1a7b02bb76eb08869392c00851/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=c8151703b2bebf1a7b02bb76eb08869392c00851", "patch": "@@ -74,8 +74,7 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResul\n                 BitOr => l | r,\n                 BitXor => l ^ r,\n                 BitAnd => l & r,\n-                Add | Sub | Mul | Div | Rem | Shl | Shr =>\n-                    panic!(\"invalid binary operation on booleans: {:?}\", bin_op),\n+                Add | Sub | Mul | Div | Rem | Shl | Shr => return Err(EvalError::InvalidBoolOp(bin_op)),\n             })\n         }\n \n@@ -99,33 +98,33 @@ pub fn binary_op(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResul\n                 Le => Bool(l <= r),\n                 Gt => Bool(l > r),\n                 Ge => Bool(l >= r),\n-                _ => unimplemented!(),\n+                _ => return Err(EvalError::Unimplemented(format!(\"unimplemented ptr op: {:?}\", bin_op))),\n             }\n         }\n \n-        _ => unimplemented!(),\n+        (l, r) => return Err(EvalError::Unimplemented(format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", l, r, bin_op))),\n     };\n \n     Ok(val)\n }\n \n-pub fn unary_op(un_op: mir::UnOp, val: PrimVal) -> PrimVal {\n+pub fn unary_op(un_op: mir::UnOp, val: PrimVal) -> EvalResult<PrimVal> {\n     use rustc::mir::repr::UnOp::*;\n     use self::PrimVal::*;\n     match (un_op, val) {\n-        (Not, Bool(b)) => Bool(!b),\n-        (Not, I8(n))  => I8(!n),\n-        (Neg, I8(n))  => I8(-n),\n-        (Not, I16(n)) => I16(!n),\n-        (Neg, I16(n)) => I16(-n),\n-        (Not, I32(n)) => I32(!n),\n-        (Neg, I32(n)) => I32(-n),\n-        (Not, I64(n)) => I64(!n),\n-        (Neg, I64(n)) => I64(-n),\n-        (Not, U8(n))  => U8(!n),\n-        (Not, U16(n)) => U16(!n),\n-        (Not, U32(n)) => U32(!n),\n-        (Not, U64(n)) => U64(!n),\n-        _ => unimplemented!(),\n+        (Not, Bool(b)) => Ok(Bool(!b)),\n+        (Not, I8(n))  => Ok(I8(!n)),\n+        (Neg, I8(n))  => Ok(I8(-n)),\n+        (Not, I16(n)) => Ok(I16(!n)),\n+        (Neg, I16(n)) => Ok(I16(-n)),\n+        (Not, I32(n)) => Ok(I32(!n)),\n+        (Neg, I32(n)) => Ok(I32(-n)),\n+        (Not, I64(n)) => Ok(I64(!n)),\n+        (Neg, I64(n)) => Ok(I64(-n)),\n+        (Not, U8(n))  => Ok(U8(!n)),\n+        (Not, U16(n)) => Ok(U16(!n)),\n+        (Not, U32(n)) => Ok(U32(!n)),\n+        (Not, U64(n)) => Ok(U64(!n)),\n+        _ => Err(EvalError::Unimplemented(format!(\"unimplemented unary op: {:?}, {:?}\", un_op, val))),\n     }\n }"}, {"sha": "0cadd76cccf34e864b18ffdf46273c840759d502", "filename": "tests/compile-fail/errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8151703b2bebf1a7b02bb76eb08869392c00851/tests%2Fcompile-fail%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8151703b2bebf1a7b02bb76eb08869392c00851/tests%2Fcompile-fail%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ferrors.rs?ref=c8151703b2bebf1a7b02bb76eb08869392c00851", "patch": "@@ -6,7 +6,9 @@ fn overwriting_part_of_relocation_makes_the_rest_undefined() -> i32 {\n     let mut p = &42;\n     unsafe {\n         let ptr: *mut _ = &mut p;\n-        *(ptr as *mut u32) = 123;\n+        *(ptr as *mut u8) = 123; // if we ever support 8 bit pointers, this is gonna cause\n+        // \"attempted to interpret some raw bytes as a pointer address\" instead of\n+        // \"attempted to read undefined bytes\"\n     }\n     *p //~ ERROR: attempted to read undefined bytes\n }\n@@ -34,7 +36,7 @@ fn undefined_byte_read() -> u8 {\n #[miri_run]\n fn out_of_bounds_read() -> u8 {\n     let v: Vec<u8> = vec![1, 2];\n-    unsafe { *v.get_unchecked(5) } //~ ERROR: pointer offset outside bounds of allocation\n+    unsafe { *v.get_unchecked(5) } //~ ERROR: memory access of 5..6 outside bounds of allocation 11 which has size 2\n }\n \n #[miri_run]"}, {"sha": "184e28241324286452638d06293831c81a6cfb3c", "filename": "tests/compiletest.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8151703b2bebf1a7b02bb76eb08869392c00851/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8151703b2bebf1a7b02bb76eb08869392c00851/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=c8151703b2bebf1a7b02bb76eb08869392c00851", "patch": "@@ -3,17 +3,24 @@ extern crate compiletest_rs as compiletest;\n use std::path::PathBuf;\n \n fn run_mode(mode: &'static str) {\n-    let mut config = compiletest::default_config();\n-    config.rustc_path = \"target/debug/miri\".into();\n-    let path = std::env::var(\"RUST_SYSROOT\").expect(\"env variable `RUST_SYSROOT` not set\");\n-    config.target_rustcflags = Some(format!(\"--sysroot {}\", path));\n-    config.host_rustcflags = Some(format!(\"--sysroot {}\", path));\n-    let cfg_mode = mode.parse().ok().expect(\"Invalid mode\");\n+    // FIXME: read directories in sysroot/lib/rustlib and generate the test targets from that\n+    let targets = &[\"x86_64-unknown-linux-gnu\", \"i686-unknown-linux-gnu\"];\n \n-    config.mode = cfg_mode;\n-    config.src_base = PathBuf::from(format!(\"tests/{}\", mode));\n+    for &target in targets {\n+        let mut config = compiletest::default_config();\n+        config.rustc_path = \"target/debug/miri\".into();\n+        let path = std::env::var(\"RUST_SYSROOT\").expect(\"env variable `RUST_SYSROOT` not set\");\n+        config.run_lib_path = format!(\"{}/lib/rustlib/{}/lib\", path, target);\n+        let path = format!(\"--sysroot {}\", path);\n+        config.target_rustcflags = Some(path.clone());\n+        config.host_rustcflags = Some(path);\n+        let cfg_mode = mode.parse().ok().expect(\"Invalid mode\");\n \n-    compiletest::run_tests(&config);\n+        config.mode = cfg_mode;\n+        config.src_base = PathBuf::from(format!(\"tests/{}\", mode));\n+        config.target = target.to_owned();\n+        compiletest::run_tests(&config);\n+    }\n }\n \n #[test]"}, {"sha": "809233511698895e8ad703e393039ef83af21466", "filename": "tests/run-pass/strings.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8151703b2bebf1a7b02bb76eb08869392c00851/tests%2Frun-pass%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8151703b2bebf1a7b02bb76eb08869392c00851/tests%2Frun-pass%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstrings.rs?ref=c8151703b2bebf1a7b02bb76eb08869392c00851", "patch": "@@ -21,4 +21,9 @@ fn hello_bytes_fat() -> &'static [u8] {\n     b\"Hello, world!\"\n }\n \n+#[miri_run]\n+fn fat_pointer_on_32_bit() {\n+    Some(5).expect(\"foo\");\n+}\n+\n fn main() {}"}]}