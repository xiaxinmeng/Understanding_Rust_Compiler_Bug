{"sha": "f58ffc93815f76576eb56df4bdeec2fe8f12b766", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1OGZmYzkzODE1Zjc2NTc2ZWI1NmRmNGJkZWVjMmZlOGYxMmI3NjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-24T21:42:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-24T21:42:39Z"}, "message": "Auto merge of #78334 - jonas-schievink:rollup-z0gzbmm, r=jonas-schievink\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #75115 (`#[deny(unsafe_op_in_unsafe_fn)]` in sys/cloudabi)\n - #76614 (change the order of type arguments on ControlFlow)\n - #77610 (revise Hermit's mutex interface to support the behaviour of StaticMutex)\n - #77830 (Simplify query proc-macros)\n - #77930 (Do not ICE with TraitPredicates containing [type error])\n - #78069 (Fix const core::panic!(non_literal_str).)\n - #78072 (Cleanup constant matching in exhaustiveness checking)\n - #78119 (Throw core::panic!(\"message\") as &str instead of String.)\n - #78191 (Introduce a temporary for discriminant value in MatchBranchSimplification)\n - #78272 (const_evaluatable_checked: deal with unused nodes + div)\n - #78318 (TyCtxt: generate single impl block with `slice_interners` macro)\n - #78327 (resolve: Relax macro resolution consistency check to account for any errors)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "60e8bc7b8fe3ab206a1cedc66fc90627d4bfdb24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60e8bc7b8fe3ab206a1cedc66fc90627d4bfdb24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f58ffc93815f76576eb56df4bdeec2fe8f12b766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f58ffc93815f76576eb56df4bdeec2fe8f12b766", "html_url": "https://github.com/rust-lang/rust/commit/f58ffc93815f76576eb56df4bdeec2fe8f12b766", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f58ffc93815f76576eb56df4bdeec2fe8f12b766/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffa2e7ae8fbf9badc035740db949b9dae271c29f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffa2e7ae8fbf9badc035740db949b9dae271c29f", "html_url": "https://github.com/rust-lang/rust/commit/ffa2e7ae8fbf9badc035740db949b9dae271c29f"}, {"sha": "58ae889779e761e35d3ca0c8c7beb92cde52dd7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/58ae889779e761e35d3ca0c8c7beb92cde52dd7d", "html_url": "https://github.com/rust-lang/rust/commit/58ae889779e761e35d3ca0c8c7beb92cde52dd7d"}], "stats": {"total": 2238, "additions": 1418, "deletions": 820}, "files": [{"sha": "8af442c8f4b3e2e3155691b05e199645b963380f", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -1366,9 +1366,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.15\"\n+version = \"0.1.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3deed196b6e7f9e44a2ae8d94225d80302d81208b1bb673fd21fe634645c85a9\"\n+checksum = \"5aca5565f760fb5b220e499d72710ed156fdb74e631659e99377d9ebfbd13ae8\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\","}, {"sha": "5f42d46e28575453abc62e2694d3549befbf3679", "filename": "compiler/rustc_data_structures/src/graph/iterate/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -1,6 +1,7 @@\n use super::{DirectedGraph, WithNumNodes, WithStartNode, WithSuccessors};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n+use std::ops::ControlFlow;\n \n #[cfg(test)]\n mod tests;\n@@ -86,10 +87,6 @@ where\n     }\n }\n \n-/// Allows searches to terminate early with a value.\n-// FIXME (#75744): remove the alias once the generics are in a better order and `C=()`.\n-pub type ControlFlow<T> = std::ops::ControlFlow<(), T>;\n-\n /// The status of a node in the depth-first search.\n ///\n /// See the documentation of `TriColorDepthFirstSearch` to see how a node's status is updated"}, {"sha": "0ae3c75fcc2cbafd1364405568e907a75e2fd724", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -111,17 +111,6 @@ cfg_if! {\n \n type Profiler = measureme::Profiler<SerializationSink>;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd)]\n-pub enum ProfileCategory {\n-    Parsing,\n-    Expansion,\n-    TypeChecking,\n-    BorrowChecking,\n-    Codegen,\n-    Linking,\n-    Other,\n-}\n-\n bitflags::bitflags! {\n     struct EventFilter: u32 {\n         const GENERIC_ACTIVITIES = 1 << 0;"}, {"sha": "3e4eb9eafd7f99a0a9124e8d43d65d8b740b27a0", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -263,6 +263,7 @@ language_item_table! {\n     // is required to define it somewhere. Additionally, there are restrictions on crates that use\n     // a weak lang item, but do not have it defined.\n     Panic,                   sym::panic,               panic_fn,                   Target::Fn;\n+    PanicStr,                sym::panic_str,           panic_str,                  Target::Fn;\n     PanicBoundsCheck,        sym::panic_bounds_check,  panic_bounds_check_fn,      Target::Fn;\n     PanicInfo,               sym::panic_info,          panic_info,                 Target::Struct;\n     PanicLocation,           sym::panic_location,      panic_location,             Target::Struct;"}, {"sha": "fd85919636949ac89760c4b4270b6b94449e613a", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 6, "deletions": 66, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -190,7 +190,11 @@ impl<T: Parse> Parse for List<T> {\n }\n \n /// A named group containing queries.\n+///\n+/// For now, the name is not used any more, but the capability remains interesting for future\n+/// developments of the query system.\n struct Group {\n+    #[allow(unused)]\n     name: Ident,\n     queries: List<Query>,\n }\n@@ -417,12 +421,9 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut query_stream = quote! {};\n     let mut query_description_stream = quote! {};\n     let mut dep_node_def_stream = quote! {};\n-    let mut dep_node_force_stream = quote! {};\n-    let mut try_load_from_on_disk_cache_stream = quote! {};\n     let mut cached_queries = quote! {};\n \n     for group in groups.0 {\n-        let mut group_stream = quote! {};\n         for mut query in group.queries.0 {\n             let modifiers = process_modifiers(&mut query);\n             let name = &query.name;\n@@ -437,22 +438,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 cached_queries.extend(quote! {\n                     #name,\n                 });\n-\n-                try_load_from_on_disk_cache_stream.extend(quote! {\n-                    ::rustc_middle::dep_graph::DepKind::#name => {\n-                        if <#arg as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key() {\n-                            debug_assert!($tcx.dep_graph\n-                                            .node_color($dep_node)\n-                                            .map(|c| c.is_green())\n-                                            .unwrap_or(false));\n-\n-                            let key = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node).unwrap();\n-                            if queries::#name::cache_on_disk($tcx, &key, None) {\n-                                let _ = $tcx.#name(key);\n-                            }\n-                        }\n-                    }\n-                });\n             }\n \n             let mut attributes = Vec::new();\n@@ -485,47 +470,20 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             let attribute_stream = quote! {#(#attributes),*};\n             let doc_comments = query.doc_comments.iter();\n             // Add the query to the group\n-            group_stream.extend(quote! {\n+            query_stream.extend(quote! {\n                 #(#doc_comments)*\n-                [#attribute_stream] fn #name: #name(#arg) #result,\n+                [#attribute_stream] fn #name(#arg) #result,\n             });\n \n             // Create a dep node for the query\n             dep_node_def_stream.extend(quote! {\n                 [#attribute_stream] #name(#arg),\n             });\n \n-            // Add a match arm to force the query given the dep node\n-            dep_node_force_stream.extend(quote! {\n-                ::rustc_middle::dep_graph::DepKind::#name => {\n-                    if <#arg as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key() {\n-                        if let Some(key) = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node) {\n-                            force_query::<crate::ty::query::queries::#name<'_>, _>(\n-                                $tcx,\n-                                key,\n-                                DUMMY_SP,\n-                                *$dep_node\n-                            );\n-                            return true;\n-                        }\n-                    }\n-                }\n-            });\n-\n             add_query_description_impl(&query, modifiers, &mut query_description_stream);\n         }\n-        let name = &group.name;\n-        query_stream.extend(quote! {\n-            #name { #group_stream },\n-        });\n     }\n \n-    dep_node_force_stream.extend(quote! {\n-        ::rustc_middle::dep_graph::DepKind::Null => {\n-            bug!(\"Cannot force dep node: {:?}\", $dep_node)\n-        }\n-    });\n-\n     TokenStream::from(quote! {\n         macro_rules! rustc_query_append {\n             ([$($macro:tt)*][$($other:tt)*]) => {\n@@ -546,30 +504,12 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 );\n             }\n         }\n-        macro_rules! rustc_dep_node_force {\n-            ([$dep_node:expr, $tcx:expr] $($other:tt)*) => {\n-                match $dep_node.kind {\n-                    $($other)*\n-\n-                    #dep_node_force_stream\n-                }\n-            }\n-        }\n         macro_rules! rustc_cached_queries {\n             ($($macro:tt)*) => {\n                 $($macro)*(#cached_queries);\n             }\n         }\n \n         #query_description_stream\n-\n-        macro_rules! rustc_dep_node_try_load_from_on_disk_cache {\n-            ($dep_node:expr, $tcx:expr) => {\n-                match $dep_node.kind {\n-                    #try_load_from_on_disk_cache_stream\n-                    _ => (),\n-                }\n-            }\n-        }\n     })\n }"}, {"sha": "f6ea6743a0e0476a6dec16e2a0184d3ad5f3d7be", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -2036,13 +2036,13 @@ direct_interners! {\n \n macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ty)),+ $(,)?) => (\n-        $(impl<'tcx> TyCtxt<'tcx> {\n-            pub fn $method(self, v: &[$ty]) -> &'tcx List<$ty> {\n+        impl<'tcx> TyCtxt<'tcx> {\n+            $(pub fn $method(self, v: &[$ty]) -> &'tcx List<$ty> {\n                 self.interners.$field.intern_ref(v, || {\n                     Interned(List::from_arena(&*self.arena, v))\n                 }).0\n-            }\n-        })+\n+            })+\n+        }\n     );\n }\n "}, {"sha": "7ba4d5a14dffb49e474bcbe37a6607ff8b84cd96", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -34,7 +34,6 @@ use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_data_structures::profiling::ProfileCategory::*;\n use rustc_data_structures::stable_hasher::StableVec;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n@@ -169,26 +168,71 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n         return false;\n     }\n \n-    rustc_dep_node_force!([dep_node, tcx]\n-        // These are inputs that are expected to be pre-allocated and that\n-        // should therefore always be red or green already.\n-        DepKind::CrateMetadata |\n+    macro_rules! force_from_dep_node {\n+        ($($(#[$attr:meta])* [$($modifiers:tt)*] $name:ident($K:ty),)*) => {\n+            match dep_node.kind {\n+                // These are inputs that are expected to be pre-allocated and that\n+                // should therefore always be red or green already.\n+                DepKind::CrateMetadata |\n \n-        // These are anonymous nodes.\n-        DepKind::TraitSelect |\n+                // These are anonymous nodes.\n+                DepKind::TraitSelect |\n \n-        // We don't have enough information to reconstruct the query key of\n-        // these.\n-        DepKind::CompileCodegenUnit => {\n-            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n+                // We don't have enough information to reconstruct the query key of\n+                // these.\n+                DepKind::CompileCodegenUnit |\n+\n+                // Forcing this makes no sense.\n+                DepKind::Null => {\n+                    bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n+                }\n+\n+                $(DepKind::$name => {\n+                    debug_assert!(<$K as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key());\n+\n+                    if let Some(key) = <$K as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node) {\n+                        force_query::<queries::$name<'_>, _>(\n+                            tcx,\n+                            key,\n+                            DUMMY_SP,\n+                            *dep_node\n+                        );\n+                        return true;\n+                    }\n+                })*\n+            }\n         }\n-    );\n+    }\n+\n+    rustc_dep_node_append! { [force_from_dep_node!][] }\n \n     false\n }\n \n pub(crate) fn try_load_from_on_disk_cache<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) {\n-    rustc_dep_node_try_load_from_on_disk_cache!(dep_node, tcx)\n+    macro_rules! try_load_from_on_disk_cache {\n+        ($($name:ident,)*) => {\n+            match dep_node.kind {\n+                $(DepKind::$name => {\n+                    if <query_keys::$name<'tcx> as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key() {\n+                        debug_assert!(tcx.dep_graph\n+                                         .node_color(dep_node)\n+                                         .map(|c| c.is_green())\n+                                         .unwrap_or(false));\n+\n+                        let key = <query_keys::$name<'tcx> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node).unwrap();\n+                        if queries::$name::cache_on_disk(tcx, &key, None) {\n+                            let _ = tcx.$name(key);\n+                        }\n+                    }\n+                })*\n+\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    rustc_cached_queries!(try_load_from_on_disk_cache!);\n }\n \n mod sealed {"}, {"sha": "d038695283c107588aa8a252da3d4061f561aeb7", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -242,33 +242,22 @@ macro_rules! hash_result {\n     };\n }\n \n-macro_rules! define_queries {\n-    (<$tcx:tt> $($category:tt {\n-        $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident: $node:ident($($K:tt)*) -> $V:ty,)*\n-    },)*) => {\n-        define_queries_inner! { <$tcx>\n-            $($( $(#[$attr])* category<$category> [$($modifiers)*] fn $name: $node($($K)*) -> $V,)*)*\n-        }\n-    }\n-}\n-\n macro_rules! query_helper_param_ty {\n     (DefId) => { impl IntoQueryParam<DefId> };\n     ($K:ty) => { $K };\n }\n \n-macro_rules! define_queries_inner {\n+macro_rules! define_queries {\n     (<$tcx:tt>\n-     $($(#[$attr:meta])* category<$category:tt>\n-        [$($modifiers:tt)*] fn $name:ident: $node:ident($($K:tt)*) -> $V:ty,)*) => {\n+     $($(#[$attr:meta])*\n+        [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n \n         use std::mem;\n         use crate::{\n             rustc_data_structures::stable_hasher::HashStable,\n             rustc_data_structures::stable_hasher::StableHasher,\n             ich::StableHashingContext\n         };\n-        use rustc_data_structures::profiling::ProfileCategory;\n \n         define_queries_struct! {\n             tcx: $tcx,\n@@ -362,13 +351,12 @@ macro_rules! define_queries_inner {\n                 as QueryStorage\n             >::Stored;\n             const NAME: &'static str = stringify!($name);\n-            const CATEGORY: ProfileCategory = $category;\n         }\n \n         impl<$tcx> QueryAccessors<TyCtxt<$tcx>> for queries::$name<$tcx> {\n             const ANON: bool = is_anon!([$($modifiers)*]);\n             const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n-            const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$node;\n+            const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$name;\n \n             type Cache = query_storage!([$($modifiers)*][$($K)*, $V]);\n "}, {"sha": "e0b44ce23c912c0fba3c5e0f48dc6d28b4bd9787", "filename": "compiler/rustc_middle/src/ty/query/stats.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -120,13 +120,13 @@ pub fn print_stats(tcx: TyCtxt<'_>) {\n }\n \n macro_rules! print_stats {\n-    (<$tcx:tt> $($category:tt {\n-        $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*\n-    },)*) => {\n+    (<$tcx:tt>\n+        $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident($K:ty) -> $V:ty,)*\n+    ) => {\n         fn query_stats(tcx: TyCtxt<'_>) -> Vec<QueryStats> {\n             let mut queries = Vec::new();\n \n-            $($(\n+            $(\n                 queries.push(stats::<\n                     crate::dep_graph::DepKind,\n                     <TyCtxt<'_> as QueryContext>::Query,\n@@ -135,7 +135,7 @@ macro_rules! print_stats {\n                     stringify!($name),\n                     &tcx.queries.$name,\n                 ));\n-            )*)*\n+            )*\n \n             queries\n         }"}, {"sha": "7e2cae094811a07ccc69b533b764917ce63891ae", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -70,9 +70,10 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n     ) -> InterpResult<'tcx> {\n         let def_id = instance.def_id();\n         if Some(def_id) == self.tcx.lang_items().panic_fn()\n+            || Some(def_id) == self.tcx.lang_items().panic_str()\n             || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n         {\n-            // &'static str\n+            // &str\n             assert!(args.len() == 1);\n \n             let msg_place = self.deref_operand(args[0])?;"}, {"sha": "b93d63b4fddb9335d2bdf731f3bce6e1b0e073b0", "filename": "compiler/rustc_mir/src/transform/check_consts/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -74,7 +74,9 @@ impl ConstCx<'mir, 'tcx> {\n \n /// Returns `true` if this `DefId` points to one of the official `panic` lang items.\n pub fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n-    Some(def_id) == tcx.lang_items().panic_fn() || Some(def_id) == tcx.lang_items().begin_panic_fn()\n+    Some(def_id) == tcx.lang_items().panic_fn()\n+        || Some(def_id) == tcx.lang_items().panic_str()\n+        || Some(def_id) == tcx.lang_items().begin_panic_fn()\n }\n \n pub fn allow_internal_unstable(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {"}, {"sha": "06690dcbf6eb7aae23c859b953f3272c6b98b4ce", "filename": "compiler/rustc_mir/src/transform/match_branches.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -38,19 +38,16 @@ pub struct MatchBranchSimplification;\n \n impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        // FIXME: This optimization can result in unsoundness, because it introduces\n-        // additional uses of a place holding the discriminant value without ensuring that\n-        // it is valid to do so.\n-        if !tcx.sess.opts.debugging_opts.unsound_mir_opts {\n+        if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {\n             return;\n         }\n \n         let param_env = tcx.param_env(body.source.def_id());\n-        let bbs = body.basic_blocks_mut();\n+        let (bbs, local_decls) = body.basic_blocks_and_local_decls_mut();\n         'outer: for bb_idx in bbs.indices() {\n             let (discr, val, switch_ty, first, second) = match bbs[bb_idx].terminator().kind {\n                 TerminatorKind::SwitchInt {\n-                    discr: Operand::Copy(ref place) | Operand::Move(ref place),\n+                    discr: ref discr @ (Operand::Copy(_) | Operand::Move(_)),\n                     switch_ty,\n                     ref targets,\n                     ..\n@@ -59,7 +56,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                     if target == targets.otherwise() {\n                         continue;\n                     }\n-                    (place, value, switch_ty, target, targets.otherwise())\n+                    (discr, value, switch_ty, target, targets.otherwise())\n                 }\n                 // Only optimize switch int statements\n                 _ => continue,\n@@ -99,6 +96,10 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n             // Take ownership of items now that we know we can optimize.\n             let discr = discr.clone();\n \n+            // Introduce a temporary for the discriminant value.\n+            let source_info = bbs[bb_idx].terminator().source_info;\n+            let discr_local = local_decls.push(LocalDecl::new(switch_ty, source_info.span));\n+\n             // We already checked that first and second are different blocks,\n             // and bb_idx has a different terminator from both of them.\n             let (from, first, second) = bbs.pick3_mut(bb_idx, first, second);\n@@ -127,7 +128,11 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                                 rustc_span::DUMMY_SP,\n                             );\n                             let op = if f_b { BinOp::Eq } else { BinOp::Ne };\n-                            let rhs = Rvalue::BinaryOp(op, Operand::Copy(discr.clone()), const_cmp);\n+                            let rhs = Rvalue::BinaryOp(\n+                                op,\n+                                Operand::Copy(Place::from(discr_local)),\n+                                const_cmp,\n+                            );\n                             Statement {\n                                 source_info: f.source_info,\n                                 kind: StatementKind::Assign(box (*lhs, rhs)),\n@@ -138,7 +143,16 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                     _ => unreachable!(),\n                 }\n             });\n+\n+            from.statements\n+                .push(Statement { source_info, kind: StatementKind::StorageLive(discr_local) });\n+            from.statements.push(Statement {\n+                source_info,\n+                kind: StatementKind::Assign(box (Place::from(discr_local), Rvalue::Use(discr))),\n+            });\n             from.statements.extend(new_stmts);\n+            from.statements\n+                .push(Statement { source_info, kind: StatementKind::StorageDead(discr_local) });\n             from.terminator_mut().kind = first.terminator().kind.clone();\n         }\n     }"}, {"sha": "576b537c017669140c562cb46a4c6ec6af94703c", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -1,5 +1,5 @@\n use rustc_data_structures::graph::iterate::{\n-    ControlFlow, NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n+    NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n };\n use rustc_hir::intravisit::FnKind;\n use rustc_middle::hir::map::blocks::FnLikeNode;\n@@ -8,6 +8,7 @@ use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n use rustc_span::Span;\n+use std::ops::ControlFlow;\n \n crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n     let def_id = body.source.def_id().expect_local();"}, {"sha": "0449e14983150da08372f98a4c916d97e7777d44", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 111, "deletions": 339, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -302,10 +302,9 @@ use super::{FieldPat, Pat, PatKind, PatRange};\n \n use rustc_arena::TypedArena;\n use rustc_attr::{SignedInt, UnsignedInt};\n-use rustc_errors::ErrorReported;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{HirId, RangeEnd};\n-use rustc_middle::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n+use rustc_middle::mir::interpret::{truncate, ConstValue};\n use rustc_middle::mir::Field;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n@@ -314,108 +313,21 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n-use std::borrow::Cow;\n use std::cmp::{self, max, min, Ordering};\n-use std::convert::TryInto;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n \n-crate fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> Pat<'tcx> {\n-    LiteralExpander { tcx: cx.tcx, param_env: cx.param_env }.fold_pattern(&pat)\n+crate fn expand_pattern<'tcx>(pat: Pat<'tcx>) -> Pat<'tcx> {\n+    LiteralExpander.fold_pattern(&pat)\n }\n \n-struct LiteralExpander<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n+struct LiteralExpander;\n \n-impl<'tcx> LiteralExpander<'tcx> {\n-    /// Derefs `val` and potentially unsizes the value if `crty` is an array and `rty` a slice.\n-    ///\n-    /// `crty` and `rty` can differ because you can use array constants in the presence of slice\n-    /// patterns. So the pattern may end up being a slice, but the constant is an array. We convert\n-    /// the array to a slice in that case.\n-    fn fold_const_value_deref(\n-        &mut self,\n-        val: ConstValue<'tcx>,\n-        // the pattern's pointee type\n-        rty: Ty<'tcx>,\n-        // the constant's pointee type\n-        crty: Ty<'tcx>,\n-    ) -> ConstValue<'tcx> {\n-        debug!(\"fold_const_value_deref {:?} {:?} {:?}\", val, rty, crty);\n-        match (val, &crty.kind(), &rty.kind()) {\n-            // the easy case, deref a reference\n-            (ConstValue::Scalar(p), x, y) if x == y => {\n-                match p {\n-                    Scalar::Ptr(p) => {\n-                        let alloc = self.tcx.global_alloc(p.alloc_id).unwrap_memory();\n-                        ConstValue::ByRef { alloc, offset: p.offset }\n-                    }\n-                    Scalar::Raw { .. } => {\n-                        let layout = self.tcx.layout_of(self.param_env.and(rty)).unwrap();\n-                        if layout.is_zst() {\n-                            // Deref of a reference to a ZST is a nop.\n-                            ConstValue::Scalar(Scalar::zst())\n-                        } else {\n-                            // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;`\n-                            bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty);\n-                        }\n-                    }\n-                }\n-            }\n-            // unsize array to slice if pattern is array but match value or other patterns are slice\n-            (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n-                assert_eq!(t, u);\n-                ConstValue::Slice {\n-                    data: self.tcx.global_alloc(p.alloc_id).unwrap_memory(),\n-                    start: p.offset.bytes().try_into().unwrap(),\n-                    end: n.eval_usize(self.tcx, ty::ParamEnv::empty()).try_into().unwrap(),\n-                }\n-            }\n-            // fat pointers stay the same\n-            (ConstValue::Slice { .. }, _, _)\n-            | (_, ty::Slice(_), ty::Slice(_))\n-            | (_, ty::Str, ty::Str) => val,\n-            // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;` being used\n-            _ => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> PatternFolder<'tcx> for LiteralExpander<'tcx> {\n+impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n         debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind(), pat.kind);\n         match (pat.ty.kind(), &*pat.kind) {\n-            (&ty::Ref(_, rty, _), &PatKind::Constant { value: Const { val, ty: const_ty } })\n-                if const_ty.is_ref() =>\n-            {\n-                let crty =\n-                    if let ty::Ref(_, crty, _) = const_ty.kind() { crty } else { unreachable!() };\n-                if let ty::ConstKind::Value(val) = val {\n-                    Pat {\n-                        ty: pat.ty,\n-                        span: pat.span,\n-                        kind: box PatKind::Deref {\n-                            subpattern: Pat {\n-                                ty: rty,\n-                                span: pat.span,\n-                                kind: box PatKind::Constant {\n-                                    value: Const::from_value(\n-                                        self.tcx,\n-                                        self.fold_const_value_deref(*val, rty, crty),\n-                                        rty,\n-                                    ),\n-                                },\n-                            },\n-                        },\n-                    }\n-                } else {\n-                    bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty)\n-                }\n-            }\n-\n             (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => s.fold_with(self),\n             (_, &PatKind::AscribeUserType { subpattern: ref s, .. }) => s.fold_with(self),\n             _ => pat.super_fold_with(self),\n@@ -500,9 +412,15 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+        is_my_head_ctor: bool,\n     ) -> Option<PatStack<'p, 'tcx>> {\n-        let new_fields =\n-            specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns)?;\n+        let new_fields = specialize_one_pattern(\n+            cx,\n+            self.head(),\n+            constructor,\n+            ctor_wild_subpatterns,\n+            is_my_head_ctor,\n+        )?;\n         Some(new_fields.push_on_patstack(&self.0[1..]))\n     }\n }\n@@ -680,6 +598,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                                 cx,\n                                 constructor,\n                                 ctor_wild_subpatterns,\n+                                false,\n                             )\n                         })\n                         .collect()\n@@ -705,7 +624,9 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n             SpecializationCache::Incompatible => self\n                 .patterns\n                 .iter()\n-                .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n+                .filter_map(|r| {\n+                    r.specialize_constructor(cx, constructor, ctor_wild_subpatterns, false)\n+                })\n                 .collect(),\n         }\n     }\n@@ -725,6 +646,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n /// +++++++++++++++++++++++++++++\n /// + _     + [_, _, tail @ ..] +\n /// +++++++++++++++++++++++++++++\n+/// ```\n impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"\\n\")?;\n@@ -926,42 +848,30 @@ enum Constructor<'tcx> {\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n-    /// Literal values.\n-    ConstantValue(&'tcx ty::Const<'tcx>),\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n     IntRange(IntRange<'tcx>),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n     FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n+    /// String literals. Strings are not quite the same as `&[u8]` so we treat them separately.\n+    Str(&'tcx ty::Const<'tcx>),\n     /// Array and slice patterns.\n     Slice(Slice),\n+    /// Constants that must not be matched structurally. They are treated as black\n+    /// boxes for the purposes of exhaustiveness: we must not inspect them, and they\n+    /// don't count towards making a match exhaustive.\n+    Opaque,\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n }\n \n impl<'tcx> Constructor<'tcx> {\n-    fn is_slice(&self) -> bool {\n-        match self {\n-            Slice(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn variant_index_for_adt<'a>(\n-        &self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n-        adt: &'tcx ty::AdtDef,\n-    ) -> VariantIdx {\n+    fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> VariantIdx {\n         match *self {\n             Variant(id) => adt.variant_index_with_id(id),\n             Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n-            ConstantValue(c) => cx\n-                .tcx\n-                .destructure_const(cx.param_env.and(c))\n-                .variant\n-                .expect(\"destructed const of adt without variant id\"),\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt),\n         }\n     }\n@@ -975,16 +885,14 @@ impl<'tcx> Constructor<'tcx> {\n \n         match self {\n             // Those constructors can only match themselves.\n-            Single | Variant(_) | ConstantValue(..) | FloatRange(..) => {\n+            Single | Variant(_) | Str(..) | FloatRange(..) => {\n                 if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n             }\n             &Slice(slice) => {\n                 let mut other_slices = other_ctors\n                     .iter()\n                     .filter_map(|c: &Constructor<'_>| match c {\n                         Slice(slice) => Some(*slice),\n-                        // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                        ConstantValue(..) => None,\n                         _ => bug!(\"bad slice pattern constructor {:?}\", c),\n                     })\n                     .map(Slice::value_kind);\n@@ -1048,6 +956,7 @@ impl<'tcx> Constructor<'tcx> {\n             }\n             // This constructor is never covered by anything else\n             NonExhaustive => vec![NonExhaustive],\n+            Opaque => bug!(\"unexpected opaque ctor {:?} found in all_ctors\", self),\n         }\n     }\n \n@@ -1087,7 +996,7 @@ impl<'tcx> Constructor<'tcx> {\n                             PatKind::Variant {\n                                 adt_def: adt,\n                                 substs,\n-                                variant_index: self.variant_index_for_adt(cx, adt),\n+                                variant_index: self.variant_index_for_adt(adt),\n                                 subpatterns,\n                             }\n                         } else {\n@@ -1126,10 +1035,11 @@ impl<'tcx> Constructor<'tcx> {\n                     PatKind::Slice { prefix, slice: Some(wild), suffix }\n                 }\n             },\n-            &ConstantValue(value) => PatKind::Constant { value },\n+            &Str(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(cx.tcx),\n             NonExhaustive => PatKind::Wild,\n+            Opaque => bug!(\"we should not try to apply an opaque constructor {:?}\", self),\n         };\n \n         Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n@@ -1204,12 +1114,6 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         Fields::Slice(std::slice::from_ref(pat))\n     }\n \n-    /// Construct a new `Fields` from the given patterns. You must be sure those patterns can't\n-    /// contain fields that need to be filtered out. When in doubt, prefer `replace_fields`.\n-    fn from_slice_unfiltered(pats: &'p [Pat<'tcx>]) -> Self {\n-        Fields::Slice(pats)\n-    }\n-\n     /// Convenience; internal use.\n     fn wildcards_from_tys(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n@@ -1239,7 +1143,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         // Use T as the sub pattern type of Box<T>.\n                         Fields::from_single_pattern(wildcard_from_ty(substs.type_at(0)))\n                     } else {\n-                        let variant = &adt.variants[constructor.variant_index_for_adt(cx, adt)];\n+                        let variant = &adt.variants[constructor.variant_index_for_adt(adt)];\n                         // Whether we must not match the fields of this variant exhaustively.\n                         let is_non_exhaustive =\n                             variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n@@ -1287,7 +1191,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n-            ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => Fields::empty(),\n+            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque => Fields::empty(),\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n@@ -1600,9 +1504,7 @@ fn all_constructors<'a, 'tcx>(\n         )\n     };\n     match *pcx.ty.kind() {\n-        ty::Bool => {\n-            [true, false].iter().map(|&b| ConstantValue(ty::Const::from_bool(cx.tcx, b))).collect()\n-        }\n+        ty::Bool => vec![make_range(0, 1)],\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n@@ -1717,7 +1619,7 @@ impl<'tcx> IntRange<'tcx> {\n     #[inline]\n     fn is_integral(ty: Ty<'_>) -> bool {\n         match ty.kind() {\n-            ty::Char | ty::Int(_) | ty::Uint(_) => true,\n+            ty::Char | ty::Int(_) | ty::Uint(_) | ty::Bool => true,\n             _ => false,\n         }\n     }\n@@ -1739,6 +1641,7 @@ impl<'tcx> IntRange<'tcx> {\n     #[inline]\n     fn integral_size_and_signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'_>) -> Option<(Size, u128)> {\n         match *ty.kind() {\n+            ty::Bool => Some((Size::from_bytes(1), 0)),\n             ty::Char => Some((Size::from_bytes(4), 0)),\n             ty::Int(ity) => {\n                 let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n@@ -2230,7 +2133,7 @@ fn is_useful_specialized<'p, 'tcx>(\n     // We cache the result of `Fields::wildcards` because it is used a lot.\n     let ctor_wild_subpatterns = Fields::wildcards(cx, &ctor, ty);\n     let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n-    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n+    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns, true)\n         .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false))\n         .map(|u| u.apply_constructor(cx, &ctor, ty, &ctor_wild_subpatterns))\n         .unwrap_or(NotUseful)\n@@ -2255,18 +2158,13 @@ fn pat_constructor<'tcx>(\n             if let Some(int_range) = IntRange::from_const(tcx, param_env, value, pat.span) {\n                 Some(IntRange(int_range))\n             } else {\n-                match (value.val, &value.ty.kind()) {\n-                    (_, ty::Array(_, n)) => {\n-                        let len = n.eval_usize(tcx, param_env);\n-                        Some(Slice(Slice { array_len: Some(len), kind: FixedLen(len) }))\n-                    }\n-                    (ty::ConstKind::Value(ConstValue::Slice { start, end, .. }), ty::Slice(_)) => {\n-                        let len = (end - start) as u64;\n-                        Some(Slice(Slice { array_len: None, kind: FixedLen(len) }))\n-                    }\n-                    // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                    // (ty::ConstKind::Value(ConstValue::ByRef { .. }), ty::Slice(_)) => { ... }\n-                    _ => Some(ConstantValue(value)),\n+                match value.ty.kind() {\n+                    ty::Float(_) => Some(FloatRange(value, value, RangeEnd::Included)),\n+                    ty::Ref(_, t, _) if t.is_str() => Some(Str(value)),\n+                    // All constants that can be structurally matched have already been expanded\n+                    // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n+                    // opaque.\n+                    _ => Some(Opaque),\n                 }\n             }\n         }\n@@ -2302,75 +2200,6 @@ fn pat_constructor<'tcx>(\n     }\n }\n \n-// checks whether a constant is equal to a user-written slice pattern. Only supports byte slices,\n-// meaning all other types will compare unequal and thus equal patterns often do not cause the\n-// second pattern to lint about unreachable match arms.\n-fn slice_pat_covered_by_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    _span: Span,\n-    const_val: &'tcx ty::Const<'tcx>,\n-    prefix: &[Pat<'tcx>],\n-    slice: &Option<Pat<'tcx>>,\n-    suffix: &[Pat<'tcx>],\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> Result<bool, ErrorReported> {\n-    let const_val_val = if let ty::ConstKind::Value(val) = const_val.val {\n-        val\n-    } else {\n-        bug!(\n-            \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n-            const_val,\n-            prefix,\n-            slice,\n-            suffix,\n-        )\n-    };\n-\n-    let data: &[u8] = match (const_val_val, &const_val.ty.kind()) {\n-        (ConstValue::ByRef { offset, alloc, .. }, ty::Array(t, n)) => {\n-            assert_eq!(*t, tcx.types.u8);\n-            let n = n.eval_usize(tcx, param_env);\n-            let ptr = Pointer::new(AllocId(0), offset);\n-            alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n-        }\n-        (ConstValue::Slice { data, start, end }, ty::Slice(t)) => {\n-            assert_eq!(*t, tcx.types.u8);\n-            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start));\n-            data.get_bytes(&tcx, ptr, Size::from_bytes(end - start)).unwrap()\n-        }\n-        // FIXME(oli-obk): create a way to extract fat pointers from ByRef\n-        (_, ty::Slice(_)) => return Ok(false),\n-        _ => bug!(\n-            \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n-            const_val,\n-            prefix,\n-            slice,\n-            suffix,\n-        ),\n-    };\n-\n-    let pat_len = prefix.len() + suffix.len();\n-    if data.len() < pat_len || (slice.is_none() && data.len() > pat_len) {\n-        return Ok(false);\n-    }\n-\n-    for (ch, pat) in data[..prefix.len()]\n-        .iter()\n-        .zip(prefix)\n-        .chain(data[data.len() - suffix.len()..].iter().zip(suffix))\n-    {\n-        if let box PatKind::Constant { value } = pat.kind {\n-            let b = value.eval_bits(tcx, param_env, pat.ty);\n-            assert_eq!(b as u8 as u128, b);\n-            if b as u8 != *ch {\n-                return Ok(false);\n-            }\n-        }\n-    }\n-\n-    Ok(true)\n-}\n-\n /// For exhaustive integer matching, some constructors are grouped within other constructors\n /// (namely integer typed values are grouped within ranges). However, when specialising these\n /// constructors, we want to be specialising for the underlying constructors (the integers), not\n@@ -2668,35 +2497,6 @@ fn lint_overlapping_patterns<'tcx>(\n     }\n }\n \n-fn constructor_covered_by_range<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ctor: &Constructor<'tcx>,\n-    pat: &Pat<'tcx>,\n-) -> Option<()> {\n-    if let Single = ctor {\n-        return Some(());\n-    }\n-\n-    let (pat_from, pat_to, pat_end, ty) = match *pat.kind {\n-        PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-        PatKind::Range(PatRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n-        _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n-    };\n-    let (ctor_from, ctor_to, ctor_end) = match *ctor {\n-        ConstantValue(value) => (value, value, RangeEnd::Included),\n-        FloatRange(from, to, ctor_end) => (from, to, ctor_end),\n-        _ => bug!(\"`constructor_covered_by_range` called with {:?}\", ctor),\n-    };\n-    trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, pat_from, pat_to, ty);\n-\n-    let to = compare_const_vals(tcx, ctor_to, pat_to, param_env, ty)?;\n-    let from = compare_const_vals(tcx, ctor_from, pat_from, param_env, ty)?;\n-    let intersects = (from == Ordering::Greater || from == Ordering::Equal)\n-        && (to == Ordering::Less || (pat_end == ctor_end && to == Ordering::Equal));\n-    if intersects { Some(()) } else { None }\n-}\n-\n /// This is the main specialization step. It expands the pattern\n /// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n /// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n@@ -2713,15 +2513,43 @@ fn specialize_one_pattern<'p, 'tcx>(\n     pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n     ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+    is_its_own_ctor: bool, // Whether `ctor` is known to be derived from `pat`\n ) -> Option<Fields<'p, 'tcx>> {\n     if let NonExhaustive = constructor {\n-        // Only a wildcard pattern can match the special extra constructor\n+        // Only a wildcard pattern can match the special extra constructor.\n         if !pat.is_wildcard() {\n             return None;\n         }\n         return Some(Fields::empty());\n     }\n \n+    if let Opaque = constructor {\n+        // Only a wildcard pattern can match an opaque constant, unless we're specializing the\n+        // value against its own constructor. That happens when we call\n+        // `v.specialize_constructor(ctor)` with `ctor` obtained from `pat_constructor(v.head())`.\n+        // For example, in the following match, when we are dealing with the third branch, we will\n+        // specialize with an `Opaque` ctor. We want to ignore the second branch because opaque\n+        // constants should not be inspected, but we don't want to ignore the current (third)\n+        // branch, as that would cause us to always conclude that such a branch is unreachable.\n+        // ```rust\n+        // #[derive(PartialEq)]\n+        // struct Foo(i32);\n+        // impl Eq for Foo {}\n+        // const FOO: Foo = Foo(42);\n+        //\n+        // match (Foo(0), true) {\n+        //     (_, true) => {}\n+        //     (FOO, true) => {}\n+        //     (FOO, false) => {}\n+        // }\n+        // ```\n+        if is_its_own_ctor || pat.is_wildcard() {\n+            return Some(Fields::empty());\n+        } else {\n+            return None;\n+        }\n+    }\n+\n     let result = match *pat.kind {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n \n@@ -2741,93 +2569,52 @@ fn specialize_one_pattern<'p, 'tcx>(\n \n         PatKind::Deref { ref subpattern } => Some(Fields::from_single_pattern(subpattern)),\n \n-        PatKind::Constant { value } if constructor.is_slice() => {\n-            // We extract an `Option` for the pointer because slices of zero\n-            // elements don't necessarily point to memory, they are usually\n-            // just integers. The only time they should be pointing to memory\n-            // is when they are subslices of nonzero slices.\n-            let (alloc, offset, n, ty) = match value.ty.kind() {\n-                ty::Array(t, n) => {\n-                    let n = n.eval_usize(cx.tcx, cx.param_env);\n-                    // Shortcut for `n == 0` where no matter what `alloc` and `offset` we produce,\n-                    // the result would be exactly what we early return here.\n-                    if n == 0 {\n-                        if ctor_wild_subpatterns.len() as u64 != n {\n-                            return None;\n-                        }\n-                        return Some(Fields::empty());\n-                    }\n-                    match value.val {\n-                        ty::ConstKind::Value(ConstValue::ByRef { offset, alloc, .. }) => {\n-                            (Cow::Borrowed(alloc), offset, n, t)\n-                        }\n-                        _ => span_bug!(pat.span, \"array pattern is {:?}\", value,),\n+        PatKind::Constant { .. } | PatKind::Range { .. } => {\n+            match constructor {\n+                IntRange(ctor) => {\n+                    let pat = IntRange::from_pat(cx.tcx, cx.param_env, pat)?;\n+                    ctor.intersection(cx.tcx, &pat)?;\n+                    // Constructor splitting should ensure that all intersections we encounter\n+                    // are actually inclusions.\n+                    assert!(ctor.is_subrange(&pat));\n+                }\n+                FloatRange(ctor_from, ctor_to, ctor_end) => {\n+                    let (pat_from, pat_to, pat_end, ty) = match *pat.kind {\n+                        PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n+                        PatKind::Range(PatRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n+                        _ => unreachable!(), // This is ensured by the branch we're in\n+                    };\n+                    let to = compare_const_vals(cx.tcx, ctor_to, pat_to, cx.param_env, ty)?;\n+                    let from = compare_const_vals(cx.tcx, ctor_from, pat_from, cx.param_env, ty)?;\n+                    let intersects = (from == Ordering::Greater || from == Ordering::Equal)\n+                        && (to == Ordering::Less\n+                            || (pat_end == *ctor_end && to == Ordering::Equal));\n+                    if !intersects {\n+                        return None;\n                     }\n                 }\n-                ty::Slice(t) => {\n-                    match value.val {\n-                        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n-                            let offset = Size::from_bytes(start);\n-                            let n = (end - start) as u64;\n-                            (Cow::Borrowed(data), offset, n, t)\n-                        }\n-                        ty::ConstKind::Value(ConstValue::ByRef { .. }) => {\n-                            // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                            return None;\n-                        }\n+                Str(ctor_value) => {\n+                    let pat_value = match *pat.kind {\n+                        PatKind::Constant { value } => value,\n                         _ => span_bug!(\n                             pat.span,\n-                            \"slice pattern constant must be scalar pair but is {:?}\",\n-                            value,\n+                            \"unexpected range pattern {:?} for constant value ctor\",\n+                            pat\n                         ),\n+                    };\n+\n+                    // FIXME: there's probably a more direct way of comparing for equality\n+                    if compare_const_vals(cx.tcx, ctor_value, pat_value, cx.param_env, pat.ty)?\n+                        != Ordering::Equal\n+                    {\n+                        return None;\n                     }\n                 }\n-                _ => span_bug!(\n-                    pat.span,\n-                    \"unexpected const-val {:?} with ctor {:?}\",\n-                    value,\n-                    constructor,\n-                ),\n-            };\n-            if ctor_wild_subpatterns.len() as u64 != n {\n-                return None;\n-            }\n-\n-            // Convert a constant slice/array pattern to a list of patterns.\n-            let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n-            let ptr = Pointer::new(AllocId(0), offset);\n-            let pats = cx.pattern_arena.alloc_from_iter((0..n).filter_map(|i| {\n-                let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n-                let scalar = scalar.check_init().ok()?;\n-                let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                let pattern = Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n-                Some(pattern)\n-            }));\n-            // Ensure none of the dereferences failed.\n-            if pats.len() as u64 != n {\n-                return None;\n-            }\n-            Some(Fields::from_slice_unfiltered(pats))\n-        }\n-\n-        PatKind::Constant { .. } | PatKind::Range { .. } => {\n-            // If the constructor is a:\n-            // - Single value: add a row if the pattern contains the constructor.\n-            // - Range: add a row if the constructor intersects the pattern.\n-            if let IntRange(ctor) = constructor {\n-                let pat = IntRange::from_pat(cx.tcx, cx.param_env, pat)?;\n-                ctor.intersection(cx.tcx, &pat)?;\n-                // Constructor splitting should ensure that all intersections we encounter\n-                // are actually inclusions.\n-                assert!(ctor.is_subrange(&pat));\n-            } else {\n-                // Fallback for non-ranges and ranges that involve\n-                // floating-point numbers, which are not conveniently handled\n-                // by `IntRange`. For these cases, the constructor may not be a\n-                // range so intersection actually devolves into being covered\n-                // by the pattern.\n-                constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat)?;\n+                _ => {\n+                    // If we reach here, we must be trying to inspect an opaque constant. Thus we skip\n+                    // the row.\n+                    return None;\n+                }\n             }\n             Some(Fields::empty())\n         }\n@@ -2850,21 +2637,6 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 let suffix = suffix.iter().enumerate().map(|(i, p)| (arity - suffix.len() + i, p));\n                 Some(ctor_wild_subpatterns.replace_fields_indexed(prefix.chain(suffix)))\n             }\n-            ConstantValue(cv) => {\n-                match slice_pat_covered_by_const(\n-                    cx.tcx,\n-                    pat.span,\n-                    cv,\n-                    prefix,\n-                    slice,\n-                    suffix,\n-                    cx.param_env,\n-                ) {\n-                    Ok(true) => Some(Fields::empty()),\n-                    Ok(false) => None,\n-                    Err(ErrorReported) => None,\n-                }\n-            }\n             _ => span_bug!(pat.span, \"unexpected ctor {:?} for slice pat\", constructor),\n         },\n "}, {"sha": "30b700a1d4f63e6c0fb6e9dda087d4002b8597c9", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -137,7 +137,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         patcx.include_lint_checks();\n         let pattern = patcx.lower_pattern(pat);\n         let pattern_ty = pattern.ty;\n-        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n+        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(pattern));\n         if !patcx.errors.is_empty() {\n             *have_errors = true;\n             patcx.report_inlining_errors(pat.span);"}, {"sha": "6370f8c375b2a91cf5d4cef7018d52f96b6e6aec", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -387,14 +387,16 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // `&str` and `&[u8]` are represented as `ConstValue::Slice`, let's keep using this\n                 // optimization for now.\n                 ty::Str => PatKind::Constant { value: cv },\n-                ty::Slice(elem_ty) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n                 // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n                 // matching against references, you can only use byte string literals.\n-                // FIXME: clean this up, likely by permitting array patterns when matching on slices\n-                ty::Array(elem_ty, _) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n+                // The typechecker has a special case for byte string literals, by treating them\n+                // as slices. This means we turn `&[T; N]` constants into slice patterns, which\n+                // has no negative effects on pattern matching, even if we're actually matching on\n+                // arrays.\n+                ty::Array(..) |\n                 // Cannot merge this with the catch all branch below, because the `const_deref`\n-                // changes the type from slice to array, and slice patterns behave differently from\n-                // array patterns.\n+                // changes the type from slice to array, we need to keep the original type in the\n+                // pattern.\n                 ty::Slice(..) => {\n                     let old = self.behind_reference.replace(true);\n                     let array = tcx.deref_const(self.param_env.and(cv));"}, {"sha": "25e187243416d5e412c9b552f3fbc54873739816", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -158,6 +158,13 @@ crate enum PatKind<'tcx> {\n         subpattern: Pat<'tcx>,\n     },\n \n+    /// One of the following:\n+    /// * `&str`, which will be handled as a string pattern and thus exhaustiveness\n+    ///   checking will detect if you use the same string twice in different patterns.\n+    /// * integer, bool, char or float, which will be handled by exhaustivenes to cover exactly\n+    ///   its own value, similar to `&str`, but these values are much simpler.\n+    /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n+    ///   `PartialEq` and `Eq`.\n     Constant {\n         value: &'tcx ty::Const<'tcx>,\n     },"}, {"sha": "0f0684b354791b549120d1e29101ac9a0095955b", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -5,7 +5,6 @@ use crate::dep_graph::SerializedDepNodeIndex;\n use crate::query::caches::QueryCache;\n use crate::query::plumbing::CycleError;\n use crate::query::{QueryContext, QueryState};\n-use rustc_data_structures::profiling::ProfileCategory;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use std::borrow::Cow;\n@@ -14,7 +13,6 @@ use std::hash::Hash;\n \n pub trait QueryConfig {\n     const NAME: &'static str;\n-    const CATEGORY: ProfileCategory;\n \n     type Key: Eq + Hash + Clone + Debug;\n     type Value;"}, {"sha": "b5b281b93bcae5376115c7588b4a64d1adf42576", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -19,7 +19,7 @@ use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id;\n use rustc_middle::middle::stability;\n-use rustc_middle::{span_bug, ty};\n+use rustc_middle::ty;\n use rustc_session::lint::builtin::UNUSED_MACROS;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n@@ -885,11 +885,11 @@ impl<'a> Resolver<'a> {\n                                  initial_res: Option<Res>,\n                                  res: Res| {\n             if let Some(initial_res) = initial_res {\n-                if res != initial_res && res != Res::Err && this.ambiguity_errors.is_empty() {\n+                if res != initial_res {\n                     // Make sure compilation does not succeed if preferred macro resolution\n                     // has changed after the macro had been expanded. In theory all such\n-                    // situations should be reported as ambiguity errors, so this is a bug.\n-                    span_bug!(span, \"inconsistent resolution for a macro\");\n+                    // situations should be reported as errors, so this is a bug.\n+                    this.session.delay_span_bug(span, \"inconsistent resolution for a macro\");\n                 }\n             } else {\n                 // It's possible that the macro was unresolved (indeterminate) and silently"}, {"sha": "3133090575e36e0dc6adde677303c88aee11fa97", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -777,6 +777,7 @@ symbols! {\n         panic_info,\n         panic_location,\n         panic_runtime,\n+        panic_str,\n         panic_unwind,\n         param_attrs,\n         parent_trait,"}, {"sha": "3cb6ec8626186f511710f5d26f7b9615d256090b", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -121,7 +121,10 @@ where\n     // contains unbound type parameters. It could be a slight\n     // optimization to stop iterating early.\n     if let Err(errors) = fulfill_cx.select_all_or_error(infcx) {\n-        bug!(\"Encountered errors `{:?}` resolving bounds after type-checking\", errors);\n+        infcx.tcx.sess.delay_span_bug(\n+            rustc_span::DUMMY_SP,\n+            &format!(\"Encountered errors `{:?}` resolving bounds after type-checking\", errors),\n+        );\n     }\n \n     let result = infcx.resolve_vars_if_possible(result);"}, {"sha": "c79b2624f8cb0256d003fd53ae9e4ede270c1c34", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 64, "deletions": 21, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -223,11 +223,23 @@ impl AbstractConst<'tcx> {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+struct WorkNode<'tcx> {\n+    node: Node<'tcx>,\n+    span: Span,\n+    used: bool,\n+}\n+\n struct AbstractConstBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n     /// The current WIP node tree.\n-    nodes: IndexVec<NodeId, Node<'tcx>>,\n+    ///\n+    /// We require all nodes to be used in the final abstract const,\n+    /// so we store this here. Note that we also consider nodes as used\n+    /// if they are mentioned in an assert, so some used nodes are never\n+    /// actually reachable by walking the [`AbstractConst`].\n+    nodes: IndexVec<NodeId, WorkNode<'tcx>>,\n     locals: IndexVec<mir::Local, NodeId>,\n     /// We only allow field accesses if they access\n     /// the result of a checked operation.\n@@ -274,6 +286,27 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         Ok(Some(builder))\n     }\n \n+    fn add_node(&mut self, node: Node<'tcx>, span: Span) -> NodeId {\n+        // Mark used nodes.\n+        match node {\n+            Node::Leaf(_) => (),\n+            Node::Binop(_, lhs, rhs) => {\n+                self.nodes[lhs].used = true;\n+                self.nodes[rhs].used = true;\n+            }\n+            Node::UnaryOp(_, input) => {\n+                self.nodes[input].used = true;\n+            }\n+            Node::FunctionCall(func, nodes) => {\n+                self.nodes[func].used = true;\n+                nodes.iter().for_each(|&n| self.nodes[n].used = true);\n+            }\n+        }\n+\n+        // Nodes start as unused.\n+        self.nodes.push(WorkNode { node, span, used: false })\n+    }\n+\n     fn place_to_local(\n         &mut self,\n         span: Span,\n@@ -311,7 +344,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 let local = self.place_to_local(span, p)?;\n                 Ok(self.locals[local])\n             }\n-            mir::Operand::Constant(ct) => Ok(self.nodes.push(Node::Leaf(ct.literal))),\n+            mir::Operand::Constant(ct) => Ok(self.add_node(Node::Leaf(ct.literal), span)),\n         }\n     }\n \n@@ -336,38 +369,38 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n     fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Result<(), ErrorReported> {\n         debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n+        let span = stmt.source_info.span;\n         match stmt.kind {\n             StatementKind::Assign(box (ref place, ref rvalue)) => {\n-                let local = self.place_to_local(stmt.source_info.span, place)?;\n+                let local = self.place_to_local(span, place)?;\n                 match *rvalue {\n                     Rvalue::Use(ref operand) => {\n-                        self.locals[local] =\n-                            self.operand_to_node(stmt.source_info.span, operand)?;\n+                        self.locals[local] = self.operand_to_node(span, operand)?;\n                         Ok(())\n                     }\n                     Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n-                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n-                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n+                        let lhs = self.operand_to_node(span, lhs)?;\n+                        let rhs = self.operand_to_node(span, rhs)?;\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n                         if op.is_checkable() {\n                             bug!(\"unexpected unchecked checkable binary operation\");\n                         } else {\n                             Ok(())\n                         }\n                     }\n                     Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n-                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n-                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n+                        let lhs = self.operand_to_node(span, lhs)?;\n+                        let rhs = self.operand_to_node(span, rhs)?;\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n                         self.checked_op_locals.insert(local);\n                         Ok(())\n                     }\n                     Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n-                        let operand = self.operand_to_node(stmt.source_info.span, operand)?;\n-                        self.locals[local] = self.nodes.push(Node::UnaryOp(op, operand));\n+                        let operand = self.operand_to_node(span, operand)?;\n+                        self.locals[local] = self.add_node(Node::UnaryOp(op, operand), span);\n                         Ok(())\n                     }\n-                    _ => self.error(Some(stmt.source_info.span), \"unsupported rvalue\")?,\n+                    _ => self.error(Some(span), \"unsupported rvalue\")?,\n                 }\n             }\n             // These are not actually relevant for us here, so we can ignore them.\n@@ -415,13 +448,9 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                         .map(|arg| self.operand_to_node(terminator.source_info.span, arg))\n                         .collect::<Result<Vec<NodeId>, _>>()?,\n                 );\n-                self.locals[local] = self.nodes.push(Node::FunctionCall(func, args));\n+                self.locals[local] = self.add_node(Node::FunctionCall(func, args), fn_span);\n                 Ok(Some(target))\n             }\n-            // We only allow asserts for checked operations.\n-            //\n-            // These asserts seem to all have the form `!_local.0` so\n-            // we only allow exactly that.\n             TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n                 let p = match cond {\n                     mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n@@ -430,7 +459,15 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n                 const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n                 debug!(\"proj: {:?}\", p.projection);\n-                if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n+                if let Some(p) = p.as_local() {\n+                    debug_assert!(!self.checked_op_locals.contains(p));\n+                    // Mark locals directly used in asserts as used.\n+                    //\n+                    // This is needed because division does not use `CheckedBinop` but instead\n+                    // adds an explicit assert for `divisor != 0`.\n+                    self.nodes[self.locals[p]].used = true;\n+                    return Ok(Some(target));\n+                } else if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n                     // Only allow asserts checking the result of a checked operation.\n                     if self.checked_op_locals.contains(p.local) {\n                         return Ok(Some(target));\n@@ -457,7 +494,13 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             if let Some(next) = self.build_terminator(block.terminator())? {\n                 block = &self.body.basic_blocks()[next];\n             } else {\n-                return Ok(self.tcx.arena.alloc_from_iter(self.nodes));\n+                assert_eq!(self.locals[mir::RETURN_PLACE], self.nodes.last().unwrap());\n+                self.nodes[self.locals[mir::RETURN_PLACE]].used = true;\n+                if let Some(&unused) = self.nodes.iter().find(|n| !n.used) {\n+                    self.error(Some(unused.span), \"dead code\")?;\n+                }\n+\n+                return Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter().map(|n| n.node)));\n             }\n         }\n     }"}, {"sha": "dd7dcfbc4aa452f55b94af9b1ab305d5b3b4d1b5", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -372,7 +372,7 @@ pub fn handle_alloc_error(layout: Layout) -> ! {\n     unsafe { oom_impl(layout) }\n }\n \n-#[cfg(not(any(test, bootstrap)))]\n+#[cfg(not(any(target_os = \"hermit\", test, bootstrap)))]\n #[doc(hidden)]\n #[allow(unused_attributes)]\n #[unstable(feature = \"alloc_internals\", issue = \"none\")]"}, {"sha": "9c8e639c2d802cfcf0350386b69575e874f5345a", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -1280,7 +1280,7 @@ where\n         #[inline]\n         fn find<T, B>(\n             f: &mut impl FnMut(T) -> Option<B>,\n-        ) -> impl FnMut((), T) -> ControlFlow<(), B> + '_ {\n+        ) -> impl FnMut((), T) -> ControlFlow<B> + '_ {\n             move |(), x| match f(x) {\n                 Some(x) => ControlFlow::Break(x),\n                 None => ControlFlow::CONTINUE,\n@@ -2059,7 +2059,7 @@ where\n             flag: &'a mut bool,\n             p: &'a mut impl FnMut(&T) -> bool,\n             mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n             move |acc, x| {\n                 if p(&x) {\n                     ControlFlow::from_try(fold(acc, x))\n@@ -2372,7 +2372,7 @@ where\n         fn check<T, Acc, R: Try<Ok = Acc>>(\n             mut n: usize,\n             mut fold: impl FnMut(Acc, T) -> R,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> {\n             move |acc, x| {\n                 n -= 1;\n                 let r = fold(acc, x);\n@@ -2496,7 +2496,7 @@ where\n         fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n             n: &'a mut usize,\n             mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n             move |acc, x| {\n                 *n -= 1;\n                 let r = fold(acc, x);\n@@ -2681,7 +2681,7 @@ where\n             state: &'a mut St,\n             f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n             mut fold: impl FnMut(Acc, B) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n             move |acc, x| match f(state, x) {\n                 None => ControlFlow::Break(try { acc }),\n                 Some(x) => ControlFlow::from_try(fold(acc, x)),"}, {"sha": "6f8cb6b5a65b6fcdef683a4b24b300cbfd1037e0", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -339,9 +339,7 @@ pub trait DoubleEndedIterator: Iterator {\n         P: FnMut(&Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(\n-            mut predicate: impl FnMut(&T) -> bool,\n-        ) -> impl FnMut((), T) -> ControlFlow<(), T> {\n+        fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut((), T) -> ControlFlow<T> {\n             move |(), x| {\n                 if predicate(&x) { ControlFlow::Break(x) } else { ControlFlow::CONTINUE }\n             }"}, {"sha": "7fc60caec2a736fe5ee56895dc3575188c43bdab", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -2109,7 +2109,7 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<(), ()> {\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<()> {\n             move |(), x| {\n                 if f(x) { ControlFlow::CONTINUE } else { ControlFlow::BREAK }\n             }\n@@ -2162,7 +2162,7 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<(), ()> {\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<()> {\n             move |(), x| {\n                 if f(x) { ControlFlow::BREAK } else { ControlFlow::CONTINUE }\n             }\n@@ -2222,9 +2222,7 @@ pub trait Iterator {\n         P: FnMut(&Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(\n-            mut predicate: impl FnMut(&T) -> bool,\n-        ) -> impl FnMut((), T) -> ControlFlow<(), T> {\n+        fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut((), T) -> ControlFlow<T> {\n             move |(), x| {\n                 if predicate(&x) { ControlFlow::Break(x) } else { ControlFlow::CONTINUE }\n             }\n@@ -2255,9 +2253,7 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n         #[inline]\n-        fn check<T, B>(\n-            mut f: impl FnMut(T) -> Option<B>,\n-        ) -> impl FnMut((), T) -> ControlFlow<(), B> {\n+        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut((), T) -> ControlFlow<B> {\n             move |(), x| match f(x) {\n                 Some(x) => ControlFlow::Break(x),\n                 None => ControlFlow::CONTINUE,\n@@ -2296,7 +2292,7 @@ pub trait Iterator {\n         R: Try<Ok = bool>,\n     {\n         #[inline]\n-        fn check<F, T, R>(mut f: F) -> impl FnMut((), T) -> ControlFlow<(), Result<T, R::Error>>\n+        fn check<F, T, R>(mut f: F) -> impl FnMut((), T) -> ControlFlow<Result<T, R::Error>>\n         where\n             F: FnMut(&T) -> R,\n             R: Try<Ok = bool>,"}, {"sha": "ac45e819cf67a23a82186b45adb3942606ea6b0f", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -10,7 +10,7 @@ macro_rules! panic {\n         $crate::panicking::panic($msg)\n     );\n     ($msg:expr) => (\n-        $crate::panic!(\"{}\", $crate::convert::identity::<&str>($msg))\n+        $crate::panicking::panic_str($msg)\n     );\n     ($msg:expr,) => (\n         $crate::panic!($msg)"}, {"sha": "5ede1ba8e2c104076aa205dff4ff2edd5e87a738", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -3,15 +3,15 @@ use crate::ops::Try;\n /// Used to make try_fold closures more like normal loops\n #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n #[derive(Debug, Clone, Copy, PartialEq)]\n-pub enum ControlFlow<C, B> {\n+pub enum ControlFlow<B, C = ()> {\n     /// Continue in the loop, using the given value for the next iteration\n     Continue(C),\n     /// Exit the loop, yielding the given value\n     Break(B),\n }\n \n #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n-impl<C, B> Try for ControlFlow<C, B> {\n+impl<B, C> Try for ControlFlow<B, C> {\n     type Ok = C;\n     type Error = B;\n     #[inline]\n@@ -31,7 +31,7 @@ impl<C, B> Try for ControlFlow<C, B> {\n     }\n }\n \n-impl<C, B> ControlFlow<C, B> {\n+impl<B, C> ControlFlow<B, C> {\n     /// Returns `true` if this is a `Break` variant.\n     #[inline]\n     #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n@@ -58,7 +58,7 @@ impl<C, B> ControlFlow<C, B> {\n     }\n }\n \n-impl<R: Try> ControlFlow<R::Ok, R> {\n+impl<R: Try> ControlFlow<R, R::Ok> {\n     /// Create a `ControlFlow` from any type implementing `Try`.\n     #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n     #[inline]\n@@ -80,7 +80,7 @@ impl<R: Try> ControlFlow<R::Ok, R> {\n     }\n }\n \n-impl<B> ControlFlow<(), B> {\n+impl<B> ControlFlow<B, ()> {\n     /// It's frequently the case that there's no value needed with `Continue`,\n     /// so this provides a way to avoid typing `(())`, if you prefer it.\n     ///\n@@ -102,7 +102,7 @@ impl<B> ControlFlow<(), B> {\n     pub const CONTINUE: Self = ControlFlow::Continue(());\n }\n \n-impl<C> ControlFlow<C, ()> {\n+impl<C> ControlFlow<(), C> {\n     /// APIs like `try_for_each` don't need values with `Break`,\n     /// so this provides a way to avoid typing `(())`, if you prefer it.\n     ///"}, {"sha": "09dd19b8f5f9385450fa7dc6ce4e5c85eeacf52f", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -50,6 +50,13 @@ pub fn panic(expr: &'static str) -> ! {\n     panic_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n }\n \n+#[inline]\n+#[track_caller]\n+#[cfg_attr(not(bootstrap), lang = \"panic_str\")] // needed for const-evaluated panics\n+pub fn panic_str(expr: &str) -> ! {\n+    panic_fmt(format_args!(\"{}\", expr));\n+}\n+\n #[cold]\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[track_caller]"}, {"sha": "5925aa87a3f1398bdd3aabcbca2f8b1789a4f24f", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -42,7 +42,7 @@ dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n [target.'cfg(all(any(target_arch = \"x86_64\", target_arch = \"aarch64\"), target_os = \"hermit\"))'.dependencies]\n-hermit-abi = { version = \"0.1.15\", features = ['rustc-dep-of-std'] }\n+hermit-abi = { version = \"0.1.17\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.9.0\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "3da0ebdd4982ae95fcce551a84f5f6cdca7d9a30", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -259,6 +259,7 @@\n #![feature(exhaustive_patterns)]\n #![feature(extend_one)]\n #![feature(external_doc)]\n+#![feature(fmt_as_str)]\n #![feature(fn_traits)]\n #![feature(format_args_nl)]\n #![feature(gen_future)]"}, {"sha": "221ae809e23a2dbbd6beac3a740d99eb86ad3d3b", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -478,10 +478,26 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n         }\n     }\n \n+    struct StrPanicPayload(&'static str);\n+\n+    unsafe impl BoxMeUp for StrPanicPayload {\n+        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n+            Box::into_raw(Box::new(self.0))\n+        }\n+\n+        fn get(&mut self) -> &(dyn Any + Send) {\n+            &self.0\n+        }\n+    }\n+\n     let loc = info.location().unwrap(); // The current implementation always returns Some\n     let msg = info.message().unwrap(); // The current implementation always returns Some\n     crate::sys_common::backtrace::__rust_end_short_backtrace(move || {\n-        rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), loc);\n+        if let Some(msg) = msg.as_str() {\n+            rust_panic_with_hook(&mut StrPanicPayload(msg), info.message(), loc);\n+        } else {\n+            rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), loc);\n+        }\n     })\n }\n "}, {"sha": "5c4e3fd85c41caca2352b02a3060b6dea52f2d99", "filename": "library/std/src/sys/cloudabi/abi/cloudabi.rs", "status": "modified", "additions": 70, "deletions": 63, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -1910,7 +1910,7 @@ extern \"C\" {\n /// The resolution of the clock.\n #[inline]\n pub unsafe fn clock_res_get(clock_id_: clockid, resolution_: &mut timestamp) -> errno {\n-    cloudabi_sys_clock_res_get(clock_id_, resolution_)\n+    unsafe { cloudabi_sys_clock_res_get(clock_id_, resolution_) }\n }\n \n /// Obtains the time value of a clock.\n@@ -1934,7 +1934,7 @@ pub unsafe fn clock_time_get(\n     precision_: timestamp,\n     time_: *mut timestamp,\n ) -> errno {\n-    cloudabi_sys_clock_time_get(clock_id_, precision_, time_)\n+    unsafe { cloudabi_sys_clock_time_get(clock_id_, precision_, time_) }\n }\n \n /// Wakes up threads waiting on a userspace condition variable.\n@@ -1961,7 +1961,7 @@ pub unsafe fn clock_time_get(\n /// threads, all threads are woken up.\n #[inline]\n pub unsafe fn condvar_signal(condvar_: *mut condvar, scope_: scope, nwaiters_: nthreads) -> errno {\n-    cloudabi_sys_condvar_signal(condvar_, scope_, nwaiters_)\n+    unsafe { cloudabi_sys_condvar_signal(condvar_, scope_, nwaiters_) }\n }\n \n /// Closes a file descriptor.\n@@ -1972,7 +1972,7 @@ pub unsafe fn condvar_signal(condvar_: *mut condvar, scope_: scope, nwaiters_: n\n /// The file descriptor that needs to be closed.\n #[inline]\n pub unsafe fn fd_close(fd_: fd) -> errno {\n-    cloudabi_sys_fd_close(fd_)\n+    unsafe { cloudabi_sys_fd_close(fd_) }\n }\n \n /// Creates a file descriptor.\n@@ -1990,7 +1990,7 @@ pub unsafe fn fd_close(fd_: fd) -> errno {\n /// The file descriptor that has been created.\n #[inline]\n pub unsafe fn fd_create1(type_: filetype, fd_: &mut fd) -> errno {\n-    cloudabi_sys_fd_create1(type_, fd_)\n+    unsafe { cloudabi_sys_fd_create1(type_, fd_) }\n }\n \n /// Creates a pair of file descriptors.\n@@ -2013,7 +2013,8 @@ pub unsafe fn fd_create1(type_: filetype, fd_: &mut fd) -> errno {\n /// The second file descriptor of the pair.\n #[inline]\n pub unsafe fn fd_create2(type_: filetype, fd1_: &mut fd, fd2_: &mut fd) -> errno {\n-    cloudabi_sys_fd_create2(type_, fd1_, fd2_)\n+    // SAFETY: the caller must uphold the safety contract for `cloudabi_sys_fd_create2`.\n+    unsafe { cloudabi_sys_fd_create2(type_, fd1_, fd2_) }\n }\n \n /// Synchronizes the data of a file to disk.\n@@ -2025,7 +2026,9 @@ pub unsafe fn fd_create2(type_: filetype, fd1_: &mut fd, fd2_: &mut fd) -> errno\n /// needs to be synchronized to disk.\n #[inline]\n pub unsafe fn fd_datasync(fd_: fd) -> errno {\n-    cloudabi_sys_fd_datasync(fd_)\n+    // SAFETY: the caller must guarantee that `fd` is valid\n+    // for synchronization.\n+    unsafe { cloudabi_sys_fd_datasync(fd_) }\n }\n \n /// Duplicates a file descriptor.\n@@ -2040,7 +2043,7 @@ pub unsafe fn fd_datasync(fd_: fd) -> errno {\n /// The new file descriptor.\n #[inline]\n pub unsafe fn fd_dup(from_: fd, fd_: &mut fd) -> errno {\n-    cloudabi_sys_fd_dup(from_, fd_)\n+    unsafe { cloudabi_sys_fd_dup(from_, fd_) }\n }\n \n /// Reads from a file descriptor, without using and updating the\n@@ -2064,7 +2067,7 @@ pub unsafe fn fd_dup(from_: fd, fd_: &mut fd) -> errno {\n /// The number of bytes read.\n #[inline]\n pub unsafe fn fd_pread(fd_: fd, iovs_: &[iovec], offset_: filesize, nread_: &mut usize) -> errno {\n-    cloudabi_sys_fd_pread(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nread_)\n+    unsafe { cloudabi_sys_fd_pread(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nread_) }\n }\n \n /// Writes to a file descriptor, without using and updating the\n@@ -2093,7 +2096,7 @@ pub unsafe fn fd_pwrite(\n     offset_: filesize,\n     nwritten_: &mut usize,\n ) -> errno {\n-    cloudabi_sys_fd_pwrite(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nwritten_)\n+    unsafe { cloudabi_sys_fd_pwrite(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nwritten_) }\n }\n \n /// Reads from a file descriptor.\n@@ -2112,7 +2115,7 @@ pub unsafe fn fd_pwrite(\n /// The number of bytes read.\n #[inline]\n pub unsafe fn fd_read(fd_: fd, iovs_: &[iovec], nread_: &mut usize) -> errno {\n-    cloudabi_sys_fd_read(fd_, iovs_.as_ptr(), iovs_.len(), nread_)\n+    unsafe { cloudabi_sys_fd_read(fd_, iovs_.as_ptr(), iovs_.len(), nread_) }\n }\n \n /// Atomically replaces a file descriptor by a copy of another\n@@ -2138,7 +2141,7 @@ pub unsafe fn fd_read(fd_: fd, iovs_: &[iovec], nread_: &mut usize) -> errno {\n /// overwritten.\n #[inline]\n pub unsafe fn fd_replace(from_: fd, to_: fd) -> errno {\n-    cloudabi_sys_fd_replace(from_, to_)\n+    unsafe { cloudabi_sys_fd_replace(from_, to_) }\n }\n \n /// Moves the offset of the file descriptor.\n@@ -2166,7 +2169,7 @@ pub unsafe fn fd_seek(\n     whence_: whence,\n     newoffset_: &mut filesize,\n ) -> errno {\n-    cloudabi_sys_fd_seek(fd_, offset_, whence_, newoffset_)\n+    unsafe { cloudabi_sys_fd_seek(fd_, offset_, whence_, newoffset_) }\n }\n \n /// Gets attributes of a file descriptor.\n@@ -2182,7 +2185,7 @@ pub unsafe fn fd_seek(\n /// attributes are stored.\n #[inline]\n pub unsafe fn fd_stat_get(fd_: fd, buf_: *mut fdstat) -> errno {\n-    cloudabi_sys_fd_stat_get(fd_, buf_)\n+    unsafe { cloudabi_sys_fd_stat_get(fd_, buf_) }\n }\n \n /// Adjusts attributes of a file descriptor.\n@@ -2202,7 +2205,7 @@ pub unsafe fn fd_stat_get(fd_: fd, buf_: *mut fdstat) -> errno {\n /// be adjusted.\n #[inline]\n pub unsafe fn fd_stat_put(fd_: fd, buf_: *const fdstat, flags_: fdsflags) -> errno {\n-    cloudabi_sys_fd_stat_put(fd_, buf_, flags_)\n+    unsafe { cloudabi_sys_fd_stat_put(fd_, buf_, flags_) }\n }\n \n /// Synchronizes the data and metadata of a file to disk.\n@@ -2214,7 +2217,7 @@ pub unsafe fn fd_stat_put(fd_: fd, buf_: *const fdstat, flags_: fdsflags) -> err\n /// and metadata needs to be synchronized to disk.\n #[inline]\n pub unsafe fn fd_sync(fd_: fd) -> errno {\n-    cloudabi_sys_fd_sync(fd_)\n+    unsafe { cloudabi_sys_fd_sync(fd_) }\n }\n \n /// Writes to a file descriptor.\n@@ -2233,7 +2236,7 @@ pub unsafe fn fd_sync(fd_: fd) -> errno {\n /// The number of bytes written.\n #[inline]\n pub unsafe fn fd_write(fd_: fd, iovs_: &[ciovec], nwritten_: &mut usize) -> errno {\n-    cloudabi_sys_fd_write(fd_, iovs_.as_ptr(), iovs_.len(), nwritten_)\n+    unsafe { cloudabi_sys_fd_write(fd_, iovs_.as_ptr(), iovs_.len(), nwritten_) }\n }\n \n /// Provides file advisory information on a file descriptor.\n@@ -2256,7 +2259,7 @@ pub unsafe fn fd_write(fd_: fd, iovs_: &[ciovec], nwritten_: &mut usize) -> errn\n /// The advice.\n #[inline]\n pub unsafe fn file_advise(fd_: fd, offset_: filesize, len_: filesize, advice_: advice) -> errno {\n-    cloudabi_sys_file_advise(fd_, offset_, len_, advice_)\n+    unsafe { cloudabi_sys_file_advise(fd_, offset_, len_, advice_) }\n }\n \n /// Forces the allocation of space in a file.\n@@ -2275,7 +2278,7 @@ pub unsafe fn file_advise(fd_: fd, offset_: filesize, len_: filesize, advice_: a\n /// The length of the area that is allocated.\n #[inline]\n pub unsafe fn file_allocate(fd_: fd, offset_: filesize, len_: filesize) -> errno {\n-    cloudabi_sys_file_allocate(fd_, offset_, len_)\n+    unsafe { cloudabi_sys_file_allocate(fd_, offset_, len_) }\n }\n \n /// Creates a file of a specified type.\n@@ -2296,7 +2299,7 @@ pub unsafe fn file_allocate(fd_: fd, offset_: filesize, len_: filesize) -> errno\n ///     Creates a directory.\n #[inline]\n pub unsafe fn file_create(fd_: fd, path_: &[u8], type_: filetype) -> errno {\n-    cloudabi_sys_file_create(fd_, path_.as_ptr(), path_.len(), type_)\n+    unsafe { cloudabi_sys_file_create(fd_, path_.as_ptr(), path_.len(), type_)}\n }\n \n /// Creates a hard link.\n@@ -2320,7 +2323,7 @@ pub unsafe fn file_create(fd_: fd, path_: &[u8], type_: filetype) -> errno {\n /// should be created.\n #[inline]\n pub unsafe fn file_link(fd1_: lookup, path1_: &[u8], fd2_: fd, path2_: &[u8]) -> errno {\n-    cloudabi_sys_file_link(fd1_, path1_.as_ptr(), path1_.len(), fd2_, path2_.as_ptr(), path2_.len())\n+    unsafe { cloudabi_sys_file_link(fd1_, path1_.as_ptr(), path1_.len(), fd2_, path2_.as_ptr(), path2_.len()) }\n }\n \n /// Opens a file.\n@@ -2362,7 +2365,7 @@ pub unsafe fn file_open(\n     fds_: *const fdstat,\n     fd_: &mut fd,\n ) -> errno {\n-    cloudabi_sys_file_open(dirfd_, path_.as_ptr(), path_.len(), oflags_, fds_, fd_)\n+    unsafe { cloudabi_sys_file_open(dirfd_, path_.as_ptr(), path_.len(), oflags_, fds_, fd_) }\n }\n \n /// Reads directory entries from a directory.\n@@ -2402,7 +2405,7 @@ pub unsafe fn file_readdir(\n     cookie_: dircookie,\n     bufused_: &mut usize,\n ) -> errno {\n-    cloudabi_sys_file_readdir(fd_, buf_.as_mut_ptr() as *mut (), buf_.len(), cookie_, bufused_)\n+    unsafe { cloudabi_sys_file_readdir(fd_, buf_.as_mut_ptr() as *mut (), buf_.len(), cookie_, bufused_) }\n }\n \n /// Reads the contents of a symbolic link.\n@@ -2425,14 +2428,16 @@ pub unsafe fn file_readdir(\n /// The number of bytes placed in the buffer.\n #[inline]\n pub unsafe fn file_readlink(fd_: fd, path_: &[u8], buf_: &mut [u8], bufused_: &mut usize) -> errno {\n-    cloudabi_sys_file_readlink(\n-        fd_,\n-        path_.as_ptr(),\n-        path_.len(),\n-        buf_.as_mut_ptr(),\n-        buf_.len(),\n-        bufused_,\n-    )\n+    unsafe {\n+        cloudabi_sys_file_readlink(\n+            fd_,\n+            path_.as_ptr(),\n+            path_.len(),\n+            buf_.as_mut_ptr(),\n+            buf_.len(),\n+            bufused_,\n+        )\n+    }\n }\n \n /// Renames a file.\n@@ -2456,14 +2461,16 @@ pub unsafe fn file_readlink(fd_: fd, path_: &[u8], buf_: &mut [u8], bufused_: &m\n /// be renamed.\n #[inline]\n pub unsafe fn file_rename(fd1_: fd, path1_: &[u8], fd2_: fd, path2_: &[u8]) -> errno {\n-    cloudabi_sys_file_rename(\n-        fd1_,\n-        path1_.as_ptr(),\n-        path1_.len(),\n-        fd2_,\n-        path2_.as_ptr(),\n-        path2_.len(),\n-    )\n+    unsafe {\n+        cloudabi_sys_file_rename(\n+            fd1_,\n+            path1_.as_ptr(),\n+            path1_.len(),\n+            fd2_,\n+            path2_.as_ptr(),\n+            path2_.len(),\n+        )\n+    }\n }\n \n /// Gets attributes of a file by file descriptor.\n@@ -2479,7 +2486,7 @@ pub unsafe fn file_rename(fd1_: fd, path1_: &[u8], fd2_: fd, path2_: &[u8]) -> e\n /// stored.\n #[inline]\n pub unsafe fn file_stat_fget(fd_: fd, buf_: *mut filestat) -> errno {\n-    cloudabi_sys_file_stat_fget(fd_, buf_)\n+    unsafe { cloudabi_sys_file_stat_fget(fd_, buf_) }\n }\n \n /// Adjusts attributes of a file by file descriptor.\n@@ -2499,7 +2506,7 @@ pub unsafe fn file_stat_fget(fd_: fd, buf_: *mut filestat) -> errno {\n /// be adjusted.\n #[inline]\n pub unsafe fn file_stat_fput(fd_: fd, buf_: *const filestat, flags_: fsflags) -> errno {\n-    cloudabi_sys_file_stat_fput(fd_, buf_, flags_)\n+    unsafe { cloudabi_sys_file_stat_fput(fd_, buf_, flags_) }\n }\n \n /// Gets attributes of a file by path.\n@@ -2520,7 +2527,7 @@ pub unsafe fn file_stat_fput(fd_: fd, buf_: *const filestat, flags_: fsflags) ->\n /// stored.\n #[inline]\n pub unsafe fn file_stat_get(fd_: lookup, path_: &[u8], buf_: *mut filestat) -> errno {\n-    cloudabi_sys_file_stat_get(fd_, path_.as_ptr(), path_.len(), buf_)\n+    unsafe { cloudabi_sys_file_stat_get(fd_, path_.as_ptr(), path_.len(), buf_) }\n }\n \n /// Adjusts attributes of a file by path.\n@@ -2550,7 +2557,7 @@ pub unsafe fn file_stat_put(\n     buf_: *const filestat,\n     flags_: fsflags,\n ) -> errno {\n-    cloudabi_sys_file_stat_put(fd_, path_.as_ptr(), path_.len(), buf_, flags_)\n+    unsafe { cloudabi_sys_file_stat_put(fd_, path_.as_ptr(), path_.len(), buf_, flags_) }\n }\n \n /// Creates a symbolic link.\n@@ -2569,7 +2576,7 @@ pub unsafe fn file_stat_put(\n /// link should be created.\n #[inline]\n pub unsafe fn file_symlink(path1_: &[u8], fd_: fd, path2_: &[u8]) -> errno {\n-    cloudabi_sys_file_symlink(path1_.as_ptr(), path1_.len(), fd_, path2_.as_ptr(), path2_.len())\n+    unsafe { cloudabi_sys_file_symlink(path1_.as_ptr(), path1_.len(), fd_, path2_.as_ptr(), path2_.len()) }\n }\n \n /// Unlinks a file, or removes a directory.\n@@ -2591,7 +2598,7 @@ pub unsafe fn file_symlink(path1_: &[u8], fd_: fd, path2_: &[u8]) -> errno {\n ///     Otherwise, unlink a file.\n #[inline]\n pub unsafe fn file_unlink(fd_: fd, path_: &[u8], flags_: ulflags) -> errno {\n-    cloudabi_sys_file_unlink(fd_, path_.as_ptr(), path_.len(), flags_)\n+    unsafe { cloudabi_sys_file_unlink(fd_, path_.as_ptr(), path_.len(), flags_) }\n }\n \n /// Unlocks a write-locked userspace lock.\n@@ -2618,7 +2625,7 @@ pub unsafe fn file_unlink(fd_: fd, path_: &[u8], flags_: ulflags) -> errno {\n /// shared memory.\n #[inline]\n pub unsafe fn lock_unlock(lock_: *mut lock, scope_: scope) -> errno {\n-    cloudabi_sys_lock_unlock(lock_, scope_)\n+    unsafe { cloudabi_sys_lock_unlock(lock_, scope_) }\n }\n \n /// Provides memory advisory information on a region of memory.\n@@ -2633,7 +2640,7 @@ pub unsafe fn lock_unlock(lock_: *mut lock, scope_: scope) -> errno {\n /// The advice.\n #[inline]\n pub unsafe fn mem_advise(mapping_: &mut [u8], advice_: advice) -> errno {\n-    cloudabi_sys_mem_advise(mapping_.as_mut_ptr() as *mut (), mapping_.len(), advice_)\n+    unsafe { cloudabi_sys_mem_advise(mapping_.as_mut_ptr() as *mut (), mapping_.len(), advice_) }\n }\n \n /// Creates a memory mapping, making the contents of a file\n@@ -2682,7 +2689,7 @@ pub unsafe fn mem_map(\n     off_: filesize,\n     mem_: &mut *mut (),\n ) -> errno {\n-    cloudabi_sys_mem_map(addr_, len_, prot_, flags_, fd_, off_, mem_)\n+    unsafe { cloudabi_sys_mem_map(addr_, len_, prot_, flags_, fd_, off_, mem_) }\n }\n \n /// Changes the protection of a memory mapping.\n@@ -2696,7 +2703,7 @@ pub unsafe fn mem_map(\n /// New protection options.\n #[inline]\n pub unsafe fn mem_protect(mapping_: &mut [u8], prot_: mprot) -> errno {\n-    cloudabi_sys_mem_protect(mapping_.as_mut_ptr() as *mut (), mapping_.len(), prot_)\n+    unsafe { cloudabi_sys_mem_protect(mapping_.as_mut_ptr() as *mut (), mapping_.len(), prot_) }\n }\n \n /// Synchronizes a region of memory with its physical storage.\n@@ -2710,7 +2717,7 @@ pub unsafe fn mem_protect(mapping_: &mut [u8], prot_: mprot) -> errno {\n /// The method of synchronization.\n #[inline]\n pub unsafe fn mem_sync(mapping_: &mut [u8], flags_: msflags) -> errno {\n-    cloudabi_sys_mem_sync(mapping_.as_mut_ptr() as *mut (), mapping_.len(), flags_)\n+    unsafe { cloudabi_sys_mem_sync(mapping_.as_mut_ptr() as *mut (), mapping_.len(), flags_) }\n }\n \n /// Unmaps a region of memory.\n@@ -2721,7 +2728,7 @@ pub unsafe fn mem_sync(mapping_: &mut [u8], flags_: msflags) -> errno {\n /// The pages that needs to be unmapped.\n #[inline]\n pub unsafe fn mem_unmap(mapping_: &mut [u8]) -> errno {\n-    cloudabi_sys_mem_unmap(mapping_.as_mut_ptr() as *mut (), mapping_.len())\n+    unsafe { cloudabi_sys_mem_unmap(mapping_.as_mut_ptr() as *mut (), mapping_.len()) }\n }\n \n /// Concurrently polls for the occurrence of a set of events.\n@@ -2746,7 +2753,7 @@ pub unsafe fn poll(\n     nsubscriptions_: usize,\n     nevents_: *mut usize,\n ) -> errno {\n-    cloudabi_sys_poll(in_, out_, nsubscriptions_, nevents_)\n+    unsafe { cloudabi_sys_poll(in_, out_, nsubscriptions_, nevents_) }\n }\n \n /// Replaces the process by a new executable.\n@@ -2784,7 +2791,7 @@ pub unsafe fn poll(\n /// execution.\n #[inline]\n pub unsafe fn proc_exec(fd_: fd, data_: &[u8], fds_: &[fd]) -> errno {\n-    cloudabi_sys_proc_exec(fd_, data_.as_ptr() as *const (), data_.len(), fds_.as_ptr(), fds_.len())\n+    unsafe { cloudabi_sys_proc_exec(fd_, data_.as_ptr() as *const (), data_.len(), fds_.as_ptr(), fds_.len()) }\n }\n \n /// Terminates the process normally.\n@@ -2797,7 +2804,7 @@ pub unsafe fn proc_exec(fd_: fd, data_: &[u8], fds_: &[fd]) -> errno {\n /// through [`event.union.proc_terminate.exitcode`](struct.event_proc_terminate.html#structfield.exitcode).\n #[inline]\n pub unsafe fn proc_exit(rval_: exitcode) -> ! {\n-    cloudabi_sys_proc_exit(rval_)\n+    unsafe { cloudabi_sys_proc_exit(rval_) }\n }\n \n /// Forks the process of the calling thread.\n@@ -2822,7 +2829,7 @@ pub unsafe fn proc_exit(rval_: exitcode) -> ! {\n /// initial thread of the child process.\n #[inline]\n pub unsafe fn proc_fork(fd_: &mut fd, tid_: &mut tid) -> errno {\n-    cloudabi_sys_proc_fork(fd_, tid_)\n+    unsafe { cloudabi_sys_proc_fork(fd_, tid_) }\n }\n \n /// Sends a signal to the process of the calling thread.\n@@ -2837,7 +2844,7 @@ pub unsafe fn proc_fork(fd_: &mut fd, tid_: &mut tid) -> errno {\n /// [`event.union.proc_terminate.signal`](struct.event_proc_terminate.html#structfield.signal).\n #[inline]\n pub unsafe fn proc_raise(sig_: signal) -> errno {\n-    cloudabi_sys_proc_raise(sig_)\n+    unsafe { cloudabi_sys_proc_raise(sig_) }\n }\n \n /// Obtains random data from the kernel random number generator.\n@@ -2853,7 +2860,7 @@ pub unsafe fn proc_raise(sig_: signal) -> errno {\n /// data.\n #[inline]\n pub unsafe fn random_get(buf_: &mut [u8]) -> errno {\n-    cloudabi_sys_random_get(buf_.as_mut_ptr() as *mut (), buf_.len())\n+    unsafe { cloudabi_sys_random_get(buf_.as_mut_ptr() as *mut (), buf_.len()) }\n }\n \n /// Receives a message on a socket.\n@@ -2871,7 +2878,7 @@ pub unsafe fn random_get(buf_: &mut [u8]) -> errno {\n /// Output parameters.\n #[inline]\n pub unsafe fn sock_recv(sock_: fd, in_: *const recv_in, out_: *mut recv_out) -> errno {\n-    cloudabi_sys_sock_recv(sock_, in_, out_)\n+    unsafe { cloudabi_sys_sock_recv(sock_, in_, out_) }\n }\n \n /// Sends a message on a socket.\n@@ -2888,7 +2895,7 @@ pub unsafe fn sock_recv(sock_: fd, in_: *const recv_in, out_: *mut recv_out) ->\n /// Output parameters.\n #[inline]\n pub unsafe fn sock_send(sock_: fd, in_: *const send_in, out_: *mut send_out) -> errno {\n-    cloudabi_sys_sock_send(sock_, in_, out_)\n+    unsafe { cloudabi_sys_sock_send(sock_, in_, out_) }\n }\n \n /// Shuts down socket send and receive channels.\n@@ -2903,7 +2910,7 @@ pub unsafe fn sock_send(sock_: fd, in_: *const send_in, out_: *mut send_out) ->\n /// down.\n #[inline]\n pub unsafe fn sock_shutdown(sock_: fd, how_: sdflags) -> errno {\n-    cloudabi_sys_sock_shutdown(sock_, how_)\n+    unsafe { cloudabi_sys_sock_shutdown(sock_, how_) }\n }\n \n /// Creates a new thread within the current process.\n@@ -2917,7 +2924,7 @@ pub unsafe fn sock_shutdown(sock_: fd, how_: sdflags) -> errno {\n /// The thread ID of the new thread.\n #[inline]\n pub unsafe fn thread_create(attr_: *mut threadattr, tid_: &mut tid) -> errno {\n-    cloudabi_sys_thread_create(attr_, tid_)\n+    unsafe { cloudabi_sys_thread_create(attr_, tid_) }\n }\n \n /// Terminates the calling thread.\n@@ -2937,11 +2944,11 @@ pub unsafe fn thread_create(attr_: *mut threadattr, tid_: &mut tid) -> errno {\n /// shared memory.\n #[inline]\n pub unsafe fn thread_exit(lock_: *mut lock, scope_: scope) -> ! {\n-    cloudabi_sys_thread_exit(lock_, scope_)\n+    unsafe { cloudabi_sys_thread_exit(lock_, scope_) }\n }\n \n /// Temporarily yields execution of the calling thread.\n #[inline]\n pub unsafe fn thread_yield() -> errno {\n-    cloudabi_sys_thread_yield()\n+    unsafe { cloudabi_sys_thread_yield() }\n }"}, {"sha": "13f1bc8826e61b92810f957b50483207a4735901", "filename": "library/std/src/sys/cloudabi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmod.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -1,3 +1,5 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::io::ErrorKind;\n use crate::mem;\n "}, {"sha": "9dafcbc1fba0bb9b5e21964c06e2f94f2a8b8ff6", "filename": "library/std/src/sys/cloudabi/mutex.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -103,7 +103,9 @@ impl ReentrantMutex {\n             };\n             let mut event = MaybeUninit::<abi::event>::uninit();\n             let mut nevents = MaybeUninit::<usize>::uninit();\n-            let ret = abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr());\n+            // SAFE: The caller must to ensure that `event` and `nevents` are initialized.\n+            let ret =\n+                unsafe { abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr()) };\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire mutex\");\n             let event = event.assume_init();\n             assert_eq!(event.error, abi::errno::SUCCESS, \"Failed to acquire mutex\");"}, {"sha": "829d4c943f11b2b33d743def77331af5136e1270", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -334,10 +334,6 @@ impl File {\n     pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n         Err(Error::from_raw_os_error(22))\n     }\n-\n-    pub fn diverge(&self) -> ! {\n-        loop {}\n-    }\n }\n \n impl DirBuilder {"}, {"sha": "af05310a8d3ab0c8c1118d484de8d817623027bb", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -31,6 +31,7 @@ pub mod net;\n pub mod os;\n pub mod path;\n pub mod pipe;\n+#[path = \"../unsupported/process.rs\"]\n pub mod process;\n pub mod rwlock;\n pub mod stack_overflow;"}, {"sha": "f988a019cfedb39f98c22f5fd12543f961d4cacb", "filename": "library/std/src/sys/hermit/mutex.rs", "status": "modified", "additions": 180, "deletions": 10, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -1,44 +1,214 @@\n+use crate::cell::UnsafeCell;\n+use crate::collections::VecDeque;\n use crate::ffi::c_void;\n+use crate::ops::{Deref, DerefMut, Drop};\n use crate::ptr;\n+use crate::sync::atomic::{spin_loop_hint, AtomicUsize, Ordering};\n use crate::sys::hermit::abi;\n \n+/// This type provides a lock based on busy waiting to realize mutual exclusion\n+///\n+/// # Description\n+///\n+/// This structure behaves a lot like a common mutex. There are some differences:\n+///\n+/// - By using busy waiting, it can be used outside the runtime.\n+/// - It is a so called ticket lock and is completly fair.\n+#[cfg_attr(target_arch = \"x86_64\", repr(align(128)))]\n+#[cfg_attr(not(target_arch = \"x86_64\"), repr(align(64)))]\n+struct Spinlock<T: ?Sized> {\n+    queue: AtomicUsize,\n+    dequeue: AtomicUsize,\n+    data: UnsafeCell<T>,\n+}\n+\n+unsafe impl<T: ?Sized + Send> Sync for Spinlock<T> {}\n+unsafe impl<T: ?Sized + Send> Send for Spinlock<T> {}\n+\n+/// A guard to which the protected data can be accessed\n+///\n+/// When the guard falls out of scope it will release the lock.\n+struct SpinlockGuard<'a, T: ?Sized + 'a> {\n+    dequeue: &'a AtomicUsize,\n+    data: &'a mut T,\n+}\n+\n+impl<T> Spinlock<T> {\n+    pub const fn new(user_data: T) -> Spinlock<T> {\n+        Spinlock {\n+            queue: AtomicUsize::new(0),\n+            dequeue: AtomicUsize::new(1),\n+            data: UnsafeCell::new(user_data),\n+        }\n+    }\n+\n+    #[inline]\n+    fn obtain_lock(&self) {\n+        let ticket = self.queue.fetch_add(1, Ordering::SeqCst) + 1;\n+        while self.dequeue.load(Ordering::SeqCst) != ticket {\n+            spin_loop_hint();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) -> SpinlockGuard<'_, T> {\n+        self.obtain_lock();\n+        SpinlockGuard { dequeue: &self.dequeue, data: &mut *self.data.get() }\n+    }\n+}\n+\n+impl<T: ?Sized + Default> Default for Spinlock<T> {\n+    fn default() -> Spinlock<T> {\n+        Spinlock::new(Default::default())\n+    }\n+}\n+\n+impl<'a, T: ?Sized> Deref for SpinlockGuard<'a, T> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        &*self.data\n+    }\n+}\n+\n+impl<'a, T: ?Sized> DerefMut for SpinlockGuard<'a, T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut *self.data\n+    }\n+}\n+\n+impl<'a, T: ?Sized> Drop for SpinlockGuard<'a, T> {\n+    /// The dropping of the SpinlockGuard will release the lock it was created from.\n+    fn drop(&mut self) {\n+        self.dequeue.fetch_add(1, Ordering::SeqCst);\n+    }\n+}\n+\n+/// Realize a priority queue for tasks\n+struct PriorityQueue {\n+    queues: [Option<VecDeque<abi::Tid>>; abi::NO_PRIORITIES],\n+    prio_bitmap: u64,\n+}\n+\n+impl PriorityQueue {\n+    pub const fn new() -> PriorityQueue {\n+        PriorityQueue {\n+            queues: [\n+                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n+                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n+                None, None, None,\n+            ],\n+            prio_bitmap: 0,\n+        }\n+    }\n+\n+    /// Add a task id by its priority to the queue\n+    pub fn push(&mut self, prio: abi::Priority, id: abi::Tid) {\n+        let i: usize = prio.into().into();\n+        self.prio_bitmap |= (1 << i) as u64;\n+        if let Some(queue) = &mut self.queues[i] {\n+            queue.push_back(id);\n+        } else {\n+            let mut queue = VecDeque::new();\n+            queue.push_back(id);\n+            self.queues[i] = Some(queue);\n+        }\n+    }\n+\n+    fn pop_from_queue(&mut self, queue_index: usize) -> Option<abi::Tid> {\n+        if let Some(queue) = &mut self.queues[queue_index] {\n+            let id = queue.pop_front();\n+\n+            if queue.is_empty() {\n+                self.prio_bitmap &= !(1 << queue_index as u64);\n+            }\n+\n+            id\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Pop the task handle with the highest priority from the queue\n+    pub fn pop(&mut self) -> Option<abi::Tid> {\n+        for i in 0..abi::NO_PRIORITIES {\n+            if self.prio_bitmap & (1 << i) != 0 {\n+                return self.pop_from_queue(i);\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+struct MutexInner {\n+    locked: bool,\n+    blocked_task: PriorityQueue,\n+}\n+\n+impl MutexInner {\n+    pub const fn new() -> MutexInner {\n+        MutexInner { locked: false, blocked_task: PriorityQueue::new() }\n+    }\n+}\n+\n pub struct Mutex {\n-    inner: *const c_void,\n+    inner: Spinlock<MutexInner>,\n }\n \n+pub type MovableMutex = Box<Mutex>;\n+\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n impl Mutex {\n     pub const fn new() -> Mutex {\n-        Mutex { inner: ptr::null() }\n+        Mutex { inner: Spinlock::new(MutexInner::new()) }\n     }\n \n     #[inline]\n     pub unsafe fn init(&mut self) {\n-        let _ = abi::sem_init(&mut self.inner as *mut *const c_void, 1);\n+        self.inner = Spinlock::new(MutexInner::new());\n     }\n \n     #[inline]\n     pub unsafe fn lock(&self) {\n-        let _ = abi::sem_timedwait(self.inner, 0);\n+        loop {\n+            let mut guard = self.inner.lock();\n+            if guard.locked == false {\n+                guard.locked = true;\n+                return;\n+            } else {\n+                let prio = abi::get_priority();\n+                let id = abi::getpid();\n+\n+                guard.blocked_task.push(prio, id);\n+                abi::block_current_task();\n+                drop(guard);\n+                abi::yield_now();\n+            }\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn unlock(&self) {\n-        let _ = abi::sem_post(self.inner);\n+        let mut guard = self.inner.lock();\n+        guard.locked = false;\n+        if let Some(tid) = guard.blocked_task.pop() {\n+            abi::wakeup_task(tid);\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        let result = abi::sem_trywait(self.inner);\n-        result == 0\n+        let mut guard = self.inner.lock();\n+        if guard.locked == false {\n+            guard.locked = true;\n+        }\n+        guard.locked\n     }\n \n     #[inline]\n-    pub unsafe fn destroy(&self) {\n-        let _ = abi::sem_destroy(self.inner);\n-    }\n+    pub unsafe fn destroy(&self) {}\n }\n \n pub struct ReentrantMutex {"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "library/std/src/sys/hermit/process.rs", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/ffa2e7ae8fbf9badc035740db949b9dae271c29f/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffa2e7ae8fbf9badc035740db949b9dae271c29f/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fprocess.rs?ref=ffa2e7ae8fbf9badc035740db949b9dae271c29f", "patch": "@@ -1,149 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::fmt;\n-use crate::io;\n-use crate::sys::fs::File;\n-use crate::sys::pipe::AnonPipe;\n-use crate::sys::{unsupported, Void};\n-use crate::sys_common::process::CommandEnv;\n-\n-pub use crate::ffi::OsString as EnvKey;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Command {\n-    env: CommandEnv,\n-}\n-\n-// passed back to std::process with the pipes connected to the child, if any\n-// were requested\n-pub struct StdioPipes {\n-    pub stdin: Option<AnonPipe>,\n-    pub stdout: Option<AnonPipe>,\n-    pub stderr: Option<AnonPipe>,\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    MakePipe,\n-}\n-\n-impl Command {\n-    pub fn new(_program: &OsStr) -> Command {\n-        Command { env: Default::default() }\n-    }\n-\n-    pub fn arg(&mut self, _arg: &OsStr) {}\n-\n-    pub fn env_mut(&mut self) -> &mut CommandEnv {\n-        &mut self.env\n-    }\n-\n-    pub fn cwd(&mut self, _dir: &OsStr) {}\n-\n-    pub fn stdin(&mut self, _stdin: Stdio) {}\n-\n-    pub fn stdout(&mut self, _stdout: Stdio) {}\n-\n-    pub fn stderr(&mut self, _stderr: Stdio) {}\n-\n-    pub fn spawn(\n-        &mut self,\n-        _default: Stdio,\n-        _needs_stdin: bool,\n-    ) -> io::Result<(Process, StdioPipes)> {\n-        unsupported()\n-    }\n-}\n-\n-impl From<AnonPipe> for Stdio {\n-    fn from(pipe: AnonPipe) -> Stdio {\n-        pipe.diverge()\n-    }\n-}\n-\n-impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n-        file.diverge()\n-    }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n-    }\n-}\n-\n-pub struct ExitStatus(Void);\n-\n-impl ExitStatus {\n-    pub fn success(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for ExitStatus {\n-    fn clone(&self) -> ExitStatus {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Copy for ExitStatus {}\n-\n-impl PartialEq for ExitStatus {\n-    fn eq(&self, _other: &ExitStatus) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for ExitStatus {}\n-\n-impl fmt::Debug for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitCode(bool);\n-\n-impl ExitCode {\n-    pub const SUCCESS: ExitCode = ExitCode(false);\n-    pub const FAILURE: ExitCode = ExitCode(true);\n-\n-    pub fn as_i32(&self) -> i32 {\n-        self.0 as i32\n-    }\n-}\n-\n-pub struct Process(Void);\n-\n-impl Process {\n-    pub fn id(&self) -> u32 {\n-        match self.0 {}\n-    }\n-\n-    pub fn kill(&mut self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        match self.0 {}\n-    }\n-\n-    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n-        match self.0 {}\n-    }\n-}"}, {"sha": "b4628b649117ed6b353afd45025a9d697e3da818", "filename": "library/std/src/sys/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -89,6 +89,7 @@ cfg_if::cfg_if! {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub use self::ext as windows_ext;\n     } else if #[cfg(any(target_os = \"cloudabi\",\n+                        target_os = \"hermit\",\n                         target_arch = \"wasm32\",\n                         all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n         // On CloudABI and wasm right now the shim below doesn't compile, so"}, {"sha": "d3a29aa5d51c191f942c45cf4eb765664ceab1d8", "filename": "src/test/mir-opt/matches_reduce_branches.bar.MatchBranchSimplification.32bit.diff", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.32bit.diff?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -10,6 +10,7 @@\n       let mut _8: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:35:9: 35:10\n       let mut _9: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:35:12: 35:13\n       let mut _10: bool;                   // in scope 0 at $DIR/matches_reduce_branches.rs:35:15: 35:16\n++     let mut _11: i32;                    // in scope 0 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n       scope 1 {\n           debug a => _2;                   // in scope 1 at $DIR/matches_reduce_branches.rs:13:9: 13:10\n           let _3: bool;                    // in scope 1 at $DIR/matches_reduce_branches.rs:14:9: 14:10\n@@ -33,10 +34,13 @@\n           StorageLive(_5);                 // scope 3 at $DIR/matches_reduce_branches.rs:16:9: 16:10\n           StorageLive(_6);                 // scope 4 at $DIR/matches_reduce_branches.rs:18:5: 33:6\n -         switchInt(_1) -> [7_i32: bb2, otherwise: bb1]; // scope 4 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n-+         _2 = Ne(_1, const 7_i32);        // scope 4 at $DIR/matches_reduce_branches.rs:20:13: 20:22\n-+         _3 = Eq(_1, const 7_i32);        // scope 4 at $DIR/matches_reduce_branches.rs:21:13: 21:21\n++         StorageLive(_11);                // scope 4 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n++         _11 = _1;                        // scope 4 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n++         _2 = Ne(_11, const 7_i32);       // scope 4 at $DIR/matches_reduce_branches.rs:20:13: 20:22\n++         _3 = Eq(_11, const 7_i32);       // scope 4 at $DIR/matches_reduce_branches.rs:21:13: 21:21\n +         _4 = const false;                // scope 4 at $DIR/matches_reduce_branches.rs:22:13: 22:22\n +         _5 = const true;                 // scope 4 at $DIR/matches_reduce_branches.rs:23:13: 23:21\n++         StorageDead(_11);                // scope 4 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n +         goto -> bb3;                     // scope 4 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n       }\n   "}, {"sha": "d3a29aa5d51c191f942c45cf4eb765664ceab1d8", "filename": "src/test/mir-opt/matches_reduce_branches.bar.MatchBranchSimplification.64bit.diff", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.64bit.diff?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -10,6 +10,7 @@\n       let mut _8: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:35:9: 35:10\n       let mut _9: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:35:12: 35:13\n       let mut _10: bool;                   // in scope 0 at $DIR/matches_reduce_branches.rs:35:15: 35:16\n++     let mut _11: i32;                    // in scope 0 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n       scope 1 {\n           debug a => _2;                   // in scope 1 at $DIR/matches_reduce_branches.rs:13:9: 13:10\n           let _3: bool;                    // in scope 1 at $DIR/matches_reduce_branches.rs:14:9: 14:10\n@@ -33,10 +34,13 @@\n           StorageLive(_5);                 // scope 3 at $DIR/matches_reduce_branches.rs:16:9: 16:10\n           StorageLive(_6);                 // scope 4 at $DIR/matches_reduce_branches.rs:18:5: 33:6\n -         switchInt(_1) -> [7_i32: bb2, otherwise: bb1]; // scope 4 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n-+         _2 = Ne(_1, const 7_i32);        // scope 4 at $DIR/matches_reduce_branches.rs:20:13: 20:22\n-+         _3 = Eq(_1, const 7_i32);        // scope 4 at $DIR/matches_reduce_branches.rs:21:13: 21:21\n++         StorageLive(_11);                // scope 4 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n++         _11 = _1;                        // scope 4 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n++         _2 = Ne(_11, const 7_i32);       // scope 4 at $DIR/matches_reduce_branches.rs:20:13: 20:22\n++         _3 = Eq(_11, const 7_i32);       // scope 4 at $DIR/matches_reduce_branches.rs:21:13: 21:21\n +         _4 = const false;                // scope 4 at $DIR/matches_reduce_branches.rs:22:13: 22:22\n +         _5 = const true;                 // scope 4 at $DIR/matches_reduce_branches.rs:23:13: 23:21\n++         StorageDead(_11);                // scope 4 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n +         goto -> bb3;                     // scope 4 at $DIR/matches_reduce_branches.rs:19:9: 19:10\n       }\n   "}, {"sha": "ba963e3fe920bce99359f450a13e7b6cf0c22b33", "filename": "src/test/mir-opt/matches_reduce_branches.foo.MatchBranchSimplification.32bit.diff", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.32bit.diff?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -6,12 +6,16 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/matches_reduce_branches.rs:6:25: 6:25\n       let mut _2: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       let mut _3: isize;                   // in scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n++     let mut _4: isize;                   // in scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n   \n       bb0: {\n           StorageLive(_2);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _3 = discriminant(_1);           // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n -         switchInt(move _3) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n-+         _2 = Eq(_3, const 0_isize);      // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n++         StorageLive(_4);                 // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n++         _4 = move _3;                    // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n++         _2 = Eq(_4, const 0_isize);      // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n++         StorageDead(_4);                 // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n +         goto -> bb3;                     // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n       }\n   "}, {"sha": "ba963e3fe920bce99359f450a13e7b6cf0c22b33", "filename": "src/test/mir-opt/matches_reduce_branches.foo.MatchBranchSimplification.64bit.diff", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.64bit.diff?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -6,12 +6,16 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/matches_reduce_branches.rs:6:25: 6:25\n       let mut _2: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       let mut _3: isize;                   // in scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n++     let mut _4: isize;                   // in scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n   \n       bb0: {\n           StorageLive(_2);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _3 = discriminant(_1);           // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n -         switchInt(move _3) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n-+         _2 = Eq(_3, const 0_isize);      // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n++         StorageLive(_4);                 // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n++         _4 = move _3;                    // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n++         _2 = Eq(_4, const 0_isize);      // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n++         StorageDead(_4);                 // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n +         goto -> bb3;                     // scope 0 at $DIR/matches_reduce_branches.rs:7:22: 7:26\n       }\n   "}, {"sha": "1f46d3777bed8442b165731739b676b12932355f", "filename": "src/test/mir-opt/matches_reduce_branches.match_nested_if.MatchBranchSimplification.32bit.diff", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.32bit.diff?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,116 @@\n+- // MIR for `match_nested_if` before MatchBranchSimplification\n++ // MIR for `match_nested_if` after MatchBranchSimplification\n+  \n+  fn match_nested_if() -> bool {\n+      let mut _0: bool;                    // return place in scope 0 at $DIR/matches_reduce_branches.rs:38:25: 38:29\n+      let _1: bool;                        // in scope 0 at $DIR/matches_reduce_branches.rs:39:9: 39:12\n+      let mut _2: ();                      // in scope 0 at $DIR/matches_reduce_branches.rs:39:21: 39:23\n+      let mut _3: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      let mut _4: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n+      let mut _5: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n+      let mut _6: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:24: 40:28\n++     let mut _7: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n++     let mut _8: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n++     let mut _9: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++     let mut _10: bool;                   // in scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      scope 1 {\n+          debug val => _1;                 // in scope 1 at $DIR/matches_reduce_branches.rs:39:9: 39:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/matches_reduce_branches.rs:39:9: 39:12\n+          StorageLive(_2);                 // scope 0 at $DIR/matches_reduce_branches.rs:39:21: 39:23\n+          StorageLive(_3);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+          StorageLive(_4);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n+          StorageLive(_5);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n+          StorageLive(_6);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:24: 40:28\n+          _6 = const true;                 // scope 0 at $DIR/matches_reduce_branches.rs:40:24: 40:28\n+-         switchInt(_6) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n++         StorageLive(_7);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n++         _7 = _6;                         // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n++         _5 = Ne(_7, const false);        // scope 0 at $DIR/matches_reduce_branches.rs:40:42: 40:47\n++         StorageDead(_7);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n++         goto -> bb3;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n+      }\n+  \n+      bb1: {\n+          _5 = const true;                 // scope 0 at $DIR/matches_reduce_branches.rs:40:30: 40:34\n+          goto -> bb3;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n+      }\n+  \n+      bb2: {\n+          _5 = const false;                // scope 0 at $DIR/matches_reduce_branches.rs:40:42: 40:47\n+          goto -> bb3;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n+      }\n+  \n+      bb3: {\n+          StorageDead(_6);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:47: 40:48\n+-         switchInt(_5) -> [false: bb4, otherwise: bb5]; // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n++         StorageLive(_8);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n++         _8 = _5;                         // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n++         _4 = Ne(_8, const false);        // scope 0 at $DIR/matches_reduce_branches.rs:40:62: 40:67\n++         StorageDead(_8);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n++         goto -> bb6;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n+      }\n+  \n+      bb4: {\n+          _4 = const false;                // scope 0 at $DIR/matches_reduce_branches.rs:40:62: 40:67\n+          goto -> bb6;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n+      }\n+  \n+      bb5: {\n+          _4 = const true;                 // scope 0 at $DIR/matches_reduce_branches.rs:40:50: 40:54\n+          goto -> bb6;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n+      }\n+  \n+      bb6: {\n+          StorageDead(_5);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:67: 40:68\n+-         switchInt(_4) -> [false: bb7, otherwise: bb8]; // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         StorageLive(_9);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         _9 = _4;                         // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         _3 = Ne(_9, const false);        // scope 0 at $DIR/matches_reduce_branches.rs:40:82: 40:87\n++         StorageDead(_9);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         goto -> bb9;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      }\n+  \n+      bb7: {\n+          _3 = const false;                // scope 0 at $DIR/matches_reduce_branches.rs:40:82: 40:87\n+          goto -> bb9;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      }\n+  \n+      bb8: {\n+          _3 = const true;                 // scope 0 at $DIR/matches_reduce_branches.rs:40:70: 40:74\n+          goto -> bb9;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      }\n+  \n+      bb9: {\n+          StorageDead(_4);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:87: 40:88\n+-         switchInt(move _3) -> [false: bb11, otherwise: bb10]; // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         StorageLive(_10);                // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         _10 = move _3;                   // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         StorageDead(_3);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:95: 40:96\n++         _1 = Ne(_10, const false);       // scope 0 at $DIR/matches_reduce_branches.rs:41:14: 41:19\n++         StorageDead(_10);                // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         goto -> bb12;                    // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      }\n+  \n+      bb10: {\n+          StorageDead(_3);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:95: 40:96\n+          _1 = const true;                 // scope 0 at $DIR/matches_reduce_branches.rs:40:92: 40:96\n+          goto -> bb12;                    // scope 0 at $DIR/matches_reduce_branches.rs:39:15: 42:6\n+      }\n+  \n+      bb11: {\n+          StorageDead(_3);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:95: 40:96\n+          _1 = const false;                // scope 0 at $DIR/matches_reduce_branches.rs:41:14: 41:19\n+          goto -> bb12;                    // scope 0 at $DIR/matches_reduce_branches.rs:39:15: 42:6\n+      }\n+  \n+      bb12: {\n+          StorageDead(_2);                 // scope 0 at $DIR/matches_reduce_branches.rs:42:6: 42:7\n+          _0 = _1;                         // scope 1 at $DIR/matches_reduce_branches.rs:43:5: 43:8\n+          StorageDead(_1);                 // scope 0 at $DIR/matches_reduce_branches.rs:44:1: 44:2\n+          return;                          // scope 0 at $DIR/matches_reduce_branches.rs:44:2: 44:2\n+      }\n+  }\n+  "}, {"sha": "1f46d3777bed8442b165731739b676b12932355f", "filename": "src/test/mir-opt/matches_reduce_branches.match_nested_if.MatchBranchSimplification.64bit.diff", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.64bit.diff?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,116 @@\n+- // MIR for `match_nested_if` before MatchBranchSimplification\n++ // MIR for `match_nested_if` after MatchBranchSimplification\n+  \n+  fn match_nested_if() -> bool {\n+      let mut _0: bool;                    // return place in scope 0 at $DIR/matches_reduce_branches.rs:38:25: 38:29\n+      let _1: bool;                        // in scope 0 at $DIR/matches_reduce_branches.rs:39:9: 39:12\n+      let mut _2: ();                      // in scope 0 at $DIR/matches_reduce_branches.rs:39:21: 39:23\n+      let mut _3: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      let mut _4: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n+      let mut _5: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n+      let mut _6: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:24: 40:28\n++     let mut _7: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n++     let mut _8: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n++     let mut _9: bool;                    // in scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++     let mut _10: bool;                   // in scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      scope 1 {\n+          debug val => _1;                 // in scope 1 at $DIR/matches_reduce_branches.rs:39:9: 39:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/matches_reduce_branches.rs:39:9: 39:12\n+          StorageLive(_2);                 // scope 0 at $DIR/matches_reduce_branches.rs:39:21: 39:23\n+          StorageLive(_3);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+          StorageLive(_4);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n+          StorageLive(_5);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n+          StorageLive(_6);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:24: 40:28\n+          _6 = const true;                 // scope 0 at $DIR/matches_reduce_branches.rs:40:24: 40:28\n+-         switchInt(_6) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n++         StorageLive(_7);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n++         _7 = _6;                         // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n++         _5 = Ne(_7, const false);        // scope 0 at $DIR/matches_reduce_branches.rs:40:42: 40:47\n++         StorageDead(_7);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n++         goto -> bb3;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n+      }\n+  \n+      bb1: {\n+          _5 = const true;                 // scope 0 at $DIR/matches_reduce_branches.rs:40:30: 40:34\n+          goto -> bb3;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n+      }\n+  \n+      bb2: {\n+          _5 = const false;                // scope 0 at $DIR/matches_reduce_branches.rs:40:42: 40:47\n+          goto -> bb3;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:21: 40:48\n+      }\n+  \n+      bb3: {\n+          StorageDead(_6);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:47: 40:48\n+-         switchInt(_5) -> [false: bb4, otherwise: bb5]; // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n++         StorageLive(_8);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n++         _8 = _5;                         // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n++         _4 = Ne(_8, const false);        // scope 0 at $DIR/matches_reduce_branches.rs:40:62: 40:67\n++         StorageDead(_8);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n++         goto -> bb6;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n+      }\n+  \n+      bb4: {\n+          _4 = const false;                // scope 0 at $DIR/matches_reduce_branches.rs:40:62: 40:67\n+          goto -> bb6;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n+      }\n+  \n+      bb5: {\n+          _4 = const true;                 // scope 0 at $DIR/matches_reduce_branches.rs:40:50: 40:54\n+          goto -> bb6;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:18: 40:68\n+      }\n+  \n+      bb6: {\n+          StorageDead(_5);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:67: 40:68\n+-         switchInt(_4) -> [false: bb7, otherwise: bb8]; // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         StorageLive(_9);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         _9 = _4;                         // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         _3 = Ne(_9, const false);        // scope 0 at $DIR/matches_reduce_branches.rs:40:82: 40:87\n++         StorageDead(_9);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         goto -> bb9;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      }\n+  \n+      bb7: {\n+          _3 = const false;                // scope 0 at $DIR/matches_reduce_branches.rs:40:82: 40:87\n+          goto -> bb9;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      }\n+  \n+      bb8: {\n+          _3 = const true;                 // scope 0 at $DIR/matches_reduce_branches.rs:40:70: 40:74\n+          goto -> bb9;                     // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      }\n+  \n+      bb9: {\n+          StorageDead(_4);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:87: 40:88\n+-         switchInt(move _3) -> [false: bb11, otherwise: bb10]; // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         StorageLive(_10);                // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         _10 = move _3;                   // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         StorageDead(_3);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:95: 40:96\n++         _1 = Ne(_10, const false);       // scope 0 at $DIR/matches_reduce_branches.rs:41:14: 41:19\n++         StorageDead(_10);                // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n++         goto -> bb12;                    // scope 0 at $DIR/matches_reduce_branches.rs:40:15: 40:88\n+      }\n+  \n+      bb10: {\n+          StorageDead(_3);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:95: 40:96\n+          _1 = const true;                 // scope 0 at $DIR/matches_reduce_branches.rs:40:92: 40:96\n+          goto -> bb12;                    // scope 0 at $DIR/matches_reduce_branches.rs:39:15: 42:6\n+      }\n+  \n+      bb11: {\n+          StorageDead(_3);                 // scope 0 at $DIR/matches_reduce_branches.rs:40:95: 40:96\n+          _1 = const false;                // scope 0 at $DIR/matches_reduce_branches.rs:41:14: 41:19\n+          goto -> bb12;                    // scope 0 at $DIR/matches_reduce_branches.rs:39:15: 42:6\n+      }\n+  \n+      bb12: {\n+          StorageDead(_2);                 // scope 0 at $DIR/matches_reduce_branches.rs:42:6: 42:7\n+          _0 = _1;                         // scope 1 at $DIR/matches_reduce_branches.rs:43:5: 43:8\n+          StorageDead(_1);                 // scope 0 at $DIR/matches_reduce_branches.rs:44:1: 44:2\n+          return;                          // scope 0 at $DIR/matches_reduce_branches.rs:44:2: 44:2\n+      }\n+  }\n+  "}, {"sha": "e95a62aeeb0b9c86bef337c17c2c04057fb5e064", "filename": "src/test/mir-opt/matches_reduce_branches.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -1,7 +1,7 @@\n-// compile-flags: -Zunsound-mir-opts\n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n // EMIT_MIR matches_reduce_branches.foo.MatchBranchSimplification.diff\n // EMIT_MIR matches_reduce_branches.bar.MatchBranchSimplification.diff\n+// EMIT_MIR matches_reduce_branches.match_nested_if.MatchBranchSimplification.diff\n \n fn foo(bar: Option<()>) {\n     if matches!(bar, None) {\n@@ -35,9 +35,17 @@ fn bar(i: i32) -> (bool, bool, bool, bool) {\n     (a, b, c, d)\n }\n \n+fn match_nested_if() -> bool {\n+    let val = match () {\n+        () if if if if true {true} else {false} {true} else {false} {true} else {false} => true,\n+        _ => false,\n+    };\n+    val\n+}\n \n fn main() {\n   let _ = foo(None);\n   let _ = foo(Some(()));\n   let _ = bar(0);\n+  let _ = match_nested_if();\n }"}, {"sha": "dc3a6a36d9eef6e735fefc68aee2f1d1994387e1", "filename": "src/test/mir-opt/not_equal_false.opt.InstCombine.diff", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fnot_equal_false.opt.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fmir-opt%2Fnot_equal_false.opt.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnot_equal_false.opt.InstCombine.diff?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -8,61 +8,52 @@\n       let mut _3: isize;                   // in scope 0 at $DIR/not_equal_false.rs:4:17: 4:21\n       let mut _4: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       let mut _5: isize;                   // in scope 0 at $DIR/not_equal_false.rs:4:38: 4:45\n+      let mut _6: isize;                   // in scope 0 at $DIR/not_equal_false.rs:4:17: 4:21\n+      let mut _7: isize;                   // in scope 0 at $DIR/not_equal_false.rs:4:38: 4:45\n+      let mut _8: bool;                    // in scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n   \n       bb0: {\n           StorageLive(_2);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _3 = discriminant(_1);           // scope 0 at $DIR/not_equal_false.rs:4:17: 4:21\n-          switchInt(move _3) -> [0_isize: bb6, otherwise: bb5]; // scope 0 at $DIR/not_equal_false.rs:4:17: 4:21\n+          StorageLive(_6);                 // scope 0 at $DIR/not_equal_false.rs:4:17: 4:21\n+          _6 = move _3;                    // scope 0 at $DIR/not_equal_false.rs:4:17: 4:21\n+          _2 = Eq(_6, const 0_isize);      // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_6);                 // scope 0 at $DIR/not_equal_false.rs:4:17: 4:21\n+          goto -> bb4;                     // scope 0 at $DIR/not_equal_false.rs:4:17: 4:21\n       }\n   \n       bb1: {\n           _0 = const true;                 // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n-          goto -> bb4;                     // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n+          goto -> bb3;                     // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n       }\n   \n       bb2: {\n-          _0 = const false;                // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n-          goto -> bb4;                     // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n-      }\n-  \n-      bb3: {\n           StorageLive(_4);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _5 = discriminant(_1);           // scope 0 at $DIR/not_equal_false.rs:4:38: 4:45\n-          switchInt(move _5) -> [1_isize: bb9, otherwise: bb8]; // scope 0 at $DIR/not_equal_false.rs:4:38: 4:45\n+          StorageLive(_7);                 // scope 0 at $DIR/not_equal_false.rs:4:38: 4:45\n+          _7 = move _5;                    // scope 0 at $DIR/not_equal_false.rs:4:38: 4:45\n+          _4 = Eq(_7, const 1_isize);      // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_7);                 // scope 0 at $DIR/not_equal_false.rs:4:38: 4:45\n+          goto -> bb5;                     // scope 0 at $DIR/not_equal_false.rs:4:38: 4:45\n       }\n   \n-      bb4: {\n+      bb3: {\n           StorageDead(_4);                 // scope 0 at $DIR/not_equal_false.rs:4:45: 4:46\n           StorageDead(_2);                 // scope 0 at $DIR/not_equal_false.rs:4:45: 4:46\n           return;                          // scope 0 at $DIR/not_equal_false.rs:5:2: 5:2\n       }\n   \n-      bb5: {\n-          _2 = const false;                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          goto -> bb7;                     // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      }\n-  \n-      bb6: {\n-          _2 = const true;                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          goto -> bb7;                     // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      }\n-  \n-      bb7: {\n-          switchInt(move _2) -> [false: bb3, otherwise: bb1]; // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n-      }\n-  \n-      bb8: {\n-          _4 = const false;                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          goto -> bb10;                    // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      }\n-  \n-      bb9: {\n-          _4 = const true;                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          goto -> bb10;                    // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      bb4: {\n+          switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n       }\n   \n-      bb10: {\n-          switchInt(move _4) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n+      bb5: {\n+          StorageLive(_8);                 // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n+          _8 = move _4;                    // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n+-         _0 = Ne(_8, const false);        // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n++         _0 = _8;                         // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n+          StorageDead(_8);                 // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n+          goto -> bb3;                     // scope 0 at $DIR/not_equal_false.rs:4:5: 4:46\n       }\n   }\n   "}, {"sha": "71a5f2d3472013d457b6b623159c1313c5266c49", "filename": "src/test/ui/const-generics/const_evaluatable_checked/division.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdivision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdivision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdivision.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,11 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+fn with_bound<const N: usize>() where [u8; N / 2]: Sized {\n+    let _: [u8; N / 2] = [0; N / 2];\n+}\n+\n+fn main() {\n+    with_bound::<4>();\n+}"}, {"sha": "9c603c57a4818e16dc127e89c07702a29b60b625", "filename": "src/test/ui/const-generics/const_evaluatable_checked/unused_expr.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,25 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+fn add<const N: usize>() -> [u8; { N + 1; 5 }] {\n+    //~^ ERROR overly complex generic constant\n+    todo!()\n+}\n+\n+fn div<const N: usize>() -> [u8; { N / 1; 5 }] {\n+    //~^ ERROR overly complex generic constant\n+    todo!()\n+}\n+\n+const fn foo(n: usize) {}\n+\n+fn fn_call<const N: usize>() -> [u8; { foo(N); 5 }] {\n+    //~^ ERROR overly complex generic constant\n+    todo!()\n+}\n+\n+fn main() {\n+    add::<12>();\n+    div::<9>();\n+    fn_call::<14>();\n+}"}, {"sha": "1687dbbcbe3f8c3fedef497409a5aec01dfb0586", "filename": "src/test/ui/const-generics/const_evaluatable_checked/unused_expr.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,32 @@\n+error: overly complex generic constant\n+  --> $DIR/unused_expr.rs:4:34\n+   |\n+LL | fn add<const N: usize>() -> [u8; { N + 1; 5 }] {\n+   |                                  ^^-----^^^^^\n+   |                                    |\n+   |                                    dead code\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: overly complex generic constant\n+  --> $DIR/unused_expr.rs:9:34\n+   |\n+LL | fn div<const N: usize>() -> [u8; { N / 1; 5 }] {\n+   |                                  ^^-----^^^^^\n+   |                                    |\n+   |                                    dead code\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: overly complex generic constant\n+  --> $DIR/unused_expr.rs:16:38\n+   |\n+LL | fn fn_call<const N: usize>() -> [u8; { foo(N); 5 }] {\n+   |                                      ^^------^^^^^\n+   |                                        |\n+   |                                        dead code\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "799c185fb8e4b534e003e35c58ab946f1a4d2a8a", "filename": "src/test/ui/consts/const-eval/const_panic.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -1,6 +1,8 @@\n #![feature(const_panic)]\n #![crate_type = \"lib\"]\n \n+const MSG: &str = \"hello\";\n+\n const Z: () = std::panic!(\"cheese\");\n //~^ ERROR any use of this value will cause an error\n \n@@ -12,6 +14,9 @@ const Y: () = std::unreachable!();\n \n const X: () = std::unimplemented!();\n //~^ ERROR any use of this value will cause an error\n+//\n+const W: () = std::panic!(MSG);\n+//~^ ERROR any use of this value will cause an error\n \n const Z_CORE: () = core::panic!(\"cheese\");\n //~^ ERROR any use of this value will cause an error\n@@ -24,3 +29,6 @@ const Y_CORE: () = core::unreachable!();\n \n const X_CORE: () = core::unimplemented!();\n //~^ ERROR any use of this value will cause an error\n+\n+const W_CORE: () = core::panic!(MSG);\n+//~^ ERROR any use of this value will cause an error"}, {"sha": "c2711952d58373f0b8329516aa83d55bad75cdd7", "filename": "src/test/ui/consts/const-eval/const_panic.stderr", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic.stderr?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -1,83 +1,103 @@\n error: any use of this value will cause an error\n-  --> $DIR/const_panic.rs:4:15\n+  --> $DIR/const_panic.rs:6:15\n    |\n LL | const Z: () = std::panic!(\"cheese\");\n    | --------------^^^^^^^^^^^^^^^^^^^^^-\n    |               |\n-   |               the evaluated program panicked at 'cheese', $DIR/const_panic.rs:4:15\n+   |               the evaluated program panicked at 'cheese', $DIR/const_panic.rs:6:15\n    |\n    = note: `#[deny(const_err)]` on by default\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n-  --> $DIR/const_panic.rs:7:16\n+  --> $DIR/const_panic.rs:9:16\n    |\n LL | const Z2: () = std::panic!();\n    | ---------------^^^^^^^^^^^^^-\n    |                |\n-   |                the evaluated program panicked at 'explicit panic', $DIR/const_panic.rs:7:16\n+   |                the evaluated program panicked at 'explicit panic', $DIR/const_panic.rs:9:16\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n-  --> $DIR/const_panic.rs:10:15\n+  --> $DIR/const_panic.rs:12:15\n    |\n LL | const Y: () = std::unreachable!();\n    | --------------^^^^^^^^^^^^^^^^^^^-\n    |               |\n-   |               the evaluated program panicked at 'internal error: entered unreachable code', $DIR/const_panic.rs:10:15\n+   |               the evaluated program panicked at 'internal error: entered unreachable code', $DIR/const_panic.rs:12:15\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n-  --> $DIR/const_panic.rs:13:15\n+  --> $DIR/const_panic.rs:15:15\n    |\n LL | const X: () = std::unimplemented!();\n    | --------------^^^^^^^^^^^^^^^^^^^^^-\n    |               |\n-   |               the evaluated program panicked at 'not implemented', $DIR/const_panic.rs:13:15\n+   |               the evaluated program panicked at 'not implemented', $DIR/const_panic.rs:15:15\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n-  --> $DIR/const_panic.rs:16:20\n+  --> $DIR/const_panic.rs:18:15\n+   |\n+LL | const W: () = std::panic!(MSG);\n+   | --------------^^^^^^^^^^^^^^^^-\n+   |               |\n+   |               the evaluated program panicked at 'hello', $DIR/const_panic.rs:18:15\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const_panic.rs:21:20\n    |\n LL | const Z_CORE: () = core::panic!(\"cheese\");\n    | -------------------^^^^^^^^^^^^^^^^^^^^^^-\n    |                    |\n-   |                    the evaluated program panicked at 'cheese', $DIR/const_panic.rs:16:20\n+   |                    the evaluated program panicked at 'cheese', $DIR/const_panic.rs:21:20\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n-  --> $DIR/const_panic.rs:19:21\n+  --> $DIR/const_panic.rs:24:21\n    |\n LL | const Z2_CORE: () = core::panic!();\n    | --------------------^^^^^^^^^^^^^^-\n    |                     |\n-   |                     the evaluated program panicked at 'explicit panic', $DIR/const_panic.rs:19:21\n+   |                     the evaluated program panicked at 'explicit panic', $DIR/const_panic.rs:24:21\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n-  --> $DIR/const_panic.rs:22:20\n+  --> $DIR/const_panic.rs:27:20\n    |\n LL | const Y_CORE: () = core::unreachable!();\n    | -------------------^^^^^^^^^^^^^^^^^^^^-\n    |                    |\n-   |                    the evaluated program panicked at 'internal error: entered unreachable code', $DIR/const_panic.rs:22:20\n+   |                    the evaluated program panicked at 'internal error: entered unreachable code', $DIR/const_panic.rs:27:20\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n-  --> $DIR/const_panic.rs:25:20\n+  --> $DIR/const_panic.rs:30:20\n    |\n LL | const X_CORE: () = core::unimplemented!();\n    | -------------------^^^^^^^^^^^^^^^^^^^^^^-\n    |                    |\n-   |                    the evaluated program panicked at 'not implemented', $DIR/const_panic.rs:25:20\n+   |                    the evaluated program panicked at 'not implemented', $DIR/const_panic.rs:30:20\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const_panic.rs:33:20\n+   |\n+LL | const W_CORE: () = core::panic!(MSG);\n+   | -------------------^^^^^^^^^^^^^^^^^-\n+   |                    |\n+   |                    the evaluated program panicked at 'hello', $DIR/const_panic.rs:33:20\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 10 previous errors\n "}, {"sha": "96e8795e52d56687ceb660c8d9a5bd1833f1e8e4", "filename": "src/test/ui/consts/const_in_pattern/issue-44333.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "previous_filename": "src/test/ui/issues/issue-44333.rs"}, {"sha": "8302b09e5334d0b62919327b4258d3bbc85b69a5", "filename": "src/test/ui/consts/const_in_pattern/issue-44333.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.stderr?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "previous_filename": "src/test/ui/issues/issue-44333.stderr"}, {"sha": "355ba63790f3bd2f283362803ec916ca2aa1c8b4", "filename": "src/test/ui/consts/const_in_pattern/issue-53708.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-53708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-53708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-53708.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// https://github.com/rust-lang/rust/issues/53708\n+#[derive(PartialEq, Eq)]\n+struct S;\n+\n+fn main() {\n+    const C: &S = &S;\n+    match C {\n+        C => {}\n+    }\n+}"}, {"sha": "69cf8404da18e34506019ef421193e7134bfbbf2", "filename": "src/test/ui/consts/const_in_pattern/issue-78057.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,17 @@\n+#![deny(unreachable_patterns)]\n+\n+#[derive(PartialEq)]\n+struct Opaque(i32);\n+\n+impl Eq for Opaque {}\n+\n+const FOO: Opaque = Opaque(42);\n+\n+fn main() {\n+    match FOO {\n+        FOO => {},\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => {}\n+        //~^ ERROR unreachable pattern\n+    }\n+}"}, {"sha": "0d49d0e96c8540908508e46b7e3a651fc782ea28", "filename": "src/test/ui/consts/const_in_pattern/issue-78057.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,20 @@\n+error: to use a constant of type `Opaque` in a pattern, `Opaque` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/issue-78057.rs:12:9\n+   |\n+LL |         FOO => {},\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/issue-78057.rs:14:9\n+   |\n+LL |         _ => {}\n+   |         ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-78057.rs:1:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4a91198ab9f6fac8edfdca1a0e27c11bc4171509", "filename": "src/test/ui/intrinsics/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -53,8 +53,8 @@ enum LR_NonZero {\n fn test_panic_msg<T>(op: impl (FnOnce() -> T) + panic::UnwindSafe, msg: &str) {\n     let err = panic::catch_unwind(op).err();\n     assert_eq!(\n-        err.as_ref().and_then(|a| a.downcast_ref::<String>()).map(|s| &**s),\n-        Some(msg)\n+        err.as_ref().and_then(|a| a.downcast_ref::<&str>()),\n+        Some(&msg)\n     );\n }\n "}, {"sha": "9b04d5ee0008db4df88f4c272ed6dbf995760e3c", "filename": "src/test/ui/issues/issue-77919.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fissues%2Fissue-77919.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fissues%2Fissue-77919.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-77919.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,13 @@\n+fn main() {\n+    [1; <Multiply<Five, Five>>::VAL]; //~ ERROR evaluation of constant value failed\n+}\n+trait TypeVal<T> {\n+    const VAL: T; //~ ERROR any use of this value will cause an error\n+}\n+struct Five;\n+struct Multiply<N, M> {\n+    _n: PhantomData, //~ ERROR cannot find type `PhantomData` in this scope\n+}\n+impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n+//~^ ERROR cannot find type `VAL` in this scope\n+//~| ERROR not all trait items implemented, missing: `VAL`"}, {"sha": "129af00644fff589a9e76f74477a5571a29eda65", "filename": "src/test/ui/issues/issue-77919.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fissues%2Fissue-77919.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fissues%2Fissue-77919.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-77919.stderr?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,46 @@\n+error[E0412]: cannot find type `PhantomData` in this scope\n+  --> $DIR/issue-77919.rs:9:9\n+   |\n+LL |     _n: PhantomData,\n+   |         ^^^^^^^^^^^ not found in this scope\n+   |\n+help: consider importing this struct\n+   |\n+LL | use std::marker::PhantomData;\n+   |\n+\n+error[E0412]: cannot find type `VAL` in this scope\n+  --> $DIR/issue-77919.rs:11:63\n+   |\n+LL | impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n+   |          -                                                    ^^^ not found in this scope\n+   |          |\n+   |          help: you might be missing a type parameter: `, VAL`\n+\n+error[E0046]: not all trait items implemented, missing: `VAL`\n+  --> $DIR/issue-77919.rs:11:1\n+   |\n+LL |     const VAL: T;\n+   |     ------------- `VAL` from trait\n+...\n+LL | impl<N, M> TypeVal<usize> for Multiply<N, M> where N: TypeVal<VAL> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `VAL` in implementation\n+\n+error: any use of this value will cause an error\n+  --> $DIR/issue-77919.rs:5:5\n+   |\n+LL |     const VAL: T;\n+   |     ^^^^^^^^^^^^^ no MIR body is available for DefId(0:7 ~ issue_77919[317d]::TypeVal::VAL)\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-77919.rs:2:9\n+   |\n+LL |     [1; <Multiply<Five, Five>>::VAL];\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0046, E0080, E0412.\n+For more information about an error, try `rustc --explain E0046`."}, {"sha": "919eca4f9bf6d7e96b70a9fd54cbae03ad0ba2f1", "filename": "src/test/ui/macros/issue-78325-inconsistent-resolution.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fmacros%2Fissue-78325-inconsistent-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fmacros%2Fissue-78325-inconsistent-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-78325-inconsistent-resolution.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,12 @@\n+macro_rules! define_other_core {\n+    ( ) => {\n+        extern crate std as core;\n+        //~^ ERROR macro-expanded `extern crate` items cannot shadow names passed with `--extern`\n+    };\n+}\n+\n+fn main() {\n+    core::panic!();\n+}\n+\n+define_other_core!();"}, {"sha": "cf3af593141ff98b97de6fef9992a4748e3efcd4", "filename": "src/test/ui/macros/issue-78325-inconsistent-resolution.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fmacros%2Fissue-78325-inconsistent-resolution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fmacros%2Fissue-78325-inconsistent-resolution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-78325-inconsistent-resolution.stderr?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,13 @@\n+error: macro-expanded `extern crate` items cannot shadow names passed with `--extern`\n+  --> $DIR/issue-78325-inconsistent-resolution.rs:3:9\n+   |\n+LL |         extern crate std as core;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | define_other_core!();\n+   | --------------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "f87f96e34fccdc373f5ca237d60b2596caa5bf5f", "filename": "src/test/ui/pattern/usefulness/consts-opaque.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,114 @@\n+// This file tests the exhaustiveness algorithm on opaque constants. Most of the examples give\n+// unnecessary warnings because const_to_pat.rs converts a constant pattern to a wildcard when the\n+// constant is not allowed as a pattern. This is an edge case so we may not care to fix it.\n+// See also https://github.com/rust-lang/rust/issues/78057\n+\n+#![deny(unreachable_patterns)]\n+\n+#[derive(PartialEq)]\n+struct Foo(i32);\n+impl Eq for Foo {}\n+const FOO: Foo = Foo(42);\n+const FOO_REF: &Foo = &Foo(42);\n+const FOO_REF_REF: &&Foo = &&Foo(42);\n+\n+#[derive(PartialEq)]\n+struct Bar;\n+impl Eq for Bar {}\n+const BAR: Bar = Bar;\n+\n+#[derive(PartialEq)]\n+enum Baz {\n+    Baz1,\n+    Baz2\n+}\n+impl Eq for Baz {}\n+const BAZ: Baz = Baz::Baz1;\n+\n+type Quux = fn(usize, usize) -> usize;\n+fn quux(a: usize, b: usize) -> usize { a + b }\n+const QUUX: Quux = quux;\n+\n+fn main() {\n+    match FOO {\n+        FOO => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match FOO_REF {\n+        FOO_REF => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        Foo(_) => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    // This used to cause an ICE (https://github.com/rust-lang/rust/issues/78071)\n+    match FOO_REF_REF {\n+        FOO_REF_REF => {}\n+        //~^ WARNING must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARNING this was previously accepted by the compiler but is being phased out\n+        Foo(_) => {}\n+    }\n+\n+    match BAR {\n+        Bar => {}\n+        BAR => {} // should not be emitting unreachable warning\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| ERROR unreachable pattern\n+        _ => {}\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match BAR {\n+        BAR => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        Bar => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+        _ => {}\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match BAR {\n+        BAR => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        BAR => {} // should not be emitting unreachable warning\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| ERROR unreachable pattern\n+        _ => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match BAZ {\n+        BAZ => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        Baz::Baz1 => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+        _ => {}\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match BAZ {\n+        Baz::Baz1 => {}\n+        BAZ => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => {}\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match BAZ {\n+        BAZ => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        Baz::Baz2 => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+        _ => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match QUUX {\n+        QUUX => {}\n+        QUUX => {}\n+        _ => {}\n+    }\n+}"}, {"sha": "f10166d5a35801cae7b9a33a5e32d672ad706d0e", "filename": "src/test/ui/pattern/usefulness/consts-opaque.stderr", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -0,0 +1,158 @@\n+error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:34:9\n+   |\n+LL |         FOO => {}\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:36:9\n+   |\n+LL |         _ => {} // should not be emitting unreachable warning\n+   |         ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/consts-opaque.rs:6:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:41:9\n+   |\n+LL |         FOO_REF => {}\n+   |         ^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:43:9\n+   |\n+LL |         Foo(_) => {} // should not be emitting unreachable warning\n+   |         ^^^^^^\n+\n+warning: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:49:9\n+   |\n+LL |         FOO_REF_REF => {}\n+   |         ^^^^^^^^^^^\n+   |\n+   = note: `#[warn(indirect_structural_match)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:57:9\n+   |\n+LL |         BAR => {} // should not be emitting unreachable warning\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:57:9\n+   |\n+LL |         Bar => {}\n+   |         --- matches any value\n+LL |         BAR => {} // should not be emitting unreachable warning\n+   |         ^^^ unreachable pattern\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:60:9\n+   |\n+LL |         Bar => {}\n+   |         --- matches any value\n+...\n+LL |         _ => {}\n+   |         ^ unreachable pattern\n+\n+error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:65:9\n+   |\n+LL |         BAR => {}\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:67:9\n+   |\n+LL |         Bar => {} // should not be emitting unreachable warning\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:69:9\n+   |\n+LL |         Bar => {} // should not be emitting unreachable warning\n+   |         --- matches any value\n+LL |\n+LL |         _ => {}\n+   |         ^ unreachable pattern\n+\n+error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:74:9\n+   |\n+LL |         BAR => {}\n+   |         ^^^\n+\n+error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:76:9\n+   |\n+LL |         BAR => {} // should not be emitting unreachable warning\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:76:9\n+   |\n+LL |         BAR => {} // should not be emitting unreachable warning\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:79:9\n+   |\n+LL |         _ => {} // should not be emitting unreachable warning\n+   |         ^\n+\n+error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:84:9\n+   |\n+LL |         BAZ => {}\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:86:9\n+   |\n+LL |         Baz::Baz1 => {} // should not be emitting unreachable warning\n+   |         ^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:88:9\n+   |\n+LL |         _ => {}\n+   |         ^\n+\n+error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:94:9\n+   |\n+LL |         BAZ => {}\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:96:9\n+   |\n+LL |         _ => {}\n+   |         ^\n+\n+error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:101:9\n+   |\n+LL |         BAZ => {}\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:103:9\n+   |\n+LL |         Baz::Baz2 => {} // should not be emitting unreachable warning\n+   |         ^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:105:9\n+   |\n+LL |         _ => {} // should not be emitting unreachable warning\n+   |         ^\n+\n+error: aborting due to 22 previous errors; 1 warning emitted\n+"}, {"sha": "7968f9713ff2272552e57f07f83501e0b7739953", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f58ffc93815f76576eb56df4bdeec2fe8f12b766/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=f58ffc93815f76576eb56df4bdeec2fe8f12b766", "patch": "@@ -7,11 +7,11 @@ LL |     match buf {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8; 4]`\n \n-error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..=u8::MAX, _, _, _]` not covered\n   --> $DIR/match-byte-array-patterns-2.rs:10:11\n    |\n LL |     match buf {\n-   |           ^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n+   |           ^^^ patterns `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..=u8::MAX, _, _, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8]`"}]}