{"sha": "d7b8512eae0f92e64b8a9eabe8584ac18bf9e061", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3Yjg1MTJlYWUwZjkyZTY0YjhhOWVhYmU4NTg0YWMxOGJmOWUwNjE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T03:08:08Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T03:08:08Z"}, "message": "Copyedit section 4 of tutorial", "tree": {"sha": "9d44d059624a49a6256dcae609f1e2e85587d68a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d44d059624a49a6256dcae609f1e2e85587d68a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7b8512eae0f92e64b8a9eabe8584ac18bf9e061", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7b8512eae0f92e64b8a9eabe8584ac18bf9e061", "html_url": "https://github.com/rust-lang/rust/commit/d7b8512eae0f92e64b8a9eabe8584ac18bf9e061", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7b8512eae0f92e64b8a9eabe8584ac18bf9e061/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6627ac662386541737ab26e3a1c633dc88185c62", "url": "https://api.github.com/repos/rust-lang/rust/commits/6627ac662386541737ab26e3a1c633dc88185c62", "html_url": "https://github.com/rust-lang/rust/commit/6627ac662386541737ab26e3a1c633dc88185c62"}], "stats": {"total": 91, "additions": 49, "deletions": 42}, "files": [{"sha": "1695977e6277bfe259f8ab202b46ef9808b17161", "filename": "doc/tutorial.md", "status": "modified", "additions": 49, "deletions": 42, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d7b8512eae0f92e64b8a9eabe8584ac18bf9e061/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d7b8512eae0f92e64b8a9eabe8584ac18bf9e061/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d7b8512eae0f92e64b8a9eabe8584ac18bf9e061", "patch": "@@ -545,8 +545,8 @@ You can define your own syntax extensions with the macro system. For details, se\n \n ## Conditionals\n \n-We've seen `if` pass by a few times already. To recap, braces are\n-compulsory, an optional `else` clause can be appended, and multiple\n+We've seen `if` expressions a few times already. To recap, braces are\n+compulsory, an `if` can have an optional `else` clause, and multiple\n `if`/`else` constructs can be chained together:\n \n ~~~~\n@@ -559,10 +559,10 @@ if false {\n }\n ~~~~\n \n-The condition given to an `if` construct *must* be of type boolean (no\n-implicit conversion happens). If the arms return a value, this value\n-must be of the same type for every arm in which control reaches the\n-end of the block:\n+The condition given to an `if` construct *must* be of type `bool` (no\n+implicit conversion happens). If the arms are blocks that have a\n+value, this value must be of the same type for every arm in which\n+control reaches the end of the block:\n \n ~~~~\n fn signum(x: int) -> int {\n@@ -575,9 +575,10 @@ fn signum(x: int) -> int {\n ## Pattern matching\n \n Rust's `match` construct is a generalized, cleaned-up version of C's\n-`switch` construct. You provide it with a value and a number of *arms*,\n-each labelled with a pattern, and the code will attempt to match each pattern\n-in order. For the first one that matches, the arm is executed.\n+`switch` construct. You provide it with a value and a number of\n+*arms*, each labelled with a pattern, and the code compares the value\n+against each pattern in order until one matches. The matching pattern\n+executes its corresponding arm.\n \n ~~~~\n # let my_number = 1;\n@@ -589,15 +590,19 @@ match my_number {\n }\n ~~~~\n \n-There is no 'falling through' between arms, as in C\u2014only one arm is\n-executed, and it doesn't have to explicitly `break` out of the\n+Unlike in C, there is no 'falling through' between arms: only one arm\n+executes, and it doesn't have to explicitly `break` out of the\n construct when it is finished.\n \n-The part to the left of the arrow `=>` is called the *pattern*. Literals are\n-valid patterns and will match only their own value. The pipe operator\n-(`|`) can be used to assign multiple patterns to a single arm. Ranges\n-of numeric literal patterns can be expressed with two dots, as in `M..N`. The\n-underscore (`_`) is a wildcard pattern that matches everything.\n+A `match` arm consists of a *pattern*, then an arrow `=>`, followed by\n+an *action* (expression). Literals are valid patterns and match only\n+their own value. A single arm may match multiple different patterns by\n+combining them with the pipe operator (`|`), so long as every pattern\n+binds the same set of variables. Ranges of numeric literal patterns\n+can be expressed with two dots, as in `M..N`. The underscore (`_`) is\n+a wildcard pattern that matches any single value. The asterisk (`*`)\n+is a different wildcard that can match one or more fields in an `enum`\n+variant.\n \n The patterns in an match arm are followed by a fat arrow, `=>`, then an\n expression to evaluate. Each case is separated by commas. It's often\n@@ -612,13 +617,14 @@ match my_number {\n }\n ~~~\n \n-`match` constructs must be *exhaustive*: they must have an arm covering every\n-possible case. For example, if the arm with the wildcard pattern was left off\n-in the above example, the typechecker would reject it.\n+`match` constructs must be *exhaustive*: they must have an arm\n+covering every possible case. For example, the typechecker would\n+reject the previous example if the arm with the wildcard pattern was\n+omitted.\n \n-A powerful application of pattern matching is *destructuring*, where\n-you use the matching to get at the contents of data types. Remember\n-that `(float, float)` is a tuple of two floats:\n+A powerful application of pattern matching is *destructuring*:\n+matching in order to bind names to the contents of data\n+types. Remember that `(float, float)` is a tuple of two floats:\n \n ~~~~\n fn angle(vector: (float, float)) -> float {\n@@ -631,37 +637,39 @@ fn angle(vector: (float, float)) -> float {\n }\n ~~~~\n \n-A variable name in a pattern matches everything, *and* binds that name\n-to the value of the matched thing inside of the arm block. Thus, `(0f,\n+A variable name in a pattern matches any value, *and* binds that name\n+to the value of the matched value inside of the arm's action. Thus, `(0f,\n y)` matches any tuple whose first element is zero, and binds `y` to\n the second element. `(x, y)` matches any tuple, and binds both\n-elements to a variable.\n+elements to variables.\n \n-Any `match` arm can have a guard clause (written `if EXPR`), which is\n-an expression of type `bool` that determines, after the pattern is\n-found to match, whether the arm is taken or not. The variables bound\n-by the pattern are available in this guard expression.\n+Any `match` arm can have a guard clause (written `if EXPR`), called a\n+*pattern guard*, which is an expression of type `bool` that\n+determines, after the pattern is found to match, whether the arm is\n+taken or not. The variables bound by the pattern are in scope in this\n+guard expression. The first arm in the `angle` example shows an\n+example of a pattern guard.\n \n You've already seen simple `let` bindings, but `let` is a little\n-fancier than you've been led to believe. It too supports destructuring\n-patterns. For example, you can say this to extract the fields from a\n-tuple, introducing two variables, `a` and `b`.\n+fancier than you've been led to believe. It, too, supports destructuring\n+patterns. For example, you can write this to extract the fields from a\n+tuple, introducing two variables at once: `a` and `b`.\n \n ~~~~\n # fn get_tuple_of_two_ints() -> (int, int) { (1, 1) }\n let (a, b) = get_tuple_of_two_ints();\n ~~~~\n \n-Let bindings only work with _irrefutable_ patterns, that is, patterns\n+Let bindings only work with _irrefutable_ patterns: that is, patterns\n that can never fail to match. This excludes `let` from matching\n-literals and most enum variants.\n+literals and most `enum` variants.\n \n ## Loops\n \n-`while` produces a loop that runs as long as its given condition\n-(which must have type `bool`) evaluates to true. Inside a loop, the\n-keyword `break` can be used to abort the loop, and `loop` can be used\n-to abort the current iteration and continue with the next.\n+`while` denotes a loop that iterates as long as its given condition\n+(which must have type `bool`) evaluates to `true`. Inside a loop, the\n+keyword `break` aborts the loop, and `loop` aborts the current\n+iteration and continues with the next.\n \n ~~~~\n let mut cake_amount = 8;\n@@ -670,7 +678,7 @@ while cake_amount > 0 {\n }\n ~~~~\n \n-`loop` is the preferred way of writing `while true`:\n+`loop` denotes an infinite loop, and is the preferred way of writing `while true`:\n \n ~~~~\n let mut x = 5;\n@@ -684,9 +692,8 @@ loop {\n This code prints out a weird sequence of numbers and stops as soon as\n it finds one that can be divided by five.\n \n-For more involved iteration, such as going over the elements of a\n-collection, Rust uses higher-order functions. We'll come back to those\n-in a moment.\n+For more involved iteration, such as enumerating the elements of a\n+collection, Rust uses [higher-order functions](#closures).\n \n # Data structures\n "}]}