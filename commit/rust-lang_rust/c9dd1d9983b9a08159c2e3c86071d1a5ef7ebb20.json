{"sha": "c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "node_id": "C_kwDOAAsO6NoAKGM5ZGQxZDk5ODNiOWEwODE1OWMyZTNjODYwNzFkMWE1ZWY3ZWJiMjA", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2022-07-04T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2022-07-07T06:11:49Z"}, "message": "Make MIR basic blocks field public\n\nThis makes it possible to mutably borrow different fields of the MIR\nbody without resorting to methods like `basic_blocks_local_decls_mut_and_var_debug_info`.\n\nTo preserve validity of control flow graph caches in the presence of\nmodifications, a new struct `BasicBlocks` wraps together basic blocks\nand control flow graph caches.\n\nThe `BasicBlocks` dereferences to `IndexVec<BasicBlock, BasicBlockData>`.\nOn the other hand a mutable access requires explicit `as_mut()` call.", "tree": {"sha": "821f63c3785e5599f0252939c2289414b947d530", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/821f63c3785e5599f0252939c2289414b947d530"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "html_url": "https://github.com/rust-lang/rust/commit/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fac8fa56726f7a5b2d4880a4719c5f99beec8328", "url": "https://api.github.com/repos/rust-lang/rust/commits/fac8fa56726f7a5b2d4880a4719c5f99beec8328", "html_url": "https://github.com/rust-lang/rust/commit/fac8fa56726f7a5b2d4880a4719c5f99beec8328"}], "stats": {"total": 408, "additions": 213, "deletions": 195}, "files": [{"sha": "12527a9b2ae6602e5e2d4506b490c48c27585917", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -856,7 +856,8 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     literal: ConstantKind::from_const(_const, tcx),\n                 }))\n             };\n-            let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n+            let blocks = self.source.basic_blocks.as_mut();\n+            let local_decls = &mut self.source.local_decls;\n             let loc = candidate.location;\n             let statement = &mut blocks[loc.block].statements[loc.statement_index];\n             match statement.kind {\n@@ -865,7 +866,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     Rvalue::Ref(ref mut region, borrow_kind, ref mut place),\n                 )) => {\n                     // Use the underlying local for this (necessarily interior) borrow.\n-                    let ty = local_decls.local_decls()[place.local].ty;\n+                    let ty = local_decls[place.local].ty;\n                     let span = statement.source_info.span;\n \n                     let ref_ty = tcx.mk_ref("}, {"sha": "ec3a818472bd07cb585a6301adebaa8bff23f8da", "filename": "compiler/rustc_middle/src/mir/basic_blocks.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -0,0 +1,141 @@\n+use crate::mir::graph_cyclic_cache::GraphIsCyclicCache;\n+use crate::mir::predecessors::{PredecessorCache, Predecessors};\n+use crate::mir::switch_sources::{SwitchSourceCache, SwitchSources};\n+use crate::mir::traversal::PostorderCache;\n+use crate::mir::{BasicBlock, BasicBlockData, Successors, START_BLOCK};\n+\n+use rustc_data_structures::graph;\n+use rustc_index::vec::IndexVec;\n+\n+#[derive(Clone, TyEncodable, TyDecodable, Debug, HashStable, TypeFoldable, TypeVisitable)]\n+pub struct BasicBlocks<'tcx> {\n+    basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    predecessor_cache: PredecessorCache,\n+    switch_source_cache: SwitchSourceCache,\n+    is_cyclic: GraphIsCyclicCache,\n+    postorder_cache: PostorderCache,\n+}\n+\n+impl<'tcx> BasicBlocks<'tcx> {\n+    #[inline]\n+    pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n+        BasicBlocks {\n+            basic_blocks,\n+            predecessor_cache: PredecessorCache::new(),\n+            switch_source_cache: SwitchSourceCache::new(),\n+            is_cyclic: GraphIsCyclicCache::new(),\n+            postorder_cache: PostorderCache::new(),\n+        }\n+    }\n+\n+    /// Returns true if control-flow graph contains a cycle reachable from the `START_BLOCK`.\n+    #[inline]\n+    pub fn is_cfg_cyclic(&self) -> bool {\n+        self.is_cyclic.is_cyclic(self)\n+    }\n+\n+    /// Returns predecessors for each basic block.\n+    #[inline]\n+    pub fn predecessors(&self) -> &Predecessors {\n+        self.predecessor_cache.compute(&self.basic_blocks)\n+    }\n+\n+    /// Returns basic blocks in a postorder.\n+    #[inline]\n+    pub fn postorder(&self) -> &[BasicBlock] {\n+        self.postorder_cache.compute(&self.basic_blocks)\n+    }\n+\n+    /// `switch_sources()[&(target, switch)]` returns a list of switch\n+    /// values that lead to a `target` block from a `switch` block.\n+    #[inline]\n+    pub fn switch_sources(&self) -> &SwitchSources {\n+        self.switch_source_cache.compute(&self.basic_blocks)\n+    }\n+\n+    /// Returns mutable reference to basic blocks. Invalidates CFG cache.\n+    #[inline]\n+    pub fn as_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        self.invalidate_cfg_cache();\n+        &mut self.basic_blocks\n+    }\n+\n+    /// Get mutable access to basic blocks without invalidating the CFG cache.\n+    ///\n+    /// By calling this method instead of e.g. [`BasicBlocks::as_mut`] you promise not to change\n+    /// the CFG. This means that\n+    ///\n+    ///  1) The number of basic blocks remains unchanged\n+    ///  2) The set of successors of each terminator remains unchanged.\n+    ///  3) For each `TerminatorKind::SwitchInt`, the `targets` remains the same and the terminator\n+    ///     kind is not changed.\n+    ///\n+    /// If any of these conditions cannot be upheld, you should call [`BasicBlocks::invalidate_cfg_cache`].\n+    #[inline]\n+    pub fn as_mut_preserves_cfg(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &mut self.basic_blocks\n+    }\n+\n+    /// Invalidates cached information about the CFG.\n+    ///\n+    /// You will only ever need this if you have also called [`BasicBlocks::as_mut_preserves_cfg`].\n+    /// All other methods that allow you to mutate the basic blocks also call this method\n+    /// themselves, thereby avoiding any risk of accidentaly cache invalidation.\n+    pub fn invalidate_cfg_cache(&mut self) {\n+        self.predecessor_cache.invalidate();\n+        self.switch_source_cache.invalidate();\n+        self.is_cyclic.invalidate();\n+        self.postorder_cache.invalidate();\n+    }\n+}\n+\n+impl<'tcx> std::ops::Deref for BasicBlocks<'tcx> {\n+    type Target = IndexVec<BasicBlock, BasicBlockData<'tcx>>;\n+\n+    #[inline]\n+    fn deref(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &self.basic_blocks\n+    }\n+}\n+\n+impl<'tcx> graph::DirectedGraph for BasicBlocks<'tcx> {\n+    type Node = BasicBlock;\n+}\n+\n+impl<'tcx> graph::WithNumNodes for BasicBlocks<'tcx> {\n+    #[inline]\n+    fn num_nodes(&self) -> usize {\n+        self.basic_blocks.len()\n+    }\n+}\n+\n+impl<'tcx> graph::WithStartNode for BasicBlocks<'tcx> {\n+    #[inline]\n+    fn start_node(&self) -> Self::Node {\n+        START_BLOCK\n+    }\n+}\n+\n+impl<'tcx> graph::WithSuccessors for BasicBlocks<'tcx> {\n+    #[inline]\n+    fn successors(&self, node: Self::Node) -> <Self as graph::GraphSuccessors<'_>>::Iter {\n+        self.basic_blocks[node].terminator().successors()\n+    }\n+}\n+\n+impl<'a, 'b> graph::GraphSuccessors<'b> for BasicBlocks<'a> {\n+    type Item = BasicBlock;\n+    type Iter = Successors<'b>;\n+}\n+\n+impl<'tcx, 'graph> graph::GraphPredecessors<'graph> for BasicBlocks<'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = std::iter::Copied<std::slice::Iter<'graph, BasicBlock>>;\n+}\n+\n+impl<'tcx> graph::WithPredecessors for BasicBlocks<'tcx> {\n+    #[inline]\n+    fn predecessors(&self, node: Self::Node) -> <Self as graph::GraphPredecessors<'_>>::Iter {\n+        self.predecessors()[node].iter().copied()\n+    }\n+}"}, {"sha": "6a0aa247a94e5155de8991d13d01d9d0bac952b5", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 138, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -5,7 +5,6 @@\n use crate::mir::interpret::{\n     AllocRange, ConstAllocation, ConstValue, GlobalAlloc, LitToConstInput, Scalar,\n };\n-use crate::mir::traversal::PostorderCache;\n use crate::mir::visit::MirVisitable;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable};\n@@ -28,7 +27,6 @@ use polonius_engine::Atom;\n pub use rustc_ast::Mutability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n-use rustc_data_structures::graph::{self, GraphSuccessors};\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_serialize::{Decodable, Encodable};\n@@ -43,11 +41,12 @@ use std::fmt::{self, Debug, Display, Formatter, Write};\n use std::ops::{ControlFlow, Index, IndexMut};\n use std::{iter, mem};\n \n-use self::graph_cyclic_cache::GraphIsCyclicCache;\n-use self::predecessors::{PredecessorCache, Predecessors};\n+use self::predecessors::Predecessors;\n pub use self::query::*;\n-use self::switch_sources::{SwitchSourceCache, SwitchSources};\n+use self::switch_sources::SwitchSources;\n+pub use basic_blocks::BasicBlocks;\n \n+mod basic_blocks;\n pub mod coverage;\n mod generic_graph;\n pub mod generic_graphviz;\n@@ -189,7 +188,7 @@ pub struct GeneratorInfo<'tcx> {\n pub struct Body<'tcx> {\n     /// A list of basic blocks. References to basic block use a newtyped index type [`BasicBlock`]\n     /// that indexes into this vector.\n-    basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    pub basic_blocks: BasicBlocks<'tcx>,\n \n     /// Records how far through the \"desugaring and optimization\" process this particular\n     /// MIR has traversed. This is particularly useful when inlining, since in that context\n@@ -257,11 +256,6 @@ pub struct Body<'tcx> {\n     /// potentially allow things like `[u8; std::mem::size_of::<T>() * 0]` due to this.\n     pub is_polymorphic: bool,\n \n-    predecessor_cache: PredecessorCache,\n-    switch_source_cache: SwitchSourceCache,\n-    is_cyclic: GraphIsCyclicCache,\n-    postorder_cache: PostorderCache,\n-\n     pub tainted_by_errors: Option<ErrorGuaranteed>,\n }\n \n@@ -289,7 +283,7 @@ impl<'tcx> Body<'tcx> {\n         let mut body = Body {\n             phase: MirPhase::Built,\n             source,\n-            basic_blocks,\n+            basic_blocks: BasicBlocks::new(basic_blocks),\n             source_scopes,\n             generator: generator_kind.map(|generator_kind| {\n                 Box::new(GeneratorInfo {\n@@ -307,10 +301,6 @@ impl<'tcx> Body<'tcx> {\n             span,\n             required_consts: Vec::new(),\n             is_polymorphic: false,\n-            predecessor_cache: PredecessorCache::new(),\n-            switch_source_cache: SwitchSourceCache::new(),\n-            is_cyclic: GraphIsCyclicCache::new(),\n-            postorder_cache: PostorderCache::new(),\n             tainted_by_errors,\n         };\n         body.is_polymorphic = body.has_param_types_or_consts();\n@@ -326,7 +316,7 @@ impl<'tcx> Body<'tcx> {\n         let mut body = Body {\n             phase: MirPhase::Built,\n             source: MirSource::item(CRATE_DEF_ID.to_def_id()),\n-            basic_blocks,\n+            basic_blocks: BasicBlocks::new(basic_blocks),\n             source_scopes: IndexVec::new(),\n             generator: None,\n             local_decls: IndexVec::new(),\n@@ -337,10 +327,6 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             var_debug_info: Vec::new(),\n             is_polymorphic: false,\n-            predecessor_cache: PredecessorCache::new(),\n-            switch_source_cache: SwitchSourceCache::new(),\n-            is_cyclic: GraphIsCyclicCache::new(),\n-            postorder_cache: PostorderCache::new(),\n             tainted_by_errors: None,\n         };\n         body.is_polymorphic = body.has_param_types_or_consts();\n@@ -354,74 +340,13 @@ impl<'tcx> Body<'tcx> {\n \n     #[inline]\n     pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        // Because the user could mutate basic block terminators via this reference, we need to\n-        // invalidate the caches.\n-        //\n-        // FIXME: Use a finer-grained API for this, so only transformations that alter terminators\n-        // invalidate the caches.\n-        self.invalidate_cfg_cache();\n-        &mut self.basic_blocks\n-    }\n-\n-    #[inline]\n-    pub fn basic_blocks_and_local_decls_mut(\n-        &mut self,\n-    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n-        self.invalidate_cfg_cache();\n-        (&mut self.basic_blocks, &mut self.local_decls)\n-    }\n-\n-    #[inline]\n-    pub fn basic_blocks_local_decls_mut_and_var_debug_info(\n-        &mut self,\n-    ) -> (\n-        &mut IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-        &mut LocalDecls<'tcx>,\n-        &mut Vec<VarDebugInfo<'tcx>>,\n-    ) {\n-        self.invalidate_cfg_cache();\n-        (&mut self.basic_blocks, &mut self.local_decls, &mut self.var_debug_info)\n-    }\n-\n-    /// Get mutable access to parts of the Body without invalidating the CFG cache.\n-    ///\n-    /// By calling this method instead of eg [`Body::basic_blocks_mut`], you promise not to change\n-    /// the CFG. This means that\n-    ///\n-    ///  1) The number of basic blocks remains unchanged\n-    ///  2) The set of successors of each terminator remains unchanged.\n-    ///  3) For each `TerminatorKind::SwitchInt`, the `targets` remains the same and the terminator\n-    ///     kind is not changed.\n-    ///\n-    /// If any of these conditions cannot be upheld, you should call [`Body::invalidate_cfg_cache`].\n-    #[inline]\n-    pub fn basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate(\n-        &mut self,\n-    ) -> (\n-        &mut IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-        &mut LocalDecls<'tcx>,\n-        &mut Vec<VarDebugInfo<'tcx>>,\n-    ) {\n-        (&mut self.basic_blocks, &mut self.local_decls, &mut self.var_debug_info)\n-    }\n-\n-    /// Invalidates cached information about the CFG.\n-    ///\n-    /// You will only ever need this if you have also called\n-    /// [`Body::basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate`]. All other methods\n-    /// that allow you to mutate the body also call this method themselves, thereby avoiding any\n-    /// risk of accidentaly cache invalidation.\n-    pub fn invalidate_cfg_cache(&mut self) {\n-        self.predecessor_cache.invalidate();\n-        self.switch_source_cache.invalidate();\n-        self.is_cyclic.invalidate();\n-        self.postorder_cache.invalidate();\n+        self.basic_blocks.as_mut()\n     }\n \n     /// Returns `true` if a cycle exists in the control-flow graph that is reachable from the\n     /// `START_BLOCK`.\n     pub fn is_cfg_cyclic(&self) -> bool {\n-        self.is_cyclic.is_cyclic(self)\n+        self.basic_blocks.is_cfg_cyclic()\n     }\n \n     #[inline]\n@@ -495,14 +420,6 @@ impl<'tcx> Body<'tcx> {\n         self.local_decls.drain(self.arg_count + 1..)\n     }\n \n-    /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n-    /// invalidating statement indices in `Location`s.\n-    pub fn make_statement_nop(&mut self, location: Location) {\n-        let block = &mut self.basic_blocks[location.block];\n-        debug_assert!(location.statement_index < block.statements.len());\n-        block.statements[location.statement_index].make_nop()\n-    }\n-\n     /// Returns the source info associated with `location`.\n     pub fn source_info(&self, location: Location) -> &SourceInfo {\n         let block = &self[location.block];\n@@ -540,19 +457,19 @@ impl<'tcx> Body<'tcx> {\n \n     #[inline]\n     pub fn predecessors(&self) -> &Predecessors {\n-        self.predecessor_cache.compute(&self.basic_blocks)\n+        self.basic_blocks.predecessors()\n     }\n \n     /// `body.switch_sources()[&(target, switch)]` returns a list of switch\n     /// values that lead to a `target` block from a `switch` block.\n     #[inline]\n     pub fn switch_sources(&self) -> &SwitchSources {\n-        self.switch_source_cache.compute(&self.basic_blocks)\n+        self.basic_blocks.switch_sources()\n     }\n \n     #[inline]\n     pub fn dominators(&self) -> Dominators<BasicBlock> {\n-        dominators(self)\n+        dominators(&self.basic_blocks)\n     }\n \n     #[inline]\n@@ -599,7 +516,7 @@ impl<'tcx> Index<BasicBlock> for Body<'tcx> {\n impl<'tcx> IndexMut<BasicBlock> for Body<'tcx> {\n     #[inline]\n     fn index_mut(&mut self, index: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        &mut self.basic_blocks_mut()[index]\n+        &mut self.basic_blocks.as_mut()[index]\n     }\n }\n \n@@ -2890,48 +2807,6 @@ fn pretty_print_const_value<'tcx>(\n     })\n }\n \n-impl<'tcx> graph::DirectedGraph for Body<'tcx> {\n-    type Node = BasicBlock;\n-}\n-\n-impl<'tcx> graph::WithNumNodes for Body<'tcx> {\n-    #[inline]\n-    fn num_nodes(&self) -> usize {\n-        self.basic_blocks.len()\n-    }\n-}\n-\n-impl<'tcx> graph::WithStartNode for Body<'tcx> {\n-    #[inline]\n-    fn start_node(&self) -> Self::Node {\n-        START_BLOCK\n-    }\n-}\n-\n-impl<'tcx> graph::WithSuccessors for Body<'tcx> {\n-    #[inline]\n-    fn successors(&self, node: Self::Node) -> <Self as GraphSuccessors<'_>>::Iter {\n-        self.basic_blocks[node].terminator().successors()\n-    }\n-}\n-\n-impl<'a, 'b> graph::GraphSuccessors<'b> for Body<'a> {\n-    type Item = BasicBlock;\n-    type Iter = Successors<'b>;\n-}\n-\n-impl<'tcx, 'graph> graph::GraphPredecessors<'graph> for Body<'tcx> {\n-    type Item = BasicBlock;\n-    type Iter = std::iter::Copied<std::slice::Iter<'graph, BasicBlock>>;\n-}\n-\n-impl<'tcx> graph::WithPredecessors for Body<'tcx> {\n-    #[inline]\n-    fn predecessors(&self, node: Self::Node) -> <Self as graph::GraphPredecessors<'_>>::Iter {\n-        self.predecessors()[node].iter().copied()\n-    }\n-}\n-\n /// `Location` represents the position of the start of the statement; or, if\n /// `statement_index` equals the number of statements, then the start of the\n /// terminator."}, {"sha": "627dc32f37eb571cceaea53daef6480589b29a04", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -104,22 +104,25 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n ///\n /// A Postorder traversal of this graph is `D B C A` or `D C B A`\n pub struct Postorder<'a, 'tcx> {\n-    body: &'a Body<'tcx>,\n+    basic_blocks: &'a IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     visited: BitSet<BasicBlock>,\n     visit_stack: Vec<(BasicBlock, Successors<'a>)>,\n     root_is_start_block: bool,\n }\n \n impl<'a, 'tcx> Postorder<'a, 'tcx> {\n-    pub fn new(body: &'a Body<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n+    pub fn new(\n+        basic_blocks: &'a IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+        root: BasicBlock,\n+    ) -> Postorder<'a, 'tcx> {\n         let mut po = Postorder {\n-            body,\n-            visited: BitSet::new_empty(body.basic_blocks().len()),\n+            basic_blocks,\n+            visited: BitSet::new_empty(basic_blocks.len()),\n             visit_stack: Vec::new(),\n             root_is_start_block: root == START_BLOCK,\n         };\n \n-        let data = &po.body[root];\n+        let data = &po.basic_blocks[root];\n \n         if let Some(ref term) = data.terminator {\n             po.visited.insert(root);\n@@ -190,7 +193,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n             };\n \n             if self.visited.insert(bb) {\n-                if let Some(term) = &self.body[bb].terminator {\n+                if let Some(term) = &self.basic_blocks[bb].terminator {\n                     self.visit_stack.push((bb, term.successors()));\n                 }\n             }\n@@ -199,7 +202,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n }\n \n pub fn postorder<'a, 'tcx>(body: &'a Body<'tcx>) -> Postorder<'a, 'tcx> {\n-    Postorder::new(body, START_BLOCK)\n+    Postorder::new(&body.basic_blocks, START_BLOCK)\n }\n \n impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n@@ -211,12 +214,12 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n             self.traverse_successor();\n         }\n \n-        next.map(|(bb, _)| (bb, &self.body[bb]))\n+        next.map(|(bb, _)| (bb, &self.basic_blocks[bb]))\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         // All the blocks, minus the number of blocks we've visited.\n-        let upper = self.body.basic_blocks().len() - self.visited.count();\n+        let upper = self.basic_blocks.len() - self.visited.count();\n \n         let lower = if self.root_is_start_block {\n             // We will visit all remaining blocks exactly once.\n@@ -263,10 +266,8 @@ pub struct ReversePostorder<'a, 'tcx> {\n \n impl<'a, 'tcx> ReversePostorder<'a, 'tcx> {\n     pub fn new(body: &'a Body<'tcx>, root: BasicBlock) -> ReversePostorder<'a, 'tcx> {\n-        let blocks: Vec<_> = Postorder::new(body, root).map(|(bb, _)| bb).collect();\n-\n+        let blocks: Vec<_> = Postorder::new(&body.basic_blocks, root).map(|(bb, _)| bb).collect();\n         let len = blocks.len();\n-\n         ReversePostorder { body, blocks, idx: len }\n     }\n }\n@@ -334,10 +335,8 @@ impl<'a, 'tcx> Iterator for ReversePostorderIter<'a, 'tcx> {\n impl<'a, 'tcx> ExactSizeIterator for ReversePostorderIter<'a, 'tcx> {}\n \n pub fn reverse_postorder<'a, 'tcx>(body: &'a Body<'tcx>) -> ReversePostorderIter<'a, 'tcx> {\n-    let blocks = body.postorder_cache.compute(body);\n-\n+    let blocks = body.basic_blocks.postorder();\n     let len = blocks.len();\n-\n     ReversePostorderIter { body, blocks, idx: len }\n }\n \n@@ -360,7 +359,7 @@ impl PostorderCache {\n \n     /// Returns the `&[BasicBlocks]` represents the postorder graph for this MIR.\n     #[inline]\n-    pub(super) fn compute(&self, body: &Body<'_>) -> &[BasicBlock] {\n+    pub(super) fn compute(&self, body: &IndexVec<BasicBlock, BasicBlockData<'_>>) -> &[BasicBlock] {\n         self.cache.get_or_init(|| Postorder::new(body, START_BLOCK).map(|(bb, _)| bb).collect())\n     }\n }"}, {"sha": "d21a8c4f9b9a3e2a410d32e1d067046b7f3e501e", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::graph::iterate::{\n     NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n };\n use rustc_hir::intravisit::FnKind;\n-use rustc_middle::mir::{BasicBlock, Body, Operand, TerminatorKind};\n+use rustc_middle::mir::{BasicBlock, BasicBlocks, Body, Operand, TerminatorKind};\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n@@ -30,7 +30,9 @@ pub(crate) fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n         };\n \n         let mut vis = Search { tcx, body, reachable_recursive_calls: vec![], trait_substs };\n-        if let Some(NonRecursive) = TriColorDepthFirstSearch::new(&body).run_from_start(&mut vis) {\n+        if let Some(NonRecursive) =\n+            TriColorDepthFirstSearch::new(&body.basic_blocks).run_from_start(&mut vis)\n+        {\n             return;\n         }\n         if vis.reachable_recursive_calls.is_empty() {\n@@ -101,7 +103,7 @@ impl<'mir, 'tcx> Search<'mir, 'tcx> {\n     }\n }\n \n-impl<'mir, 'tcx> TriColorVisitor<&'mir Body<'tcx>> for Search<'mir, 'tcx> {\n+impl<'mir, 'tcx> TriColorVisitor<BasicBlocks<'tcx>> for Search<'mir, 'tcx> {\n     type BreakVal = NonRecursive;\n \n     fn node_examined("}, {"sha": "5d15f03491d79fa8b6e06fcfa8df4ece7a4fc486", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -91,7 +91,8 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         super::add_call_guards::AllCallEdges.run_pass(tcx, body);\n \n         let (span, arg_count) = (body.span, body.arg_count);\n-        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n+        let basic_blocks = body.basic_blocks.as_mut();\n+        let local_decls = &body.local_decls;\n         let needs_retag = |place: &Place<'tcx>| {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that."}, {"sha": "47f851c97092d892f388f5df9d73f2fb98ba4487", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -80,7 +80,7 @@ impl CoverageGraph {\n         IndexVec<BasicCoverageBlock, BasicCoverageBlockData>,\n         IndexVec<BasicBlock, Option<BasicCoverageBlock>>,\n     ) {\n-        let num_basic_blocks = mir_body.num_nodes();\n+        let num_basic_blocks = mir_body.basic_blocks.len();\n         let mut bcbs = IndexVec::with_capacity(num_basic_blocks);\n         let mut bb_to_bcb = IndexVec::from_elem_n(None, num_basic_blocks);\n "}, {"sha": "423e78317aadbc1f21639b2a6ea0f7af77f6b28b", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -321,7 +321,8 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     }\n \n     fn mir_to_initial_sorted_coverage_spans(&self) -> Vec<CoverageSpan> {\n-        let mut initial_spans = Vec::<CoverageSpan>::with_capacity(self.mir_body.num_nodes() * 2);\n+        let mut initial_spans =\n+            Vec::<CoverageSpan>::with_capacity(self.mir_body.basic_blocks.len() * 2);\n         for (bcb, bcb_data) in self.basic_coverage_blocks.iter_enumerated() {\n             initial_spans.extend(self.bcb_to_initial_coverage_spans(bcb, bcb_data));\n         }"}, {"sha": "6380f03528ae8dc6a58936dc5d84b2710ace47bd", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -222,6 +222,7 @@ fn print_mir_graphviz(name: &str, mir_body: &Body<'_>) {\n                         bb,\n                         debug::term_type(&data.terminator().kind),\n                         mir_body\n+                            .basic_blocks\n                             .successors(bb)\n                             .map(|successor| { format!(\"    {:?} -> {:?};\", bb, successor) })\n                             .join(\"\\n\")"}, {"sha": "9163672f570396113e372faf60addc21b5e3278d", "filename": "compiler/rustc_mir_transform/src/dead_store_elimination.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -66,7 +66,7 @@ pub fn eliminate<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, borrowed: &BitS\n         return;\n     }\n \n-    let bbs = body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate().0;\n+    let bbs = body.basic_blocks.as_mut_preserves_cfg();\n     for Location { block, statement_index } in patch {\n         bbs[block].statements[statement_index].make_nop();\n     }"}, {"sha": "b93fe5879f4fd99a7bc388bf008cb2465b3f4c0f", "filename": "compiler/rustc_mir_transform/src/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -11,9 +11,7 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let (basic_blocks, local_decls, _) =\n-            body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate();\n-        let local_decls = &*local_decls;\n+        let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n         for bb in basic_blocks {\n             bb.expand_statements(|stmt| {\n                 // FIXME(eddyb) don't match twice on `stmt.kind` (post-NLL).\n@@ -38,7 +36,7 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n                 Some(expand_aggregate(\n                     lhs,\n                     operands.into_iter().map(|op| {\n-                        let ty = op.ty(local_decls, tcx);\n+                        let ty = op.ty(&body.local_decls, tcx);\n                         (op, ty)\n                     }),\n                     *kind,"}, {"sha": "44e3945d6fc8905e1b0bc5023cb7a52793ea16a2", "filename": "compiler/rustc_mir_transform/src/elaborate_box_derefs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -110,13 +110,13 @@ impl<'tcx> MirPass<'tcx> for ElaborateBoxDerefs {\n \n             let patch = MirPatch::new(body);\n \n-            let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n+            let local_decls = &mut body.local_decls;\n \n             let mut visitor =\n                 ElaborateBoxDerefVisitor { tcx, unique_did, nonnull_did, local_decls, patch };\n \n             for (block, BasicBlockData { statements, terminator, .. }) in\n-                basic_blocks.iter_enumerated_mut()\n+                body.basic_blocks.as_mut().iter_enumerated_mut()\n             {\n                 let mut index = 0;\n                 for statement in statements {"}, {"sha": "2f3c65869ef3b2ce275ef446af389d6eeb259e39", "filename": "compiler/rustc_mir_transform/src/instcombine.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -16,9 +16,8 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n-        let ctx = InstCombineContext { tcx, local_decls };\n-        for block in basic_blocks.iter_mut() {\n+        let ctx = InstCombineContext { tcx, local_decls: &body.local_decls };\n+        for block in body.basic_blocks.as_mut() {\n             for statement in block.statements.iter_mut() {\n                 match statement.kind {\n                     StatementKind::Assign(box (_place, ref mut rvalue)) => {"}, {"sha": "b7ba616510c28874b2356f294ba7155b6a7f8bb7", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -11,8 +11,8 @@ pub struct LowerIntrinsics;\n \n impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n-        for block in basic_blocks {\n+        let local_decls = &body.local_decls;\n+        for block in body.basic_blocks.as_mut() {\n             let terminator = block.terminator.as_mut().unwrap();\n             if let TerminatorKind::Call { func, args, destination, target, .. } =\n                 &mut terminator.kind"}, {"sha": "47848cfa497f3bee5b64b99cecc6075e7ed32e35", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -27,12 +27,10 @@ pub fn lower_slice_len_calls<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     };\n \n     // The one successor remains unchanged, so no need to invalidate\n-    let (basic_blocks, local_decls, _) =\n-        body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate();\n-\n+    let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n     for block in basic_blocks {\n         // lower `<[_]>::len` calls\n-        lower_slice_len_call(tcx, block, &*local_decls, slice_len_fn_item_def_id);\n+        lower_slice_len_call(tcx, block, &body.local_decls, slice_len_fn_item_def_id);\n     }\n }\n "}, {"sha": "a0ba69c89b048491f9840a9cd6806f91bf2fd46f", "filename": "compiler/rustc_mir_transform/src/match_branches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n         let def_id = body.source.def_id();\n         let param_env = tcx.param_env(def_id);\n \n-        let (bbs, local_decls) = body.basic_blocks_and_local_decls_mut();\n+        let bbs = body.basic_blocks.as_mut();\n         let mut should_cleanup = false;\n         'outer: for bb_idx in bbs.indices() {\n             if !tcx.consider_optimizing(|| format!(\"MatchBranchSimplification {:?} \", def_id)) {\n@@ -108,7 +108,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n \n             // Introduce a temporary for the discriminant value.\n             let source_info = bbs[bb_idx].terminator().source_info;\n-            let discr_local = local_decls.push(LocalDecl::new(switch_ty, source_info.span));\n+            let discr_local = body.local_decls.push(LocalDecl::new(switch_ty, source_info.span));\n \n             // We already checked that first and second are different blocks,\n             // and bb_idx has a different terminator from both of them."}, {"sha": "c0217a105414b65ff9fb20292f3d54aa3a1234d1", "filename": "compiler/rustc_mir_transform/src/normalize_array_len.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -33,8 +33,8 @@ impl<'tcx> MirPass<'tcx> for NormalizeArrayLen {\n \n pub fn normalize_array_len_calls<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     // We don't ever touch terminators, so no need to invalidate the CFG cache\n-    let (basic_blocks, local_decls, _) =\n-        body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate();\n+    let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n+    let local_decls = &mut body.local_decls;\n \n     // do a preliminary analysis to see if we ever have locals of type `[T;N]` or `&[T;N]`\n     let mut interesting_locals = BitSet::new_empty(local_decls.len());"}, {"sha": "dbe082e909371f57adf1c3563d29a9e96391d7a6", "filename": "compiler/rustc_mir_transform/src/remove_storage_markers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_storage_markers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_storage_markers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_storage_markers.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -17,7 +17,7 @@ impl<'tcx> MirPass<'tcx> for RemoveStorageMarkers {\n         }\n \n         trace!(\"Running RemoveStorageMarkers on {:?}\", body.source);\n-        for data in body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate().0 {\n+        for data in body.basic_blocks.as_mut_preserves_cfg() {\n             data.statements.retain(|statement| match statement.kind {\n                 StatementKind::StorageLive(..)\n                 | StatementKind::StorageDead(..)"}, {"sha": "84ccf6e1f61d492d9393134640ecaf5ef99a5296", "filename": "compiler/rustc_mir_transform/src/remove_unneeded_drops.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -20,11 +20,10 @@ impl<'tcx> MirPass<'tcx> for RemoveUnneededDrops {\n         let param_env = tcx.param_env_reveal_all_normalized(did);\n         let mut should_simplify = false;\n \n-        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n-        for block in basic_blocks {\n+        for block in body.basic_blocks.as_mut() {\n             let terminator = block.terminator_mut();\n             if let TerminatorKind::Drop { place, target, .. } = terminator.kind {\n-                let ty = place.ty(local_decls, tcx);\n+                let ty = place.ty(&body.local_decls, tcx);\n                 if ty.ty.needs_drop(tcx, param_env) {\n                     continue;\n                 }"}, {"sha": "40be4f146db98ffefec45920ffeca6e460609786", "filename": "compiler/rustc_mir_transform/src/remove_zsts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -18,9 +18,9 @@ impl<'tcx> MirPass<'tcx> for RemoveZsts {\n             return;\n         }\n         let param_env = tcx.param_env(body.source.def_id());\n-        let (basic_blocks, local_decls, _) =\n-            body.basic_blocks_local_decls_mut_and_var_debug_info_no_invalidate();\n-        for block in basic_blocks.iter_mut() {\n+        let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n+        let local_decls = &body.local_decls;\n+        for block in basic_blocks {\n             for statement in block.statements.iter_mut() {\n                 if let StatementKind::Assign(box (place, _)) | StatementKind::Deinit(box place) =\n                     statement.kind"}, {"sha": "fca9f7eeb24613cff074538de800b7f2e1afe507", "filename": "compiler/rustc_mir_transform/src/simplify_try.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs?ref=c9dd1d9983b9a08159c2e3c86071d1a5ef7ebb20", "patch": "@@ -386,14 +386,17 @@ impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n         trace!(\"running SimplifyArmIdentity on {:?}\", source);\n \n         let local_uses = LocalUseCounter::get_local_uses(body);\n-        let (basic_blocks, local_decls, debug_info) =\n-            body.basic_blocks_local_decls_mut_and_var_debug_info();\n-        for bb in basic_blocks {\n+        for bb in body.basic_blocks.as_mut() {\n             if let Some(opt_info) =\n-                get_arm_identity_info(&bb.statements, local_decls.len(), debug_info)\n+                get_arm_identity_info(&bb.statements, body.local_decls.len(), &body.var_debug_info)\n             {\n                 trace!(\"got opt_info = {:#?}\", opt_info);\n-                if !optimization_applies(&opt_info, local_decls, &local_uses, &debug_info) {\n+                if !optimization_applies(\n+                    &opt_info,\n+                    &body.local_decls,\n+                    &local_uses,\n+                    &body.var_debug_info,\n+                ) {\n                     debug!(\"optimization skipped for {:?}\", source);\n                     continue;\n                 }\n@@ -431,7 +434,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n \n                 // Fix the debug info to point to the right local\n                 for dbg_index in opt_info.dbg_info_to_adjust {\n-                    let dbg_info = &mut debug_info[dbg_index];\n+                    let dbg_info = &mut body.var_debug_info[dbg_index];\n                     assert!(\n                         matches!(dbg_info.value, VarDebugInfoContents::Place(_)),\n                         \"value was not a Place\""}]}