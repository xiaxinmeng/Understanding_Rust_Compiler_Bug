{"sha": "5e736293b3bcada7dba0a134604eb6c9866d5858", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNzM2MjkzYjNiY2FkYTdkYmEwYTEzNDYwNGViNmM5ODY2ZDU4NTg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-03-05T10:21:44Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-03-05T10:21:44Z"}, "message": "Rustfmt", "tree": {"sha": "eebf9bbdd93d337ff67eec2599fcce8c23a504ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eebf9bbdd93d337ff67eec2599fcce8c23a504ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e736293b3bcada7dba0a134604eb6c9866d5858", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e736293b3bcada7dba0a134604eb6c9866d5858", "html_url": "https://github.com/rust-lang/rust/commit/5e736293b3bcada7dba0a134604eb6c9866d5858", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e736293b3bcada7dba0a134604eb6c9866d5858/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5f67dc703cc2f874a170927c0024e28e3a1121b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5f67dc703cc2f874a170927c0024e28e3a1121b", "html_url": "https://github.com/rust-lang/rust/commit/b5f67dc703cc2f874a170927c0024e28e3a1121b"}], "stats": {"total": 1725, "additions": 429, "deletions": 1296}, "files": [{"sha": "2bd8f7d1bc15d7a6690a34aad18f968f7af9bd3c", "filename": "rustfmt.toml", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -0,0 +1,4 @@\n+# Matches rustfmt.toml of rustc\n+version = \"Two\"\n+use_small_heuristics = \"Max\"\n+merge_derives = false"}, {"sha": "c3cf90e1e70be209295c81096cdfa3dfe5291ab2", "filename": "src/abi/comments.rs", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -42,11 +42,7 @@ pub(super) fn add_arg_comment<'tcx>(\n         [param_a, param_b] => Cow::Owned(format!(\"= {:?},{:?}\", param_a, param_b)),\n         params => Cow::Owned(format!(\n             \"= {}\",\n-            params\n-                .iter()\n-                .map(ToString::to_string)\n-                .collect::<Vec<_>>()\n-                .join(\",\")\n+            params.iter().map(ToString::to_string).collect::<Vec<_>>().join(\",\")\n         )),\n     };\n \n@@ -75,14 +71,8 @@ pub(super) fn add_local_place_comments<'tcx>(\n     local: Local,\n ) {\n     let TyAndLayout { ty, layout } = place.layout();\n-    let rustc_target::abi::Layout {\n-        size,\n-        align,\n-        abi: _,\n-        variants: _,\n-        fields: _,\n-        largest_niche: _,\n-    } = layout;\n+    let rustc_target::abi::Layout { size, align, abi: _, variants: _, fields: _, largest_niche: _ } =\n+        layout;\n \n     let (kind, extra) = match *place.inner() {\n         CPlaceInner::Var(place_local, var) => {\n@@ -91,10 +81,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n         }\n         CPlaceInner::VarPair(place_local, var1, var2) => {\n             assert_eq!(local, place_local);\n-            (\n-                \"ssa\",\n-                Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())),\n-            )\n+            (\"ssa\", Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())))\n         }\n         CPlaceInner::VarLane(_local, _var, _lane) => unreachable!(),\n         CPlaceInner::Addr(ptr, meta) => {\n@@ -104,18 +91,15 @@ pub(super) fn add_local_place_comments<'tcx>(\n                 Cow::Borrowed(\"\")\n             };\n             match ptr.base_and_offset() {\n-                (crate::pointer::PointerBase::Addr(addr), offset) => (\n-                    \"reuse\",\n-                    format!(\"storage={}{}{}\", addr, offset, meta).into(),\n-                ),\n-                (crate::pointer::PointerBase::Stack(stack_slot), offset) => (\n-                    \"stack\",\n-                    format!(\"storage={}{}{}\", stack_slot, offset, meta).into(),\n-                ),\n-                (crate::pointer::PointerBase::Dangling(align), offset) => (\n-                    \"zst\",\n-                    format!(\"align={},offset={}\", align.bytes(), offset).into(),\n-                ),\n+                (crate::pointer::PointerBase::Addr(addr), offset) => {\n+                    (\"reuse\", format!(\"storage={}{}{}\", addr, offset, meta).into())\n+                }\n+                (crate::pointer::PointerBase::Stack(stack_slot), offset) => {\n+                    (\"stack\", format!(\"storage={}{}{}\", stack_slot, offset, meta).into())\n+                }\n+                (crate::pointer::PointerBase::Dangling(align), offset) => {\n+                    (\"zst\", format!(\"align={},offset={}\", align.bytes(), offset).into())\n+                }\n             }\n         }\n     };\n@@ -128,11 +112,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n         size.bytes(),\n         align.abi.bytes(),\n         align.pref.bytes(),\n-        if extra.is_empty() {\n-            \"\"\n-        } else {\n-            \"              \"\n-        },\n+        if extra.is_empty() { \"\" } else { \"              \" },\n         extra,\n     ));\n }"}, {"sha": "c79889f8ca1da99c5db002f7b19746fad5d1d04d", "filename": "src/abi/mod.rs", "status": "modified", "additions": 27, "deletions": 96, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -40,21 +40,13 @@ fn clif_sig_from_fn_abi<'tcx>(\n         | Conv::AvrInterrupt\n         | Conv::AvrNonBlockingInterrupt => todo!(\"{:?}\", fn_abi.conv),\n     };\n-    let inputs = fn_abi\n-        .args\n-        .iter()\n-        .map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter())\n-        .flatten();\n+    let inputs = fn_abi.args.iter().map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter()).flatten();\n \n     let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n     // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n     let params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n \n-    Signature {\n-        params,\n-        returns,\n-        call_conv,\n-    }\n+    Signature { params, returns, call_conv }\n }\n \n pub(crate) fn get_function_sig<'tcx>(\n@@ -63,11 +55,7 @@ pub(crate) fn get_function_sig<'tcx>(\n     inst: Instance<'tcx>,\n ) -> Signature {\n     assert!(!inst.substs.needs_infer());\n-    clif_sig_from_fn_abi(\n-        tcx,\n-        triple,\n-        &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]),\n-    )\n+    clif_sig_from_fn_abi(tcx, triple, &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]))\n }\n \n /// Instance must be monomorphized\n@@ -78,19 +66,14 @@ pub(crate) fn import_function<'tcx>(\n ) -> FuncId {\n     let name = tcx.symbol_name(inst).name.to_string();\n     let sig = get_function_sig(tcx, module.isa().triple(), inst);\n-    module\n-        .declare_function(&name, Linkage::Import, &sig)\n-        .unwrap()\n+    module.declare_function(&name, Linkage::Import, &sig).unwrap()\n }\n \n impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     /// Instance must be monomorphized\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n         let func_id = import_function(self.tcx, self.cx.module, inst);\n-        let func_ref = self\n-            .cx\n-            .module\n-            .declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n \n         #[cfg(debug_assertions)]\n         self.add_comment(func_ref, format!(\"{:?}\", inst));\n@@ -105,20 +88,9 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         returns: Vec<AbiParam>,\n         args: &[Value],\n     ) -> &[Value] {\n-        let sig = Signature {\n-            params,\n-            returns,\n-            call_conv: CallConv::triple_default(self.triple()),\n-        };\n-        let func_id = self\n-            .cx\n-            .module\n-            .declare_function(&name, Linkage::Import, &sig)\n-            .unwrap();\n-        let func_ref = self\n-            .cx\n-            .module\n-            .declare_func_in_func(func_id, &mut self.bcx.func);\n+        let sig = Signature { params, returns, call_conv: CallConv::triple_default(self.triple()) };\n+        let func_id = self.cx.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n+        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         #[cfg(debug_assertions)]\n         {\n@@ -138,17 +110,12 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let (input_tys, args): (Vec<_>, Vec<_>) = args\n             .iter()\n             .map(|arg| {\n-                (\n-                    AbiParam::new(self.clif_type(arg.layout().ty).unwrap()),\n-                    arg.load_scalar(self),\n-                )\n+                (AbiParam::new(self.clif_type(arg.layout().ty).unwrap()), arg.load_scalar(self))\n             })\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n         let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.types()\n-                .map(|ty| AbiParam::new(self.clif_type(ty).unwrap()))\n-                .collect()\n+            tup.types().map(|ty| AbiParam::new(self.clif_type(ty).unwrap())).collect()\n         } else {\n             vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n         };\n@@ -199,13 +166,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     #[cfg(debug_assertions)]\n     self::comments::add_args_header_comment(fx);\n \n-    let mut block_params_iter = fx\n-        .bcx\n-        .func\n-        .dfg\n-        .block_params(start_block)\n-        .to_vec()\n-        .into_iter();\n+    let mut block_params_iter = fx.bcx.func.dfg.block_params(start_block).to_vec().into_iter();\n     let ret_place =\n         self::returning::codegen_return_param(fx, &ssa_analyzed, &mut block_params_iter);\n     assert_eq!(fx.local_map.push(ret_place), RETURN_PLACE);\n@@ -281,10 +242,10 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n             if let Some((addr, meta)) = val.try_to_ptr() {\n                 let local_decl = &fx.mir.local_decls[local];\n                 //                       v this ! is important\n-                let internally_mutable = !val.layout().ty.is_freeze(\n-                    fx.tcx.at(local_decl.source_info.span),\n-                    ParamEnv::reveal_all(),\n-                );\n+                let internally_mutable = !val\n+                    .layout()\n+                    .ty\n+                    .is_freeze(fx.tcx.at(local_decl.source_info.span), ParamEnv::reveal_all());\n                 if local_decl.mutability == mir::Mutability::Not && !internally_mutable {\n                     // We wont mutate this argument, so it is fine to borrow the backing storage\n                     // of this argument, to prevent a copy.\n@@ -316,9 +277,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n             ArgKind::Spread(params) => {\n                 for (i, param) in params.into_iter().enumerate() {\n                     if let Some(param) = param {\n-                        place\n-                            .place_field(fx, mir::Field::new(i))\n-                            .write_cvalue(fx, param);\n+                        place.place_field(fx, mir::Field::new(i)).write_cvalue(fx, param);\n                     }\n                 }\n             }\n@@ -335,9 +294,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n         assert_eq!(fx.local_map.push(place), local);\n     }\n \n-    fx.bcx\n-        .ins()\n-        .jump(*fx.block_map.get(START_BLOCK).unwrap(), &[]);\n+    fx.bcx.ins().jump(*fx.block_map.get(START_BLOCK).unwrap(), &[]);\n }\n \n pub(crate) fn codegen_terminator_call<'tcx>(\n@@ -349,9 +306,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     destination: Option<(Place<'tcx>, BasicBlock)>,\n ) {\n     let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n-    let fn_sig = fx\n-        .tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+    let fn_sig =\n+        fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n \n     let destination = destination.map(|(place, bb)| (codegen_place(fx, place), bb));\n \n@@ -399,20 +355,11 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     let fn_abi = if let Some(instance) = instance {\n         FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n     } else {\n-        FnAbi::of_fn_ptr(\n-            &RevealAllLayoutCx(fx.tcx),\n-            fn_ty.fn_sig(fx.tcx),\n-            &extra_args,\n-        )\n+        FnAbi::of_fn_ptr(&RevealAllLayoutCx(fx.tcx), fn_ty.fn_sig(fx.tcx), &extra_args)\n     };\n \n     let is_cold = instance\n-        .map(|inst| {\n-            fx.tcx\n-                .codegen_fn_attrs(inst.def_id())\n-                .flags\n-                .contains(CodegenFnAttrFlags::COLD)\n-        })\n+        .map(|inst| fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD))\n         .unwrap_or(false);\n     if is_cold {\n         fx.cold_blocks.insert(current_block);\n@@ -436,20 +383,15 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         }\n         args\n     } else {\n-        args.iter()\n-            .map(|arg| codegen_operand(fx, arg))\n-            .collect::<Vec<_>>()\n+        args.iter().map(|arg| codegen_operand(fx, arg)).collect::<Vec<_>>()\n     };\n \n     //   | indirect call target\n     //   |         | the first argument to be passed\n     //   v         v\n     let (func_ref, first_arg) = match instance {\n         // Trait object call\n-        Some(Instance {\n-            def: InstanceDef::Virtual(_, idx),\n-            ..\n-        }) => {\n+        Some(Instance { def: InstanceDef::Virtual(_, idx), .. }) => {\n             #[cfg(debug_assertions)]\n             {\n                 let nop_inst = fx.bcx.ins().nop();\n@@ -506,10 +448,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 )\n                 .collect::<Vec<_>>();\n \n-            if instance\n-                .map(|inst| inst.def.requires_caller_location(fx.tcx))\n-                .unwrap_or(false)\n-            {\n+            if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n                 // Pass the caller location for `#[track_caller]`.\n                 let caller_location = fx.get_caller_location(span);\n                 call_args.extend(\n@@ -538,10 +477,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n         if fn_sig.abi != Abi::C {\n-            fx.tcx.sess.span_fatal(\n-                span,\n-                &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n-            );\n+            fx.tcx.sess.span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n         }\n         let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n         let abi_params = call_args\n@@ -550,9 +486,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let ty = fx.bcx.func.dfg.value_type(arg);\n                 if !ty.is_int() {\n                     // FIXME set %al to upperbound on float args once floats are supported\n-                    fx.tcx\n-                        .sess\n-                        .span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n+                    fx.tcx.sess.span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n                 }\n                 AbiParam::new(ty)\n             })\n@@ -606,10 +540,7 @@ pub(crate) fn codegen_drop<'tcx>(\n                     fx,\n                     fx.layout_of(fx.tcx.mk_ref(\n                         &ty::RegionKind::ReErased,\n-                        TypeAndMut {\n-                            ty,\n-                            mutbl: crate::rustc_hir::Mutability::Mut,\n-                        },\n+                        TypeAndMut { ty, mutbl: crate::rustc_hir::Mutability::Mut },\n                     )),\n                 );\n                 let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0]);"}, {"sha": "d58f952f53c1a6d4087dd81d7d18e5881e217513", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 19, "deletions": 71, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -71,12 +71,7 @@ fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n         .prefix\n         .iter()\n         .flatten()\n-        .map(|&kind| {\n-            reg_to_abi_param(Reg {\n-                kind,\n-                size: cast.prefix_chunk_size,\n-            })\n-        })\n+        .map(|&kind| reg_to_abi_param(Reg { kind, size: cast.prefix_chunk_size }))\n         .chain((0..rest_count).map(|_| reg_to_abi_param(cast.rest.unit)))\n         .collect::<SmallVec<_>>();\n \n@@ -120,29 +115,18 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n             PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n-            PassMode::Indirect {\n-                attrs,\n-                extra_attrs: None,\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n                     let size = u32::try_from(self.layout.size.bytes()).unwrap();\n                     smallvec![apply_arg_attrs_to_abi_param(\n                         AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructArgument(size),),\n                         attrs\n                     )]\n                 } else {\n-                    smallvec![apply_arg_attrs_to_abi_param(\n-                        AbiParam::new(pointer_ty(tcx)),\n-                        attrs\n-                    )]\n+                    smallvec![apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), attrs)]\n                 }\n             }\n-            PassMode::Indirect {\n-                attrs,\n-                extra_attrs: Some(extra_attrs),\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs, extra_attrs: Some(extra_attrs), on_stack } => {\n                 assert!(!on_stack);\n                 smallvec![\n                     apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), attrs),\n@@ -156,10 +140,9 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         match self.mode {\n             PassMode::Ignore => (None, vec![]),\n             PassMode::Direct(_) => match &self.layout.abi {\n-                Abi::Scalar(scalar) => (\n-                    None,\n-                    vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))],\n-                ),\n+                Abi::Scalar(scalar) => {\n+                    (None, vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))])\n+                }\n                 Abi::Vector { .. } => {\n                     let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n                     (None, vec![AbiParam::new(vector_ty)])\n@@ -175,25 +158,13 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n             PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n-            PassMode::Indirect {\n-                attrs: _,\n-                extra_attrs: None,\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs: _, extra_attrs: None, on_stack } => {\n                 assert!(!on_stack);\n-                (\n-                    Some(AbiParam::special(\n-                        pointer_ty(tcx),\n-                        ArgumentPurpose::StructReturn,\n-                    )),\n-                    vec![],\n-                )\n+                (Some(AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructReturn)), vec![])\n+            }\n+            PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+                unreachable!(\"unsized return value\")\n             }\n-            PassMode::Indirect {\n-                attrs: _,\n-                extra_attrs: Some(_),\n-                on_stack: _,\n-            } => unreachable!(\"unsized return value\"),\n         }\n     }\n }\n@@ -209,9 +180,7 @@ pub(super) fn to_casted_value<'tcx>(\n     cast_target_to_abi_params(cast)\n         .into_iter()\n         .map(|param| {\n-            let val = ptr\n-                .offset_i64(fx, offset)\n-                .load(fx, param.value_type, MemFlags::new());\n+            let val = ptr.offset_i64(fx, offset).load(fx, param.value_type, MemFlags::new());\n             offset += i64::from(param.value_type.bytes());\n             val\n         })\n@@ -225,10 +194,7 @@ pub(super) fn from_casted_value<'tcx>(\n     cast: CastTarget,\n ) -> CValue<'tcx> {\n     let abi_params = cast_target_to_abi_params(cast);\n-    let abi_param_size: u32 = abi_params\n-        .iter()\n-        .map(|param| param.value_type.bytes())\n-        .sum();\n+    let abi_param_size: u32 = abi_params.iter().map(|param| param.value_type.bytes()).sum();\n     let layout_size = u32::try_from(layout.size.bytes()).unwrap();\n     let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n@@ -292,10 +258,7 @@ pub(super) fn cvalue_for_param<'tcx>(\n         .into_iter()\n         .map(|abi_param| {\n             let block_param = block_params_iter.next().unwrap();\n-            assert_eq!(\n-                fx.bcx.func.dfg.value_type(block_param),\n-                abi_param.value_type\n-            );\n+            assert_eq!(fx.bcx.func.dfg.value_type(block_param), abi_param.value_type);\n             block_param\n         })\n         .collect::<SmallVec<[_; 2]>>();\n@@ -319,29 +282,14 @@ pub(super) fn cvalue_for_param<'tcx>(\n         }\n         PassMode::Pair(_, _) => {\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n-            Some(CValue::by_val_pair(\n-                block_params[0],\n-                block_params[1],\n-                arg_abi.layout,\n-            ))\n+            Some(CValue::by_val_pair(block_params[0], block_params[1], arg_abi.layout))\n         }\n         PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n-            Some(CValue::by_ref(\n-                Pointer::new(block_params[0]),\n-                arg_abi.layout,\n-            ))\n+            Some(CValue::by_ref(Pointer::new(block_params[0]), arg_abi.layout))\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n             Some(CValue::by_ref_unsized(\n                 Pointer::new(block_params[0]),"}, {"sha": "9fa066df69b3cd936b346b28a6bc1213ad633cb9", "filename": "src/abi/returning.rs", "status": "modified", "additions": 21, "deletions": 57, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -13,9 +13,8 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n     args: &[mir::Operand<'tcx>],\n ) -> bool {\n     let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n-    let fn_sig = fx\n-        .tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+    let fn_sig =\n+        fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n \n     // Handle special calls like instrinsics and empty drop glue.\n     let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n@@ -42,11 +41,7 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n     let fn_abi = if let Some(instance) = instance {\n         FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n     } else {\n-        FnAbi::of_fn_ptr(\n-            &RevealAllLayoutCx(fx.tcx),\n-            fn_ty.fn_sig(fx.tcx),\n-            &extra_args,\n-        )\n+        FnAbi::of_fn_ptr(&RevealAllLayoutCx(fx.tcx), fn_ty.fn_sig(fx.tcx), &extra_args)\n     };\n     match fn_abi.ret.mode {\n         PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) => true,\n@@ -63,10 +58,7 @@ pub(super) fn codegen_return_param<'tcx>(\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore => (\n-            CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout),\n-            smallvec![],\n-        ),\n+        PassMode::Ignore => (CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout), smallvec![]),\n         PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n@@ -79,26 +71,17 @@ pub(super) fn codegen_return_param<'tcx>(\n                 smallvec![],\n             )\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             let ret_param = block_params_iter.next().unwrap();\n             assert_eq!(fx.bcx.func.dfg.value_type(ret_param), pointer_ty(fx.tcx));\n             (\n-                CPlace::for_ptr(\n-                    Pointer::new(ret_param),\n-                    fx.fn_abi.as_ref().unwrap().ret.layout,\n-                ),\n+                CPlace::for_ptr(Pointer::new(ret_param), fx.fn_abi.as_ref().unwrap().ret.layout),\n                 smallvec![ret_param],\n             )\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n     };\n \n     #[cfg(not(debug_assertions))]\n@@ -128,19 +111,13 @@ pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n ) -> (Inst, T) {\n     let return_ptr = match ret_arg_abi.mode {\n         PassMode::Ignore => None,\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => match ret_place {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => match ret_place {\n             Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n         },\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n         PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => None,\n     };\n \n@@ -177,16 +154,10 @@ pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n                 ret_place.write_cvalue(fx, result);\n             }\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {}\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {}\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n     }\n \n     (call_inst, meta)\n@@ -195,19 +166,12 @@ pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n /// Codegen a return instruction with the right return value(s) if any.\n pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n     match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore\n-        | PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Ignore | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             fx.bcx.ins().return_(&[]);\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n         PassMode::Direct(_) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx).load_scalar(fx);"}, {"sha": "efb64233ef2c3109104b0dce231dec1d7aca699f", "filename": "src/allocator.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fallocator.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -66,13 +66,9 @@ fn codegen_inner(\n         let callee_name = kind.fn_name(method.name);\n         //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n \n-        let func_id = module\n-            .declare_function(&caller_name, Linkage::Export, &sig)\n-            .unwrap();\n+        let func_id = module.declare_function(&caller_name, Linkage::Export, &sig).unwrap();\n \n-        let callee_func_id = module\n-            .declare_function(&callee_name, Linkage::Import, &sig)\n-            .unwrap();\n+        let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n         let mut ctx = Context::new();\n         ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig.clone());\n@@ -96,11 +92,7 @@ fn codegen_inner(\n             bcx.finalize();\n         }\n         module\n-            .define_function(\n-                func_id,\n-                &mut ctx,\n-                &mut cranelift_codegen::binemit::NullTrapSink {},\n-            )\n+            .define_function(func_id, &mut ctx, &mut cranelift_codegen::binemit::NullTrapSink {})\n             .unwrap();\n         unwind_context.add_function(func_id, &ctx, module.isa());\n     }\n@@ -114,13 +106,10 @@ fn codegen_inner(\n     let callee_name = kind.fn_name(sym::oom);\n     //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n \n-    let func_id = module\n-        .declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig)\n-        .unwrap();\n+    let func_id =\n+        module.declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig).unwrap();\n \n-    let callee_func_id = module\n-        .declare_function(&callee_name, Linkage::Import, &sig)\n-        .unwrap();\n+    let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n     let mut ctx = Context::new();\n     ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n@@ -143,11 +132,7 @@ fn codegen_inner(\n         bcx.finalize();\n     }\n     module\n-        .define_function(\n-            func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n+        .define_function(func_id, &mut ctx, &mut cranelift_codegen::binemit::NullTrapSink {})\n         .unwrap();\n     unwind_context.add_function(func_id, &ctx, module.isa());\n }"}, {"sha": "efead25552f4d1ca203e35b49a2c4912ab253c4b", "filename": "src/analyze.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -40,12 +40,7 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n         }\n \n         match &bb.terminator().kind {\n-            TerminatorKind::Call {\n-                destination,\n-                func,\n-                args,\n-                ..\n-            } => {\n+            TerminatorKind::Call { destination, func, args, .. } => {\n                 if let Some((dest_place, _dest_bb)) = destination {\n                     if !crate::abi::can_return_to_ssa_var(fx, func, args) {\n                         not_ssa(&mut flag_map, dest_place.local)"}, {"sha": "7583fc424071e251cb158c390265c294bbe30836", "filename": "src/archive.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -12,10 +12,7 @@ use object::{Object, ObjectSymbol, SymbolKind};\n \n #[derive(Debug)]\n enum ArchiveEntry {\n-    FromArchive {\n-        archive_index: usize,\n-        entry_index: usize,\n-    },\n+    FromArchive { archive_index: usize, entry_index: usize },\n     File(PathBuf),\n }\n \n@@ -45,10 +42,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 let entry = entry.unwrap();\n                 entries.push((\n                     String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n-                    ArchiveEntry::FromArchive {\n-                        archive_index: 0,\n-                        entry_index: i,\n-                    },\n+                    ArchiveEntry::FromArchive { archive_index: 0, entry_index: i },\n                 ));\n                 i += 1;\n             }\n@@ -93,14 +87,9 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n     fn add_native_library(&mut self, name: rustc_span::symbol::Symbol) {\n         let location = find_library(name, &self.lib_search_paths, self.sess);\n-        self.add_archive(location.clone(), |_| false)\n-            .unwrap_or_else(|e| {\n-                panic!(\n-                    \"failed to add native library {}: {}\",\n-                    location.to_string_lossy(),\n-                    e\n-                );\n-            });\n+        self.add_archive(location.clone(), |_| false).unwrap_or_else(|e| {\n+            panic!(\"failed to add native library {}: {}\", location.to_string_lossy(), e);\n+        });\n     }\n \n     fn add_rlib(\n@@ -152,10 +141,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             // FIXME only read the symbol table of the object files to avoid having to keep all\n             // object files in memory at once, or read them twice.\n             let data = match entry {\n-                ArchiveEntry::FromArchive {\n-                    archive_index,\n-                    entry_index,\n-                } => {\n+                ArchiveEntry::FromArchive { archive_index, entry_index } => {\n                     // FIXME read symbols from symtab\n                     use std::io::Read;\n                     let (ref _src_archive_path, ref mut src_archive) =\n@@ -221,10 +207,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                             err\n                         ));\n                     }),\n-                    entries\n-                        .iter()\n-                        .map(|(name, _)| name.as_bytes().to_vec())\n-                        .collect(),\n+                    entries.iter().map(|(name, _)| name.as_bytes().to_vec()).collect(),\n                     ar::GnuSymbolTableFormat::Size32,\n                     symbol_table,\n                 )\n@@ -267,8 +250,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 .expect(\"Couldn't run ranlib\");\n \n             if !status.success() {\n-                self.sess\n-                    .fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n+                self.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n             }\n         }\n     }\n@@ -288,13 +270,8 @@ impl<'a> ArArchiveBuilder<'a> {\n             let file_name = String::from_utf8(entry.header().identifier().to_vec())\n                 .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n-                self.entries.push((\n-                    file_name,\n-                    ArchiveEntry::FromArchive {\n-                        archive_index,\n-                        entry_index: i,\n-                    },\n-                ));\n+                self.entries\n+                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n             }\n             i += 1;\n         }"}, {"sha": "eb7927fc4adebdbd16cf8742b6b8709d3076361e", "filename": "src/backend.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbackend.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -22,9 +22,7 @@ pub(crate) trait WriteMetadata {\n \n impl WriteMetadata for object::write::Object {\n     fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>, _is_like_osx: bool) {\n-        let segment = self\n-            .segment_name(object::write::StandardSegment::Data)\n-            .to_vec();\n+        let segment = self.segment_name(object::write::StandardSegment::Data).to_vec();\n         let section_id = self.add_section(segment, b\".rustc\".to_vec(), object::SectionKind::Data);\n         let offset = self.append_section_data(section_id, &data, 1);\n         // For MachO and probably PE this is necessary to prevent the linker from throwing away the\n@@ -74,11 +72,7 @@ impl WriteDebugInfo for ObjectProduct {\n         let section_id = self.object.add_section(\n             segment,\n             name,\n-            if id == SectionId::EhFrame {\n-                SectionKind::ReadOnlyData\n-            } else {\n-                SectionKind::Debug\n-            },\n+            if id == SectionId::EhFrame { SectionKind::ReadOnlyData } else { SectionKind::Debug },\n         );\n         self.object\n             .section_mut(section_id)\n@@ -132,10 +126,9 @@ pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object\n         target_lexicon::Architecture::X86_64 => object::Architecture::X86_64,\n         target_lexicon::Architecture::Arm(_) => object::Architecture::Arm,\n         target_lexicon::Architecture::Aarch64(_) => object::Architecture::Aarch64,\n-        architecture => sess.fatal(&format!(\n-            \"target architecture {:?} is unsupported\",\n-            architecture,\n-        )),\n+        architecture => {\n+            sess.fatal(&format!(\"target architecture {:?} is unsupported\", architecture,))\n+        }\n     };\n     let endian = match triple.endianness().unwrap() {\n         target_lexicon::Endianness::Little => object::Endianness::Little,"}, {"sha": "0a7734d6a0443e6171fa6651b63d79c9f0fec7cd", "filename": "src/base.rs", "status": "modified", "additions": 48, "deletions": 118, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -38,9 +38,8 @@ pub(crate) fn codegen_fn<'tcx>(\n \n     // Predefine blocks\n     let start_block = bcx.create_block();\n-    let block_map: IndexVec<BasicBlock, Block> = (0..mir.basic_blocks().len())\n-        .map(|_| bcx.create_block())\n-        .collect();\n+    let block_map: IndexVec<BasicBlock, Block> =\n+        (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n     let pointer_type = cx.module.target_config().pointer_type();\n@@ -68,27 +67,23 @@ pub(crate) fn codegen_fn<'tcx>(\n         inline_asm_index: 0,\n     };\n \n-    let arg_uninhabited = fx.mir.args_iter().any(|arg| {\n-        fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty))\n-            .abi\n-            .is_uninhabited()\n-    });\n+    let arg_uninhabited = fx\n+        .mir\n+        .args_iter()\n+        .any(|arg| fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n \n     if !crate::constant::check_constants(&mut fx) {\n-        fx.bcx\n-            .append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n         fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n         crate::trap::trap_unreachable(&mut fx, \"compilation should have been aborted\");\n     } else if arg_uninhabited {\n-        fx.bcx\n-            .append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n         fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n         crate::trap::trap_unreachable(&mut fx, \"function has uninhabited argument\");\n     } else {\n         tcx.sess.time(\"codegen clif ir\", || {\n-            tcx.sess.time(\"codegen prelude\", || {\n-                crate::abi::codegen_fn_prelude(&mut fx, start_block)\n-            });\n+            tcx.sess\n+                .time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block));\n             codegen_fn_content(&mut fx);\n         });\n     }\n@@ -136,11 +131,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n         module\n-            .define_function(\n-                func_id,\n-                context,\n-                &mut cranelift_codegen::binemit::NullTrapSink {},\n-            )\n+            .define_function(func_id, context, &mut cranelift_codegen::binemit::NullTrapSink {})\n             .unwrap()\n     });\n \n@@ -202,8 +193,7 @@ pub(crate) fn verify_func(\n                     Some(Box::new(writer)),\n                     err,\n                 );\n-                tcx.sess\n-                    .fatal(&format!(\"cranelift verify error:\\n{}\", pretty_error));\n+                tcx.sess.fatal(&format!(\"cranelift verify error:\\n{}\", pretty_error));\n             }\n         }\n     });\n@@ -232,11 +222,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n         #[cfg(debug_assertions)]\n         {\n             let mut terminator_head = \"\\n\".to_string();\n-            bb_data\n-                .terminator()\n-                .kind\n-                .fmt_head(&mut terminator_head)\n-                .unwrap();\n+            bb_data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n             let inst = fx.bcx.func.layout.last_inst(block).unwrap();\n             fx.add_comment(inst, terminator_head);\n         }\n@@ -268,13 +254,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n             TerminatorKind::Return => {\n                 crate::abi::codegen_return(fx);\n             }\n-            TerminatorKind::Assert {\n-                cond,\n-                expected,\n-                msg,\n-                target,\n-                cleanup: _,\n-            } => {\n+            TerminatorKind::Assert { cond, expected, msg, target, cleanup: _ } => {\n                 if !fx.tcx.sess.overflow_checks() {\n                     if let mir::AssertKind::OverflowNeg(_) = *msg {\n                         let target = fx.get_block(*target);\n@@ -320,11 +300,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                 }\n             }\n \n-            TerminatorKind::SwitchInt {\n-                discr,\n-                switch_ty,\n-                targets,\n-            } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty, targets } => {\n                 let discr = codegen_operand(fx, discr).load_scalar(fx);\n \n                 let use_bool_opt = switch_ty.kind() == fx.tcx.types.bool.kind()\n@@ -434,11 +410,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n             | TerminatorKind::GeneratorDrop => {\n                 bug!(\"shouldn't exist at codegen {:?}\", bb_data.terminator());\n             }\n-            TerminatorKind::Drop {\n-                place,\n-                target,\n-                unwind: _,\n-            } => {\n+            TerminatorKind::Drop { place, target, unwind: _ } => {\n                 let drop_place = codegen_place(fx, *place);\n                 crate::abi::codegen_drop(fx, bb_data.terminator().source_info.span, drop_place);\n \n@@ -471,10 +443,7 @@ fn codegen_stmt<'tcx>(\n     }\n \n     match &stmt.kind {\n-        StatementKind::SetDiscriminant {\n-            place,\n-            variant_index,\n-        } => {\n+        StatementKind::SetDiscriminant { place, variant_index } => {\n             let place = codegen_place(fx, **place);\n             crate::discriminant::codegen_set_discriminant(fx, place, *variant_index);\n         }\n@@ -597,14 +566,9 @@ fn codegen_stmt<'tcx>(\n \n                     fn is_fat_ptr<'tcx>(fx: &FunctionCx<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n                         ty.builtin_deref(true)\n-                            .map(\n-                                |ty::TypeAndMut {\n-                                     ty: pointee_ty,\n-                                     mutbl: _,\n-                                 }| {\n-                                    has_ptr_meta(fx.tcx, pointee_ty)\n-                                },\n-                            )\n+                            .map(|ty::TypeAndMut { ty: pointee_ty, mutbl: _ }| {\n+                                has_ptr_meta(fx.tcx, pointee_ty)\n+                            })\n                             .unwrap_or(false)\n                     }\n \n@@ -700,8 +664,7 @@ fn codegen_stmt<'tcx>(\n                         // FIXME use emit_small_memset where possible\n                         let addr = lval.to_ptr().get_addr(fx);\n                         let val = operand.load_scalar(fx);\n-                        fx.bcx\n-                            .call_memset(fx.cx.module.target_config(), addr, val, times);\n+                        fx.bcx.call_memset(fx.cx.module.target_config(), addr, val, times);\n                     } else {\n                         let loop_block = fx.bcx.create_block();\n                         let loop_block2 = fx.bcx.create_block();\n@@ -736,36 +699,31 @@ fn codegen_stmt<'tcx>(\n                     let content_ty = fx.monomorphize(content_ty);\n                     let layout = fx.layout_of(content_ty);\n                     let llsize = fx.bcx.ins().iconst(usize_type, layout.size.bytes() as i64);\n-                    let llalign = fx\n-                        .bcx\n-                        .ins()\n-                        .iconst(usize_type, layout.align.abi.bytes() as i64);\n+                    let llalign = fx.bcx.ins().iconst(usize_type, layout.align.abi.bytes() as i64);\n                     let box_layout = fx.layout_of(fx.tcx.mk_box(content_ty));\n \n                     // Allocate space:\n-                    let def_id = match fx\n-                        .tcx\n-                        .lang_items()\n-                        .require(rustc_hir::LangItem::ExchangeMalloc)\n-                    {\n-                        Ok(id) => id,\n-                        Err(s) => {\n-                            fx.tcx\n-                                .sess\n-                                .fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n-                        }\n-                    };\n+                    let def_id =\n+                        match fx.tcx.lang_items().require(rustc_hir::LangItem::ExchangeMalloc) {\n+                            Ok(id) => id,\n+                            Err(s) => {\n+                                fx.tcx\n+                                    .sess\n+                                    .fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n+                            }\n+                        };\n                     let instance = ty::Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n                     let func_ref = fx.get_function_ref(instance);\n                     let call = fx.bcx.ins().call(func_ref, &[llsize, llalign]);\n                     let ptr = fx.bcx.inst_results(call)[0];\n                     lval.write_cvalue(fx, CValue::by_val(ptr, box_layout));\n                 }\n                 Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n-                    assert!(lval\n-                        .layout()\n-                        .ty\n-                        .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all()));\n+                    assert!(\n+                        lval.layout()\n+                            .ty\n+                            .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all())\n+                    );\n                     let ty_size = fx.layout_of(fx.monomorphize(ty)).size.bytes();\n                     let val =\n                         CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), ty_size.into());\n@@ -793,11 +751,7 @@ fn codegen_stmt<'tcx>(\n \n         StatementKind::LlvmInlineAsm(asm) => {\n             use rustc_span::symbol::Symbol;\n-            let LlvmInlineAsm {\n-                asm,\n-                outputs,\n-                inputs,\n-            } = &**asm;\n+            let LlvmInlineAsm { asm, outputs, inputs } = &**asm;\n             let rustc_hir::LlvmInlineAsmInner {\n                 asm: asm_code,         // Name\n                 outputs: output_names, // Vec<LlvmInlineAsmOutput>\n@@ -813,15 +767,9 @@ fn codegen_stmt<'tcx>(\n                     // Black box\n                 }\n                 \"mov %rbx, %rsi\\n                  cpuid\\n                  xchg %rbx, %rsi\" => {\n-                    assert_eq!(\n-                        input_names,\n-                        &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]\n-                    );\n+                    assert_eq!(input_names, &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]);\n                     assert_eq!(output_names.len(), 4);\n-                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"])\n-                        .iter()\n-                        .enumerate()\n-                    {\n+                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"]).iter().enumerate() {\n                         assert_eq!(&output_names[i].constraint.as_str(), c);\n                         assert!(!output_names[i].is_rw);\n                         assert!(!output_names[i].is_indirect);\n@@ -867,12 +815,7 @@ fn codegen_stmt<'tcx>(\n                     crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n                 }\n                 // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-                _ if fx\n-                    .tcx\n-                    .symbol_name(fx.instance)\n-                    .name\n-                    .starts_with(\"___chkstk\") =>\n-                {\n+                _ if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") => {\n                     crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n                 }\n                 _ if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" => {\n@@ -895,15 +838,12 @@ fn codegen_stmt<'tcx>(\n fn codegen_array_len<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, place: CPlace<'tcx>) -> Value {\n     match *place.layout().ty.kind() {\n         ty::Array(_elem_ty, len) => {\n-            let len = fx\n-                .monomorphize(len)\n-                .eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64;\n+            let len = fx.monomorphize(len).eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64;\n             fx.bcx.ins().iconst(fx.pointer_type, len)\n         }\n-        ty::Slice(_elem_ty) => place\n-            .to_ptr_maybe_unsized()\n-            .1\n-            .expect(\"Length metadata for slice place\"),\n+        ty::Slice(_elem_ty) => {\n+            place.to_ptr_maybe_unsized().1.expect(\"Length metadata for slice place\")\n+        }\n         _ => bug!(\"Rvalue::Len({:?})\", place),\n     }\n }\n@@ -926,11 +866,7 @@ pub(crate) fn codegen_place<'tcx>(\n                 let index = fx.get_local_place(local).to_cvalue(fx).load_scalar(fx);\n                 cplace = cplace.place_index(fx, index);\n             }\n-            PlaceElem::ConstantIndex {\n-                offset,\n-                min_length: _,\n-                from_end,\n-            } => {\n+            PlaceElem::ConstantIndex { offset, min_length: _, from_end } => {\n                 let offset: u64 = offset;\n                 let index = if !from_end {\n                     fx.bcx.ins().iconst(fx.pointer_type, offset as i64)\n@@ -997,10 +933,7 @@ pub(crate) fn codegen_panic<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, msg_str: &s\n     let location = fx.get_caller_location(span).load_scalar(fx);\n \n     let msg_ptr = fx.anonymous_str(\"assert\", msg_str);\n-    let msg_len = fx\n-        .bcx\n-        .ins()\n-        .iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n+    let msg_len = fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n     let args = [msg_ptr, msg_len, location];\n \n     codegen_panic_inner(fx, rustc_hir::LangItem::Panic, &args, span);\n@@ -1012,11 +945,8 @@ pub(crate) fn codegen_panic_inner<'tcx>(\n     args: &[Value],\n     span: Span,\n ) {\n-    let def_id = fx\n-        .tcx\n-        .lang_items()\n-        .require(lang_item)\n-        .unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n+    let def_id =\n+        fx.tcx.lang_items().require(lang_item).unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n \n     let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n     let symbol_name = fx.tcx.symbol_name(instance).name;"}, {"sha": "983839d48d2d756ab0bbf5760668eac6854d4329", "filename": "src/bin/cg_clif.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fbin%2Fcg_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fbin%2Fcg_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcg_clif.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -27,13 +27,7 @@ impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n         config.opts.cg.panic = Some(PanicStrategy::Abort);\n         config.opts.debugging_opts.panic_abort_tests = true;\n         config.opts.maybe_sysroot = Some(config.opts.maybe_sysroot.clone().unwrap_or_else(|| {\n-            std::env::current_exe()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .to_owned()\n+            std::env::current_exe().unwrap().parent().unwrap().parent().unwrap().to_owned()\n         }));\n     }\n }"}, {"sha": "e7cd5edbbf654a2888e6b0ba4965da554f37f4a1", "filename": "src/bin/cg_clif_build_sysroot.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fbin%2Fcg_clif_build_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fbin%2Fcg_clif_build_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcg_clif_build_sysroot.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -46,15 +46,8 @@ impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n \n         config.opts.cg.panic = Some(PanicStrategy::Abort);\n         config.opts.debugging_opts.panic_abort_tests = true;\n-        config.opts.maybe_sysroot = Some(\n-            std::env::current_exe()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .to_owned(),\n-        );\n+        config.opts.maybe_sysroot =\n+            Some(std::env::current_exe().unwrap().parent().unwrap().parent().unwrap().to_owned());\n     }\n }\n "}, {"sha": "74c5e09f08da008decbad6a70710b106adb4b0bf", "filename": "src/cast.rs", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -40,11 +40,7 @@ pub(crate) fn clif_intcast(\n         // reduce\n         (types::I128, _) => {\n             let (lsb, _msb) = fx.bcx.ins().isplit(val);\n-            if to == types::I64 {\n-                lsb\n-            } else {\n-                fx.bcx.ins().ireduce(to, lsb)\n-            }\n+            if to == types::I64 { lsb } else { fx.bcx.ins().ireduce(to, lsb) }\n         }\n         (_, _) => fx.bcx.ins().ireduce(to, val),\n     }\n@@ -87,11 +83,7 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = if from_signed {\n-                fx.tcx.types.i128\n-            } else {\n-                fx.tcx.types.u128\n-            };\n+            let from_rust_ty = if from_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n \n             let to_rust_ty = match to_ty {\n                 types::F32 => fx.tcx.types.f32,\n@@ -100,11 +92,7 @@ pub(crate) fn clif_int_or_float_cast(\n             };\n \n             return fx\n-                .easy_call(\n-                    &name,\n-                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n-                    to_rust_ty,\n-                )\n+                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n                 .load_scalar(fx);\n         }\n \n@@ -138,18 +126,10 @@ pub(crate) fn clif_int_or_float_cast(\n                 _ => unreachable!(),\n             };\n \n-            let to_rust_ty = if to_signed {\n-                fx.tcx.types.i128\n-            } else {\n-                fx.tcx.types.u128\n-            };\n+            let to_rust_ty = if to_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n \n             return fx\n-                .easy_call(\n-                    &name,\n-                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n-                    to_rust_ty,\n-                )\n+                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n                 .load_scalar(fx);\n         }\n "}, {"sha": "ae75e6508cb0bac04150342c238c9453221e85a4", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -31,11 +31,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n         }\n         BinOp::Add | BinOp::Sub if !checked => None,\n         BinOp::Mul if !checked => {\n-            let val_ty = if is_signed {\n-                fx.tcx.types.i128\n-            } else {\n-                fx.tcx.types.u128\n-            };\n+            let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n             Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n         }\n         BinOp::Add | BinOp::Sub | BinOp::Mul => {\n@@ -47,11 +43,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 AbiParam::new(types::I128),\n                 AbiParam::new(types::I128),\n             ];\n-            let args = [\n-                out_place.to_ptr().get_addr(fx),\n-                lhs.load_scalar(fx),\n-                rhs.load_scalar(fx),\n-            ];\n+            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Add, false) => \"__rust_u128_addo\",\n                 (BinOp::Add, true) => \"__rust_i128_addo\","}, {"sha": "6a4a6744a5cf7bc469c1f01f00437f9b38cdad37", "filename": "src/common.rs", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -54,11 +54,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n             FloatTy::F64 => types::F64,\n         },\n         ty::FnPtr(_) => pointer_ty(tcx),\n-        ty::RawPtr(TypeAndMut {\n-            ty: pointee_ty,\n-            mutbl: _,\n-        })\n-        | ty::Ref(_, pointee_ty, _) => {\n+        ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, pointee_ty) {\n                 return None;\n             } else {\n@@ -97,11 +93,7 @@ fn clif_pair_type_from_ty<'tcx>(\n             }\n             (a, b)\n         }\n-        ty::RawPtr(TypeAndMut {\n-            ty: pointee_ty,\n-            mutbl: _,\n-        })\n-        | ty::Ref(_, pointee_ty, _) => {\n+        ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, pointee_ty) {\n                 (pointer_ty(tcx), pointer_ty(tcx))\n             } else {\n@@ -114,15 +106,8 @@ fn clif_pair_type_from_ty<'tcx>(\n \n /// Is a pointer to this type a fat ptr?\n pub(crate) fn has_ptr_meta<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    let ptr_ty = tcx.mk_ptr(TypeAndMut {\n-        ty,\n-        mutbl: rustc_hir::Mutability::Not,\n-    });\n-    match &tcx\n-        .layout_of(ParamEnv::reveal_all().and(ptr_ty))\n-        .unwrap()\n-        .abi\n-    {\n+    let ptr_ty = tcx.mk_ptr(TypeAndMut { ty, mutbl: rustc_hir::Mutability::Not });\n+    match &tcx.layout_of(ParamEnv::reveal_all().and(ptr_ty)).unwrap().abi {\n         Abi::Scalar(_) => false,\n         Abi::ScalarPair(_, _) => true,\n         abi => unreachable!(\"Abi of ptr to {:?} is {:?}???\", ty, abi),\n@@ -369,12 +354,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let msg_id = self\n             .cx\n             .module\n-            .declare_data(\n-                &format!(\"__{}_{:08x}\", prefix, msg_hash),\n-                Linkage::Local,\n-                false,\n-                false,\n-            )\n+            .declare_data(&format!(\"__{}_{:08x}\", prefix, msg_hash), Linkage::Local, false, false)\n             .unwrap();\n \n         // Ignore DuplicateDefinition error, as the data will be the same\n@@ -397,15 +377,13 @@ impl<'tcx> LayoutOf for RevealAllLayoutCx<'tcx> {\n \n     fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n         assert!(!ty.still_further_specializable());\n-        self.0\n-            .layout_of(ParamEnv::reveal_all().and(&ty))\n-            .unwrap_or_else(|e| {\n-                if let layout::LayoutError::SizeOverflow(_) = e {\n-                    self.0.sess.fatal(&e.to_string())\n-                } else {\n-                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n-            })\n+        self.0.layout_of(ParamEnv::reveal_all().and(&ty)).unwrap_or_else(|e| {\n+            if let layout::LayoutError::SizeOverflow(_) = e {\n+                self.0.sess.fatal(&e.to_string())\n+            } else {\n+                bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+            }\n+        })\n     }\n }\n "}, {"sha": "b0639cf9e15fe70839956ee2e18dbcdea2120d6f", "filename": "src/constant.rs", "status": "modified", "additions": 19, "deletions": 52, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -44,15 +44,12 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n             ConstKind::Value(_) => {}\n             ConstKind::Unevaluated(def, ref substs, promoted) => {\n                 if let Err(err) =\n-                    fx.tcx\n-                        .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n+                    fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n                 {\n                     all_constants_ok = false;\n                     match err {\n                         ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted => {\n-                            fx.tcx\n-                                .sess\n-                                .span_err(constant.span, \"erroneous constant encountered\");\n+                            fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n                         }\n                         ErrorHandled::TooGeneric => {\n                             span_bug!(\n@@ -131,16 +128,10 @@ pub(crate) fn codegen_constant<'tcx>(\n             .to_cvalue(fx);\n         }\n         ConstKind::Unevaluated(def, ref substs, promoted) => {\n-            match fx\n-                .tcx\n-                .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n-            {\n+            match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None) {\n                 Ok(const_val) => const_val,\n                 Err(_) => {\n-                    span_bug!(\n-                        constant.span,\n-                        \"erroneous constant not captured by required_consts\"\n-                    );\n+                    span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n                 }\n             }\n         }\n@@ -171,9 +162,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n             if fx.clif_type(layout.ty).is_none() {\n                 let (size, align) = (layout.size, layout.align.pref);\n                 let mut alloc = Allocation::from_bytes(\n-                    std::iter::repeat(0)\n-                        .take(size.bytes_usize())\n-                        .collect::<Vec<u8>>(),\n+                    std::iter::repeat(0).take(size.bytes_usize()).collect::<Vec<u8>>(),\n                     align,\n                 );\n                 let ptr = Pointer::new(AllocId(!0), Size::ZERO); // The alloc id is never used\n@@ -216,9 +205,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n                     };\n                     let val = if ptr.offset.bytes() != 0 {\n-                        fx.bcx\n-                            .ins()\n-                            .iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap())\n+                        fx.bcx.ins().iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap())\n                     } else {\n                         base_addr\n                     };\n@@ -235,10 +222,10 @@ pub(crate) fn codegen_const_value<'tcx>(\n             let ptr = pointer_for_allocation(fx, data)\n                 .offset_i64(fx, i64::try_from(start).unwrap())\n                 .get_addr(fx);\n-            let len = fx.bcx.ins().iconst(\n-                fx.pointer_type,\n-                i64::try_from(end.checked_sub(start).unwrap()).unwrap(),\n-            );\n+            let len = fx\n+                .bcx\n+                .ins()\n+                .iconst(fx.pointer_type, i64::try_from(end.checked_sub(start).unwrap()).unwrap());\n             CValue::by_val_pair(ptr, len, layout)\n         }\n     }\n@@ -299,12 +286,7 @@ fn data_id_for_static(\n     } else {\n         !ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n     };\n-    let align = tcx\n-        .layout_of(ParamEnv::reveal_all().and(ty))\n-        .unwrap()\n-        .align\n-        .pref\n-        .bytes();\n+    let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n \n     let attrs = tcx.codegen_fn_attrs(def_id);\n \n@@ -327,17 +309,11 @@ fn data_id_for_static(\n         // zero.\n \n         let ref_name = format!(\"_rust_extern_with_linkage_{}\", symbol_name);\n-        let ref_data_id = module\n-            .declare_data(&ref_name, Linkage::Local, false, false)\n-            .unwrap();\n+        let ref_data_id = module.declare_data(&ref_name, Linkage::Local, false, false).unwrap();\n         let mut data_ctx = DataContext::new();\n         data_ctx.set_align(align);\n         let data = module.declare_data_in_data(data_id, &mut data_ctx);\n-        data_ctx.define(\n-            std::iter::repeat(0)\n-                .take(pointer_ty(tcx).bytes() as usize)\n-                .collect(),\n-        );\n+        data_ctx.define(std::iter::repeat(0).take(pointer_ty(tcx).bytes() as usize).collect());\n         data_ctx.write_data_addr(0, data, 0);\n         match module.define_data(ref_data_id, &data_ctx) {\n             // Every time the static is referenced there will be another definition of this global,\n@@ -366,10 +342,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n             TodoItem::Static(def_id) => {\n                 //println!(\"static {:?}\", def_id);\n \n-                let section_name = tcx\n-                    .codegen_fn_attrs(def_id)\n-                    .link_section\n-                    .map(|s| s.as_str());\n+                let section_name = tcx.codegen_fn_attrs(def_id).link_section.map(|s| s.as_str());\n \n                 let alloc = tcx.eval_static_initializer(def_id).unwrap();\n \n@@ -391,9 +364,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n             data_ctx.set_segment_section(\"\", &*section_name);\n         }\n \n-        let bytes = alloc\n-            .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n-            .to_vec();\n+        let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()).to_vec();\n         data_ctx.define(bytes.into_boxed_slice());\n \n         for &(offset, (_tag, reloc)) in alloc.relocations().iter() {\n@@ -421,10 +392,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     data_id_for_alloc_id(module, reloc, target_alloc.mutability)\n                 }\n                 GlobalAlloc::Static(def_id) => {\n-                    if tcx\n-                        .codegen_fn_attrs(def_id)\n-                        .flags\n-                        .contains(CodegenFnAttrFlags::THREAD_LOCAL)\n+                    if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n                     {\n                         tcx.sess.fatal(&format!(\n                             \"Allocation {:?} contains reference to TLS value {:?}\",\n@@ -457,9 +425,8 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n ) -> Option<&'tcx Const<'tcx>> {\n     match operand {\n         Operand::Copy(_) | Operand::Move(_) => None,\n-        Operand::Constant(const_) => Some(\n-            fx.monomorphize(const_.literal)\n-                .eval(fx.tcx, ParamEnv::reveal_all()),\n-        ),\n+        Operand::Constant(const_) => {\n+            Some(fx.monomorphize(const_.literal).eval(fx.tcx, ParamEnv::reveal_all()))\n+        }\n     }\n }"}, {"sha": "6018eefcd42fb4ae4b196729bed6ecbe19d33dc8", "filename": "src/debuginfo/emit.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Femit.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -14,10 +14,7 @@ impl DebugContext<'_> {\n         let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n         let root = self.dwarf.unit.root();\n         let root = self.dwarf.unit.get_mut(root);\n-        root.set(\n-            gimli::DW_AT_ranges,\n-            AttributeValue::RangeListRef(unit_range_list_id),\n-        );\n+        root.set(gimli::DW_AT_ranges, AttributeValue::RangeListRef(unit_range_list_id));\n \n         let mut sections = Sections::new(WriterRelocate::new(self.endian));\n         self.dwarf.write(&mut sections).unwrap();\n@@ -66,10 +63,7 @@ pub(super) struct WriterRelocate {\n \n impl WriterRelocate {\n     pub(super) fn new(endian: RunTimeEndian) -> Self {\n-        WriterRelocate {\n-            relocs: Vec::new(),\n-            writer: EndianVec::new(endian),\n-        }\n+        WriterRelocate { relocs: Vec::new(), writer: EndianVec::new(endian) }\n     }\n \n     /// Perform the collected relocations to be usable for JIT usage.\n@@ -85,9 +79,7 @@ impl WriterRelocate {\n                         cranelift_module::FuncId::from_u32(sym.try_into().unwrap()),\n                     );\n                     let val = (addr as u64 as i64 + reloc.addend) as u64;\n-                    self.writer\n-                        .write_udata_at(reloc.offset as usize, val, reloc.size)\n-                        .unwrap();\n+                    self.writer.write_udata_at(reloc.offset as usize, val, reloc.size).unwrap();\n                 }\n             }\n         }"}, {"sha": "30ed356c7627f65b9ec6da55b3ca4a8a6094997b", "filename": "src/debuginfo/line_info.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fline_info.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -53,11 +53,7 @@ pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     if hash.kind == SourceFileHashAlgorithm::Md5 {\n         let mut buf = [0u8; MD5_LEN];\n         buf.copy_from_slice(hash.hash_bytes());\n-        Some(FileInfo {\n-            timestamp: 0,\n-            size: 0,\n-            md5: buf,\n-        })\n+        Some(FileInfo { timestamp: 0, size: 0, md5: buf })\n     } else {\n         None\n     }\n@@ -112,19 +108,10 @@ impl<'tcx> DebugContext<'tcx> {\n \n         let entry = self.dwarf.unit.get_mut(entry_id);\n \n-        entry.set(\n-            gimli::DW_AT_decl_file,\n-            AttributeValue::FileIndex(Some(file_id)),\n-        );\n-        entry.set(\n-            gimli::DW_AT_decl_line,\n-            AttributeValue::Udata(loc.line as u64),\n-        );\n+        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n+        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(loc.line as u64));\n         // FIXME: probably omit this\n-        entry.set(\n-            gimli::DW_AT_decl_column,\n-            AttributeValue::Udata(loc.col.to_usize() as u64),\n-        );\n+        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(loc.col.to_usize() as u64));\n     }\n \n     pub(super) fn create_debug_lines(\n@@ -223,10 +210,7 @@ impl<'tcx> DebugContext<'tcx> {\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n-        entry.set(\n-            gimli::DW_AT_high_pc,\n-            AttributeValue::Udata(u64::from(func_end)),\n-        );\n+        entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(func_end)));\n \n         self.emit_location(entry_id, function_span);\n "}, {"sha": "dc8bc8d9cb74147814e27809f1e7e20457df6885", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 9, "deletions": 36, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -90,20 +90,11 @@ impl<'tcx> DebugContext<'tcx> {\n \n             let root = dwarf.unit.root();\n             let root = dwarf.unit.get_mut(root);\n-            root.set(\n-                gimli::DW_AT_producer,\n-                AttributeValue::StringRef(dwarf.strings.add(producer)),\n-            );\n-            root.set(\n-                gimli::DW_AT_language,\n-                AttributeValue::Language(gimli::DW_LANG_Rust),\n-            );\n+            root.set(gimli::DW_AT_producer, AttributeValue::StringRef(dwarf.strings.add(producer)));\n+            root.set(gimli::DW_AT_language, AttributeValue::Language(gimli::DW_LANG_Rust));\n             root.set(gimli::DW_AT_name, AttributeValue::StringRef(name));\n             root.set(gimli::DW_AT_comp_dir, AttributeValue::StringRef(comp_dir));\n-            root.set(\n-                gimli::DW_AT_low_pc,\n-                AttributeValue::Address(Address::Constant(0)),\n-            );\n+            root.set(gimli::DW_AT_low_pc, AttributeValue::Address(Address::Constant(0)));\n         }\n \n         DebugContext {\n@@ -142,10 +133,7 @@ impl<'tcx> DebugContext<'tcx> {\n             ty::Int(_) => primitive(&mut self.dwarf, gimli::DW_ATE_signed),\n             ty::Float(_) => primitive(&mut self.dwarf, gimli::DW_ATE_float),\n             ty::Ref(_, pointee_ty, _mutbl)\n-            | ty::RawPtr(ty::TypeAndMut {\n-                ty: pointee_ty,\n-                mutbl: _mutbl,\n-            }) => {\n+            | ty::RawPtr(ty::TypeAndMut { ty: pointee_ty, mutbl: _mutbl }) => {\n                 let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_pointer_type);\n \n                 // Ensure that type is inserted before recursing to avoid duplicates\n@@ -172,10 +160,7 @@ impl<'tcx> DebugContext<'tcx> {\n                     let field_offset = layout.fields.offset(field_idx);\n                     let field_layout = layout\n                         .field(\n-                            &layout::LayoutCx {\n-                                tcx: self.tcx,\n-                                param_env: ParamEnv::reveal_all(),\n-                            },\n+                            &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n                             field_idx,\n                         )\n                         .unwrap();\n@@ -204,10 +189,7 @@ impl<'tcx> DebugContext<'tcx> {\n         let type_entry = self.dwarf.unit.get_mut(type_id);\n \n         type_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        type_entry.set(\n-            gimli::DW_AT_byte_size,\n-            AttributeValue::Udata(layout.size.bytes()),\n-        );\n+        type_entry.set(gimli::DW_AT_byte_size, AttributeValue::Udata(layout.size.bytes()));\n \n         self.types.insert(ty, type_id);\n \n@@ -247,10 +229,7 @@ impl<'tcx> DebugContext<'tcx> {\n         let name_id = self.dwarf.strings.add(name);\n         // Gdb requires DW_AT_name. Otherwise the DW_TAG_subprogram is skipped.\n         entry.set(gimli::DW_AT_name, AttributeValue::StringRef(name_id));\n-        entry.set(\n-            gimli::DW_AT_linkage_name,\n-            AttributeValue::StringRef(name_id),\n-        );\n+        entry.set(gimli::DW_AT_linkage_name, AttributeValue::StringRef(name_id));\n \n         let end = self.create_debug_lines(symbol, entry_id, context, mir.span, source_info_set);\n \n@@ -287,10 +266,7 @@ impl<'tcx> DebugContext<'tcx> {\n                     context,\n                     &local_map,\n                     &value_labels_ranges,\n-                    Place {\n-                        local,\n-                        projection: ty::List::empty(),\n-                    },\n+                    Place { local, projection: ty::List::empty() },\n                 );\n \n                 let var_entry = self.dwarf.unit.get_mut(var_id);\n@@ -328,10 +304,7 @@ fn place_location<'tcx>(\n                                 symbol,\n                                 addend: i64::from(value_loc_range.start),\n                             },\n-                            end: Address::Symbol {\n-                                symbol,\n-                                addend: i64::from(value_loc_range.end),\n-                            },\n+                            end: Address::Symbol { symbol, addend: i64::from(value_loc_range.end) },\n                             data: translate_loc(\n                                 isa,\n                                 value_loc_range.loc,"}, {"sha": "357c9fe6ed83a08e19e022c259a84b1b1a23ed36", "filename": "src/debuginfo/unwind.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Funwind.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -28,11 +28,7 @@ impl<'tcx> UnwindContext<'tcx> {\n             None\n         };\n \n-        UnwindContext {\n-            tcx,\n-            frame_table,\n-            cie_id,\n-        }\n+        UnwindContext { tcx, frame_table, cie_id }\n     }\n \n     pub(crate) fn add_function(&mut self, func_id: FuncId, context: &Context, isa: &dyn TargetIsa) {\n@@ -46,10 +42,8 @@ impl<'tcx> UnwindContext<'tcx> {\n             UnwindInfo::SystemV(unwind_info) => {\n                 self.frame_table.add_fde(\n                     self.cie_id.unwrap(),\n-                    unwind_info.to_fde(Address::Symbol {\n-                        symbol: func_id.as_u32() as usize,\n-                        addend: 0,\n-                    }),\n+                    unwind_info\n+                        .to_fde(Address::Symbol { symbol: func_id.as_u32() as usize, addend: 0 }),\n                 );\n             }\n             UnwindInfo::WindowsX64(_) => {\n@@ -60,9 +54,8 @@ impl<'tcx> UnwindContext<'tcx> {\n     }\n \n     pub(crate) fn emit<P: WriteDebugInfo>(self, product: &mut P) {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n-            self.tcx,\n-        )));\n+        let mut eh_frame =\n+            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if !eh_frame.0.writer.slice().is_empty() {\n@@ -82,9 +75,8 @@ impl<'tcx> UnwindContext<'tcx> {\n         self,\n         jit_module: &cranelift_jit::JITModule,\n     ) -> Option<UnwindRegistry> {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n-            self.tcx,\n-        )));\n+        let mut eh_frame =\n+            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if eh_frame.0.writer.slice().is_empty() {\n@@ -130,10 +122,7 @@ impl<'tcx> UnwindContext<'tcx> {\n             registrations.push(ptr as usize);\n         }\n \n-        Some(UnwindRegistry {\n-            _frame_table: eh_frame,\n-            registrations,\n-        })\n+        Some(UnwindRegistry { _frame_table: eh_frame, registrations })\n     }\n }\n "}, {"sha": "3326f87f000757099e3a9940de6677609889b533", "filename": "src/discriminant.rs", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiscriminant.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -26,11 +26,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n             variants: _,\n         } => {\n             let ptr = place.place_field(fx, mir::Field::new(tag_field));\n-            let to = layout\n-                .ty\n-                .discriminant_for_variant(fx.tcx, variant_index)\n-                .unwrap()\n-                .val;\n+            let to = layout.ty.discriminant_for_variant(fx.tcx, variant_index).unwrap().val;\n             let to = if ptr.layout().abi.is_signed() {\n                 ty::ScalarInt::try_from_int(\n                     ptr.layout().size.sign_extend(to) as i128,\n@@ -46,12 +42,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n         Variants::Multiple {\n             tag: _,\n             tag_field,\n-            tag_encoding:\n-                TagEncoding::Niche {\n-                    dataful_variant,\n-                    ref niche_variants,\n-                    niche_start,\n-                },\n+            tag_encoding: TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n             variants: _,\n         } => {\n             if variant_index != dataful_variant {\n@@ -101,12 +92,9 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             };\n             return CValue::const_val(fx, dest_layout, discr_val);\n         }\n-        Variants::Multiple {\n-            tag,\n-            tag_field,\n-            tag_encoding,\n-            variants: _,\n-        } => (tag, *tag_field, tag_encoding),\n+        Variants::Multiple { tag, tag_field, tag_encoding, variants: _ } => {\n+            (tag, *tag_field, tag_encoding)\n+        }\n     };\n \n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n@@ -125,11 +113,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             let val = clif_intcast(fx, tag, cast_to, signed);\n             CValue::by_val(val, dest_layout)\n         }\n-        TagEncoding::Niche {\n-            dataful_variant,\n-            ref niche_variants,\n-            niche_start,\n-        } => {\n+        TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n             // Rebase from niche values to discriminants, and check\n             // whether the result is in range for the niche variants.\n \n@@ -146,9 +130,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 tag\n             } else {\n                 // FIXME handle niche_start > i64::MAX\n-                fx.bcx\n-                    .ins()\n-                    .iadd_imm(tag, -i64::try_from(niche_start).unwrap())\n+                fx.bcx.ins().iadd_imm(tag, -i64::try_from(niche_start).unwrap())\n             };\n             let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n             let is_niche = {\n@@ -176,15 +158,10 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 } else {\n                     clif_intcast(fx, relative_discr, cast_to, false)\n                 };\n-                fx.bcx\n-                    .ins()\n-                    .iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n+                fx.bcx.ins().iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n             };\n \n-            let dataful_variant = fx\n-                .bcx\n-                .ins()\n-                .iconst(cast_to, i64::from(dataful_variant.as_u32()));\n+            let dataful_variant = fx.bcx.ins().iconst(cast_to, i64::from(dataful_variant.as_u32()));\n             let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n             CValue::by_val(discr, dest_layout)\n         }"}, {"sha": "b87dcc41928b699b27f7e905a69f83f23299e894", "filename": "src/driver/aot.rs", "status": "modified", "additions": 14, "deletions": 50, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -46,13 +46,10 @@ fn emit_module(\n \n     unwind_context.emit(&mut product);\n \n-    let tmp_file = tcx\n-        .output_filenames(LOCAL_CRATE)\n-        .temp_path(OutputType::Object, Some(&name));\n+    let tmp_file = tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(&name));\n     let obj = product.object.write().unwrap();\n     if let Err(err) = std::fs::write(&tmp_file, obj) {\n-        tcx.sess\n-            .fatal(&format!(\"error writing object file: {}\", err));\n+        tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n     }\n \n     let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n@@ -66,13 +63,7 @@ fn emit_module(\n     };\n \n     ModuleCodegenResult(\n-        CompiledModule {\n-            name,\n-            kind,\n-            object: Some(tmp_file),\n-            dwarf_object: None,\n-            bytecode: None,\n-        },\n+        CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None },\n         work_product,\n     )\n }\n@@ -132,9 +123,7 @@ fn module_codegen(\n         let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n         match mono_item {\n             MonoItem::Fn(inst) => {\n-                cx.tcx.sess.time(\"codegen fn\", || {\n-                    crate::base::codegen_fn(&mut cx, inst, linkage)\n-                });\n+                cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst, linkage));\n             }\n             MonoItem::Static(def_id) => {\n                 crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n@@ -194,9 +183,7 @@ pub(super) fn run_aot(\n         cgus.iter()\n             .map(|cgu| {\n                 let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n-                tcx.sess\n-                    .cgu_reuse_tracker\n-                    .set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n+                tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n \n                 match cgu_reuse {\n                     _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n@@ -269,8 +256,7 @@ pub(super) fn run_aot(\n             });\n \n             if let Err(err) = std::fs::write(&tmp_file, obj) {\n-                tcx.sess\n-                    .fatal(&format!(\"error writing metadata object file: {}\", err));\n+                tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));\n             }\n \n             (metadata_cgu_name, tmp_file)\n@@ -324,8 +310,7 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n                 \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\",\n             );\n         } else {\n-            tcx.sess\n-                .fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n+            tcx.sess.fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n         }\n     }\n \n@@ -335,19 +320,12 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n     // Remove all LLVM style comments\n     let global_asm = global_asm\n         .lines()\n-        .map(|line| {\n-            if let Some(index) = line.find(\"//\") {\n-                &line[0..index]\n-            } else {\n-                line\n-            }\n-        })\n+        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n         .collect::<Vec<_>>()\n         .join(\"\\n\");\n \n-    let output_object_file = tcx\n-        .output_filenames(LOCAL_CRATE)\n-        .temp_path(OutputType::Object, Some(cgu_name));\n+    let output_object_file =\n+        tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(cgu_name));\n \n     // Assemble `global_asm`\n     let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n@@ -357,16 +335,10 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n         .stdin(Stdio::piped())\n         .spawn()\n         .expect(\"Failed to spawn `as`.\");\n-    child\n-        .stdin\n-        .take()\n-        .unwrap()\n-        .write_all(global_asm.as_bytes())\n-        .unwrap();\n+    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n     let status = child.wait().expect(\"Failed to wait for `as`.\");\n     if !status.success() {\n-        tcx.sess\n-            .fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n+        tcx.sess.fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n     }\n \n     // Link the global asm and main object file together\n@@ -410,11 +382,7 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n     }\n \n     let work_product_id = &cgu.work_product_id();\n-    if tcx\n-        .dep_graph\n-        .previous_work_product(work_product_id)\n-        .is_none()\n-    {\n+    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n         // We don't have anything cached for this CGU. This can happen\n         // if the CGU did not exist in the previous session.\n         return CguReuse::No;\n@@ -433,9 +401,5 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         cgu.name()\n     );\n \n-    if tcx.try_mark_green(&dep_node) {\n-        CguReuse::PreLto\n-    } else {\n-        CguReuse::No\n-    }\n+    if tcx.try_mark_green(&dep_node) { CguReuse::PreLto } else { CguReuse::No }\n }"}, {"sha": "245df03ffb84de600b7d127369f0e8b602ca9824", "filename": "src/driver/jit.rs", "status": "modified", "additions": 22, "deletions": 47, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -25,10 +25,8 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n \n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n-    let mut jit_builder = JITBuilder::with_isa(\n-        crate::build_isa(tcx.sess),\n-        cranelift_module::default_libcall_names(),\n-    );\n+    let mut jit_builder =\n+        JITBuilder::with_isa(crate::build_isa(tcx.sess), cranelift_module::default_libcall_names());\n     jit_builder.hotswap(matches!(backend_config.codegen_mode, CodegenMode::JitLazy));\n     jit_builder.symbols(imported_symbols);\n     let mut jit_module = JITModule::new(jit_builder);\n@@ -39,14 +37,10 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n             AbiParam::new(jit_module.target_config().pointer_type()),\n             AbiParam::new(jit_module.target_config().pointer_type()),\n         ],\n-        returns: vec![AbiParam::new(\n-            jit_module.target_config().pointer_type(), /*isize*/\n-        )],\n+        returns: vec![AbiParam::new(jit_module.target_config().pointer_type() /*isize*/)],\n         call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n     };\n-    let main_func_id = jit_module\n-        .declare_function(\"main\", Linkage::Import, &sig)\n-        .unwrap();\n+    let main_func_id = jit_module.declare_function(\"main\", Linkage::Import, &sig).unwrap();\n \n     let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n     let mono_items = cgus\n@@ -67,9 +61,9 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx.sess.time(\"codegen fn\", || {\n-                            crate::base::codegen_fn(&mut cx, inst, linkage)\n-                        });\n+                        cx.tcx\n+                            .sess\n+                            .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst, linkage));\n                     }\n                     CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n                 },\n@@ -78,8 +72,7 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n                 }\n                 MonoItem::GlobalAsm(item_id) => {\n                     let item = cx.tcx.hir().item(item_id);\n-                    tcx.sess\n-                        .span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n+                    tcx.sess.span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n                 }\n             }\n         }\n@@ -104,7 +97,9 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n \n     let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n \n-    println!(\"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\");\n+    println!(\n+        \"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\"\n+    );\n \n     let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n         unsafe { ::std::mem::transmute(finalized_main) };\n@@ -121,10 +116,7 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n     argv.push(std::ptr::null());\n \n     BACKEND_CONFIG.with(|tls_backend_config| {\n-        assert!(tls_backend_config\n-            .borrow_mut()\n-            .replace(backend_config)\n-            .is_none())\n+        assert!(tls_backend_config.borrow_mut().replace(backend_config).is_none())\n     });\n     CURRENT_MODULE\n         .with(|current_module| assert!(current_module.borrow_mut().replace(jit_module).is_none()));\n@@ -148,15 +140,12 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n \n             let name = tcx.symbol_name(instance).name.to_string();\n             let sig = crate::abi::get_function_sig(tcx, jit_module.isa().triple(), instance);\n-            let func_id = jit_module\n-                .declare_function(&name, Linkage::Export, &sig)\n-                .unwrap();\n+            let func_id = jit_module.declare_function(&name, Linkage::Export, &sig).unwrap();\n             jit_module.prepare_for_function_redefine(func_id).unwrap();\n \n             let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n-            tcx.sess.time(\"codegen fn\", || {\n-                crate::base::codegen_fn(&mut cx, instance, Linkage::Export)\n-            });\n+            tcx.sess\n+                .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, instance, Linkage::Export));\n \n             let (global_asm, _debug_context, unwind_context) = cx.finalize();\n             assert!(global_asm.is_empty());\n@@ -185,9 +174,8 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n                 let name = tcx.crate_name(cnum);\n-                let mut err = tcx\n-                    .sess\n-                    .struct_err(&format!(\"Can't load static lib {}\", name.as_str()));\n+                let mut err =\n+                    tcx.sess.struct_err(&format!(\"Can't load static lib {}\", name.as_str()));\n                 err.note(\"rustc_codegen_cranelift can only load dylibs in JIT mode.\");\n                 err.emit();\n             }\n@@ -239,10 +227,7 @@ pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'t\n \n     let name = tcx.symbol_name(inst).name.to_string();\n     let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), inst);\n-    let func_id = cx\n-        .module\n-        .declare_function(&name, Linkage::Export, &sig)\n-        .unwrap();\n+    let func_id = cx.module.declare_function(&name, Linkage::Export, &sig).unwrap();\n \n     let instance_ptr = Box::into_raw(Box::new(inst));\n \n@@ -263,28 +248,18 @@ pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'t\n     let mut builder_ctx = FunctionBuilderContext::new();\n     let mut trampoline_builder = FunctionBuilder::new(&mut trampoline, &mut builder_ctx);\n \n-    let jit_fn = cx\n-        .module\n-        .declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let jit_fn = cx.module.declare_func_in_func(jit_fn, trampoline_builder.func);\n     let sig_ref = trampoline_builder.func.import_signature(sig);\n \n     let entry_block = trampoline_builder.create_block();\n     trampoline_builder.append_block_params_for_function_params(entry_block);\n-    let fn_args = trampoline_builder\n-        .func\n-        .dfg\n-        .block_params(entry_block)\n-        .to_vec();\n+    let fn_args = trampoline_builder.func.dfg.block_params(entry_block).to_vec();\n \n     trampoline_builder.switch_to_block(entry_block);\n-    let instance_ptr = trampoline_builder\n-        .ins()\n-        .iconst(pointer_type, instance_ptr as u64 as i64);\n+    let instance_ptr = trampoline_builder.ins().iconst(pointer_type, instance_ptr as u64 as i64);\n     let jitted_fn = trampoline_builder.ins().call(jit_fn, &[instance_ptr]);\n     let jitted_fn = trampoline_builder.func.dfg.inst_results(jitted_fn)[0];\n-    let call_inst = trampoline_builder\n-        .ins()\n-        .call_indirect(sig_ref, jitted_fn, &fn_args);\n+    let call_inst = trampoline_builder.ins().call_indirect(sig_ref, jitted_fn, &fn_args);\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n "}, {"sha": "b994f28ffef5b39fe832355a3d4ac570d96b9601", "filename": "src/driver/mod.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -24,10 +24,8 @@ pub(crate) fn codegen_crate(\n     match backend_config.codegen_mode {\n         CodegenMode::Aot => aot::run_aot(tcx, backend_config, metadata, need_metadata_module),\n         CodegenMode::Jit | CodegenMode::JitLazy => {\n-            let is_executable = tcx\n-                .sess\n-                .crate_types()\n-                .contains(&rustc_session::config::CrateType::Executable);\n+            let is_executable =\n+                tcx.sess.crate_types().contains(&rustc_session::config::CrateType::Executable);\n             if !is_executable {\n                 tcx.sess.fatal(\"can't jit non-executable crate\");\n             }\n@@ -36,8 +34,7 @@ pub(crate) fn codegen_crate(\n             let _: ! = jit::run_jit(tcx, backend_config);\n \n             #[cfg(not(feature = \"jit\"))]\n-            tcx.sess\n-                .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+            tcx.sess.fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n         }\n     }\n }\n@@ -63,21 +60,12 @@ fn predefine_mono_items<'tcx>(\n }\n \n fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n-    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\")\n-        .as_ref()\n-        .map(|val| &**val)\n-        == Ok(\"1\")\n-    {\n+    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\").as_ref().map(|val| &**val) == Ok(\"1\") {\n         println!(\"[{:<30}: {}] start\", tcx.crate_name(LOCAL_CRATE), name);\n         let before = std::time::Instant::now();\n         let res = tcx.sess.time(name, f);\n         let after = std::time::Instant::now();\n-        println!(\n-            \"[{:<30}: {}] end time: {:?}\",\n-            tcx.crate_name(LOCAL_CRATE),\n-            name,\n-            after - before\n-        );\n+        println!(\"[{:<30}: {}] end time: {:?}\", tcx.crate_name(LOCAL_CRATE), name, after - before);\n         res\n     } else {\n         tcx.sess.time(name, f)"}, {"sha": "5b3df2bd382808c908a94907c90dbbc8d3737139", "filename": "src/inline_asm.rs", "status": "modified", "additions": 11, "deletions": 42, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -53,11 +53,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                     crate::base::codegen_operand(fx, value).load_scalar(fx),\n                 ));\n             }\n-            InlineAsmOperand::Out {\n-                reg,\n-                late: _,\n-                place,\n-            } => {\n+            InlineAsmOperand::Out { reg, late: _, place } => {\n                 let reg = expect_reg(reg);\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 if let Some(place) = place {\n@@ -68,12 +64,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                     ));\n                 }\n             }\n-            InlineAsmOperand::InOut {\n-                reg,\n-                late: _,\n-                ref in_value,\n-                out_place,\n-            } => {\n+            InlineAsmOperand::InOut { reg, late: _, ref in_value, out_place } => {\n                 let reg = expect_reg(reg);\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 inputs.push((\n@@ -97,11 +88,8 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n \n     let inline_asm_index = fx.inline_asm_index;\n     fx.inline_asm_index += 1;\n-    let asm_name = format!(\n-        \"{}__inline_asm_{}\",\n-        fx.tcx.symbol_name(fx.instance).name,\n-        inline_asm_index\n-    );\n+    let asm_name =\n+        format!(\"{}__inline_asm_{}\", fx.tcx.symbol_name(fx.instance).name, inline_asm_index);\n \n     let generated_asm = generate_asm_wrapper(\n         &asm_name,\n@@ -129,12 +117,7 @@ fn generate_asm_wrapper(\n     let mut generated_asm = String::new();\n     writeln!(generated_asm, \".globl {}\", asm_name).unwrap();\n     writeln!(generated_asm, \".type {},@function\", asm_name).unwrap();\n-    writeln!(\n-        generated_asm,\n-        \".section .text.{},\\\"ax\\\",@progbits\",\n-        asm_name\n-    )\n-    .unwrap();\n+    writeln!(generated_asm, \".section .text.{},\\\"ax\\\",@progbits\", asm_name).unwrap();\n     writeln!(generated_asm, \"{}:\", asm_name).unwrap();\n \n     generated_asm.push_str(\".intel_syntax noprefix\\n\");\n@@ -164,11 +147,7 @@ fn generate_asm_wrapper(\n             InlineAsmTemplatePiece::String(s) => {\n                 generated_asm.push_str(s);\n             }\n-            InlineAsmTemplatePiece::Placeholder {\n-                operand_idx: _,\n-                modifier: _,\n-                span: _,\n-            } => todo!(),\n+            InlineAsmTemplatePiece::Placeholder { operand_idx: _, modifier: _, span: _ } => todo!(),\n         }\n     }\n     generated_asm.push('\\n');\n@@ -230,28 +209,20 @@ fn call_inline_asm<'tcx>(\n             },\n         )\n         .unwrap();\n-    let inline_asm_func = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(inline_asm_func, asm_name);\n \n     for (_reg, offset, value) in inputs {\n-        fx.bcx\n-            .ins()\n-            .stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+        fx.bcx.ins().stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n     }\n \n     let stack_slot_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n     fx.bcx.ins().call(inline_asm_func, &[stack_slot_addr]);\n \n     for (_reg, offset, place) in outputs {\n         let ty = fx.clif_type(place.layout().ty).unwrap();\n-        let value = fx\n-            .bcx\n-            .ins()\n-            .stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+        let value = fx.bcx.ins().stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n         place.write_cvalue(fx, CValue::by_val(value, place.layout()));\n     }\n }\n@@ -267,8 +238,7 @@ fn save_register(generated_asm: &mut String, arch: InlineAsmArch, reg: InlineAsm\n     match arch {\n         InlineAsmArch::X86_64 => {\n             write!(generated_asm, \"    mov [rbp+0x{:x}], \", offset.bytes()).unwrap();\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n-                .unwrap();\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n             generated_asm.push('\\n');\n         }\n         _ => unimplemented!(\"save_register for {:?}\", arch),\n@@ -284,8 +254,7 @@ fn restore_register(\n     match arch {\n         InlineAsmArch::X86_64 => {\n             generated_asm.push_str(\"    mov \");\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n-                .unwrap();\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n             writeln!(generated_asm, \", [rbp+0x{:x}]\", offset.bytes()).unwrap();\n         }\n         _ => unimplemented!(\"restore_register for {:?}\", arch),"}, {"sha": "b27b0eddfbad6f6d4ad4e763fc37249dced899bc", "filename": "src/intrinsics/cpuid.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fcpuid.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -31,54 +31,28 @@ pub(crate) fn codegen_cpuid_call<'tcx>(\n \n     fx.bcx.switch_to_block(leaf_0);\n     let max_basic_leaf = fx.bcx.ins().iconst(types::I32, 1);\n-    let vend0 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n-    let vend2 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n-    let vend1 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n+    let vend0 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n+    let vend2 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n+    let vend1 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n+    fx.bcx.ins().jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n \n     fx.bcx.switch_to_block(leaf_1);\n     let cpu_signature = fx.bcx.ins().iconst(types::I32, 0);\n     let additional_information = fx.bcx.ins().iconst(types::I32, 0);\n     let ecx_features = fx.bcx.ins().iconst(types::I32, 0);\n-    let edx_features = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, 1 << 25 /* sse */ | 1 << 26 /* sse2 */);\n-    fx.bcx.ins().jump(\n-        dest,\n-        &[\n-            cpu_signature,\n-            additional_information,\n-            ecx_features,\n-            edx_features,\n-        ],\n-    );\n+    let edx_features = fx.bcx.ins().iconst(types::I32, 1 << 25 /* sse */ | 1 << 26 /* sse2 */);\n+    fx.bcx.ins().jump(dest, &[cpu_signature, additional_information, ecx_features, edx_features]);\n \n     fx.bcx.switch_to_block(leaf_8000_0000);\n     let extended_max_basic_leaf = fx.bcx.ins().iconst(types::I32, 0);\n     let zero = fx.bcx.ins().iconst(types::I32, 0);\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n+    fx.bcx.ins().jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n \n     fx.bcx.switch_to_block(leaf_8000_0001);\n     let zero = fx.bcx.ins().iconst(types::I32, 0);\n     let proc_info_ecx = fx.bcx.ins().iconst(types::I32, 0);\n     let proc_info_edx = fx.bcx.ins().iconst(types::I32, 0);\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n+    fx.bcx.ins().jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n \n     fx.bcx.switch_to_block(unsupported_leaf);\n     crate::trap::trap_unreachable("}, {"sha": "39e047a98f9eb660d25054e898ac824d959ba6ad", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -227,9 +227,8 @@ fn simd_reduce<'tcx>(\n \n     let mut res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     for lane_idx in 1..lane_count {\n-        let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n-            .load_scalar(fx);\n+        let lane =\n+            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n         res_val = f(fx, lane_layout, res_val, lane);\n     }\n     let res = CValue::by_val(res_val, lane_layout);\n@@ -248,9 +247,8 @@ fn simd_reduce_bool<'tcx>(\n     let res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     let mut res_val = fx.bcx.ins().band_imm(res_val, 1); // mask to boolean\n     for lane_idx in 1..lane_count {\n-        let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n-            .load_scalar(fx);\n+        let lane =\n+            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n         let lane = fx.bcx.ins().band_imm(lane, 1); // mask to boolean\n         res_val = f(fx, res_val, lane);\n     }"}, {"sha": "e1927ad3a69200ecc7668a60ec71886bf53e01ba", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -149,11 +149,8 @@ impl<'m, 'tcx> CodegenCx<'m, 'tcx> {\n             module.isa(),\n             matches!(backend_config.codegen_mode, CodegenMode::Aot),\n         );\n-        let debug_context = if debug_info {\n-            Some(DebugContext::new(tcx, module.isa()))\n-        } else {\n-            None\n-        };\n+        let debug_context =\n+            if debug_info { Some(DebugContext::new(tcx, module.isa())) } else { None };\n         CodegenCx {\n             tcx,\n             module,\n@@ -303,14 +300,7 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n     flags_builder.enable(\"is_pic\").unwrap();\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n     flags_builder\n-        .set(\n-            \"enable_verifier\",\n-            if cfg!(debug_assertions) {\n-                \"true\"\n-            } else {\n-                \"false\"\n-            },\n-        )\n+        .set(\"enable_verifier\", if cfg!(debug_assertions) { \"true\" } else { \"false\" })\n         .unwrap();\n \n     let tls_model = match target_triple.binary_format {"}, {"sha": "62e551b186ff7c8cb96350eb8e4977496dce9193", "filename": "src/main_shim.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -26,13 +26,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n         return;\n     }\n \n-    create_entry_fn(\n-        tcx,\n-        module,\n-        unwind_context,\n-        main_def_id,\n-        use_start_lang_item,\n-    );\n+    create_entry_fn(tcx, module, unwind_context, main_def_id, use_start_lang_item);\n \n     fn create_entry_fn(\n         tcx: TyCtxt<'_>,\n@@ -54,23 +48,17 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 AbiParam::new(m.target_config().pointer_type()),\n                 AbiParam::new(m.target_config().pointer_type()),\n             ],\n-            returns: vec![AbiParam::new(\n-                m.target_config().pointer_type(), /*isize*/\n-            )],\n+            returns: vec![AbiParam::new(m.target_config().pointer_type() /*isize*/)],\n             call_conv: CallConv::triple_default(m.isa().triple()),\n         };\n \n-        let cmain_func_id = m\n-            .declare_function(\"main\", Linkage::Export, &cmain_sig)\n-            .unwrap();\n+        let cmain_func_id = m.declare_function(\"main\", Linkage::Export, &cmain_sig).unwrap();\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n         let main_name = tcx.symbol_name(instance).name.to_string();\n         let main_sig = get_function_sig(tcx, m.isa().triple(), instance);\n-        let main_func_id = m\n-            .declare_function(&main_name, Linkage::Import, &main_sig)\n-            .unwrap();\n+        let main_func_id = m.declare_function(&main_name, Linkage::Import, &main_sig).unwrap();\n \n         let mut ctx = Context::new();\n         ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig);\n@@ -98,9 +86,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 .polymorphize(tcx);\n                 let start_func_id = import_function(tcx, m, start_instance);\n \n-                let main_val = bcx\n-                    .ins()\n-                    .func_addr(m.target_config().pointer_type(), main_func_ref);\n+                let main_val = bcx.ins().func_addr(m.target_config().pointer_type(), main_func_ref);\n \n                 let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n                 bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])"}, {"sha": "190c4f45ccafdefe6ca1f55662e57c4fddc39a3b", "filename": "src/metadata.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmetadata.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -94,9 +94,7 @@ pub(crate) fn write_metadata<P: WriteMetadata>(\n \n     assert!(kind == MetadataKind::Compressed);\n     let mut compressed = tcx.metadata_encoding_version();\n-    FrameEncoder::new(&mut compressed)\n-        .write_all(&metadata.raw_data)\n-        .unwrap();\n+    FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n \n     product.add_rustc_section(\n         rustc_middle::middle::exported_symbols::metadata_symbol_name(tcx),"}, {"sha": "da49e1c6c91dbacaa5df5900ed8abe5fa8f59a8a", "filename": "src/num.rs", "status": "modified", "additions": 9, "deletions": 40, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -93,12 +93,7 @@ pub(crate) fn codegen_binop<'tcx>(\n         ty::Uint(_) | ty::Int(_) => crate::num::codegen_int_binop(fx, bin_op, in_lhs, in_rhs),\n         ty::Float(_) => crate::num::codegen_float_binop(fx, bin_op, in_lhs, in_rhs),\n         ty::RawPtr(..) | ty::FnPtr(..) => crate::num::codegen_ptr_binop(fx, bin_op, in_lhs, in_rhs),\n-        _ => unreachable!(\n-            \"{:?}({:?}, {:?})\",\n-            bin_op,\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty\n-        ),\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n     }\n }\n \n@@ -185,12 +180,7 @@ pub(crate) fn codegen_int_binop<'tcx>(\n             }\n         }\n         // Compare binops handles by `codegen_binop`.\n-        _ => unreachable!(\n-            \"{:?}({:?}, {:?})\",\n-            bin_op,\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty\n-        ),\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n     };\n \n     CValue::by_val(val, in_lhs.layout())\n@@ -268,9 +258,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                     let rhs = fx.bcx.ins().sextend(ty.double_width().unwrap(), rhs);\n                     let val = fx.bcx.ins().imul(lhs, rhs);\n                     let has_underflow =\n-                        fx.bcx\n-                            .ins()\n-                            .icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n+                        fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n                     let has_overflow = fx.bcx.ins().icmp_imm(\n                         IntCC::SignedGreaterThan,\n                         val,\n@@ -309,10 +297,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n             let val = fx.bcx.ins().ishl(lhs, actual_shift);\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx\n-                .bcx\n-                .ins()\n-                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n         BinOp::Shr => {\n@@ -326,26 +311,15 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n             };\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx\n-                .bcx\n-                .ins()\n-                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n-        _ => bug!(\n-            \"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\",\n-            bin_op,\n-            in_lhs,\n-            in_rhs\n-        ),\n+        _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n \n     let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n \n-    let out_layout = fx.layout_of(\n-        fx.tcx\n-            .mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()),\n-    );\n+    let out_layout = fx.layout_of(fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()));\n     CValue::by_val_pair(res, has_overflow, out_layout)\n }\n \n@@ -445,9 +419,7 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n                 let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n \n                 let ptr_cmp =\n-                    fx.bcx\n-                        .ins()\n-                        .icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n+                    fx.bcx.ins().icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n                 let extra_cmp = fx.bcx.ins().icmp(\n                     bin_op_to_intcc(bin_op, false).unwrap(),\n                     lhs_extra,\n@@ -459,9 +431,6 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n             _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n         };\n \n-        CValue::by_val(\n-            fx.bcx.ins().bint(types::I8, res),\n-            fx.layout_of(fx.tcx.types.bool),\n-        )\n+        CValue::by_val(fx.bcx.ins().bint(types::I8, res), fx.layout_of(fx.tcx.types.bool))\n     }\n }"}, {"sha": "ca9ff15ec10ffee9967d95ccf086ab0e345ba1fe", "filename": "src/optimize/code_layout.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Foptimize%2Fcode_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Foptimize%2Fcode_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fcode_layout.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -15,10 +15,7 @@ pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block\n     // bytecodealliance/cranelift#1339 is implemented.\n \n     let mut block_insts = FxHashMap::default();\n-    for block in cold_blocks\n-        .keys()\n-        .filter(|&block| cold_blocks.contains(block))\n-    {\n+    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n         let insts = ctx.func.layout.block_insts(block).collect::<Vec<_>>();\n         for &inst in &insts {\n             ctx.func.layout.remove_inst(inst);\n@@ -28,10 +25,7 @@ pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block\n     }\n \n     // And then append them at the back again.\n-    for block in cold_blocks\n-        .keys()\n-        .filter(|&block| cold_blocks.contains(block))\n-    {\n+    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n         ctx.func.layout.append_block(block);\n         for inst in block_insts.remove(&block).unwrap() {\n             ctx.func.layout.append_inst(inst, block);"}, {"sha": "b95e2d72877d992f35622873a25270f624d635e0", "filename": "src/optimize/peephole.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fpeephole.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -10,10 +10,7 @@ use cranelift_frontend::FunctionBuilder;\n pub(crate) fn maybe_unwrap_bint(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n     if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n         match bcx.func.dfg[arg_inst] {\n-            InstructionData::Unary {\n-                opcode: Opcode::Bint,\n-                arg,\n-            } => arg,\n+            InstructionData::Unary { opcode: Opcode::Bint, arg } => arg,\n             _ => arg,\n         }\n     } else {\n@@ -54,12 +51,7 @@ pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -\n \n         match bcx.func.dfg[arg_inst] {\n             // This is the lowering of Rvalue::Not\n-            InstructionData::Load {\n-                opcode: Opcode::Load,\n-                arg: ptr,\n-                flags,\n-                offset,\n-            } => {\n+            InstructionData::Load { opcode: Opcode::Load, arg: ptr, flags, offset } => {\n                 // Using `load.i8 + uextend.i32` would legalize to `uload8 + ireduce.i8 +\n                 // uextend.i32`. Just `uload8` is much faster.\n                 match bcx.func.dfg.ctrl_typevar(arg_inst) {\n@@ -95,20 +87,14 @@ pub(crate) fn maybe_known_branch_taken(\n     };\n \n     match bcx.func.dfg[arg_inst] {\n-        InstructionData::UnaryBool {\n-            opcode: Opcode::Bconst,\n-            imm,\n-        } => {\n+        InstructionData::UnaryBool { opcode: Opcode::Bconst, imm } => {\n             if test_zero {\n                 Some(!imm)\n             } else {\n                 Some(imm)\n             }\n         }\n-        InstructionData::UnaryImm {\n-            opcode: Opcode::Iconst,\n-            imm,\n-        } => {\n+        InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => {\n             if test_zero {\n                 Some(imm.bits() == 0)\n             } else {"}, {"sha": "d111f37f5e4552a3d582636e73026b07f31364ac", "filename": "src/optimize/stack2reg.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fstack2reg.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -175,16 +175,14 @@ impl<'a> OptimizeContext<'a> {\n             }\n         }\n \n-        OptimizeContext {\n-            ctx,\n-            stack_slot_usage_map,\n-        }\n+        OptimizeContext { ctx, stack_slot_usage_map }\n     }\n }\n \n pub(super) fn optimize_function(\n     ctx: &mut Context,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] clif_comments: &mut crate::pretty_clif::CommentWriter,\n+    #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n+    clif_comments: &mut crate::pretty_clif::CommentWriter,\n ) {\n     combine_stack_addr_with_load_store(&mut ctx.func);\n \n@@ -296,12 +294,7 @@ fn combine_stack_addr_with_load_store(func: &mut Function) {\n     while let Some(_block) = cursor.next_block() {\n         while let Some(inst) = cursor.next_inst() {\n             match cursor.func.dfg[inst] {\n-                InstructionData::Load {\n-                    opcode: Opcode::Load,\n-                    arg: addr,\n-                    flags: _,\n-                    offset,\n-                } => {\n+                InstructionData::Load { opcode: Opcode::Load, arg: addr, flags: _, offset } => {\n                     if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n                         || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n                     {\n@@ -391,20 +384,14 @@ fn remove_unused_stack_addr_and_stack_load(opt_ctx: &mut OptimizeContext<'_>) {\n         stack_slot_users\n             .stack_addr\n             .drain_filter(|inst| {\n-                stack_addr_load_insts_users\n-                    .get(inst)\n-                    .map(|users| users.is_empty())\n-                    .unwrap_or(true)\n+                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n             })\n             .for_each(|inst| StackSlotUsage::remove_unused_stack_addr(&mut func, inst));\n \n         stack_slot_users\n             .stack_load\n             .drain_filter(|inst| {\n-                stack_addr_load_insts_users\n-                    .get(inst)\n-                    .map(|users| users.is_empty())\n-                    .unwrap_or(true)\n+                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n             })\n             .for_each(|inst| StackSlotUsage::remove_unused_load(&mut func, inst));\n     }\n@@ -415,11 +402,8 @@ fn try_get_stack_slot_and_offset_for_addr(\n     addr: Value,\n ) -> Option<(StackSlot, Offset32)> {\n     if let ValueDef::Result(addr_inst, 0) = func.dfg.value_def(addr) {\n-        if let InstructionData::StackLoad {\n-            opcode: Opcode::StackAddr,\n-            stack_slot,\n-            offset,\n-        } = func.dfg[addr_inst]\n+        if let InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset } =\n+            func.dfg[addr_inst]\n         {\n             return Some((stack_slot, offset));\n         }\n@@ -437,16 +421,8 @@ enum SpatialOverlap {\n fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n     fn inst_info(func: &Function, inst: Inst) -> (StackSlot, Offset32, u32) {\n         match func.dfg[inst] {\n-            InstructionData::StackLoad {\n-                opcode: Opcode::StackAddr,\n-                stack_slot,\n-                offset,\n-            }\n-            | InstructionData::StackLoad {\n-                opcode: Opcode::StackLoad,\n-                stack_slot,\n-                offset,\n-            }\n+            InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset }\n+            | InstructionData::StackLoad { opcode: Opcode::StackLoad, stack_slot, offset }\n             | InstructionData::StackStore {\n                 opcode: Opcode::StackStore,\n                 stack_slot,\n@@ -471,10 +447,7 @@ fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n     }\n \n     let src_end: i64 = src_offset.try_add_i64(i64::from(src_size)).unwrap().into();\n-    let dest_end: i64 = dest_offset\n-        .try_add_i64(i64::from(dest_size))\n-        .unwrap()\n-        .into();\n+    let dest_end: i64 = dest_offset.try_add_i64(i64::from(dest_size)).unwrap().into();\n     if src_end <= dest_offset.into() || dest_end <= src_offset.into() {\n         return SpatialOverlap::No;\n     }"}, {"sha": "88a78f3214d87b054efdb0281dde5d557009d6ee", "filename": "src/pointer.rs", "status": "modified", "additions": 17, "deletions": 48, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpointer.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -23,32 +23,20 @@ pub(crate) enum PointerBase {\n \n impl Pointer {\n     pub(crate) fn new(addr: Value) -> Self {\n-        Pointer {\n-            base: PointerBase::Addr(addr),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n     }\n \n     pub(crate) fn stack_slot(stack_slot: StackSlot) -> Self {\n-        Pointer {\n-            base: PointerBase::Stack(stack_slot),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Stack(stack_slot), offset: Offset32::new(0) }\n     }\n \n     pub(crate) fn const_addr(fx: &mut FunctionCx<'_, '_, '_>, addr: i64) -> Self {\n         let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n-        Pointer {\n-            base: PointerBase::Addr(addr),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n     }\n \n     pub(crate) fn dangling(align: Align) -> Self {\n-        Pointer {\n-            base: PointerBase::Dangling(align),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }\n \n     #[cfg(debug_assertions)]\n@@ -60,21 +48,14 @@ impl Pointer {\n         match self.base {\n             PointerBase::Addr(base_addr) => {\n                 let offset: i64 = self.offset.into();\n-                if offset == 0 {\n-                    base_addr\n-                } else {\n-                    fx.bcx.ins().iadd_imm(base_addr, offset)\n-                }\n+                if offset == 0 { base_addr } else { fx.bcx.ins().iadd_imm(base_addr, offset) }\n             }\n             PointerBase::Stack(stack_slot) => {\n-                fx.bcx\n-                    .ins()\n-                    .stack_addr(fx.pointer_type, stack_slot, self.offset)\n+                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset)\n+            }\n+            PointerBase::Dangling(align) => {\n+                fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap())\n             }\n-            PointerBase::Dangling(align) => fx\n-                .bcx\n-                .ins()\n-                .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n         }\n     }\n \n@@ -84,10 +65,7 @@ impl Pointer {\n \n     pub(crate) fn offset_i64(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: i64) -> Self {\n         if let Some(new_offset) = self.offset.try_add_i64(extra_offset) {\n-            Pointer {\n-                base: self.base,\n-                offset: new_offset,\n-            }\n+            Pointer { base: self.base, offset: new_offset }\n         } else {\n             let base_offset: i64 = self.offset.into();\n             if let Some(new_offset) = base_offset.checked_add(extra_offset) {\n@@ -96,16 +74,12 @@ impl Pointer {\n                     PointerBase::Stack(stack_slot) => {\n                         fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0)\n                     }\n-                    PointerBase::Dangling(align) => fx\n-                        .bcx\n-                        .ins()\n-                        .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n+                    PointerBase::Dangling(align) => {\n+                        fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap())\n+                    }\n                 };\n                 let addr = fx.bcx.ins().iadd_imm(base_addr, new_offset);\n-                Pointer {\n-                    base: PointerBase::Addr(addr),\n-                    offset: Offset32::new(0),\n-                }\n+                Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n             } else {\n                 panic!(\n                     \"self.offset ({}) + extra_offset ({}) not representable in i64\",\n@@ -122,20 +96,15 @@ impl Pointer {\n                 offset: self.offset,\n             },\n             PointerBase::Stack(stack_slot) => {\n-                let base_addr = fx\n-                    .bcx\n-                    .ins()\n-                    .stack_addr(fx.pointer_type, stack_slot, self.offset);\n+                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset);\n                 Pointer {\n                     base: PointerBase::Addr(fx.bcx.ins().iadd(base_addr, extra_offset)),\n                     offset: Offset32::new(0),\n                 }\n             }\n             PointerBase::Dangling(align) => {\n-                let addr = fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap());\n+                let addr =\n+                    fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap());\n                 Pointer {\n                     base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n                     offset: self.offset,"}, {"sha": "9c91b92e515b1b0ffc22a06fc81a4452a488db1d", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -79,20 +79,14 @@ impl CommentWriter {\n             vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name),\n                 format!(\"instance {:?}\", instance),\n-                format!(\n-                    \"abi {:?}\",\n-                    FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])\n-                ),\n+                format!(\"abi {:?}\", FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n                 String::new(),\n             ]\n         } else {\n             vec![]\n         };\n \n-        CommentWriter {\n-            global_comments,\n-            entity_comments: FxHashMap::default(),\n-        }\n+        CommentWriter { global_comments, entity_comments: FxHashMap::default() }\n     }\n }\n \n@@ -201,10 +195,7 @@ impl FunctionCx<'_, '_, '_> {\n }\n \n pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n-    tcx.sess\n-        .opts\n-        .output_types\n-        .contains_key(&OutputType::LlvmAssembly)\n+    tcx.sess.opts.output_types.contains_key(&OutputType::LlvmAssembly)\n }\n \n pub(crate) fn write_ir_file<'tcx>(\n@@ -243,37 +234,30 @@ pub(crate) fn write_clif_file<'tcx>(\n     context: &cranelift_codegen::Context,\n     mut clif_comments: &CommentWriter,\n ) {\n-    write_ir_file(\n-        tcx,\n-        &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n-        |file| {\n-            let value_ranges = isa.map(|isa| {\n-                context\n-                    .build_value_labels_ranges(isa)\n-                    .expect(\"value location ranges\")\n-            });\n+    write_ir_file(tcx, &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix), |file| {\n+        let value_ranges =\n+            isa.map(|isa| context.build_value_labels_ranges(isa).expect(\"value location ranges\"));\n \n-            let mut clif = String::new();\n-            cranelift_codegen::write::decorate_function(\n-                &mut clif_comments,\n-                &mut clif,\n-                &context.func,\n-                &DisplayFunctionAnnotations {\n-                    isa: Some(&*crate::build_isa(tcx.sess)),\n-                    value_ranges: value_ranges.as_ref(),\n-                },\n-            )\n-            .unwrap();\n+        let mut clif = String::new();\n+        cranelift_codegen::write::decorate_function(\n+            &mut clif_comments,\n+            &mut clif,\n+            &context.func,\n+            &DisplayFunctionAnnotations {\n+                isa: Some(&*crate::build_isa(tcx.sess)),\n+                value_ranges: value_ranges.as_ref(),\n+            },\n+        )\n+        .unwrap();\n \n-            writeln!(file, \"test compile\")?;\n-            writeln!(file, \"set is_pic\")?;\n-            writeln!(file, \"set enable_simd\")?;\n-            writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n-            writeln!(file)?;\n-            file.write_all(clif.as_bytes())?;\n-            Ok(())\n-        },\n-    );\n+        writeln!(file, \"test compile\")?;\n+        writeln!(file, \"set is_pic\")?;\n+        writeln!(file, \"set enable_simd\")?;\n+        writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n+        writeln!(file)?;\n+        file.write_all(clif.as_bytes())?;\n+        Ok(())\n+    });\n }\n \n impl fmt::Debug for FunctionCx<'_, '_, '_> {"}, {"sha": "484a9b699a0aa41aa73c412610bae16e2155d456", "filename": "src/toolchain.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Ftoolchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Ftoolchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftoolchain.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -71,12 +71,9 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                 flavor,\n             )),\n             (Some(linker), None) => {\n-                let stem = linker\n-                    .file_stem()\n-                    .and_then(|stem| stem.to_str())\n-                    .unwrap_or_else(|| {\n-                        sess.fatal(\"couldn't extract file stem from specified linker\")\n-                    });\n+                let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n+                    sess.fatal(\"couldn't extract file stem from specified linker\")\n+                });\n \n                 let flavor = if stem == \"emcc\" {\n                     LinkerFlavor::Em\n@@ -105,11 +102,7 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     // linker and linker flavor specified via command line have precedence over what the target\n     // specification specifies\n-    if let Some(ret) = infer_from(\n-        sess,\n-        sess.opts.cg.linker.clone(),\n-        sess.opts.cg.linker_flavor,\n-    ) {\n+    if let Some(ret) = infer_from(sess, sess.opts.cg.linker.clone(), sess.opts.cg.linker_flavor) {\n         return ret;\n     }\n "}, {"sha": "042583cd5720fa07b7cac71d3928a302f7d3be0b", "filename": "src/unsize.rs", "status": "modified", "additions": 21, "deletions": 46, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -19,13 +19,12 @@ pub(crate) fn unsized_info<'tcx>(\n     old_info: Option<Value>,\n ) -> Value {\n     let (source, target) =\n-        fx.tcx\n-            .struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n+        fx.tcx.struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n     match (&source.kind(), &target.kind()) {\n-        (&ty::Array(_, len), &ty::Slice(_)) => fx.bcx.ins().iconst(\n-            fx.pointer_type,\n-            len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64,\n-        ),\n+        (&ty::Array(_, len), &ty::Slice(_)) => fx\n+            .bcx\n+            .ins()\n+            .iconst(fx.pointer_type, len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64),\n         (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n@@ -35,11 +34,7 @@ pub(crate) fn unsized_info<'tcx>(\n         (_, &ty::Dynamic(ref data, ..)) => {\n             crate::vtable::get_vtable(fx, fx.layout_of(source), data.principal())\n         }\n-        _ => bug!(\n-            \"unsized_info: invalid unsizing {:?} -> {:?}\",\n-            source,\n-            target\n-        ),\n+        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n@@ -96,17 +91,15 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n     let src_ty = src.layout().ty;\n     let dst_ty = dst.layout().ty;\n     let mut coerce_ptr = || {\n-        let (base, info) = if fx\n-            .layout_of(src.layout().ty.builtin_deref(true).unwrap().ty)\n-            .is_unsized()\n-        {\n-            // fat-ptr to fat-ptr unsize preserves the vtable\n-            // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-            src.load_scalar_pair(fx)\n-        } else {\n-            let base = src.load_scalar(fx);\n-            unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n-        };\n+        let (base, info) =\n+            if fx.layout_of(src.layout().ty.builtin_deref(true).unwrap().ty).is_unsized() {\n+                // fat-ptr to fat-ptr unsize preserves the vtable\n+                // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n+                src.load_scalar_pair(fx)\n+            } else {\n+                let base = src.load_scalar(fx);\n+                unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n+            };\n         dst.write_cvalue(fx, CValue::by_val_pair(base, info, dst.layout()));\n     };\n     match (&src_ty.kind(), &dst_ty.kind()) {\n@@ -131,11 +124,7 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n                 }\n             }\n         }\n-        _ => bug!(\n-            \"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n-            src_ty,\n-            dst_ty\n-        ),\n+        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\", src_ty, dst_ty),\n     }\n }\n \n@@ -147,33 +136,22 @@ pub(crate) fn size_and_align_of_dst<'tcx>(\n     info: Value,\n ) -> (Value, Value) {\n     if !layout.is_unsized() {\n-        let size = fx\n-            .bcx\n-            .ins()\n-            .iconst(fx.pointer_type, layout.size.bytes() as i64);\n-        let align = fx\n-            .bcx\n-            .ins()\n-            .iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n+        let size = fx.bcx.ins().iconst(fx.pointer_type, layout.size.bytes() as i64);\n+        let align = fx.bcx.ins().iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n         return (size, align);\n     }\n     match layout.ty.kind() {\n         ty::Dynamic(..) => {\n             // load size/align from vtable\n-            (\n-                crate::vtable::size_of_obj(fx, info),\n-                crate::vtable::min_align_of_obj(fx, info),\n-            )\n+            (crate::vtable::size_of_obj(fx, info), crate::vtable::min_align_of_obj(fx, info))\n         }\n         ty::Slice(_) | ty::Str => {\n             let unit = layout.field(fx, 0);\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             (\n                 fx.bcx.ins().imul_imm(info, unit.size.bytes() as i64),\n-                fx.bcx\n-                    .ins()\n-                    .iconst(fx.pointer_type, unit.align.abi.bytes() as i64),\n+                fx.bcx.ins().iconst(fx.pointer_type, unit.align.abi.bytes() as i64),\n             )\n         }\n         _ => {\n@@ -211,10 +189,7 @@ pub(crate) fn size_and_align_of_dst<'tcx>(\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let cmp = fx\n-                .bcx\n-                .ins()\n-                .icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n+            let cmp = fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n             let align = fx.bcx.ins().select(cmp, sized_align, unsized_align);\n \n             // Issue #27023: must add any necessary padding to `size`"}, {"sha": "eaaf71ff20f8d84ec928fdbc866b6783e265d9ef", "filename": "src/value_and_place.rs", "status": "modified", "additions": 30, "deletions": 105, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -16,10 +16,7 @@ fn codegen_field<'tcx>(\n     let field_layout = layout.field(&*fx, field.index());\n \n     let simple = |fx: &mut FunctionCx<'_, '_, '_>| {\n-        (\n-            base.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap()),\n-            field_layout,\n-        )\n+        (base.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap()), field_layout)\n     };\n \n     if let Some(extra) = extra {\n@@ -58,10 +55,7 @@ fn scalar_pair_calculate_b_offset(\n     a_scalar: &Scalar,\n     b_scalar: &Scalar,\n ) -> Offset32 {\n-    let b_offset = a_scalar\n-        .value\n-        .size(&tcx)\n-        .align_to(b_scalar.value.align(&tcx).abi);\n+    let b_offset = a_scalar.value.size(&tcx).align_to(b_scalar.value.align(&tcx).abi);\n     Offset32::new(b_offset.bytes().try_into().unwrap())\n }\n \n@@ -223,13 +217,7 @@ impl<'tcx> CValue<'tcx> {\n         layout: TyAndLayout<'tcx>,\n         const_val: ty::ScalarInt,\n     ) -> CValue<'tcx> {\n-        assert_eq!(\n-            const_val.size(),\n-            layout.size,\n-            \"{:#?}: {:?}\",\n-            const_val,\n-            layout\n-        );\n+        assert_eq!(const_val.size(), layout.size, \"{:#?}: {:?}\", const_val, layout);\n         use cranelift_codegen::ir::immediates::{Ieee32, Ieee64};\n \n         let clif_ty = fx.clif_type(layout.ty).unwrap();\n@@ -246,18 +234,11 @@ impl<'tcx> CValue<'tcx> {\n             ty::Uint(UintTy::U128) | ty::Int(IntTy::I128) => {\n                 let const_val = const_val.to_bits(layout.size).unwrap();\n                 let lsb = fx.bcx.ins().iconst(types::I64, const_val as u64 as i64);\n-                let msb = fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(types::I64, (const_val >> 64) as u64 as i64);\n+                let msb = fx.bcx.ins().iconst(types::I64, (const_val >> 64) as u64 as i64);\n                 fx.bcx.ins().iconcat(lsb, msb)\n             }\n-            ty::Bool | ty::Char | ty::Uint(_) | ty::Int(_) | ty::Ref(..)\n-            | ty::RawPtr(..) => {\n-                fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(clif_ty, const_val.to_bits(layout.size).unwrap() as i64)\n+            ty::Bool | ty::Char | ty::Uint(_) | ty::Int(_) | ty::Ref(..) | ty::RawPtr(..) => {\n+                fx.bcx.ins().iconst(clif_ty, const_val.to_bits(layout.size).unwrap() as i64)\n             }\n             ty::Float(FloatTy::F32) => {\n                 fx.bcx.ins().f32const(Ieee32::with_bits(u32::try_from(const_val).unwrap()))\n@@ -275,14 +256,8 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     pub(crate) fn cast_pointer_to(self, layout: TyAndLayout<'tcx>) -> Self {\n-        assert!(matches!(\n-            self.layout().ty.kind(),\n-            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n-        ));\n-        assert!(matches!(\n-            layout.ty.kind(),\n-            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n-        ));\n+        assert!(matches!(self.layout().ty.kind(), ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)));\n+        assert!(matches!(layout.ty.kind(), ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)));\n         assert_eq!(self.layout().abi, layout.abi);\n         CValue(self.0, layout)\n     }\n@@ -313,10 +288,7 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn no_place(layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None), layout }\n     }\n \n     pub(crate) fn new_stack_slot(\n@@ -335,10 +307,7 @@ impl<'tcx> CPlace<'tcx> {\n             size: (u32::try_from(layout.size.bytes()).unwrap() + 15) / 16 * 16,\n             offset: None,\n         });\n-        CPlace {\n-            inner: CPlaceInner::Addr(Pointer::stack_slot(stack_slot), None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(Pointer::stack_slot(stack_slot), None), layout }\n     }\n \n     pub(crate) fn new_var(\n@@ -349,10 +318,7 @@ impl<'tcx> CPlace<'tcx> {\n         let var = Variable::with_u32(fx.next_ssa_var);\n         fx.next_ssa_var += 1;\n         fx.bcx.declare_var(var, fx.clif_type(layout.ty).unwrap());\n-        CPlace {\n-            inner: CPlaceInner::Var(local, var),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Var(local, var), layout }\n     }\n \n     pub(crate) fn new_var_pair(\n@@ -368,52 +334,39 @@ impl<'tcx> CPlace<'tcx> {\n         let (ty1, ty2) = fx.clif_pair_type(layout.ty).unwrap();\n         fx.bcx.declare_var(var1, ty1);\n         fx.bcx.declare_var(var2, ty2);\n-        CPlace {\n-            inner: CPlaceInner::VarPair(local, var1, var2),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::VarPair(local, var1, var2), layout }\n     }\n \n     pub(crate) fn for_ptr(ptr: Pointer, layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(ptr, None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(ptr, None), layout }\n     }\n \n     pub(crate) fn for_ptr_with_extra(\n         ptr: Pointer,\n         extra: Value,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(ptr, Some(extra)),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(ptr, Some(extra)), layout }\n     }\n \n     pub(crate) fn to_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> CValue<'tcx> {\n         let layout = self.layout();\n         match self.inner {\n             CPlaceInner::Var(_local, var) => {\n                 let val = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 CValue::by_val(val, layout)\n             }\n             CPlaceInner::VarPair(_local, var1, var2) => {\n                 let val1 = fx.bcx.use_var(var1);\n-                fx.bcx\n-                    .set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n+                fx.bcx.set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n                 let val2 = fx.bcx.use_var(var2);\n-                fx.bcx\n-                    .set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n+                fx.bcx.set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n                 CValue::by_val_pair(val1, val2, layout)\n             }\n             CPlaceInner::VarLane(_local, var, lane) => {\n                 let val = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 let val = fx.bcx.ins().extractlane(val, lane);\n                 CValue::by_val(val, layout)\n             }\n@@ -503,8 +456,7 @@ impl<'tcx> CPlace<'tcx> {\n                 }\n                 _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty, dst_ty),\n             };\n-            fx.bcx\n-                .set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+            fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n             fx.bcx.def_var(var, data);\n         }\n \n@@ -550,15 +502,13 @@ impl<'tcx> CPlace<'tcx> {\n \n                 // First get the old vector\n                 let vector = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n \n                 // Next insert the written lane into the vector\n                 let vector = fx.bcx.ins().insertlane(vector, data, lane);\n \n                 // Finally write the new vector\n-                fx.bcx\n-                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 fx.bcx.def_var(var, vector);\n \n                 return;\n@@ -596,10 +546,7 @@ impl<'tcx> CPlace<'tcx> {\n                 to_ptr.store(fx, val, flags);\n             }\n             CValueInner::ByValPair(_, _) => {\n-                bug!(\n-                    \"Non ScalarPair abi {:?} for ByValPair CValue\",\n-                    dst_layout.abi\n-                );\n+                bug!(\"Non ScalarPair abi {:?} for ByValPair CValue\", dst_layout.abi);\n             }\n             CValueInner::ByRef(from_ptr, None) => {\n                 let from_addr = from_ptr.get_addr(fx);\n@@ -642,18 +589,8 @@ impl<'tcx> CPlace<'tcx> {\n                 let layout = layout.field(&*fx, field.index());\n \n                 match field.as_u32() {\n-                    0 => {\n-                        return CPlace {\n-                            inner: CPlaceInner::Var(local, var1),\n-                            layout,\n-                        }\n-                    }\n-                    1 => {\n-                        return CPlace {\n-                            inner: CPlaceInner::Var(local, var2),\n-                            layout,\n-                        }\n-                    }\n+                    0 => return CPlace { inner: CPlaceInner::Var(local, var1), layout },\n+                    1 => return CPlace { inner: CPlaceInner::Var(local, var2), layout },\n                     _ => unreachable!(\"field should be 0 or 1\"),\n                 }\n             }\n@@ -681,10 +618,7 @@ impl<'tcx> CPlace<'tcx> {\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };\n \n-        let offset = fx\n-            .bcx\n-            .ins()\n-            .imul_imm(index, elem_layout.size.bytes() as i64);\n+        let offset = fx.bcx.ins().imul_imm(index, elem_layout.size.bytes() as i64);\n \n         CPlace::for_ptr(ptr.offset_value(fx, offset), elem_layout)\n     }\n@@ -695,10 +629,7 @@ impl<'tcx> CPlace<'tcx> {\n             let (addr, extra) = self.to_cvalue(fx).load_scalar_pair(fx);\n             CPlace::for_ptr_with_extra(Pointer::new(addr), extra, inner_layout)\n         } else {\n-            CPlace::for_ptr(\n-                Pointer::new(self.to_cvalue(fx).load_scalar(fx)),\n-                inner_layout,\n-            )\n+            CPlace::for_ptr(Pointer::new(self.to_cvalue(fx).load_scalar(fx)), inner_layout)\n         }\n     }\n \n@@ -726,10 +657,7 @@ impl<'tcx> CPlace<'tcx> {\n     ) -> Self {\n         assert!(!self.layout().is_unsized());\n         let layout = self.layout().for_variant(fx, variant);\n-        CPlace {\n-            inner: self.inner,\n-            layout,\n-        }\n+        CPlace { inner: self.inner, layout }\n     }\n }\n \n@@ -768,12 +696,9 @@ pub(crate) fn assert_assignable<'tcx>(\n         }\n         (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n             for (from, to) in from_traits.iter().zip(to_traits) {\n-                let from = fx\n-                    .tcx\n-                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n-                let to = fx\n-                    .tcx\n-                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n+                let from =\n+                    fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n+                let to = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n                 assert_eq!(\n                     from, to,\n                     \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\","}, {"sha": "4d2551a061b99b5e1b74e55d0f53d15b76ce2f04", "filename": "src/vtable.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e736293b3bcada7dba0a134604eb6c9866d5858/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=5e736293b3bcada7dba0a134604eb6c9866d5858", "patch": "@@ -165,11 +165,8 @@ fn build_vtable<'tcx>(\n }\n \n fn write_usize(tcx: TyCtxt<'_>, buf: &mut [u8], idx: usize, num: u64) {\n-    let pointer_size = tcx\n-        .layout_of(ParamEnv::reveal_all().and(tcx.types.usize))\n-        .unwrap()\n-        .size\n-        .bytes() as usize;\n+    let pointer_size =\n+        tcx.layout_of(ParamEnv::reveal_all().and(tcx.types.usize)).unwrap().size.bytes() as usize;\n     let target = &mut buf[idx * pointer_size..(idx + 1) * pointer_size];\n \n     match tcx.data_layout.endian {"}]}