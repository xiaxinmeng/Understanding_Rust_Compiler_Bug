{"sha": "08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZDI3NDQxZWNjOTZhNTZlMWIwZTcyYzBhY2NiY2VkMmNlNmE3ZDM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-10T14:10:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T07:26:13Z"}, "message": "rustc: move the formatter into ty::print::PrintCx.", "tree": {"sha": "76d2903c337ad49e7e6aa0875a7b76d994e159c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76d2903c337ad49e7e6aa0875a7b76d994e159c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "html_url": "https://github.com/rust-lang/rust/commit/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0", "html_url": "https://github.com/rust-lang/rust/commit/732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0"}], "stats": {"total": 877, "additions": 448, "deletions": 429}, "files": [{"sha": "53f39d3ac8a37eac0c28b44cc5bb162138a1d578", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "patch": "@@ -31,6 +31,7 @@\n #![deny(rust_2018_idioms)]\n #![allow(explicit_outlives_requirements)]\n \n+#![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]"}, {"sha": "7d2050a7c68a889ae6fc75694e6ccf5bbe26b641", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "patch": "@@ -2369,7 +2369,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 };\n \n                 // When printing regions, add trailing space if necessary.\n-                ty::print::PrintCx::with(|cx| {\n+                ty::print::PrintCx::with(ty::print::FmtPrinter { fmt }, |cx| {\n                     let region = if cx.is_verbose || cx.identify_regions {\n                         let mut region = region.to_string();\n                         if region.len() > 0 {\n@@ -2380,7 +2380,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         // Do not even print 'static\n                         String::new()\n                     };\n-                    write!(fmt, \"&{}{}{:?}\", region, kind_str, place)\n+                    write!(cx.printer.fmt, \"&{}{}{:?}\", region, kind_str, place)\n                 })\n             }\n "}, {"sha": "0612401ca25db3626afadabc410d404740528cb4", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 67, "deletions": 63, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "patch": "@@ -59,11 +59,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// root, unless with_forced_absolute_paths was used.\n     pub fn item_path_str(self, def_id: DefId) -> String {\n         debug!(\"item_path_str: def_id={:?}\", def_id);\n-        let mut cx = PrintCx::new(self);\n         if FORCE_ABSOLUTE.with(|force| force.get()) {\n-            AbsolutePathPrinter::print_item_path(&mut cx, def_id)\n+            PrintCx::new(self, AbsolutePathPrinter).print_item_path(def_id)\n         } else {\n-            LocalPathPrinter::print_item_path(&mut cx, def_id)\n+            PrintCx::new(self, LocalPathPrinter).print_item_path(def_id)\n         }\n     }\n \n@@ -76,26 +75,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// suitable for user output. It always begins with a crate identifier.\n     pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n         debug!(\"absolute_item_path_str: def_id={:?}\", def_id);\n-        let mut cx = PrintCx::new(self);\n-        AbsolutePathPrinter::print_item_path(&mut cx, def_id)\n+        PrintCx::new(self, AbsolutePathPrinter).print_item_path(def_id)\n     }\n }\n \n-impl PrintCx<'a, 'gcx, 'tcx> {\n-    pub fn default_print_item_path<P>(&mut self, def_id: DefId) -> P::Path\n-        where P: ItemPathPrinter\n-    {\n+impl<P: ItemPathPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n+    pub fn default_print_item_path(&mut self, def_id: DefId) -> P::Path {\n         debug!(\"default_print_item_path: def_id={:?}\", def_id);\n         let key = self.tcx.def_key(def_id);\n         debug!(\"default_print_item_path: key={:?}\", key);\n         match key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n                 assert!(key.parent.is_none());\n-                P::path_crate(self, def_id.krate)\n+                self.path_crate(def_id.krate)\n             }\n \n             DefPathData::Impl => {\n-                self.default_print_impl_path::<P>(def_id)\n+                self.default_print_impl_path(def_id)\n             }\n \n             // Unclear if there is any value in distinguishing these.\n@@ -121,20 +117,18 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n             data @ DefPathData::ImplTrait |\n             data @ DefPathData::GlobalMetaData(..) => {\n                 let parent_did = self.tcx.parent_def_id(def_id).unwrap();\n-                let path = P::print_item_path(self, parent_did);\n-                P::path_append(path, &data.as_interned_str().as_symbol().as_str())\n+                let path = self.print_item_path(parent_did);\n+                self.path_append(path, &data.as_interned_str().as_symbol().as_str())\n             },\n \n             DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n                 let parent_def_id = self.tcx.parent_def_id(def_id).unwrap();\n-                P::print_item_path(self, parent_def_id)\n+                self.print_item_path(parent_def_id)\n             }\n         }\n     }\n \n-    fn default_print_impl_path<P>(&mut self, impl_def_id: DefId) -> P::Path\n-        where P: ItemPathPrinter\n-    {\n+    fn default_print_impl_path(&mut self, impl_def_id: DefId) -> P::Path {\n         debug!(\"default_print_impl_path: impl_def_id={:?}\", impl_def_id);\n         let parent_def_id = self.tcx.parent_def_id(impl_def_id).unwrap();\n \n@@ -147,7 +141,7 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n         };\n \n         if !use_types {\n-            return self.default_print_impl_path_fallback::<P>(impl_def_id);\n+            return self.default_print_impl_path_fallback(impl_def_id);\n         }\n \n         // Decide whether to print the parent path for the impl.\n@@ -171,11 +165,11 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n             // If the impl is not co-located with either self-type or\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n-            let path = P::print_item_path(self, parent_def_id);\n+            let path = self.print_item_path(parent_def_id);\n             if let Some(trait_ref) = impl_trait_ref {\n-                return P::path_append(path, &format!(\"<impl {} for {}>\", trait_ref, self_ty));\n+                return self.path_append(path, &format!(\"<impl {} for {}>\", trait_ref, self_ty));\n             } else {\n-                return P::path_append(path, &format!(\"<impl {}>\", self_ty));\n+                return self.path_append(path, &format!(\"<impl {}>\", self_ty));\n             }\n         }\n \n@@ -184,7 +178,7 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n \n         if let Some(trait_ref) = impl_trait_ref {\n             // Trait impls.\n-            return P::path_impl(self, &format!(\"<{} as {}>\", self_ty, trait_ref));\n+            return self.path_impl(&format!(\"<{} as {}>\", self_ty, trait_ref));\n         }\n \n         // Inherent impls. Try to print `Foo::bar` for an inherent\n@@ -194,42 +188,40 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n             ty::Adt(adt_def, substs) => {\n                 // FIXME(eddyb) always print without <> here.\n                 if substs.types().next().is_none() { // ignore regions\n-                    P::print_item_path(self, adt_def.did)\n+                    self.print_item_path(adt_def.did)\n                 } else {\n-                    P::path_impl(self, &format!(\"<{}>\", self_ty))\n+                    self.path_impl(&format!(\"<{}>\", self_ty))\n                 }\n             }\n \n-            ty::Foreign(did) => P::print_item_path(self, did),\n+            ty::Foreign(did) => self.print_item_path(did),\n \n             ty::Bool |\n             ty::Char |\n             ty::Int(_) |\n             ty::Uint(_) |\n             ty::Float(_) |\n             ty::Str => {\n-                P::path_impl(self, &self_ty.to_string())\n+                self.path_impl(&self_ty.to_string())\n             }\n \n             _ => {\n-                P::path_impl(self, &format!(\"<{}>\", self_ty))\n+                self.path_impl(&format!(\"<{}>\", self_ty))\n             }\n         }\n     }\n \n-    fn default_print_impl_path_fallback<P>(&mut self, impl_def_id: DefId) -> P::Path\n-        where P: ItemPathPrinter\n-    {\n+    fn default_print_impl_path_fallback(&mut self, impl_def_id: DefId) -> P::Path {\n         // If no type info is available, fall back to\n         // pretty printing some span information. This should\n         // only occur very early in the compiler pipeline.\n         // FIXME(eddyb) this should just be using `tcx.def_span(impl_def_id)`\n         let parent_def_id = self.tcx.parent_def_id(impl_def_id).unwrap();\n-        let path = P::print_item_path(self, parent_def_id);\n+        let path = self.print_item_path(parent_def_id);\n         let hir_id = self.tcx.hir().as_local_hir_id(impl_def_id).unwrap();\n         let item = self.tcx.hir().expect_item_by_hir_id(hir_id);\n         let span_str = self.tcx.sess.source_map().span_to_string(item.span);\n-        P::path_append(path, &format!(\"<impl at {}>\", span_str))\n+        self.path_append(path, &format!(\"<impl at {}>\", span_str))\n     }\n }\n \n@@ -296,27 +288,35 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n pub trait ItemPathPrinter: Sized {\n     type Path;\n \n-    fn print_item_path(cx: &mut PrintCx<'_, '_, '_>, def_id: DefId) -> Self::Path {\n-        cx.default_print_item_path::<Self>(def_id)\n+    fn print_item_path(self: &mut PrintCx<'_, '_, '_, Self>, def_id: DefId) -> Self::Path {\n+        self.default_print_item_path(def_id)\n     }\n \n-    fn path_crate(cx: &mut PrintCx<'_, '_, '_>, cnum: CrateNum) -> Self::Path;\n-    fn path_impl(cx: &mut PrintCx<'_, '_, '_>, text: &str) -> Self::Path;\n-    fn path_append(path: Self::Path, text: &str) -> Self::Path;\n+    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path;\n+    fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path;\n+    fn path_append(\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n+        path: Self::Path,\n+        text: &str,\n+    ) -> Self::Path;\n }\n \n struct AbsolutePathPrinter;\n \n impl ItemPathPrinter for AbsolutePathPrinter {\n     type Path = String;\n \n-    fn path_crate(cx: &mut PrintCx<'_, '_, '_>, cnum: CrateNum) -> Self::Path {\n-        cx.tcx.original_crate_name(cnum).to_string()\n+    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n+        self.tcx.original_crate_name(cnum).to_string()\n     }\n-    fn path_impl(_cx: &mut PrintCx<'_, '_, '_>, text: &str) -> Self::Path {\n+    fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n         text.to_string()\n     }\n-    fn path_append(mut path: Self::Path, text: &str) -> Self::Path {\n+    fn path_append(\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n+        mut path: Self::Path,\n+        text: &str,\n+    ) -> Self::Path {\n         if !path.is_empty() {\n             path.push_str(\"::\");\n         }\n@@ -332,7 +332,7 @@ impl LocalPathPrinter {\n     /// from at least one local module and returns true. If the crate defining `def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n     fn try_print_visible_item_path(\n-        cx: &mut PrintCx<'_, '_, '_>,\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n         def_id: DefId,\n     ) -> Option<<Self as ItemPathPrinter>::Path> {\n         debug!(\"try_print_visible_item_path: def_id={:?}\", def_id);\n@@ -343,7 +343,7 @@ impl LocalPathPrinter {\n             let cnum = def_id.krate;\n \n             if cnum == LOCAL_CRATE {\n-                return Some(Self::path_crate(cx, cnum));\n+                return Some(self.path_crate(cnum));\n             }\n \n             // In local mode, when we encounter a crate other than\n@@ -356,7 +356,7 @@ impl LocalPathPrinter {\n             // 2. for an extern inferred from a path or an indirect crate,\n             //    where there is no explicit `extern crate`, we just prepend\n             //    the crate name.\n-            match *cx.tcx.extern_crate(def_id) {\n+            match *self.tcx.extern_crate(def_id) {\n                 Some(ExternCrate {\n                     src: ExternCrateSource::Extern(def_id),\n                     direct: true,\n@@ -365,14 +365,14 @@ impl LocalPathPrinter {\n                 }) => {\n                     debug!(\"try_print_visible_item_path: def_id={:?}\", def_id);\n                     let path = if !span.is_dummy() {\n-                        Self::print_item_path(cx, def_id)\n+                        self.print_item_path(def_id)\n                     } else {\n-                        Self::path_crate(cx, cnum)\n+                        self.path_crate(cnum)\n                     };\n                     return Some(path);\n                 }\n                 None => {\n-                    return Some(Self::path_crate(cx, cnum));\n+                    return Some(self.path_crate(cnum));\n                 }\n                 _ => {},\n             }\n@@ -382,9 +382,9 @@ impl LocalPathPrinter {\n             return None;\n         }\n \n-        let visible_parent_map = cx.tcx.visible_parent_map(LOCAL_CRATE);\n+        let visible_parent_map = self.tcx.visible_parent_map(LOCAL_CRATE);\n \n-        let mut cur_def_key = cx.tcx.def_key(def_id);\n+        let mut cur_def_key = self.tcx.def_key(def_id);\n         debug!(\"try_print_visible_item_path: cur_def_key={:?}\", cur_def_key);\n \n         // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n@@ -394,12 +394,12 @@ impl LocalPathPrinter {\n                 index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n             };\n \n-            cur_def_key = cx.tcx.def_key(parent);\n+            cur_def_key = self.tcx.def_key(parent);\n         }\n \n         let visible_parent = visible_parent_map.get(&def_id).cloned()?;\n-        let path = Self::try_print_visible_item_path(cx, visible_parent)?;\n-        let actual_parent = cx.tcx.parent(def_id);\n+        let path = self.try_print_visible_item_path(visible_parent)?;\n+        let actual_parent = self.tcx.parent(def_id);\n \n         let data = cur_def_key.disambiguated_data.data;\n         debug!(\n@@ -441,7 +441,7 @@ impl LocalPathPrinter {\n             // have access to the re-exported name.\n             DefPathData::Module(actual_name) |\n             DefPathData::TypeNs(actual_name) if Some(visible_parent) != actual_parent => {\n-                cx.tcx.item_children(visible_parent)\n+                self.tcx.item_children(visible_parent)\n                     .iter()\n                     .find(|child| child.def.def_id() == def_id)\n                     .map(|child| child.ident.as_str())\n@@ -451,43 +451,47 @@ impl LocalPathPrinter {\n                 data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n                     // Re-exported `extern crate` (#43189).\n                     if let DefPathData::CrateRoot = data {\n-                        cx.tcx.original_crate_name(def_id.krate).as_str()\n+                        self.tcx.original_crate_name(def_id.krate).as_str()\n                     } else {\n                         Symbol::intern(\"<unnamed>\").as_str()\n                     }\n                 })\n             },\n         };\n         debug!(\"try_print_visible_item_path: symbol={:?}\", symbol);\n-        Some(Self::path_append(path, &symbol))\n+        Some(self.path_append(path, &symbol))\n     }\n }\n \n impl ItemPathPrinter for LocalPathPrinter {\n     type Path = String;\n \n-    fn print_item_path(cx: &mut PrintCx<'_, '_, '_>, def_id: DefId) -> Self::Path {\n-        Self::try_print_visible_item_path(cx, def_id)\n-            .unwrap_or_else(|| cx.default_print_item_path::<Self>(def_id))\n+    fn print_item_path(self: &mut PrintCx<'_, '_, '_, Self>, def_id: DefId) -> Self::Path {\n+        self.try_print_visible_item_path(def_id)\n+            .unwrap_or_else(|| self.default_print_item_path(def_id))\n     }\n \n-    fn path_crate(cx: &mut PrintCx<'_, '_, '_>, cnum: CrateNum) -> Self::Path {\n+    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n         if cnum == LOCAL_CRATE {\n-            if cx.tcx.sess.rust_2018() {\n+            if self.tcx.sess.rust_2018() {\n                 // We add the `crate::` keyword on Rust 2018, only when desired.\n                 if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n                     return keywords::Crate.name().to_string();\n                 }\n             }\n             String::new()\n         } else {\n-            cx.tcx.crate_name(cnum).to_string()\n+            self.tcx.crate_name(cnum).to_string()\n         }\n     }\n-    fn path_impl(_cx: &mut PrintCx<'_, '_, '_>, text: &str) -> Self::Path {\n+    fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n         text.to_string()\n     }\n-    fn path_append(mut path: Self::Path, text: &str) -> Self::Path {\n+    fn path_append(\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n+        mut path: Self::Path,\n+        text: &str,\n+    ) -> Self::Path {\n         if !path.is_empty() {\n             path.push_str(\"::\");\n         }"}, {"sha": "a1d93bc4140cc2f5542f4a94a183734255cd1286", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "patch": "@@ -4,6 +4,7 @@ use rustc_data_structures::fx::FxHashSet;\n use syntax::symbol::InternedString;\n \n use std::fmt;\n+use std::ops::Deref;\n \n // FIXME(eddyb) this module uses `pub(crate)` for things used only\n // from `ppaux` - when that is removed, they can be re-privatized.\n@@ -21,8 +22,9 @@ impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n     }\n }\n \n-pub struct PrintCx<'a, 'gcx, 'tcx> {\n+pub struct PrintCx<'a, 'gcx, 'tcx, P> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub printer: P,\n     pub(crate) is_debug: bool,\n     pub(crate) is_verbose: bool,\n     pub(crate) identify_regions: bool,\n@@ -31,10 +33,20 @@ pub struct PrintCx<'a, 'gcx, 'tcx> {\n     pub(crate) binder_depth: usize,\n }\n \n-impl PrintCx<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+// HACK(eddyb) this is solely for `self: &mut PrintCx<Self>`, e.g. to\n+// implement traits on the printer and call the methods on the context.\n+impl<P> Deref for PrintCx<'_, '_, '_, P> {\n+    type Target = P;\n+    fn deref(&self) -> &P {\n+        &self.printer\n+    }\n+}\n+\n+impl<P> PrintCx<'a, 'gcx, 'tcx, P> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, printer: P) -> Self {\n         PrintCx {\n             tcx,\n+            printer,\n             is_debug: false,\n             is_verbose: tcx.sess.verbose(),\n             identify_regions: tcx.sess.opts.debugging_opts.identify_regions,\n@@ -44,8 +56,8 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn with<R>(f: impl FnOnce(PrintCx<'_, '_, '_>) -> R) -> R {\n-        ty::tls::with(|tcx| f(PrintCx::new(tcx)))\n+    pub(crate) fn with<R>(printer: P, f: impl FnOnce(PrintCx<'_, '_, '_, P>) -> R) -> R {\n+        ty::tls::with(|tcx| f(PrintCx::new(tcx, printer)))\n     }\n     pub(crate) fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n     where T: TypeFoldable<'tcx>\n@@ -57,24 +69,26 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub trait Print<'tcx> {\n-    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, 'tcx>) -> fmt::Result;\n-    fn print_display<F: fmt::Write>(\n-        &self,\n-        f: &mut F,\n-        cx: &mut PrintCx<'_, '_, 'tcx>,\n-    ) -> fmt::Result {\n+pub trait Print<'tcx, P> {\n+    type Output;\n+\n+    fn print(&self, cx: &mut PrintCx<'_, '_, 'tcx, P>) -> Self::Output;\n+    fn print_display(&self, cx: &mut PrintCx<'_, '_, 'tcx, P>) -> Self::Output {\n         let old_debug = cx.is_debug;\n         cx.is_debug = false;\n-        let result = self.print(f, cx);\n+        let result = self.print(cx);\n         cx.is_debug = old_debug;\n         result\n     }\n-    fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, 'tcx>) -> fmt::Result {\n+    fn print_debug(&self, cx: &mut PrintCx<'_, '_, 'tcx, P>) -> Self::Output {\n         let old_debug = cx.is_debug;\n         cx.is_debug = true;\n-        let result = self.print(f, cx);\n+        let result = self.print(cx);\n         cx.is_debug = old_debug;\n         result\n     }\n }\n+\n+pub struct FmtPrinter<F: fmt::Write> {\n+    pub fmt: F,\n+}"}, {"sha": "780ff8a61e41c55a96d482b85840b3b8950cdccc", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 327, "deletions": 335, "changes": 662, "blob_url": "https://github.com/rust-lang/rust/blob/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "patch": "@@ -9,7 +9,7 @@ use crate::ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n use crate::ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n use crate::ty::{Placeholder, UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n use crate::ty::{self, ParamConst, Ty, TypeFoldable};\n-use crate::ty::print::{PrintCx, Print};\n+use crate::ty::print::{FmtPrinter, PrintCx, Print};\n use crate::mir::interpret::ConstValue;\n \n use std::cell::Cell;\n@@ -161,8 +161,8 @@ impl RegionHighlightMode {\n macro_rules! gen_display_debug_body {\n     ( $with:path ) => {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            PrintCx::with(|mut cx| {\n-                $with(&cx.tcx.lift(self).expect(\"could not lift for printing\"), f, &mut cx)\n+            PrintCx::with(FmtPrinter { fmt: f }, |mut cx| {\n+                $with(&cx.tcx.lift(self).expect(\"could not lift for printing\"), &mut cx)\n             })\n         }\n     };\n@@ -191,25 +191,19 @@ macro_rules! gen_display_debug {\n     ( $generic:tt $target:ty, $t:ident no ) => {};\n }\n macro_rules! gen_print_impl {\n-    ( ($($x:tt)+) $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n-        impl<$($x)+> Print<'tcx> for $target {\n-            fn print<F: fmt::Write>(\n-                &$self,\n-                $f: &mut F,\n-                $cx: &mut PrintCx<'_, '_, 'tcx>,\n-            ) -> fmt::Result {\n+    ( ($($x:tt)+) $target:ty, ($self:ident, $cx:ident) $disp:block $dbg:block ) => {\n+        impl<$($x)+, F: fmt::Write> Print<'tcx, FmtPrinter<F>> for $target {\n+            type Output = fmt::Result;\n+            fn print(&$self, $cx: &mut PrintCx<'_, '_, 'tcx, FmtPrinter<F>>) -> fmt::Result {\n                 if $cx.is_debug $dbg\n                 else $disp\n             }\n         }\n     };\n-    ( () $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n-        impl Print<'tcx> for $target {\n-            fn print<F: fmt::Write>(\n-                &$self,\n-                $f: &mut F,\n-                $cx: &mut PrintCx<'_, '_, 'tcx>,\n-            ) -> fmt::Result {\n+    ( () $target:ty, ($self:ident, $cx:ident) $disp:block $dbg:block ) => {\n+        impl<F: fmt::Write> Print<'tcx, FmtPrinter<F>> for $target {\n+            type Output = fmt::Result;\n+            fn print(&$self, $cx: &mut PrintCx<'_, '_, 'tcx, FmtPrinter<F>>) -> fmt::Result {\n                 if $cx.is_debug $dbg\n                 else $disp\n             }\n@@ -238,9 +232,9 @@ macro_rules! define_print {\n         } yes $dbg }\n     };\n     ( $generic:tt $target:ty,\n-      ($self:ident, $f:ident, $cx:ident) { display $disp:block } ) => {\n-        gen_print_impl! { $generic $target, ($self, $f, $cx) yes $disp no {\n-            write!($f, \"{:?}\", $self)\n+      ($self:ident, $cx:ident) { display $disp:block } ) => {\n+        gen_print_impl! { $generic $target, ($self, $cx) yes $disp no {\n+            write!($cx.printer.fmt, \"{:?}\", $self)\n         } }\n     };\n }\n@@ -250,48 +244,47 @@ macro_rules! define_print_multi {\n     };\n }\n macro_rules! print_inner {\n-    ( $f:expr, $cx:expr, write ($($data:expr),+) ) => {\n-        write!($f, $($data),+)\n+    ( $cx:expr, write ($($data:expr),+) ) => {\n+        write!($cx.printer.fmt, $($data),+)\n     };\n-    ( $f:expr, $cx:expr, $kind:ident ($data:expr) ) => {\n-        $data.$kind($f, $cx)\n+    ( $cx:expr, $kind:ident ($data:expr) ) => {\n+        $data.$kind($cx)\n     };\n }\n macro_rules! print {\n-    ( $f:expr, $cx:expr $(, $kind:ident $data:tt)+ ) => {\n-        Ok(())$(.and_then(|_| print_inner!($f, $cx, $kind $data)))+\n+    ( $cx:expr $(, $kind:ident $data:tt)+ ) => {\n+        Ok(())$(.and_then(|_| print_inner!($cx, $kind $data)))+\n     };\n }\n \n-impl PrintCx<'a, 'gcx, 'tcx> {\n-    fn fn_sig<F: fmt::Write>(&mut self,\n-                             f: &mut F,\n-                             inputs: &[Ty<'tcx>],\n-                             c_variadic: bool,\n-                             output: Ty<'tcx>)\n-                             -> fmt::Result {\n-        write!(f, \"(\")?;\n+impl<F: fmt::Write> PrintCx<'a, 'gcx, 'tcx, FmtPrinter<F>> {\n+    fn fn_sig(\n+        &mut self,\n+        inputs: &[Ty<'tcx>],\n+        c_variadic: bool,\n+        output: Ty<'tcx>,\n+    ) -> fmt::Result {\n+        print!(self, write(\"(\"))?;\n         let mut inputs = inputs.iter();\n         if let Some(&ty) = inputs.next() {\n-            print!(f, self, print_display(ty))?;\n+            print!(self, print_display(ty))?;\n             for &ty in inputs {\n-                print!(f, self, write(\", \"), print_display(ty))?;\n+                print!(self, write(\", \"), print_display(ty))?;\n             }\n             if c_variadic {\n-                write!(f, \", ...\")?;\n+                print!(self, write(\", ...\"))?;\n             }\n         }\n-        write!(f, \")\")?;\n+        print!(self, write(\")\"))?;\n         if !output.is_unit() {\n-            print!(f, self, write(\" -> \"), print_display(output))?;\n+            print!(self, write(\" -> \"), print_display(output))?;\n         }\n \n         Ok(())\n     }\n \n-    fn parameterized<F: fmt::Write>(\n+    fn parameterized(\n         &mut self,\n-        f: &mut F,\n         mut def_id: DefId,\n         substs: SubstsRef<'tcx>,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n@@ -321,41 +314,41 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n             let parent_has_own_self =\n                 parent_generics.has_self && parent_generics.parent_count == 0;\n             if parent_has_own_self {\n-                print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n+                print!(self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n             }\n-            self.parameterized(f, parent_def_id, substs, iter::empty())?;\n+            self.parameterized(parent_def_id, substs, iter::empty())?;\n             if parent_has_own_self {\n-                write!(f, \">\")?;\n+                print!(self, write(\">\"))?;\n             }\n \n-            write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str())?;\n+            print!(self, write(\"::{}\", key.disambiguated_data.data.as_interned_str()))?;\n         } else {\n             // Try to print `impl`s more like how you'd refer to their associated items.\n             if let DefPathData::Impl = key.disambiguated_data.data {\n                 if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n                     // HACK(eddyb) this is in lieu of more specific disambiguation.\n-                    print!(f, self, write(\"{}\", self.tcx.item_path_str(def_id)))?;\n+                    print!(self, write(\"{}\", self.tcx.item_path_str(def_id)))?;\n \n                     let trait_ref = trait_ref.subst(self.tcx, substs);\n-                    print!(f, self, print_debug(trait_ref))?;\n+                    print!(self, print_debug(trait_ref))?;\n                 } else {\n                     let self_ty = self.tcx.type_of(def_id).subst(self.tcx, substs);\n                     // FIXME(eddyb) omit the <> where possible.\n-                    print!(f, self, write(\"<\"), print(self_ty), write(\">\"))?;\n+                    print!(self, write(\"<\"), print(self_ty), write(\">\"))?;\n                 }\n                 return Ok(());\n             }\n \n-            print!(f, self, write(\"{}\", self.tcx.item_path_str(def_id)))?;\n+            print!(self, write(\"{}\", self.tcx.item_path_str(def_id)))?;\n         }\n \n         let mut empty = true;\n-        let mut start_or_continue = |f: &mut F, start: &str, cont: &str| {\n+        let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n             if empty {\n                 empty = false;\n-                write!(f, \"{}\", start)\n+                print!(cx, write(\"{}\", start))\n             } else {\n-                write!(f, \"{}\", cont)\n+                print!(cx, write(\"{}\", cont))\n             }\n         };\n \n@@ -395,42 +388,42 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n                     if !print_regions {\n                         continue;\n                     }\n-                    start_or_continue(f, start, \", \")?;\n+                    start_or_continue(self, start, \", \")?;\n                     if !region.display_outputs_anything(self) {\n                         // This happens when the value of the region\n                         // parameter is not easily serialized. This may be\n                         // because the user omitted it in the first place,\n                         // or because it refers to some block in the code,\n                         // etc. I'm not sure how best to serialize this.\n-                        write!(f, \"'_\")?;\n+                        print!(self, write(\"'_\"))?;\n                     } else {\n-                        region.print_display(f, self)?;\n+                        region.print_display(self)?;\n                     }\n                 }\n                 UnpackedKind::Type(ty) => {\n-                    start_or_continue(f, start, \", \")?;\n-                    ty.print_display(f, self)?;\n+                    start_or_continue(self, start, \", \")?;\n+                    ty.print_display(self)?;\n                 }\n                 UnpackedKind::Const(ct) => {\n-                    start_or_continue(f, start, \", \")?;\n-                    ct.print_display(f, self)?;\n+                    start_or_continue(self, start, \", \")?;\n+                    ct.print_display(self)?;\n                 }\n             }\n         }\n \n         for projection in projections {\n-            start_or_continue(f, start, \", \")?;\n-            print!(f, self,\n+            start_or_continue(self, start, \", \")?;\n+            print!(self,\n                     write(\"{}=\",\n                             self.tcx.associated_item(projection.item_def_id).ident),\n                     print_display(projection.ty))?;\n         }\n \n-        start_or_continue(f, \"\", \">\")\n+        start_or_continue(self, \"\", \">\")\n     }\n \n-    fn in_binder<T, F>(&mut self, f: &mut F, value: &ty::Binder<T>) -> fmt::Result\n-        where T: Print<'tcx> + TypeFoldable<'tcx>, F: fmt::Write\n+    fn in_binder<T>(&mut self, value: &ty::Binder<T>) -> fmt::Result\n+        where T: Print<'tcx, FmtPrinter<F>, Output = fmt::Result> + TypeFoldable<'tcx>\n     {\n         fn name_by_region_index(index: usize) -> InternedString {\n             match index {\n@@ -450,22 +443,22 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n         }\n \n         let mut empty = true;\n-        let mut start_or_continue = |f: &mut F, start: &str, cont: &str| {\n+        let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n             if empty {\n                 empty = false;\n-                write!(f, \"{}\", start)\n+                print!(cx, write(\"{}\", start))\n             } else {\n-                write!(f, \"{}\", cont)\n+                print!(cx, write(\"{}\", cont))\n             }\n         };\n \n         let old_region_index = self.region_index;\n         let mut region_index = old_region_index;\n         let new_value = self.tcx.replace_late_bound_regions(value, |br| {\n-            let _ = start_or_continue(f, \"for<\", \", \");\n+            let _ = start_or_continue(self, \"for<\", \", \");\n             let br = match br {\n                 ty::BrNamed(_, name) => {\n-                    let _ = write!(f, \"{}\", name);\n+                    let _ = print!(self, write(\"{}\", name));\n                     br\n                 }\n                 ty::BrAnon(_) |\n@@ -478,18 +471,18 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n                             break name;\n                         }\n                     };\n-                    let _ = write!(f, \"{}\", name);\n+                    let _ = print!(self, write(\"{}\", name));\n                     ty::BrNamed(self.tcx.hir().local_def_id(CRATE_NODE_ID), name)\n                 }\n             };\n             self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n         }).0;\n-        start_or_continue(f, \"\", \"> \")?;\n+        start_or_continue(self, \"\", \"> \")?;\n \n         // Push current state to gcx, and restore after writing new_value.\n         self.binder_depth += 1;\n         self.region_index = region_index;\n-        let result = new_value.print_display(f, self);\n+        let result = new_value.print_display(self);\n         self.region_index = old_region_index;\n         self.binder_depth -= 1;\n         result\n@@ -504,20 +497,21 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n }\n \n pub fn parameterized<F: fmt::Write>(f: &mut F, did: DefId, substs: SubstsRef<'_>) -> fmt::Result {\n-    PrintCx::with(|mut cx| {\n+    PrintCx::with(FmtPrinter { fmt: f }, |mut cx| {\n         let substs = cx.tcx.lift(&substs).expect(\"could not lift for printing\");\n-        cx.parameterized(f, did, substs, iter::empty())\n+        cx.parameterized(did, substs, iter::empty())\n     })\n }\n \n-impl<'a, 'tcx, T: Print<'tcx>> Print<'tcx> for &'a T {\n-    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, 'tcx>) -> fmt::Result {\n-        (*self).print(f, cx)\n+impl<'a, 'tcx, P, T: Print<'tcx, P>> Print<'tcx, P> for &'a T {\n+    type Output = T::Output;\n+    fn print(&self, cx: &mut PrintCx<'_, '_, 'tcx, P>) -> Self::Output {\n+        (*self).print(cx)\n     }\n }\n \n define_print! {\n-    ('tcx) &'tcx ty::List<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n+    ('tcx) &'tcx ty::List<ty::ExistentialPredicate<'tcx>>, (self, cx) {\n         display {\n             // Generate the main trait ref, including associated types.\n             let mut first = true;\n@@ -530,8 +524,8 @@ define_print! {\n                     if let Tuple(ref args) = principal.substs.type_at(0).sty {\n                         let mut projections = self.projection_bounds();\n                         if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                            print!(f, cx, write(\"{}\", cx.tcx.item_path_str(principal.def_id)))?;\n-                            cx.fn_sig(f, args, false, proj.ty)?;\n+                            print!(cx, write(\"{}\", cx.tcx.item_path_str(principal.def_id)))?;\n+                            cx.fn_sig(args, false, proj.ty)?;\n                             resugared_principal = true;\n                         }\n                     }\n@@ -542,7 +536,6 @@ define_print! {\n                     let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n                     let principal = principal.with_self_ty(cx.tcx, dummy_self);\n                     cx.parameterized(\n-                        f,\n                         principal.def_id,\n                         principal.substs,\n                         self.projection_bounds(),\n@@ -567,11 +560,11 @@ define_print! {\n \n             for auto_trait in auto_traits {\n                 if !first {\n-                    write!(f, \" + \")?;\n+                    print!(cx, write(\" + \"))?;\n                 }\n                 first = false;\n \n-                write!(f, \"{}\", auto_trait)?;\n+                print!(cx, write(\"{}\", auto_trait))?;\n             }\n \n             Ok(())\n@@ -596,16 +589,16 @@ impl fmt::Debug for ty::GenericParamDef {\n \n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with(|cx| {\n-            write!(f, \"{}\", cx.tcx.item_path_str(self.def_id))\n+        PrintCx::with(FmtPrinter { fmt: f }, |cx| {\n+            print!(cx, write(\"{}\", cx.tcx.item_path_str(self.def_id)))\n         })\n     }\n }\n \n impl fmt::Debug for ty::AdtDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with(|cx| {\n-            write!(f, \"{}\", cx.tcx.item_path_str(self.did))\n+        PrintCx::with(FmtPrinter { fmt: f }, |cx| {\n+            print!(cx, write(\"{}\", cx.tcx.item_path_str(self.did)))\n         })\n     }\n }\n@@ -620,12 +613,12 @@ impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n \n impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n-               self.var_path.hir_id,\n-               PrintCx::with(|cx| {\n-                    cx.tcx.hir().name_by_hir_id(self.var_path.hir_id)\n-               }),\n-               self.closure_expr_id)\n+        PrintCx::with(FmtPrinter { fmt: f }, |cx| {\n+            print!(cx, write(\"UpvarId({:?};`{}`;{:?})\",\n+                self.var_path.hir_id,\n+                cx.tcx.hir().name_by_hir_id(self.var_path.hir_id),\n+                self.closure_expr_id))\n+        })\n     }\n }\n \n@@ -637,86 +630,86 @@ impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n }\n \n define_print! {\n-    ('tcx) &'tcx ty::List<Ty<'tcx>>, (self, f, cx) {\n+    ('tcx) &'tcx ty::List<Ty<'tcx>>, (self, cx) {\n         display {\n-            write!(f, \"{{\")?;\n+            print!(cx, write(\"{{\"))?;\n             let mut tys = self.iter();\n             if let Some(&ty) = tys.next() {\n-                print!(f, cx, print(ty))?;\n+                print!(cx, print(ty))?;\n                 for &ty in tys {\n-                    print!(f, cx, write(\", \"), print(ty))?;\n+                    print!(cx, write(\", \"), print(ty))?;\n                 }\n             }\n-            write!(f, \"}}\")\n+            print!(cx, write(\"}}\"))\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::TypeAndMut<'tcx>, (self, f, cx) {\n+    ('tcx) ty::TypeAndMut<'tcx>, (self, cx) {\n         display {\n-            print!(f, cx,\n+            print!(cx,\n                    write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n                    print(self.ty))\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::ExistentialTraitRef<'tcx>, (self, f, cx) {\n+    ('tcx) ty::ExistentialTraitRef<'tcx>, (self, cx) {\n         display {\n             let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n \n             let trait_ref = *ty::Binder::bind(*self)\n                 .with_self_ty(cx.tcx, dummy_self)\n                 .skip_binder();\n-            cx.parameterized(f, trait_ref.def_id, trait_ref.substs, iter::empty())\n+            cx.parameterized(trait_ref.def_id, trait_ref.substs, iter::empty())\n         }\n         debug {\n-            self.print_display(f, cx)\n+            self.print_display(cx)\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::adjustment::Adjustment<'tcx>, (self, f, cx) {\n+    ('tcx) ty::adjustment::Adjustment<'tcx>, (self, cx) {\n         debug {\n-            print!(f, cx, write(\"{:?} -> \", self.kind), print(self.target))\n+            print!(cx, write(\"{:?} -> \", self.kind), print(self.target))\n         }\n     }\n }\n \n define_print! {\n-    () ty::BoundRegion, (self, f, cx) {\n+    () ty::BoundRegion, (self, cx) {\n         display {\n             if cx.is_verbose {\n-                return self.print_debug(f, cx);\n+                return self.print_debug(cx);\n             }\n \n             if let BrNamed(_, name) = *self {\n                 if name != \"\" && name != \"'_\" {\n-                    return write!(f, \"{}\", name);\n+                    return print!(cx, write(\"{}\", name));\n                 }\n             }\n \n             let highlight = RegionHighlightMode::get();\n             if let Some((region, counter)) = highlight.highlight_bound_region {\n                 if *self == region {\n-                    return write!(f, \"'{}\", counter);\n+                    return print!(cx, write(\"'{}\", counter));\n                 }\n             }\n \n             Ok(())\n         }\n         debug {\n             return match *self {\n-                BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n-                BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n+                BrAnon(n) => print!(cx, write(\"BrAnon({:?})\", n)),\n+                BrFresh(n) => print!(cx, write(\"BrFresh({:?})\", n)),\n                 BrNamed(did, name) => {\n-                    write!(f, \"BrNamed({:?}:{:?}, {})\",\n-                           did.krate, did.index, name)\n+                    print!(cx, write(\"BrNamed({:?}:{:?}, {})\",\n+                           did.krate, did.index, name))\n                 }\n-                BrEnv => write!(f, \"BrEnv\"),\n+                BrEnv => print!(cx, write(\"BrEnv\")),\n             };\n         }\n     }\n@@ -726,7 +719,7 @@ define_print! {\n //\n // NB: this must be kept in sync with the printing logic above.\n impl ty::BoundRegion {\n-    fn display_outputs_anything(&self, cx: &mut PrintCx<'_, '_, '_>) -> bool {\n+    fn display_outputs_anything<P>(&self, cx: &mut PrintCx<'_, '_, '_, P>) -> bool {\n         if cx.is_verbose {\n             return true;\n         }\n@@ -749,18 +742,18 @@ impl ty::BoundRegion {\n }\n \n define_print! {\n-    () ty::PlaceholderRegion, (self, f, cx) {\n+    () ty::PlaceholderRegion, (self, cx) {\n         display {\n             if cx.is_verbose {\n-                return self.print_debug(f, cx);\n+                return self.print_debug(cx);\n             }\n \n             let highlight = RegionHighlightMode::get();\n             if let Some(counter) = highlight.placeholder_highlight(*self) {\n-                return write!(f, \"'{}\", counter);\n+                return print!(cx, write(\"'{}\", counter));\n             }\n \n-            write!(f, \"{}\", self.name)\n+            print!(cx, print_display(self.name))\n         }\n     }\n }\n@@ -769,7 +762,7 @@ define_print! {\n //\n // NB: this must be kept in sync with the printing logic above.\n impl ty::PlaceholderRegion {\n-    fn display_outputs_anything(&self, cx: &mut PrintCx<'_, '_, '_>) -> bool {\n+    fn display_outputs_anything<P>(&self, cx: &mut PrintCx<'_, '_, '_, P>) -> bool {\n         if cx.is_verbose {\n             return true;\n         }\n@@ -784,15 +777,15 @@ impl ty::PlaceholderRegion {\n }\n \n define_print! {\n-    () ty::RegionKind, (self, f, cx) {\n+    () ty::RegionKind, (self, cx) {\n         display {\n             if cx.is_verbose {\n-                return self.print_debug(f, cx);\n+                return self.print_debug(cx);\n             }\n \n             // Watch out for region highlights.\n             if let Some(n) = RegionHighlightMode::get().region_highlighted(self) {\n-                return write!(f, \"'{:?}\", n);\n+                return print!(cx, write(\"'{:?}\", n));\n             }\n \n             // These printouts are concise.  They do not contain all the information\n@@ -802,89 +795,88 @@ define_print! {\n             match *self {\n                 ty::ReEarlyBound(ref data) => {\n                     if data.name != \"'_\" {\n-                        write!(f, \"{}\", data.name)\n+                        print!(cx, write(\"{}\", data.name))\n                     } else {\n                         Ok(())\n                     }\n                 }\n                 ty::ReLateBound(_, br) |\n                 ty::ReFree(ty::FreeRegion { bound_region: br, .. }) => {\n-                    write!(f, \"{}\", br)\n+                    print!(cx, print_display(br))\n                 }\n                 ty::RePlaceholder(p) => {\n-                    write!(f, \"{}\", p)\n+                    print!(cx, print_display(p))\n                 }\n                 ty::ReScope(scope) if cx.identify_regions => {\n                     match scope.data {\n                         region::ScopeData::Node =>\n-                            write!(f, \"'{}s\", scope.item_local_id().as_usize()),\n+                            print!(cx, write(\"'{}s\", scope.item_local_id().as_usize())),\n                         region::ScopeData::CallSite =>\n-                            write!(f, \"'{}cs\", scope.item_local_id().as_usize()),\n+                            print!(cx, write(\"'{}cs\", scope.item_local_id().as_usize())),\n                         region::ScopeData::Arguments =>\n-                            write!(f, \"'{}as\", scope.item_local_id().as_usize()),\n+                            print!(cx, write(\"'{}as\", scope.item_local_id().as_usize())),\n                         region::ScopeData::Destruction =>\n-                            write!(f, \"'{}ds\", scope.item_local_id().as_usize()),\n-                        region::ScopeData::Remainder(first_statement_index) => write!(\n-                            f,\n+                            print!(cx, write(\"'{}ds\", scope.item_local_id().as_usize())),\n+                        region::ScopeData::Remainder(first_statement_index) => print!(cx, write(\n                             \"'{}_{}rs\",\n                             scope.item_local_id().as_usize(),\n                             first_statement_index.index()\n-                        ),\n+                        )),\n                     }\n                 }\n                 ty::ReVar(region_vid) if cx.identify_regions => {\n-                    write!(f, \"{:?}\", region_vid)\n+                    print!(cx, print_debug(region_vid))\n                 }\n                 ty::ReVar(region_vid) => {\n-                    write!(f, \"{}\", region_vid)\n+                    print!(cx, print_display(region_vid))\n                 }\n                 ty::ReScope(_) |\n                 ty::ReErased => Ok(()),\n-                ty::ReStatic => write!(f, \"'static\"),\n-                ty::ReEmpty => write!(f, \"'<empty>\"),\n+                ty::ReStatic => print!(cx, write(\"'static\")),\n+                ty::ReEmpty => print!(cx, write(\"'<empty>\")),\n \n                 // The user should never encounter these in unsubstituted form.\n-                ty::ReClosureBound(vid) => write!(f, \"{:?}\", vid),\n+                ty::ReClosureBound(vid) => print!(cx, write(\"{:?}\", vid)),\n             }\n         }\n         debug {\n             match *self {\n                 ty::ReEarlyBound(ref data) => {\n-                    write!(f, \"ReEarlyBound({}, {})\",\n+                    print!(cx, write(\"ReEarlyBound({}, {})\",\n                            data.index,\n-                           data.name)\n+                           data.name))\n                 }\n \n                 ty::ReClosureBound(ref vid) => {\n-                    write!(f, \"ReClosureBound({:?})\",\n-                           vid)\n+                    print!(cx, write(\"ReClosureBound({:?})\",\n+                           vid))\n                 }\n \n                 ty::ReLateBound(binder_id, ref bound_region) => {\n-                    write!(f, \"ReLateBound({:?}, {:?})\",\n+                    print!(cx, write(\"ReLateBound({:?}, {:?})\",\n                            binder_id,\n-                           bound_region)\n+                           bound_region))\n                 }\n \n-                ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n+                ty::ReFree(ref fr) => print!(cx, write(\"{:?}\", fr)),\n \n                 ty::ReScope(id) => {\n-                    write!(f, \"ReScope({:?})\", id)\n+                    print!(cx, write(\"ReScope({:?})\", id))\n                 }\n \n-                ty::ReStatic => write!(f, \"ReStatic\"),\n+                ty::ReStatic => print!(cx, write(\"ReStatic\")),\n \n                 ty::ReVar(ref vid) => {\n-                    write!(f, \"{:?}\", vid)\n+                    print!(cx, write(\"{:?}\", vid))\n                 }\n \n                 ty::RePlaceholder(placeholder) => {\n-                    write!(f, \"RePlaceholder({:?})\", placeholder)\n+                    print!(cx, write(\"RePlaceholder({:?})\", placeholder))\n                 }\n \n-                ty::ReEmpty => write!(f, \"ReEmpty\"),\n+                ty::ReEmpty => print!(cx, write(\"ReEmpty\")),\n \n-                ty::ReErased => write!(f, \"ReErased\")\n+                ty::ReErased => print!(cx, write(\"ReErased\"))\n             }\n         }\n     }\n@@ -897,7 +889,7 @@ define_print! {\n //\n // NB: this must be kept in sync with the printing logic above.\n impl ty::RegionKind {\n-    fn display_outputs_anything(&self, cx: &mut PrintCx<'_, '_, '_>) -> bool {\n+    fn display_outputs_anything<P>(&self, cx: &mut PrintCx<'_, '_, '_, P>) -> bool {\n         if cx.is_verbose {\n             return true;\n         }\n@@ -934,17 +926,17 @@ impl ty::RegionKind {\n }\n \n define_print! {\n-    () ty::FreeRegion, (self, f, cx) {\n+    () ty::FreeRegion, (self, cx) {\n         debug {\n-            write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)\n+            print!(cx, write(\"ReFree({:?}, {:?})\", self.scope, self.bound_region))\n         }\n     }\n }\n \n define_print! {\n-    () ty::Variance, (self, f, cx) {\n+    () ty::Variance, (self, cx) {\n         debug {\n-            f.write_str(match *self {\n+            cx.printer.fmt.write_str(match *self {\n                 ty::Covariant => \"+\",\n                 ty::Contravariant => \"-\",\n                 ty::Invariant => \"o\",\n@@ -955,21 +947,22 @@ define_print! {\n }\n \n define_print! {\n-    ('tcx) ty::FnSig<'tcx>, (self, f, cx) {\n+    ('tcx) ty::FnSig<'tcx>, (self, cx) {\n         display {\n             if self.unsafety == hir::Unsafety::Unsafe {\n-                write!(f, \"unsafe \")?;\n+                print!(cx, write(\"unsafe \"))?;\n             }\n \n             if self.abi != Abi::Rust {\n-                write!(f, \"extern {} \", self.abi)?;\n+                print!(cx, write(\"extern {} \", self.abi))?;\n             }\n \n-            write!(f, \"fn\")?;\n-            cx.fn_sig(f, self.inputs(), self.c_variadic, self.output())\n+            print!(cx, write(\"fn\"))?;\n+            cx.fn_sig(self.inputs(), self.c_variadic, self.output())\n         }\n         debug {\n-            write!(f, \"({:?}; c_variadic: {})->{:?}\", self.inputs(), self.c_variadic, self.output())\n+            print!(cx, write(\"({:?}; c_variadic: {})->{:?}\",\n+                self.inputs(), self.c_variadic, self.output()))\n         }\n     }\n }\n@@ -999,15 +992,15 @@ impl fmt::Debug for ty::FloatVid {\n }\n \n define_print! {\n-    () ty::RegionVid, (self, f, cx) {\n+    () ty::RegionVid, (self, cx) {\n         display {\n             if cx.is_verbose {\n-                return self.print_debug(f, cx);\n+                return self.print_debug(cx);\n             }\n \n             let highlight = RegionHighlightMode::get();\n             if let Some(counter) = highlight.region_highlighted(&ty::ReVar(*self)) {\n-                return write!(f, \"'{:?}\", counter);\n+                return print!(cx, write(\"'{:?}\", counter));\n             }\n \n             Ok(())\n@@ -1017,10 +1010,10 @@ define_print! {\n             // to keep NLL borrowck working even with `-Zverbose`.\n             let highlight = RegionHighlightMode::get();\n             if let Some(counter) = highlight.region_highlighted(&ty::ReVar(*self)) {\n-                return write!(f, \"'{:?}\", counter);\n+                return print!(cx, write(\"'{:?}\", counter));\n             }\n \n-            write!(f, \"'_#{}r\", self.index())\n+            print!(cx, write(\"'_#{}r\", self.index()))\n         }\n     }\n }\n@@ -1029,7 +1022,7 @@ define_print! {\n //\n // NB: this must be kept in sync with the printing logic above.\n impl ty::RegionVid {\n-    fn display_outputs_anything(&self, cx: &mut PrintCx<'_, '_, '_>) -> bool {\n+    fn display_outputs_anything<P>(&self, cx: &mut PrintCx<'_, '_, '_, P>) -> bool {\n         if cx.is_verbose {\n             return true;\n         }\n@@ -1044,28 +1037,28 @@ impl ty::RegionVid {\n }\n \n define_print! {\n-    () ty::InferTy, (self, f, cx) {\n+    () ty::InferTy, (self, cx) {\n         display {\n             if cx.is_verbose {\n-                return self.print_debug(f, cx);\n+                return self.print_debug(cx);\n             }\n             match *self {\n-                ty::TyVar(_) => write!(f, \"_\"),\n-                ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n-                ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n-                ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n-                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+                ty::TyVar(_) => print!(cx, write(\"_\")),\n+                ty::IntVar(_) => print!(cx, write(\"{}\", \"{integer}\")),\n+                ty::FloatVar(_) => print!(cx, write(\"{}\", \"{float}\")),\n+                ty::FreshTy(v) => print!(cx, write(\"FreshTy({})\", v)),\n+                ty::FreshIntTy(v) => print!(cx, write(\"FreshIntTy({})\", v)),\n+                ty::FreshFloatTy(v) => print!(cx, write(\"FreshFloatTy({})\", v))\n             }\n         }\n         debug {\n             match *self {\n-                ty::TyVar(ref v) => write!(f, \"{:?}\", v),\n-                ty::IntVar(ref v) => write!(f, \"{:?}\", v),\n-                ty::FloatVar(ref v) => write!(f, \"{:?}\", v),\n-                ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n-                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n-                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n+                ty::TyVar(ref v) => print!(cx, write(\"{:?}\", v)),\n+                ty::IntVar(ref v) => print!(cx, write(\"{:?}\", v)),\n+                ty::FloatVar(ref v) => print!(cx, write(\"{:?}\", v)),\n+                ty::FreshTy(v) => print!(cx, write(\"FreshTy({:?})\", v)),\n+                ty::FreshIntTy(v) => print!(cx, write(\"FreshIntTy({:?})\", v)),\n+                ty::FreshFloatTy(v) => print!(cx, write(\"FreshFloatTy({:?})\", v))\n             }\n         }\n     }\n@@ -1093,7 +1086,7 @@ impl fmt::Debug for ty::FloatVarValue {\n           for<'a> <T as ty::Lift<'a>>::Lifted: fmt::Display + TypeFoldable<'a>\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with(|cx| cx.in_binder(f, cx.tcx.lift(self)\n+        PrintCx::with(|cx| cx.in_binder(cx.tcx.lift(self)\n             .expect(\"could not lift for printing\")))\n     }\n }*/\n@@ -1109,136 +1102,131 @@ define_print_multi! {\n     ('tcx) ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n     ('tcx) ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>\n     ]\n-    (self, f, cx) {\n+    (self, cx) {\n         display {\n-            cx.in_binder(f, self)\n+            cx.in_binder(self)\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::TraitRef<'tcx>, (self, f, cx) {\n+    ('tcx) ty::TraitRef<'tcx>, (self, cx) {\n         display {\n-            cx.parameterized(f, self.def_id, self.substs, iter::empty())\n+            cx.parameterized(self.def_id, self.substs, iter::empty())\n         }\n         debug {\n-            // when printing out the debug representation, we don't need\n-            // to enumerate the `for<...>` etc because the debruijn index\n-            // tells you everything you need to know.\n-            print!(f, cx,\n-                   write(\"<\"),\n-                   print(self.self_ty()),\n-                   write(\" as \"))?;\n-            cx.parameterized(f, self.def_id, self.substs, iter::empty())?;\n-            write!(f, \">\")\n+            print!(cx, write(\"<\"), print(self.self_ty()), write(\" as \"))?;\n+            cx.parameterized(self.def_id, self.substs, iter::empty())?;\n+            print!(cx, write(\">\"))\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::Ty<'tcx>, (self, f, cx) {\n+    ('tcx) ty::Ty<'tcx>, (self, cx) {\n         display {\n             match self.sty {\n-                Bool => write!(f, \"bool\"),\n-                Char => write!(f, \"char\"),\n-                Int(t) => write!(f, \"{}\", t.ty_to_string()),\n-                Uint(t) => write!(f, \"{}\", t.ty_to_string()),\n-                Float(t) => write!(f, \"{}\", t.ty_to_string()),\n+                Bool => print!(cx, write(\"bool\")),\n+                Char => print!(cx, write(\"char\")),\n+                Int(t) => print!(cx, write(\"{}\", t.ty_to_string())),\n+                Uint(t) => print!(cx, write(\"{}\", t.ty_to_string())),\n+                Float(t) => print!(cx, write(\"{}\", t.ty_to_string())),\n                 RawPtr(ref tm) => {\n-                    write!(f, \"*{} \", match tm.mutbl {\n+                    print!(cx, write(\"*{} \", match tm.mutbl {\n                         hir::MutMutable => \"mut\",\n                         hir::MutImmutable => \"const\",\n-                    })?;\n-                    tm.ty.print(f, cx)\n+                    }))?;\n+                    tm.ty.print(cx)\n                 }\n                 Ref(r, ty, mutbl) => {\n-                    write!(f, \"&\")?;\n+                    print!(cx, write(\"&\"))?;\n                     if r.display_outputs_anything(cx) {\n-                        print!(f, cx, print_display(r), write(\" \"))?;\n+                        print!(cx, print_display(r), write(\" \"))?;\n                     }\n-                    ty::TypeAndMut { ty, mutbl }.print(f, cx)\n+                    ty::TypeAndMut { ty, mutbl }.print(cx)\n                 }\n-                Never => write!(f, \"!\"),\n+                Never => print!(cx, write(\"!\")),\n                 Tuple(ref tys) => {\n-                    write!(f, \"(\")?;\n+                    print!(cx, write(\"(\"))?;\n                     let mut tys = tys.iter();\n                     if let Some(&ty) = tys.next() {\n-                        print!(f, cx, print(ty), write(\",\"))?;\n+                        print!(cx, print(ty), write(\",\"))?;\n                         if let Some(&ty) = tys.next() {\n-                            print!(f, cx, write(\" \"), print(ty))?;\n+                            print!(cx, write(\" \"), print(ty))?;\n                             for &ty in tys {\n-                                print!(f, cx, write(\", \"), print(ty))?;\n+                                print!(cx, write(\", \"), print(ty))?;\n                             }\n                         }\n                     }\n-                    write!(f, \")\")\n+                    print!(cx, write(\")\"))\n                 }\n                 FnDef(def_id, substs) => {\n                     let sig = cx.tcx.fn_sig(def_id).subst(cx.tcx, substs);\n-                    print!(f, cx, print(sig), write(\" {{\"))?;\n-                    cx.parameterized(f, def_id, substs, iter::empty())?;\n-                    write!(f, \"}}\")\n+                    print!(cx, print(sig), write(\" {{\"))?;\n+                    cx.parameterized(def_id, substs, iter::empty())?;\n+                    print!(cx, write(\"}}\"))\n                 }\n                 FnPtr(ref bare_fn) => {\n-                    bare_fn.print(f, cx)\n+                    bare_fn.print(cx)\n                 }\n-                Infer(infer_ty) => write!(f, \"{}\", infer_ty),\n-                Error => write!(f, \"[type error]\"),\n-                Param(ref param_ty) => write!(f, \"{}\", param_ty),\n+                Infer(infer_ty) => print!(cx, write(\"{}\", infer_ty)),\n+                Error => print!(cx, write(\"[type error]\")),\n+                Param(ref param_ty) => print!(cx, write(\"{}\", param_ty)),\n                 Bound(debruijn, bound_ty) => {\n                     match bound_ty.kind {\n                         ty::BoundTyKind::Anon => {\n                             if debruijn == ty::INNERMOST {\n-                                write!(f, \"^{}\", bound_ty.var.index())\n+                                print!(cx, write(\"^{}\", bound_ty.var.index()))\n                             } else {\n-                                write!(f, \"^{}_{}\", debruijn.index(), bound_ty.var.index())\n+                                print!(cx, write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n                             }\n                         }\n \n-                        ty::BoundTyKind::Param(p) => write!(f, \"{}\", p),\n+                        ty::BoundTyKind::Param(p) => print!(cx, write(\"{}\", p)),\n                     }\n                 }\n-                Adt(def, substs) => cx.parameterized(f, def.did, substs, iter::empty()),\n+                Adt(def, substs) => cx.parameterized(def.did, substs, iter::empty()),\n                 Dynamic(data, r) => {\n                     let print_r = r.display_outputs_anything(cx);\n                     if print_r {\n-                        write!(f, \"(\")?;\n+                        print!(cx, write(\"(\"))?;\n                     }\n-                    write!(f, \"dyn \")?;\n-                    data.print(f, cx)?;\n+                    print!(cx, write(\"dyn \"))?;\n+                    data.print(cx)?;\n                     if print_r {\n-                        print!(f, cx, write(\" + \"), print_display(r), write(\")\"))?;\n+                        print!(cx, write(\" + \"), print_display(r), write(\")\"))?;\n                     }\n                     Ok(())\n                 }\n                 Foreign(def_id) => {\n-                    cx.parameterized(f, def_id, subst::InternalSubsts::empty(), iter::empty())\n+                    cx.parameterized(def_id, subst::InternalSubsts::empty(), iter::empty())\n                 }\n-                Projection(ref data) => data.print(f, cx),\n+                Projection(ref data) => data.print(cx),\n                 UnnormalizedProjection(ref data) => {\n-                    write!(f, \"Unnormalized(\")?;\n-                    data.print(f, cx)?;\n-                    write!(f, \")\")\n+                    print!(cx, write(\"Unnormalized(\"))?;\n+                    data.print(cx)?;\n+                    print!(cx, write(\")\"))\n                 }\n                 Placeholder(placeholder) => {\n-                    write!(f, \"Placeholder({:?})\", placeholder)\n+                    print!(cx, write(\"Placeholder({:?})\", placeholder))\n                 }\n                 Opaque(def_id, substs) => {\n                     if cx.is_verbose {\n-                        return write!(f, \"Opaque({:?}, {:?})\", def_id, substs);\n+                        return print!(cx, write(\"Opaque({:?}, {:?})\", def_id, substs));\n                     }\n \n                     let def_key = cx.tcx.def_key(def_id);\n                     if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                        write!(f, \"{}\", name)?;\n+                        print!(cx, write(\"{}\", name))?;\n                         let mut substs = substs.iter();\n+                        // FIXME(eddyb) print this with `parameterized`.\n                         if let Some(first) = substs.next() {\n-                            write!(f, \"::<\")?;\n-                            write!(f, \"{}\", first)?;\n+                            print!(cx, write(\"::<\"))?;\n+                            print!(cx, write(\"{}\", first))?;\n                             for subst in substs {\n-                                write!(f, \", {}\", subst)?;\n+                                print!(cx, write(\", {}\", subst))?;\n                             }\n-                            write!(f, \">\")?;\n+                            print!(cx, write(\">\"))?;\n                         }\n                         return Ok(());\n                     }\n@@ -1248,7 +1236,7 @@ define_print! {\n \n                     let mut first = true;\n                     let mut is_sized = false;\n-                    write!(f, \"impl\")?;\n+                    print!(cx, write(\"impl\"))?;\n                     for predicate in bounds.predicates {\n                         if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n                             // Don't print +Sized, but rather +?Sized if absent.\n@@ -1257,35 +1245,36 @@ define_print! {\n                                 continue;\n                             }\n \n-                            print!(f, cx,\n+                            print!(cx,\n                                     write(\"{}\", if first { \" \" } else { \"+\" }),\n                                     print(trait_ref))?;\n                             first = false;\n                         }\n                     }\n                     if !is_sized {\n-                        write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n-                        } else if first {\n-                            write!(f, \" Sized\")?;\n+                        print!(cx, write(\"{}?Sized\", if first { \" \" } else { \"+\" }))?;\n+                    } else if first {\n+                        print!(cx, write(\" Sized\"))?;\n                     }\n                     Ok(())\n                 }\n-                Str => write!(f, \"str\"),\n+                Str => print!(cx, write(\"str\")),\n                 Generator(did, substs, movability) => {\n                     let upvar_tys = substs.upvar_tys(did, cx.tcx);\n                     let witness = substs.witness(did, cx.tcx);\n                     if movability == hir::GeneratorMovability::Movable {\n-                        write!(f, \"[generator\")?;\n+                        print!(cx, write(\"[generator\"))?;\n                     } else {\n-                        write!(f, \"[static generator\")?;\n+                        print!(cx, write(\"[static generator\"))?;\n                     }\n \n+                    // FIXME(eddyb) should use `def_span`.\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n-                        write!(f, \"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id))?;\n+                        print!(cx, write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)))?;\n                         let mut sep = \" \";\n                         cx.tcx.with_freevars(hir_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                                print!(f, cx,\n+                                print!(cx,\n                                        write(\"{}{}:\",\n                                              sep,\n                                              cx.tcx.hir().name(freevar.var_id())),\n@@ -1297,35 +1286,36 @@ define_print! {\n                     } else {\n                         // cross-crate closure types should only be\n                         // visible in codegen bug reports, I imagine.\n-                        write!(f, \"@{:?}\", did)?;\n+                        print!(cx, write(\"@{:?}\", did))?;\n                         let mut sep = \" \";\n                         for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            print!(f, cx,\n+                            print!(cx,\n                                    write(\"{}{}:\", sep, index),\n                                    print(upvar_ty))?;\n                             sep = \", \";\n                         }\n                     }\n \n-                    print!(f, cx, write(\" \"), print(witness), write(\"]\"))\n+                    print!(cx, write(\" \"), print(witness), write(\"]\"))\n                 },\n                 GeneratorWitness(types) => {\n-                    cx.in_binder(f, &types)\n+                    cx.in_binder(&types)\n                 }\n                 Closure(did, substs) => {\n                     let upvar_tys = substs.upvar_tys(did, cx.tcx);\n-                    write!(f, \"[closure\")?;\n+                    print!(cx, write(\"[closure\"))?;\n \n+                    // FIXME(eddyb) should use `def_span`.\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n                         if cx.tcx.sess.opts.debugging_opts.span_free_formats {\n-                            write!(f, \"@{:?}\", hir_id)?;\n+                            print!(cx, write(\"@{:?}\", hir_id))?;\n                         } else {\n-                            write!(f, \"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id))?;\n+                            print!(cx, write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)))?;\n                         }\n                         let mut sep = \" \";\n                         cx.tcx.with_freevars(hir_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                                print!(f, cx,\n+                                print!(cx,\n                                        write(\"{}{}:\",\n                                              sep,\n                                              cx.tcx.hir().name(freevar.var_id())),\n@@ -1337,104 +1327,104 @@ define_print! {\n                     } else {\n                         // cross-crate closure types should only be\n                         // visible in codegen bug reports, I imagine.\n-                        write!(f, \"@{:?}\", did)?;\n+                        print!(cx, write(\"@{:?}\", did))?;\n                         let mut sep = \" \";\n                         for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            print!(f, cx,\n+                            print!(cx,\n                                    write(\"{}{}:\", sep, index),\n                                    print(upvar_ty))?;\n                             sep = \", \";\n                         }\n                     }\n \n                     if cx.is_verbose {\n-                        write!(\n-                            f,\n+                        print!(cx, write(\n                             \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n                             substs.closure_kind_ty(did, cx.tcx),\n-                            substs.closure_sig_ty(did, cx.tcx),\n-                        )?;\n+                            substs.closure_sig_ty(did, cx.tcx)\n+                        ))?;\n                     }\n \n-                    write!(f, \"]\")\n+                    print!(cx, write(\"]\"))\n                 },\n                 Array(ty, sz) => {\n-                    print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n+                    print!(cx, write(\"[\"), print(ty), write(\"; \"))?;\n                     match sz {\n                         ty::LazyConst::Unevaluated(_def_id, _substs) => {\n-                            write!(f, \"_\")?;\n+                            print!(cx, write(\"_\"))?;\n                         }\n                         ty::LazyConst::Evaluated(c) => {\n                             match c.val {\n-                                ConstValue::Infer(..) => write!(f, \"_\")?,\n+                                ConstValue::Infer(..) => print!(cx, write(\"_\"))?,\n                                 ConstValue::Param(ParamConst { name, .. }) =>\n-                                    write!(f, \"{}\", name)?,\n-                                _ => write!(f, \"{}\", c.unwrap_usize(cx.tcx))?,\n+                                    print!(cx, write(\"{}\", name))?,\n+                                _ => print!(cx, write(\"{}\", c.unwrap_usize(cx.tcx)))?,\n                             }\n                         }\n                     }\n-                    write!(f, \"]\")\n+                    print!(cx, write(\"]\"))\n                 }\n                 Slice(ty) => {\n-                    print!(f, cx, write(\"[\"), print(ty), write(\"]\"))\n+                    print!(cx, write(\"[\"), print(ty), write(\"]\"))\n                 }\n             }\n         }\n         debug {\n-            self.print_display(f, cx)\n+            self.print_display(cx)\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ConstValue<'tcx>, (self, f, cx) {\n+    ('tcx) ConstValue<'tcx>, (self, cx) {\n         display {\n             match self {\n-                ConstValue::Infer(..) => write!(f, \"_\"),\n-                ConstValue::Param(ParamConst { name, .. }) => write!(f, \"{}\", name),\n-                _ => write!(f, \"{:?}\", self),\n+                ConstValue::Infer(..) => print!(cx, write(\"_\")),\n+                ConstValue::Param(ParamConst { name, .. }) => print!(cx, write(\"{}\", name)),\n+                _ => print!(cx, write(\"{:?}\", self)),\n             }\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::Const<'tcx>, (self, f, cx) {\n+    ('tcx) ty::Const<'tcx>, (self, cx) {\n         display {\n-            write!(f, \"{} : {}\", self.val, self.ty)\n+            print!(cx, write(\"{} : {}\", self.val, self.ty))\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::LazyConst<'tcx>, (self, f, cx) {\n+    ('tcx) ty::LazyConst<'tcx>, (self, cx) {\n         display {\n             match self {\n-                ty::LazyConst::Unevaluated(..) => write!(f, \"_ : _\"),\n-                ty::LazyConst::Evaluated(c) => write!(f, \"{}\", c),\n+                // FIXME(const_generics) this should print at least the type.\n+                ty::LazyConst::Unevaluated(..) => print!(cx, write(\"_ : _\")),\n+                ty::LazyConst::Evaluated(c) => print!(cx, write(\"{}\", c)),\n             }\n         }\n     }\n }\n \n define_print! {\n-    () ty::ParamTy, (self, f, cx) {\n+    () ty::ParamTy, (self, cx) {\n         display {\n-            write!(f, \"{}\", self.name)\n+            print!(cx, write(\"{}\", self.name))\n         }\n         debug {\n-            write!(f, \"{}/#{}\", self.name, self.idx)\n+            print!(cx, write(\"{}/#{}\", self.name, self.idx))\n         }\n     }\n }\n \n define_print! {\n-    () ty::ParamConst, (self, f, cx) {\n+    () ty::ParamConst, (self, cx) {\n         display {\n-            write!(f, \"{}\", self.name)\n+            print!(cx, write(\"{}\", self.name))\n         }\n         debug {\n-            write!(f, \"{}/#{}\", self.name, self.index)\n+            print!(cx, write(\"{}/#{}\", self.name, self.index))\n         }\n     }\n }\n@@ -1445,129 +1435,131 @@ define_print_multi! {\n     ('tcx) ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>,\n     ('tcx) ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n     ]\n-    (self, f, cx) {\n+    (self, cx) {\n         display {\n-            print!(f, cx, print(self.0), write(\" : \"), print(self.1))\n+            print!(cx, print(self.0), write(\" : \"), print(self.1))\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::SubtypePredicate<'tcx>, (self, f, cx) {\n+    ('tcx) ty::SubtypePredicate<'tcx>, (self, cx) {\n         display {\n-            print!(f, cx, print(self.a), write(\" <: \"), print(self.b))\n+            print!(cx, print(self.a), write(\" <: \"), print(self.b))\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::TraitPredicate<'tcx>, (self, f, cx) {\n+    ('tcx) ty::TraitPredicate<'tcx>, (self, cx) {\n         debug {\n-            write!(f, \"TraitPredicate({:?})\",\n-                   self.trait_ref)\n+            print!(cx, write(\"TraitPredicate({:?})\",\n+                   self.trait_ref))\n         }\n         display {\n-            print!(f, cx, print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n+            print!(cx, print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::ProjectionPredicate<'tcx>, (self, f, cx) {\n+    ('tcx) ty::ProjectionPredicate<'tcx>, (self, cx) {\n         debug {\n-            print!(f, cx,\n+            print!(cx,\n                    write(\"ProjectionPredicate(\"),\n                    print(self.projection_ty),\n                    write(\", \"),\n                    print(self.ty),\n                    write(\")\"))\n         }\n         display {\n-            print!(f, cx, print(self.projection_ty), write(\" == \"), print(self.ty))\n+            print!(cx, print(self.projection_ty), write(\" == \"), print(self.ty))\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::ProjectionTy<'tcx>, (self, f, cx) {\n+    ('tcx) ty::ProjectionTy<'tcx>, (self, cx) {\n         display {\n-            cx.parameterized(f, self.item_def_id, self.substs, iter::empty())\n+            cx.parameterized(self.item_def_id, self.substs, iter::empty())\n         }\n     }\n }\n \n define_print! {\n-    () ty::ClosureKind, (self, f, cx) {\n+    () ty::ClosureKind, (self, cx) {\n         display {\n             match *self {\n-                ty::ClosureKind::Fn => write!(f, \"Fn\"),\n-                ty::ClosureKind::FnMut => write!(f, \"FnMut\"),\n-                ty::ClosureKind::FnOnce => write!(f, \"FnOnce\"),\n+                ty::ClosureKind::Fn => print!(cx, write(\"Fn\")),\n+                ty::ClosureKind::FnMut => print!(cx, write(\"FnMut\")),\n+                ty::ClosureKind::FnOnce => print!(cx, write(\"FnOnce\")),\n             }\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) ty::Predicate<'tcx>, (self, f, cx) {\n+    ('tcx) ty::Predicate<'tcx>, (self, cx) {\n         display {\n             match *self {\n-                ty::Predicate::Trait(ref data) => data.print(f, cx),\n-                ty::Predicate::Subtype(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::RegionOutlives(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::TypeOutlives(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::Projection(ref predicate) => predicate.print(f, cx),\n-                ty::Predicate::WellFormed(ty) => print!(f, cx, print(ty), write(\" well-formed\")),\n+                ty::Predicate::Trait(ref data) => data.print(cx),\n+                ty::Predicate::Subtype(ref predicate) => predicate.print(cx),\n+                ty::Predicate::RegionOutlives(ref predicate) => predicate.print(cx),\n+                ty::Predicate::TypeOutlives(ref predicate) => predicate.print(cx),\n+                ty::Predicate::Projection(ref predicate) => predicate.print(cx),\n+                ty::Predicate::WellFormed(ty) => print!(cx, print(ty), write(\" well-formed\")),\n                 ty::Predicate::ObjectSafe(trait_def_id) => {\n-                    write!(f, \"the trait `{}` is object-safe\", cx.tcx.item_path_str(trait_def_id))\n+                    print!(cx, write(\"the trait `{}` is object-safe\",\n+                        cx.tcx.item_path_str(trait_def_id)))\n                 }\n                 ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n-                    write!(f, \"the closure `{}` implements the trait `{}`\",\n-                           cx.tcx.item_path_str(closure_def_id), kind)\n+                    print!(cx, write(\"the closure `{}` implements the trait `{}`\",\n+                           cx.tcx.item_path_str(closure_def_id), kind))\n                 }\n                 ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                    write!(f, \"the constant `\")?;\n-                    cx.parameterized(f, def_id, substs, iter::empty())?;\n-                    write!(f, \"` can be evaluated\")\n+                    print!(cx, write(\"the constant `\"))?;\n+                    cx.parameterized(def_id, substs, iter::empty())?;\n+                    print!(cx, write(\"` can be evaluated\"))\n                 }\n             }\n         }\n         debug {\n             match *self {\n-                ty::Predicate::Trait(ref a) => a.print(f, cx),\n-                ty::Predicate::Subtype(ref pair) => pair.print(f, cx),\n-                ty::Predicate::RegionOutlives(ref pair) => pair.print(f, cx),\n-                ty::Predicate::TypeOutlives(ref pair) => pair.print(f, cx),\n-                ty::Predicate::Projection(ref pair) => pair.print(f, cx),\n-                ty::Predicate::WellFormed(ty) => ty.print(f, cx),\n+                ty::Predicate::Trait(ref a) => a.print(cx),\n+                ty::Predicate::Subtype(ref pair) => pair.print(cx),\n+                ty::Predicate::RegionOutlives(ref pair) => pair.print(cx),\n+                ty::Predicate::TypeOutlives(ref pair) => pair.print(cx),\n+                ty::Predicate::Projection(ref pair) => pair.print(cx),\n+                ty::Predicate::WellFormed(ty) => ty.print(cx),\n                 ty::Predicate::ObjectSafe(trait_def_id) => {\n-                    write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+                    print!(cx, write(\"ObjectSafe({:?})\", trait_def_id))\n                 }\n                 ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                    write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n+                    print!(cx, write(\"ClosureKind({:?}, {:?}, {:?})\",\n+                        closure_def_id, closure_substs, kind))\n                 }\n                 ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                    write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n+                    print!(cx, write(\"ConstEvaluatable({:?}, {:?})\", def_id, substs))\n                 }\n             }\n         }\n     }\n }\n \n define_print! {\n-    ('tcx) Kind<'tcx>, (self, f, cx) {\n+    ('tcx) Kind<'tcx>, (self, cx) {\n         display {\n             match self.unpack() {\n-                UnpackedKind::Lifetime(lt) => print!(f, cx, print(lt)),\n-                UnpackedKind::Type(ty) => print!(f, cx, print(ty)),\n-                UnpackedKind::Const(ct) => print!(f, cx, print(ct)),\n+                UnpackedKind::Lifetime(lt) => print!(cx, print(lt)),\n+                UnpackedKind::Type(ty) => print!(cx, print(ty)),\n+                UnpackedKind::Const(ct) => print!(cx, print(ct)),\n             }\n         }\n         debug {\n             match self.unpack() {\n-                UnpackedKind::Lifetime(lt) => print!(f, cx, print(lt)),\n-                UnpackedKind::Type(ty) => print!(f, cx, print(ty)),\n-                UnpackedKind::Const(ct) => print!(f, cx, print(ct)),\n+                UnpackedKind::Lifetime(lt) => print!(cx, print(lt)),\n+                UnpackedKind::Type(ty) => print!(cx, print(ty)),\n+                UnpackedKind::Const(ct) => print!(cx, print(ct)),\n             }\n         }\n     }"}, {"sha": "466cf40a15795b85bb4376764bf0cc69031b3a3a", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "patch": "@@ -4,6 +4,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(custom_attribute)]"}, {"sha": "6bd9b159775e3bfb27b5b231a215e63148067c09", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "patch": "@@ -225,8 +225,7 @@ fn get_symbol_hash<'a, 'tcx>(\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     item_path::with_forced_absolute_paths(|| {\n-        let mut cx = PrintCx::new(tcx);\n-        SymbolPathPrinter::print_item_path(&mut cx, def_id).into_interned()\n+        PrintCx::new(tcx, SymbolPathPrinter).print_item_path(def_id).into_interned()\n     })\n }\n \n@@ -401,17 +400,21 @@ struct SymbolPathPrinter;\n impl ItemPathPrinter for SymbolPathPrinter {\n     type Path = SymbolPath;\n \n-    fn path_crate(cx: &mut PrintCx<'_, '_, '_>, cnum: CrateNum) -> Self::Path {\n-        let mut path = SymbolPath::new(cx.tcx);\n-        path.push(&cx.tcx.original_crate_name(cnum).as_str());\n+    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n+        let mut path = SymbolPath::new(self.tcx);\n+        path.push(&self.tcx.original_crate_name(cnum).as_str());\n         path\n     }\n-    fn path_impl(cx: &mut PrintCx<'_, '_, '_>, text: &str) -> Self::Path {\n-        let mut path = SymbolPath::new(cx.tcx);\n+    fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n+        let mut path = SymbolPath::new(self.tcx);\n         path.push(text);\n         path\n     }\n-    fn path_append(mut path: Self::Path, text: &str) -> Self::Path {\n+    fn path_append(\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n+        mut path: Self::Path,\n+        text: &str,\n+    ) -> Self::Path {\n         path.push(text);\n         path\n     }"}, {"sha": "d321697f713f88156897eb7bbd95e41a935dc9d7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "patch": "@@ -4233,20 +4233,23 @@ where F: Fn(DefId) -> Def {\n     impl ItemPathPrinter for AbsolutePathPrinter {\n         type Path = Vec<String>;\n \n-        fn path_crate(cx: &mut PrintCx<'_, '_, '_>, cnum: CrateNum) -> Self::Path {\n-            vec![cx.tcx.original_crate_name(cnum).to_string()]\n+        fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n+            vec![self.tcx.original_crate_name(cnum).to_string()]\n         }\n-        fn path_impl(_: &mut PrintCx<'_, '_, '_>, text: &str) -> Self::Path {\n+        fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n             vec![text.to_string()]\n         }\n-        fn path_append(mut path: Self::Path, text: &str) -> Self::Path {\n+        fn path_append(\n+            self: &mut PrintCx<'_, '_, '_, Self>,\n+            mut path: Self::Path,\n+            text: &str,\n+        ) -> Self::Path {\n             path.push(text.to_string());\n             path\n         }\n     }\n \n-    let mut cx = PrintCx::new(tcx);\n-    let names = AbsolutePathPrinter::print_item_path(&mut cx, def_id);\n+    let names = PrintCx::new(tcx, AbsolutePathPrinter).print_item_path(def_id);\n \n     hir::Path {\n         span: DUMMY_SP,"}, {"sha": "58ba827ee05f3d4268ec4af6e968cb683770761d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d27441ecc96a56e1b0e72c0accbced2ce6a7d3/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=08d27441ecc96a56e1b0e72c0accbced2ce6a7d3", "patch": "@@ -5,6 +5,7 @@\n \n #![feature(bind_by_move_pattern_guards)]\n #![feature(rustc_private)]\n+#![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(nll)]"}]}