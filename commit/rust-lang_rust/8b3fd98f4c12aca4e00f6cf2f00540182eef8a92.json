{"sha": "8b3fd98f4c12aca4e00f6cf2f00540182eef8a92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiM2ZkOThmNGMxMmFjYTRlMDBmNmNmMmYwMDU0MDE4MmVlZjhhOTI=", "commit": {"author": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2017-12-15T15:32:00Z"}, "committer": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2018-01-26T17:46:04Z"}, "message": "libtest: rustfmt run\n\nlibtest: Whoops", "tree": {"sha": "c86cd4276f8cc4294289fbe2cca0f060346ce48d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c86cd4276f8cc4294289fbe2cca0f060346ce48d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b3fd98f4c12aca4e00f6cf2f00540182eef8a92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b3fd98f4c12aca4e00f6cf2f00540182eef8a92", "html_url": "https://github.com/rust-lang/rust/commit/8b3fd98f4c12aca4e00f6cf2f00540182eef8a92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b3fd98f4c12aca4e00f6cf2f00540182eef8a92/comments", "author": null, "committer": null, "parents": [{"sha": "94bd1216bb735514118670878d28081f8493d1ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/94bd1216bb735514118670878d28081f8493d1ac", "html_url": "https://github.com/rust-lang/rust/commit/94bd1216bb735514118670878d28081f8493d1ac"}], "stats": {"total": 1323, "additions": 747, "deletions": 576}, "files": [{"sha": "59228146e6be40588f6819d08eafe72f5b545d47", "filename": "src/libtest/formatters.rs", "status": "modified", "additions": 101, "deletions": 77, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/8b3fd98f4c12aca4e00f6cf2f00540182eef8a92/src%2Flibtest%2Fformatters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3fd98f4c12aca4e00f6cf2f00540182eef8a92/src%2Flibtest%2Fformatters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters.rs?ref=8b3fd98f4c12aca4e00f6cf2f00540182eef8a92", "patch": "@@ -14,10 +14,12 @@ pub(crate) trait OutputFormatter {\n     fn write_run_start(&mut self, test_count: usize) -> io::Result<()>;\n     fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()>;\n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()>;\n-    fn write_result(&mut self,\n-                    desc: &TestDesc,\n-                    result: &TestResult,\n-                    stdout: &[u8]) -> io::Result<()>;\n+    fn write_result(\n+        &mut self,\n+        desc: &TestDesc,\n+        result: &TestResult,\n+        stdout: &[u8],\n+    ) -> io::Result<()>;\n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n }\n \n@@ -34,11 +36,13 @@ pub(crate) struct HumanFormatter<T> {\n }\n \n impl<T: Write> HumanFormatter<T> {\n-    pub fn new(out: OutputLocation<T>,\n-                use_color: bool,\n-                terse: bool,\n-                max_name_len: usize,\n-                is_multithreaded: bool) -> Self {\n+    pub fn new(\n+        out: OutputLocation<T>,\n+        use_color: bool,\n+        terse: bool,\n+        max_name_len: usize,\n+        is_multithreaded: bool,\n+    ) -> Self {\n         HumanFormatter {\n             out,\n             terse,\n@@ -74,8 +78,12 @@ impl<T: Write> HumanFormatter<T> {\n         self.write_pretty(\"bench\", term::color::CYAN)\n     }\n \n-    pub fn write_short_result(&mut self, verbose: &str, quiet: &str, color: term::color::Color)\n-                              -> io::Result<()> {\n+    pub fn write_short_result(\n+        &mut self,\n+        verbose: &str,\n+        quiet: &str,\n+        color: term::color::Color,\n+    ) -> io::Result<()> {\n         if self.terse {\n             self.write_pretty(quiet, color)?;\n             if self.test_count % QUIET_MODE_MAX_COLUMN == QUIET_MODE_MAX_COLUMN - 1 {\n@@ -182,11 +190,7 @@ impl<T: Write> HumanFormatter<T> {\n \n impl<T: Write> OutputFormatter for HumanFormatter<T> {\n     fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n-        let noun = if test_count != 1 {\n-            \"tests\"\n-        } else {\n-            \"test\"\n-        };\n+        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n         self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n     }\n \n@@ -224,9 +228,11 @@ impl<T: Write> OutputFormatter for HumanFormatter<T> {\n             self.write_test_name(desc)?;\n         }\n \n-        self.write_plain(&format!(\"test {} has been running for over {} seconds\\n\",\n-                                  desc.name,\n-                                  TEST_WARN_TIMEOUT_S))\n+        self.write_plain(&format!(\n+            \"test {} has been running for over {} seconds\\n\",\n+            desc.name,\n+            TEST_WARN_TIMEOUT_S\n+        ))\n     }\n \n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n@@ -255,15 +261,17 @@ impl<T: Write> OutputFormatter for HumanFormatter<T> {\n                 state.allowed_fail,\n                 state.ignored,\n                 state.measured,\n-                state.filtered_out)\n+                state.filtered_out\n+            )\n         } else {\n             format!(\n                 \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n                 state.passed,\n                 state.failed,\n                 state.ignored,\n                 state.measured,\n-                state.filtered_out)\n+                state.filtered_out\n+            )\n         };\n \n         self.write_plain(&s)?;\n@@ -273,7 +281,7 @@ impl<T: Write> OutputFormatter for HumanFormatter<T> {\n }\n \n pub(crate) struct JsonFormatter<T> {\n-    out: OutputLocation<T>\n+    out: OutputLocation<T>,\n }\n \n impl<T: Write> JsonFormatter<T> {\n@@ -288,108 +296,121 @@ impl<T: Write> JsonFormatter<T> {\n         self.out.write_all(b\"\\n\")\n     }\n \n-    fn write_event(&mut self,\n-                    ty: &str,\n-                    name: &str,\n-                    evt: &str,\n-                    extra: Option<String>) -> io::Result<()> {\n+    fn write_event(\n+        &mut self,\n+        ty: &str,\n+        name: &str,\n+        evt: &str,\n+        extra: Option<String>,\n+    ) -> io::Result<()> {\n         if let Some(extras) = extra {\n-            self.write_message(&*format!(r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n-                                    ty,\n-                                    name,\n-                                    evt,\n-                                    extras))\n-        }\n-        else {\n-            self.write_message(&*format!(r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n-                                    ty,\n-                                    name,\n-                                    evt))\n+            self.write_message(&*format!(\n+                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n+                ty,\n+                name,\n+                evt,\n+                extras\n+            ))\n+        } else {\n+            self.write_message(&*format!(\n+                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n+                ty,\n+                name,\n+                evt\n+            ))\n         }\n     }\n }\n \n impl<T: Write> OutputFormatter for JsonFormatter<T> {\n     fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n-        self.write_message(\n-            &*format!(r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"{}\" }}\"#,\n-                        test_count))\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"{}\" }}\"#,\n+            test_count\n+        ))\n     }\n \n     fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_message(&*format!(r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n-                                desc.name))\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n+            desc.name\n+        ))\n     }\n \n-    fn write_result(&mut self,\n-                        desc: &TestDesc,\n-                        result: &TestResult,\n-                        stdout: &[u8]) -> io::Result<()> {\n+    fn write_result(\n+        &mut self,\n+        desc: &TestDesc,\n+        result: &TestResult,\n+        stdout: &[u8],\n+    ) -> io::Result<()> {\n         match *result {\n-            TrOk => {\n-                self.write_event(\"test\", desc.name.as_slice(), \"ok\", None)\n-            },\n+            TrOk => self.write_event(\"test\", desc.name.as_slice(), \"ok\", None),\n \n             TrFailed => {\n                 let extra_data = if stdout.len() > 0 {\n-                    Some(format!(r#\"\"stdout\": \"{}\"\"#,\n-                        EscapedString(String::from_utf8_lossy(stdout))))\n-                }\n-                else {\n+                    Some(format!(\n+                        r#\"\"stdout\": \"{}\"\"#,\n+                        EscapedString(String::from_utf8_lossy(stdout))\n+                    ))\n+                } else {\n                     None\n                 };\n \n                 self.write_event(\"test\", desc.name.as_slice(), \"failed\", extra_data)\n-            },\n+            }\n \n             TrFailedMsg(ref m) => {\n-                self.write_event(\"test\",\n-                                    desc.name.as_slice(),\n-                                    \"failed\",\n-                                    Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))))\n-            },\n+                self.write_event(\n+                    \"test\",\n+                    desc.name.as_slice(),\n+                    \"failed\",\n+                    Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n+                )\n+            }\n \n-            TrIgnored => {\n-                self.write_event(\"test\", desc.name.as_slice(), \"ignored\", None)\n-            },\n+            TrIgnored => self.write_event(\"test\", desc.name.as_slice(), \"ignored\", None),\n \n             TrAllowedFail => {\n                 self.write_event(\"test\", desc.name.as_slice(), \"allowed_failure\", None)\n-            },\n+            }\n \n             TrBench(ref bs) => {\n                 let median = bs.ns_iter_summ.median as usize;\n                 let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n \n                 let mbps = if bs.mb_s == 0 {\n                     \"\".into()\n-                }\n-                else {\n+                } else {\n                     format!(r#\", \"mib_per_second\": {}\"#, bs.mb_s)\n                 };\n \n-                let line = format!(\"{{ \\\"type\\\": \\\"bench\\\", \\\n+                let line = format!(\n+                    \"{{ \\\"type\\\": \\\"bench\\\", \\\n                                 \\\"name\\\": \\\"{}\\\", \\\n                                 \\\"median\\\": {}, \\\n                                 \\\"deviation\\\": {}{} }}\",\n-                        desc.name,\n-                        median,\n-                        deviation,\n-                        mbps);\n+                    desc.name,\n+                    median,\n+                    deviation,\n+                    mbps\n+                );\n \n                 self.write_message(&*line)\n-            },\n+            }\n         }\n     }\n \n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_message(&*format!(r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n-                        desc.name))\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n+            desc.name\n+        ))\n     }\n \n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n \n-        self.write_message(&*format!(\"{{ \\\"type\\\": \\\"suite\\\", \\\n+        self.write_message(&*format!(\n+            \"{{ \\\"type\\\": \\\"suite\\\", \\\n             \\\"event\\\": \\\"{}\\\", \\\n             \\\"passed\\\": {}, \\\n             \\\"failed\\\": {}, \\\n@@ -403,7 +424,8 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n             state.allowed_fail,\n             state.ignored,\n             state.measured,\n-            state.filtered_out))?;\n+            state.filtered_out\n+        ))?;\n \n         Ok(state.failed == 0)\n     }\n@@ -454,7 +476,9 @@ impl<S: AsRef<str>> ::std::fmt::Display for EscapedString<S> {\n                 b'\\x1e' => \"\\\\u001e\",\n                 b'\\x1f' => \"\\\\u001f\",\n                 b'\\x7f' => \"\\\\u007f\",\n-                _ => { continue; }\n+                _ => {\n+                    continue;\n+                }\n             };\n \n             if start < i {"}, {"sha": "4da89f5ab4b3c2bef2b178dbfae342802cda753f", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 383, "deletions": 258, "changes": 641, "blob_url": "https://github.com/rust-lang/rust/blob/8b3fd98f4c12aca4e00f6cf2f00540182eef8a92/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3fd98f4c12aca4e00f6cf2f00540182eef8a92/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=8b3fd98f4c12aca4e00f6cf2f00540182eef8a92", "patch": "@@ -240,10 +240,7 @@ pub struct Metric {\n \n impl Metric {\n     pub fn new(value: f64, noise: f64) -> Metric {\n-        Metric {\n-            value,\n-            noise,\n-        }\n+        Metric { value, noise }\n     }\n }\n \n@@ -255,9 +252,7 @@ pub struct Options {\n \n impl Options {\n     pub fn new() -> Options {\n-        Options {\n-            display_output: false,\n-        }\n+        Options { display_output: false }\n     }\n \n     pub fn display_output(mut self, display_output: bool) -> Options {\n@@ -297,25 +292,24 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n // rather than a &[].\n pub fn test_main_static(tests: &[TestDescAndFn]) {\n     let args = env::args().collect::<Vec<_>>();\n-    let owned_tests = tests.iter()\n-                           .map(|t| {\n-                               match t.testfn {\n-                                   StaticTestFn(f) => {\n-                                       TestDescAndFn {\n-                                           testfn: StaticTestFn(f),\n-                                           desc: t.desc.clone(),\n-                                       }\n-                                   }\n-                                   StaticBenchFn(f) => {\n-                                       TestDescAndFn {\n-                                           testfn: StaticBenchFn(f),\n-                                           desc: t.desc.clone(),\n-                                       }\n-                                   }\n-                                   _ => panic!(\"non-static tests passed to test::test_main_static\"),\n-                               }\n-                           })\n-                           .collect();\n+    let owned_tests = tests\n+        .iter()\n+        .map(|t| match t.testfn {\n+            StaticTestFn(f) => {\n+                TestDescAndFn {\n+                    testfn: StaticTestFn(f),\n+                    desc: t.desc.clone(),\n+                }\n+            }\n+            StaticBenchFn(f) => {\n+                TestDescAndFn {\n+                    testfn: StaticBenchFn(f),\n+                    desc: t.desc.clone(),\n+                }\n+            }\n+            _ => panic!(\"non-static tests passed to test::test_main_static\"),\n+        })\n+        .collect();\n     test_main(&args, owned_tests, Options::new())\n }\n \n@@ -330,7 +324,7 @@ pub enum ColorConfig {\n pub enum OutputFormat {\n     Pretty,\n     Terse,\n-    Json\n+    Json,\n }\n \n #[derive(Debug)]\n@@ -381,33 +375,76 @@ fn optgroups() -> getopts::Options {\n         .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n         .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n         .optflag(\"h\", \"help\", \"Display this message (longer with --help)\")\n-        .optopt(\"\", \"logfile\", \"Write logs to the specified file instead \\\n-                                of stdout\", \"PATH\")\n-        .optflag(\"\", \"nocapture\", \"don't capture stdout/stderr of each \\\n-                                   task, allow printing directly\")\n-        .optopt(\"\", \"test-threads\", \"Number of threads used for running tests \\\n-                                     in parallel\", \"n_threads\")\n-        .optmulti(\"\", \"skip\", \"Skip tests whose names contain FILTER (this flag can \\\n-                               be used multiple times)\",\"FILTER\")\n-        .optflag(\"q\", \"quiet\", \"Display one character per test instead of one line. \\\n-                                Alias to --format=terse\")\n-        .optflag(\"\", \"exact\", \"Exactly match filters rather than by substring\")\n-        .optopt(\"\", \"color\", \"Configure coloring of output:\n+        .optopt(\n+            \"\",\n+            \"logfile\",\n+            \"Write logs to the specified file instead \\\n+                                of stdout\",\n+            \"PATH\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"nocapture\",\n+            \"don't capture stdout/stderr of each \\\n+                                   task, allow printing directly\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"test-threads\",\n+            \"Number of threads used for running tests \\\n+                                     in parallel\",\n+            \"n_threads\",\n+        )\n+        .optmulti(\n+            \"\",\n+            \"skip\",\n+            \"Skip tests whose names contain FILTER (this flag can \\\n+                               be used multiple times)\",\n+            \"FILTER\",\n+        )\n+        .optflag(\n+            \"q\",\n+            \"quiet\",\n+            \"Display one character per test instead of one line. \\\n+                                Alias to --format=terse\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"exact\",\n+            \"Exactly match filters rather than by substring\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"color\",\n+            \"Configure coloring of output:\n             auto   = colorize if stdout is a tty and tests are run on serially (default);\n             always = always colorize output;\n-            never  = never colorize output;\", \"auto|always|never\")\n-        .optopt(\"\", \"format\", \"Configure formatting of output:\n+            never  = never colorize output;\",\n+            \"auto|always|never\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"format\",\n+            \"Configure formatting of output:\n             pretty = Print verbose output;\n             terse  = Display one character per test;\n-            json   = Output a json document\", \"pretty|terse|json\")\n-        .optopt(\"Z\", \"\", \"Enable nightly-only flags:\n-            unstable-options = Allow use of experimental features\", \"unstable-options\");\n-    return opts\n+            json   = Output a json document\",\n+            \"pretty|terse|json\",\n+        )\n+        .optopt(\n+            \"Z\",\n+            \"\",\n+            \"Enable nightly-only flags:\n+            unstable-options = Allow use of experimental features\",\n+            \"unstable-options\",\n+        );\n+    return opts;\n }\n \n fn usage(binary: &str, options: &getopts::Options) {\n     let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n-    println!(r#\"{usage}\n+    println!(\n+        r#\"{usage}\n \n The FILTER string is tested against the name of all tests, and only those\n tests whose names contain the filter are run.\n@@ -434,7 +471,8 @@ Test Attributes:\n                      test, then the test runner will ignore these tests during\n                      normal test runs. Running with --ignored will run these\n                      tests.\"#,\n-             usage = options.usage(&message));\n+        usage = options.usage(&message)\n+    );\n }\n \n // FIXME: Copied from libsyntax until linkage errors are resolved.\n@@ -459,7 +497,10 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n \n     if let Some(opt) = matches.opt_str(\"Z\") {\n         if !is_nightly() {\n-            return Some(Err(\"the option `Z` is only accepted on the nightly compiler\".into()));\n+            return Some(Err(\n+                \"the option `Z` is only accepted on the nightly compiler\"\n+                    .into(),\n+            ));\n         }\n \n         match &*opt {\n@@ -498,22 +539,25 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     if !nocapture {\n         nocapture = match env::var(\"RUST_TEST_NOCAPTURE\") {\n             Ok(val) => &val != \"0\",\n-            Err(_) => false\n+            Err(_) => false,\n         };\n     }\n \n     let test_threads = match matches.opt_str(\"test-threads\") {\n-        Some(n_str) =>\n+        Some(n_str) => {\n             match n_str.parse::<usize>() {\n-                Ok(0) =>\n-                    return Some(Err(format!(\"argument for --test-threads must not be 0\"))),\n+                Ok(0) => return Some(Err(format!(\"argument for --test-threads must not be 0\"))),\n                 Ok(n) => Some(n),\n-                Err(e) =>\n-                    return Some(Err(format!(\"argument for --test-threads must be a number > 0 \\\n-                                             (error: {})\", e)))\n-            },\n-        None =>\n-            None,\n+                Err(e) => {\n+                    return Some(Err(format!(\n+                        \"argument for --test-threads must be a number > 0 \\\n+                                             (error: {})\",\n+                        e\n+                    )))\n+                }\n+            }\n+        }\n+        None => None,\n     };\n \n     let color = match matches.opt_str(\"color\").as_ref().map(|s| &**s) {\n@@ -522,9 +566,11 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         Some(\"never\") => NeverColor,\n \n         Some(v) => {\n-            return Some(Err(format!(\"argument for --color must be auto, always, or never (was \\\n+            return Some(Err(format!(\n+                \"argument for --color must be auto, always, or never (was \\\n                                      {})\",\n-                                    v)))\n+                v\n+            )))\n         }\n     };\n \n@@ -534,16 +580,20 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         Some(\"terse\") => OutputFormat::Terse,\n         Some(\"json\") => {\n             if !allow_unstable {\n-                return Some(\n-                    Err(\"The \\\"json\\\" format is only accepted on the nightly compiler\".into()));\n+                return Some(Err(\n+                    \"The \\\"json\\\" format is only accepted on the nightly compiler\"\n+                        .into(),\n+                ));\n             }\n             OutputFormat::Json\n-        },\n+        }\n \n         Some(v) => {\n-            return Some(Err(format!(\"argument for --format must be pretty, terse, or json (was \\\n+            return Some(Err(format!(\n+                \"argument for --format must be pretty, terse, or json (was \\\n                                      {})\",\n-                                    v)))\n+                v\n+            )))\n         }\n     };\n \n@@ -593,14 +643,14 @@ impl<T: Write> Write for OutputLocation<T> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         match *self {\n             Pretty(ref mut term) => term.write(buf),\n-            Raw(ref mut stdout) => stdout.write(buf)\n+            Raw(ref mut stdout) => stdout.write(buf),\n         }\n     }\n \n     fn flush(&mut self) -> io::Result<()> {\n         match *self {\n             Pretty(ref mut term) => term.flush(),\n-            Raw(ref mut stdout) => stdout.flush()\n+            Raw(ref mut stdout) => stdout.flush(),\n         }\n     }\n }\n@@ -652,17 +702,18 @@ impl ConsoleTestState {\n     }\n \n     pub fn write_log_result(&mut self, test: &TestDesc, result: &TestResult) -> io::Result<()> {\n-        self.write_log(\n-            format!(\"{} {}\\n\",\n-                    match *result {\n-                        TrOk => \"ok\".to_owned(),\n-                        TrFailed => \"failed\".to_owned(),\n-                        TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n-                        TrIgnored => \"ignored\".to_owned(),\n-                        TrAllowedFail => \"failed (allowed)\".to_owned(),\n-                        TrBench(ref bs) => fmt_bench_samples(bs),\n-                    },\n-                    test.name))\n+        self.write_log(format!(\n+            \"{} {}\\n\",\n+            match *result {\n+                TrOk => \"ok\".to_owned(),\n+                TrFailed => \"failed\".to_owned(),\n+                TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n+                TrIgnored => \"ignored\".to_owned(),\n+                TrAllowedFail => \"failed (allowed)\".to_owned(),\n+                TrBench(ref bs) => fmt_bench_samples(bs),\n+            },\n+            test.name\n+        ))\n     }\n \n     fn current_test_count(&self) -> usize {\n@@ -701,12 +752,17 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n     let median = bs.ns_iter_summ.median as usize;\n     let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n \n-    output.write_fmt(format_args!(\"{:>11} ns/iter (+/- {})\",\n-                                  fmt_thousands_sep(median, ','),\n-                                  fmt_thousands_sep(deviation, ',')))\n-          .unwrap();\n+    output\n+        .write_fmt(format_args!(\n+            \"{:>11} ns/iter (+/- {})\",\n+            fmt_thousands_sep(median, ','),\n+            fmt_thousands_sep(deviation, ',')\n+        ))\n+        .unwrap();\n     if bs.mb_s != 0 {\n-        output.write_fmt(format_args!(\" = {} MB/s\", bs.mb_s)).unwrap();\n+        output\n+            .write_fmt(format_args!(\" = {} MB/s\", bs.mb_s))\n+            .unwrap();\n     }\n     output\n }\n@@ -728,11 +784,21 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n     for test in filter_tests(&opts, tests) {\n         use TestFn::*;\n \n-        let TestDescAndFn { desc: TestDesc { name, .. }, testfn } = test;\n+        let TestDescAndFn {\n+            desc: TestDesc { name, .. },\n+            testfn,\n+        } = test;\n \n         let fntype = match testfn {\n-            StaticTestFn(..) | DynTestFn(..) => { ntest += 1; \"test\" },\n-            StaticBenchFn(..) | DynBenchFn(..) => { nbench += 1; \"benchmark\" },\n+            StaticTestFn(..) | DynTestFn(..) => {\n+                ntest += 1;\n+                \"test\"\n+            }\n+            StaticBenchFn(..) |\n+            DynBenchFn(..) => {\n+                nbench += 1;\n+                \"benchmark\"\n+            }\n         };\n \n         out.write_plain(format!(\"{}: {}\\n\", name, fntype))?;\n@@ -750,9 +816,11 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n         if ntest != 0 || nbench != 0 {\n             out.write_plain(\"\\n\")?;\n         }\n-        out.write_plain(format!(\"{}, {}\\n\",\n+        out.write_plain(format!(\n+            \"{}, {}\\n\",\n             plural(ntest, \"test\"),\n-            plural(nbench, \"benchmark\")))?;\n+            plural(nbench, \"benchmark\")\n+        ))?;\n     }\n \n     Ok(())\n@@ -769,15 +837,17 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         tests\n     };\n \n-    fn callback(event: &TestEvent,\n-                st: &mut ConsoleTestState,\n-                out: &mut OutputFormatter) -> io::Result<()> {\n+    fn callback(\n+        event: &TestEvent,\n+        st: &mut ConsoleTestState,\n+        out: &mut OutputFormatter,\n+    ) -> io::Result<()> {\n \n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => {\n                 st.total = filtered_tests.len();\n                 out.write_run_start(filtered_tests.len())\n-            },\n+            }\n             TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n             TeWait(ref test) => out.write_test_start(test),\n             TeTimeout(ref test) => out.write_timeout(test),\n@@ -792,9 +862,11 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n                     TrIgnored => st.ignored += 1,\n                     TrAllowedFail => st.allowed_fail += 1,\n                     TrBench(bs) => {\n-                        st.metrics.insert_metric(test.name.as_slice(),\n-                                                 bs.ns_iter_summ.median,\n-                                                 bs.ns_iter_summ.max - bs.ns_iter_summ.min);\n+                        st.metrics.insert_metric(\n+                            test.name.as_slice(),\n+                            bs.ns_iter_summ.median,\n+                            bs.ns_iter_summ.max - bs.ns_iter_summ.min,\n+                        );\n                         st.measured += 1\n                     }\n                     TrFailed => {\n@@ -804,9 +876,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n                     TrFailedMsg(msg) => {\n                         st.failed += 1;\n                         let mut stdout = stdout;\n-                        stdout.extend_from_slice(\n-                            format!(\"note: {}\", msg).as_bytes()\n-                        );\n+                        stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n                         st.failures.push((test, stdout));\n                     }\n                 }\n@@ -820,27 +890,32 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         Some(t) => Pretty(t),\n     };\n \n-    let max_name_len = tests.iter()\n-                        .max_by_key(|t| len_if_padded(*t))\n-                        .map(|t| t.desc.name.as_slice().len())\n-                        .unwrap_or(0);\n+    let max_name_len = tests\n+        .iter()\n+        .max_by_key(|t| len_if_padded(*t))\n+        .map(|t| t.desc.name.as_slice().len())\n+        .unwrap_or(0);\n \n     let is_multithreaded = match opts.test_threads {\n         Some(n) => n > 1,\n         None => get_concurrency() > 1,\n     };\n \n     let mut out: Box<OutputFormatter> = match opts.format {\n-        OutputFormat::Pretty => Box::new(HumanFormatter::new(output,\n-                                                                use_color(opts),\n-                                                                false,\n-                                                                max_name_len,\n-                                                                is_multithreaded)),\n-        OutputFormat::Terse => Box::new(HumanFormatter::new(output,\n-                                                                use_color(opts),\n-                                                                true,\n-                                                                max_name_len,\n-                                                                is_multithreaded)),\n+        OutputFormat::Pretty => Box::new(HumanFormatter::new(\n+            output,\n+            use_color(opts),\n+            false,\n+            max_name_len,\n+            is_multithreaded,\n+        )),\n+        OutputFormat::Terse => Box::new(HumanFormatter::new(\n+            output,\n+            use_color(opts),\n+            true,\n+            max_name_len,\n+            is_multithreaded,\n+        )),\n         OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n     };\n     let mut st = ConsoleTestState::new(opts)?;\n@@ -874,7 +949,7 @@ fn should_sort_failures_before_printing_them() {\n         allow_fail: false,\n     };\n \n-    let mut out = HumanFormatter::new(Raw(Vec::new()), false, false, 10);\n+    let mut out = HumanFormatter::new(Raw(Vec::new()), false, false, 10, false);\n \n     let st = ConsoleTestState {\n         log_out: None,\n@@ -952,7 +1027,8 @@ pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n \n \n pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n-    where F: FnMut(TestEvent) -> io::Result<()>\n+where\n+    F: FnMut(TestEvent) -> io::Result<()>,\n {\n     use std::collections::HashMap;\n     use std::sync::mpsc::RecvTimeoutError;\n@@ -967,18 +1043,14 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n     let filtered_out = tests_len - filtered_tests.len();\n     callback(TeFilteredOut(filtered_out))?;\n \n-    let filtered_descs = filtered_tests.iter()\n-                                       .map(|t| t.desc.clone())\n-                                       .collect();\n+    let filtered_descs = filtered_tests.iter().map(|t| t.desc.clone()).collect();\n \n     callback(TeFiltered(filtered_descs))?;\n \n     let (filtered_tests, filtered_benchs): (Vec<_>, _) =\n-        filtered_tests.into_iter().partition(|e| {\n-            match e.testfn {\n-                StaticTestFn(_) | DynTestFn(_) => true,\n-                _ => false,\n-            }\n+        filtered_tests.into_iter().partition(|e| match e.testfn {\n+            StaticTestFn(_) | DynTestFn(_) => true,\n+            _ => false,\n         });\n \n     let concurrency = match opts.test_threads {\n@@ -996,8 +1068,13 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n \n     fn get_timed_out_tests(running_tests: &mut HashMap<TestDesc, Instant>) -> Vec<TestDesc> {\n         let now = Instant::now();\n-        let timed_out = running_tests.iter()\n-            .filter_map(|(desc, timeout)| if &now >= timeout { Some(desc.clone())} else { None })\n+        let timed_out = running_tests\n+            .iter()\n+            .filter_map(|(desc, timeout)| if &now >= timeout {\n+                Some(desc.clone())\n+            } else {\n+                None\n+            })\n             .collect();\n         for test in &timed_out {\n             running_tests.remove(test);\n@@ -1012,7 +1089,8 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n                 *next_timeout - now\n             } else {\n                 Duration::new(0, 0)\n-            }})\n+            }\n+        })\n     };\n \n     if concurrency == 1 {\n@@ -1078,8 +1156,10 @@ fn get_concurrency() -> usize {\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => {\n-                    panic!(\"RUST_TEST_THREADS is `{}`, should be a positive integer.\",\n-                           s)\n+                    panic!(\n+                        \"RUST_TEST_THREADS is `{}`, should be a positive integer.\",\n+                        s\n+                    )\n                 }\n             }\n         }\n@@ -1136,10 +1216,8 @@ fn get_concurrency() -> usize {\n         unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n     }\n \n-    #[cfg(any(target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n-              target_os = \"netbsd\"))]\n+    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"bitrig\",\n+                target_os = \"netbsd\"))]\n     fn num_cpus() -> usize {\n         use std::ptr;\n \n@@ -1152,12 +1230,14 @@ fn get_concurrency() -> usize {\n         if cpus < 1 {\n             let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n             unsafe {\n-                libc::sysctl(mib.as_mut_ptr(),\n-                             2,\n-                             &mut cpus as *mut _ as *mut _,\n-                             &mut cpus_size as *mut _ as *mut _,\n-                             ptr::null_mut(),\n-                             0);\n+                libc::sysctl(\n+                    mib.as_mut_ptr(),\n+                    2,\n+                    &mut cpus as *mut _ as *mut _,\n+                    &mut cpus_size as *mut _ as *mut _,\n+                    ptr::null_mut(),\n+                    0,\n+                );\n             }\n             if cpus < 1 {\n                 cpus = 1;\n@@ -1175,12 +1255,14 @@ fn get_concurrency() -> usize {\n         let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n \n         unsafe {\n-            libc::sysctl(mib.as_mut_ptr(),\n-                         2,\n-                         &mut cpus as *mut _ as *mut _,\n-                         &mut cpus_size as *mut _ as *mut _,\n-                         ptr::null_mut(),\n-                         0);\n+            libc::sysctl(\n+                mib.as_mut_ptr(),\n+                2,\n+                &mut cpus as *mut _ as *mut _,\n+                &mut cpus_size as *mut _ as *mut _,\n+                ptr::null_mut(),\n+                0,\n+            );\n         }\n         if cpus < 1 {\n             cpus = 1;\n@@ -1202,27 +1284,27 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     filtered = match opts.filter {\n         None => filtered,\n         Some(ref filter) => {\n-            filtered.into_iter()\n-                    .filter(|test| {\n-                        if opts.filter_exact {\n-                            test.desc.name.as_slice() == &filter[..]\n-                        } else {\n-                            test.desc.name.as_slice().contains(&filter[..])\n-                        }\n-                    })\n-                    .collect()\n+            filtered\n+                .into_iter()\n+                .filter(|test| if opts.filter_exact {\n+                    test.desc.name.as_slice() == &filter[..]\n+                } else {\n+                    test.desc.name.as_slice().contains(&filter[..])\n+                })\n+                .collect()\n         }\n     };\n \n     // Skip tests that match any of the skip filters\n-    filtered = filtered.into_iter()\n-        .filter(|t| !opts.skip.iter().any(|sf| {\n-                if opts.filter_exact {\n-                    t.desc.name.as_slice() == &sf[..]\n-                } else {\n-                    t.desc.name.as_slice().contains(&sf[..])\n-                }\n-            }))\n+    filtered = filtered\n+        .into_iter()\n+        .filter(|t| {\n+            !opts.skip.iter().any(|sf| if opts.filter_exact {\n+                t.desc.name.as_slice() == &sf[..]\n+            } else {\n+                t.desc.name.as_slice().contains(&sf[..])\n+            })\n+        })\n         .collect();\n \n     // Maybe pull out the ignored test and unignore them\n@@ -1231,9 +1313,12 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     } else {\n         fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n             if test.desc.ignore {\n-                let TestDescAndFn {desc, testfn} = test;\n+                let TestDescAndFn { desc, testfn } = test;\n                 Some(TestDescAndFn {\n-                    desc: TestDesc { ignore: false, ..desc },\n+                    desc: TestDesc {\n+                        ignore: false,\n+                        ..desc\n+                    },\n                     testfn,\n                 })\n             } else {\n@@ -1244,7 +1329,9 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     };\n \n     // Sort the tests alphabetically\n-    filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n+    filtered.sort_by(|t1, t2| {\n+        t1.desc.name.as_slice().cmp(t2.desc.name.as_slice())\n+    });\n \n     filtered\n }\n@@ -1267,24 +1354,26 @@ pub fn convert_benchmarks_to_tests(tests: Vec<TestDescAndFn>) -> Vec<TestDescAnd\n                     })\n                 }))\n             }\n-            f => f,\n-        };\n-        TestDescAndFn {\n-            desc: x.desc,\n-            testfn,\n-        }\n-    }).collect()\n+                f => f,\n+            };\n+            TestDescAndFn {\n+                desc: x.desc,\n+                testfn,\n+            }\n+        })\n+        .collect()\n }\n \n-pub fn run_test(opts: &TestOpts,\n-                force_ignore: bool,\n-                test: TestDescAndFn,\n-                monitor_ch: Sender<MonitorMsg>) {\n+pub fn run_test(\n+    opts: &TestOpts,\n+    force_ignore: bool,\n+    test: TestDescAndFn,\n+    monitor_ch: Sender<MonitorMsg>,\n+) {\n \n-    let TestDescAndFn {desc, testfn} = test;\n+    let TestDescAndFn { desc, testfn } = test;\n \n-    let ignore_because_panic_abort =\n-        cfg!(target_arch = \"wasm32\") &&\n+    let ignore_because_panic_abort = cfg!(target_arch = \"wasm32\") &&\n         !cfg!(target_os = \"emscripten\") &&\n         desc.should_panic != ShouldPanic::No;\n \n@@ -1316,7 +1405,7 @@ pub fn run_test(opts: &TestOpts,\n             let oldio = if !nocapture {\n                 Some((\n                     io::set_print(Some(Box::new(Sink(data2.clone())))),\n-                    io::set_panic(Some(Box::new(Sink(data2))))\n+                    io::set_panic(Some(Box::new(Sink(data2)))),\n                 ))\n             } else {\n                 None\n@@ -1331,16 +1420,16 @@ pub fn run_test(opts: &TestOpts,\n \n             let test_result = calc_result(&desc, result);\n             let stdout = data.lock().unwrap().to_vec();\n-            monitor_ch.send((desc.clone(), test_result, stdout)).unwrap();\n+            monitor_ch\n+                .send((desc.clone(), test_result, stdout))\n+                .unwrap();\n         };\n \n \n         // If the platform is single-threaded we're just going to run\n         // the test synchronously, regardless of the concurrency\n         // level.\n-        let supports_threads =\n-            !cfg!(target_os = \"emscripten\") &&\n-            !cfg!(target_arch = \"wasm32\");\n+        let supports_threads = !cfg!(target_os = \"emscripten\") && !cfg!(target_arch = \"wasm32\");\n         if supports_threads {\n             let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n             cfg.spawn(runtest).unwrap();\n@@ -1382,20 +1471,22 @@ fn calc_result(desc: &TestDesc, task_result: Result<(), Box<Any + Send>>) -> Tes\n     match (&desc.should_panic, task_result) {\n         (&ShouldPanic::No, Ok(())) |\n         (&ShouldPanic::Yes, Err(_)) => TrOk,\n-        (&ShouldPanic::YesWithMessage(msg), Err(ref err)) =>\n+        (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n             if err.downcast_ref::<String>()\n-                  .map(|e| &**e)\n-                  .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e))\n-                  .map(|e| e.contains(msg))\n-                  .unwrap_or(false) {\n+                .map(|e| &**e)\n+                .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e))\n+                .map(|e| e.contains(msg))\n+                .unwrap_or(false)\n+            {\n                 TrOk\n             } else {\n                 if desc.allow_fail {\n                     TrAllowedFail\n                 } else {\n                     TrFailedMsg(format!(\"Panic did not include expected string '{}'\", msg))\n                 }\n-            },\n+            }\n+        }\n         _ if desc.allow_fail => TrAllowedFail,\n         _ => TrFailed,\n     }\n@@ -1423,18 +1514,15 @@ impl MetricMap {\n     /// you want to see grow larger, so a change larger than `noise` in the\n     /// negative direction represents a regression.\n     pub fn insert_metric(&mut self, name: &str, value: f64, noise: f64) {\n-        let m = Metric {\n-            value,\n-            noise,\n-        };\n+        let m = Metric { value, noise };\n         self.0.insert(name.to_owned(), m);\n     }\n \n     pub fn fmt_metrics(&self) -> String {\n         let v = self.0\n-                   .iter()\n-                   .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n-                   .collect::<Vec<_>>();\n+            .iter()\n+            .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n+            .collect::<Vec<_>>();\n         v.join(\", \")\n     }\n }\n@@ -1464,7 +1552,8 @@ pub fn black_box<T>(dummy: T) -> T {\n impl Bencher {\n     /// Callback for benchmark functions to run in their body.\n     pub fn iter<T, F>(&mut self, mut inner: F)\n-        where F: FnMut() -> T\n+    where\n+        F: FnMut() -> T,\n     {\n         if self.mode == BenchMode::Single {\n             ns_iter_inner(&mut inner, 1);\n@@ -1475,7 +1564,8 @@ impl Bencher {\n     }\n \n     pub fn bench<F>(&mut self, mut f: F) -> Option<stats::Summary>\n-        where F: FnMut(&mut Bencher)\n+    where\n+        F: FnMut(&mut Bencher),\n     {\n         f(self);\n         return self.summary;\n@@ -1487,7 +1577,8 @@ fn ns_from_dur(dur: Duration) -> u64 {\n }\n \n fn ns_iter_inner<T, F>(inner: &mut F, k: u64) -> u64\n-    where F: FnMut() -> T\n+where\n+    F: FnMut() -> T,\n {\n     let start = Instant::now();\n     for _ in 0..k {\n@@ -1498,7 +1589,8 @@ fn ns_iter_inner<T, F>(inner: &mut F, k: u64) -> u64\n \n \n pub fn iter<T, F>(inner: &mut F) -> stats::Summary\n-    where F: FnMut() -> T\n+where\n+    F: FnMut() -> T,\n {\n     // Initial bench run to get ballpark figure.\n     let ns_single = ns_iter_inner(inner, 1);\n@@ -1540,7 +1632,8 @@ pub fn iter<T, F>(inner: &mut F) -> stats::Summary\n         // If we've run for 100ms and seem to have converged to a\n         // stable median.\n         if loop_run > Duration::from_millis(100) && summ.median_abs_dev_pct < 1.0 &&\n-           summ.median - summ5.median < summ5.median_abs_dev {\n+            summ.median - summ5.median < summ5.median_abs_dev\n+        {\n             return summ5;\n         }\n \n@@ -1569,7 +1662,8 @@ pub mod bench {\n     use super::{Bencher, BenchSamples, BenchMode};\n \n     pub fn benchmark<F>(f: F) -> BenchSamples\n-        where F: FnMut(&mut Bencher)\n+    where\n+        F: FnMut(&mut Bencher),\n     {\n         let mut bs = Bencher {\n             mode: BenchMode::Auto,\n@@ -1600,7 +1694,8 @@ pub mod bench {\n     }\n \n     pub fn run_once<F>(f: F)\n-        where F: FnMut(&mut Bencher)\n+    where\n+        F: FnMut(&mut Bencher),\n     {\n         let mut bs = Bencher {\n             mode: BenchMode::Single,\n@@ -1740,7 +1835,11 @@ mod tests {\n \n     #[test]\n     fn parse_ignored_flag() {\n-        let args = vec![\"progname\".to_string(), \"filter\".to_string(), \"--ignored\".to_string()];\n+        let args = vec![\n+            \"progname\".to_string(),\n+            \"filter\".to_string(),\n+            \"--ignored\".to_string(),\n+        ];\n         let opts = match parse_opts(&args) {\n             Some(Ok(o)) => o,\n             _ => panic!(\"Malformed arg in parse_ignored_flag\"),\n@@ -1757,7 +1856,8 @@ mod tests {\n         opts.run_tests = true;\n         opts.run_ignored = true;\n \n-        let tests = vec![TestDescAndFn {\n+        let tests =\n+            vec![TestDescAndFn {\n                              desc: TestDesc {\n                                  name: StaticTestName(\"1\"),\n                                  ignore: true,\n@@ -1785,72 +1885,95 @@ mod tests {\n     #[test]\n     pub fn exact_filter_match() {\n         fn tests() -> Vec<TestDescAndFn> {\n-            vec![\"base\",\n-                 \"base::test\",\n-                 \"base::test1\",\n-                 \"base::test2\",\n-            ].into_iter()\n-            .map(|name| TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(name),\n-                    ignore: false,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {}))\n-            })\n-            .collect()\n+            vec![\"base\", \"base::test\", \"base::test1\", \"base::test2\"]\n+                .into_iter()\n+                .map(|name| {\n+                    TestDescAndFn {\n+                        desc: TestDesc {\n+                            name: StaticTestName(name),\n+                            ignore: false,\n+                            should_panic: ShouldPanic::No,\n+                            allow_fail: false,\n+                        },\n+                        testfn: DynTestFn(Box::new(move || {}))\n+                    }\n+                }).collect()\n         }\n \n-        let substr = filter_tests(&TestOpts {\n+        let substr = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"base\".into()),\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(substr.len(), 4);\n \n-        let substr = filter_tests(&TestOpts {\n+        let substr = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"bas\".into()),\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(substr.len(), 4);\n \n-        let substr = filter_tests(&TestOpts {\n+        let substr = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"::test\".into()),\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(substr.len(), 3);\n \n-        let substr = filter_tests(&TestOpts {\n+        let substr = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"base::test\".into()),\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(substr.len(), 3);\n \n-        let exact = filter_tests(&TestOpts {\n+        let exact = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"base\".into()),\n-                filter_exact: true, ..TestOpts::new()\n-            }, tests());\n+                filter_exact: true,\n+                ..TestOpts::new()\n+            },\n+            tests(),\n+        );\n         assert_eq!(exact.len(), 1);\n \n-        let exact = filter_tests(&TestOpts {\n+        let exact = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"bas\".into()),\n                 filter_exact: true,\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(exact.len(), 0);\n \n-        let exact = filter_tests(&TestOpts {\n+        let exact = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"::test\".into()),\n                 filter_exact: true,\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(exact.len(), 0);\n \n-        let exact = filter_tests(&TestOpts {\n+        let exact = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"base::test\".into()),\n                 filter_exact: true,\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(exact.len(), 1);\n     }\n \n@@ -1859,15 +1982,17 @@ mod tests {\n         let mut opts = TestOpts::new();\n         opts.run_tests = true;\n \n-        let names = vec![\"sha1::test\".to_string(),\n-                         \"isize::test_to_str\".to_string(),\n-                         \"isize::test_pow\".to_string(),\n-                         \"test::do_not_run_ignored_tests\".to_string(),\n-                         \"test::ignored_tests_result_in_ignored\".to_string(),\n-                         \"test::first_free_arg_should_be_a_filter\".to_string(),\n-                         \"test::parse_ignored_flag\".to_string(),\n-                         \"test::filter_for_ignored_option\".to_string(),\n-                         \"test::sort_tests\".to_string()];\n+        let names = vec![\n+            \"sha1::test\".to_string(),\n+            \"isize::test_to_str\".to_string(),\n+            \"isize::test_pow\".to_string(),\n+            \"test::do_not_run_ignored_tests\".to_string(),\n+            \"test::ignored_tests_result_in_ignored\".to_string(),\n+            \"test::first_free_arg_should_be_a_filter\".to_string(),\n+            \"test::parse_ignored_flag\".to_string(),\n+            \"test::filter_for_ignored_option\".to_string(),\n+            \"test::sort_tests\".to_string(),\n+        ];\n         let tests = {\n             fn testfn() {}\n             let mut tests = Vec::new();\n@@ -1887,15 +2012,17 @@ mod tests {\n         };\n         let filtered = filter_tests(&opts, tests);\n \n-        let expected = vec![\"isize::test_pow\".to_string(),\n-                            \"isize::test_to_str\".to_string(),\n-                            \"sha1::test\".to_string(),\n-                            \"test::do_not_run_ignored_tests\".to_string(),\n-                            \"test::filter_for_ignored_option\".to_string(),\n-                            \"test::first_free_arg_should_be_a_filter\".to_string(),\n-                            \"test::ignored_tests_result_in_ignored\".to_string(),\n-                            \"test::parse_ignored_flag\".to_string(),\n-                            \"test::sort_tests\".to_string()];\n+        let expected = vec![\n+            \"isize::test_pow\".to_string(),\n+            \"isize::test_to_str\".to_string(),\n+            \"sha1::test\".to_string(),\n+            \"test::do_not_run_ignored_tests\".to_string(),\n+            \"test::filter_for_ignored_option\".to_string(),\n+            \"test::first_free_arg_should_be_a_filter\".to_string(),\n+            \"test::ignored_tests_result_in_ignored\".to_string(),\n+            \"test::parse_ignored_flag\".to_string(),\n+            \"test::sort_tests\".to_string(),\n+        ];\n \n         for (a, b) in expected.iter().zip(filtered) {\n             assert!(*a == b.desc.name.to_string());\n@@ -1934,8 +2061,7 @@ mod tests {\n     #[test]\n     pub fn test_bench_once_iter() {\n         fn f(b: &mut Bencher) {\n-            b.iter(|| {\n-            })\n+            b.iter(|| {})\n         }\n         bench::run_once(f);\n     }\n@@ -1949,8 +2075,7 @@ mod tests {\n     #[test]\n     pub fn test_bench_iter() {\n         fn f(b: &mut Bencher) {\n-            b.iter(|| {\n-            })\n+            b.iter(|| {})\n         }\n         bench::benchmark(f);\n     }"}, {"sha": "e22fdf77fc171e4ad06596947dc1493c8bcae063", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 263, "deletions": 241, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/8b3fd98f4c12aca4e00f6cf2f00540182eef8a92/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3fd98f4c12aca4e00f6cf2f00540182eef8a92/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=8b3fd98f4c12aca4e00f6cf2f00540182eef8a92", "patch": "@@ -400,16 +400,18 @@ mod tests {\n     }\n     #[test]\n     fn test_norm10narrow() {\n-        let val = &[966.0000000000,\n-                    985.0000000000,\n-                    1110.0000000000,\n-                    848.0000000000,\n-                    821.0000000000,\n-                    975.0000000000,\n-                    962.0000000000,\n-                    1157.0000000000,\n-                    1217.0000000000,\n-                    955.0000000000];\n+        let val = &[\n+            966.0000000000,\n+            985.0000000000,\n+            1110.0000000000,\n+            848.0000000000,\n+            821.0000000000,\n+            975.0000000000,\n+            962.0000000000,\n+            1157.0000000000,\n+            1217.0000000000,\n+            955.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 9996.0000000000,\n             min: 821.0000000000,\n@@ -428,16 +430,18 @@ mod tests {\n     }\n     #[test]\n     fn test_norm10medium() {\n-        let val = &[954.0000000000,\n-                    1064.0000000000,\n-                    855.0000000000,\n-                    1000.0000000000,\n-                    743.0000000000,\n-                    1084.0000000000,\n-                    704.0000000000,\n-                    1023.0000000000,\n-                    357.0000000000,\n-                    869.0000000000];\n+        let val = &[\n+            954.0000000000,\n+            1064.0000000000,\n+            855.0000000000,\n+            1000.0000000000,\n+            743.0000000000,\n+            1084.0000000000,\n+            704.0000000000,\n+            1023.0000000000,\n+            357.0000000000,\n+            869.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 8653.0000000000,\n             min: 357.0000000000,\n@@ -456,16 +460,18 @@ mod tests {\n     }\n     #[test]\n     fn test_norm10wide() {\n-        let val = &[505.0000000000,\n-                    497.0000000000,\n-                    1591.0000000000,\n-                    887.0000000000,\n-                    1026.0000000000,\n-                    136.0000000000,\n-                    1580.0000000000,\n-                    940.0000000000,\n-                    754.0000000000,\n-                    1433.0000000000];\n+        let val = &[\n+            505.0000000000,\n+            497.0000000000,\n+            1591.0000000000,\n+            887.0000000000,\n+            1026.0000000000,\n+            136.0000000000,\n+            1580.0000000000,\n+            940.0000000000,\n+            754.0000000000,\n+            1433.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 9349.0000000000,\n             min: 136.0000000000,\n@@ -484,31 +490,33 @@ mod tests {\n     }\n     #[test]\n     fn test_norm25verynarrow() {\n-        let val = &[991.0000000000,\n-                    1018.0000000000,\n-                    998.0000000000,\n-                    1013.0000000000,\n-                    974.0000000000,\n-                    1007.0000000000,\n-                    1014.0000000000,\n-                    999.0000000000,\n-                    1011.0000000000,\n-                    978.0000000000,\n-                    985.0000000000,\n-                    999.0000000000,\n-                    983.0000000000,\n-                    982.0000000000,\n-                    1015.0000000000,\n-                    1002.0000000000,\n-                    977.0000000000,\n-                    948.0000000000,\n-                    1040.0000000000,\n-                    974.0000000000,\n-                    996.0000000000,\n-                    989.0000000000,\n-                    1015.0000000000,\n-                    994.0000000000,\n-                    1024.0000000000];\n+        let val = &[\n+            991.0000000000,\n+            1018.0000000000,\n+            998.0000000000,\n+            1013.0000000000,\n+            974.0000000000,\n+            1007.0000000000,\n+            1014.0000000000,\n+            999.0000000000,\n+            1011.0000000000,\n+            978.0000000000,\n+            985.0000000000,\n+            999.0000000000,\n+            983.0000000000,\n+            982.0000000000,\n+            1015.0000000000,\n+            1002.0000000000,\n+            977.0000000000,\n+            948.0000000000,\n+            1040.0000000000,\n+            974.0000000000,\n+            996.0000000000,\n+            989.0000000000,\n+            1015.0000000000,\n+            994.0000000000,\n+            1024.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 24926.0000000000,\n             min: 948.0000000000,\n@@ -527,16 +535,18 @@ mod tests {\n     }\n     #[test]\n     fn test_exp10a() {\n-        let val = &[23.0000000000,\n-                    11.0000000000,\n-                    2.0000000000,\n-                    57.0000000000,\n-                    4.0000000000,\n-                    12.0000000000,\n-                    5.0000000000,\n-                    29.0000000000,\n-                    3.0000000000,\n-                    21.0000000000];\n+        let val = &[\n+            23.0000000000,\n+            11.0000000000,\n+            2.0000000000,\n+            57.0000000000,\n+            4.0000000000,\n+            12.0000000000,\n+            5.0000000000,\n+            29.0000000000,\n+            3.0000000000,\n+            21.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 167.0000000000,\n             min: 2.0000000000,\n@@ -555,16 +565,18 @@ mod tests {\n     }\n     #[test]\n     fn test_exp10b() {\n-        let val = &[24.0000000000,\n-                    17.0000000000,\n-                    6.0000000000,\n-                    38.0000000000,\n-                    25.0000000000,\n-                    7.0000000000,\n-                    51.0000000000,\n-                    2.0000000000,\n-                    61.0000000000,\n-                    32.0000000000];\n+        let val = &[\n+            24.0000000000,\n+            17.0000000000,\n+            6.0000000000,\n+            38.0000000000,\n+            25.0000000000,\n+            7.0000000000,\n+            51.0000000000,\n+            2.0000000000,\n+            61.0000000000,\n+            32.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 263.0000000000,\n             min: 2.0000000000,\n@@ -583,16 +595,18 @@ mod tests {\n     }\n     #[test]\n     fn test_exp10c() {\n-        let val = &[71.0000000000,\n-                    2.0000000000,\n-                    32.0000000000,\n-                    1.0000000000,\n-                    6.0000000000,\n-                    28.0000000000,\n-                    13.0000000000,\n-                    37.0000000000,\n-                    16.0000000000,\n-                    36.0000000000];\n+        let val = &[\n+            71.0000000000,\n+            2.0000000000,\n+            32.0000000000,\n+            1.0000000000,\n+            6.0000000000,\n+            28.0000000000,\n+            13.0000000000,\n+            37.0000000000,\n+            16.0000000000,\n+            36.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 242.0000000000,\n             min: 1.0000000000,\n@@ -611,31 +625,33 @@ mod tests {\n     }\n     #[test]\n     fn test_exp25() {\n-        let val = &[3.0000000000,\n-                    24.0000000000,\n-                    1.0000000000,\n-                    19.0000000000,\n-                    7.0000000000,\n-                    5.0000000000,\n-                    30.0000000000,\n-                    39.0000000000,\n-                    31.0000000000,\n-                    13.0000000000,\n-                    25.0000000000,\n-                    48.0000000000,\n-                    1.0000000000,\n-                    6.0000000000,\n-                    42.0000000000,\n-                    63.0000000000,\n-                    2.0000000000,\n-                    12.0000000000,\n-                    108.0000000000,\n-                    26.0000000000,\n-                    1.0000000000,\n-                    7.0000000000,\n-                    44.0000000000,\n-                    25.0000000000,\n-                    11.0000000000];\n+        let val = &[\n+            3.0000000000,\n+            24.0000000000,\n+            1.0000000000,\n+            19.0000000000,\n+            7.0000000000,\n+            5.0000000000,\n+            30.0000000000,\n+            39.0000000000,\n+            31.0000000000,\n+            13.0000000000,\n+            25.0000000000,\n+            48.0000000000,\n+            1.0000000000,\n+            6.0000000000,\n+            42.0000000000,\n+            63.0000000000,\n+            2.0000000000,\n+            12.0000000000,\n+            108.0000000000,\n+            26.0000000000,\n+            1.0000000000,\n+            7.0000000000,\n+            44.0000000000,\n+            25.0000000000,\n+            11.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 593.0000000000,\n             min: 1.0000000000,\n@@ -654,31 +670,33 @@ mod tests {\n     }\n     #[test]\n     fn test_binom25() {\n-        let val = &[18.0000000000,\n-                    17.0000000000,\n-                    27.0000000000,\n-                    15.0000000000,\n-                    21.0000000000,\n-                    25.0000000000,\n-                    17.0000000000,\n-                    24.0000000000,\n-                    25.0000000000,\n-                    24.0000000000,\n-                    26.0000000000,\n-                    26.0000000000,\n-                    23.0000000000,\n-                    15.0000000000,\n-                    23.0000000000,\n-                    17.0000000000,\n-                    18.0000000000,\n-                    18.0000000000,\n-                    21.0000000000,\n-                    16.0000000000,\n-                    15.0000000000,\n-                    31.0000000000,\n-                    20.0000000000,\n-                    17.0000000000,\n-                    15.0000000000];\n+        let val = &[\n+            18.0000000000,\n+            17.0000000000,\n+            27.0000000000,\n+            15.0000000000,\n+            21.0000000000,\n+            25.0000000000,\n+            17.0000000000,\n+            24.0000000000,\n+            25.0000000000,\n+            24.0000000000,\n+            26.0000000000,\n+            26.0000000000,\n+            23.0000000000,\n+            15.0000000000,\n+            23.0000000000,\n+            17.0000000000,\n+            18.0000000000,\n+            18.0000000000,\n+            21.0000000000,\n+            16.0000000000,\n+            15.0000000000,\n+            31.0000000000,\n+            20.0000000000,\n+            17.0000000000,\n+            15.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 514.0000000000,\n             min: 15.0000000000,\n@@ -697,31 +715,33 @@ mod tests {\n     }\n     #[test]\n     fn test_pois25lambda30() {\n-        let val = &[27.0000000000,\n-                    33.0000000000,\n-                    34.0000000000,\n-                    34.0000000000,\n-                    24.0000000000,\n-                    39.0000000000,\n-                    28.0000000000,\n-                    27.0000000000,\n-                    31.0000000000,\n-                    28.0000000000,\n-                    38.0000000000,\n-                    21.0000000000,\n-                    33.0000000000,\n-                    36.0000000000,\n-                    29.0000000000,\n-                    37.0000000000,\n-                    32.0000000000,\n-                    34.0000000000,\n-                    31.0000000000,\n-                    39.0000000000,\n-                    25.0000000000,\n-                    31.0000000000,\n-                    32.0000000000,\n-                    40.0000000000,\n-                    24.0000000000];\n+        let val = &[\n+            27.0000000000,\n+            33.0000000000,\n+            34.0000000000,\n+            34.0000000000,\n+            24.0000000000,\n+            39.0000000000,\n+            28.0000000000,\n+            27.0000000000,\n+            31.0000000000,\n+            28.0000000000,\n+            38.0000000000,\n+            21.0000000000,\n+            33.0000000000,\n+            36.0000000000,\n+            29.0000000000,\n+            37.0000000000,\n+            32.0000000000,\n+            34.0000000000,\n+            31.0000000000,\n+            39.0000000000,\n+            25.0000000000,\n+            31.0000000000,\n+            32.0000000000,\n+            40.0000000000,\n+            24.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 787.0000000000,\n             min: 21.0000000000,\n@@ -740,31 +760,33 @@ mod tests {\n     }\n     #[test]\n     fn test_pois25lambda40() {\n-        let val = &[42.0000000000,\n-                    50.0000000000,\n-                    42.0000000000,\n-                    46.0000000000,\n-                    34.0000000000,\n-                    45.0000000000,\n-                    34.0000000000,\n-                    49.0000000000,\n-                    39.0000000000,\n-                    28.0000000000,\n-                    40.0000000000,\n-                    35.0000000000,\n-                    37.0000000000,\n-                    39.0000000000,\n-                    46.0000000000,\n-                    44.0000000000,\n-                    32.0000000000,\n-                    45.0000000000,\n-                    42.0000000000,\n-                    37.0000000000,\n-                    48.0000000000,\n-                    42.0000000000,\n-                    33.0000000000,\n-                    42.0000000000,\n-                    48.0000000000];\n+        let val = &[\n+            42.0000000000,\n+            50.0000000000,\n+            42.0000000000,\n+            46.0000000000,\n+            34.0000000000,\n+            45.0000000000,\n+            34.0000000000,\n+            49.0000000000,\n+            39.0000000000,\n+            28.0000000000,\n+            40.0000000000,\n+            35.0000000000,\n+            37.0000000000,\n+            39.0000000000,\n+            46.0000000000,\n+            44.0000000000,\n+            32.0000000000,\n+            45.0000000000,\n+            42.0000000000,\n+            37.0000000000,\n+            48.0000000000,\n+            42.0000000000,\n+            33.0000000000,\n+            42.0000000000,\n+            48.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 1019.0000000000,\n             min: 28.0000000000,\n@@ -783,31 +805,33 @@ mod tests {\n     }\n     #[test]\n     fn test_pois25lambda50() {\n-        let val = &[45.0000000000,\n-                    43.0000000000,\n-                    44.0000000000,\n-                    61.0000000000,\n-                    51.0000000000,\n-                    53.0000000000,\n-                    59.0000000000,\n-                    52.0000000000,\n-                    49.0000000000,\n-                    51.0000000000,\n-                    51.0000000000,\n-                    50.0000000000,\n-                    49.0000000000,\n-                    56.0000000000,\n-                    42.0000000000,\n-                    52.0000000000,\n-                    51.0000000000,\n-                    43.0000000000,\n-                    48.0000000000,\n-                    48.0000000000,\n-                    50.0000000000,\n-                    42.0000000000,\n-                    43.0000000000,\n-                    42.0000000000,\n-                    60.0000000000];\n+        let val = &[\n+            45.0000000000,\n+            43.0000000000,\n+            44.0000000000,\n+            61.0000000000,\n+            51.0000000000,\n+            53.0000000000,\n+            59.0000000000,\n+            52.0000000000,\n+            49.0000000000,\n+            51.0000000000,\n+            51.0000000000,\n+            50.0000000000,\n+            49.0000000000,\n+            56.0000000000,\n+            42.0000000000,\n+            52.0000000000,\n+            51.0000000000,\n+            43.0000000000,\n+            48.0000000000,\n+            48.0000000000,\n+            50.0000000000,\n+            42.0000000000,\n+            43.0000000000,\n+            42.0000000000,\n+            60.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 1235.0000000000,\n             min: 42.0000000000,\n@@ -826,31 +850,33 @@ mod tests {\n     }\n     #[test]\n     fn test_unif25() {\n-        let val = &[99.0000000000,\n-                    55.0000000000,\n-                    92.0000000000,\n-                    79.0000000000,\n-                    14.0000000000,\n-                    2.0000000000,\n-                    33.0000000000,\n-                    49.0000000000,\n-                    3.0000000000,\n-                    32.0000000000,\n-                    84.0000000000,\n-                    59.0000000000,\n-                    22.0000000000,\n-                    86.0000000000,\n-                    76.0000000000,\n-                    31.0000000000,\n-                    29.0000000000,\n-                    11.0000000000,\n-                    41.0000000000,\n-                    53.0000000000,\n-                    45.0000000000,\n-                    44.0000000000,\n-                    98.0000000000,\n-                    98.0000000000,\n-                    7.0000000000];\n+        let val = &[\n+            99.0000000000,\n+            55.0000000000,\n+            92.0000000000,\n+            79.0000000000,\n+            14.0000000000,\n+            2.0000000000,\n+            33.0000000000,\n+            49.0000000000,\n+            3.0000000000,\n+            32.0000000000,\n+            84.0000000000,\n+            59.0000000000,\n+            22.0000000000,\n+            86.0000000000,\n+            76.0000000000,\n+            31.0000000000,\n+            29.0000000000,\n+            11.0000000000,\n+            41.0000000000,\n+            53.0000000000,\n+            45.0000000000,\n+            44.0000000000,\n+            98.0000000000,\n+            98.0000000000,\n+            7.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 1242.0000000000,\n             min: 2.0000000000,\n@@ -885,18 +911,14 @@ mod bench {\n \n     #[bench]\n     pub fn sum_three_items(b: &mut Bencher) {\n-        b.iter(|| {\n-            [1e20f64, 1.5f64, -1e20f64].sum();\n-        })\n+        b.iter(|| { [1e20f64, 1.5f64, -1e20f64].sum(); })\n     }\n     #[bench]\n     pub fn sum_many_f64(b: &mut Bencher) {\n         let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n         let v = (0..500).map(|i| nums[i % 5]).collect::<Vec<_>>();\n \n-        b.iter(|| {\n-            v.sum();\n-        })\n+        b.iter(|| { v.sum(); })\n     }\n \n     #[bench]"}]}