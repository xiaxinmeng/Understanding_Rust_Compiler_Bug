{"sha": "3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYjIzNWI0NWVmMDg1ODU4Y2QxYzJmYWQxY2Y1MzhiYTkzZjgxYTI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-27T00:46:00Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-05-25T05:52:11Z"}, "message": "Improve intercrate hygiene.", "tree": {"sha": "80edf2375cf69e25f01c1aa5ab9f4fef2f2ac97b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80edf2375cf69e25f01c1aa5ab9f4fef2f2ac97b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "html_url": "https://github.com/rust-lang/rust/commit/3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dde8dc61ddfd9fa9dd271a811e473eebecb92702", "url": "https://api.github.com/repos/rust-lang/rust/commits/dde8dc61ddfd9fa9dd271a811e473eebecb92702", "html_url": "https://github.com/rust-lang/rust/commit/dde8dc61ddfd9fa9dd271a811e473eebecb92702"}], "stats": {"total": 186, "additions": 112, "deletions": 74}, "files": [{"sha": "feded417ce17fb7910d62a4e671c7ea0a48575be", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "patch": "@@ -117,7 +117,7 @@ pub type ExportMap = NodeMap<Vec<Export>>;\n \n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Export {\n-    pub name: ast::Name, // The name of the target.\n+    pub ident: ast::Ident, // The name of the target.\n     pub def: Def, // The definition of the target.\n     pub span: Span, // The span of the target definition.\n }"}, {"sha": "91cfbc38aa0ece054207968b2844c7dfcd942885", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "patch": "@@ -2662,7 +2662,7 @@ impl<'a> LoweringContext<'a> {\n         let parent_def = self.parent_def.unwrap();\n         let def_id = {\n             let defs = self.resolver.definitions();\n-            let def_path_data = DefPathData::Binding(name.as_str());\n+            let def_path_data = DefPathData::Binding(Ident::with_empty_ctxt(name));\n             let def_index = defs\n                 .create_def_with_parent(parent_def, id, def_path_data, REGULAR_SPACE, Mark::root());\n             DefId::local(def_index)"}, {"sha": "cb25b462b6e243e791514e80316b73e29d5647c2", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::{CRATE_DEF_INDEX, DefIndex, DefIndexAddressSpace};\n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::keywords;\n \n use hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n \n@@ -103,14 +103,14 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 DefPathData::Impl,\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) | ItemKind::Trait(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n-                DefPathData::TypeNs(i.ident.name.as_str()),\n+                DefPathData::TypeNs(i.ident.modern()),\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n-            ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n+            ItemKind::Mod(..) => DefPathData::Module(i.ident.modern()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n-                DefPathData::ValueNs(i.ident.name.as_str()),\n-            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n+                DefPathData::ValueNs(i.ident.modern()),\n+            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.modern()),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n             ItemKind::Use(ref view_path) => {\n@@ -138,15 +138,13 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.name.as_str()),\n+                                            DefPathData::EnumVariant(v.node.name.modern()),\n                                             REGULAR_SPACE);\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n-                                let name = field.ident.map(|ident| ident.name)\n-                                    .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                                this.create_def(field.id,\n-                                                DefPathData::Field(name.as_str()),\n-                                                REGULAR_SPACE);\n+                                let ident = field.ident.map(Ident::modern)\n+                                    .unwrap_or_else(|| Ident::from_str(&index.to_string()));\n+                                this.create_def(field.id, DefPathData::Field(ident), REGULAR_SPACE);\n                             }\n \n                             if let Some(ref expr) = v.node.disr_expr {\n@@ -164,9 +162,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     }\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n-                        let name = field.ident.map(|ident| ident.name.as_str())\n-                            .unwrap_or(Symbol::intern(&index.to_string()).as_str());\n-                        this.create_def(field.id, DefPathData::Field(name), REGULAR_SPACE);\n+                        let ident = field.ident.map(Ident::modern)\n+                            .unwrap_or_else(|| Ident::from_str(&index.to_string()));\n+                        this.create_def(field.id, DefPathData::Field(ident), REGULAR_SPACE);\n                     }\n                 }\n                 _ => {}\n@@ -177,7 +175,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()),\n+                                  DefPathData::ValueNs(foreign_item.ident.modern()),\n                                   REGULAR_SPACE);\n \n         self.with_parent(def, |this| {\n@@ -188,7 +186,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_generics(&mut self, generics: &'a Generics) {\n         for ty_param in generics.ty_params.iter() {\n             self.create_def(ty_param.id,\n-                            DefPathData::TypeParam(ty_param.ident.name.as_str()),\n+                            DefPathData::TypeParam(ty_param.ident.modern()),\n                             REGULAR_SPACE);\n         }\n \n@@ -198,8 +196,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.name.as_str()),\n-            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name.as_str()),\n+                DefPathData::ValueNs(ti.ident.modern()),\n+            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.modern()),\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n@@ -216,8 +214,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.ident.name.as_str()),\n-            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name.as_str()),\n+                DefPathData::ValueNs(ii.ident.modern()),\n+            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.modern()),\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n@@ -238,7 +236,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             PatKind::Mac(..) => return self.visit_macro_invoc(pat.id, false),\n             PatKind::Ident(_, id, _) => {\n                 let def = self.create_def(pat.id,\n-                                          DefPathData::Binding(id.node.name.as_str()),\n+                                          DefPathData::Binding(id.node.modern()),\n                                           REGULAR_SPACE);\n                 self.parent_def = Some(def);\n             }\n@@ -283,7 +281,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_lifetime_def(&mut self, def: &'a LifetimeDef) {\n         self.create_def(def.lifetime.id,\n-                        DefPathData::LifetimeDef(def.lifetime.ident.name.as_str()),\n+                        DefPathData::LifetimeDef(def.lifetime.ident.modern()),\n                         REGULAR_SPACE);\n     }\n "}, {"sha": "c86b140fbc61462d6723c5a61dbb140351c7b631", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "patch": "@@ -23,8 +23,8 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n use std::hash::Hash;\n-use syntax::ast;\n-use syntax::ext::hygiene::Mark;\n+use syntax::ast::{self, Ident};\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n@@ -327,7 +327,7 @@ impl DefPath {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n@@ -341,31 +341,31 @@ pub enum DefPathData {\n     /// An impl\n     Impl,\n     /// Something in the type NS\n-    TypeNs(InternedString),\n+    TypeNs(Ident),\n     /// Something in the value NS\n-    ValueNs(InternedString),\n+    ValueNs(Ident),\n     /// A module declaration\n-    Module(InternedString),\n+    Module(Ident),\n     /// A macro rule\n-    MacroDef(InternedString),\n+    MacroDef(Ident),\n     /// A closure expression\n     ClosureExpr,\n \n     // Subportions of items\n     /// A type parameter (generic parameter)\n-    TypeParam(InternedString),\n+    TypeParam(Ident),\n     /// A lifetime definition\n-    LifetimeDef(InternedString),\n+    LifetimeDef(Ident),\n     /// A variant of a enum\n-    EnumVariant(InternedString),\n+    EnumVariant(Ident),\n     /// A struct field\n-    Field(InternedString),\n+    Field(Ident),\n     /// Implicit ctor for a tuple-like struct\n     StructCtor,\n     /// Initializer for a const\n     Initializer,\n     /// Pattern binding\n-    Binding(InternedString),\n+    Binding(Ident),\n     /// An `impl Trait` type node.\n     ImplTrait,\n     /// A `typeof` type node.\n@@ -551,18 +551,18 @@ impl Definitions {\n }\n \n impl DefPathData {\n-    pub fn get_opt_name(&self) -> Option<ast::Name> {\n+    pub fn get_opt_ident(&self) -> Option<Ident> {\n         use self::DefPathData::*;\n         match *self {\n-            TypeNs(ref name) |\n-            ValueNs(ref name) |\n-            Module(ref name) |\n-            MacroDef(ref name) |\n-            TypeParam(ref name) |\n-            LifetimeDef(ref name) |\n-            EnumVariant(ref name) |\n-            Binding(ref name) |\n-            Field(ref name) => Some(Symbol::intern(name)),\n+            TypeNs(ident) |\n+            ValueNs(ident) |\n+            Module(ident) |\n+            MacroDef(ident) |\n+            TypeParam(ident) |\n+            LifetimeDef(ident) |\n+            EnumVariant(ident) |\n+            Binding(ident) |\n+            Field(ident) => Some(ident),\n \n             Impl |\n             CrateRoot |\n@@ -575,19 +575,23 @@ impl DefPathData {\n         }\n     }\n \n+    pub fn get_opt_name(&self) -> Option<ast::Name> {\n+        self.get_opt_ident().map(|ident| ident.name)\n+    }\n+\n     pub fn as_interned_str(&self) -> InternedString {\n         use self::DefPathData::*;\n         let s = match *self {\n-            TypeNs(ref name) |\n-            ValueNs(ref name) |\n-            Module(ref name) |\n-            MacroDef(ref name) |\n-            TypeParam(ref name) |\n-            LifetimeDef(ref name) |\n-            EnumVariant(ref name) |\n-            Binding(ref name) |\n-            Field(ref name) => {\n-                return name.clone();\n+            TypeNs(ident) |\n+            ValueNs(ident) |\n+            Module(ident) |\n+            MacroDef(ident) |\n+            TypeParam(ident) |\n+            LifetimeDef(ident) |\n+            EnumVariant(ident) |\n+            Binding(ident) |\n+            Field(ident) => {\n+                return ident.name.as_str();\n             }\n \n             // note that this does not show up in user printouts\n@@ -609,3 +613,25 @@ impl DefPathData {\n         self.as_interned_str().to_string()\n     }\n }\n+\n+impl Eq for DefPathData {}\n+impl PartialEq for DefPathData {\n+    fn eq(&self, other: &DefPathData) -> bool {\n+        ::std::mem::discriminant(self) == ::std::mem::discriminant(other) &&\n+        self.get_opt_ident() == other.get_opt_ident()\n+    }\n+}\n+\n+impl ::std::hash::Hash for DefPathData {\n+    fn hash<H: ::std::hash::Hasher>(&self, hasher: &mut H) {\n+        ::std::mem::discriminant(self).hash(hasher);\n+        if let Some(ident) = self.get_opt_ident() {\n+            if ident.ctxt == SyntaxContext::empty() && ident.name == ident.name.interned() {\n+                ident.name.as_str().hash(hasher)\n+            } else {\n+                // FIXME(jseyfried) implement stable hashing for idents with macros 2.0 hygiene info\n+                ident.hash(hasher)\n+            }\n+        }\n+    }\n+}"}, {"sha": "dbe91e2725deffec2a377df2602646edbb886d79", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "patch": "@@ -1118,7 +1118,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::def_id::DefIn\n }\n \n impl_stable_hash_for!(struct hir::def::Export {\n-    name,\n+    ident,\n     def,\n     span\n });"}, {"sha": "d1d9dd4853d7baa19ee5a43266f8d8321f1ec131", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "patch": "@@ -28,6 +28,7 @@\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n+#![feature(discriminant_value)]\n #![feature(i128_type)]\n #![feature(libc)]\n #![feature(never_type)]"}, {"sha": "1db5821f31878e9ca1bf954e17ae9e69ff642a8f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "patch": "@@ -39,7 +39,7 @@ use std::u32;\n \n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n-use syntax::ast;\n+use syntax::ast::{self, Ident};\n use syntax::codemap;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n@@ -667,7 +667,8 @@ impl<'a, 'tcx> CrateMetadata {\n                         },\n                         ext.kind()\n                     );\n-                    callback(def::Export { name: name, def: def, span: DUMMY_SP });\n+                    let ident = Ident::with_empty_ctxt(name);\n+                    callback(def::Export { ident: ident, def: def, span: DUMMY_SP });\n                 }\n             }\n             return\n@@ -703,7 +704,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(def) = self.get_def(child_index) {\n                                 callback(def::Export {\n                                     def: def,\n-                                    name: self.item_name(child_index),\n+                                    ident: Ident::with_empty_ctxt(self.item_name(child_index)),\n                                     span: self.entry(child_index).span.decode(self),\n                                 });\n                             }\n@@ -720,23 +721,24 @@ impl<'a, 'tcx> CrateMetadata {\n                 let span = child.span.decode(self);\n                 if let (Some(def), Some(name)) =\n                     (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n-                    callback(def::Export { def: def, name: name, span: span });\n+                    let ident = Ident::with_empty_ctxt(name);\n+                    callback(def::Export { def: def, ident: ident, span: span });\n                     // For non-reexport structs and variants add their constructors to children.\n                     // Reexport lists automatically contain constructors when necessary.\n                     match def {\n                         Def::Struct(..) => {\n                             if let Some(ctor_def_id) = self.get_struct_ctor_def_id(child_index) {\n                                 let ctor_kind = self.get_ctor_kind(child_index);\n                                 let ctor_def = Def::StructCtor(ctor_def_id, ctor_kind);\n-                                callback(def::Export { def: ctor_def, name: name, span: span });\n+                                callback(def::Export { def: ctor_def, ident: ident, span: span });\n                             }\n                         }\n                         Def::Variant(def_id) => {\n                             // Braced variants, unlike structs, generate unusable names in\n                             // value namespace, they are reserved for possible future use.\n                             let ctor_kind = self.get_ctor_kind(child_index);\n                             let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-                            callback(def::Export { def: ctor_def, name: name, span: span });\n+                            callback(def::Export { def: ctor_def, ident: ident, span: span });\n                         }\n                         _ => {}\n                     }"}, {"sha": "597a62f86884b94092cd57cb40c1ced511eba780", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "patch": "@@ -439,7 +439,7 @@ impl<'a> Resolver<'a> {\n \n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'a>, child: Export) {\n-        let ident = Ident::with_empty_ctxt(child.name);\n+        let ident = child.ident;\n         let def = child.def;\n         let def_id = def.def_id();\n         let vis = self.session.cstore.visibility(def_id);\n@@ -480,9 +480,8 @@ impl<'a> Resolver<'a> {\n \n                 for child in self.session.cstore.item_children(def_id) {\n                     let ns = if let Def::AssociatedTy(..) = child.def { TypeNS } else { ValueNS };\n-                    let ident = Ident::with_empty_ctxt(child.name);\n-                    self.define(module, ident, ns, (child.def, ty::Visibility::Public,\n-                                                    DUMMY_SP, expansion));\n+                    self.define(module, child.ident, ns,\n+                                (child.def, ty::Visibility::Public, DUMMY_SP, expansion));\n \n                     if self.session.cstore.associated_item_cloned(child.def.def_id())\n                            .method_has_self_argument {\n@@ -643,7 +642,7 @@ impl<'a> Resolver<'a> {\n             let ident = Ident::with_empty_ctxt(name);\n             let result = self.resolve_ident_in_module(module, ident, MacroNS, false, false, span);\n             if let Ok(binding) = result {\n-                self.macro_exports.push(Export { name: name, def: binding.def(), span: span });\n+                self.macro_exports.push(Export { ident: ident, def: binding.def(), span: span });\n             } else {\n                 span_err!(self.session, span, E0470, \"reexported macro not found\");\n             }"}, {"sha": "9a37df762327979cca096ffeb6a45b50a9753f08", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "patch": "@@ -726,7 +726,8 @@ impl<'a> Resolver<'a> {\n             }));\n             if attr::contains_name(&item.attrs, \"macro_export\") {\n                 let def = Def::Macro(def_id, MacroKind::Bang);\n-                self.macro_exports.push(Export { name: ident.name, def: def, span: item.span });\n+                self.macro_exports\n+                    .push(Export { ident: ident.modern(), def: def, span: item.span });\n             } else {\n                 self.unused_macros.insert(def_id);\n             }"}, {"sha": "c077f507932c62e6ac5eb235d3779689be9bb19a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "patch": "@@ -803,7 +803,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if module as *const _ == self.graph_root as *const _ {\n             let macro_exports = mem::replace(&mut self.macro_exports, Vec::new());\n             for export in macro_exports.into_iter().rev() {\n-                if exported_macro_names.insert(export.name, export.span).is_none() {\n+                if exported_macro_names.insert(export.ident.modern(), export.span).is_none() {\n                     reexports.push(export);\n                 }\n             }\n@@ -824,7 +824,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         self.session.cstore.export_macros(def.def_id().krate);\n                     }\n                     if let Def::Macro(..) = def {\n-                        if let Some(&span) = exported_macro_names.get(&ident.name) {\n+                        if let Some(&span) = exported_macro_names.get(&ident.modern()) {\n                             let msg =\n                                 format!(\"a macro named `{}` has already been exported\", ident);\n                             self.session.struct_span_err(span, &msg)\n@@ -833,7 +833,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                 .emit();\n                         }\n                     }\n-                    reexports.push(Export { name: ident.name, def: def, span: binding.span });\n+                    reexports.push(Export { ident: ident.modern(), def: def, span: binding.span });\n                 }\n             }\n "}, {"sha": "73c0256f2c1f50babdde07d8a7a5c8c6e0e8f196", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb235b45ef085858cd1c2fad1cf538ba93f81a2/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=3eb235b45ef085858cd1c2fad1cf538ba93f81a2", "patch": "@@ -54,13 +54,24 @@ impl fmt::Display for Ident {\n \n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.name.encode(s)\n+        if self.ctxt.modern() == SyntaxContext::empty() {\n+            s.emit_str(&self.name.as_str())\n+        } else { // FIXME(jseyfried) intercrate hygiene\n+            let mut string = \"#\".to_owned();\n+            string.push_str(&self.name.as_str());\n+            s.emit_str(&string)\n+        }\n     }\n }\n \n impl Decodable for Ident {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(Ident::with_empty_ctxt(Symbol::decode(d)?))\n+        let string = d.read_str()?;\n+        Ok(if !string.starts_with('#') {\n+            Ident::from_str(&string)\n+        } else { // FIXME(jseyfried) intercrate hygiene\n+            Ident::with_empty_ctxt(Symbol::gensym(&string[1..]))\n+        })\n     }\n }\n "}]}