{"sha": "fb9731ea13a2526583cedcfa674be92d2a120970", "node_id": "C_kwDOAAsO6NoAKGZiOTczMWVhMTNhMjUyNjU4M2NlZGNmYTY3NGJlOTJkMmExMjA5NzA", "commit": {"author": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2022-04-17T05:03:45Z"}, "committer": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2022-04-17T05:23:47Z"}, "message": "Remove unnecessary function", "tree": {"sha": "b8eb7c4c3528a9baf6755056df30af3313040a12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8eb7c4c3528a9baf6755056df30af3313040a12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb9731ea13a2526583cedcfa674be92d2a120970", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9731ea13a2526583cedcfa674be92d2a120970", "html_url": "https://github.com/rust-lang/rust/commit/fb9731ea13a2526583cedcfa674be92d2a120970", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb9731ea13a2526583cedcfa674be92d2a120970/comments", "author": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e87082293e11a2f9c6d38bcd9896e8742e110ef8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e87082293e11a2f9c6d38bcd9896e8742e110ef8", "html_url": "https://github.com/rust-lang/rust/commit/e87082293e11a2f9c6d38bcd9896e8742e110ef8"}], "stats": {"total": 38, "additions": 18, "deletions": 20}, "files": [{"sha": "c03d197e0194c9c4f2a6ea9ddc89d873ce81a290", "filename": "library/std/src/path.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fb9731ea13a2526583cedcfa674be92d2a120970/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9731ea13a2526583cedcfa674be92d2a120970/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=fb9731ea13a2526583cedcfa674be92d2a120970", "patch": "@@ -193,7 +193,7 @@ impl<'a> Prefix<'a> {\n     fn len(&self) -> usize {\n         use self::Prefix::*;\n         fn os_str_len(s: &OsStr) -> usize {\n-            os_str_as_u8_slice(s).len()\n+            s.bytes().len()\n         }\n         match *self {\n             Verbatim(x) => 4 + os_str_len(x),\n@@ -299,19 +299,17 @@ where\n     }\n }\n \n-// See note at the top of this module to understand why these are used:\n-//\n-// These casts are safe as OsStr is internally a wrapper around [u8] on all\n-// platforms.\n-//\n-// Note that currently this relies on the special knowledge that libstd has;\n-// these types are single-element structs but are not marked repr(transparent)\n-// or repr(C) which would make these casts allowable outside std.\n-fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n-    unsafe { &*(s as *const OsStr as *const [u8]) }\n-}\n unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n-    // SAFETY: see the comment of `os_str_as_u8_slice`\n+    // SAFETY: See note at the top of this module to understand why this and\n+    // `OsStr::bytes` are used:\n+    //\n+    // This casts are safe as OsStr is internally a wrapper around [u8] on all\n+    // platforms.\n+    //\n+    // Note that currently this relies on the special knowledge that libstd has;\n+    // these types are single-element structs but are not marked\n+    // repr(transparent) or repr(C) which would make these casts not allowable\n+    // outside std.\n     unsafe { &*(s as *const [u8] as *const OsStr) }\n }\n \n@@ -332,15 +330,15 @@ fn has_physical_root(s: &[u8], prefix: Option<Prefix<'_>>) -> bool {\n \n // basic workhorse for splitting stem and extension\n fn rsplit_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n-    if os_str_as_u8_slice(file) == b\"..\" {\n+    if file.bytes() == b\"..\" {\n         return (Some(file), None);\n     }\n \n     // The unsafety here stems from converting between &OsStr and &[u8]\n     // and back. This is safe to do because (1) we only look at ASCII\n     // contents of the encoding and (2) new &OsStr values are produced\n     // only from ASCII-bounded slices of existing &OsStr values.\n-    let mut iter = os_str_as_u8_slice(file).rsplitn(2, |b| *b == b'.');\n+    let mut iter = file.bytes().rsplitn(2, |b| *b == b'.');\n     let after = iter.next();\n     let before = iter.next();\n     if before == Some(b\"\") {\n@@ -351,7 +349,7 @@ fn rsplit_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n }\n \n fn split_file_at_dot(file: &OsStr) -> (&OsStr, Option<&OsStr>) {\n-    let slice = os_str_as_u8_slice(file);\n+    let slice = file.bytes();\n     if slice == b\"..\" {\n         return (file, None);\n     }\n@@ -1445,17 +1443,17 @@ impl PathBuf {\n     fn _set_extension(&mut self, extension: &OsStr) -> bool {\n         let file_stem = match self.file_stem() {\n             None => return false,\n-            Some(f) => os_str_as_u8_slice(f),\n+            Some(f) => f.bytes(),\n         };\n \n         // truncate until right after the file stem\n         let end_file_stem = file_stem[file_stem.len()..].as_ptr().addr();\n-        let start = os_str_as_u8_slice(&self.inner).as_ptr().addr();\n+        let start = self.inner.bytes().as_ptr().addr();\n         let v = self.as_mut_vec();\n         v.truncate(end_file_stem.wrapping_sub(start));\n \n         // add the new extension, if any\n-        let new = os_str_as_u8_slice(extension);\n+        let new = extension.bytes();\n         if !new.is_empty() {\n             v.reserve_exact(new.len() + 1);\n             v.push(b'.');\n@@ -1948,7 +1946,7 @@ impl Path {\n     }\n     // The following (private!) function reveals the byte encoding used for OsStr.\n     fn as_u8_slice(&self) -> &[u8] {\n-        os_str_as_u8_slice(&self.inner)\n+        self.inner.bytes()\n     }\n \n     /// Directly wraps a string slice as a `Path` slice."}]}