{"sha": "e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "node_id": "C_kwDOAAsO6NoAKGU2ZDNkOTg4OGRiZjBlNmNmOGViOWVjYjg5ZmE5MWI1ZjZkMjliMDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-06T19:30:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-06T19:30:38Z"}, "message": "Auto merge of #1963 - cbeuw:weak-memory, r=RalfJung\n\nWeak memory emulation using store buffers\n\nThis implements the second half of the [Lidbury & Donaldson paper](https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf): weak memory emulation using store buffers. A store buffer is created over a memory range on atomic access. Stores will push store elements into the buffer and loads will search through the buffer in reverse modification order, determine which store elements are valid for the current load, and pick one randomly.\n\nThis implementation will never generate weak memory behaviours forbidden by the C++11 model, but it is incapable of producing all possible weak behaviours allowed by the model. There are certain weak behaviours observable on real hardware but not while using this.\n\nNote that this implementation does not take into account of C++20's memory model revision to SC accesses and fences introduced by [P0668](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html). This implementation is not fully correct under the revised C++20 model and may generate behaviours C++20 disallows.\n\nRust follows the C++20 memory model (except for the Consume ordering and some operations not performable through C++'s std::atomic<T> API). It is therefore possible for this implementation to generate behaviours never observable when the same program is compiled and run natively. Unfortunately, no literature exists at the time of writing which proposes an implementable and C++20-compatible relaxed memory model that supports all atomic operation existing in Rust. The closest one is [A Promising Semantics for Relaxed-Memory Concurrency](https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf) by Jeehoon Kang et al. However, this model lacks SC accesses and is therefore unusable by Miri (SC accesses are everywhere in library code).\n\nSafe/sound Rust allows for more operations on atomic locations than the C++20 atomic API was intended to allow, such as non-atomically accessing a previously atomically accessed location, or accessing previously atomically accessed locations with a differently sized operation (such as accessing the top 16 bits of an `AtomicU32`). These scenarios are generally left undefined in formalisations of C++ memory model, even though they [became possible](https://lists.isocpp.org/std-discussion/2022/05/1662.php) in C++20 with `std::atomic_ref<T>`. In Rust, these operations can only be done through a `&mut AtomicFoo` reference or one derived from it, therefore these operations can only happen after all previous accesses on the same locations. This implementation is adapted to accommodate these.\n\n----------\nTODOs:\n\n- [x] Add tests cases that actually demonstrate weak memory behaviour (even if they are scheduler dependent)\n- [x] Change `{mutex, rwlock, cond, srwlock}_get_or_create_id` functions under `src/shims` to use atomic RMWs instead of separate read -> check if need to create a new one -> write steps\n- [x] Make sure Crossbeam tests still pass (https://github.com/crossbeam-rs/crossbeam/pull/831)\n- [x] Move as much weak-memory related code as possible into `weak_memory.rs`\n- [x] Remove \"weak memory effects are not emulated\" warnings\n- [x] Accommodate certain mixed size and mixed atomicity accesses Rust allows on top of the C++ model", "tree": {"sha": "6fdae3da40d54c19f291ccaf94de7932eab28b80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fdae3da40d54c19f291ccaf94de7932eab28b80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "html_url": "https://github.com/rust-lang/rust/commit/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3361eabf3882578207a483f2cee631646e80eabc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3361eabf3882578207a483f2cee631646e80eabc", "html_url": "https://github.com/rust-lang/rust/commit/3361eabf3882578207a483f2cee631646e80eabc"}, {"sha": "1b32d14255aed79e1ff308e8c47b8cb884ed9703", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b32d14255aed79e1ff308e8c47b8cb884ed9703", "html_url": "https://github.com/rust-lang/rust/commit/1b32d14255aed79e1ff308e8c47b8cb884ed9703"}], "stats": {"total": 1974, "additions": 1848, "deletions": 126}, "files": [{"sha": "938a64cd045b1e16e49480ebd3b75e5f94029d71", "filename": "README.md", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -20,7 +20,8 @@ for example:\n   or an invalid enum discriminant)\n * **Experimental**: Violations of the [Stacked Borrows] rules governing aliasing\n   for reference types\n-* **Experimental**: Data races (but no weak memory effects)\n+* **Experimental**: Data races\n+* **Experimental**: Emulation of weak memory effects (i.e., reads can return outdated values)\n \n On top of that, Miri will also tell you about memory leaks: when there is memory\n still allocated at the end of the execution, and that memory is not reachable\n@@ -61,9 +62,11 @@ in your program, and cannot run all programs:\n   not support networking. System API support varies between targets; if you run\n   on Windows it is a good idea to use `--target x86_64-unknown-linux-gnu` to get\n   better support.\n-* Threading support is not finished yet. E.g., weak memory effects are not\n-  emulated and spin loops (without syscalls) just loop forever. There is no\n-  threading support on Windows.\n+* Threading support is not finished yet. E.g. spin loops (without syscalls) just\n+  loop forever. There is no threading support on Windows.\n+* Weak memory emulation may produce weak behaivours unobservable by compiled\n+  programs running on real hardware when `SeqCst` fences are used, and it cannot\n+  produce all behaviors possibly observable on real hardware.\n \n [rust]: https://www.rust-lang.org/\n [mir]: https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md\n@@ -317,7 +320,7 @@ to Miri failing to detect cases of undefined behavior in a program.\n   can focus on other failures, but it means Miri can miss bugs in your program.\n   Using this flag is **unsound**.\n * `-Zmiri-disable-data-race-detector` disables checking for data races.  Using\n-  this flag is **unsound**.\n+  this flag is **unsound**. This implies `-Zmiri-disable-weak-memory-emulation`.\n * `-Zmiri-disable-stacked-borrows` disables checking the experimental\n   [Stacked Borrows] aliasing rules.  This can make Miri run faster, but it also\n   means no aliasing violations will be detected.  Using this flag is **unsound**\n@@ -327,6 +330,8 @@ to Miri failing to detect cases of undefined behavior in a program.\n   as out-of-bounds accesses) first.  Setting this flag means Miri can miss bugs\n   in your program.  However, this can also help to make Miri run faster.  Using\n   this flag is **unsound**.\n+* `-Zmiri-disable-weak-memory-emulation` disables the emulation of some C++11 weak\n+  memory effects.\n * `-Zmiri-measureme=<name>` enables `measureme` profiling for the interpreted program.\n    This can be used to find which parts of your program are executing slowly under Miri.\n    The profile is written out to a file with the prefix `<name>`, and can be processed"}, {"sha": "907e620404b9bba5817bfc32a25abfef66719540", "filename": "src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -318,6 +318,7 @@ fn main() {\n             miri_config.stacked_borrows = false;\n         } else if arg == \"-Zmiri-disable-data-race-detector\" {\n             miri_config.data_race_detector = false;\n+            miri_config.weak_memory_emulation = false;\n         } else if arg == \"-Zmiri-disable-alignment-check\" {\n             miri_config.check_alignment = miri::AlignmentCheck::None;\n         } else if arg == \"-Zmiri-symbolic-alignment-check\" {\n@@ -340,6 +341,8 @@ fn main() {\n                 isolation_enabled = Some(false);\n             }\n             miri_config.isolated_op = miri::IsolatedOp::Allow;\n+        } else if arg == \"-Zmiri-disable-weak-memory-emulation\" {\n+            miri_config.weak_memory_emulation = false;\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-isolation-error=\") {\n             if matches!(isolation_enabled, Some(false)) {\n                 panic!(\"-Zmiri-isolation-error cannot be used along with -Zmiri-disable-isolation\");"}, {"sha": "62469dcaf43a873f800bbd8ac978a179151bfc0e", "filename": "src/concurrency/allocation_map.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fconcurrency%2Fallocation_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fconcurrency%2Fallocation_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fallocation_map.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,278 @@\n+//! Implements a map from allocation ranges to data.\n+//! This is somewhat similar to RangeMap, but the ranges\n+//! and data are discrete and non-splittable. An allocation in the\n+//! map will always have the same range until explicitly removed\n+\n+use rustc_target::abi::Size;\n+use std::ops::{Index, IndexMut, Range};\n+\n+use rustc_const_eval::interpret::AllocRange;\n+\n+#[derive(Clone, Debug)]\n+struct Elem<T> {\n+    /// The range covered by this element; never empty.\n+    range: AllocRange,\n+    /// The data stored for this element.\n+    data: T,\n+}\n+\n+/// Index of an allocation within the map\n+type Position = usize;\n+\n+#[derive(Clone, Debug)]\n+pub struct AllocationMap<T> {\n+    v: Vec<Elem<T>>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum AccessType {\n+    /// The access perfectly overlaps (same offset and range) with the exsiting allocation\n+    PerfectlyOverlapping(Position),\n+    /// The access does not touch any exising allocation\n+    Empty(Position),\n+    /// The access overlaps with one or more existing allocations\n+    ImperfectlyOverlapping(Range<Position>),\n+}\n+\n+impl<T> AllocationMap<T> {\n+    pub fn new() -> Self {\n+        Self { v: Vec::new() }\n+    }\n+\n+    /// Finds the position of the allocation containing the given offset. If the offset is not\n+    /// in an existing allocation, then returns Err containing the position\n+    /// where such allocation should be inserted\n+    fn find_offset(&self, offset: Size) -> Result<Position, Position> {\n+        // We do a binary search.\n+        let mut left = 0usize; // inclusive\n+        let mut right = self.v.len(); // exclusive\n+        loop {\n+            if left == right {\n+                // No element contains the given offset. But the\n+                // position is where such element should be placed at.\n+                return Err(left);\n+            }\n+            let candidate = left.checked_add(right).unwrap() / 2;\n+            let elem = &self.v[candidate];\n+            if offset < elem.range.start {\n+                // We are too far right (offset is further left).\n+                debug_assert!(candidate < right); // we are making progress\n+                right = candidate;\n+            } else if offset >= elem.range.end() {\n+                // We are too far left (offset is further right).\n+                debug_assert!(candidate >= left); // we are making progress\n+                left = candidate + 1;\n+            } else {\n+                // This is it!\n+                return Ok(candidate);\n+            }\n+        }\n+    }\n+\n+    /// Determines whether a given access on `range` overlaps with\n+    /// an existing allocation\n+    pub fn access_type(&self, range: AllocRange) -> AccessType {\n+        match self.find_offset(range.start) {\n+            Ok(pos) => {\n+                // Start of the range belongs to an existing object, now let's check the overlapping situation\n+                let elem = &self.v[pos];\n+                // FIXME: derive Eq for AllocRange in rustc\n+                if elem.range.start == range.start && elem.range.size == range.size {\n+                    // Happy case: perfectly overlapping access\n+                    AccessType::PerfectlyOverlapping(pos)\n+                } else {\n+                    // FIXME: add a last() method to AllocRange that returns the last inclusive offset (end() is exclusive)\n+                    let end_pos = match self.find_offset(range.end() - Size::from_bytes(1)) {\n+                        // If the end lands in an existing object, add one to get the exclusive position\n+                        Ok(inclusive_pos) => inclusive_pos + 1,\n+                        Err(exclusive_pos) => exclusive_pos,\n+                    };\n+\n+                    AccessType::ImperfectlyOverlapping(pos..end_pos)\n+                }\n+            }\n+            Err(pos) => {\n+                // Start of the range doesn't belong to an existing object\n+                match self.find_offset(range.end() - Size::from_bytes(1)) {\n+                    // Neither does the end\n+                    Err(end_pos) =>\n+                        if pos == end_pos {\n+                            // There's nothing between the start and the end, so the range thing is empty\n+                            AccessType::Empty(pos)\n+                        } else {\n+                            // Otherwise we have entirely covered an existing object\n+                            AccessType::ImperfectlyOverlapping(pos..end_pos)\n+                        },\n+                    // Otherwise at least part of it overlaps with something else\n+                    Ok(end_pos) => AccessType::ImperfectlyOverlapping(pos..end_pos + 1),\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Inserts an object and its occupied range at given position\n+    // The Position can be calculated from AllocRange, but the only user of AllocationMap\n+    // always calls access_type before calling insert/index/index_mut, and we don't\n+    // want to repeat the binary search on each time, so we ask the caller to supply Position\n+    pub fn insert_at_pos(&mut self, pos: Position, range: AllocRange, data: T) {\n+        self.v.insert(pos, Elem { range, data });\n+        // If we aren't the first element, then our start must be greater than the preivous element's end\n+        if pos > 0 {\n+            debug_assert!(self.v[pos - 1].range.end() <= range.start);\n+        }\n+        // If we aren't the last element, then our end must be smaller than next element's start\n+        if pos < self.v.len() - 1 {\n+            debug_assert!(range.end() <= self.v[pos + 1].range.start);\n+        }\n+    }\n+\n+    pub fn remove_pos_range(&mut self, pos_range: Range<Position>) {\n+        self.v.drain(pos_range);\n+    }\n+\n+    pub fn remove_from_pos(&mut self, pos: Position) {\n+        self.v.remove(pos);\n+    }\n+}\n+\n+impl<T> Index<Position> for AllocationMap<T> {\n+    type Output = T;\n+\n+    fn index(&self, pos: Position) -> &Self::Output {\n+        &self.v[pos].data\n+    }\n+}\n+\n+impl<T> IndexMut<Position> for AllocationMap<T> {\n+    fn index_mut(&mut self, pos: Position) -> &mut Self::Output {\n+        &mut self.v[pos].data\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use rustc_const_eval::interpret::alloc_range;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn empty_map() {\n+        // FIXME: make Size::from_bytes const\n+        let four = Size::from_bytes(4);\n+        let map = AllocationMap::<()>::new();\n+\n+        // Correctly tells where we should insert the first element (at position 0)\n+        assert_eq!(map.find_offset(Size::from_bytes(3)), Err(0));\n+\n+        // Correctly tells the access type along with the supposed position\n+        assert_eq!(map.access_type(alloc_range(Size::ZERO, four)), AccessType::Empty(0));\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn no_overlapping_inserts() {\n+        let four = Size::from_bytes(4);\n+\n+        let mut map = AllocationMap::<&str>::new();\n+\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 1 2 3 4 5 6 7 8 9 a b c d\n+        map.insert_at_pos(0, alloc_range(four, four), \"#\");\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 ^ ^ ^ ^ 5 6 7 8 9 a b c d\n+        map.insert_at_pos(0, alloc_range(Size::from_bytes(1), four), \"@\");\n+    }\n+\n+    #[test]\n+    fn boundaries() {\n+        let four = Size::from_bytes(4);\n+\n+        let mut map = AllocationMap::<&str>::new();\n+\n+        // |#|#|#|#|_|_|...\n+        //  0 1 2 3 4 5\n+        map.insert_at_pos(0, alloc_range(Size::ZERO, four), \"#\");\n+        // |#|#|#|#|_|_|...\n+        //  0 1 2 3 ^ 5\n+        assert_eq!(map.find_offset(four), Err(1));\n+        // |#|#|#|#|_|_|_|_|_|...\n+        //  0 1 2 3 ^ ^ ^ ^ 8\n+        assert_eq!(map.access_type(alloc_range(four, four)), AccessType::Empty(1));\n+\n+        let eight = Size::from_bytes(8);\n+        // |#|#|#|#|_|_|_|_|@|@|@|@|_|_|...\n+        //  0 1 2 3 4 5 6 7 8 9 a b c d\n+        map.insert_at_pos(1, alloc_range(eight, four), \"@\");\n+        // |#|#|#|#|_|_|_|_|@|@|@|@|_|_|...\n+        //  0 1 2 3 4 5 6 ^ 8 9 a b c d\n+        assert_eq!(map.find_offset(Size::from_bytes(7)), Err(1));\n+        // |#|#|#|#|_|_|_|_|@|@|@|@|_|_|...\n+        //  0 1 2 3 ^ ^ ^ ^ 8 9 a b c d\n+        assert_eq!(map.access_type(alloc_range(four, four)), AccessType::Empty(1));\n+    }\n+\n+    #[test]\n+    fn perfectly_overlapping() {\n+        let four = Size::from_bytes(4);\n+\n+        let mut map = AllocationMap::<&str>::new();\n+\n+        // |#|#|#|#|_|_|...\n+        //  0 1 2 3 4 5\n+        map.insert_at_pos(0, alloc_range(Size::ZERO, four), \"#\");\n+        // |#|#|#|#|_|_|...\n+        //  ^ ^ ^ ^ 4 5\n+        assert_eq!(map.find_offset(Size::ZERO), Ok(0));\n+        assert_eq!(\n+            map.access_type(alloc_range(Size::ZERO, four)),\n+            AccessType::PerfectlyOverlapping(0)\n+        );\n+\n+        // |#|#|#|#|@|@|@|@|_|...\n+        //  0 1 2 3 4 5 6 7 8\n+        map.insert_at_pos(1, alloc_range(four, four), \"@\");\n+        // |#|#|#|#|@|@|@|@|_|...\n+        //  0 1 2 3 ^ ^ ^ ^ 8\n+        assert_eq!(map.find_offset(four), Ok(1));\n+        assert_eq!(map.access_type(alloc_range(four, four)), AccessType::PerfectlyOverlapping(1));\n+    }\n+\n+    #[test]\n+    fn straddling() {\n+        let four = Size::from_bytes(4);\n+\n+        let mut map = AllocationMap::<&str>::new();\n+\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 1 2 3 4 5 6 7 8 9 a b c d\n+        map.insert_at_pos(0, alloc_range(four, four), \"#\");\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 1 ^ ^ ^ ^ 6 7 8 9 a b c d\n+        assert_eq!(\n+            map.access_type(alloc_range(Size::from_bytes(2), four)),\n+            AccessType::ImperfectlyOverlapping(0..1)\n+        );\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 1 2 3 4 5 ^ ^ ^ ^ a b c d\n+        assert_eq!(\n+            map.access_type(alloc_range(Size::from_bytes(6), four)),\n+            AccessType::ImperfectlyOverlapping(0..1)\n+        );\n+        // |_|_|_|_|#|#|#|#|_|_|_|_|...\n+        //  0 1 ^ ^ ^ ^ ^ ^ ^ ^ a b c d\n+        assert_eq!(\n+            map.access_type(alloc_range(Size::from_bytes(2), Size::from_bytes(8))),\n+            AccessType::ImperfectlyOverlapping(0..1)\n+        );\n+\n+        // |_|_|_|_|#|#|#|#|_|_|@|@|_|_|...\n+        //  0 1 2 3 4 5 6 7 8 9 a b c d\n+        map.insert_at_pos(1, alloc_range(Size::from_bytes(10), Size::from_bytes(2)), \"@\");\n+        // |_|_|_|_|#|#|#|#|_|_|@|@|_|_|...\n+        //  0 1 2 3 4 5 ^ ^ ^ ^ ^ ^ ^ ^\n+        assert_eq!(\n+            map.access_type(alloc_range(Size::from_bytes(6), Size::from_bytes(8))),\n+            AccessType::ImperfectlyOverlapping(0..2)\n+        );\n+    }\n+}"}, {"sha": "28b09d2f909a3e9437de5c5a6ea87a67b19648b8", "filename": "src/concurrency/data_race.rs", "status": "renamed", "additions": 148, "deletions": 44, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -12,7 +12,7 @@\n //! The implementation also models races with memory allocation and deallocation via treating allocation and\n //! deallocation as a type of write internally for detecting data-races.\n //!\n-//! This does not explore weak memory orders and so can still miss data-races\n+//! Weak memory orders are explored but not all weak behaviours are exhibited, so it can still miss data-races\n //! but should not report false-positives\n //!\n //! Data-race definition from(<https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races>):\n@@ -29,22 +29,6 @@\n //! This means that the thread-index can be safely re-used, starting on the next timestamp for the newly created\n //! thread.\n //!\n-//! The sequentially consistent ordering corresponds to the ordering that the threads\n-//! are currently scheduled, this means that the data-race detector has no additional\n-//! logic for sequentially consistent accesses at the moment since they are indistinguishable\n-//! from acquire/release operations. If weak memory orderings are explored then this\n-//! may need to change or be updated accordingly.\n-//!\n-//! Per the C++ spec for the memory model a sequentially consistent operation:\n-//!   \"A load operation with this memory order performs an acquire operation,\n-//!    a store performs a release operation, and read-modify-write performs\n-//!    both an acquire operation and a release operation, plus a single total\n-//!    order exists in which all threads observe all modifications in the same\n-//!    order (see Sequentially-consistent ordering below) \"\n-//! So in the absence of weak memory effects a seq-cst load & a seq-cst store is identical\n-//! to an acquire load and a release store given the global sequentially consistent order\n-//! of the schedule.\n-//!\n //! The timestamps used in the data-race detector assign each sequence of non-atomic operations\n //! followed by a single atomic or concurrent operation a single timestamp.\n //! Write, Read, Write, ThreadJoin will be represented by a single timestamp value on a thread.\n@@ -74,6 +58,8 @@ use rustc_target::abi::Size;\n \n use crate::*;\n \n+use super::weak_memory::EvalContextExt as _;\n+\n pub type AllocExtra = VClockAlloc;\n \n /// Valid atomic read-write operations, alias of atomic::Ordering (not non-exhaustive).\n@@ -115,10 +101,10 @@ pub enum AtomicFenceOp {\n /// of a thread, contains the happens-before clock and\n /// additional metadata to model atomic fence operations.\n #[derive(Clone, Default, Debug)]\n-struct ThreadClockSet {\n+pub(super) struct ThreadClockSet {\n     /// The increasing clock representing timestamps\n     /// that happen-before this thread.\n-    clock: VClock,\n+    pub(super) clock: VClock,\n \n     /// The set of timestamps that will happen-before this\n     /// thread once it performs an acquire fence.\n@@ -127,6 +113,18 @@ struct ThreadClockSet {\n     /// The last timestamp of happens-before relations that\n     /// have been released by this thread by a fence.\n     fence_release: VClock,\n+\n+    /// Timestamps of the last SC fence performed by each\n+    /// thread, updated when this thread performs an SC fence\n+    pub(super) fence_seqcst: VClock,\n+\n+    /// Timestamps of the last SC write performed by each\n+    /// thread, updated when this thread performs an SC fence\n+    pub(super) write_seqcst: VClock,\n+\n+    /// Timestamps of the last SC fence performed by each\n+    /// thread, updated when this thread performs an SC read\n+    pub(super) read_seqcst: VClock,\n }\n \n impl ThreadClockSet {\n@@ -289,6 +287,15 @@ impl MemoryCellClocks {\n         Ok(())\n     }\n \n+    /// Checks if the memory cell access is ordered with all prior atomic reads and writes\n+    fn race_free_with_atomic(&self, clocks: &ThreadClockSet) -> bool {\n+        if let Some(atomic) = self.atomic() {\n+            atomic.read_vector <= clocks.clock && atomic.write_vector <= clocks.clock\n+        } else {\n+            true\n+        }\n+    }\n+\n     /// Update memory cell data-race tracking for atomic\n     /// load relaxed semantics, is a no-op if this memory was\n     /// not used previously as atomic memory.\n@@ -447,14 +454,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     #[inline]\n     fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n         let this = self.eval_context_ref();\n-        let old = if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.replace(false)\n-        } else {\n-            false\n-        };\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(true);\n+        }\n         let result = op(this);\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.set(old);\n+            data_race.ongoing_action_data_race_free.set(false);\n         }\n         result\n     }\n@@ -468,14 +473,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         op: impl FnOnce(&mut MiriEvalContext<'mir, 'tcx>) -> R,\n     ) -> R {\n         let this = self.eval_context_mut();\n-        let old = if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.replace(false)\n-        } else {\n-            false\n-        };\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(true);\n+        }\n         let result = op(this);\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.set(old);\n+            data_race.ongoing_action_data_race_free.set(false);\n         }\n         result\n     }\n@@ -514,9 +517,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicReadOp,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_ref();\n+        // This will read from the last store in the modification order of this location. In case\n+        // weak memory emulation is enabled, this may not be the store we will pick to actually read from and return.\n+        // This is fine with StackedBorrow and race checks because they don't concern metadata on\n+        // the *value* (including the associated provenance if this is an AtomicPtr) at this location.\n+        // Only metadata on the location itself is used.\n         let scalar = this.allow_data_races_ref(move |this| this.read_scalar(&place.into()))?;\n-        this.validate_atomic_load(place, atomic)?;\n-        Ok(scalar)\n+        this.validate_overlapping_atomic(place)?;\n+        this.buffered_atomic_read(place, atomic, scalar, || {\n+            this.validate_atomic_load(place, atomic)\n+        })\n     }\n \n     /// Perform an atomic write operation at the memory location.\n@@ -527,8 +537,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicWriteOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n+        this.validate_overlapping_atomic(dest)?;\n         this.allow_data_races_mut(move |this| this.write_scalar(val, &(*dest).into()))?;\n-        this.validate_atomic_store(dest, atomic)\n+        this.validate_atomic_store(dest, atomic)?;\n+        // FIXME: it's not possible to get the value before write_scalar. A read_scalar will cause\n+        // side effects from a read the program did not perform. So we have to initialise\n+        // the store buffer with the value currently being written\n+        // ONCE this is fixed please remove the hack in buffered_atomic_write() in weak_memory.rs\n+        // https://github.com/rust-lang/miri/issues/2164\n+        this.buffered_atomic_write(val, dest, atomic, val)\n     }\n \n     /// Perform an atomic operation on a memory location.\n@@ -542,6 +559,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n \n+        this.validate_overlapping_atomic(place)?;\n         let old = this.allow_data_races_mut(|this| this.read_immediate(&place.into()))?;\n \n         // Atomics wrap around on overflow.\n@@ -550,6 +568,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         this.allow_data_races_mut(|this| this.write_immediate(*val, &(*place).into()))?;\n \n         this.validate_atomic_rmw(place, atomic)?;\n+\n+        this.buffered_atomic_rmw(\n+            val.to_scalar_or_uninit(),\n+            place,\n+            atomic,\n+            old.to_scalar_or_uninit(),\n+        )?;\n         Ok(old)\n     }\n \n@@ -563,9 +588,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_mut();\n \n+        this.validate_overlapping_atomic(place)?;\n         let old = this.allow_data_races_mut(|this| this.read_scalar(&place.into()))?;\n         this.allow_data_races_mut(|this| this.write_scalar(new, &(*place).into()))?;\n+\n         this.validate_atomic_rmw(place, atomic)?;\n+\n+        this.buffered_atomic_rmw(new, place, atomic, old)?;\n         Ok(old)\n     }\n \n@@ -580,6 +609,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n \n+        this.validate_overlapping_atomic(place)?;\n         let old = this.allow_data_races_mut(|this| this.read_immediate(&place.into()))?;\n         let lt = this.binary_op(mir::BinOp::Lt, &old, &rhs)?.to_scalar()?.to_bool()?;\n \n@@ -593,6 +623,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n \n         this.validate_atomic_rmw(place, atomic)?;\n \n+        this.buffered_atomic_rmw(\n+            new_val.to_scalar_or_uninit(),\n+            place,\n+            atomic,\n+            old.to_scalar_or_uninit(),\n+        )?;\n+\n         // Return the old value.\n         Ok(old)\n     }\n@@ -615,6 +652,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         use rand::Rng as _;\n         let this = self.eval_context_mut();\n \n+        this.validate_overlapping_atomic(place)?;\n         // Failure ordering cannot be stronger than success ordering, therefore first attempt\n         // to read with the failure ordering and if successful then try again with the success\n         // read ordering and write in the success case.\n@@ -642,8 +680,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         if cmpxchg_success {\n             this.allow_data_races_mut(|this| this.write_scalar(new, &(*place).into()))?;\n             this.validate_atomic_rmw(place, success)?;\n+            this.buffered_atomic_rmw(new, place, success, old.to_scalar_or_uninit())?;\n         } else {\n             this.validate_atomic_load(place, fail)?;\n+            // A failed compare exchange is equivalent to a load, reading from the latest store\n+            // in the modification order.\n+            // Since `old` is only a value and not the store element, we need to separately\n+            // find it in our store buffer and perform load_impl on it.\n+            this.perform_read_on_buffered_latest(place, fail, old.to_scalar_or_uninit())?;\n         }\n \n         // Return the old value.\n@@ -658,6 +702,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicReadOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n+        this.validate_overlapping_atomic(place)?;\n         this.validate_atomic_op(\n             place,\n             atomic,\n@@ -680,6 +725,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicWriteOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n+        this.validate_overlapping_atomic(place)?;\n         this.validate_atomic_op(\n             place,\n             atomic,\n@@ -705,6 +751,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         let acquire = matches!(atomic, Acquire | AcqRel | SeqCst);\n         let release = matches!(atomic, Release | AcqRel | SeqCst);\n         let this = self.eval_context_mut();\n+        this.validate_overlapping_atomic(place)?;\n         this.validate_atomic_op(place, atomic, \"Atomic RMW\", move |memory, clocks, index, _| {\n             if acquire {\n                 memory.load_acquire(clocks, index)?;\n@@ -723,7 +770,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn validate_atomic_fence(&mut self, atomic: AtomicFenceOp) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if let Some(data_race) = &mut this.machine.data_race {\n-            data_race.maybe_perform_sync_operation(move |index, mut clocks| {\n+            data_race.maybe_perform_sync_operation(|index, mut clocks| {\n                 log::trace!(\"Atomic fence on {:?} with ordering {:?}\", index, atomic);\n \n                 // Apply data-race detection for the current fences\n@@ -737,6 +784,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                     // Either Release | AcqRel | SeqCst\n                     clocks.apply_release_fence();\n                 }\n+                if atomic == AtomicFenceOp::SeqCst {\n+                    data_race.last_sc_fence.borrow_mut().set_at_index(&clocks.clock, index);\n+                    clocks.fence_seqcst.join(&data_race.last_sc_fence.borrow());\n+                    clocks.write_seqcst.join(&data_race.last_sc_write.borrow());\n+                }\n \n                 // Increment timestamp in case of release semantics.\n                 Ok(atomic != AtomicFenceOp::Acquire)\n@@ -885,8 +937,23 @@ impl VClockAlloc {\n         )\n     }\n \n+    /// Detect racing atomic read and writes (not data races)\n+    /// on every byte of the current access range\n+    pub(super) fn race_free_with_atomic(&self, range: AllocRange, global: &GlobalState) -> bool {\n+        if global.race_detecting() {\n+            let (_, clocks) = global.current_thread_state();\n+            let alloc_ranges = self.alloc_ranges.borrow();\n+            for (_, range) in alloc_ranges.iter(range.start, range.size) {\n+                if !range.race_free_with_atomic(&clocks) {\n+                    return false;\n+                }\n+            }\n+        }\n+        true\n+    }\n+\n     /// Detect data-races for an unsynchronized read operation, will not perform\n-    /// data-race detection if `multi-threaded` is false, either due to no threads\n+    /// data-race detection if `race_detecting()` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation for which data-race detection is handled separately, for example\n     /// atomic read operations.\n@@ -896,7 +963,7 @@ impl VClockAlloc {\n         range: AllocRange,\n         global: &GlobalState,\n     ) -> InterpResult<'tcx> {\n-        if global.multi_threaded.get() {\n+        if global.race_detecting() {\n             let (index, clocks) = global.current_thread_state();\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n@@ -925,7 +992,7 @@ impl VClockAlloc {\n         write_type: WriteType,\n         global: &mut GlobalState,\n     ) -> InterpResult<'tcx> {\n-        if global.multi_threaded.get() {\n+        if global.race_detecting() {\n             let (index, clocks) = global.current_thread_state();\n             for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.write_race_detect(&*clocks, index, write_type) {\n@@ -946,7 +1013,7 @@ impl VClockAlloc {\n     }\n \n     /// Detect data-races for an unsynchronized write operation, will not perform\n-    /// data-race threads if `multi-threaded` is false, either due to no threads\n+    /// data-race threads if `race_detecting()` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n     pub fn write<'tcx>(\n@@ -959,7 +1026,7 @@ impl VClockAlloc {\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n-    /// data-race threads if `multi-threaded` is false, either due to no threads\n+    /// data-race threads if `race_detecting()` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n     pub fn deallocate<'tcx>(\n@@ -989,12 +1056,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n         if let Some(data_race) = &this.machine.data_race {\n-            if data_race.multi_threaded.get() {\n+            if data_race.race_detecting() {\n                 let size = place.layout.size;\n                 let (alloc_id, base_offset, _tag) = this.ptr_get_alloc_id(place.ptr)?;\n                 // Load and log the atomic operation.\n                 // Note that atomic loads are possible even from read-only allocations, so `get_alloc_extra_mut` is not an option.\n-                let alloc_meta = &this.get_alloc_extra(alloc_id)?.data_race.as_ref().unwrap();\n+                let alloc_meta = this.get_alloc_extra(alloc_id)?.data_race.as_ref().unwrap();\n                 log::trace!(\n                     \"Atomic op({}) with ordering {:?} on {:?} (size={})\",\n                     description,\n@@ -1079,6 +1146,11 @@ pub struct GlobalState {\n     /// any data-races.\n     multi_threaded: Cell<bool>,\n \n+    /// A flag to mark we are currently performing\n+    /// a data race free action (such as atomic access)\n+    /// to supress the race detector\n+    ongoing_action_data_race_free: Cell<bool>,\n+\n     /// Mapping of a vector index to a known set of thread\n     /// clocks, this is not directly mapping from a thread id\n     /// since it may refer to multiple threads.\n@@ -1116,6 +1188,12 @@ pub struct GlobalState {\n     /// The associated vector index will be moved into re-use candidates\n     /// after the join operation occurs.\n     terminated_threads: RefCell<FxHashMap<ThreadId, VectorIdx>>,\n+\n+    /// The timestamp of last SC fence performed by each thread\n+    last_sc_fence: RefCell<VClock>,\n+\n+    /// The timestamp of last SC write performed by each thread\n+    last_sc_write: RefCell<VClock>,\n }\n \n impl GlobalState {\n@@ -1124,13 +1202,16 @@ impl GlobalState {\n     pub fn new() -> Self {\n         let mut global_state = GlobalState {\n             multi_threaded: Cell::new(false),\n+            ongoing_action_data_race_free: Cell::new(false),\n             vector_clocks: RefCell::new(IndexVec::new()),\n             vector_info: RefCell::new(IndexVec::new()),\n             thread_info: RefCell::new(IndexVec::new()),\n             current_index: Cell::new(VectorIdx::new(0)),\n             active_thread_count: Cell::new(1),\n             reuse_candidates: RefCell::new(FxHashSet::default()),\n             terminated_threads: RefCell::new(FxHashMap::default()),\n+            last_sc_fence: RefCell::new(VClock::default()),\n+            last_sc_write: RefCell::new(VClock::default()),\n         };\n \n         // Setup the main-thread since it is not explicitly created:\n@@ -1147,6 +1228,17 @@ impl GlobalState {\n         global_state\n     }\n \n+    // We perform data race detection when there are more than 1 active thread\n+    // and we have not temporarily disabled race detection to perform something\n+    // data race free\n+    fn race_detecting(&self) -> bool {\n+        self.multi_threaded.get() && !self.ongoing_action_data_race_free.get()\n+    }\n+\n+    pub fn ongoing_action_data_race_free(&self) -> bool {\n+        self.ongoing_action_data_race_free.get()\n+    }\n+\n     // Try to find vector index values that can potentially be re-used\n     // by a new thread instead of a new vector index being created.\n     fn find_vector_index_reuse_candidate(&self) -> Option<VectorIdx> {\n@@ -1445,7 +1537,7 @@ impl GlobalState {\n     /// Load the current vector clock in use and the current set of thread clocks\n     /// in use for the vector.\n     #[inline]\n-    fn current_thread_state(&self) -> (VectorIdx, Ref<'_, ThreadClockSet>) {\n+    pub(super) fn current_thread_state(&self) -> (VectorIdx, Ref<'_, ThreadClockSet>) {\n         let index = self.current_index();\n         let ref_vector = self.vector_clocks.borrow();\n         let clocks = Ref::map(ref_vector, |vec| &vec[index]);\n@@ -1455,7 +1547,7 @@ impl GlobalState {\n     /// Load the current vector clock in use and the current set of thread clocks\n     /// in use for the vector mutably for modification.\n     #[inline]\n-    fn current_thread_state_mut(&self) -> (VectorIdx, RefMut<'_, ThreadClockSet>) {\n+    pub(super) fn current_thread_state_mut(&self) -> (VectorIdx, RefMut<'_, ThreadClockSet>) {\n         let index = self.current_index();\n         let ref_vector = self.vector_clocks.borrow_mut();\n         let clocks = RefMut::map(ref_vector, |vec| &mut vec[index]);\n@@ -1468,4 +1560,16 @@ impl GlobalState {\n     fn current_index(&self) -> VectorIdx {\n         self.current_index.get()\n     }\n+\n+    // SC ATOMIC STORE rule in the paper.\n+    pub(super) fn sc_write(&self) {\n+        let (index, clocks) = self.current_thread_state();\n+        self.last_sc_write.borrow_mut().set_at_index(&clocks.clock, index);\n+    }\n+\n+    // SC ATOMIC READ rule in the paper.\n+    pub(super) fn sc_read(&self) {\n+        let (.., mut clocks) = self.current_thread_state_mut();\n+        clocks.read_seqcst.join(&self.last_sc_fence.borrow());\n+    }\n }", "previous_filename": "src/data_race.rs"}, {"sha": "ad1586bbf0f9bff36b5a054c6d1a44a61df2edb1", "filename": "src/concurrency/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fconcurrency%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fconcurrency%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fmod.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,3 @@\n+mod allocation_map;\n+pub mod data_race;\n+pub mod weak_memory;"}, {"sha": "da36fcd2fb3a8418ec9ba45f900573cc45bef237", "filename": "src/concurrency/weak_memory.rs", "status": "added", "additions": 570, "deletions": 0, "changes": 570, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,570 @@\n+//! Implementation of C++11-consistent weak memory emulation using store buffers\n+//! based on Dynamic Race Detection for C++ (\"the paper\"):\n+//! https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf\n+//!\n+//! This implementation will never generate weak memory behaviours forbidden by the C++11 model,\n+//! but it is incapable of producing all possible weak behaviours allowed by the model. There are\n+//! certain weak behaviours observable on real hardware but not while using this.\n+//!\n+//! Note that this implementation does not take into account of C++20's memory model revision to SC accesses\n+//! and fences introduced by P0668 (https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html).\n+//! This implementation is not fully correct under the revised C++20 model and may generate behaviours C++20\n+//! disallows.\n+//!\n+//! Rust follows the C++20 memory model (except for the Consume ordering and some operations not performable through C++'s\n+//! std::atomic<T> API). It is therefore possible for this implementation to generate behaviours never observable when the\n+//! same program is compiled and run natively. Unfortunately, no literature exists at the time of writing which proposes\n+//! an implementable and C++20-compatible relaxed memory model that supports all atomic operation existing in Rust. The closest one is\n+//! A Promising Semantics for Relaxed-Memory Concurrency by Jeehoon Kang et al. (https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf)\n+//! However, this model lacks SC accesses and is therefore unusable by Miri (SC accesses are everywhere in library code).\n+//!\n+//! If you find anything that proposes a relaxed memory model that is C++20-consistent, supports all orderings Rust's atomic accesses\n+//! and fences accept, and is implementable (with operational semanitcs), please open a GitHub issue!\n+//!\n+//! One characteristic of this implementation, in contrast to some other notable operational models such as ones proposed in\n+//! Taming Release-Acquire Consistency by Ori Lahav et al. (https://plv.mpi-sws.org/sra/paper.pdf) or Promising Semantics noted above,\n+//! is that this implementation does not require each thread to hold an isolated view of the entire memory. Here, store buffers are per-location\n+//! and shared across all threads. This is more memory efficient but does require store elements (representing writes to a location) to record\n+//! information about reads, whereas in the other two models it is the other way round: reads points to the write it got its value from.\n+//! Additionally, writes in our implementation do not have globally unique timestamps attached. In the other two models this timestamp is\n+//! used to make sure a value in a thread's view is not overwritten by a write that occured earlier than the one in the existing view.\n+//! In our implementation, this is detected using read information attached to store elements, as there is no data strucutre representing reads.\n+//!\n+//! The C++ memory model is built around the notion of an 'atomic object', so it would be natural\n+//! to attach store buffers to atomic objects. However, Rust follows LLVM in that it only has\n+//! 'atomic accesses'. Therefore Miri cannot know when and where atomic 'objects' are being\n+//! created or destroyed, to manage its store buffers. Instead, we hence lazily create an\n+//! atomic object on the first atomic access to a given region, and we destroy that object\n+//! on the next non-atomic or imperfectly overlapping atomic access to that region.\n+//! These lazy (de)allocations happen in memory_accessed() on non-atomic accesses, and\n+//! get_or_create_store_buffer() on atomic accesses. This mostly works well, but it does\n+//! lead to some issues (https://github.com/rust-lang/miri/issues/2164).\n+//!\n+//! One consequence of this difference is that safe/sound Rust allows for more operations on atomic locations\n+//! than the C++20 atomic API was intended to allow, such as non-atomically accessing\n+//! a previously atomically accessed location, or accessing previously atomically accessed locations with a differently sized operation\n+//! (such as accessing the top 16 bits of an AtomicU32). These senarios are generally undiscussed in formalisations of C++ memory model.\n+//! In Rust, these operations can only be done through a `&mut AtomicFoo` reference or one derived from it, therefore these operations\n+//! can only happen after all previous accesses on the same locations. This implementation is adapted to allow these operations.\n+//! A mixed atomicity read that races with writes, or a write that races with reads or writes will still cause UBs to be thrown.\n+//! Mixed size atomic accesses must not race with any other atomic access, whether read or write, or a UB will be thrown.\n+//! You can refer to test cases in weak_memory/extra_cpp.rs and weak_memory/extra_cpp_unsafe.rs for examples of these operations.\n+\n+// Our and the author's own implementation (tsan11) of the paper have some deviations from the provided operational semantics in \u00a75.3:\n+// 1. In the operational semantics, store elements keep a copy of the atomic object's vector clock (AtomicCellClocks::sync_vector in miri),\n+// but this is not used anywhere so it's omitted here.\n+//\n+// 2. In the operational semantics, each store element keeps the timestamp of a thread when it loads from the store.\n+// If the same thread loads from the same store element multiple times, then the timestamps at all loads are saved in a list of load elements.\n+// This is not necessary as later loads by the same thread will always have greater timetstamp values, so we only need to record the timestamp of the first\n+// load by each thread. This optimisation is done in tsan11\n+// (https://github.com/ChrisLidbury/tsan11/blob/ecbd6b81e9b9454e01cba78eb9d88684168132c7/lib/tsan/rtl/tsan_relaxed.h#L35-L37)\n+// and here.\n+//\n+// 3. \u00a74.5 of the paper wants an SC store to mark all existing stores in the buffer that happens before it\n+// as SC. This is not done in the operational semantics but implemented correctly in tsan11\n+// (https://github.com/ChrisLidbury/tsan11/blob/ecbd6b81e9b9454e01cba78eb9d88684168132c7/lib/tsan/rtl/tsan_relaxed.cc#L160-L167)\n+// and here.\n+//\n+// 4. W_SC ; R_SC case requires the SC load to ignore all but last store maked SC (stores not marked SC are not\n+// affected). But this rule is applied to all loads in ReadsFromSet from the paper (last two lines of code), not just SC load.\n+// This is implemented correctly in tsan11\n+// (https://github.com/ChrisLidbury/tsan11/blob/ecbd6b81e9b9454e01cba78eb9d88684168132c7/lib/tsan/rtl/tsan_relaxed.cc#L295)\n+// and here.\n+\n+use std::{\n+    cell::{Ref, RefCell},\n+    collections::VecDeque,\n+};\n+\n+use rustc_const_eval::interpret::{\n+    alloc_range, AllocRange, InterpResult, MPlaceTy, ScalarMaybeUninit,\n+};\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use crate::{AtomicReadOp, AtomicRwOp, AtomicWriteOp, Tag, VClock, VTimestamp, VectorIdx};\n+\n+use super::{\n+    allocation_map::{AccessType, AllocationMap},\n+    data_race::{GlobalState, ThreadClockSet},\n+};\n+\n+pub type AllocExtra = StoreBufferAlloc;\n+\n+// Each store buffer must be bounded otherwise it will grow indefinitely.\n+// However, bounding the store buffer means restricting the amount of weak\n+// behaviours observable. The author picked 128 as a good tradeoff\n+// so we follow them here.\n+const STORE_BUFFER_LIMIT: usize = 128;\n+\n+#[derive(Debug, Clone)]\n+pub struct StoreBufferAlloc {\n+    /// Store buffer of each atomic object in this allocation\n+    // Behind a RefCell because we need to allocate/remove on read access\n+    store_buffers: RefCell<AllocationMap<StoreBuffer>>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(super) struct StoreBuffer {\n+    // Stores to this location in modification order\n+    buffer: VecDeque<StoreElement>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+struct StoreElement {\n+    /// The identifier of the vector index, corresponding to a thread\n+    /// that performed the store.\n+    store_index: VectorIdx,\n+\n+    /// Whether this store is SC.\n+    is_seqcst: bool,\n+\n+    /// The timestamp of the storing thread when it performed the store\n+    timestamp: VTimestamp,\n+    /// The value of this store\n+    // FIXME: this means the store is either fully initialized or fully uninitialized;\n+    // we will have to change this if we want to support atomics on\n+    // partially initialized data.\n+    val: ScalarMaybeUninit<Tag>,\n+\n+    /// Timestamp of first loads from this store element by each thread\n+    /// Behind a RefCell to keep load op take &self\n+    loads: RefCell<FxHashMap<VectorIdx, VTimestamp>>,\n+}\n+\n+impl StoreBufferAlloc {\n+    pub fn new_allocation() -> Self {\n+        Self { store_buffers: RefCell::new(AllocationMap::new()) }\n+    }\n+\n+    /// Checks if the range imperfectly overlaps with existing buffers\n+    /// Used to determine if mixed-size atomic accesses\n+    fn is_overlapping(&self, range: AllocRange) -> bool {\n+        let buffers = self.store_buffers.borrow();\n+        let access_type = buffers.access_type(range);\n+        matches!(access_type, AccessType::ImperfectlyOverlapping(_))\n+    }\n+\n+    /// When a non-atomic access happens on a location that has been atomically accessed\n+    /// before without data race, we can determine that the non-atomic access fully happens\n+    /// after all the prior atomic accesses so the location no longer needs to exhibit\n+    /// any weak memory behaviours until further atomic accesses.\n+    pub fn memory_accessed(&self, range: AllocRange, global: &GlobalState) {\n+        if !global.ongoing_action_data_race_free() {\n+            let mut buffers = self.store_buffers.borrow_mut();\n+            let access_type = buffers.access_type(range);\n+            match access_type {\n+                AccessType::PerfectlyOverlapping(pos) => {\n+                    buffers.remove_from_pos(pos);\n+                }\n+                AccessType::ImperfectlyOverlapping(pos_range) => {\n+                    buffers.remove_pos_range(pos_range);\n+                }\n+                AccessType::Empty(_) => {\n+                    // The range had no weak behaivours attached, do nothing\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Gets a store buffer associated with an atomic object in this allocation,\n+    /// or creates one with the specified initial value if no atomic object exists yet.\n+    fn get_or_create_store_buffer<'tcx>(\n+        &self,\n+        range: AllocRange,\n+        init: ScalarMaybeUninit<Tag>,\n+    ) -> InterpResult<'tcx, Ref<'_, StoreBuffer>> {\n+        let access_type = self.store_buffers.borrow().access_type(range);\n+        let pos = match access_type {\n+            AccessType::PerfectlyOverlapping(pos) => pos,\n+            AccessType::Empty(pos) => {\n+                let mut buffers = self.store_buffers.borrow_mut();\n+                buffers.insert_at_pos(pos, range, StoreBuffer::new(init));\n+                pos\n+            }\n+            AccessType::ImperfectlyOverlapping(pos_range) => {\n+                // Once we reach here we would've already checked that this access is not racy\n+                let mut buffers = self.store_buffers.borrow_mut();\n+                buffers.remove_pos_range(pos_range.clone());\n+                buffers.insert_at_pos(pos_range.start, range, StoreBuffer::new(init));\n+                pos_range.start\n+            }\n+        };\n+        Ok(Ref::map(self.store_buffers.borrow(), |buffer| &buffer[pos]))\n+    }\n+\n+    /// Gets a mutable store buffer associated with an atomic object in this allocation\n+    fn get_or_create_store_buffer_mut<'tcx>(\n+        &mut self,\n+        range: AllocRange,\n+        init: ScalarMaybeUninit<Tag>,\n+    ) -> InterpResult<'tcx, &mut StoreBuffer> {\n+        let buffers = self.store_buffers.get_mut();\n+        let access_type = buffers.access_type(range);\n+        let pos = match access_type {\n+            AccessType::PerfectlyOverlapping(pos) => pos,\n+            AccessType::Empty(pos) => {\n+                buffers.insert_at_pos(pos, range, StoreBuffer::new(init));\n+                pos\n+            }\n+            AccessType::ImperfectlyOverlapping(pos_range) => {\n+                buffers.remove_pos_range(pos_range.clone());\n+                buffers.insert_at_pos(pos_range.start, range, StoreBuffer::new(init));\n+                pos_range.start\n+            }\n+        };\n+        Ok(&mut buffers[pos])\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> StoreBuffer {\n+    fn new(init: ScalarMaybeUninit<Tag>) -> Self {\n+        let mut buffer = VecDeque::new();\n+        buffer.reserve(STORE_BUFFER_LIMIT);\n+        let mut ret = Self { buffer };\n+        let store_elem = StoreElement {\n+            // The thread index and timestamp of the initialisation write\n+            // are never meaningfully used, so it's fine to leave them as 0\n+            store_index: VectorIdx::from(0),\n+            timestamp: 0,\n+            val: init,\n+            is_seqcst: false,\n+            loads: RefCell::new(FxHashMap::default()),\n+        };\n+        ret.buffer.push_back(store_elem);\n+        ret\n+    }\n+\n+    /// Reads from the last store in modification order\n+    fn read_from_last_store(&self, global: &GlobalState) {\n+        let store_elem = self.buffer.back();\n+        if let Some(store_elem) = store_elem {\n+            let (index, clocks) = global.current_thread_state();\n+            store_elem.load_impl(index, &clocks);\n+        }\n+    }\n+\n+    fn buffered_read(\n+        &self,\n+        global: &GlobalState,\n+        is_seqcst: bool,\n+        rng: &mut (impl rand::Rng + ?Sized),\n+        validate: impl FnOnce() -> InterpResult<'tcx>,\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+        // Having a live borrow to store_buffer while calling validate_atomic_load is fine\n+        // because the race detector doesn't touch store_buffer\n+\n+        let store_elem = {\n+            // The `clocks` we got here must be dropped before calling validate_atomic_load\n+            // as the race detector will update it\n+            let (.., clocks) = global.current_thread_state();\n+            // Load from a valid entry in the store buffer\n+            self.fetch_store(is_seqcst, &clocks, &mut *rng)\n+        };\n+\n+        // Unlike in buffered_atomic_write, thread clock updates have to be done\n+        // after we've picked a store element from the store buffer, as presented\n+        // in ATOMIC LOAD rule of the paper. This is because fetch_store\n+        // requires access to ThreadClockSet.clock, which is updated by the race detector\n+        validate()?;\n+\n+        let (index, clocks) = global.current_thread_state();\n+        let loaded = store_elem.load_impl(index, &clocks);\n+        Ok(loaded)\n+    }\n+\n+    fn buffered_write(\n+        &mut self,\n+        val: ScalarMaybeUninit<Tag>,\n+        global: &GlobalState,\n+        is_seqcst: bool,\n+    ) -> InterpResult<'tcx> {\n+        let (index, clocks) = global.current_thread_state();\n+\n+        self.store_impl(val, index, &clocks.clock, is_seqcst);\n+        Ok(())\n+    }\n+\n+    /// Selects a valid store element in the buffer.\n+    fn fetch_store<R: rand::Rng + ?Sized>(\n+        &self,\n+        is_seqcst: bool,\n+        clocks: &ThreadClockSet,\n+        rng: &mut R,\n+    ) -> &StoreElement {\n+        use rand::seq::IteratorRandom;\n+        let mut found_sc = false;\n+        // FIXME: we want an inclusive take_while (stops after a false predicate, but\n+        // includes the element that gave the false), but such function doesn't yet\n+        // exist in the standard libary https://github.com/rust-lang/rust/issues/62208\n+        // so we have to hack around it with keep_searching\n+        let mut keep_searching = true;\n+        let candidates = self\n+            .buffer\n+            .iter()\n+            .rev()\n+            .take_while(move |&store_elem| {\n+                if !keep_searching {\n+                    return false;\n+                }\n+\n+                keep_searching = if store_elem.timestamp <= clocks.clock[store_elem.store_index] {\n+                    // CoWR: if a store happens-before the current load,\n+                    // then we can't read-from anything earlier in modification order.\n+                    log::info!(\"Stopping due to coherent write-read\");\n+                    false\n+                } else if store_elem.loads.borrow().iter().any(|(&load_index, &load_timestamp)| {\n+                    load_timestamp <= clocks.clock[load_index]\n+                }) {\n+                    // CoRR: if there was a load from this store which happened-before the current load,\n+                    // then we cannot read-from anything earlier in modification order.\n+                    log::info!(\"Stopping due to coherent read-read\");\n+                    false\n+                } else if store_elem.timestamp <= clocks.fence_seqcst[store_elem.store_index] {\n+                    // The current load, which may be sequenced-after an SC fence, can only read-from\n+                    // the last store sequenced-before an SC fence in another thread (or any stores\n+                    // later than that SC fence)\n+                    log::info!(\"Stopping due to coherent load sequenced after sc fence\");\n+                    false\n+                } else if store_elem.timestamp <= clocks.write_seqcst[store_elem.store_index]\n+                    && store_elem.is_seqcst\n+                {\n+                    // The current non-SC load can only read-from the latest SC store (or any stores later than that\n+                    // SC store)\n+                    log::info!(\"Stopping due to needing to load from the last SC store\");\n+                    false\n+                } else if is_seqcst && store_elem.timestamp <= clocks.read_seqcst[store_elem.store_index] {\n+                    // The current SC load can only read-from the last store sequenced-before\n+                    // the last SC fence (or any stores later than the SC fence)\n+                    log::info!(\"Stopping due to sc load needing to load from the last SC store before an SC fence\");\n+                    false\n+                } else {true};\n+\n+                true\n+            })\n+            .filter(|&store_elem| {\n+                if is_seqcst && store_elem.is_seqcst {\n+                    // An SC load needs to ignore all but last store maked SC (stores not marked SC are not\n+                    // affected)\n+                    let include = !found_sc;\n+                    found_sc = true;\n+                    include\n+                } else {\n+                    true\n+                }\n+            });\n+\n+        candidates\n+            .choose(rng)\n+            .expect(\"store buffer cannot be empty, an element is populated on construction\")\n+    }\n+\n+    /// ATOMIC STORE IMPL in the paper (except we don't need the location's vector clock)\n+    fn store_impl(\n+        &mut self,\n+        val: ScalarMaybeUninit<Tag>,\n+        index: VectorIdx,\n+        thread_clock: &VClock,\n+        is_seqcst: bool,\n+    ) {\n+        let store_elem = StoreElement {\n+            store_index: index,\n+            timestamp: thread_clock[index],\n+            // In the language provided in the paper, an atomic store takes the value from a\n+            // non-atomic memory location.\n+            // But we already have the immediate value here so we don't need to do the memory\n+            // access\n+            val,\n+            is_seqcst,\n+            loads: RefCell::new(FxHashMap::default()),\n+        };\n+        self.buffer.push_back(store_elem);\n+        if self.buffer.len() > STORE_BUFFER_LIMIT {\n+            self.buffer.pop_front();\n+        }\n+        if is_seqcst {\n+            // Every store that happens before this needs to be marked as SC\n+            // so that in a later SC load, only the last SC store (i.e. this one) or stores that\n+            // aren't ordered by hb with the last SC is picked.\n+            self.buffer.iter_mut().rev().for_each(|elem| {\n+                if elem.timestamp <= thread_clock[elem.store_index] {\n+                    elem.is_seqcst = true;\n+                }\n+            })\n+        }\n+    }\n+}\n+\n+impl StoreElement {\n+    /// ATOMIC LOAD IMPL in the paper\n+    /// Unlike the operational semantics in the paper, we don't need to keep track\n+    /// of the thread timestamp for every single load. Keeping track of the first (smallest)\n+    /// timestamp of each thread that has loaded from a store is sufficient: if the earliest\n+    /// load of another thread happens before the current one, then we must stop searching the store\n+    /// buffer regardless of subsequent loads by the same thread; if the earliest load of another\n+    /// thread doesn't happen before the current one, then no subsequent load by the other thread\n+    /// can happen before the current one.\n+    fn load_impl(&self, index: VectorIdx, clocks: &ThreadClockSet) -> ScalarMaybeUninit<Tag> {\n+        let _ = self.loads.borrow_mut().try_insert(index, clocks.clock[index]);\n+        self.val\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n+    crate::MiriEvalContextExt<'mir, 'tcx>\n+{\n+    // If weak memory emulation is enabled, check if this atomic op imperfectly overlaps with a previous\n+    // atomic read or write. If it does, then we require it to be ordered (non-racy) with all previous atomic\n+    // accesses on all the bytes in range\n+    fn validate_overlapping_atomic(&self, place: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+        let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n+        if let crate::AllocExtra {\n+            weak_memory: Some(alloc_buffers),\n+            data_race: Some(alloc_clocks),\n+            ..\n+        } = this.get_alloc_extra(alloc_id)?\n+        {\n+            let range = alloc_range(base_offset, place.layout.size);\n+            if alloc_buffers.is_overlapping(range)\n+                && !alloc_clocks\n+                    .race_free_with_atomic(range, this.machine.data_race.as_ref().unwrap())\n+            {\n+                throw_unsup_format!(\n+                    \"racy imperfectly overlapping atomic access is not possible in the C++20 memory model, and not supported by Miri's weak memory emulation\"\n+                );\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn buffered_atomic_rmw(\n+        &mut self,\n+        new_val: ScalarMaybeUninit<Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n+        atomic: AtomicRwOp,\n+        init: ScalarMaybeUninit<Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n+        if let (\n+            crate::AllocExtra { weak_memory: Some(alloc_buffers), .. },\n+            crate::Evaluator { data_race: Some(global), .. },\n+        ) = this.get_alloc_extra_mut(alloc_id)?\n+        {\n+            if atomic == AtomicRwOp::SeqCst {\n+                global.sc_read();\n+                global.sc_write();\n+            }\n+            let range = alloc_range(base_offset, place.layout.size);\n+            let buffer = alloc_buffers.get_or_create_store_buffer_mut(range, init)?;\n+            buffer.read_from_last_store(global);\n+            buffer.buffered_write(new_val, global, atomic == AtomicRwOp::SeqCst)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn buffered_atomic_read(\n+        &self,\n+        place: &MPlaceTy<'tcx, Tag>,\n+        atomic: AtomicReadOp,\n+        latest_in_mo: ScalarMaybeUninit<Tag>,\n+        validate: impl FnOnce() -> InterpResult<'tcx>,\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+        let this = self.eval_context_ref();\n+        if let Some(global) = &this.machine.data_race {\n+            let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n+            if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n+                if atomic == AtomicReadOp::SeqCst {\n+                    global.sc_read();\n+                }\n+                let mut rng = this.machine.rng.borrow_mut();\n+                let buffer = alloc_buffers.get_or_create_store_buffer(\n+                    alloc_range(base_offset, place.layout.size),\n+                    latest_in_mo,\n+                )?;\n+                let loaded = buffer.buffered_read(\n+                    global,\n+                    atomic == AtomicReadOp::SeqCst,\n+                    &mut *rng,\n+                    validate,\n+                )?;\n+\n+                return Ok(loaded);\n+            }\n+        }\n+\n+        // Race detector or weak memory disabled, simply read the latest value\n+        validate()?;\n+        Ok(latest_in_mo)\n+    }\n+\n+    fn buffered_atomic_write(\n+        &mut self,\n+        val: ScalarMaybeUninit<Tag>,\n+        dest: &MPlaceTy<'tcx, Tag>,\n+        atomic: AtomicWriteOp,\n+        init: ScalarMaybeUninit<Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(dest.ptr)?;\n+        if let (\n+            crate::AllocExtra { weak_memory: Some(alloc_buffers), .. },\n+            crate::Evaluator { data_race: Some(global), .. },\n+        ) = this.get_alloc_extra_mut(alloc_id)?\n+        {\n+            if atomic == AtomicWriteOp::SeqCst {\n+                global.sc_write();\n+            }\n+\n+            // UGLY HACK: in write_scalar_atomic() we don't know the value before our write,\n+            // so init == val always. If the buffer is fresh then we would've duplicated an entry,\n+            // so we need to remove it.\n+            // See https://github.com/rust-lang/miri/issues/2164\n+            let was_empty = matches!(\n+                alloc_buffers\n+                    .store_buffers\n+                    .borrow()\n+                    .access_type(alloc_range(base_offset, dest.layout.size)),\n+                AccessType::Empty(_)\n+            );\n+            let buffer = alloc_buffers\n+                .get_or_create_store_buffer_mut(alloc_range(base_offset, dest.layout.size), init)?;\n+            if was_empty {\n+                buffer.buffer.pop_front();\n+            }\n+\n+            buffer.buffered_write(val, global, atomic == AtomicWriteOp::SeqCst)?;\n+        }\n+\n+        // Caller should've written to dest with the vanilla scalar write, we do nothing here\n+        Ok(())\n+    }\n+\n+    /// Caller should never need to consult the store buffer for the latest value.\n+    /// This function is used exclusively for failed atomic_compare_exchange_scalar\n+    /// to perform load_impl on the latest store element\n+    fn perform_read_on_buffered_latest(\n+        &self,\n+        place: &MPlaceTy<'tcx, Tag>,\n+        atomic: AtomicReadOp,\n+        init: ScalarMaybeUninit<Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+\n+        if let Some(global) = &this.machine.data_race {\n+            if atomic == AtomicReadOp::SeqCst {\n+                global.sc_read();\n+            }\n+            let size = place.layout.size;\n+            let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n+            if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n+                let buffer = alloc_buffers\n+                    .get_or_create_store_buffer(alloc_range(base_offset, size), init)?;\n+                buffer.read_from_last_store(global);\n+            }\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "bdf527a0d13e0565a479859ca39d8b6ce2750555", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -105,6 +105,8 @@ pub struct MiriConfig {\n     pub tag_raw: bool,\n     /// Determine if data race detection should be enabled\n     pub data_race_detector: bool,\n+    /// Determine if weak memory emulation should be enabled. Requires data race detection to be enabled\n+    pub weak_memory_emulation: bool,\n     /// Rate of spurious failures for compare_exchange_weak atomic operations,\n     /// between 0.0 and 1.0, defaulting to 0.8 (80% chance of failure).\n     pub cmpxchg_weak_failure_rate: f64,\n@@ -142,6 +144,7 @@ impl Default for MiriConfig {\n             tracked_alloc_ids: HashSet::default(),\n             tag_raw: false,\n             data_race_detector: true,\n+            weak_memory_emulation: true,\n             cmpxchg_weak_failure_rate: 0.8,\n             measureme_out: None,\n             panic_on_unsupported: false,"}, {"sha": "982d3873d57304af303abc33606e502544b0b008", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -31,7 +31,7 @@ extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n \n-mod data_race;\n+mod concurrency;\n mod diagnostics;\n mod eval;\n mod helpers;\n@@ -63,7 +63,7 @@ pub use crate::shims::time::EvalContextExt as _;\n pub use crate::shims::tls::{EvalContextExt as _, TlsData};\n pub use crate::shims::EvalContextExt as _;\n \n-pub use crate::data_race::{\n+pub use crate::concurrency::data_race::{\n     AtomicFenceOp, AtomicReadOp, AtomicRwOp, AtomicWriteOp,\n     EvalContextExt as DataRaceEvalContextExt,\n };"}, {"sha": "1ae49edd6001a1cfc213f3c8b12f21c398a9154f", "filename": "src/machine.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -28,7 +28,11 @@ use rustc_span::Symbol;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n-use crate::{shims::unix::FileHandler, *};\n+use crate::{\n+    concurrency::{data_race, weak_memory},\n+    shims::unix::FileHandler,\n+    *,\n+};\n \n // Some global facts about the emulated machine.\n pub const PAGE_SIZE: u64 = 4 * 1024; // FIXME: adjust to target architecture\n@@ -190,6 +194,9 @@ pub struct AllocExtra {\n     /// Data race detection via the use of a vector-clock,\n     ///  this is only added if it is enabled.\n     pub data_race: Option<data_race::AllocExtra>,\n+    /// Weak memory emulation via the use of store buffers,\n+    ///  this is only added if it is enabled.\n+    pub weak_memory: Option<weak_memory::AllocExtra>,\n }\n \n /// Precomputed layouts of primitive types\n@@ -323,6 +330,9 @@ pub struct Evaluator<'mir, 'tcx> {\n \n     /// Corresponds to -Zmiri-mute-stdout-stderr and doesn't write the output but acts as if it succeeded.\n     pub(crate) mute_stdout_stderr: bool,\n+\n+    /// Whether weak memory emulation is enabled\n+    pub(crate) weak_memory: bool,\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n@@ -378,6 +388,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             check_alignment: config.check_alignment,\n             cmpxchg_weak_failure_rate: config.cmpxchg_weak_failure_rate,\n             mute_stdout_stderr: config.mute_stdout_stderr,\n+            weak_memory: config.weak_memory_emulation,\n         }\n     }\n \n@@ -626,9 +637,18 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         } else {\n             None\n         };\n+        let buffer_alloc = if ecx.machine.weak_memory {\n+            Some(weak_memory::AllocExtra::new_allocation())\n+        } else {\n+            None\n+        };\n         let alloc: Allocation<Tag, Self::AllocExtra> = alloc.convert_tag_add_extra(\n             &ecx.tcx,\n-            AllocExtra { stacked_borrows: stacks, data_race: race_alloc },\n+            AllocExtra {\n+                stacked_borrows: stacks,\n+                data_race: race_alloc,\n+                weak_memory: buffer_alloc,\n+            },\n             |ptr| Evaluator::tag_alloc_base_pointer(ecx, ptr),\n         );\n         Cow::Owned(alloc)\n@@ -716,10 +736,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n                 machine.current_span(),\n-            )\n-        } else {\n-            Ok(())\n+            )?;\n+        }\n+        if let Some(weak_memory) = &alloc_extra.weak_memory {\n+            weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n         }\n+        Ok(())\n     }\n \n     #[inline(always)]\n@@ -740,10 +762,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n                 machine.current_span(),\n-            )\n-        } else {\n-            Ok(())\n+            )?;\n         }\n+        if let Some(weak_memory) = &alloc_extra.weak_memory {\n+            weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n+        }\n+        Ok(())\n     }\n \n     #[inline(always)]"}, {"sha": "4dc40cf2fe3dc9e40707c12af1a03b947bc2eb2c", "filename": "src/shims/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fthread.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -14,7 +14,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.tcx.sess.warn(\n-            \"thread support is experimental and incomplete: weak memory effects are not emulated.\",\n+            \"thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\\n(see https://github.com/rust-lang/miri/issues/1388)\",\n         );\n \n         // Create the new thread"}, {"sha": "0d702fd9c8e17e5510937b76f6aa6ce53d37fe97", "filename": "src/thread.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::Mutability;\n \n+use crate::concurrency::data_race;\n use crate::sync::SynchronizationState;\n use crate::*;\n "}, {"sha": "716fdba0f67c29aee28d5448eba1c55a46660956", "filename": "src/vector_clock.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fvector_clock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/src%2Fvector_clock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvector_clock.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -108,10 +108,8 @@ impl VClock {\n \n     /// Set the element at the current index of the vector\n     pub fn set_at_index(&mut self, other: &Self, idx: VectorIdx) {\n-        let idx = idx.index();\n-        let mut_slice = self.get_mut_with_min_len(idx + 1);\n-        let slice = other.as_slice();\n-        mut_slice[idx] = slice[idx];\n+        let mut_slice = self.get_mut_with_min_len(idx.index() + 1);\n+        mut_slice[idx.index()] = other[idx];\n     }\n \n     /// Set the vector to the all-zero vector"}, {"sha": "2ce73fdaaec101ab0108c858311a57c652345f5f", "filename": "tests/fail/concurrency/libc_pthread_create_main_terminate.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_main_terminate.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: the main thread terminated without waiting for all remaining threads\n "}, {"sha": "b106cc4c9541852d53aed8f1aef913162a8a200e", "filename": "tests/fail/concurrency/libc_pthread_join_detached.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: trying to join a detached or already joined thread\n   --> $DIR/libc_pthread_join_detached.rs:LL:CC"}, {"sha": "438998208d11b6e62f47b5ba09d1a6e9f597416b", "filename": "tests/fail/concurrency/libc_pthread_join_joined.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: trying to join a detached or already joined thread\n   --> $DIR/libc_pthread_join_joined.rs:LL:CC"}, {"sha": "04f2ab07406c0b0534cce64b64f9bbdd35756b9d", "filename": "tests/fail/concurrency/libc_pthread_join_main.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: trying to join a detached or already joined thread\n   --> $DIR/libc_pthread_join_main.rs:LL:CC"}, {"sha": "daf18c50e034ff21223b07bbbd543dd78adcc783", "filename": "tests/fail/concurrency/libc_pthread_join_multiple.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: trying to join a detached or already joined thread\n   --> $DIR/libc_pthread_join_multiple.rs:LL:CC"}, {"sha": "b2e0779f5fbbd68b0e8b73b1effa1f464ab6e864", "filename": "tests/fail/concurrency/libc_pthread_join_self.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_self.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: trying to join itself\n   --> $DIR/libc_pthread_join_self.rs:LL:CC"}, {"sha": "ad5528dc555ab897757a1a32a51fd4902c80517f", "filename": "tests/fail/concurrency/thread_local_static_dealloc.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: pointer to ALLOC was dereferenced after this allocation got freed\n   --> $DIR/thread_local_static_dealloc.rs:LL:CC"}, {"sha": "1ed8c5a510f4f854203375ce052e85bbdd1a39df", "filename": "tests/fail/concurrency/too_few_args.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Ftoo_few_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Ftoo_few_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Ftoo_few_args.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: callee has fewer arguments than expected\n   --> $DIR/too_few_args.rs:LL:CC"}, {"sha": "5602dab993b0842ee0d0efa02d2eb61368e6d5a1", "filename": "tests/fail/concurrency/too_many_args.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Ftoo_many_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Ftoo_many_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Ftoo_many_args.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: callee has more arguments than expected\n   --> $DIR/too_many_args.rs:LL:CC"}, {"sha": "26a196a5590f18a9798ee51e965e9ca00abd7f1e", "filename": "tests/fail/concurrency/unwind_top_of_stack.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n thread '<unnamed>' panicked at 'explicit panic', $DIR/unwind_top_of_stack.rs:LL:CC\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "2ddbb657245a625d723572579f3f25cda1b8a8cc", "filename": "tests/fail/data_race/alloc_read_race.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-weak-memory-emulation\n #![feature(new_uninit)]\n \n use std::thread::spawn;"}, {"sha": "0b247fb19bc9ca89613adbc064612583c1cf7347", "filename": "tests/fail/data_race/alloc_read_race.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_read_race.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Read on Thread(id = 2) and Allocate on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/alloc_read_race.rs:LL:CC"}, {"sha": "d32eb55676067588bc8d3784b7eb9b918ddea663", "filename": "tests/fail/data_race/alloc_write_race.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-weak-memory-emulation\n #![feature(new_uninit)]\n \n use std::thread::spawn;"}, {"sha": "3594980ef9b02074403b9b1b6a2d71869079b3d3", "filename": "tests/fail/data_race/alloc_write_race.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_write_race.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Allocate on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/alloc_write_race.rs:LL:CC"}, {"sha": "0c9aaf5a0019a313c07c5b02bd406eea8699798b", "filename": "tests/fail/data_race/atomic_read_na_write_race1.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Atomic Load on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_read_na_write_race1.rs:LL:CC"}, {"sha": "6e3a1330f9dd6e60d8118b7122bb320280f1fa18", "filename": "tests/fail/data_race/atomic_read_na_write_race2.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Atomic Load on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_read_na_write_race2.rs:LL:CC"}, {"sha": "4dc4ac1e6768e794ae4963549b392deb79d21b2f", "filename": "tests/fail/data_race/atomic_write_na_read_race1.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Read on Thread(id = 2) and Atomic Store on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_write_na_read_race1.rs:LL:CC"}, {"sha": "e665073c539e287b3f5c11869099d9c8cc4894f9", "filename": "tests/fail/data_race/atomic_write_na_read_race2.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Atomic Store on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_write_na_read_race2.rs:LL:CC"}, {"sha": "a70c3b52de50343595f91246fc8c403a1a7698f9", "filename": "tests/fail/data_race/atomic_write_na_write_race1.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Atomic Store on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_write_na_write_race1.rs:LL:CC"}, {"sha": "79730d507934c55210f42924c96b31b4ecfc80e5", "filename": "tests/fail/data_race/atomic_write_na_write_race2.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Atomic Store on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/atomic_write_na_write_race2.rs:LL:CC"}, {"sha": "21b3eefc5e4180e59f65ea265a0b3353d807090e", "filename": "tests/fail/data_race/dangling_thread_async_race.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Write on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dangling_thread_async_race.rs:LL:CC"}, {"sha": "3ca8862a5819a85214df24435a259539858df966", "filename": "tests/fail/data_race/dangling_thread_race.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Write on Thread(id = 0, name = \"main\") and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dangling_thread_race.rs:LL:CC"}, {"sha": "10b32003ff4004c0ef3a8201372eb370a9c4d281", "filename": "tests/fail/data_race/dealloc_read_race1.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dealloc_read_race1.rs:LL:CC"}, {"sha": "a21de1d9f7a9f71334d682e586aa74302387debf", "filename": "tests/fail/data_race/dealloc_read_race2.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: pointer to ALLOC was dereferenced after this allocation got freed\n   --> $DIR/dealloc_read_race2.rs:LL:CC"}, {"sha": "b70db5f4ac4b77920624539516972574ed5c1a61", "filename": "tests/fail/data_race/dealloc_read_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation\n \n use std::thread::{spawn, sleep};\n use std::ptr::null_mut;"}, {"sha": "0f7213eb8d52144073523e5aa88283bd285ef662", "filename": "tests/fail/data_race/dealloc_read_race_stack.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 1) and Read on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dealloc_read_race_stack.rs:LL:CC"}, {"sha": "76258e9d8fc0b810d8ef80e2d6c97d62c3692d58", "filename": "tests/fail/data_race/dealloc_write_race1.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dealloc_write_race1.rs:LL:CC"}, {"sha": "d9aef72118d8906f42b784dfbf57a09a122c6caf", "filename": "tests/fail/data_race/dealloc_write_race2.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: pointer to ALLOC was dereferenced after this allocation got freed\n   --> $DIR/dealloc_write_race2.rs:LL:CC"}, {"sha": "f2b49fc5f344ade90924e139739230695891bc5c", "filename": "tests/fail/data_race/dealloc_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation\n \n use std::thread::{spawn, sleep};\n use std::ptr::null_mut;"}, {"sha": "70533f654b777ee02ec8c2b899c313c697abcb1f", "filename": "tests/fail/data_race/dealloc_write_race_stack.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dealloc_write_race_stack.rs:LL:CC"}, {"sha": "58d33ffa8cf3c8afc945bc640d11996570bfaffc", "filename": "tests/fail/data_race/enable_after_join_to_main.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Write on Thread(id = 6) and Write on Thread(id = 5) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/enable_after_join_to_main.rs:LL:CC"}, {"sha": "1e3186b08fa115d09868678db6a0863d6806b2b2", "filename": "tests/fail/data_race/fence_after_load.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Ffence_after_load.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Write on Thread(id = 0, name = \"main\") and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/fence_after_load.rs:LL:CC"}, {"sha": "5078e662546a8de0377eea7bd74838d46d726e1f", "filename": "tests/fail/data_race/read_write_race.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/read_write_race.rs:LL:CC"}, {"sha": "9edeed0af6521737684045db762af26bfd207e54", "filename": "tests/fail/data_race/read_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation -Zmir-opt-level=0\n+// compile-flags: -Zmiri-disable-isolation -Zmir-opt-level=0 -Zmiri-disable-weak-memory-emulation\n \n // Note: mir-opt-level set to 0 to prevent the read of stack_var in thread 1\n // from being optimized away and preventing the detection of the data-race."}, {"sha": "843bea753b651a5659d7d3738b07c5e9ed048118", "filename": "tests/fail/data_race/read_write_race_stack.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Read on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/read_write_race_stack.rs:LL:CC"}, {"sha": "20e63dc4b171a10443f85180195e837e3f10490c", "filename": "tests/fail/data_race/relax_acquire_race.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-weak-memory-emulation\n \n use std::thread::spawn;\n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "d2423ff9163169d628588af706c18cf85f3cf054", "filename": "tests/fail/data_race/relax_acquire_race.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/relax_acquire_race.rs:LL:CC"}, {"sha": "6ff84aa04b2632fe41b6f76ad0ea92f0ca9e68e1", "filename": "tests/fail/data_race/release_seq_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation\n \n use std::thread::{spawn, sleep};\n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "ffbf50c09172d48b0ddf11aabeba3d91bd063bc5", "filename": "tests/fail/data_race/release_seq_race.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/release_seq_race.rs:LL:CC"}, {"sha": "1245fb96f497d50e18b46aa4541e43f1a790a774", "filename": "tests/fail/data_race/release_seq_race_same_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation\n \n use std::thread::spawn;\n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "b7602151461136287fcd0cb03ba705035903db59", "filename": "tests/fail/data_race/release_seq_race_same_thread.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Read on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/release_seq_race_same_thread.rs:LL:CC"}, {"sha": "c968c83422c06d7feef5d0cd3574ffc83258ecd9", "filename": "tests/fail/data_race/rmw_race.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frmw_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frmw_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frmw_race.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-weak-memory-emulation\n \n use std::thread::spawn;\n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "c6b09ba5f00bcae7051469257ce4d51ac2a384ad", "filename": "tests/fail/data_race/rmw_race.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frmw_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Frmw_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frmw_race.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Read on Thread(id = 3) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/rmw_race.rs:LL:CC"}, {"sha": "5acba97486eab98ce4db3a434805f05c220ec082", "filename": "tests/fail/data_race/write_write_race.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Write on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/write_write_race.rs:LL:CC"}, {"sha": "daa3e5f5c478961686e0661fd16b021589b19739", "filename": "tests/fail/data_race/write_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-disable-isolation\n+// compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation\n \n use std::thread::{spawn, sleep};\n use std::ptr::null_mut;"}, {"sha": "d052206f4cc72e9f36562e139c661ffaab10ce4a", "filename": "tests/fail/data_race/write_write_race_stack.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: Data race detected between Write on Thread(id = 1) and Write on Thread(id = 2) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/write_write_race_stack.rs:LL:CC"}, {"sha": "e5192cd0d6706214e07090da453d240c9979ed32", "filename": "tests/fail/should-pass/cpp20_rwc_syncs.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,87 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-ignore-leaks\n+// error-pattern:\n+\n+// https://plv.mpi-sws.org/scfix/paper.pdf\n+// 2.2 Second Problem: SC Fences are Too Weak\n+// This test should pass under the C++20 model Rust is using.\n+// Unfortunately, Miri's weak memory emulation only follows the C++11 model\n+// as we don't know how to correctly emulate C++20's revised SC semantics,\n+// so we have to stick to C++11 emulation from existing research.\n+\n+use std::sync::atomic::Ordering::*;\n+use std::sync::atomic::{fence, AtomicUsize};\n+use std::thread::spawn;\n+\n+// Spins until it reads the given value\n+fn reads_value(loc: &AtomicUsize, val: usize) -> usize {\n+    while loc.load(Relaxed) != val {\n+        std::hint::spin_loop();\n+    }\n+    val\n+}\n+\n+// We can't create static items because we need to run each test\n+// multiple tests\n+fn static_atomic(val: usize) -> &'static AtomicUsize {\n+    let ret = Box::leak(Box::new(AtomicUsize::new(val)));\n+    // A workaround to put the initialization value in the store buffer.\n+    // See https://github.com/rust-lang/miri/issues/2164\n+    ret.load(Relaxed);\n+    ret\n+}\n+\n+fn test_cpp20_rwc_syncs() {\n+    /*\n+    int main() {\n+        atomic_int x = 0;\n+        atomic_int y = 0;\n+\n+        {{{ x.store(1,mo_relaxed);\n+        ||| { r1=x.load(mo_relaxed).readsvalue(1);\n+              fence(mo_seq_cst);\n+              r2=y.load(mo_relaxed); }\n+        ||| { y.store(1,mo_relaxed);\n+              fence(mo_seq_cst);\n+              r3=x.load(mo_relaxed); }\n+        }}}\n+        return 0;\n+    }\n+    */\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        reads_value(&x, 1);\n+        fence(SeqCst);\n+        y.load(Relaxed)\n+    });\n+\n+    let j3 = spawn(move || {\n+        y.store(1, Relaxed);\n+        fence(SeqCst);\n+        x.load(Relaxed)\n+    });\n+\n+    j1.join().unwrap();\n+    let b = j2.join().unwrap();\n+    let c = j3.join().unwrap();\n+\n+    // We cannot write assert_ne!() since ui_test's fail\n+    // tests expect exit status 1, whereas panics produce 101.\n+    // Our ui_test does not yet support overriding failure status codes.\n+    if (b, c) == (0, 0) {\n+        // This *should* be unreachable, but Miri will reach it.\n+        std::process::exit(1);\n+    }\n+}\n+\n+pub fn main() {\n+    for _ in 0..500 {\n+        test_cpp20_rwc_syncs();\n+    }\n+}"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/fail/should-pass/cpp20_rwc_syncs.stderr", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,3 @@\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n+"}, {"sha": "d1f9ee6cdd5f146bfe2a49dfb62e267a8e251e06", "filename": "tests/fail/sync/libc_pthread_mutex_deadlock.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_deadlock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_deadlock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_deadlock.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: deadlock: the evaluated program deadlocked\n   --> $DIR/libc_pthread_mutex_deadlock.rs:LL:CC"}, {"sha": "e9f0e2d4c1573c3b031eae2bcc8dc03a165db5ff", "filename": "tests/fail/sync/libc_pthread_mutex_wrong_owner.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_wrong_owner.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_wrong_owner.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_mutex_wrong_owner.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: unlocked a default mutex that was not locked by the current thread\n   --> $DIR/libc_pthread_mutex_wrong_owner.rs:LL:CC"}, {"sha": "c25ab25a3da5be14ed4fa2247eaae324e43c7b3a", "filename": "tests/fail/sync/libc_pthread_rwlock_read_wrong_owner.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_read_wrong_owner.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_read_wrong_owner.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_read_wrong_owner.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: unlocked an rwlock that was not locked by the active thread\n   --> $DIR/libc_pthread_rwlock_read_wrong_owner.rs:LL:CC"}, {"sha": "8fc2ae4c82e561405b63bbb054726a9a44c59c3f", "filename": "tests/fail/sync/libc_pthread_rwlock_write_read_deadlock.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_read_deadlock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_read_deadlock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_read_deadlock.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: deadlock: the evaluated program deadlocked\n   --> $DIR/libc_pthread_rwlock_write_read_deadlock.rs:LL:CC"}, {"sha": "86c67925fb93525fd79146f4ed543f0aef1a72bc", "filename": "tests/fail/sync/libc_pthread_rwlock_write_write_deadlock.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_write_deadlock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_write_deadlock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_write_deadlock.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: deadlock: the evaluated program deadlocked\n   --> $DIR/libc_pthread_rwlock_write_write_deadlock.rs:LL:CC"}, {"sha": "8965d55a489d1da164d4c13a3a62082a9d04324d", "filename": "tests/fail/sync/libc_pthread_rwlock_write_wrong_owner.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_wrong_owner.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_wrong_owner.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fsync%2Flibc_pthread_rwlock_write_wrong_owner.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n error: Undefined Behavior: unlocked an rwlock that was not locked by the active thread\n   --> $DIR/libc_pthread_rwlock_write_wrong_owner.rs:LL:CC"}, {"sha": "6d53670a4e92edb5c2593155cc4d42fd7cad1177", "filename": "tests/fail/weak_memory/racing_mixed_size.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,38 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+#![feature(core_intrinsics)]\n+\n+use std::sync::atomic::AtomicU32;\n+use std::sync::atomic::Ordering::*;\n+use std::thread::spawn;\n+\n+fn static_atomic_u32(val: u32) -> &'static AtomicU32 {\n+    let ret = Box::leak(Box::new(AtomicU32::new(val)));\n+    ret\n+}\n+\n+fn split_u32_ptr(dword: *const u32) -> *const [u16; 2] {\n+    unsafe { std::mem::transmute::<*const u32, *const [u16; 2]>(dword) }\n+}\n+\n+// Wine's SRWLock implementation does this, which is definitely undefined in C++ memory model\n+// https://github.com/wine-mirror/wine/blob/303f8042f9db508adaca02ef21f8de4992cb9c03/dlls/ntdll/sync.c#L543-L566\n+// Though it probably works just fine on x86\n+pub fn main() {\n+    let x = static_atomic_u32(0);\n+    let j1 = spawn(move || {\n+        x.store(1, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        let x_ptr = x as *const AtomicU32 as *const u32;\n+        let x_split = split_u32_ptr(x_ptr);\n+        unsafe {\n+            let hi = &(*x_split)[0] as *const u16;\n+            std::intrinsics::atomic_load_relaxed(hi); //~ ERROR: imperfectly overlapping\n+        }\n+    });\n+\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+}"}, {"sha": "fc6be84315d77b21d6fb7f4d12164ef4ee74d981", "filename": "tests/fail/weak_memory/racing_mixed_size.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,17 @@\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n+\n+error: unsupported operation: racy imperfectly overlapping atomic access is not possible in the C++20 memory model, and not supported by Miri's weak memory emulation\n+  --> $DIR/racing_mixed_size.rs:LL:CC\n+   |\n+LL |             std::intrinsics::atomic_load_relaxed(hi);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ racy imperfectly overlapping atomic access is not possible in the C++20 memory model, and not supported by Miri's weak memory emulation\n+   |\n+   = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n+           \n+   = note: inside closure at $DIR/racing_mixed_size.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "0129b55aff618f74e2569c2650459e4106020f1b", "filename": "tests/fail/weak_memory/racing_mixed_size_read.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,39 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+#![feature(core_intrinsics)]\n+\n+use std::sync::atomic::AtomicU32;\n+use std::sync::atomic::Ordering::*;\n+use std::thread::spawn;\n+\n+fn static_atomic(val: u32) -> &'static AtomicU32 {\n+    let ret = Box::leak(Box::new(AtomicU32::new(val)));\n+    ret\n+}\n+\n+fn split_u32_ptr(dword: *const u32) -> *const [u16; 2] {\n+    unsafe { std::mem::transmute::<*const u32, *const [u16; 2]>(dword) }\n+}\n+\n+// Racing mixed size reads may cause two loads to read-from\n+// the same store but observe different values, which doesn't make\n+// sense under the formal model so we forbade this.\n+pub fn main() {\n+    let x = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.load(Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        let x_ptr = x as *const AtomicU32 as *const u32;\n+        let x_split = split_u32_ptr(x_ptr);\n+        unsafe {\n+            let hi = &(*x_split)[0] as *const u16;\n+            std::intrinsics::atomic_load_relaxed(hi); //~ ERROR: imperfectly overlapping\n+        }\n+    });\n+\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+}"}, {"sha": "846d03f5448ff143ce341ed82cae1f17493d1f26", "filename": "tests/fail/weak_memory/racing_mixed_size_read.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,17 @@\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n+\n+error: unsupported operation: racy imperfectly overlapping atomic access is not possible in the C++20 memory model, and not supported by Miri's weak memory emulation\n+  --> $DIR/racing_mixed_size_read.rs:LL:CC\n+   |\n+LL |             std::intrinsics::atomic_load_relaxed(hi);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ racy imperfectly overlapping atomic access is not possible in the C++20 memory model, and not supported by Miri's weak memory emulation\n+   |\n+   = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n+           \n+   = note: inside closure at $DIR/racing_mixed_size_read.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/channels.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fchannels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fchannels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fchannels.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,2 +1,3 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n "}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/concurrent_caller_location.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,2 +1,3 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n "}, {"sha": "c51080f474fb137b70f9428bac2841e26f882fbe", "filename": "tests/pass/concurrency/data_race.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fdata_race.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-weak-memory-emulation\n \n \n use std::sync::atomic::{AtomicUsize, fence, Ordering};"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/data_race.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fdata_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fdata_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fdata_race.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,2 +1,3 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n "}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/disable_data_race_detector.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,2 +1,3 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n "}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/issue1643.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fissue1643.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fissue1643.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fissue1643.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,2 +1,3 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n "}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/linux-futex.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Flinux-futex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Flinux-futex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Flinux-futex.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,2 +1,3 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n "}, {"sha": "0ba9e8645b28a08b617129443d695bab856642f6", "filename": "tests/pass/concurrency/simple.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fsimple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fsimple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsimple.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n thread '<unnamed>' panicked at 'Hello!', $DIR/simple.rs:LL:CC\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/spin_loops.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fspin_loops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fspin_loops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loops.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,2 +1,3 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n "}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/sync.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fsync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fsync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsync.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,2 +1,3 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n "}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/thread_locals.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fthread_locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Fthread_locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fthread_locals.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,2 +1,3 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n "}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/concurrency/tls_lib_drop.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,2 +1,3 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n "}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/libc.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Flibc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Flibc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flibc.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,2 +1,3 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n "}, {"sha": "b90cc01bb857ea18211338406a196dbed879a6c2", "filename": "tests/pass/panic/concurrent-panic.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fpanic%2Fconcurrent-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fpanic%2Fconcurrent-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpanic%2Fconcurrent-panic.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,4 +1,5 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n Thread 1 starting, will block on mutex\n Thread 1 reported it has started"}, {"sha": "af327a3012c3707514e9ee7908531e5425114523", "filename": "tests/pass/threadleak_ignored.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fthreadleak_ignored.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fthreadleak_ignored.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fthreadleak_ignored.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -1,3 +1,4 @@\n-warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n \n Dropping 0"}, {"sha": "8a7c1340cc593a8a21ce82d8109d560656374da3", "filename": "tests/pass/weak_memory/consistency.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fconsistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fconsistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fconsistency.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,226 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-ignore-leaks -Zmiri-disable-stacked-borrows\n+\n+// The following tests check whether our weak memory emulation produces\n+// any inconsistent execution outcomes\n+//\n+// Due to the random nature of choosing valid stores, it is always\n+// possible that our tests spuriously succeeds: even though our weak\n+// memory emulation code has incorrectly identified a store in\n+// modification order as being valid, it may be never chosen by\n+// the RNG and never observed in our tests.\n+//\n+// To mitigate this, each test is ran enough times such that the chance\n+// of spurious success is very low. These tests never supriously fail.\n+\n+// Test cases and their consistent outcomes are from\n+// http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/\n+// Based on\n+// M. Batty, S. Owens, S. Sarkar, P. Sewell and T. Weber,\n+// \"Mathematizing C++ concurrency\", ACM SIGPLAN Notices, vol. 46, no. 1, pp. 55-66, 2011.\n+// Available: https://ss265.host.cs.st-andrews.ac.uk/papers/n3132.pdf.\n+\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::atomic::Ordering::*;\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+// We can't create static items because we need to run each test\n+// multiple times\n+fn static_atomic(val: usize) -> &'static AtomicUsize {\n+    let ret = Box::leak(Box::new(AtomicUsize::new(val)));\n+    ret\n+}\n+\n+// Spins until it acquires a pre-determined value.\n+fn acquires_value(loc: &AtomicUsize, val: usize) -> usize {\n+    while loc.load(Acquire) != val {\n+        std::hint::spin_loop();\n+    }\n+    val\n+}\n+\n+fn test_corr() {\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, Relaxed);\n+        x.store(2, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        let r2 = x.load(Relaxed); // -------------------------------------+\n+        y.store(1, Release); // ---------------------+                    |\n+        r2 //                                        |                    |\n+    }); //                                           |                    |\n+    //                                               |synchronizes-with   |happens-before\n+    let j3 = spawn(move || { //                      |                    |\n+        acquires_value(&y, 1); // <------------------+                    |\n+        x.load(Relaxed) // <----------------------------------------------+\n+        // The two reads on x are ordered by hb, so they cannot observe values\n+        // differently from the modification order. If the first read observed\n+        // 2, then the second read must observe 2 as well.\n+    });\n+\n+    j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+    let r3 = j3.join().unwrap();\n+    if r2 == 2 {\n+        assert_eq!(r3, 2);\n+    }\n+}\n+\n+fn test_wrc() {\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, Release); // ---------------------+---------------------+\n+    }); //                                           |                     |\n+    //                                               |synchronizes-with    |\n+    let j2 = spawn(move || { //                      |                     |\n+        acquires_value(&x, 1); // <------------------+                     |\n+        y.store(1, Release); // ---------------------+                     |happens-before\n+    }); //                                           |                     |\n+    //                                               |synchronizes-with    |\n+    let j3 = spawn(move || { //                      |                     |\n+        acquires_value(&y, 1); // <------------------+                     |\n+        x.load(Relaxed) // <-----------------------------------------------+\n+    });\n+\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+    let r3 = j3.join().unwrap();\n+\n+    assert_eq!(r3, 1);\n+}\n+\n+fn test_message_passing() {\n+    let mut var = 0u32;\n+    let ptr = &mut var as *mut u32;\n+    let x = EvilSend(ptr);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        unsafe { *x.0 = 1 }; // -----------------------------------------+\n+        y.store(1, Release); // ---------------------+                   |\n+    }); //                                           |                   |\n+    //                                               |synchronizes-with  | happens-before\n+    let j2 = spawn(move || { //                      |                   |\n+        acquires_value(&y, 1); // <------------------+                   |\n+        unsafe { *x.0 } // <---------------------------------------------+\n+    });\n+\n+    j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+\n+    assert_eq!(r2, 1);\n+}\n+\n+// LB+acq_rel+acq_rel\n+fn test_load_buffering_acq_rel() {\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+    let j1 = spawn(move || {\n+        let r1 = x.load(Acquire);\n+        y.store(1, Release);\n+        r1\n+    });\n+\n+    let j2 = spawn(move || {\n+        let r2 = y.load(Acquire);\n+        x.store(1, Release);\n+        r2\n+    });\n+\n+    let r1 = j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+\n+    // 3 consistent outcomes: (0,0), (0,1), (1,0)\n+    assert_ne!((r1, r2), (1, 1));\n+}\n+\n+fn test_mixed_access() {\n+    /*\n+    int main() {\n+      atomic_int x = 0;\n+      {{{\n+        x.store(1, mo_relaxed);\n+      }}}\n+\n+      x.store(2, mo_relaxed);\n+\n+      {{{\n+        r1 = x.load(mo_relaxed);\n+      }}}\n+\n+      return 0;\n+    }\n+        */\n+    let x = static_atomic(0);\n+\n+    spawn(move || {\n+        x.store(1, Relaxed);\n+    })\n+    .join()\n+    .unwrap();\n+\n+    x.store(2, Relaxed);\n+\n+    let r2 = spawn(move || x.load(Relaxed)).join().unwrap();\n+\n+    assert_eq!(r2, 2);\n+}\n+\n+// The following two tests are taken from Repairing Sequential Consistency in C/C++11\n+// by Lahav et al.\n+// https://plv.mpi-sws.org/scfix/paper.pdf\n+\n+// Test case SB\n+fn test_sc_store_buffering() {\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, SeqCst);\n+        y.load(SeqCst)\n+    });\n+\n+    let j2 = spawn(move || {\n+        y.store(1, SeqCst);\n+        x.load(SeqCst)\n+    });\n+\n+    let a = j1.join().unwrap();\n+    let b = j2.join().unwrap();\n+\n+    assert_ne!((a, b), (0, 0));\n+}\n+\n+fn test_single_thread() {\n+    let x = AtomicUsize::new(42);\n+\n+    assert_eq!(x.load(Relaxed), 42);\n+\n+    x.store(43, Relaxed);\n+\n+    assert_eq!(x.load(Relaxed), 43);\n+}\n+\n+pub fn main() {\n+    for _ in 0..100 {\n+        test_single_thread();\n+        test_mixed_access();\n+        test_load_buffering_acq_rel();\n+        test_message_passing();\n+        test_wrc();\n+        test_corr();\n+        test_sc_store_buffering();\n+    }\n+}"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/weak_memory/consistency.stderr", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fconsistency.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fconsistency.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fconsistency.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,3 @@\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n+"}, {"sha": "750c628458b8a3a416789420397ee65bc8e44d63", "filename": "tests/pass/weak_memory/extra_cpp.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fextra_cpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fextra_cpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fextra_cpp.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,82 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-ignore-leaks\n+\n+// Tests operations not perfomable through C++'s atomic API\n+// but doable in safe (at least sound) Rust.\n+\n+#![feature(atomic_from_mut)]\n+#![feature(core_intrinsics)]\n+\n+use std::sync::atomic::Ordering::*;\n+use std::sync::atomic::{AtomicU16, AtomicU32};\n+use std::thread::spawn;\n+\n+fn static_atomic_mut(val: u32) -> &'static mut AtomicU32 {\n+    let ret = Box::leak(Box::new(AtomicU32::new(val)));\n+    ret\n+}\n+\n+fn split_u32(dword: &mut u32) -> &mut [u16; 2] {\n+    unsafe { std::mem::transmute::<&mut u32, &mut [u16; 2]>(dword) }\n+}\n+\n+fn mem_replace() {\n+    let mut x = AtomicU32::new(0);\n+\n+    let old_x = std::mem::replace(&mut x, AtomicU32::new(42));\n+\n+    assert_eq!(x.load(Relaxed), 42);\n+    assert_eq!(old_x.load(Relaxed), 0);\n+}\n+\n+fn assign_to_mut() {\n+    let x = static_atomic_mut(0);\n+    x.store(1, Relaxed);\n+\n+    *x = AtomicU32::new(2);\n+\n+    assert_eq!(x.load(Relaxed), 2);\n+}\n+\n+fn get_mut_write() {\n+    let x = static_atomic_mut(0);\n+    x.store(1, Relaxed);\n+    {\n+        let x_mut = x.get_mut();\n+        *x_mut = 2;\n+    }\n+\n+    let j1 = spawn(move || x.load(Relaxed));\n+\n+    let r1 = j1.join().unwrap();\n+    assert_eq!(r1, 2);\n+}\n+\n+// This is technically doable in C++ with atomic_ref\n+// but little literature exists atm on its involvement\n+// in mixed size/atomicity accesses\n+fn from_mut_split() {\n+    let mut x: u32 = 0;\n+\n+    {\n+        let x_atomic = AtomicU32::from_mut(&mut x);\n+        x_atomic.store(u32::from_be(0xabbafafa), Relaxed);\n+    }\n+\n+    // Split the `AtomicU32` into two `AtomicU16`.\n+    // Crucially, there is no non-atomic access to `x`! All accesses are atomic, but of different size.\n+    let (x_hi, x_lo) = split_u32(&mut x).split_at_mut(1);\n+\n+    let x_hi_atomic = AtomicU16::from_mut(&mut x_hi[0]);\n+    let x_lo_atomic = AtomicU16::from_mut(&mut x_lo[0]);\n+\n+    assert_eq!(x_hi_atomic.load(Relaxed), u16::from_be(0xabba));\n+    assert_eq!(x_lo_atomic.load(Relaxed), u16::from_be(0xfafa));\n+}\n+\n+pub fn main() {\n+    get_mut_write();\n+    from_mut_split();\n+    assign_to_mut();\n+    mem_replace();\n+}"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/weak_memory/extra_cpp.stderr", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fextra_cpp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fextra_cpp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fextra_cpp.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,3 @@\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n+"}, {"sha": "d77a090e6e43f4ac710d50e746d79a2de82a8917", "filename": "tests/pass/weak_memory/extra_cpp_unsafe.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,42 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-ignore-leaks\n+\n+// Tests operations not perfomable through C++'s atomic API\n+// but doable in unsafe Rust which we think *should* be fine.\n+// Nonetheless they may be determined as inconsistent with the\n+// memory model in the future.\n+\n+#![feature(atomic_from_mut)]\n+#![feature(core_intrinsics)]\n+\n+use std::sync::atomic::AtomicU32;\n+use std::sync::atomic::Ordering::*;\n+use std::thread::spawn;\n+\n+fn static_atomic(val: u32) -> &'static AtomicU32 {\n+    let ret = Box::leak(Box::new(AtomicU32::new(val)));\n+    ret\n+}\n+\n+// We allow perfectly overlapping non-atomic and atomic reads to race\n+fn racing_mixed_atomicity_read() {\n+    let x = static_atomic(0);\n+    x.store(42, Relaxed);\n+\n+    let j1 = spawn(move || x.load(Relaxed));\n+\n+    let j2 = spawn(move || {\n+        let x_ptr = x as *const AtomicU32 as *const u32;\n+        unsafe { std::intrinsics::atomic_load_relaxed(x_ptr) }\n+    });\n+\n+    let r1 = j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+\n+    assert_eq!(r1, 42);\n+    assert_eq!(r2, 42);\n+}\n+\n+pub fn main() {\n+    racing_mixed_atomicity_read();\n+}"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/weak_memory/extra_cpp_unsafe.stderr", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,3 @@\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n+"}, {"sha": "70e1bf00f442e0180eeacc2bd78925ba7193855a", "filename": "tests/pass/weak_memory/weak.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fweak.rs?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,109 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-ignore-leaks\n+\n+// Tests showing weak memory behaviours are exhibited. All tests\n+// return true when the desired behaviour is seen.\n+// This is scheduler and pseudo-RNG dependent, so each test is\n+// run multiple times until one try returns true.\n+// Spurious failure is possible, if you are really unlucky with\n+// the RNG and always read the latest value from the store buffer.\n+\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::atomic::Ordering::*;\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+// We can't create static items because we need to run each test\n+// multiple times\n+fn static_atomic(val: usize) -> &'static AtomicUsize {\n+    let ret = Box::leak(Box::new(AtomicUsize::new(val)));\n+    ret\n+}\n+\n+// Spins until it reads the given value\n+fn reads_value(loc: &AtomicUsize, val: usize) -> usize {\n+    while loc.load(Relaxed) != val {\n+        std::hint::spin_loop();\n+    }\n+    val\n+}\n+\n+fn relaxed() -> bool {\n+    let x = static_atomic(0);\n+    let j1 = spawn(move || {\n+        x.store(1, Relaxed);\n+        x.store(2, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || x.load(Relaxed));\n+\n+    j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+\n+    r2 == 1\n+}\n+\n+// https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf Figure 8\n+fn seq_cst() -> bool {\n+    let x = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        x.store(2, SeqCst);\n+        x.store(3, SeqCst);\n+    });\n+\n+    let j3 = spawn(move || x.load(SeqCst));\n+\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+    let r3 = j3.join().unwrap();\n+\n+    r3 == 1\n+}\n+\n+fn initialization_write() -> bool {\n+    let x = static_atomic(11);\n+    assert_eq!(x.load(Relaxed), 11);\n+\n+    let wait = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(22, Relaxed);\n+        // Relaxed is intentional. We want to test if the thread 2 reads the initialisation write\n+        // after a relaxed write\n+        wait.store(1, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        reads_value(wait, 1);\n+        x.load(Relaxed)\n+    });\n+\n+    j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+\n+    r2 == 11\n+}\n+\n+\n+// Asserts that the function returns true at least once in 100 runs\n+macro_rules! assert_once {\n+    ($f:ident) => {\n+        assert!(std::iter::repeat_with(|| $f()).take(100).any(|x| x));\n+    };\n+}\n+\n+pub fn main() {\n+    assert_once!(relaxed);\n+    assert_once!(seq_cst);\n+    assert_once!(initialization_write);\n+}"}, {"sha": "9fe6daa778c1fc66489c84ab4c37b05f227b1e52", "filename": "tests/pass/weak_memory/weak.stderr", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fweak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02/tests%2Fpass%2Fweak_memory%2Fweak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fweak.stderr?ref=e6d3d9888dbf0e6cf8eb9ecb89fa91b5f6d29b02", "patch": "@@ -0,0 +1,3 @@\n+warning: thread support is experimental: the scheduler is not preemptive, and can get stuck in spin loops.\n+         (see https://github.com/rust-lang/miri/issues/1388)\n+"}]}