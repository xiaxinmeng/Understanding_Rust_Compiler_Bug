{"sha": "6349a61231b8c0571cf3db97a68c7215e04a8791", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNDlhNjEyMzFiOGMwNTcxY2YzZGI5N2E2OGM3MjE1ZTA0YTg3OTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-12T14:54:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-15T19:28:12Z"}, "message": "Port coherence to use the new trait matching code", "tree": {"sha": "acd26a0b5205b795fcc3b69fcd65e650b52ba07b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acd26a0b5205b795fcc3b69fcd65e650b52ba07b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6349a61231b8c0571cf3db97a68c7215e04a8791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6349a61231b8c0571cf3db97a68c7215e04a8791", "html_url": "https://github.com/rust-lang/rust/commit/6349a61231b8c0571cf3db97a68c7215e04a8791", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6349a61231b8c0571cf3db97a68c7215e04a8791/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5754f3971b4bb6ea1c9527863189792ab5ee336", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5754f3971b4bb6ea1c9527863189792ab5ee336", "html_url": "https://github.com/rust-lang/rust/commit/c5754f3971b4bb6ea1c9527863189792ab5ee336"}], "stats": {"total": 709, "additions": 400, "deletions": 309}, "files": [{"sha": "850c6ecffaaa1e284b54b8de49f0637555ceafa8", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6349a61231b8c0571cf3db97a68c7215e04a8791", "patch": "@@ -470,7 +470,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         match self.tcx.inherent_impls.borrow().find(&local_def(id)) {\n             None => (),\n             Some(impl_list) => {\n-                for impl_did in impl_list.borrow().iter() {\n+                for impl_did in impl_list.iter() {\n                     for item_did in impl_items.get(impl_did).iter() {\n                         if self.live_symbols.contains(&item_did.def_id()\n                                                                .node) {"}, {"sha": "415eed380fc545f778a931379e4f531f4a8bdf7d", "filename": "src/librustc/middle/traits/coherence.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=6349a61231b8c0571cf3db97a68c7215e04a8791", "patch": "@@ -0,0 +1,168 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*! See `doc.rs` for high-level documentation */\n+\n+use super::DUMMY_CAUSE;\n+use super::{EvaluatedToMatch, EvaluatedToAmbiguity, EvaluatedToUnmatch};\n+use super::{evaluate_impl};\n+use super::util;\n+\n+use middle::subst;\n+use middle::subst::Subst;\n+use middle::ty;\n+use middle::typeck::infer::InferCtxt;\n+use syntax::ast;\n+use syntax::codemap::DUMMY_SP;\n+use util::nodemap::DefIdMap;\n+use util::ppaux::Repr;\n+\n+pub fn impl_can_satisfy(infcx: &InferCtxt,\n+                        impl1_def_id: ast::DefId,\n+                        impl2_def_id: ast::DefId)\n+                        -> bool\n+{\n+    // `impl1` provides an implementation of `Foo<X,Y> for Z`.\n+    let impl1_substs =\n+        util::fresh_substs_for_impl(infcx, DUMMY_SP, impl1_def_id);\n+    let impl1_self_ty =\n+        ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()\n+            .self_ty()\n+            .subst(infcx.tcx, &impl1_substs);\n+\n+    // Determine whether `impl2` can provide an implementation for those\n+    // same types.\n+    let param_env = ty::empty_parameter_environment();\n+    let unboxed_closures = DefIdMap::new();\n+    match evaluate_impl(infcx, &param_env, &unboxed_closures, DUMMY_CAUSE,\n+                        impl2_def_id, impl1_self_ty) {\n+        EvaluatedToMatch | EvaluatedToAmbiguity => true,\n+        EvaluatedToUnmatch => false,\n+    }\n+}\n+\n+pub fn impl_is_local(tcx: &ty::ctxt,\n+                     impl_def_id: ast::DefId)\n+                     -> bool\n+{\n+    debug!(\"impl_is_local({})\", impl_def_id.repr(tcx));\n+\n+    // We only except this routine to be invoked on implementations\n+    // of a trait, not inherent implementations.\n+    let trait_ref = ty::impl_trait_ref(tcx, impl_def_id).unwrap();\n+    debug!(\"trait_ref={}\", trait_ref.repr(tcx));\n+\n+    // If the trait is local to the crate, ok.\n+    if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n+        debug!(\"trait {} is local to current crate\",\n+               trait_ref.def_id.repr(tcx));\n+        return true;\n+    }\n+\n+    // Otherwise, self type must be local to the crate.\n+    let self_ty = ty::lookup_item_type(tcx, impl_def_id).ty;\n+    return ty_is_local(tcx, self_ty);\n+}\n+\n+pub fn ty_is_local(tcx: &ty::ctxt,\n+                   ty: ty::t)\n+                   -> bool\n+{\n+    debug!(\"ty_is_local({})\", ty.repr(tcx));\n+\n+    match ty::get(ty).sty {\n+        ty::ty_nil |\n+        ty::ty_bot |\n+        ty::ty_bool |\n+        ty::ty_char |\n+        ty::ty_int(..) |\n+        ty::ty_uint(..) |\n+        ty::ty_float(..) |\n+        ty::ty_str(..) => {\n+            false\n+        }\n+\n+        ty::ty_unboxed_closure(..) => {\n+            // This routine is invoked on types specified by users as\n+            // part of an impl and hence an unboxed closure type\n+            // cannot appear.\n+            tcx.sess.bug(\"ty_is_local applied to unboxed closure type\")\n+        }\n+\n+        ty::ty_bare_fn(..) |\n+        ty::ty_closure(..) => {\n+            false\n+        }\n+\n+        ty::ty_uniq(t) => {\n+            let krate = tcx.lang_items.owned_box().map(|d| d.krate);\n+            krate == Some(ast::LOCAL_CRATE) || ty_is_local(tcx, t)\n+        }\n+\n+        ty::ty_box(t) => {\n+            let krate = tcx.lang_items.gc().map(|d| d.krate);\n+            krate == Some(ast::LOCAL_CRATE) || ty_is_local(tcx, t)\n+        }\n+\n+        ty::ty_vec(t, _) |\n+        ty::ty_ptr(ty::mt { ty: t, .. }) |\n+        ty::ty_rptr(_, ty::mt { ty: t, .. }) => {\n+            ty_is_local(tcx, t)\n+        }\n+\n+        ty::ty_tup(ref ts) => {\n+            ts.iter().any(|&t| ty_is_local(tcx, t))\n+        }\n+\n+        ty::ty_enum(def_id, ref substs) |\n+        ty::ty_struct(def_id, ref substs) => {\n+            def_id.krate == ast::LOCAL_CRATE || {\n+                let variances = ty::item_variances(tcx, def_id);\n+                subst::ParamSpace::all().iter().any(|&space| {\n+                    substs.types.get_slice(space).iter().enumerate().any(\n+                        |(i, &t)| {\n+                            match *variances.types.get(space, i) {\n+                                ty::Bivariant => {\n+                                    // If Foo<T> is bivariant with respect to\n+                                    // T, then it doesn't matter whether T is\n+                                    // local or not, because `Foo<U>` for any\n+                                    // U will be a subtype of T.\n+                                    false\n+                                }\n+                                ty::Contravariant |\n+                                ty::Covariant |\n+                                ty::Invariant => {\n+                                    ty_is_local(tcx, t)\n+                                }\n+                            }\n+                        })\n+                })\n+            }\n+        }\n+\n+        ty::ty_trait(ref tt) => {\n+            tt.def_id.krate == ast::LOCAL_CRATE\n+        }\n+\n+        // Type parameters may be bound to types that are not local to\n+        // the crate.\n+        ty::ty_param(..) => {\n+            false\n+        }\n+\n+        ty::ty_infer(..) |\n+        ty::ty_open(..) |\n+        ty::ty_err => {\n+            tcx.sess.bug(\n+                format!(\"ty_is_local invoked on unexpected type: {}\",\n+                        ty.repr(tcx)).as_slice())\n+        }\n+    }\n+}"}, {"sha": "76c5cab234f375008bc59de619976d7835fa45c7", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "renamed", "additions": 36, "deletions": 307, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=6349a61231b8c0571cf3db97a68c7215e04a8791", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,12 +10,13 @@\n \n // Coherence phase\n //\n-// The job of the coherence phase of typechecking is to ensure that each trait\n-// has at most one implementation for each type. Then we build a mapping from\n-// each trait in the system to its implementations.\n+// The job of the coherence phase of typechecking is to ensure that\n+// each trait has at most one implementation for each type. This is\n+// done by the orphan and overlap modules. Then we build up various\n+// mappings. That mapping code resides here.\n \n \n-use metadata::csearch::{each_impl, get_impl_trait, each_implementation_for_trait};\n+use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n use middle::subst;\n use middle::subst::{Substs};\n@@ -35,27 +36,24 @@ use middle::typeck::CrateCtxt;\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n-use middle::typeck::infer;\n-use util::ppaux::Repr;\n-use middle::def::{DefStruct, DefTy};\n+use std::collections::{HashSet};\n+use std::cell::RefCell;\n+use std::rc::Rc;\n use syntax::ast::{Crate, DefId};\n-use syntax::ast::{Item, ItemEnum, ItemImpl, ItemMod, ItemStruct};\n-use syntax::ast::{LOCAL_CRATE, TraitRef, TyPath};\n+use syntax::ast::{Item, ItemImpl};\n+use syntax::ast::{LOCAL_CRATE, TraitRef};\n use syntax::ast;\n use syntax::ast_map::NodeItem;\n use syntax::ast_map;\n use syntax::ast_util::{local_def};\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::codemap::{Span};\n use syntax::parse::token;\n use syntax::visit;\n+use util::nodemap::{DefIdMap, FnvHashMap};\n+use util::ppaux::Repr;\n \n-use std::collections::HashSet;\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-\n-struct UniversalQuantificationResult {\n-    monotype: t\n-}\n+mod orphan;\n+mod overlap;\n \n fn get_base_type(inference_context: &InferCtxt,\n                  span: Span,\n@@ -96,53 +94,6 @@ fn get_base_type(inference_context: &InferCtxt,\n     }\n }\n \n-fn type_is_defined_in_local_crate(tcx: &ty::ctxt, original_type: t) -> bool {\n-    /*!\n-     *\n-     * For coherence, when we have `impl Trait for Type`, we need to\n-     * guarantee that `Type` is \"local\" to the\n-     * crate.  For our purposes, this means that it must contain\n-     * some nominal type defined in this crate.\n-     */\n-\n-    let mut found_nominal = false;\n-    ty::walk_ty(original_type, |t| {\n-        match get(t).sty {\n-            ty_enum(def_id, _) |\n-            ty_struct(def_id, _) |\n-            ty_unboxed_closure(def_id, _) => {\n-                if def_id.krate == ast::LOCAL_CRATE {\n-                    found_nominal = true;\n-                }\n-            }\n-            ty_trait(box ty::TyTrait { def_id, .. }) => {\n-                if def_id.krate == ast::LOCAL_CRATE {\n-                    found_nominal = true;\n-                }\n-            }\n-            ty_uniq(..) => {\n-                match tcx.lang_items.owned_box() {\n-                    Some(did) if did.krate == ast::LOCAL_CRATE => {\n-                        found_nominal = true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            ty_box(..) => {\n-                match tcx.lang_items.gc() {\n-                    Some(did) if did.krate == ast::LOCAL_CRATE => {\n-                        found_nominal = true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            _ => { }\n-        }\n-    });\n-    return found_nominal;\n-}\n-\n // Returns the def ID of the base type, if there is one.\n fn get_base_type_def_id(inference_context: &InferCtxt,\n                         span: Span,\n@@ -185,6 +136,7 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n struct CoherenceChecker<'a, 'tcx: 'a> {\n     crate_context: &'a CrateCtxt<'a, 'tcx>,\n     inference_context: InferCtxt<'a, 'tcx>,\n+    inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n }\n \n struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n@@ -214,57 +166,6 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n     }\n }\n \n-struct PrivilegedScopeVisitor<'a, 'tcx: 'a> {\n-    cc: &'a CoherenceChecker<'a, 'tcx>\n-}\n-\n-impl<'a, 'tcx, 'v> visit::Visitor<'v> for PrivilegedScopeVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &Item) {\n-\n-        match item.node {\n-            ItemMod(ref module_) => {\n-                // Then visit the module items.\n-                visit::walk_mod(self, module_);\n-            }\n-            ItemImpl(_, None, ref ast_ty, _) => {\n-                if !self.cc.ast_type_is_defined_in_local_crate(&**ast_ty) {\n-                    // This is an error.\n-                    let session = &self.cc.crate_context.tcx.sess;\n-                    span_err!(session, item.span, E0116,\n-                              \"cannot associate methods with a type outside the \\\n-                               crate the type is defined in; define and implement \\\n-                               a trait or new type instead\");\n-                }\n-            }\n-            ItemImpl(_, Some(ref trait_ref), _, _) => {\n-                let tcx = self.cc.crate_context.tcx;\n-                // `for_ty` is `Type` in `impl Trait for Type`\n-                let for_ty = ty::node_id_to_type(tcx, item.id);\n-                if !type_is_defined_in_local_crate(tcx, for_ty) {\n-                    // This implementation is not in scope of its base\n-                    // type. This still might be OK if the trait is\n-                    // defined in the same crate.\n-\n-                    let trait_def_id =\n-                        self.cc.trait_ref_to_trait_def_id(trait_ref);\n-\n-                    if trait_def_id.krate != LOCAL_CRATE {\n-                        let session = &self.cc.crate_context.tcx.sess;\n-                        span_err!(session, item.span, E0117,\n-                                  \"cannot provide an extension implementation \\\n-                                   where both trait and type are not defined in this crate\");\n-                    }\n-                }\n-\n-                visit::walk_item(self, item);\n-            }\n-            _ => {\n-                visit::walk_item(self, item);\n-            }\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn check(&self, krate: &Crate) {\n         // Check implementations and traits. This populates the tables\n@@ -273,11 +174,14 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let mut visitor = CoherenceCheckVisitor { cc: self };\n         visit::walk_crate(&mut visitor, krate);\n \n-        // Check that there are no overlapping trait instances\n-        self.check_implementation_coherence();\n-\n-        // Check whether traits with base types are in privileged scopes.\n-        self.check_privileged_scopes(krate);\n+        // Copy over the inherent impls we gathered up during the walk into\n+        // the tcx.\n+        let mut tcx_inherent_impls =\n+            self.crate_context.tcx.inherent_impls.borrow_mut();\n+        for (k, v) in self.inherent_impls.borrow().iter() {\n+            tcx_inherent_impls.insert((*k).clone(),\n+                                      Rc::new((*v.borrow()).clone()));\n+        }\n \n         // Bring in external crates. It's fine for this to happen after the\n         // coherence checks, because we ensure by construction that no errors\n@@ -290,7 +194,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         self.populate_destructor_table();\n     }\n \n-    fn check_implementation(&self, item: &Item,\n+    fn check_implementation(&self,\n+                            item: &Item,\n                             associated_traits: &[TraitRef]) {\n         let tcx = self.crate_context.tcx;\n         let impl_did = local_def(item.id);\n@@ -299,25 +204,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         // If there are no traits, then this implementation must have a\n         // base type.\n \n-        if associated_traits.len() == 0 {\n-            debug!(\"(checking implementation) no associated traits for item '{}'\",\n-                   token::get_ident(item.ident));\n-\n-            match get_base_type_def_id(&self.inference_context,\n-                                       item.span,\n-                                       self_type.ty) {\n-                None => {\n-                    let session = &self.crate_context.tcx.sess;\n-                    span_err!(session, item.span, E0118,\n-                              \"no base type found for inherent implementation; \\\n-                               implement a trait or new type instead\");\n-                }\n-                Some(_) => {\n-                    // Nothing to do.\n-                }\n-            }\n-        }\n-\n         let impl_items = self.create_impl_from_item(item);\n \n         for associated_trait in associated_traits.iter() {\n@@ -408,187 +294,32 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        let tcx = self.crate_context.tcx;\n-        match tcx.inherent_impls.borrow().find(&base_def_id) {\n+        match self.inherent_impls.borrow().find(&base_def_id) {\n             Some(implementation_list) => {\n                 implementation_list.borrow_mut().push(impl_def_id);\n                 return;\n             }\n             None => {}\n         }\n \n-        tcx.inherent_impls.borrow_mut().insert(base_def_id,\n-                                               Rc::new(RefCell::new(vec!(impl_def_id))));\n+        self.inherent_impls.borrow_mut().insert(\n+            base_def_id,\n+            Rc::new(RefCell::new(vec!(impl_def_id))));\n     }\n \n     fn add_trait_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n+        debug!(\"add_trait_impl: base_def_id={} impl_def_id={}\",\n+               base_def_id, impl_def_id);\n         ty::record_trait_implementation(self.crate_context.tcx,\n                                         base_def_id,\n                                         impl_def_id);\n     }\n \n-    fn check_implementation_coherence(&self) {\n-        for trait_id in self.crate_context.tcx.trait_impls.borrow().keys() {\n-            self.check_implementation_coherence_of(*trait_id);\n-        }\n-    }\n-\n-    fn check_implementation_coherence_of(&self, trait_def_id: DefId) {\n-        // Unify pairs of polytypes.\n-        self.iter_impls_of_trait_local(trait_def_id, |impl_a| {\n-            let polytype_a =\n-                self.get_self_type_for_implementation(impl_a);\n-\n-            // \"We have an impl of trait <trait_def_id> for type <polytype_a>,\n-            // and that impl is <impl_a>\"\n-            self.iter_impls_of_trait(trait_def_id, |impl_b| {\n-\n-                // An impl is coherent with itself\n-                if impl_a != impl_b {\n-                    let polytype_b = self.get_self_type_for_implementation(\n-                            impl_b);\n-\n-                    if self.polytypes_unify(polytype_a.clone(), polytype_b) {\n-                        let session = &self.crate_context.tcx.sess;\n-                        span_err!(session, self.span_of_impl(impl_a), E0119,\n-                                  \"conflicting implementations for trait `{}`\",\n-                                  ty::item_path_str(self.crate_context.tcx, trait_def_id));\n-                        if impl_b.krate == LOCAL_CRATE {\n-                            span_note!(session, self.span_of_impl(impl_b),\n-                                       \"note conflicting implementation here\");\n-                        } else {\n-                            let crate_store = &self.crate_context.tcx.sess.cstore;\n-                            let cdata = crate_store.get_crate_data(impl_b.krate);\n-                            span_note!(session, self.span_of_impl(impl_a),\n-                                       \"conflicting implementation in crate `{}`\",\n-                                       cdata.name);\n-                        }\n-                    }\n-                }\n-            })\n-        })\n-    }\n-\n-    fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |DefId|) {\n-        self.iter_impls_of_trait_local(trait_def_id, |x| f(x));\n-\n-        if trait_def_id.krate == LOCAL_CRATE {\n-            return;\n-        }\n-\n-        let crate_store = &self.crate_context.tcx.sess.cstore;\n-        csearch::each_implementation_for_trait(crate_store, trait_def_id, |impl_def_id| {\n-            // Is this actually necessary?\n-            let _ = lookup_item_type(self.crate_context.tcx, impl_def_id);\n-            f(impl_def_id);\n-        });\n-    }\n-\n-    fn iter_impls_of_trait_local(&self, trait_def_id: DefId, f: |DefId|) {\n-        match self.crate_context.tcx.trait_impls.borrow().find(&trait_def_id) {\n-            Some(impls) => {\n-                for &impl_did in impls.borrow().iter() {\n-                    f(impl_did);\n-                }\n-            }\n-            None => { /* no impls? */ }\n-        }\n-    }\n-\n-    fn polytypes_unify(&self,\n-                       polytype_a: Polytype,\n-                       polytype_b: Polytype)\n-                       -> bool {\n-        let universally_quantified_a =\n-            self.universally_quantify_polytype(polytype_a);\n-        let universally_quantified_b =\n-            self.universally_quantify_polytype(polytype_b);\n-\n-        return self.can_unify_universally_quantified(\n-            &universally_quantified_a, &universally_quantified_b) ||\n-            self.can_unify_universally_quantified(\n-            &universally_quantified_b, &universally_quantified_a);\n-    }\n-\n-    // Converts a polytype to a monotype by replacing all parameters with\n-    // type variables. Returns the monotype and the type variables created.\n-    fn universally_quantify_polytype(&self, polytype: Polytype)\n-                                     -> UniversalQuantificationResult\n-    {\n-        let substitutions =\n-            self.inference_context.fresh_substs_for_type(DUMMY_SP,\n-                                                         &polytype.generics);\n-        let monotype = polytype.ty.subst(self.crate_context.tcx, &substitutions);\n-\n-        UniversalQuantificationResult {\n-            monotype: monotype\n-        }\n-    }\n-\n-    fn can_unify_universally_quantified<'a>(&self,\n-                                            a: &'a UniversalQuantificationResult,\n-                                            b: &'a UniversalQuantificationResult)\n-                                            -> bool\n-    {\n-        infer::can_mk_subty(&self.inference_context,\n-                            a.monotype,\n-                            b.monotype).is_ok()\n-    }\n-\n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n                                         -> Polytype {\n         self.crate_context.tcx.tcache.borrow().get_copy(&impl_did)\n     }\n \n-    // Privileged scope checking\n-    fn check_privileged_scopes(&self, krate: &Crate) {\n-        let mut visitor = PrivilegedScopeVisitor{ cc: self };\n-        visit::walk_crate(&mut visitor, krate);\n-    }\n-\n-    fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {\n-        let def_map = &self.crate_context.tcx.def_map;\n-        let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n-        let trait_id = trait_def.def_id();\n-        return trait_id;\n-    }\n-\n-    /// For coherence, when we have `impl Type`, we need to guarantee that\n-    /// `Type` is \"local\" to the crate. For our purposes, this means that it\n-    /// must precisely name some nominal type defined in this crate.\n-    fn ast_type_is_defined_in_local_crate(&self, original_type: &ast::Ty) -> bool {\n-        match original_type.node {\n-            TyPath(_, _, path_id) => {\n-                match self.crate_context.tcx.def_map.borrow().get_copy(&path_id) {\n-                    DefTy(def_id) | DefStruct(def_id) => {\n-                        if def_id.krate != LOCAL_CRATE {\n-                            return false;\n-                        }\n-\n-                        // Make sure that this type precisely names a nominal\n-                        // type.\n-                        match self.crate_context.tcx.map.find(def_id.node) {\n-                            None => {\n-                                self.crate_context.tcx.sess.span_bug(\n-                                    original_type.span,\n-                                    \"resolve didn't resolve this type?!\");\n-                            }\n-                            Some(NodeItem(item)) => {\n-                                match item.node {\n-                                    ItemStruct(..) | ItemEnum(..) => true,\n-                                    _ => false,\n-                                }\n-                            }\n-                            Some(_) => false,\n-                        }\n-                    }\n-                    _ => false\n-                }\n-            }\n-            _ => false\n-        }\n-    }\n-\n     // Converts an implementation in the AST to a vector of items.\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n@@ -623,11 +354,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         }\n     }\n \n-    fn span_of_impl(&self, impl_did: DefId) -> Span {\n-        assert_eq!(impl_did.krate, LOCAL_CRATE);\n-        self.crate_context.tcx.map.span(impl_did.node)\n-    }\n-\n     // External crate handling\n \n     fn add_external_impl(&self,\n@@ -824,5 +550,8 @@ pub fn check_coherence(crate_context: &CrateCtxt) {\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n+        inherent_impls: RefCell::new(FnvHashMap::new()),\n     }.check(crate_context.tcx.map.krate());\n+    orphan::check(crate_context.tcx);\n+    overlap::check(crate_context.tcx);\n }", "previous_filename": "src/librustc/middle/typeck/coherence.rs"}, {"sha": "e7139e1229b23c69f162b00fc6a3f097363cad3e", "filename": "src/librustc/middle/typeck/coherence/orphan.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs?ref=6349a61231b8c0571cf3db97a68c7215e04a8791", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Orphan checker: every impl either implements a trait defined in this\n+ * crate or pertains to a type defined in this crate.\n+ */\n+\n+use middle::traits;\n+use middle::ty;\n+use syntax::ast::{Item, ItemImpl};\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::visit;\n+use util::ppaux::Repr;\n+\n+pub fn check(tcx: &ty::ctxt) {\n+    let mut orphan = OrphanChecker { tcx: tcx };\n+    visit::walk_crate(&mut orphan, tcx.map.krate());\n+}\n+\n+struct OrphanChecker<'cx, 'tcx:'cx> {\n+    tcx: &'cx ty::ctxt<'tcx>\n+}\n+\n+impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n+    fn visit_item(&mut self, item: &'v ast::Item) {\n+        let def_id = ast_util::local_def(item.id);\n+        match item.node {\n+            ast::ItemImpl(_, None, _, _) => {\n+                // For inherent impls, self type must be a nominal type\n+                // defined in this crate.\n+                debug!(\"coherence2::orphan check: inherent impl {}\", item.repr(self.tcx));\n+                let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n+                match ty::get(self_ty).sty {\n+                    ty::ty_enum(def_id, _) |\n+                    ty::ty_struct(def_id, _) => {\n+                        if def_id.krate != ast::LOCAL_CRATE {\n+                            span_err!(self.tcx.sess, item.span, E0116,\n+                                      \"cannot associate methods with a type outside the \\\n+                                      crate the type is defined in; define and implement \\\n+                                      a trait or new type instead\");\n+                        }\n+                    }\n+                    _ => {\n+                        span_err!(self.tcx.sess, item.span, E0118,\n+                                  \"no base type found for inherent implementation; \\\n+                                   implement a trait or new type instead\");\n+                    }\n+                }\n+            }\n+            ast::ItemImpl(_, Some(_), _, _) => {\n+                // \"Trait\" impl\n+                debug!(\"coherence2::orphan check: trait impl {}\", item.repr(self.tcx));\n+                if traits::is_orphan_impl(self.tcx, def_id) {\n+                    span_err!(self.tcx.sess, item.span, E0117,\n+                              \"cannot provide an extension implementation \\\n+                               where both trait and type are not defined in this crate\");\n+                }\n+            }\n+            _ => {\n+                // Not an impl\n+            }\n+        }\n+\n+        visit::walk_item(self, item);\n+    }\n+}"}, {"sha": "48f71d95c429aa87591169559607e60a0923bafe", "filename": "src/librustc/middle/typeck/coherence/overlap.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs?ref=6349a61231b8c0571cf3db97a68c7215e04a8791", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Overlap: No two impls for the same trait are implemented for the\n+ * same type.\n+ */\n+\n+use middle::traits;\n+use middle::ty;\n+use middle::typeck::infer::{new_infer_ctxt};\n+use middle::typeck::infer;\n+use syntax::ast::{DefId};\n+use syntax::ast::{LOCAL_CRATE};\n+use syntax::ast;\n+use syntax::codemap::{Span};\n+use util::ppaux::Repr;\n+\n+pub fn check(tcx: &ty::ctxt) {\n+    let overlap = OverlapChecker { tcx: tcx };\n+    overlap.check_for_overlapping_impls();\n+}\n+\n+struct OverlapChecker<'cx, 'tcx:'cx> {\n+    tcx: &'cx ty::ctxt<'tcx>\n+}\n+\n+impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n+    fn check_for_overlapping_impls(&self) {\n+        debug!(\"check_for_overlapping_impls\");\n+        let trait_impls = self.tcx.trait_impls.borrow();\n+        for trait_def_id in trait_impls.keys() {\n+            self.check_for_overlapping_impls_of_trait(*trait_def_id);\n+        }\n+    }\n+\n+    fn check_for_overlapping_impls_of_trait(&self,\n+                                            trait_def_id: ast::DefId)\n+    {\n+        debug!(\"check_for_overlapping_impls_of_trait(trait_def_id={})\",\n+               trait_def_id.repr(self.tcx));\n+\n+        // FIXME -- it seems like this method actually pushes\n+        // duplicate impls onto the list\n+        ty::populate_implementations_for_type_if_necessary(self.tcx,\n+                                                           trait_def_id);\n+\n+        let mut impls = Vec::new();\n+        self.push_impls_of_trait(trait_def_id, &mut impls);\n+\n+        for (i, &impl1_def_id) in impls.iter().enumerate() {\n+            if impl1_def_id.krate != ast::LOCAL_CRATE {\n+                // we don't need to check impls if both are external;\n+                // that's the other crate's job.\n+                continue;\n+            }\n+\n+            for &impl2_def_id in impls.slice_from(i+1).iter() {\n+                self.check_if_impls_overlap(trait_def_id,\n+                                            impl1_def_id,\n+                                            impl2_def_id);\n+            }\n+        }\n+    }\n+\n+    fn check_if_impls_overlap(&self,\n+                              trait_def_id: ast::DefId,\n+                              impl1_def_id: ast::DefId,\n+                              impl2_def_id: ast::DefId)\n+    {\n+        assert_eq!(impl1_def_id.krate, ast::LOCAL_CRATE);\n+\n+        debug!(\"check_if_impls_overlap({}, {}, {})\",\n+               trait_def_id.repr(self.tcx),\n+               impl1_def_id.repr(self.tcx),\n+               impl2_def_id.repr(self.tcx));\n+\n+        let infcx = infer::new_infer_ctxt(self.tcx);\n+        if !traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n+            return;\n+        }\n+\n+        span_err!(self.tcx.sess, self.span_of_impl(impl1_def_id), E0119,\n+                  \"conflicting implementations for trait `{}`\",\n+                  ty::item_path_str(self.tcx, trait_def_id));\n+\n+        if impl2_def_id.krate == ast::LOCAL_CRATE {\n+            span_note!(self.tcx.sess, self.span_of_impl(impl2_def_id),\n+                       \"note conflicting implementation here\");\n+        } else {\n+            let crate_store = &self.tcx.sess.cstore;\n+            let cdata = crate_store.get_crate_data(impl2_def_id.krate);\n+            span_note!(self.tcx.sess, self.span_of_impl(impl1_def_id),\n+                       \"conflicting implementation in crate `{}`\",\n+                       cdata.name);\n+        }\n+    }\n+\n+    fn push_impls_of_trait(&self,\n+                           trait_def_id: ast::DefId,\n+                           out: &mut Vec<ast::DefId>) {\n+        match self.tcx.trait_impls.borrow().find(&trait_def_id) {\n+            Some(impls) => { out.push_all(impls.borrow().as_slice()); }\n+            None => { /* no impls */ }\n+        }\n+    }\n+\n+    fn span_of_impl(&self, impl_did: ast::DefId) -> Span {\n+        assert_eq!(impl_did.krate, ast::LOCAL_CRATE);\n+        self.tcx.map.span(impl_did.node)\n+    }\n+}"}, {"sha": "7272425761e026824f065224208c44e62c9f1a84", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6349a61231b8c0571cf3db97a68c7215e04a8791/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=6349a61231b8c0571cf3db97a68c7215e04a8791", "patch": "@@ -226,7 +226,7 @@ fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n     match tcx.inherent_impls.borrow().find(&did) {\n         None => {}\n         Some(i) => {\n-            impls.extend(i.borrow().iter().map(|&did| { build_impl(cx, tcx, did) }));\n+            impls.extend(i.iter().map(|&did| { build_impl(cx, tcx, did) }));\n         }\n     }\n "}]}