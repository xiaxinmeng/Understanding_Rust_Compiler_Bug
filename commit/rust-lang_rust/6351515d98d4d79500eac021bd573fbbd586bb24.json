{"sha": "6351515d98d4d79500eac021bd573fbbd586bb24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNTE1MTVkOThkNGQ3OTUwMGVhYzAyMWJkNTczZmJiZDU4NmJiMjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-19T02:40:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-19T02:40:33Z"}, "message": "auto merge of #5005 : alexcrichton/rust/bitv++, r=catamorphism\n\nThese commits take the old bitv implementation and modernize it with an explicit self, some minor touchups, and using what I think is some more recent patterns (like `::new` instead of `Type()`).\r\n\r\nAdditionally, this adds an implementation of `container::Set` on top of a bit vector to have as a set of `uint`s. I initially tried to parameterize the type for the set to be `T: NumCast` but I was hitting build problems in stage0 which I think means that it's not in a snapshot yet, so it's just hardcoded as a set of `uint`s now. In the future perhaps it could be parameterized. I'm not sure if it would really add anything, though, so maybe it's nicer to be hardcoded anyway.\r\n\r\nI also added some extra methods to do normal bit vector operations on the set in-place, but these aren't a part of the `Set` trait right now. I haven't benchmarked any of these operations just yet, but I imagine that there's quite a lot of room for optimization here and there.", "tree": {"sha": "0e29fe150321ec1d8e95897fbdcda09f0b57524c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e29fe150321ec1d8e95897fbdcda09f0b57524c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6351515d98d4d79500eac021bd573fbbd586bb24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6351515d98d4d79500eac021bd573fbbd586bb24", "html_url": "https://github.com/rust-lang/rust/commit/6351515d98d4d79500eac021bd573fbbd586bb24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6351515d98d4d79500eac021bd573fbbd586bb24/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ba2e65fd6892d2200b517d11e95870e4b2ece12", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba2e65fd6892d2200b517d11e95870e4b2ece12", "html_url": "https://github.com/rust-lang/rust/commit/9ba2e65fd6892d2200b517d11e95870e4b2ece12"}, {"sha": "cf2ddf0437e347be4fb830772421ef1534cdab0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf2ddf0437e347be4fb830772421ef1534cdab0e", "html_url": "https://github.com/rust-lang/rust/commit/cf2ddf0437e347be4fb830772421ef1534cdab0e"}], "stats": {"total": 1088, "additions": 893, "deletions": 195}, "files": [{"sha": "5ba10a9eb14768ff982e26eba9d5f9c7d59ce049", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 701, "deletions": 187, "changes": 888, "blob_url": "https://github.com/rust-lang/rust/blob/6351515d98d4d79500eac021bd573fbbd586bb24/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6351515d98d4d79500eac021bd573fbbd586bb24/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=6351515d98d4d79500eac021bd573fbbd586bb24", "patch": "@@ -8,107 +8,104 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::container::{Container, Mutable, Set};\n+use core::num::NumCast;\n use core::ops;\n use core::prelude::*;\n use core::uint;\n-use core::vec::{cast_to_mut, from_elem};\n+use core::vec::from_elem;\n use core::vec;\n \n struct SmallBitv {\n     /// only the lowest nbits of this value are used. the rest is undefined.\n-    mut bits: u32\n-}\n-\n-fn SmallBitv(bits: u32) -> SmallBitv {\n-    SmallBitv {bits: bits}\n+    bits: uint\n }\n \n /// a mask that has a 1 for each defined bit in a small_bitv, assuming n bits\n #[inline(always)]\n-fn small_mask(nbits: uint) -> u32 {\n+fn small_mask(nbits: uint) -> uint {\n     (1 << nbits) - 1\n }\n \n impl SmallBitv {\n+    static fn new(bits: uint) -> SmallBitv {\n+        SmallBitv {bits: bits}\n+    }\n \n     #[inline(always)]\n-    fn bits_op(right_bits: u32, nbits: uint, f: fn(u32, u32) -> u32) -> bool {\n+    fn bits_op(&mut self, right_bits: uint, nbits: uint,\n+               f: fn(uint, uint) -> uint) -> bool {\n         let mask = small_mask(nbits);\n-        let old_b: u32 = self.bits;\n+        let old_b: uint = self.bits;\n         let new_b = f(old_b, right_bits);\n         self.bits = new_b;\n         mask & old_b != mask & new_b\n     }\n \n     #[inline(always)]\n-    fn union(s: &SmallBitv, nbits: uint) -> bool {\n+    fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n     }\n \n     #[inline(always)]\n-    fn intersect(s: &SmallBitv, nbits: uint) -> bool {\n+    fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n     }\n \n     #[inline(always)]\n-    fn become(s: &SmallBitv, nbits: uint) -> bool {\n+    fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |_u1, u2| u2)\n     }\n \n     #[inline(always)]\n-    fn difference(s: &SmallBitv, nbits: uint) -> bool {\n+    fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & !u2)\n     }\n \n     #[inline(always)]\n-    pure fn get(i: uint) -> bool {\n+    pure fn get(&self, i: uint) -> bool {\n         (self.bits & (1 << i)) != 0\n     }\n \n     #[inline(always)]\n-    fn set(i: uint, x: bool) {\n+    fn set(&mut self, i: uint, x: bool) {\n         if x {\n             self.bits |= 1<<i;\n         }\n         else {\n-            self.bits &= !(1<<i as u32);\n+            self.bits &= !(1<<i as uint);\n         }\n     }\n \n     #[inline(always)]\n-    fn equals(b: &SmallBitv, nbits: uint) -> bool {\n+    fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n         let mask = small_mask(nbits);\n         mask & self.bits == mask & b.bits\n     }\n \n     #[inline(always)]\n-    fn clear() { self.bits = 0; }\n+    fn clear(&mut self) { self.bits = 0; }\n \n     #[inline(always)]\n-    fn set_all() { self.bits = !0; }\n+    fn set_all(&mut self) { self.bits = !0; }\n \n     #[inline(always)]\n-    fn is_true(nbits: uint) -> bool {\n+    fn is_true(&self, nbits: uint) -> bool {\n         small_mask(nbits) & !self.bits == 0\n     }\n \n     #[inline(always)]\n-    fn is_false(nbits: uint) -> bool {\n+    fn is_false(&self, nbits: uint) -> bool {\n         small_mask(nbits) & self.bits == 0\n     }\n \n     #[inline(always)]\n-    fn invert() { self.bits = !self.bits; }\n+    fn invert(&mut self) { self.bits = !self.bits; }\n \n }\n \n struct BigBitv {\n-    // only mut b/c of clone and lack of other constructor\n-    mut storage: ~[uint]\n-}\n-\n-fn BigBitv(storage: ~[uint]) -> BigBitv {\n-    BigBitv {storage: storage}\n+    storage: ~[uint]\n }\n \n /**\n@@ -117,8 +114,8 @@ fn BigBitv(storage: ~[uint]) -> BigBitv {\n  */\n #[inline(always)]\n fn big_mask(nbits: uint, elem: uint) -> uint {\n-    let rmd = nbits % uint_bits;\n-    let nelems = nbits/uint_bits + if rmd == 0 {0} else {1};\n+    let rmd = nbits % uint::bits;\n+    let nelems = nbits/uint::bits + if rmd == 0 {0} else {1};\n \n     if elem < nelems - 1 || rmd == 0 {\n         !0\n@@ -128,30 +125,31 @@ fn big_mask(nbits: uint, elem: uint) -> uint {\n }\n \n impl BigBitv {\n+    static fn new(storage: ~[uint]) -> BigBitv {\n+        BigBitv {storage: storage}\n+    }\n \n     #[inline(always)]\n-    fn process(b: &BigBitv, nbits: uint, op: fn(uint, uint) -> uint) -> bool {\n+    fn process(&mut self, b: &BigBitv, nbits: uint,\n+               op: fn(uint, uint) -> uint) -> bool {\n         let len = b.storage.len();\n         assert (self.storage.len() == len);\n         let mut changed = false;\n-        do uint::range(0, len) |i| {\n+        for uint::range(0, len) |i| {\n             let mask = big_mask(nbits, i);\n             let w0 = self.storage[i] & mask;\n             let w1 = b.storage[i] & mask;\n             let w = op(w0, w1) & mask;\n             if w0 != w {\n-                unsafe {\n-                    changed = true;\n-                    self.storage[i] = w;\n-                }\n+                changed = true;\n+                self.storage[i] = w;\n             }\n-            true\n         }\n         changed\n     }\n \n     #[inline(always)]\n-     fn each_storage(op: fn(v: &mut uint) -> bool) {\n+    fn each_storage(&mut self, op: fn(v: &mut uint) -> bool) {\n         for uint::range(0, self.storage.len()) |i| {\n             let mut w = self.storage[i];\n             let b = op(&mut w);\n@@ -161,47 +159,47 @@ impl BigBitv {\n      }\n \n     #[inline(always)]\n-    fn invert() { for self.each_storage() |w| { *w = !*w } }\n+    fn invert(&mut self) { for self.each_storage |w| { *w = !*w } }\n \n     #[inline(always)]\n-    fn union(b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, lor)\n+    fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+        self.process(b, nbits, |w1, w2| w1 | w2)\n     }\n \n     #[inline(always)]\n-    fn intersect(b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, land)\n+    fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+        self.process(b, nbits, |w1, w2| w1 & w2)\n     }\n \n     #[inline(always)]\n-    fn become(b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, right)\n+    fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+        self.process(b, nbits, |_, w| w)\n     }\n \n     #[inline(always)]\n-    fn difference(b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, difference)\n+    fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+        self.process(b, nbits, |w1, w2| w1 & !w2)\n     }\n \n     #[inline(always)]\n-    pure fn get(i: uint) -> bool {\n-        let w = i / uint_bits;\n-        let b = i % uint_bits;\n+    pure fn get(&self, i: uint) -> bool {\n+        let w = i / uint::bits;\n+        let b = i % uint::bits;\n         let x = 1 & self.storage[w] >> b;\n         x == 1\n     }\n \n     #[inline(always)]\n-    fn set(i: uint, x: bool) {\n-        let w = i / uint_bits;\n-        let b = i % uint_bits;\n+    fn set(&mut self, i: uint, x: bool) {\n+        let w = i / uint::bits;\n+        let b = i % uint::bits;\n         let flag = 1 << b;\n         self.storage[w] = if x { self.storage[w] | flag }\n-                 else { self.storage[w] & !flag };\n+                          else { self.storage[w] & !flag };\n     }\n \n     #[inline(always)]\n-    fn equals(b: &BigBitv, nbits: uint) -> bool {\n+    fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n             let mask = big_mask(nbits, i);\n@@ -223,33 +221,19 @@ pub struct Bitv {\n     nbits: uint\n }\n \n-pub fn Bitv (nbits: uint, init: bool) -> Bitv {\n-    let rep = if nbits <= 32 {\n-        Small(~SmallBitv(if init {!0} else {0}))\n-    }\n-    else {\n-        let nelems = nbits/uint_bits +\n-                     if nbits % uint_bits == 0 {0} else {1};\n-        let elem = if init {!0} else {0};\n-        let s = from_elem(nelems, elem);\n-        Big(~BigBitv(s))\n-    };\n-    Bitv {rep: rep, nbits: nbits}\n-}\n-\n priv impl Bitv {\n \n-    fn die() -> ! {\n+    fn die(&self) -> ! {\n         fail!(~\"Tried to do operation on bit vectors with different sizes\");\n     }\n \n     #[inline(always)]\n-    fn do_op(op: Op, other: &Bitv) -> bool {\n+    fn do_op(&mut self, op: Op, other: &Bitv) -> bool {\n         if self.nbits != other.nbits {\n             self.die();\n         }\n         match self.rep {\n-          Small(ref s) => match other.rep {\n+          Small(ref mut s) => match other.rep {\n             Small(ref s1) => match op {\n               Union      => s.union(*s1,      self.nbits),\n               Intersect  => s.intersect(*s1,  self.nbits),\n@@ -258,7 +242,7 @@ priv impl Bitv {\n             },\n             Big(_) => self.die()\n           },\n-          Big(ref s) => match other.rep {\n+          Big(ref mut s) => match other.rep {\n             Small(_) => self.die(),\n             Big(ref s1) => match op {\n               Union      => s.union(*s1,      self.nbits),\n@@ -273,6 +257,19 @@ priv impl Bitv {\n }\n \n impl Bitv {\n+    static fn new(nbits: uint, init: bool) -> Bitv {\n+        let rep = if nbits <= uint::bits {\n+            Small(~SmallBitv::new(if init {!0} else {0}))\n+        }\n+        else {\n+            let nelems = nbits/uint::bits +\n+                         if nbits % uint::bits == 0 {0} else {1};\n+            let elem = if init {!0} else {0};\n+            let s = from_elem(nelems, elem);\n+            Big(~BigBitv::new(s))\n+        };\n+        Bitv {rep: rep, nbits: nbits}\n+    }\n \n     /**\n      * Calculates the union of two bitvectors\n@@ -281,7 +278,7 @@ impl Bitv {\n      * the same length. Returns 'true' if `self` changed.\n     */\n     #[inline(always)]\n-    fn union(v1: &Bitv) -> bool { self.do_op(Union, v1) }\n+    fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n \n     /**\n      * Calculates the intersection of two bitvectors\n@@ -290,7 +287,7 @@ impl Bitv {\n      * must be the same length. Returns 'true' if `self` changed.\n     */\n     #[inline(always)]\n-    fn intersect(v1: &Bitv) -> bool { self.do_op(Intersect, v1) }\n+    fn intersect(&mut self, v1: &Bitv) -> bool { self.do_op(Intersect, v1) }\n \n     /**\n      * Assigns the value of `v1` to `self`\n@@ -299,11 +296,11 @@ impl Bitv {\n      * changed\n      */\n     #[inline(always)]\n-    fn assign(v: &Bitv) -> bool { self.do_op(Assign, v) }\n+    fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }\n \n     /// Retrieve the value at index `i`\n     #[inline(always)]\n-    pure fn get(i: uint) -> bool {\n+    pure fn get(&self, i: uint) -> bool {\n        assert (i < self.nbits);\n        match self.rep {\n          Big(ref b)   => b.get(i),\n@@ -317,11 +314,11 @@ impl Bitv {\n      * `i` must be less than the length of the bitvector.\n      */\n     #[inline(always)]\n-    fn set(i: uint, x: bool) {\n+    fn set(&mut self, i: uint, x: bool) {\n       assert (i < self.nbits);\n       match self.rep {\n-        Big(ref b)   => b.set(i, x),\n-        Small(ref s) => s.set(i, x)\n+        Big(ref mut b)   => b.set(i, x),\n+        Small(ref mut s) => s.set(i, x)\n       }\n     }\n \n@@ -332,7 +329,7 @@ impl Bitv {\n      * bitvectors contain identical elements.\n      */\n     #[inline(always)]\n-    fn equal(v1: &Bitv) -> bool {\n+    fn equal(&self, v1: &Bitv) -> bool {\n       if self.nbits != v1.nbits { return false; }\n       match self.rep {\n         Small(ref b) => match v1.rep {\n@@ -348,27 +345,27 @@ impl Bitv {\n \n     /// Set all bits to 0\n     #[inline(always)]\n-    fn clear() {\n+    fn clear(&mut self) {\n         match self.rep {\n-          Small(ref b) => b.clear(),\n-          Big(ref s) => for s.each_storage() |w| { *w = 0u }\n+          Small(ref mut b) => b.clear(),\n+          Big(ref mut s) => for s.each_storage() |w| { *w = 0u }\n         }\n     }\n \n     /// Set all bits to 1\n     #[inline(always)]\n-    fn set_all() {\n+    fn set_all(&mut self) {\n       match self.rep {\n-        Small(ref b) => b.set_all(),\n-        Big(ref s) => for s.each_storage() |w| { *w = !0u } }\n+        Small(ref mut b) => b.set_all(),\n+        Big(ref mut s) => for s.each_storage() |w| { *w = !0u } }\n     }\n \n     /// Invert all bits\n     #[inline(always)]\n-    fn invert() {\n+    fn invert(&mut self) {\n       match self.rep {\n-        Small(ref b) => b.invert(),\n-        Big(ref s) => for s.each_storage() |w| { *w = !*w } }\n+        Small(ref mut b) => b.invert(),\n+        Big(ref mut s) => for s.each_storage() |w| { *w = !*w } }\n     }\n \n     /**\n@@ -381,11 +378,11 @@ impl Bitv {\n      * Returns `true` if `v0` was changed.\n      */\n     #[inline(always)]\n-    fn difference(v: &Bitv) -> bool { self.do_op(Difference, v) }\n+    fn difference(&mut self, v: &Bitv) -> bool { self.do_op(Difference, v) }\n \n     /// Returns true if all bits are 1\n     #[inline(always)]\n-    fn is_true() -> bool {\n+    fn is_true(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_true(self.nbits),\n         _ => {\n@@ -396,7 +393,7 @@ impl Bitv {\n     }\n \n     #[inline(always)]\n-    fn each(f: fn(bool) -> bool) {\n+    fn each(&self, f: fn(bool) -> bool) {\n         let mut i = 0;\n         while i < self.nbits {\n             if !f(self.get(i)) { break; }\n@@ -405,7 +402,7 @@ impl Bitv {\n     }\n \n     /// Returns true if all bits are 0\n-    fn is_false() -> bool {\n+    fn is_false(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_false(self.nbits),\n         Big(_) => {\n@@ -415,7 +412,7 @@ impl Bitv {\n       }\n     }\n \n-    fn init_to_vec(i: uint) -> uint {\n+    fn init_to_vec(&self, i: uint) -> uint {\n       return if self.get(i) { 1 } else { 0 };\n     }\n \n@@ -424,7 +421,7 @@ impl Bitv {\n      *\n      * Each uint in the resulting vector has either value 0u or 1u.\n      */\n-    fn to_vec() -> ~[uint] {\n+    fn to_vec(&self) -> ~[uint] {\n         vec::from_fn(self.nbits, |x| self.init_to_vec(x))\n     }\n \n@@ -434,7 +431,7 @@ impl Bitv {\n      * size of the bitv is not a multiple of 8 then trailing bits\n      * will be filled-in with false/0\n      */\n-    fn to_bytes() -> ~[u8] {\n+    fn to_bytes(&self) -> ~[u8] {\n \n         fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n             let offset = byte * 8 + bit;\n@@ -448,21 +445,21 @@ impl Bitv {\n         let len = self.nbits/8 +\n                   if self.nbits % 8 == 0 { 0 } else { 1 };\n         vec::from_fn(len, |i|\n-            bit(&self, i, 0) |\n-            bit(&self, i, 1) |\n-            bit(&self, i, 2) |\n-            bit(&self, i, 3) |\n-            bit(&self, i, 4) |\n-            bit(&self, i, 5) |\n-            bit(&self, i, 6) |\n-            bit(&self, i, 7)\n+            bit(self, i, 0) |\n+            bit(self, i, 1) |\n+            bit(self, i, 2) |\n+            bit(self, i, 3) |\n+            bit(self, i, 4) |\n+            bit(self, i, 5) |\n+            bit(self, i, 6) |\n+            bit(self, i, 7)\n         )\n     }\n \n     /**\n      * Transform self into a [bool] by turning each bit into a bool\n      */\n-    fn to_bools() -> ~[bool] {\n+    fn to_bools(&self) -> ~[bool] {\n         vec::from_fn(self.nbits, |i| self[i])\n     }\n \n@@ -485,7 +482,7 @@ impl Bitv {\n      * The uint vector is expected to only contain the values 0u and 1u. Both\n      * the bitvector and vector must have the same length\n      */\n-    fn eq_vec(v: ~[uint]) -> bool {\n+    fn eq_vec(&self, v: ~[uint]) -> bool {\n         assert self.nbits == v.len();\n         let mut i = 0;\n         while i < self.nbits {\n@@ -497,7 +494,7 @@ impl Bitv {\n         true\n     }\n \n-    fn ones(f: fn(uint) -> bool) {\n+    fn ones(&self, f: fn(uint) -> bool) {\n         for uint::range(0, self.nbits) |i| {\n             if self.get(i) {\n                 if !f(i) { break }\n@@ -516,7 +513,7 @@ impl Clone for Bitv {\n             Bitv{nbits: self.nbits, rep: Small(~SmallBitv{bits: b.bits})}\n           }\n           Big(ref b) => {\n-            let mut st = from_elem(self.nbits / uint_bits + 1, 0);\n+            let mut st = from_elem(self.nbits / uint::bits + 1, 0);\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n             Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: st})}\n@@ -551,69 +548,368 @@ pub fn from_bools(bools: &[bool]) -> Bitv {\n  * index is f(index).\n  */\n pub fn from_fn(len: uint, f: fn(index: uint) -> bool) -> Bitv {\n-    let bitv = Bitv(len, false);\n+    let mut bitv = Bitv::new(len, false);\n     for uint::range(0, len) |i| {\n         bitv.set(i, f(i));\n     }\n     bitv\n }\n \n-const uint_bits: uint = 32u + (1u << 32u >> 27u);\n+impl ops::Index<uint,bool> for Bitv {\n+    pure fn index(&self, i: uint) -> bool {\n+        self.get(i)\n+    }\n+}\n \n-pure fn lor(w0: uint, w1: uint) -> uint { return w0 | w1; }\n+#[inline(always)]\n+pure fn iterate_bits(base: uint, bits: uint, f: fn(uint) -> bool) -> bool {\n+    if bits == 0 {\n+        return true;\n+    }\n+    for uint::range(0, uint::bits) |i| {\n+        if bits & (1 << i) != 0 {\n+            if !f(base + i) {\n+                return false;\n+            }\n+        }\n+    }\n+    return true;\n+}\n \n-pure fn land(w0: uint, w1: uint) -> uint { return w0 & w1; }\n+/// An implementation of a set using a bit vector as an underlying\n+/// representation for holding numerical elements.\n+///\n+/// It should also be noted that the amount of storage necessary for holding a\n+/// set of objects is proportional to the maximum of the objects when viewed\n+/// as a uint.\n+pub struct BitvSet {\n+    priv size: uint,\n+\n+    // In theory this is a Bitv instead of always a BigBitv, but knowing that\n+    // there's an array of storage makes our lives a whole lot easier when\n+    // performing union/intersection/etc operations\n+    priv bitv: BigBitv\n+}\n \n-pure fn difference(w0: uint, w1: uint) -> uint { return w0 & !w1; }\n+impl BitvSet {\n+    /// Creates a new bit vector set with initially no contents\n+    static fn new() -> BitvSet {\n+        BitvSet{ size: 0, bitv: BigBitv::new(~[0]) }\n+    }\n \n-pure fn right(_w0: uint, w1: uint) -> uint { return w1; }\n+    /// Creates a new bit vector set from the given bit vector\n+    static fn from_bitv(bitv: Bitv) -> BitvSet {\n+        let mut size = 0;\n+        for bitv.ones |_| {\n+            size += 1;\n+        }\n+        let Bitv{rep, _} = bitv;\n+        match rep {\n+            Big(~b) => BitvSet{ size: size, bitv: b },\n+            Small(~SmallBitv{bits}) =>\n+                BitvSet{ size: size, bitv: BigBitv{ storage: ~[bits] } },\n+        }\n+    }\n \n-impl ops::Index<uint,bool> for Bitv {\n-    pure fn index(&self, i: uint) -> bool {\n-        self.get(i)\n+    /// Returns the capacity in bits for this bit vector. Inserting any\n+    /// element less than this amount will not trigger a resizing.\n+    pure fn capacity(&self) -> uint { self.bitv.storage.len() * uint::bits }\n+\n+    /// Consumes this set to return the underlying bit vector\n+    fn unwrap(self) -> Bitv {\n+        let cap = self.capacity();\n+        let BitvSet{bitv, _} = self;\n+        return Bitv{ nbits:cap, rep: Big(~bitv) };\n+    }\n+\n+    #[inline(always)]\n+    priv fn other_op(&mut self, other: &BitvSet, f: fn(uint, uint) -> uint) {\n+        fn nbits(mut w: uint) -> uint {\n+            let mut bits = 0;\n+            for uint::bits.times {\n+                if w == 0 {\n+                    break;\n+                }\n+                bits += w & 1;\n+                w >>= 1;\n+            }\n+            return bits;\n+        }\n+        if self.capacity() < other.capacity() {\n+            self.bitv.storage.grow(other.capacity() / uint::bits, &0);\n+        }\n+        for other.bitv.storage.eachi |i, &w| {\n+            let old = self.bitv.storage[i];\n+            let new = f(old, w);\n+            self.bitv.storage[i] = new;\n+            self.size += nbits(new) - nbits(old);\n+        }\n+    }\n+\n+    /// Union in-place with the specified other bit vector\n+    fn union_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 | w2);\n+    }\n+\n+    /// Intersect in-place with the specified other bit vector\n+    fn intersect_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 & w2);\n+    }\n+\n+    /// Difference in-place with the specified other bit vector\n+    fn difference_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 & !w2);\n+    }\n+\n+    /// Symmetric difference in-place with the specified other bit vector\n+    fn symmetric_difference_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 ^ w2);\n+    }\n+}\n+\n+impl BaseIter<uint> for BitvSet {\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+\n+    pure fn each(&self, blk: fn(v: &uint) -> bool) {\n+        for self.bitv.storage.eachi |i, &w| {\n+            if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n+impl cmp::Eq for BitvSet {\n+    pure fn eq(&self, other: &BitvSet) -> bool {\n+        if self.size != other.size {\n+            return false;\n+        }\n+        for self.each_common(other) |_, w1, w2| {\n+            if w1 != w2 {\n+                return false;\n+            }\n+        }\n+        for self.each_outlier(other) |_, _, w| {\n+            if w != 0 {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    pure fn ne(&self, other: &BitvSet) -> bool { !self.eq(other) }\n+}\n+\n+impl Container for BitvSet {\n+    pure fn len(&self) -> uint { self.size }\n+    pure fn is_empty(&self) -> bool { self.size == 0 }\n+}\n+\n+impl Mutable for BitvSet {\n+    fn clear(&mut self) {\n+        for self.bitv.each_storage |w| { *w = 0; }\n+        self.size = 0;\n+    }\n+}\n+\n+impl Set<uint> for BitvSet {\n+    pure fn contains(&self, value: &uint) -> bool {\n+        *value < self.bitv.storage.len() * uint::bits && self.bitv.get(*value)\n+    }\n+\n+    fn insert(&mut self, value: uint) -> bool {\n+        if self.contains(&value) {\n+            return false;\n+        }\n+        let nbits = self.capacity();\n+        if value >= nbits {\n+            let newsize = uint::max(value, nbits * 2) / uint::bits + 1;\n+            assert newsize > self.bitv.storage.len();\n+            self.bitv.storage.grow(newsize, &0);\n+        }\n+        self.size += 1;\n+        self.bitv.set(value, true);\n+        return true;\n+    }\n+\n+    fn remove(&mut self, value: &uint) -> bool {\n+        if !self.contains(value) {\n+            return false;\n+        }\n+        self.size -= 1;\n+        self.bitv.set(*value, false);\n+\n+        // Attempt to truncate our storage\n+        let mut i = self.bitv.storage.len();\n+        while i > 1 && self.bitv.storage[i - 1] == 0 {\n+            i -= 1;\n+        }\n+        self.bitv.storage.truncate(i);\n+\n+        return true;\n+    }\n+\n+    pure fn is_disjoint(&self, other: &BitvSet) -> bool {\n+        for self.intersection(other) |_| {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    pure fn is_subset(&self, other: &BitvSet) -> bool {\n+        for self.each_common(other) |_, w1, w2| {\n+            if w1 & w2 != w1 {\n+                return false;\n+            }\n+        }\n+        /* If anything is not ours, then everything is not ours so we're\n+           definitely a subset in that case. Otherwise if there's any stray\n+           ones that 'other' doesn't have, we're not a subset. */\n+        for self.each_outlier(other) |mine, _, w| {\n+            if !mine {\n+                return true;\n+            } else if w != 0 {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    pure fn is_superset(&self, other: &BitvSet) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    pure fn difference(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+        for self.each_common(other) |i, w1, w2| {\n+            if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n+                return;\n+            }\n+        }\n+        /* everything we have that they don't also shows up */\n+        self.each_outlier(other, |mine, i, w|\n+            !mine || iterate_bits(i, w, |b| f(&b))\n+        );\n+    }\n+\n+    pure fn symmetric_difference(&self, other: &BitvSet,\n+                                 f: fn(&uint) -> bool) {\n+        for self.each_common(other) |i, w1, w2| {\n+            if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n+                return;\n+            }\n+        }\n+        self.each_outlier(other, |_, i, w|\n+            iterate_bits(i, w, |b| f(&b))\n+        );\n+    }\n+\n+    pure fn intersection(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+        for self.each_common(other) |i, w1, w2| {\n+            if !iterate_bits(i, w1 & w2, |b| f(&b)) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    pure fn union(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+        for self.each_common(other) |i, w1, w2| {\n+            if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n+                return;\n+            }\n+        }\n+        self.each_outlier(other, |_, i, w|\n+            iterate_bits(i, w, |b| f(&b))\n+        );\n+    }\n+}\n+\n+priv impl BitvSet {\n+    /// Visits each of the words that the two bit vectors (self and other)\n+    /// both have in common. The three yielded arguments are (bit location,\n+    /// w1, w2) where the bit location is the number of bits offset so far,\n+    /// and w1/w2 are the words coming from the two vectors self, other.\n+    pure fn each_common(&self, other: &BitvSet,\n+                        f: fn(uint, uint, uint) -> bool) {\n+        let min = uint::min(self.bitv.storage.len(),\n+                            other.bitv.storage.len());\n+        for self.bitv.storage.view(0, min).eachi |i, &w| {\n+            if !f(i * uint::bits, w, other.bitv.storage[i]) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    /// Visits each word in self or other that extends beyond the other. This\n+    /// will only iterate through one of the vectors, and it only iterates\n+    /// over the portion that doesn't overlap with the other one.\n+    ///\n+    /// The yielded arguments are a bool, the bit offset, and a word. The bool\n+    /// is true if the word comes from 'self', and false if it comes from\n+    /// 'other'.\n+    pure fn each_outlier(&self, other: &BitvSet,\n+                         f: fn(bool, uint, uint) -> bool) {\n+        let len1 = self.bitv.storage.len();\n+        let len2 = other.bitv.storage.len();\n+        let min = uint::min(len1, len2);\n+\n+        /* only one of these loops will execute and that's the point */\n+        for self.bitv.storage.view(min, len1).eachi |i, &w| {\n+            if !f(true, (i + min) * uint::bits, w) {\n+                return;\n+            }\n+        }\n+        for other.bitv.storage.view(min, len2).eachi |i, &w| {\n+            if !f(false, (i + min) * uint::bits, w) {\n+                return;\n+            }\n+        }\n     }\n }\n \n #[cfg(test)]\n mod tests {\n     use core::prelude::*;\n+    use std::test::BenchHarness;\n \n     use bitv::*;\n     use bitv;\n \n     use core::uint;\n     use core::vec;\n+    use core::rand;\n+\n+    const bench_bits : uint = 1 << 14;\n \n     #[test]\n     pub fn test_to_str() {\n-        let zerolen = Bitv(0u, false);\n+        let zerolen = Bitv::new(0u, false);\n         assert zerolen.to_str() == ~\"\";\n \n-        let eightbits = Bitv(8u, false);\n+        let eightbits = Bitv::new(8u, false);\n         assert eightbits.to_str() == ~\"00000000\";\n     }\n \n     #[test]\n     pub fn test_0_elements() {\n         let mut act;\n         let mut exp;\n-        act = Bitv(0u, false);\n+        act = Bitv::new(0u, false);\n         exp = vec::from_elem::<uint>(0u, 0u);\n         assert act.eq_vec(exp);\n     }\n \n     #[test]\n     pub fn test_1_element() {\n         let mut act;\n-        act = Bitv(1u, false);\n+        act = Bitv::new(1u, false);\n         assert act.eq_vec(~[0u]);\n-        act = Bitv(1u, true);\n+        act = Bitv::new(1u, true);\n         assert act.eq_vec(~[1u]);\n     }\n \n     #[test]\n     pub fn test_2_elements() {\n-        let b = bitv::Bitv(2, false);\n+        let mut b = bitv::Bitv::new(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert b.to_str() == ~\"10\";\n@@ -624,15 +920,15 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv(10u, false);\n+        act = Bitv::new(10u, false);\n         assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = Bitv(10u, true);\n+        act = Bitv::new(10u, true);\n         assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(10u, false);\n+        act = Bitv::new(10u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -641,7 +937,7 @@ mod tests {\n         assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(10u, false);\n+        act = Bitv::new(10u, false);\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n@@ -650,7 +946,7 @@ mod tests {\n         assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(10u, false);\n+        act = Bitv::new(10u, false);\n         act.set(0u, true);\n         act.set(3u, true);\n         act.set(6u, true);\n@@ -663,21 +959,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv(31u, false);\n+        act = Bitv::new(31u, false);\n         assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = Bitv(31u, true);\n+        act = Bitv::new(31u, true);\n         assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(31u, false);\n+        act = Bitv::new(31u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -692,7 +988,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(31u, false);\n+        act = Bitv::new(31u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -707,7 +1003,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(31u, false);\n+        act = Bitv::new(31u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -721,7 +1017,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(31u, false);\n+        act = Bitv::new(31u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -736,21 +1032,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv(32u, false);\n+        act = Bitv::new(32u, false);\n         assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = Bitv(32u, true);\n+        act = Bitv::new(32u, true);\n         assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(32u, false);\n+        act = Bitv::new(32u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -765,7 +1061,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(32u, false);\n+        act = Bitv::new(32u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -780,7 +1076,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(32u, false);\n+        act = Bitv::new(32u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -795,7 +1091,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(32u, false);\n+        act = Bitv::new(32u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -811,21 +1107,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv(33u, false);\n+        act = Bitv::new(33u, false);\n         assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = Bitv(33u, true);\n+        act = Bitv::new(33u, true);\n         assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(33u, false);\n+        act = Bitv::new(33u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -840,7 +1136,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(33u, false);\n+        act = Bitv::new(33u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -855,7 +1151,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(33u, false);\n+        act = Bitv::new(33u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -870,7 +1166,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u, 1u, 0u]));\n         // mixed\n \n-        act = Bitv(33u, false);\n+        act = Bitv::new(33u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -884,37 +1180,37 @@ mod tests {\n \n     #[test]\n     pub fn test_equal_differing_sizes() {\n-        let v0 = Bitv(10u, false);\n-        let v1 = Bitv(11u, false);\n+        let v0 = Bitv::new(10u, false);\n+        let v1 = Bitv::new(11u, false);\n         assert !v0.equal(&v1);\n     }\n \n     #[test]\n     pub fn test_equal_greatly_differing_sizes() {\n-        let v0 = Bitv(10u, false);\n-        let v1 = Bitv(110u, false);\n+        let v0 = Bitv::new(10u, false);\n+        let v1 = Bitv::new(110u, false);\n         assert !v0.equal(&v1);\n     }\n \n     #[test]\n     pub fn test_equal_sneaky_small() {\n-        let a = bitv::Bitv(1, false);\n+        let mut a = bitv::Bitv::new(1, false);\n         a.set(0, true);\n \n-        let b = bitv::Bitv(1, true);\n+        let mut b = bitv::Bitv::new(1, true);\n         b.set(0, true);\n \n         assert a.equal(&b);\n     }\n \n     #[test]\n     pub fn test_equal_sneaky_big() {\n-        let a = bitv::Bitv(100, false);\n+        let mut a = bitv::Bitv::new(100, false);\n         for uint::range(0, 100) |i| {\n             a.set(i, true);\n         }\n \n-        let b = bitv::Bitv(100, true);\n+        let mut b = bitv::Bitv::new(100, true);\n         for uint::range(0, 100) |i| {\n             b.set(i, true);\n         }\n@@ -931,11 +1227,11 @@ mod tests {\n \n     #[test]\n     pub fn test_to_bytes() {\n-        let bv = Bitv(3, true);\n+        let mut bv = Bitv::new(3, true);\n         bv.set(1, false);\n         assert bv.to_bytes() == ~[0b10100000];\n \n-        let bv = Bitv(9, false);\n+        let mut bv = Bitv::new(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n         assert bv.to_bytes() == ~[0b00100000, 0b10000000];\n@@ -954,48 +1250,266 @@ mod tests {\n \n     #[test]\n     pub fn test_small_difference() {\n-      let b1 = Bitv(3, false);\n-      let b2 = Bitv(3, false);\n-      b1.set(0, true);\n-      b1.set(1, true);\n-      b2.set(1, true);\n-      b2.set(2, true);\n-      assert b1.difference(&b2);\n-      assert b1[0];\n-      assert !b1[1];\n-      assert !b1[2];\n+        let mut b1 = Bitv::new(3, false);\n+        let mut b2 = Bitv::new(3, false);\n+        b1.set(0, true);\n+        b1.set(1, true);\n+        b2.set(1, true);\n+        b2.set(2, true);\n+        assert b1.difference(&b2);\n+        assert b1[0];\n+        assert !b1[1];\n+        assert !b1[2];\n     }\n \n     #[test]\n     pub fn test_big_difference() {\n-      let b1 = Bitv(100, false);\n-      let b2 = Bitv(100, false);\n-      b1.set(0, true);\n-      b1.set(40, true);\n-      b2.set(40, true);\n-      b2.set(80, true);\n-      assert b1.difference(&b2);\n-      assert b1[0];\n-      assert !b1[40];\n-      assert !b1[80];\n+        let mut b1 = Bitv::new(100, false);\n+        let mut b2 = Bitv::new(100, false);\n+        b1.set(0, true);\n+        b1.set(40, true);\n+        b2.set(40, true);\n+        b2.set(80, true);\n+        assert b1.difference(&b2);\n+        assert b1[0];\n+        assert !b1[40];\n+        assert !b1[80];\n     }\n \n     #[test]\n     pub fn test_small_clear() {\n-      let b = Bitv(14, true);\n-      b.clear();\n-      for b.ones |i| {\n-          fail!(fmt!(\"found 1 at %?\", i));\n-      }\n+        let mut b = Bitv::new(14, true);\n+        b.clear();\n+        for b.ones |i| {\n+            fail!(fmt!(\"found 1 at %?\", i));\n+        }\n     }\n \n     #[test]\n     pub fn test_big_clear() {\n-      let b = Bitv(140, true);\n-      b.clear();\n-      for b.ones |i| {\n-          fail!(fmt!(\"found 1 at %?\", i));\n-      }\n+        let mut b = Bitv::new(140, true);\n+        b.clear();\n+        for b.ones |i| {\n+            fail!(fmt!(\"found 1 at %?\", i));\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_bitv_set_basic() {\n+        let mut b = BitvSet::new();\n+        assert b.insert(3);\n+        assert !b.insert(3);\n+        assert b.contains(&3);\n+        assert b.insert(400);\n+        assert !b.insert(400);\n+        assert b.contains(&400);\n+        assert b.len() == 2;\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_intersection() {\n+        let mut a = BitvSet::new();\n+        let mut b = BitvSet::new();\n+\n+        assert a.insert(11);\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(77);\n+        assert a.insert(103);\n+        assert a.insert(5);\n+\n+        assert b.insert(2);\n+        assert b.insert(11);\n+        assert b.insert(77);\n+        assert b.insert(5);\n+        assert b.insert(3);\n+\n+        let mut i = 0;\n+        let expected = [3, 5, 11, 77];\n+        for a.intersection(&b) |x| {\n+            assert *x == expected[i];\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_difference() {\n+        let mut a = BitvSet::new();\n+        let mut b = BitvSet::new();\n+\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(5);\n+        assert a.insert(200);\n+        assert a.insert(500);\n+\n+        assert b.insert(3);\n+        assert b.insert(200);\n+\n+        let mut i = 0;\n+        let expected = [1, 5, 500];\n+        for a.difference(&b) |x| {\n+            assert *x == expected[i];\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_symmetric_difference() {\n+        let mut a = BitvSet::new();\n+        let mut b = BitvSet::new();\n+\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(5);\n+        assert a.insert(9);\n+        assert a.insert(11);\n+\n+        assert b.insert(3);\n+        assert b.insert(9);\n+        assert b.insert(14);\n+        assert b.insert(220);\n+\n+        let mut i = 0;\n+        let expected = [1, 5, 11, 14, 220];\n+        for a.symmetric_difference(&b) |x| {\n+            assert *x == expected[i];\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+\n+    #[test]\n+    pub fn test_bitv_set_union() {\n+        let mut a = BitvSet::new();\n+        let mut b = BitvSet::new();\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(5);\n+        assert a.insert(9);\n+        assert a.insert(11);\n+        assert a.insert(160);\n+        assert a.insert(19);\n+        assert a.insert(24);\n+\n+        assert b.insert(1);\n+        assert b.insert(5);\n+        assert b.insert(9);\n+        assert b.insert(13);\n+        assert b.insert(19);\n+\n+        let mut i = 0;\n+        let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n+        for a.union(&b) |x| {\n+            assert *x == expected[i];\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+\n+    #[test]\n+    pub fn test_bitv_remove() {\n+        let mut a = BitvSet::new();\n+\n+        assert a.insert(1);\n+        assert a.remove(&1);\n+\n+        assert a.insert(100);\n+        assert a.remove(&100);\n+\n+        assert a.insert(1000);\n+        assert a.remove(&1000);\n+        assert a.capacity() == uint::bits;\n+    }\n+\n+    fn rng() -> rand::Rng {\n+        let seed = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n+        rand::seeded_rng(&seed)\n+    }\n+\n+    #[bench]\n+    pub fn bench_uint_small(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = 0 as uint;\n+        do b.iter {\n+            bitv |= (1 << ((r.next() as uint) % uint::bits));\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_small_bitv_small(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = SmallBitv::new(uint::bits);\n+        do b.iter {\n+            bitv.set((r.next() as uint) % uint::bits, true);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_big_bitv_small(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = BigBitv::new(~[0]);\n+        do b.iter {\n+            bitv.set((r.next() as uint) % uint::bits, true);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_big_bitv_big(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut storage = ~[];\n+        storage.grow(bench_bits / uint::bits, &0);\n+        let mut bitv = BigBitv::new(storage);\n+        do b.iter {\n+            bitv.set((r.next() as uint) % bench_bits, true);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_bitv_big(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = Bitv::new(bench_bits, false);\n+        do b.iter {\n+            bitv.set((r.next() as uint) % bench_bits, true);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_bitv_small(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = Bitv::new(uint::bits, false);\n+        do b.iter {\n+            bitv.set((r.next() as uint) % uint::bits, true);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_bitv_set_small(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = BitvSet::new();\n+        do b.iter {\n+            bitv.insert((r.next() as uint) % uint::bits);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_bitv_set_big(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = BitvSet::new();\n+        do b.iter {\n+            bitv.insert((r.next() as uint) % bench_bits);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_bitv_big_union(b: &mut BenchHarness) {\n+        let mut b1 = Bitv::new(bench_bits, false);\n+        let mut b2 = Bitv::new(bench_bits, false);\n+        do b.iter {\n+            b1.union(&b2);\n+        }\n     }\n }\n "}, {"sha": "a7f01d756485984a9b67d8dcd1693e4d1a6b075a", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6351515d98d4d79500eac021bd573fbbd586bb24/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6351515d98d4d79500eac021bd573fbbd586bb24/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=6351515d98d4d79500eac021bd573fbbd586bb24", "patch": "@@ -43,13 +43,13 @@ use ext::base::ext_ctxt;\n use ext::pipes::proto::protocol;\n \n use core::str;\n-use std::bitv::{Bitv};\n+use std::bitv::Bitv;\n \n pub fn analyze(proto: protocol, _cx: ext_ctxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n-    let colive = do (copy proto.states).map_to_vec |state| {\n-        let bv = ~Bitv(num_states, false);\n+    let mut colive = do (copy proto.states).map_to_vec |state| {\n+        let mut bv = ~Bitv::new(num_states, false);\n         for state.reachable |s| {\n             bv.set(s.id, true);\n         }\n@@ -61,15 +61,19 @@ pub fn analyze(proto: protocol, _cx: ext_ctxt) {\n     while changed {\n         changed = false;\n         debug!(\"colive iteration %?\", i);\n+        let mut new_colive = ~[];\n         for colive.eachi |i, this_colive| {\n+            let mut result = ~this_colive.clone();\n             let this = proto.get_state_by_id(i);\n             for this_colive.ones |j| {\n                 let next = proto.get_state_by_id(j);\n                 if this.dir == next.dir {\n-                    changed = changed || this_colive.union(colive[j]);\n+                    changed = result.union(colive[j]) || changed;\n                 }\n             }\n+            new_colive.push(result)\n         }\n+        colive = new_colive;\n         i += 1;\n     }\n "}, {"sha": "cfb27329174fe72c58c162264250354d4b1165f7", "filename": "src/test/bench/core-set.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/6351515d98d4d79500eac021bd573fbbd586bb24/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6351515d98d4d79500eac021bd573fbbd586bb24/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=6351515d98d4d79500eac021bd573fbbd586bb24", "patch": "@@ -0,0 +1,180 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod std;\n+use core::hashmap::linear::LinearSet;\n+use std::bitv::BitvSet;\n+use std::treemap::TreeSet;\n+use core::io::WriterUtil;\n+\n+struct Results {\n+    sequential_ints: float,\n+    random_ints: float,\n+    delete_ints: float,\n+\n+    sequential_strings: float,\n+    random_strings: float,\n+    delete_strings: float\n+}\n+\n+fn timed(result: &mut float, op: fn()) {\n+    let start = std::time::precise_time_s();\n+    op();\n+    let end = std::time::precise_time_s();\n+    *result = (end - start);\n+}\n+\n+impl Results {\n+    fn bench_int<T: Set<uint>>(&mut self, rng: @rand::Rng, num_keys: uint,\n+                               rand_cap: uint, f: fn() -> T) {\n+        {\n+            let mut set = f();\n+            do timed(&mut self.sequential_ints) {\n+                for uint::range(0, num_keys) |i| {\n+                    set.insert(i);\n+                }\n+\n+                for uint::range(0, num_keys) |i| {\n+                    assert set.contains(&i);\n+                }\n+            }\n+        }\n+\n+        {\n+            let mut set = f();\n+            do timed(&mut self.random_ints) {\n+                for num_keys.times {\n+                    set.insert((rng.next() as uint) % rand_cap);\n+                }\n+            }\n+        }\n+\n+        {\n+            let mut set = f();\n+            for uint::range(0, num_keys) |i| {\n+                set.insert(i);\n+            }\n+\n+            do timed(&mut self.delete_ints) {\n+                for uint::range(0, num_keys) |i| {\n+                    assert set.remove(&i);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn bench_str<T: Set<~str>>(&mut self, rng: @rand::Rng, num_keys: uint,\n+                               f: fn() -> T) {\n+        {\n+            let mut set = f();\n+            do timed(&mut self.sequential_strings) {\n+                for uint::range(0, num_keys) |i| {\n+                    let s = uint::to_str(i);\n+                    set.insert(s);\n+                }\n+\n+                for uint::range(0, num_keys) |i| {\n+                    let s = uint::to_str(i);\n+                    assert set.contains(&s);\n+                }\n+            }\n+        }\n+\n+        {\n+            let mut set = f();\n+            do timed(&mut self.random_strings) {\n+                for num_keys.times {\n+                    let s = uint::to_str(rng.next() as uint);\n+                    set.insert(s);\n+                }\n+            }\n+        }\n+\n+        {\n+            let mut set = f();\n+            for uint::range(0, num_keys) |i| {\n+                set.insert(uint::to_str(i));\n+            }\n+            do timed(&mut self.delete_strings) {\n+                for uint::range(0, num_keys) |i| {\n+                    assert set.remove(&uint::to_str(i));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn write_header(header: &str) {\n+    io::stdout().write_str(header);\n+    io::stdout().write_str(\"\\n\");\n+}\n+\n+fn write_row(label: &str, value: float) {\n+    io::stdout().write_str(fmt!(\"%30s %f s\\n\", label, value));\n+}\n+\n+fn write_results(label: &str, results: &Results) {\n+    write_header(label);\n+    write_row(\"sequential_ints\", results.sequential_ints);\n+    write_row(\"random_ints\", results.random_ints);\n+    write_row(\"delete_ints\", results.delete_ints);\n+    write_row(\"sequential_strings\", results.sequential_strings);\n+    write_row(\"random_strings\", results.random_strings);\n+    write_row(\"delete_strings\", results.delete_strings);\n+}\n+\n+fn empty_results() -> Results {\n+    Results {\n+        sequential_ints: 0f,\n+        random_ints: 0f,\n+        delete_ints: 0f,\n+\n+        sequential_strings: 0f,\n+        random_strings: 0f,\n+        delete_strings: 0f,\n+    }\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    let num_keys = {\n+        if args.len() == 2 {\n+            uint::from_str(args[1]).get()\n+        } else {\n+            100 // woefully inadequate for any real measurement\n+        }\n+    };\n+\n+    let seed = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let max = 200000;\n+\n+    {\n+        let rng = rand::seeded_rng(&seed);\n+        let mut results = empty_results();\n+        results.bench_int(rng, num_keys, max, || LinearSet::new::<uint>());\n+        results.bench_str(rng, num_keys, || LinearSet::new::<~str>());\n+        write_results(\"core::hashmap::LinearSet\", &results);\n+    }\n+\n+    {\n+        let rng = rand::seeded_rng(&seed);\n+        let mut results = empty_results();\n+        results.bench_int(rng, num_keys, max, || TreeSet::new::<uint>());\n+        results.bench_str(rng, num_keys, || TreeSet::new::<~str>());\n+        write_results(\"std::treemap::TreeSet\", &results);\n+    }\n+\n+    {\n+        let rng = rand::seeded_rng(&seed);\n+        let mut results = empty_results();\n+        results.bench_int(rng, num_keys, max, || BitvSet::new());\n+        write_results(\"std::bitv::BitvSet\", &results);\n+    }\n+}"}, {"sha": "a3a3ef85f45ae5f1899467386e35bad83d89c420", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6351515d98d4d79500eac021bd573fbbd586bb24/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6351515d98d4d79500eac021bd573fbbd586bb24/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=6351515d98d4d79500eac021bd573fbbd586bb24", "patch": "@@ -58,7 +58,7 @@ pub fn solve_grid(g: grid_t) {\n     fn next_color(mut g: grid, row: u8, col: u8, start_color: u8) -> bool {\n         if start_color < 10u8 {\n             // colors not yet used\n-            let avail = bitv::Bitv(10u, false);\n+            let mut avail = bitv::Bitv::new(10u, false);\n             for u8::range(start_color, 10u8) |color| {\n                 avail.set(color as uint, true);\n             }\n@@ -80,7 +80,7 @@ pub fn solve_grid(g: grid_t) {\n \n     // find colors available in neighbourhood of (row, col)\n     fn drop_colors(g: grid, avail: bitv::Bitv, row: u8, col: u8) {\n-        fn drop_color(g: grid, colors: bitv::Bitv, row: u8, col: u8) {\n+        fn drop_color(g: grid, mut colors: bitv::Bitv, row: u8, col: u8) {\n             let color = g[row][col];\n             if color != 0u8 { colors.set(color as uint, false); }\n         }"}, {"sha": "6cb0cf4e3776d7caad1a67eb88a5e8f48c1d7b24", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6351515d98d4d79500eac021bd573fbbd586bb24/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6351515d98d4d79500eac021bd573fbbd586bb24/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=6351515d98d4d79500eac021bd573fbbd586bb24", "patch": "@@ -14,8 +14,8 @@ extern mod std;\n use std::bitv::*;\n \n fn bitv_test() -> bool {\n-    let v1 = ~Bitv(31, false);\n-    let v2 = ~Bitv(31, true);\n+    let mut v1 = ~Bitv::new(31, false);\n+    let v2 = ~Bitv::new(31, true);\n     v1.union(v2);\n     true\n }"}]}