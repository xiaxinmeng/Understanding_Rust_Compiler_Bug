{"sha": "2665b6434e6c851f6bffecf83e35db22ee6bf6bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NjViNjQzNGU2Yzg1MWY2YmZmZWNmODNlMzVkYjIyZWU2YmY2YmQ=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril@gmail.com", "date": "2019-09-23T08:01:57Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril@gmail.com", "date": "2019-10-27T17:34:21Z"}, "message": "Clarify and fix the explanation of the algorithm\n\nThere was a bit of confusion between individual patterns and lists of\npatterns, and index mismatches linked to that. This introduces a\nvocabulary of \"pattern-stacks\" to provide a clearer mental model of what\nis happening. This also adds examples.", "tree": {"sha": "e608b443726e18f3fda3ff873fee1d8299d05c4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e608b443726e18f3fda3ff873fee1d8299d05c4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2665b6434e6c851f6bffecf83e35db22ee6bf6bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2665b6434e6c851f6bffecf83e35db22ee6bf6bd", "html_url": "https://github.com/rust-lang/rust/commit/2665b6434e6c851f6bffecf83e35db22ee6bf6bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2665b6434e6c851f6bffecf83e35db22ee6bf6bd/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79865994170321d0237e13fbd57aced2090f16f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/79865994170321d0237e13fbd57aced2090f16f5", "html_url": "https://github.com/rust-lang/rust/commit/79865994170321d0237e13fbd57aced2090f16f5"}], "stats": {"total": 198, "additions": 132, "deletions": 66}, "files": [{"sha": "1a619388f611c5282553ee22f117ef9c469b0c66", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 132, "deletions": 66, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/2665b6434e6c851f6bffecf83e35db22ee6bf6bd/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2665b6434e6c851f6bffecf83e35db22ee6bf6bd/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=2665b6434e6c851f6bffecf83e35db22ee6bf6bd", "patch": "@@ -11,20 +11,24 @@\n /// (without being so rigorous).\n ///\n /// The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n-/// are trying to compute a predicate `U(P, p_{m + 1})` where `P` is a list of patterns\n-/// of length `m` for a compound (product) type with `n` components (we refer to this as\n-/// a matrix). `U(P, p_{m + 1})` represents whether, given an existing list of patterns\n-/// `p_1 ..= p_m`, adding a new pattern will be \"useful\" (that is, cover previously-\n+/// are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n+/// a matrix). `U(P, p)` represents whether, given an existing list of patterns\n+/// `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n /// uncovered values of the type).\n ///\n /// If we have this predicate, then we can easily compute both exhaustiveness of an\n /// entire set of patterns and the individual usefulness of each one.\n /// (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n /// match doesn't increase the number of values we're matching)\n-/// (b) a pattern `p_i` is not useful if `U(P[0..=(i-1), p_i)` is false (i.e., adding a\n+/// (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n /// pattern to those that have come before it doesn't increase the number of values\n /// we're matching).\n ///\n+/// During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n+/// but rather partially-deconstructed patterns in the form of a list of patterns. The paper\n+/// calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n+/// new pattern `p`.\n+///\n /// For example, say we have the following:\n /// ```\n ///     // x: (Option<bool>, Result<()>)\n@@ -34,93 +38,155 @@\n ///         (None, Err(_)) => {}\n ///     }\n /// ```\n-/// Here, the matrix `P` is 3 x 2 (rows x columns).\n+/// Here, the matrix `P` starts as:\n /// [\n-///     [Some(true), _],\n-///     [None, Err(())],\n-///     [None, Err(_)],\n+///     [(Some(true), _)],\n+///     [(None, Err(()))],\n+///     [(None, Err(_))],\n /// ]\n /// We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n-/// `[Some(false), _]`, for instance). In addition, row 3 is not useful, because\n+/// `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n /// all the values it covers are already covered by row 2.\n ///\n-/// To compute `U`, we must have two other concepts.\n-///     1. `S(c, P)` is a \"specialized matrix\", where `c` is a constructor (like `Some` or\n-///        `None`). You can think of it as filtering `P` to just the rows whose *first* pattern\n-///        can cover `c` (and expanding OR-patterns into distinct patterns), and then expanding\n-///        the constructor into all of its components.\n-///        The specialization of a row vector is computed by `specialize`.\n+/// A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n+/// the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n+/// To match the paper, the top of the stack is at the beginning / on the left.\n+///\n+/// There are two important operations on pattern-stacks necessary to understand the algorithm:\n+///     1. We can pop a given constructor off the top of a stack. This operation is called\n+///        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n+///        `None`) and `p` a pattern-stack.\n+///        If the pattern on top of the stack can cover `c`, this removes the constructor and\n+///        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n+///        Otherwise the pattern-stack is discarded.\n+///        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n+///        discards the others.\n+///\n+///        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n+///        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n+///        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n+///        nothing back.\n ///\n-///        It is computed as follows. For each row `p_i` of P, we have four cases:\n-///             1.1. `p_(i,1) = c(r_1, .., r_a)`. Then `S(c, P)` has a corresponding row:\n-///                     r_1, .., r_a, p_(i,2), .., p_(i,n)\n-///             1.2. `p_(i,1) = c'(r_1, .., r_a')` where `c \u2260 c'`. Then `S(c, P)` has no\n-///                  corresponding row.\n-///             1.3. `p_(i,1) = _`. Then `S(c, P)` has a corresponding row:\n-///                     _, .., _, p_(i,2), .., p_(i,n)\n-///             1.4. `p_(i,1) = r_1 | r_2`. Then `S(c, P)` has corresponding rows inlined from:\n-///                     S(c, (r_1, p_(i,2), .., p_(i,n)))\n-///                     S(c, (r_2, p_(i,2), .., p_(i,n)))\n+///        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n+///        on top of the stack, and we have four cases:\n+///             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+///                  push onto the stack the arguments of this constructor, and return the result:\n+///                     r_1, .., r_a, p_2, .., p_n\n+///             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+///                  return nothing.\n+///             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n+///                  arguments (its arity), and return the resulting stack:\n+///                     _, .., _, p_2, .., p_n\n+///             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+///                  stack:\n+///                     S(c, (r_1, p_2, .., p_n))\n+///                     S(c, (r_2, p_2, .., p_n))\n ///\n-///     2. `D(P)` is a \"default matrix\". This is used when we know there are missing\n-///        constructor cases, but there might be existing wildcard patterns, so to check the\n-///        usefulness of the matrix, we have to check all its *other* components.\n-///        The default matrix is computed inline in `is_useful`.\n+///     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n+///        a pattern-stack.\n+///        This is used when we know there are missing constructor cases, but there might be\n+///        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n+///        all its *other* components.\n ///\n-///         It is computed as follows. For each row `p_i` of P, we have three cases:\n-///             1.1. `p_(i,1) = c(r_1, .., r_a)`. Then `D(P)` has no corresponding row.\n-///             1.2. `p_(i,1) = _`. Then `D(P)` has a corresponding row:\n-///                     p_(i,2), .., p_(i,n)\n-///             1.3. `p_(i,1) = r_1 | r_2`. Then `D(P)` has corresponding rows inlined from:\n-///                     D((r_1, p_(i,2), .., p_(i,n)))\n-///                     D((r_2, p_(i,2), .., p_(i,n)))\n+///        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n+///        and we have three cases:\n+///             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+///             1.2. `p_1 = _`. We return the rest of the stack:\n+///                     p_2, .., p_n\n+///             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+///               stack.\n+///                     D((r_1, p_2, .., p_n))\n+///                     D((r_2, p_2, .., p_n))\n+///\n+///     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n+///     exhaustive integer matching rules, so they're written here for posterity.\n+///\n+/// Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n+/// working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n+/// the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n ///\n-///     Note that the OR-patterns are not always used directly in Rust, but are used to derive\n-///     the exhaustive integer matching rules, so they're written here for posterity.\n ///\n /// The algorithm for computing `U`\n /// -------------------------------\n /// The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n /// That means we're going to check the components from left-to-right, so the algorithm\n-/// operates principally on the first component of the matrix and new pattern `p_{m + 1}`.\n+/// operates principally on the first component of the matrix and new pattern-stack `p`.\n /// This algorithm is realised in the `is_useful` function.\n ///\n /// Base case. (`n = 0`, i.e., an empty tuple pattern)\n ///     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n-///       then `U(P, p_{m + 1})` is false.\n-///     - Otherwise, `P` must be empty, so `U(P, p_{m + 1})` is true.\n+///       then `U(P, p)` is false.\n+///     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n ///\n /// Inductive step. (`n > 0`, i.e., whether there's at least one column\n ///                  [which may then be expanded into further columns later])\n-///     We're going to match on the new pattern, `p_{m + 1}`.\n-///         - If `p_{m + 1} == c(r_1, .., r_a)`, then we have a constructor pattern.\n-///           Thus, the usefulness of `p_{m + 1}` can be reduced to whether it is useful when\n-///           we ignore all the patterns in `P` that involve other constructors. This is where\n-///           `S(c, P)` comes in:\n-///           `U(P, p_{m + 1}) := U(S(c, P), S(c, p_{m + 1}))`\n+///     We're going to match on the top of the new pattern-stack, `p_1`.\n+///         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n+///           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n+///           we ignore all the patterns in the first column of `P` that involve other constructors.\n+///           This is where `S(c, P)` comes in:\n+///           `U(P, p) := U(S(c, P), S(c, p))`\n ///           This special case is handled in `is_useful_specialized`.\n-///         - If `p_{m + 1} == _`, then we have two more cases:\n-///             + All the constructors of the first component of the type exist within\n-///               all the rows (after having expanded OR-patterns). In this case:\n-///               `U(P, p_{m + 1}) := \u2228(k \u03f5 constructors) U(S(k, P), S(k, p_{m + 1}))`\n-///               I.e., the pattern `p_{m + 1}` is only useful when all the constructors are\n-///               present *if* its later components are useful for the respective constructors\n-///               covered by `p_{m + 1}` (usually a single constructor, but all in the case of `_`).\n-///             + Some constructors are not present in the existing rows (after having expanded\n-///               OR-patterns). However, there might be wildcard patterns (`_`) present. Thus, we\n-///               are only really concerned with the other patterns leading with wildcards. This is\n-///               where `D` comes in:\n-///               `U(P, p_{m + 1}) := U(D(P), p_({m + 1},2), ..,  p_({m + 1},n))`\n-///         - If `p_{m + 1} == r_1 | r_2`, then the usefulness depends on each separately:\n-///           `U(P, p_{m + 1}) := U(P, (r_1, p_({m + 1},2), .., p_({m + 1},n)))\n-///                            || U(P, (r_2, p_({m + 1},2), .., p_({m + 1},n)))`\n+///\n+///           For example, if `P` is:\n+///           [\n+///               [Some(true), _],\n+///               [None, 0],\n+///           ]\n+///           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n+///           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n+///           arguments of `Some` to know whether some new value is covered. So we compute\n+///           `U([[true, _]], [false, 0])`.\n+///\n+///         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n+///               component of the rows of `P`:\n+///             + If there are some constructors that aren't present, then we might think that the\n+///               wildcard `_` is useful, since it covers those constructors that weren't covered\n+///               before.\n+///               That's almost correct, but only works if there were no wildcards in those first\n+///               components. So we need to check that `p` is useful with respect to the rows that\n+///               start with a wildcard, if there are any. This is where `D` comes in:\n+///               `U(P, p) := U(D(P), D(p))`\n+///\n+///               For example, if `P` is:\n+///               [\n+///                   [_, true, _],\n+///                   [None, false, 1],\n+///               ]\n+///               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n+///               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n+///               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+///\n+///             + Otherwise, all possible constructors (for the relevant type) are present. In this\n+///               case we must check whether the wildcard pattern covers any unmatched value. For\n+///               that, we can think of the `_` pattern as a big OR-pattern that covers all\n+///               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n+///               example. The wildcard pattern is useful in this case if it is useful when\n+///               specialized to one of the possible constructors. So we compute:\n+///               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+///\n+///               For example, if `P` is:\n+///               [\n+///                   [Some(true), _],\n+///                   [None, false],\n+///               ]\n+///               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n+///               components of `P`. We will therefore try popping both constructors in turn: we\n+///               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n+///               [false]) for the `None` constructor. The first case returns true, so we know that\n+///               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n+///               before.\n+///\n+///         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n+///           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n+///                    || U(P, (r_2, p_2, .., p_n))`\n ///\n /// Modifications to the algorithm\n /// ------------------------------\n /// The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n /// example uninhabited types and variable-length slice patterns. These are drawn attention to\n-/// throughout the code below. I'll make a quick note here about how exhaustive integer matching\n-/// is accounted for, though.\n+/// throughout the code below. I'll make a quick note here about how exhaustive integer matching is\n+/// accounted for, though.\n ///\n /// Exhaustive integer matching\n /// ---------------------------\n@@ -150,7 +216,7 @@\n ///       invalid, because we want a disjunction over every *integer* in each range, not just a\n ///       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n ///       to form equivalence classes of subranges of the constructor range for which the behaviour\n-///       of the matrix `P` and new pattern `p_{m + 1}` are the same. This is described in more\n+///       of the matrix `P` and new pattern `p` are the same. This is described in more\n ///       detail in `split_grouped_constructors`.\n ///     + If some constructors are missing from the matrix, it turns out we don't need to do\n ///       anything special (because we know none of the integers are actually wildcards: i.e., we"}]}