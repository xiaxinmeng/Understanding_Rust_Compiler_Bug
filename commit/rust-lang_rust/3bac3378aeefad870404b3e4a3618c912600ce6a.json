{"sha": "3bac3378aeefad870404b3e4a3618c912600ce6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYWMzMzc4YWVlZmFkODcwNDA0YjNlNGEzNjE4YzkxMjYwMGNlNmE=", "commit": {"author": {"name": "Jesse Ruderman", "email": "jruderman@gmail.com", "date": "2011-09-24T06:23:04Z"}, "committer": {"name": "Jesse Ruderman", "email": "jruderman@gmail.com", "date": "2011-09-24T06:23:04Z"}, "message": "Fuzzer: use different exclusions when testing pretty-printer than when testing compiler", "tree": {"sha": "a5aa2d0ef001f830acc42d39039455bc8eb0632b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5aa2d0ef001f830acc42d39039455bc8eb0632b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bac3378aeefad870404b3e4a3618c912600ce6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bac3378aeefad870404b3e4a3618c912600ce6a", "html_url": "https://github.com/rust-lang/rust/commit/3bac3378aeefad870404b3e4a3618c912600ce6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bac3378aeefad870404b3e4a3618c912600ce6a/comments", "author": {"login": "jruderman", "id": 692547, "node_id": "MDQ6VXNlcjY5MjU0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/692547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jruderman", "html_url": "https://github.com/jruderman", "followers_url": "https://api.github.com/users/jruderman/followers", "following_url": "https://api.github.com/users/jruderman/following{/other_user}", "gists_url": "https://api.github.com/users/jruderman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jruderman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jruderman/subscriptions", "organizations_url": "https://api.github.com/users/jruderman/orgs", "repos_url": "https://api.github.com/users/jruderman/repos", "events_url": "https://api.github.com/users/jruderman/events{/privacy}", "received_events_url": "https://api.github.com/users/jruderman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jruderman", "id": 692547, "node_id": "MDQ6VXNlcjY5MjU0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/692547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jruderman", "html_url": "https://github.com/jruderman", "followers_url": "https://api.github.com/users/jruderman/followers", "following_url": "https://api.github.com/users/jruderman/following{/other_user}", "gists_url": "https://api.github.com/users/jruderman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jruderman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jruderman/subscriptions", "organizations_url": "https://api.github.com/users/jruderman/orgs", "repos_url": "https://api.github.com/users/jruderman/repos", "events_url": "https://api.github.com/users/jruderman/events{/privacy}", "received_events_url": "https://api.github.com/users/jruderman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a7a2943ddd1e7e91f625d6459c3e0636ca129cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a7a2943ddd1e7e91f625d6459c3e0636ca129cb", "html_url": "https://github.com/rust-lang/rust/commit/3a7a2943ddd1e7e91f625d6459c3e0636ca129cb"}], "stats": {"total": 278, "additions": 157, "deletions": 121}, "files": [{"sha": "57cf9918a6faba076d4648657eb3874bba015d10", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 157, "deletions": 121, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/3bac3378aeefad870404b3e4a3618c912600ce6a/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bac3378aeefad870404b3e4a3618c912600ce6a/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=3bac3378aeefad870404b3e4a3618c912600ce6a", "patch": "@@ -9,28 +9,25 @@ import rustc::syntax::{ast, ast_util, fold, visit, codemap};\n import rustc::syntax::parse::parser;\n import rustc::syntax::print::pprust;\n \n+tag test_mode { tm_converge; tm_run; }\n+type context = { mode: test_mode }; // + rng\n+\n fn write_file(filename: str, content: str) {\n     io::file_writer(filename, [io::create, io::truncate]).write_str(content);\n     // Work around https://github.com/graydon/rust/issues/726\n     std::run::run_program(\"chmod\", [\"644\", filename]);\n }\n \n-fn file_contains(filename: str, needle: str) -> bool {\n-    let contents = io::read_whole_file_str(filename);\n-    ret str::find(contents, needle) != -1;\n-}\n-\n fn contains(haystack: str, needle: str) -> bool {\n     str::find(haystack, needle) != -1\n }\n \n fn find_rust_files(&files: [str], path: str) {\n     if str::ends_with(path, \".rs\") {\n-        if file_contains(path, \"xfail-test\") {\n-            //log_err \"Skipping \" + path + \" because it is marked as xfail-test\";\n-        } else { files += [path]; }\n+        files += [path];\n     } else if fs::file_is_dir(path)\n-        && str::find(path, \"compile-fail\") == -1 {\n+        && !contains(path, \"compile-fail\")\n+        && !contains(path, \"build\") {\n         for p in fs::list_dir(path) {\n             find_rust_files(files, p);\n         }\n@@ -56,92 +53,108 @@ fn common_exprs() -> [ast::expr] {\n      dse(ast::expr_lit(@dsl(ast::lit_nil))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n-     dse(ast::expr_unary(ast::box(ast::imm), @dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n+     dse(ast::expr_unary(ast::box(ast::imm), @dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n+     dse(ast::expr_unary(ast::uniq(ast::imm), @dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n     ]\n }\n \n-fn safe_to_steal_expr(e: @ast::expr) -> bool {\n-    alt e.node {\n-      /*\n-      // For compiling (rather than pretty-printing)\n-      // combination of https://github.com/graydon/rust/issues/924 with unwind hang?\n-      ast::expr_ret(option::none.) { false }\n-      */\n+pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n+    safe_to_use_expr(*e, tm)\n+}\n \n-      // If the fuzzer moves a block-ending-in-semicolon into callee position,\n-      // the pretty-printer can't preserve this even by parenthesizing!!\n-      // See email to marijn.\n-      ast::expr_if(_, _, _) { false }\n-      ast::expr_block(_) { false }\n-      ast::expr_alt(_, _) { false }\n-      ast::expr_for(_, _, _) { false }\n-      ast::expr_for_each(_, _, _) { false }\n-      ast::expr_while(_, _) { false }\n+pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n+    alt tm {\n+      tm_converge. {\n+        alt e.node {\n+          // If the fuzzer moves a block-ending-in-semicolon into callee position,\n+          // the pretty-printer can't preserve this even by parenthesizing!!\n+          // See email to marijn.\n+          ast::expr_if(_, _, _) { false }\n+          ast::expr_if_check(_, _, _) { false }\n+          ast::expr_block(_) { false }\n+          ast::expr_alt(_, _) { false }\n+          ast::expr_for(_, _, _) { false }\n+          ast::expr_for_each(_, _, _) { false }\n+          ast::expr_while(_, _) { false }\n \n-      // https://github.com/graydon/rust/issues/929\n-      ast::expr_cast(_, _) { false }\n-      ast::expr_assert(_) { false }\n-      ast::expr_binary(_, _, _) { false }\n-      ast::expr_assign(_, _) { false }\n-      ast::expr_assign_op(_, _, _) { false }\n+          // https://github.com/graydon/rust/issues/955\n+          ast::expr_do_while(_, _) { false }\n \n-      ast::expr_fail(option::none.) { false }\n-      ast::expr_ret(option::none.) { false }\n-      ast::expr_put(option::none.) { false }\n+          // https://github.com/graydon/rust/issues/929\n+          ast::expr_cast(_, _) { false }\n+          ast::expr_assert(_) { false }\n+          ast::expr_binary(_, _, _) { false }\n+          ast::expr_assign(_, _) { false }\n+          ast::expr_assign_op(_, _, _) { false }\n \n-      // https://github.com/graydon/rust/issues/927\n-      //ast::expr_assert(_) { false }\n-      ast::expr_check(_, _) { false }\n+          ast::expr_fail(option::none.) { false }\n+          ast::expr_ret(option::none.) { false }\n+          ast::expr_put(option::none.) { false }\n \n-      // https://github.com/graydon/rust/issues/928\n-      //ast::expr_cast(_, _) { false }\n+          // https://github.com/graydon/rust/issues/953\n+          ast::expr_fail(option::some(_)) { false }\n \n-      _ { true }\n+          // https://github.com/graydon/rust/issues/927\n+          //ast::expr_assert(_) { false }\n+          ast::expr_check(_, _) { false }\n+\n+          // https://github.com/graydon/rust/issues/928\n+          //ast::expr_cast(_, _) { false }\n+\n+          _ { true }\n+        }\n+      }\n+      tm_run. { true }\n     }\n }\n \n-fn safe_to_steal_ty(t: @ast::ty) -> bool {\n-    // Same restrictions\n-    safe_to_replace_ty(t.node)\n+fn safe_to_steal_ty(t: @ast::ty, tm: test_mode) -> bool {\n+    alt t.node {\n+        // https://github.com/graydon/rust/issues/971\n+        ast::ty_constr(_, _) { false }\n+\n+        // Other restrictions happen to be the same.\n+        _ { safe_to_replace_ty(t.node, tm) }\n+    }\n }\n \n // Not type-parameterized: https://github.com/graydon/rust/issues/898\n-fn stash_expr_if(c: fn(@ast::expr)->bool, es: @mutable [ast::expr], e: @ast::expr) {\n-    if c(e) {\n+fn stash_expr_if(c: fn(@ast::expr, test_mode)->bool, es: @mutable [ast::expr], e: @ast::expr, tm: test_mode) {\n+    if c(e, tm) {\n         *es += [*e];\n     } else {/* now my indices are wrong :( */ }\n }\n \n-fn stash_ty_if(c: fn(@ast::ty)->bool, es: @mutable [ast::ty], e: @ast::ty) {\n-    if c(e) {\n+fn stash_ty_if(c: fn(@ast::ty, test_mode)->bool, es: @mutable [ast::ty], e: @ast::ty, tm: test_mode) {\n+    if c(e, tm) {\n         *es += [*e];\n     } else {/* now my indices are wrong :( */ }\n }\n \n type stolen_stuff = {exprs: [ast::expr], tys: [ast::ty]};\n \n-fn steal(crate: ast::crate) -> stolen_stuff {\n+fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n     let exprs = @mutable [];\n     let tys = @mutable [];\n     let v = visit::mk_simple_visitor(@{\n-        visit_expr: bind stash_expr_if(safe_to_steal_expr, exprs, _),\n-        visit_ty: bind stash_ty_if(safe_to_steal_ty, tys, _)\n+        visit_expr: bind stash_expr_if(safe_to_steal_expr, exprs, _, tm),\n+        visit_ty: bind stash_ty_if(safe_to_steal_ty, tys, _, tm)\n         with *visit::default_simple_visitor()\n     });\n     visit::visit_crate(crate, (), v);\n     {exprs: *exprs, tys: *tys}\n }\n \n // https://github.com/graydon/rust/issues/652\n-fn safe_to_replace_expr(e: ast::expr_) -> bool {\n+fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n     alt e {\n       ast::expr_if(_, _, _) { false }\n       ast::expr_block(_) { false }\n       _ { true }\n     }\n }\n \n-fn safe_to_replace_ty(t: ast::ty_) -> bool {\n+fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n     alt t {\n       ast::ty_infer. { false } // always implicit, always top level\n       ast::ty_bot. { false }   // in source, can only appear as the out type of a function\n@@ -151,14 +164,14 @@ fn safe_to_replace_ty(t: ast::ty_) -> bool {\n }\n \n // Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-fn replace_expr_in_crate(crate: ast::crate, i: uint, newexpr: ast::expr) ->\n+fn replace_expr_in_crate(crate: ast::crate, i: uint, newexpr: ast::expr, tm: test_mode) ->\n    ast::crate {\n     let j: @mutable uint = @mutable 0u;\n     fn fold_expr_rep(j_: @mutable uint, i_: uint, newexpr_: ast::expr_,\n-                     original: ast::expr_, fld: fold::ast_fold) ->\n+                     original: ast::expr_, fld: fold::ast_fold, tm_: test_mode) ->\n        ast::expr_ {\n         *j_ += 1u;\n-        if i_ + 1u == *j_ && safe_to_replace_expr(original) {\n+        if i_ + 1u == *j_ && safe_to_replace_expr(original, tm_) {\n             newexpr_\n         } else {\n             alt(original) {\n@@ -168,7 +181,7 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint, newexpr: ast::expr) ->\n         }\n     }\n     let afp =\n-        {fold_expr: bind fold_expr_rep(j, i, newexpr.node, _, _)\n+        {fold_expr: bind fold_expr_rep(j, i, newexpr.node, _, _, tm)\n             with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n@@ -177,19 +190,19 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint, newexpr: ast::expr) ->\n \n \n // Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty) ->\n+fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty, tm: test_mode) ->\n    ast::crate {\n     let j: @mutable uint = @mutable 0u;\n     fn fold_ty_rep(j_: @mutable uint, i_: uint, newty_: ast::ty_,\n-                     original: ast::ty_, fld: fold::ast_fold) ->\n+                     original: ast::ty_, fld: fold::ast_fold, tm_: test_mode) ->\n        ast::ty_ {\n         *j_ += 1u;\n-        if i_ + 1u == *j_ && safe_to_replace_ty(original) {\n+        if i_ + 1u == *j_ && safe_to_replace_ty(original, tm_) {\n             newty_\n         } else { fold::noop_fold_ty(original, fld) }\n     }\n     let afp =\n-        {fold_ty: bind fold_ty_rep(j, i, newty.node, _, _)\n+        {fold_ty: bind fold_ty_rep(j, i, newty.node, _, _, tm)\n             with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n@@ -210,10 +223,11 @@ fn as_str(f: fn(io::writer)) -> str {\n }\n \n fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n-                         filename: str) {\n-    let stolen = steal(crate);\n-    check_variants_T(crate, codemap, filename, \"expr\", /*common_exprs() +*/ stolen.exprs, pprust::expr_to_str, replace_expr_in_crate);\n-    check_variants_T(crate, codemap, filename, \"ty\", stolen.tys, pprust::ty_to_str, replace_ty_in_crate);\n+                         filename: str, cx: context) {\n+    let stolen = steal(crate, cx.mode);\n+    let extra_exprs = vec::filter(bind safe_to_use_expr(_, cx.mode), common_exprs());\n+    check_variants_T(crate, codemap, filename, \"expr\", extra_exprs + stolen.exprs, pprust::expr_to_str, replace_expr_in_crate, cx);\n+    check_variants_T(crate, codemap, filename, \"ty\", stolen.tys, pprust::ty_to_str, replace_ty_in_crate, cx);\n }\n \n fn check_variants_T<T>(\n@@ -223,7 +237,8 @@ fn check_variants_T<T>(\n   thing_label: str,\n   things: [T],\n   stringifier: fn(@T) -> str,\n-  replacer: fn(ast::crate, uint, T) -> ast::crate\n+  replacer: fn(ast::crate, uint, T, test_mode) -> ast::crate,\n+  cx: context\n   ) {\n     log_err #fmt(\"%s contains %u %s objects\", filename, vec::len(things), thing_label);\n \n@@ -234,18 +249,24 @@ fn check_variants_T<T>(\n             log_err \"Replacing... #\" + uint::str(i);\n             for each j: uint in under(uint::min(L, 30u)) {\n                 log_err \"With... \" + stringifier(@things[j]);\n-                let crate2 = @replacer(crate, i, things[j]);\n+                let crate2 = @replacer(crate, i, things[j], cx.mode);\n                 // It would be best to test the *crate* for stability, but testing the\n                 // string for stability is easier and ok for now.\n                 let str3 =\n                     as_str(bind pprust::print_crate(codemap, crate2,\n                                                     filename,\n                                                     io::string_reader(\"\"), _,\n                                                     pprust::no_ann()));\n-                check_roundtrip_convergence(str3, 1u);\n-                //let file_label = #fmt(\"rusttmp/%s_%s_%u_%u\", last_part(filename), thing_label, i, j);\n-                //let safe_to_run = !(content_is_dangerous_to_run(str3) || has_raw_pointers(*crate2));\n-                //check_whole_compiler(str3, file_label, safe_to_run);\n+                alt cx.mode {\n+                  tm_converge. {\n+                    check_roundtrip_convergence(str3, 1u);\n+                  }\n+                  tm_run. {\n+                    let file_label = #fmt(\"rusttmp/%s_%s_%u_%u\", last_part(filename), thing_label, i, j);\n+                    let safe_to_run = !(content_is_dangerous_to_run(str3) || has_raw_pointers(*crate2));\n+                    check_whole_compiler(str3, file_label, safe_to_run);\n+                  }\n+                }\n             }\n         }\n     }\n@@ -310,18 +331,20 @@ fn check_running(exe_filename: str) -> happiness {\n         known_bug(\"https://github.com/graydon/rust/issues/32 / https://github.com/graydon/rust/issues/445\")\n     } else if contains(comb, \"Assertion failed:\") {\n         failed(\"C++ assertion failure\")\n+    } else if contains(comb, \"leaked memory in rust main loop\") {\n+        // might also use exit code 134\n+        //failed(\"Leaked\")\n+        known_bug(\"https://github.com/graydon/rust/issues/910\")\n     } else if contains(comb, \"src/rt/\") {\n         failed(\"Mentioned src/rt/\")\n     } else if contains(comb, \"malloc\") {\n         failed(\"Mentioned malloc\")\n-    } else if contains(comb, \"leaked memory in rust main loop\") {\n-        failed(\"Leaked\") // might also use exit code 134\n     } else {\n         alt p.status {\n             0         { passed }\n             100       { cleanly_rejected(\"running: explicit fail\") }\n             101 | 247 { cleanly_rejected(\"running: timed out\") }\n-            245 | 246 { known_bug(\"https://github.com/graydon/rust/issues/32 ??\") }\n+            245 | 246 | 138 | 252 { known_bug(\"https://github.com/graydon/rust/issues/32 ??\") }\n             136 | 248 { known_bug(\"SIGFPE - https://github.com/graydon/rust/issues/944\") }\n             rc        { failed(\"Rust program ran but exited with status \" + int::str(rc)) }\n         }\n@@ -339,18 +362,14 @@ fn check_compiling(filename: str) -> happiness {\n \n     //log_err #fmt(\"Status: %d\", p.status);\n     if p.err != \"\" {\n-        if contains(p.err, \"May only branch on boolean predicates\") {\n-            known_bug(\"https://github.com/graydon/rust/issues/892 or https://github.com/graydon/rust/issues/943\")\n-        } else if contains(p.err, \"All operands to PHI node must be the same type as the PHI node!\") {\n-            known_bug(\"https://github.com/graydon/rust/issues/943\")\n-        } else if contains(p.err, \"(S->getType()->isPointerTy() && \\\"Invalid cast\\\")\") {\n-            known_bug(\"https://github.com/graydon/rust/issues/895\")\n-        } else if contains(p.err, \"Ptr must be a pointer to Val type\") {\n-            known_bug(\"https://github.com/graydon/rust/issues/897 or https://github.com/graydon/rust/issues/949\")\n+        if contains(p.err, \"Ptr must be a pointer to Val type\") {\n+            known_bug(\"https://github.com/graydon/rust/issues/897\")\n         } else if contains(p.err, \"(castIsValid(op, S, Ty) && \\\"Invalid cast!\\\"), function Create\") {\n             known_bug(\"https://github.com/graydon/rust/issues/901\")\n-        } else if contains(p.err, \"Invoking a function with a bad signature!\") {\n-            known_bug(\"https://github.com/graydon/rust/issues/946\")\n+        } else if contains(p.err, \"cast() argument of incompatible type!\") {\n+            known_bug(\"https://github.com/graydon/rust/issues/973\")\n+        } else if contains(p.err, \"cast<Ty>() argument of incompatible type!\") {\n+            known_bug(\"https://github.com/graydon/rust/issues/973\")\n         } else {\n             log_err \"Stderr: \" + p.err;\n             failed(\"Unfamiliar error message\")\n@@ -360,12 +379,10 @@ fn check_compiling(filename: str) -> happiness {\n     } else if contains(p.out, \"Out of stack space, sorry\") {\n         known_bug(\"Recursive types - https://github.com/graydon/rust/issues/742\")\n     } else if contains(p.out, \"Assertion !cx.terminated failed\") {\n-        known_bug(\"https://github.com/graydon/rust/issues/893 or https://github.com/graydon/rust/issues/894\")\n+        known_bug(\"https://github.com/graydon/rust/issues/893\")\n //  } else if contains(p.out, \"upcall fail 'non-exhaustive match failure', ../src/comp/middle/trans.rs\") {\n     } else if contains(p.out, \"trans_rec expected a rec but found _|_\") {\n         known_bug(\"https://github.com/graydon/rust/issues/924\")\n-    } else if contains(p.out, \"Assertion failed: (S->getType()->isPointerTy() && \\\"Invalid cast\\\")\") {\n-        known_bug(\"https://github.com/graydon/rust/issues/935\")\n     } else if contains(p.out, \"Assertion\") && contains(p.out, \"failed\") {\n         log_err \"Stdout: \" + p.out;\n         failed(\"Looks like an llvm assertion failure\")\n@@ -384,6 +401,9 @@ fn check_compiling(filename: str) -> happiness {\n         log_err \"Stdout: \" + p.out;\n         failed(\"internal compiler error\")\n \n+    } else if contains(p.out, \"Predicate type_is_unique_box(bcx, uniq_ty) failed\") {\n+        known_bug(\"https://github.com/graydon/rust/issues/968\")\n+\n     } else if contains(p.out, \"error:\") {\n         cleanly_rejected(\"rejected with span_error\")\n     } else {\n@@ -397,7 +417,7 @@ fn check_compiling(filename: str) -> happiness {\n fn parse_and_print(code: str) -> str {\n     let filename = \"tmp.rs\";\n     let sess = @{cm: codemap::new_codemap(), mutable next_id: 0};\n-    //write_file(filename, code);\n+    write_file(filename, code);\n     let crate = parser::parse_crate_from_source_str(\n         filename, code, [], sess);\n     ret as_str(bind pprust::print_crate(sess.cm, crate,\n@@ -423,40 +443,46 @@ fn has_raw_pointers(c: ast::crate) -> bool {\n \n fn content_is_dangerous_to_run(code: str) -> bool {\n     let dangerous_patterns =\n-        [\"import\", // espeically fs, run\n+        [\"xfail-test\",\n+         \"-> !\",    // https://github.com/graydon/rust/issues/897\n+         \"import\",  // espeically fs, run\n          \"native\",\n          \"unsafe\",\n-         \"log\"]; // python --> rust pipe deadlock?\n+         \"log\"];    // python --> rust pipe deadlock?\n \n     for p: str in dangerous_patterns { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n-fn content_is_dangerous_to_modify(code: str) -> bool {\n+fn content_is_dangerous_to_compile(code: str) -> bool {\n     let dangerous_patterns =\n-        [\"#macro\", // not safe to steal things inside of it, because they have a special syntax\n-         \"#\",      // strange representation of the arguments to #fmt, for example\n-         \"tag\",    // typeck hang: https://github.com/graydon/rust/issues/742 (from dup #900)\n-         \"with\",   // tstate hang: https://github.com/graydon/rust/issues/948\n-         \" be \"];  // don't want to replace its child with a non-call: \"Non-call expression in tail call\"\n+        [\"xfail-test\",\n+         \"-> !\",    // https://github.com/graydon/rust/issues/897\n+         \"tag\",     // typeck hang with ty variants:   https://github.com/graydon/rust/issues/742 (from dup #900)\n+         \"with\"     // tstate hang with expr variants: https://github.com/graydon/rust/issues/948\n+         ];\n \n     for p: str in dangerous_patterns { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n-fn content_is_confusing(code: str) -> bool {\n+fn content_might_not_converge(code: str) -> bool {\n     let confusing_patterns =\n-        [\"self\",       // crazy rules enforced by parser rather than typechecker?\n-        \"spawn\",       // precedence issues?\n+        [\"xfail-test\",\n+         \"xfail-pretty\",\n+         \"self\",       // crazy rules enforced by parser rather than typechecker?\n+         \"spawn\",      // precedence issues?\n          \"bind\",       // precedence issues?\n+         \" be \",       // don't want to replace its child with a non-call: \"Non-call expression in tail call\"\n+         \"&!\",         // https://github.com/graydon/rust/issues/972\n          \"\\n\\n\\n\\n\\n\"  // https://github.com/graydon/rust/issues/850\n         ];\n \n     for p: str in confusing_patterns { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n-fn file_is_confusing(filename: str) -> bool {\n+fn file_might_not_converge(filename: str) -> bool {\n     let confusing_files = [\"expr-alt.rs\"]; // pretty-printing \"(a = b) = c\" vs \"a = b = c\" and wrapping\n \n     for f in confusing_files { if contains(filename, f) { ret true; } }\n@@ -472,7 +498,7 @@ fn check_roundtrip_convergence(code: str, maxIters: uint) {\n \n     while i < maxIters {\n         old = new;\n-        if content_is_confusing(old) { ret; }\n+        if content_might_not_converge(old) { ret; }\n         new = parse_and_print(old);\n         if old == new { break; }\n         i += 1u;\n@@ -494,9 +520,9 @@ fn check_roundtrip_convergence(code: str, maxIters: uint) {\n fn check_convergence(files: [str]) {\n     log_err #fmt[\"pp convergence tests: %u files\", vec::len(files)];\n     for file in files {\n-        if !file_is_confusing(file) {\n+        if !file_might_not_converge(file) {\n             let s = io::read_whole_file_str(file);\n-            if !content_is_confusing(s) {\n+            if !content_might_not_converge(s) {\n                 log_err #fmt[\"pp converge: %s\", file];\n                 // Change from 7u to 2u once https://github.com/graydon/rust/issues/850 is fixed\n                 check_roundtrip_convergence(s, 7u);\n@@ -505,25 +531,34 @@ fn check_convergence(files: [str]) {\n     }\n }\n \n-fn check_variants(files: [str]) {\n+fn check_variants(files: [str], cx: context) {\n     for file in files {\n-        if !file_is_confusing(file) {\n-            let s = io::read_whole_file_str(file);\n-            if content_is_dangerous_to_modify(s) || content_is_confusing(s) {\n-                cont;\n-            }\n-            log_err \"check_variants: \" + file;\n-            let sess = @{cm: codemap::new_codemap(), mutable next_id: 0};\n-            let crate =\n-                parser::parse_crate_from_source_str(\n-                    file,\n-                    s, [], sess);\n-            log_err as_str(bind pprust::print_crate(sess.cm, crate,\n-                                                    file,\n-                                                    io::string_reader(s), _,\n-                                                    pprust::no_ann()));\n-            check_variants_of_ast(*crate, sess.cm, file);\n+        if cx.mode == tm_converge && file_might_not_converge(file) {\n+            cont;\n+        }\n+\n+        let s = io::read_whole_file_str(file);\n+        if contains(s, \"#\") {\n+            cont; // Macros are confusing\n         }\n+        if cx.mode == tm_converge && content_might_not_converge(s) {\n+            cont;\n+        }\n+        if cx.mode == tm_run && content_is_dangerous_to_compile(s) {\n+            cont;\n+        }\n+\n+        log_err \"check_variants: \" + file;\n+        let sess = @{cm: codemap::new_codemap(), mutable next_id: 0};\n+        let crate =\n+            parser::parse_crate_from_source_str(\n+                file,\n+                s, [], sess);\n+        log_err as_str(bind pprust::print_crate(sess.cm, crate,\n+                                                file,\n+                                                io::string_reader(s), _,\n+                                                pprust::no_ann()));\n+        check_variants_of_ast(*crate, sess.cm, file, cx);\n     }\n }\n \n@@ -537,7 +572,8 @@ fn main(args: [str]) {\n \n     find_rust_files(files, root);\n     check_convergence(files);\n-    check_variants(files);\n+    check_variants(files, { mode: tm_converge });\n+    check_variants(files, { mode: tm_run });\n \n     log_err \"Fuzzer done\";\n }"}]}