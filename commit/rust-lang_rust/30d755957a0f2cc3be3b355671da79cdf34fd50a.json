{"sha": "30d755957a0f2cc3be3b355671da79cdf34fd50a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZDc1NTk1N2EwZjJjYzNiZTNiMzU1NjcxZGE3OWNkZjM0ZmQ1MGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-06-18T00:23:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-06-22T16:53:17Z"}, "message": "Expand the deriving(ToStr) implementation", "tree": {"sha": "97f8d207fe8e4c8b7a36610387694d1884b239d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97f8d207fe8e4c8b7a36610387694d1884b239d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30d755957a0f2cc3be3b355671da79cdf34fd50a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30d755957a0f2cc3be3b355671da79cdf34fd50a", "html_url": "https://github.com/rust-lang/rust/commit/30d755957a0f2cc3be3b355671da79cdf34fd50a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30d755957a0f2cc3be3b355671da79cdf34fd50a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc4560dc26498573516d833cb2333b54071070e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4560dc26498573516d833cb2333b54071070e3", "html_url": "https://github.com/rust-lang/rust/commit/dc4560dc26498573516d833cb2333b54071070e3"}], "stats": {"total": 147, "additions": 102, "deletions": 45}, "files": [{"sha": "4eedcb9a9520264f1a3e845d175bb8a21e2aa58c", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30d755957a0f2cc3be3b355671da79cdf34fd50a/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/30d755957a0f2cc3be3b355671da79cdf34fd50a/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=30d755957a0f2cc3be3b355671da79cdf34fd50a", "patch": "@@ -1562,7 +1562,9 @@ Supported traits for `deriving` are:\n * `IterBytes`, to iterate over the bytes in a data type.\n * `Rand`, to create a random instance of a data type.\n * `ToStr`, to convert to a string. For a type with this instance,\n-  `obj.to_str()` has the same output as `fmt!(\"%?\", obj)`.\n+  `obj.to_str()` has similar output as `fmt!(\"%?\", obj)`, but it differs in that\n+  each constituent field of the type must also implement `ToStr` and will have\n+  `field.to_str()` invoked to build up the result.\n \n # Statements and expressions\n "}, {"sha": "4cd168b12c0cc64b7fed149d503687e5b097e975", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/30d755957a0f2cc3be3b355671da79cdf34fd50a/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d755957a0f2cc3be3b355671da79cdf34fd50a/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=30d755957a0f2cc3be3b355671da79cdf34fd50a", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use ast;\n use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n@@ -40,16 +41,68 @@ pub fn expand_deriving_to_str(cx: @ExtCtxt,\n     trait_def.expand(cx, span, mitem, in_items)\n }\n \n-fn to_str_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n-    match substr.self_args {\n-        [self_obj] => {\n-            let self_addr = cx.expr_addr_of(span, self_obj);\n-            cx.expr_call_global(span,\n-                                ~[cx.ident_of(\"std\"),\n-                                  cx.ident_of(\"sys\"),\n-                                  cx.ident_of(\"log_str\")],\n-                                ~[self_addr])\n+// It used to be the case that this deriving implementation invoked\n+// std::sys::log_str, but this isn't sufficient because it doesn't invoke the\n+// to_str() method on each field. Hence we mirror the logic of the log_str()\n+// method, but with tweaks to call to_str() on sub-fields.\n+fn to_str_substructure(cx: @ExtCtxt, span: span,\n+                       substr: &Substructure) -> @expr {\n+    let to_str = cx.ident_of(\"to_str\");\n+\n+    let doit = |start: &str, end: @str, name: ast::ident,\n+                fields: &[(Option<ast::ident>, @expr, ~[@expr])]| {\n+        if fields.len() == 0 {\n+            cx.expr_str_uniq(span, cx.str_of(name))\n+        } else {\n+            let buf = cx.ident_of(\"buf\");\n+            let start = cx.str_of(name) + start;\n+            let init = cx.expr_str_uniq(span, start.to_managed());\n+            let mut stmts = ~[cx.stmt_let(span, true, buf, init)];\n+            let push_str = cx.ident_of(\"push_str\");\n+\n+            let push = |s: @expr| {\n+                let ebuf = cx.expr_ident(span, buf);\n+                let call = cx.expr_method_call(span, ebuf, push_str, ~[s]);\n+                stmts.push(cx.stmt_expr(call));\n+            };\n+\n+            for fields.iter().enumerate().advance |(i, &(name, e, _))| {\n+                if i > 0 {\n+                    push(cx.expr_str(span, @\", \"));\n+                }\n+                match name {\n+                    None => {}\n+                    Some(id) => {\n+                        let name = cx.str_of(id) + \": \";\n+                        push(cx.expr_str(span, name.to_managed()));\n+                    }\n+                }\n+                push(cx.expr_method_call(span, e, to_str, ~[]));\n+            }\n+            push(cx.expr_str(span, end));\n+\n+            cx.expr_blk(cx.blk(span, stmts, Some(cx.expr_ident(span, buf))))\n+        }\n+    };\n+\n+    return match *substr.fields {\n+        Struct(ref fields) => {\n+            if fields.len() == 0 || fields[0].n0_ref().is_none() {\n+                doit(\"(\", @\")\", substr.type_ident, *fields)\n+            } else {\n+                doit(\"{\", @\"}\", substr.type_ident, *fields)\n+            }\n         }\n-        _ => cx.span_bug(span, \"Invalid number of arguments in `deriving(ToStr)`\")\n-    }\n+\n+        EnumMatching(_, variant, ref fields) => {\n+            match variant.node.kind {\n+                ast::tuple_variant_kind(*) =>\n+                    doit(\"(\", @\")\", variant.node.name, *fields),\n+                ast::struct_variant_kind(*) =>\n+                    doit(\"{\", @\"}\", variant.node.name, *fields),\n+            }\n+        }\n+\n+        _ => cx.bug(\"expected Struct or EnumMatching in deriving(ToStr)\")\n+    };\n }"}, {"sha": "1fc1d6815f5f4612b3e34a304826cb29b6c4a956", "filename": "src/test/run-pass/deriving-to-str.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/30d755957a0f2cc3be3b355671da79cdf34fd50a/src%2Ftest%2Frun-pass%2Fderiving-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d755957a0f2cc3be3b355671da79cdf34fd50a/src%2Ftest%2Frun-pass%2Fderiving-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-to-str.rs?ref=30d755957a0f2cc3be3b355671da79cdf34fd50a", "patch": "@@ -1,5 +1,4 @@\n-// xfail-fast #6330\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,39 +8,42 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rand;\n+#[deriving(ToStr)]\n+enum A {}\n+#[deriving(ToStr)]\n+enum B { B1, B2, B3 }\n+#[deriving(ToStr)]\n+enum C { C1(int), C2(B), C3(~str) }\n+#[deriving(ToStr)]\n+enum D { D1{ a: int } }\n+#[deriving(ToStr)]\n+struct E;\n+#[deriving(ToStr)]\n+struct F(int);\n+#[deriving(ToStr)]\n+struct G(int, int);\n+#[deriving(ToStr)]\n+struct H { a: int }\n+#[deriving(ToStr)]\n+struct I { a: int, b: int }\n+#[deriving(ToStr)]\n+struct J(Custom);\n \n-#[deriving(Rand,ToStr)]\n-struct A;\n-\n-#[deriving(Rand,ToStr)]\n-struct B(int, int);\n-\n-#[deriving(Rand,ToStr)]\n-struct C {\n-    x: f64,\n-    y: (u8, u8)\n-}\n-\n-#[deriving(Rand,ToStr)]\n-enum D {\n-    D0,\n-    D1(uint),\n-    D2 { x: (), y: () }\n+struct Custom;\n+impl ToStr for Custom {\n+    fn to_str(&self) -> ~str { ~\"yay\" }\n }\n \n fn main() {\n-    macro_rules! t(\n-        ($ty:ty) => {{\n-            let x =rand::random::<$ty>();\n-            assert_eq!(x.to_str(), fmt!(\"%?\", x));\n-        }}\n-    );\n-\n-    for 20.times {\n-        t!(A);\n-        t!(B);\n-        t!(C);\n-        t!(D);\n-    }\n+    assert_eq!(B1.to_str(), ~\"B1\");\n+    assert_eq!(B2.to_str(), ~\"B2\");\n+    assert_eq!(C1(3).to_str(), ~\"C1(3)\");\n+    assert_eq!(C2(B2).to_str(), ~\"C2(B2)\");\n+    assert_eq!(D1{ a: 2 }.to_str(), ~\"D1{a: 2}\");\n+    assert_eq!(E.to_str(), ~\"E\");\n+    assert_eq!(F(3).to_str(), ~\"F(3)\");\n+    assert_eq!(G(3, 4).to_str(), ~\"G(3, 4)\");\n+    assert_eq!(G(3, 4).to_str(), ~\"G(3, 4)\");\n+    assert_eq!(I{ a: 2, b: 4 }.to_str(), ~\"I{a: 2, b: 4}\");\n+    assert_eq!(J(Custom).to_str(), ~\"J(yay)\");\n }"}]}