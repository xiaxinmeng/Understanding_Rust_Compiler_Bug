{"sha": "da13c508d83032ca13679e1e122e96d25ac23283", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMTNjNTA4ZDgzMDMyY2ExMzY3OWUxZTEyMmU5NmQyNWFjMjMyODM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-02T18:11:58Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-02T18:11:58Z"}, "message": "First pass on splitting stratum and opacity off of effects. WIP.", "tree": {"sha": "51c3d466dfedf3ad8e21b56c4769325561b3d650", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51c3d466dfedf3ad8e21b56c4769325561b3d650"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da13c508d83032ca13679e1e122e96d25ac23283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da13c508d83032ca13679e1e122e96d25ac23283", "html_url": "https://github.com/rust-lang/rust/commit/da13c508d83032ca13679e1e122e96d25ac23283", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da13c508d83032ca13679e1e122e96d25ac23283/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccd62969c1bb07f8931de0819979f060f5414bcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd62969c1bb07f8931de0819979f060f5414bcc", "html_url": "https://github.com/rust-lang/rust/commit/ccd62969c1bb07f8931de0819979f060f5414bcc"}], "stats": {"total": 503, "additions": 288, "deletions": 215}, "files": [{"sha": "fed7d9ec6fefd0d81343a251cb929674aff13b91", "filename": "doc/rust.texi", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -667,11 +667,12 @@ The keywords are:\n @tab @code{export}\n @tab @code{let}\n @tab @code{auto}\n-@item @code{io}\n-@tab @code{state}\n+@item @code{state}\n+@tab @code{gc}\n+@tab @code{abs}\n+@item @code{auth}\n+@tab @code{impure}\n @tab @code{unsafe}\n-@tab @code{auth}\n-@tab @code{with}\n @item @code{bind}\n @tab @code{type}\n @tab @code{true}\n@@ -705,8 +706,8 @@ The keywords are:\n @item @code{task}\n @tab @code{port}\n @tab @code{chan}\n-@tab @code{flush}\n @tab @code{spawn}\n+@tab @code{with}\n @item @code{if}\n @tab @code{else}\n @tab @code{alt}\n@@ -1473,7 +1474,6 @@ operating-system processes.\n @cindex Message passing\n @cindex Send statement\n @cindex Receive statement\n-@cindex Flush statement\n \n With the exception of @emph{unsafe} constructs, Rust tasks are isolated from\n interfering with one another's memory directly. Instead of manipulating shared\n@@ -1515,11 +1515,7 @@ task. If too many messages are queued for transmission from a single sending\n task, without being received by a receiving task, the sending task may exceed\n its memory budget, which causes a run-time signal. To help control this\n possibility, a semi-synchronous send operation is possible, which blocks until\n-there is room in the existing queue and then executes an asynchronous send. A\n-full @code{flush} operation is also available, which blocks until a channel's\n-queue is @emph{empty}. A @code{flush} does @emph{not} guarantee that a message\n-has been @emph{received} by any particular recipient when the sending task is\n-unblocked. @xref{Ref.Stmt.Flush}.\n+there is room in the existing queue and then executes an asynchronous send.\n \n The asynchronous message-send operator is @code{<+}. The semi-synchronous\n message-send operator is @code{<|}. @xref{Ref.Stmt.Send}. The message-receive\n@@ -2550,7 +2546,6 @@ actions.\n * Ref.Stmt.Copy::               Statement for copying a value.\n * Ref.Stmt.Spawn::              Statements for creating new tasks.\n * Ref.Stmt.Send::               Statements for sending a value into a channel.\n-* Ref.Stmt.Flush::              Statement for flushing a channel queue.\n * Ref.Stmt.Recv::               Statement for receiving a value from a channel.\n * Ref.Stmt.Call::               Statement for calling a function.\n * Ref.Stmt.Bind::               Statement for binding arguments to functions.\n@@ -2933,24 +2928,6 @@ chan[str] c = @dots{};\n c <| \"hello, world\";\n @end example\n \n-@node       Ref.Stmt.Flush\n-@subsection Ref.Stmt.Flush\n-@c * Ref.Stmt.Flush::              Statement for flushing a channel queue.\n-@cindex Flush statement\n-@cindex Communication\n-\n-A @code{flush} statement takes a channel and blocks the flushing task until\n-the channel's queue has emptied. It can be used to implement a more precise\n-form of flow-control than with the send operators alone.\n-\n-An example of the @code{flush} statement:\n-@example\n-chan[str] c = @dots{};\n-c <| \"hello, world\";\n-flush c;\n-@end example\n-\n-\n @node       Ref.Stmt.Recv\n @subsection Ref.Stmt.Recv\n @c * Ref.Stmt.Recv::           Statement for receiving a value from a channel.\n@@ -3359,8 +3336,8 @@ statement following the @code{alt} when the case block completes.\n @cindex Multiplexing\n \n The simplest form of @code{alt} statement is the a @emph{communication}\n-@code{alt}. The cases of a communication @code{alt}'s arms are send, receive\n-and flush statements. @xref{Ref.Task.Comm}.\n+@code{alt}. The cases of a communication @code{alt}'s arms are send and\n+receive statements. @xref{Ref.Task.Comm}.\n \n To execute a communication @code{alt}, the runtime checks all of the ports and\n channels involved in the arms of the statement to see if any @code{case} can\n@@ -3679,3 +3656,11 @@ to the task's domain; if the queue grows too big, the task will fail.\n @printindex cp\n \n @bye\n+\n+@c Local Variables:\n+@c mode: texinfo\n+@c fill-column: 78;\n+@c indent-tabs-mode: nil\n+@c buffer-file-coding-system: utf-8-unix\n+@c compile-command: \"make -k 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+@c End:"}, {"sha": "b72c4935af56ebcc7e84fa5488db369ae36db3d4", "filename": "src/boot/fe/ast.ml", "status": "modified", "additions": 60, "deletions": 20, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Fast.ml", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Fast.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fast.ml?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -29,10 +29,20 @@ type slot_key =\n  *)\n \n type effect =\n-    PURE\n-  | IO\n-  | STATE\n-  | UNSAFE\n+    EFF_pure\n+  | EFF_impure\n+  | EFF_unsafe\n+;;\n+\n+type stratum =\n+    STRAT_value\n+  | STRAT_state\n+  | STRAT_gc\n+;;\n+\n+type opacity =\n+    OPA_transparent\n+  | OPA_abstract\n ;;\n \n type mutability =\n@@ -702,19 +712,56 @@ and fmt_effect\n     (effect:effect)\n     : unit =\n   match effect with\n-      PURE -> ()\n-    | IO -> fmt ff \"io\"\n-    | STATE -> fmt ff \"state\"\n-    | UNSAFE -> fmt ff \"unsafe\"\n+      EFF_pure -> ()\n+    | EFF_impure -> fmt ff \"impure\"\n+    | EFF_unsafe -> fmt ff \"unsafe\"\n+\n+and fmt_effect_qual\n+    (ff:Format.formatter)\n+    (e:effect)\n+    : unit =\n+  fmt_effect ff e;\n+  if e <> EFF_pure then fmt ff \" \";\n+\n+and fmt_stratum\n+    (ff:Format.formatter)\n+    (strat:stratum)\n+    : unit =\n+  match strat with\n+      STRAT_value -> ()\n+    | STRAT_state -> fmt ff \"state\"\n+    | STRAT_gc -> fmt ff \"gc\"\n+\n+and fmt_stratum_qual\n+    (ff:Format.formatter)\n+    (s:stratum)\n+    : unit =\n+  fmt_stratum ff s;\n+  if s <> STRAT_value then fmt ff \" \";\n+\n+and fmt_opacity\n+    (ff:Format.formatter)\n+    (opa:opacity)\n+    : unit =\n+  match opa with\n+      OPA_transparent -> ()\n+    | OPA_abstract -> fmt ff \"abs\"\n+\n+and fmt_opacity_qual\n+    (ff:Format.formatter)\n+    (op:opacity)\n+    : unit =\n+  fmt_opacity ff op;\n+  if op <> OPA_transparent then fmt ff \" \";\n+\n \n and fmt_ty_fn\n     (ff:Format.formatter)\n     (ident_and_params:(ident * ty_param array) option)\n     (tf:ty_fn)\n     : unit =\n   let (tsig, ta) = tf in\n-    fmt_effect ff ta.fn_effect;\n-    if ta.fn_effect <> PURE then fmt ff \" \";\n+    fmt_effect_qual ff ta.fn_effect;\n     fmt ff \"%s\" (if ta.fn_is_iter then \"iter\" else \"fn\");\n     begin\n       match ident_and_params with\n@@ -763,8 +810,7 @@ and fmt_ty (ff:Format.formatter) (t:ty) : unit =\n       fmt_ident_tys ff entries;\n       fmt ff \"@]\"\n \n-  | TY_param (i, e) -> (fmt_effect ff e;\n-                        if e <> PURE then fmt ff \" \";\n+  | TY_param (i, e) -> (fmt_effect_qual ff e;\n                         fmt ff \"<p#%d>\" i)\n   | TY_native oid -> fmt ff \"<native#%d>\" (int_of_opaque oid)\n   | TY_named n -> fmt_name ff n\n@@ -789,8 +835,7 @@ and fmt_ty (ff:Format.formatter) (t:ty) : unit =\n \n   | TY_obj (effect, fns) ->\n       fmt_obox ff;\n-      fmt_effect ff effect;\n-      if effect <> PURE then fmt ff \" \";\n+      fmt_effect_qual ff effect;\n       fmt ff \"obj \";\n       fmt_obr ff;\n       Hashtbl.iter\n@@ -1584,8 +1629,7 @@ and fmt_slice (ff:Format.formatter) (slice:slice) : unit =\n \n and fmt_decl_param (ff:Format.formatter) (param:ty_param) : unit =\n   let (ident, (i, e)) = param in\n-  fmt_effect ff e;\n-  if e <> PURE then fmt ff \" \";\n+  fmt_effect_qual ff e;\n   fmt_ident ff ident;\n   fmt ff \"=<p#%d>\" i\n \n@@ -1608,10 +1652,6 @@ and fmt_ident_and_params\n   fmt_ident ff id;\n   fmt_decl_params ff params\n \n-and fmt_effect_qual (ff:Format.formatter) (e:effect) : unit =\n-  fmt_effect ff e;\n-  if e <> PURE then fmt ff \" \";\n-\n and fmt_fn\n     (ff:Format.formatter)\n     (id:ident)"}, {"sha": "3ca4ded78a33275a0e35737cb43c1ba77fb186c0", "filename": "src/boot/fe/cexp.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Fcexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Fcexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fcexp.ml?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -181,7 +181,7 @@ and parse_cexp (ps:pstate) : cexp =\n                   fun (ident, item) ->\n                     htab_put items ident item\n                 end\n-                (Item.parse_mod_item_from_signature ps)\n+                (Item.parse_native_mod_item_from_signature ps)\n             in\n               ignore (bracketed_zero_or_more\n                         LBRACE RBRACE None get_item ps);"}, {"sha": "e8db9f3903275dce9cfbf5572e7324dba2b0cae6", "filename": "src/boot/fe/fuzz.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Ffuzz.ml", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Ffuzz.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Ffuzz.ml?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -104,7 +104,7 @@ let rec generate_mod_item (mis:mod_items) (cx:ctxt) : unit =\n     match Random.int 2 with\n         0 ->\n           let ty = generate_ty cx in\n-          let eff = PURE in\n+          let eff = Ast.EFF_pure in\n             decl (MOD_ITEM_type (eff, ty))\n       | _ ->\n           let mis' = Hashtbl.create 0 in"}, {"sha": "4c9bd556965679ff29765be41a65a8845812946e", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -154,8 +154,6 @@ and parse_stmts (ps:pstate) : Ast.stmt array =\n     if (Array.length arr) == 0 then\n       raise (err \"statement does nothing\" ps);\n     arr\n-        \n-    \n \n (*\n  * We have no way to parse a single Ast.stmt; any incoming syntactic statement\n@@ -605,7 +603,11 @@ and parse_stmts_including_none (ps:pstate) : Ast.stmt array =\n             expect ps SEMI;\n             spans ps stmts apos (Ast.STMT_join lval)\n \n-      | IO | STATE | UNSAFE | MOD | OBJ | TAG | TYPE | FN | USE | NATIVE ->\n+\n+       | STATE | GC\n+       | IMPURE | UNSAFE\n+       | ABS | NATIVE\n+       | MOD | OBJ | TAG | TYPE | FN | USE ->\n           let items = ctxt \"stmt: decl\" parse_mod_item ps in\n           let bpos = lexpos ps in\n             Array.map\n@@ -689,6 +691,8 @@ and parse_stmts_including_none (ps:pstate) : Ast.stmt array =\n \n and parse_ty_param (iref:int ref) (ps:pstate) : Ast.ty_param identified =\n   let apos = lexpos ps in\n+  let _ = Pexp.parse_opacity ps in\n+  let _ = Pexp.parse_stratum ps in\n   let e = Pexp.parse_effect ps in\n   let ident = Pexp.parse_ident ps in\n   let i = !iref in\n@@ -851,7 +855,7 @@ and parse_obj_item\n       do\n         let apos = lexpos ps in\n           match peek ps with\n-              IO | STATE | UNSAFE | FN | ITER ->\n+              IMPURE | UNSAFE | FN | ITER ->\n                 let effect = Pexp.parse_effect ps in\n                 let is_iter = (peek ps) = ITER in\n                   bump ps;\n@@ -986,7 +990,10 @@ and parse_mod_item (ps:pstate)\n \n     match peek ps with\n \n-        IO | STATE | UNSAFE | TYPE | OBJ | TAG | FN | ITER ->\n+        STATE | GC | IMPURE | UNSAFE | ABS\n+      | TYPE | OBJ | TAG | FN | ITER ->\n+          let _ = Pexp.parse_opacity ps in\n+          let _ = Pexp.parse_stratum ps in\n           let effect = Pexp.parse_effect ps in\n             begin\n               match peek ps with\n@@ -1044,7 +1051,7 @@ and parse_mod_item (ps:pstate)\n               expect ps MOD;\n               let ident = Pexp.parse_ident ps in\n               let path = parse_lib_name ident in\n-              let items = parse_mod_items_from_signature ps in\n+              let items = parse_native_mod_items_from_signature ps in\n               let bpos = lexpos ps in\n               let rlib = REQUIRED_LIB_c { required_libname = path;\n                                           required_prefix = ps.pstate_depth }\n@@ -1056,7 +1063,7 @@ and parse_mod_item (ps:pstate)\n           end\n       | _ -> raise (unexpected ps)\n \n-and parse_mod_items_header_from_signature (ps:pstate) : Ast.mod_view =\n+and parse_native_mod_header_from_signature (ps:pstate) : Ast.mod_view =\n   let exports = Hashtbl.create 0 in\n     while (peek ps = EXPORT)\n     do\n@@ -1068,36 +1075,36 @@ and parse_mod_items_header_from_signature (ps:pstate) : Ast.mod_view =\n     then htab_put exports Ast.EXPORT_all_decls ();\n     {empty_view with Ast.view_exports = exports}\n \n-and parse_mod_items_from_signature\n+and parse_native_mod_items_from_signature\n     (ps:pstate)\n     : (Ast.mod_view * Ast.mod_items) =\n   expect ps LBRACE;\n-  let view  = parse_mod_items_header_from_signature ps in\n+  let view  = parse_native_mod_header_from_signature ps in\n   let items = Hashtbl.create 0 in\n     while not (peek ps = RBRACE)\n     do\n       Array.iter\n         (fun (ident, item) ->\n            htab_put items ident item)\n         (ctxt \"mod items from sig: mod item\"\n-           parse_mod_item_from_signature ps)\n+           parse_native_mod_item_from_signature ps)\n     done;\n     expect ps RBRACE;\n     (view,items)\n \n-and parse_mod_item_from_signature (ps:pstate)\n+and parse_native_mod_item_from_signature (ps:pstate)\n     : (Ast.ident * Ast.mod_item) array =\n   let apos = lexpos ps in\n     match peek ps with\n         MOD ->\n           bump ps;\n           let (ident, params) = parse_ident_and_params ps \"mod signature\" in\n-          let items = parse_mod_items_from_signature ps in\n+          let items = parse_native_mod_items_from_signature ps in\n           let bpos = lexpos ps in\n             [| (ident,\n                 span ps apos bpos (decl params (Ast.MOD_ITEM_mod items))) |]\n \n-      | IO | STATE | UNSAFE | FN | ITER ->\n+      | IMPURE | UNSAFE | FN | ITER ->\n           let effect = Pexp.parse_effect ps in\n           let is_iter = (peek ps) = ITER in\n             bump ps;\n@@ -1142,7 +1149,7 @@ and parse_mod_item_from_signature (ps:pstate)\n           expect ps SEMI;\n           let bpos = lexpos ps in\n             [| (ident, span ps apos bpos\n-                  (decl params (Ast.MOD_ITEM_type (Ast.UNSAFE, t)))) |]\n+                  (decl params (Ast.MOD_ITEM_type (Ast.EFF_unsafe, t)))) |]\n \n     | _ -> raise (unexpected ps)\n "}, {"sha": "84aeb9ab1148724c71ae850aaf19aab6a690df47", "filename": "src/boot/fe/lexer.mll", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Flexer.mll", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Flexer.mll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Flexer.mll?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -95,8 +95,12 @@\n                 (\"claim\", CLAIM);\n                 (\"prove\", PROVE);\n \n-                (\"io\", IO);\n+                (\"abs\", ABS);\n+\n                 (\"state\", STATE);\n+                (\"gc\", GC);\n+\n+                (\"impure\", IMPURE);\n                 (\"unsafe\", UNSAFE);\n \n                 (\"native\", NATIVE);"}, {"sha": "59cfaf751bb8f7cb1c495027da26fa95a2bfc219", "filename": "src/boot/fe/pexp.ml", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Fpexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Fpexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fpexp.ml?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -140,12 +140,22 @@ and parse_optional_trailing_constrs (ps:pstate) : Ast.constrs =\n       COLON -> (bump ps; parse_constrs ps)\n     | _ -> [| |]\n \n+and parse_opacity (ps:pstate) : Ast.opacity =\n+  match peek ps with\n+      ABS -> bump ps; Ast.OPA_abstract\n+    |  _ -> Ast.OPA_transparent\n+\n+and parse_stratum (ps:pstate) : Ast.stratum =\n+  match peek ps with\n+      STATE -> bump ps; Ast.STRAT_state\n+    | GC -> bump ps; Ast.STRAT_gc\n+    |  _ -> Ast.STRAT_value\n+\n and parse_effect (ps:pstate) : Ast.effect =\n   match peek ps with\n-      IO -> bump ps; Ast.IO\n-    | STATE -> bump ps; Ast.STATE\n-    | UNSAFE -> bump ps; Ast.UNSAFE\n-    | _ -> Ast.PURE\n+      IMPURE -> bump ps; Ast.EFF_impure\n+    | UNSAFE -> bump ps; Ast.EFF_unsafe\n+    | _ -> Ast.EFF_pure\n \n and parse_mutability (ps:pstate) : Ast.mutability =\n   match peek ps with\n@@ -263,7 +273,9 @@ and parse_atomic_ty (ps:pstate) : Ast.ty =\n         bump ps;\n         Ast.TY_mach m\n \n-    | IO | STATE | UNSAFE | OBJ | FN | ITER ->\n+    | ABS | STATE | GC | IMPURE | UNSAFE | OBJ | FN | ITER ->\n+        let _ = parse_opacity ps in\n+        let _ = parse_stratum ps in\n         let effect = parse_effect ps in\n           begin\n             match peek ps with"}, {"sha": "6c2282de2109a39b41fe45ae32846480f5aa4241", "filename": "src/boot/fe/token.ml", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Ftoken.ml", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Ffe%2Ftoken.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Ftoken.ml?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -80,9 +80,15 @@ type token =\n   | CLAIM\n   | PROVE\n \n-  (* Effect keywords *)\n-  | IO\n+  (* Opacity keywords *)\n+  | ABS\n+\n+  (* Stratum keywords *)\n   | STATE\n+  | GC\n+\n+  (* Effect keywords *)\n+  | IMPURE\n   | UNSAFE\n \n   (* Type qualifiers *)\n@@ -237,9 +243,15 @@ let rec string_of_tok t =\n     | CLAIM      -> \"claim\"\n     | PROVE      -> \"prove\"\n \n-    (* Effect keywords *)\n-    | IO         -> \"io\"\n+    (* Opacity keywords *)\n+    | ABS        -> \"abs\"\n+\n+    (* Stratum keywords *)\n     | STATE      -> \"state\"\n+    | GC         -> \"gc\"\n+\n+    (* Effect keywords *)\n+    | IMPURE     -> \"impure\"\n     | UNSAFE     -> \"unsafe\"\n \n     (* Type qualifiers *)"}, {"sha": "86a0c8a63cb3ddb05e37cf74bacb4dfbcd06cc14", "filename": "src/boot/me/dwarf.ml", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Fme%2Fdwarf.ml", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Fme%2Fdwarf.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fdwarf.ml?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1527,10 +1527,9 @@ let dwarf_visitor\n     (* Note: weird encoding: mutable+pure = unsafe. *)\n     let mut_byte, pure_byte =\n       match eff with\n-          Ast.UNSAFE -> (1,1)\n-        | Ast.STATE -> (1,0)\n-        | Ast.IO -> (0,0)\n-        | Ast.PURE -> (0,1)\n+          Ast.EFF_unsafe -> (1,1)\n+        | Ast.EFF_impure -> (0,0)\n+        | Ast.EFF_pure -> (0,1)\n     in\n       SEQ [|\n         (* DW_AT_mutable: DW_FORM_flag *)\n@@ -2888,10 +2887,10 @@ let rec extract_mod_items\n   let get_effect die =\n     match (get_flag die DW_AT_mutable, get_flag die DW_AT_pure) with\n         (* Note: weird encoding: mutable+pure = unsafe. *)\n-        (true, true) -> Ast.UNSAFE\n-      | (true, false) -> Ast.STATE\n-      | (false, false) -> Ast.IO\n-      | (false, true) -> Ast.PURE\n+        (true, true) -> Ast.EFF_unsafe\n+      | (false, false) -> Ast.EFF_impure\n+      | (false, true) -> Ast.EFF_pure\n+      | _ -> failwith \"bad effect encoding\"\n   in\n \n   let get_name die = get_str die DW_AT_name in"}, {"sha": "3bb761efed11eb016bf52290c53940883a08e156", "filename": "src/boot/me/effect.ml", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Fme%2Feffect.ml", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Fme%2Feffect.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Feffect.ml?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -92,7 +92,7 @@ let function_effect_propagation_visitor\n    * This visitor calculates the effect of each function according to\n    * its statements:\n    * \n-   *    - Communication lowers to 'io'\n+   *    - Communication statements lower to 'impure'\n    *    - Native calls lower to 'unsafe'\n    *    - Calling a function with effect e lowers to e.\n    *)\n@@ -138,7 +138,7 @@ let function_effect_propagation_visitor\n     let fn_id = Stack.top curr_fn in\n     let e =\n       match htab_search item_effect fn_id with\n-          None -> Ast.PURE\n+          None -> Ast.EFF_pure\n         | Some e -> e\n     in\n     let ne = lower_effect_of ne e in\n@@ -163,7 +163,7 @@ let function_effect_propagation_visitor\n     begin\n       match s.node with\n           Ast.STMT_send _\n-        | Ast.STMT_recv _ -> lower_to s Ast.IO\n+        | Ast.STMT_recv _ -> lower_to s Ast.EFF_impure\n \n         | Ast.STMT_call (_, fn, _) ->\n             let lower_to_callee_ty t =\n@@ -183,7 +183,7 @@ let function_effect_propagation_visitor\n                     match htab_search cx.ctxt_required_items item.id with\n                         None -> ()\n                       | Some (REQUIRED_LIB_rust _, _) -> ()\n-                      | Some _ -> lower_to s Ast.UNSAFE\n+                      | Some _ -> lower_to s Ast.EFF_unsafe\n                 end\n         | _ -> ()\n     end;\n@@ -232,7 +232,7 @@ let effect_checking_visitor\n         | Some e ->\n             let curr =\n               if Stack.is_empty auth_stack\n-              then Ast.PURE\n+              then Ast.EFF_pure\n               else Stack.top auth_stack\n             in\n             let next = lower_effect_of e curr in\n@@ -253,7 +253,7 @@ let effect_checking_visitor\n           Ast.MOD_ITEM_fn f ->\n             let e =\n               match htab_search item_effect i.id with\n-                None -> Ast.PURE\n+                None -> Ast.EFF_pure\n               | Some e -> e\n             in\n             let fe = f.Ast.fn_aux.Ast.fn_effect in\n@@ -291,7 +291,7 @@ let effect_checking_visitor\n           let curr = Stack.pop auth_stack in\n           let next =\n             if Stack.is_empty auth_stack\n-            then Ast.PURE\n+            then Ast.EFF_pure\n             else Stack.top auth_stack\n           in\n           iflog cx"}, {"sha": "1b65c0dbdac190df7d9c92048218f47cda6b36a9", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -191,7 +191,7 @@ type ctxt =\n \n       ctxt_rty_cache: (Ast.ty,Il.referent_ty) Hashtbl.t;\n \n-      ctxt_type_effect_cache: (Ast.ty,Ast.effect) Hashtbl.t;\n+      ctxt_type_stratum_cache: (Ast.ty,Ast.stratum) Hashtbl.t;\n       ctxt_type_points_to_heap_cache: (Ast.ty,bool) Hashtbl.t;\n       ctxt_type_is_structured_cache: (Ast.ty,bool) Hashtbl.t;\n       ctxt_type_contains_chan_cache: (Ast.ty,bool) Hashtbl.t;\n@@ -296,7 +296,7 @@ let new_ctxt sess abi crate =\n     ctxt_curr_path = Stack.create ();\n \n     ctxt_rty_cache = Hashtbl.create 0;\n-    ctxt_type_effect_cache = Hashtbl.create 0;\n+    ctxt_type_stratum_cache = Hashtbl.create 0;\n     ctxt_type_points_to_heap_cache = Hashtbl.create 0;\n     ctxt_type_is_structured_cache = Hashtbl.create 0;\n     ctxt_type_contains_chan_cache = Hashtbl.create 0;\n@@ -1227,33 +1227,46 @@ let type_points_to_heap (cx:ctxt) (t:Ast.ty) : bool =\n       (fun _ -> fold_ty cx fold t)\n ;;\n \n-(* Effect analysis. *)\n+\n+(* Type qualifier analysis. *)\n+\n let effect_le x y =\n   match (x,y) with\n-      (Ast.UNSAFE, _) -> true\n-    | (Ast.STATE, Ast.PURE) -> true\n-    | (Ast.STATE, Ast.IO) -> true\n-    | (Ast.STATE, Ast.STATE) -> true\n-    | (Ast.IO, Ast.PURE) -> true\n-    | (Ast.IO, Ast.IO) -> true\n-    | (Ast.PURE, Ast.PURE) -> true\n+      (Ast.EFF_unsafe, _) -> true\n+    | (Ast.EFF_impure, Ast.EFF_pure) -> true\n+    | (Ast.EFF_impure, Ast.EFF_impure) -> true\n+    | (Ast.EFF_pure, Ast.EFF_pure) -> true\n     | _ -> false\n ;;\n \n let lower_effect_of x y =\n   if effect_le x y then x else y\n ;;\n \n-let type_effect (cx:ctxt) (t:Ast.ty) : Ast.effect =\n-  let fold_mutable _ = Ast.STATE in\n-  let fold = associative_binary_op_ty_fold Ast.PURE lower_effect_of in\n+let stratum_le x y =\n+  match (x,y) with\n+      (Ast.STRAT_gc, _) -> true\n+    | (Ast.STRAT_state, Ast.STRAT_value) -> true\n+    | (Ast.STRAT_state, Ast.STRAT_state) -> true\n+    | (Ast.STRAT_value, Ast.STRAT_value) -> true\n+    | _ -> false\n+;;\n+\n+let lower_stratum_of x y =\n+  if stratum_le x y then x else y\n+;;\n+\n+let type_stratum (cx:ctxt) (t:Ast.ty) : Ast.stratum =\n+  let fold_mutable _ = Ast.STRAT_state in\n+  let fold = associative_binary_op_ty_fold Ast.STRAT_value lower_stratum_of in\n   let fold = { fold with ty_fold_mutable = fold_mutable } in\n-    htab_search_or_add cx.ctxt_type_effect_cache t\n+    htab_search_or_add cx.ctxt_type_stratum_cache t\n       (fun _ -> fold_ty cx fold t)\n ;;\n \n+\n let type_has_state (cx:ctxt) (t:Ast.ty) : bool =\n-  effect_le (type_effect cx t) Ast.STATE\n+  stratum_le (type_stratum cx t) Ast.STRAT_state\n ;;\n \n \n@@ -1627,7 +1640,7 @@ let ty_of_mod_item (item:Ast.mod_item) : Ast.ty =\n     | Ast.MOD_ITEM_mod _ -> bug () \"Semant.ty_of_mod_item on mod\"\n     | Ast.MOD_ITEM_const (ty, _) -> ty\n     | Ast.MOD_ITEM_obj ob ->\n-        let taux = { Ast.fn_effect = Ast.PURE;\n+        let taux = { Ast.fn_effect = Ast.EFF_pure;\n                      Ast.fn_is_iter = false }\n         in\n         let tobj = Ast.TY_obj (ty_obj_of_obj ob) in\n@@ -1650,7 +1663,7 @@ let ty_of_mod_item (item:Ast.mod_item) : Ast.ty =\n           if Array.length hdr = 0\n           then Ast.TY_tag ttag\n           else\n-            let taux = { Ast.fn_effect = Ast.PURE;\n+            let taux = { Ast.fn_effect = Ast.EFF_pure;\n                          Ast.fn_is_iter = false }\n             in\n             let inputs = Array.map (fun (s, _) -> s.node) hdr in\n@@ -2561,7 +2574,7 @@ let mk_ty_fn_or_iter\n     (is_iter:bool)\n     : Ast.ty =\n   (* In some cases we don't care what aux or constrs are. *)\n-  let taux = { Ast.fn_effect = Ast.PURE;\n+  let taux = { Ast.fn_effect = Ast.EFF_pure;\n                Ast.fn_is_iter = is_iter; }\n   in\n   let tsig = { Ast.sig_input_slots = arg_slots;"}, {"sha": "0579775f7de8df69e67ca27e4b94f7af0e068a9d", "filename": "src/boot/me/typestate.ml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Fme%2Ftypestate.ml", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fboot%2Fme%2Ftypestate.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftypestate.ml?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -126,7 +126,7 @@ let determine_constr_key\n               match Hashtbl.find cx.ctxt_all_item_types cid with\n                   Ast.TY_fn (_, taux) ->\n                     begin\n-                      if taux.Ast.fn_effect = Ast.PURE\n+                      if taux.Ast.fn_effect = Ast.EFF_pure\n                       then cid\n                       else err (Some cid) \"impure function used in constraint\"\n                     end\n@@ -989,6 +989,7 @@ let graph_special_block_structure_building_visitor\n                         Hashtbl.replace graph cond_id [then_id; else_id];\n                         Hashtbl.replace graph then_end_id succ;\n                         Hashtbl.replace graph else_end_id succ;\n+\n                         (* Kill residual messed-up block wiring.*)\n                         remove_flow_edges graph then_end_id [then_id];\n                         remove_flow_edges graph else_id [then_id];"}, {"sha": "920b47d23c868a37bde3b11ebdfb2f84329db49f", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -11,7 +11,7 @@ import std.util.none;\n import std._str;\n import std._vec;\n \n-io fn compile_input(session.session sess, str input, str output) {\n+impure fn compile_input(session.session sess, str input, str output) {\n           auto p = parser.new_parser(sess, 0, input);\n           auto crate = parser.parse_crate(p);\n           crate = resolve.resolve_crate(sess, crate);\n@@ -36,7 +36,7 @@ fn usage(session.session sess, str argv0) {\n     log \"\";\n }\n \n-io fn main(vec[str] args) {\n+impure fn main(vec[str] args) {\n \n   auto sess = session.session();\n   let option[str] input_file = none[str];"}, {"sha": "fbeee8cbcfea70542d9b774ff9dbac1582098907", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -9,7 +9,7 @@ state type reader = state obj {\n                           fn is_eof() -> bool;\n                           fn curr() -> char;\n                           fn next() -> char;\n-                          io fn bump();\n+                          impure fn bump();\n                           fn mark();\n                           fn get_filename() -> str;\n                           fn get_mark_pos() -> common.pos;\n@@ -55,7 +55,7 @@ fn new_reader(stdio_reader rdr, str filename) -> reader\n                 ret n;\n             }\n \n-            io fn bump() {\n+            impure fn bump() {\n                 c = n;\n \n                 if (c == (-1) as char) {\n@@ -247,14 +247,14 @@ fn is_whitespace(char c) -> bool {\n     ret c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n \n-io fn consume_any_whitespace(reader rdr) {\n+impure fn consume_any_whitespace(reader rdr) {\n     while (is_whitespace(rdr.curr())) {\n         rdr.bump();\n     }\n     be consume_any_line_comment(rdr);\n }\n \n-io fn consume_any_line_comment(reader rdr) {\n+impure fn consume_any_line_comment(reader rdr) {\n     if (rdr.curr() == '/') {\n         alt (rdr.next()) {\n             case ('/') {\n@@ -277,7 +277,7 @@ io fn consume_any_line_comment(reader rdr) {\n }\n \n \n-io fn consume_block_comment(reader rdr) {\n+impure fn consume_block_comment(reader rdr) {\n     let int level = 1;\n     while (level > 0) {\n         if (rdr.curr() == '/' && rdr.next() == '*') {\n@@ -298,7 +298,7 @@ io fn consume_block_comment(reader rdr) {\n     be consume_any_whitespace(rdr);\n }\n \n-io fn next_token(reader rdr) -> token.token {\n+impure fn next_token(reader rdr) -> token.token {\n     auto accum_str = \"\";\n     auto accum_int = 0;\n \n@@ -359,7 +359,7 @@ io fn next_token(reader rdr) -> token.token {\n         ret token.LIT_INT(accum_int);\n     }\n \n-    io fn binop(reader rdr, token.binop op) -> token.token {\n+    impure fn binop(reader rdr, token.binop op) -> token.token {\n         rdr.bump();\n         if (rdr.next() == '=') {\n             rdr.bump();"}, {"sha": "fd3bd1c05bd0c546de014739fbc7961efdf9e15a", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -13,14 +13,14 @@ import util.common.new_str_hash;\n state type parser =\n     state obj {\n           fn peek() -> token.token;\n-          io fn bump();\n-          io fn err(str s);\n+          impure fn bump();\n+          impure fn err(str s);\n           fn get_session() -> session.session;\n           fn get_span() -> common.span;\n           fn next_def_id() -> ast.def_id;\n     };\n \n-io fn new_parser(session.session sess,\n+impure fn new_parser(session.session sess,\n                  ast.crate_num crate, str path) -> parser {\n     state obj stdio_parser(session.session sess,\n                            mutable token.token tok,\n@@ -35,13 +35,13 @@ io fn new_parser(session.session sess,\n                 ret tok;\n             }\n \n-            io fn bump() {\n+            impure fn bump() {\n                 tok = lexer.next_token(rdr);\n                 lo = rdr.get_mark_pos();\n                 hi = rdr.get_curr_pos();\n             }\n \n-            io fn err(str m) {\n+            impure fn err(str m) {\n                 auto span = rec(filename = rdr.get_filename(),\n                                 lo = lo, hi = hi);\n                 sess.span_err(span, m);\n@@ -68,7 +68,7 @@ io fn new_parser(session.session sess,\n                      npos, npos, 0, crate, rdr);\n }\n \n-io fn expect(parser p, token.token t) {\n+impure fn expect(parser p, token.token t) {\n     if (p.peek() == t) {\n         p.bump();\n     } else {\n@@ -86,7 +86,7 @@ fn spanned[T](&span lo, &span hi, &T node) -> ast.spanned[T] {\n                                 hi=hi.hi));\n }\n \n-io fn parse_ident(parser p) -> ast.ident {\n+impure fn parse_ident(parser p) -> ast.ident {\n     alt (p.peek()) {\n         case (token.IDENT(?i)) { p.bump(); ret i; }\n         case (_) {\n@@ -96,7 +96,7 @@ io fn parse_ident(parser p) -> ast.ident {\n     }\n }\n \n-io fn parse_possibly_mutable_ty(parser p) -> tup(bool, @ast.ty) {\n+impure fn parse_possibly_mutable_ty(parser p) -> tup(bool, @ast.ty) {\n     auto mut;\n     if (p.peek() == token.MUTABLE) {\n         p.bump();\n@@ -108,7 +108,7 @@ io fn parse_possibly_mutable_ty(parser p) -> tup(bool, @ast.ty) {\n     ret tup(mut, parse_ty(p));\n }\n \n-io fn parse_ty(parser p) -> @ast.ty {\n+impure fn parse_ty(parser p) -> @ast.ty {\n     auto lo = p.get_span();\n     let ast.ty_ t;\n     alt (p.peek()) {\n@@ -144,7 +144,7 @@ io fn parse_ty(parser p) -> @ast.ty {\n     ret @spanned(lo, lo, t);\n }\n \n-io fn parse_arg(parser p) -> ast.arg {\n+impure fn parse_arg(parser p) -> ast.arg {\n     let ast.mode m = ast.val;\n     if (p.peek() == token.BINOP(token.AND)) {\n         m = ast.alias;\n@@ -155,10 +155,10 @@ io fn parse_arg(parser p) -> ast.arg {\n     ret rec(mode=m, ty=t, ident=i, id=p.next_def_id());\n }\n \n-io fn parse_seq[T](token.token bra,\n+impure fn parse_seq[T](token.token bra,\n                       token.token ket,\n                       option[token.token] sep,\n-                      (io fn(parser) -> T) f,\n+                      (impure fn(parser) -> T) f,\n                       parser p) -> util.common.spanned[vec[T]] {\n     let bool first = true;\n     auto lo = p.get_span();\n@@ -185,7 +185,7 @@ io fn parse_seq[T](token.token bra,\n     ret spanned(lo, hi, v);\n }\n \n-io fn parse_lit(parser p) -> option[ast.lit] {\n+impure fn parse_lit(parser p) -> option[ast.lit] {\n     auto lo = p.get_span();\n     let ast.lit_ lit;\n     alt (p.peek()) {\n@@ -217,7 +217,7 @@ io fn parse_lit(parser p) -> option[ast.lit] {\n     ret some(spanned(lo, lo, lit));\n }\n \n-io fn parse_name(parser p, ast.ident id) -> ast.name {\n+impure fn parse_name(parser p, ast.ident id) -> ast.name {\n \n     auto lo = p.get_span();\n \n@@ -240,7 +240,7 @@ io fn parse_name(parser p, ast.ident id) -> ast.name {\n     ret spanned(lo, tys.span, rec(ident=id, types=tys.node));\n }\n \n-io fn parse_possibly_mutable_expr(parser p) -> tup(bool, @ast.expr) {\n+impure fn parse_possibly_mutable_expr(parser p) -> tup(bool, @ast.expr) {\n     auto mut;\n     if (p.peek() == token.MUTABLE) {\n         p.bump();\n@@ -252,7 +252,7 @@ io fn parse_possibly_mutable_expr(parser p) -> tup(bool, @ast.expr) {\n     ret tup(mut, parse_expr(p));\n }\n \n-io fn parse_bottom_expr(parser p) -> @ast.expr {\n+impure fn parse_bottom_expr(parser p) -> @ast.expr {\n \n     auto lo = p.get_span();\n     auto hi = lo;\n@@ -315,7 +315,7 @@ io fn parse_bottom_expr(parser p) -> @ast.expr {\n \n         case (token.REC) {\n             p.bump();\n-            io fn parse_entry(parser p) ->\n+            impure fn parse_entry(parser p) ->\n                 tup(ast.ident, @ast.expr) {\n                 auto i = parse_ident(p);\n                 expect(p, token.EQ);\n@@ -348,7 +348,7 @@ io fn parse_bottom_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, ex);\n }\n \n-io fn parse_path_expr(parser p) -> @ast.expr {\n+impure fn parse_path_expr(parser p) -> @ast.expr {\n     auto lo = p.get_span();\n     auto e = parse_bottom_expr(p);\n     auto hi = e.span;\n@@ -381,7 +381,7 @@ io fn parse_path_expr(parser p) -> @ast.expr {\n     ret e;\n }\n \n-io fn parse_prefix_expr(parser p) -> @ast.expr {\n+impure fn parse_prefix_expr(parser p) -> @ast.expr {\n \n     auto lo = p.get_span();\n     auto hi = lo;\n@@ -443,8 +443,8 @@ io fn parse_prefix_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, ex);\n }\n \n-io fn parse_binops(parser p,\n-                   (io fn(parser) -> @ast.expr) sub,\n+impure fn parse_binops(parser p,\n+                   (impure fn(parser) -> @ast.expr) sub,\n                    vec[tup(token.binop, ast.binop)] ops)\n     -> @ast.expr {\n     auto lo = p.get_span();\n@@ -472,8 +472,8 @@ io fn parse_binops(parser p,\n     ret e;\n }\n \n-io fn parse_binary_exprs(parser p,\n-                            (io fn(parser) -> @ast.expr) sub,\n+impure fn parse_binary_exprs(parser p,\n+                            (impure fn(parser) -> @ast.expr) sub,\n                             vec[tup(token.token, ast.binop)] ops)\n     -> @ast.expr {\n     auto lo = p.get_span();\n@@ -496,42 +496,42 @@ io fn parse_binary_exprs(parser p,\n     ret e;\n }\n \n-io fn parse_factor_expr(parser p) -> @ast.expr {\n+impure fn parse_factor_expr(parser p) -> @ast.expr {\n     auto sub = parse_prefix_expr;\n     ret parse_binops(p, sub, vec(tup(token.STAR, ast.mul),\n                                  tup(token.SLASH, ast.div),\n                                  tup(token.PERCENT, ast.rem)));\n }\n \n-io fn parse_term_expr(parser p) -> @ast.expr {\n+impure fn parse_term_expr(parser p) -> @ast.expr {\n     auto sub = parse_factor_expr;\n     ret parse_binops(p, sub, vec(tup(token.PLUS, ast.add),\n                                  tup(token.MINUS, ast.sub)));\n }\n \n-io fn parse_shift_expr(parser p) -> @ast.expr {\n+impure fn parse_shift_expr(parser p) -> @ast.expr {\n     auto sub = parse_term_expr;\n     ret parse_binops(p, sub, vec(tup(token.LSL, ast.lsl),\n                                  tup(token.LSR, ast.lsr),\n                                  tup(token.ASR, ast.asr)));\n }\n \n-io fn parse_bitand_expr(parser p) -> @ast.expr {\n+impure fn parse_bitand_expr(parser p) -> @ast.expr {\n     auto sub = parse_shift_expr;\n     ret parse_binops(p, sub, vec(tup(token.AND, ast.bitand)));\n }\n \n-io fn parse_bitxor_expr(parser p) -> @ast.expr {\n+impure fn parse_bitxor_expr(parser p) -> @ast.expr {\n     auto sub = parse_bitand_expr;\n     ret parse_binops(p, sub, vec(tup(token.CARET, ast.bitxor)));\n }\n \n-io fn parse_bitor_expr(parser p) -> @ast.expr {\n+impure fn parse_bitor_expr(parser p) -> @ast.expr {\n     auto sub = parse_bitxor_expr;\n     ret parse_binops(p, sub, vec(tup(token.OR, ast.bitor)));\n }\n \n-io fn parse_cast_expr(parser p) -> @ast.expr {\n+impure fn parse_cast_expr(parser p) -> @ast.expr {\n     auto lo = p.get_span();\n     auto e = parse_bitor_expr(p);\n     auto hi = e.span;\n@@ -552,7 +552,7 @@ io fn parse_cast_expr(parser p) -> @ast.expr {\n     ret e;\n }\n \n-io fn parse_relational_expr(parser p) -> @ast.expr {\n+impure fn parse_relational_expr(parser p) -> @ast.expr {\n     auto sub = parse_cast_expr;\n     ret parse_binary_exprs(p, sub, vec(tup(token.LT, ast.lt),\n                                        tup(token.LE, ast.le),\n@@ -561,23 +561,23 @@ io fn parse_relational_expr(parser p) -> @ast.expr {\n }\n \n \n-io fn parse_equality_expr(parser p) -> @ast.expr {\n+impure fn parse_equality_expr(parser p) -> @ast.expr {\n     auto sub = parse_relational_expr;\n     ret parse_binary_exprs(p, sub, vec(tup(token.EQEQ, ast.eq),\n                                        tup(token.NE, ast.ne)));\n }\n \n-io fn parse_and_expr(parser p) -> @ast.expr {\n+impure fn parse_and_expr(parser p) -> @ast.expr {\n     auto sub = parse_equality_expr;\n     ret parse_binary_exprs(p, sub, vec(tup(token.ANDAND, ast.and)));\n }\n \n-io fn parse_or_expr(parser p) -> @ast.expr {\n+impure fn parse_or_expr(parser p) -> @ast.expr {\n     auto sub = parse_and_expr;\n     ret parse_binary_exprs(p, sub, vec(tup(token.OROR, ast.or)));\n }\n \n-io fn parse_assign_expr(parser p) -> @ast.expr {\n+impure fn parse_assign_expr(parser p) -> @ast.expr {\n     auto lo = p.get_span();\n     auto lhs = parse_or_expr(p);\n     alt (p.peek()) {\n@@ -591,7 +591,7 @@ io fn parse_assign_expr(parser p) -> @ast.expr {\n     ret lhs;\n }\n \n-io fn parse_if_expr(parser p) -> @ast.expr {\n+impure fn parse_if_expr(parser p) -> @ast.expr {\n     auto lo = p.get_span();\n     auto hi = lo;\n \n@@ -613,7 +613,7 @@ io fn parse_if_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, ast.expr_if(cond, thn, els, none[@ast.ty]));\n }\n \n-io fn parse_expr(parser p) -> @ast.expr {\n+impure fn parse_expr(parser p) -> @ast.expr {\n     alt (p.peek()) {\n         case (token.LBRACE) {\n             auto blk = parse_block(p);\n@@ -630,7 +630,7 @@ io fn parse_expr(parser p) -> @ast.expr {\n     }\n }\n \n-io fn parse_initializer(parser p) -> option[@ast.expr] {\n+impure fn parse_initializer(parser p) -> option[@ast.expr] {\n     if (p.peek() == token.EQ) {\n         p.bump();\n         ret some(parse_expr(p));\n@@ -639,7 +639,7 @@ io fn parse_initializer(parser p) -> option[@ast.expr] {\n     ret none[@ast.expr];\n }\n \n-io fn parse_let(parser p) -> @ast.decl {\n+impure fn parse_let(parser p) -> @ast.decl {\n     auto lo = p.get_span();\n \n     expect(p, token.LET);\n@@ -659,7 +659,7 @@ io fn parse_let(parser p) -> @ast.decl {\n     ret @spanned(lo, hi, ast.decl_local(@local));\n }\n \n-io fn parse_auto(parser p) -> @ast.decl {\n+impure fn parse_auto(parser p) -> @ast.decl {\n     auto lo = p.get_span();\n \n     expect(p, token.AUTO);\n@@ -678,7 +678,7 @@ io fn parse_auto(parser p) -> @ast.decl {\n     ret @spanned(lo, hi, ast.decl_local(@local));\n }\n \n-io fn parse_stmt(parser p) -> @ast.stmt {\n+impure fn parse_stmt(parser p) -> @ast.stmt {\n     auto lo = p.get_span();\n     alt (p.peek()) {\n \n@@ -760,7 +760,7 @@ io fn parse_stmt(parser p) -> @ast.stmt {\n     fail;\n }\n \n-io fn parse_block(parser p) -> ast.block {\n+impure fn parse_block(parser p) -> ast.block {\n     auto f = parse_stmt;\n     // FIXME: passing parse_stmt as an lval doesn't work at the moment.\n     auto stmts = parse_seq[@ast.stmt](token.LBRACE,\n@@ -800,7 +800,7 @@ io fn parse_block(parser p) -> ast.block {\n     ret spanned(stmts.span, stmts.span, b);\n }\n \n-io fn parse_fn(parser p) -> tup(ast.ident, @ast.item) {\n+impure fn parse_fn(parser p) -> tup(ast.ident, @ast.item) {\n     auto lo = p.get_span();\n     expect(p, token.FN);\n     auto id = parse_ident(p);\n@@ -832,7 +832,7 @@ io fn parse_fn(parser p) -> tup(ast.ident, @ast.item) {\n     ret tup(id, @spanned(lo, body.span, item));\n }\n \n-io fn parse_mod_items(parser p, token.token term) -> ast._mod {\n+impure fn parse_mod_items(parser p, token.token term) -> ast._mod {\n    let vec[@ast.item] items = vec();\n     let hashmap[ast.ident,uint] index = new_str_hash[uint]();\n     let uint u = 0u;\n@@ -845,7 +845,7 @@ io fn parse_mod_items(parser p, token.token term) -> ast._mod {\n     ret rec(items=items, index=index);\n  }\n \n-io fn parse_mod(parser p) -> tup(ast.ident, @ast.item) {\n+impure fn parse_mod(parser p) -> tup(ast.ident, @ast.item) {\n     auto lo = p.get_span();\n     expect(p, token.MOD);\n     auto id = parse_ident(p);\n@@ -857,7 +857,7 @@ io fn parse_mod(parser p) -> tup(ast.ident, @ast.item) {\n     ret tup(id, @spanned(lo, hi, item));\n }\n \n-io fn parse_item(parser p) -> tup(ast.ident, @ast.item) {\n+impure fn parse_item(parser p) -> tup(ast.ident, @ast.item) {\n     alt (p.peek()) {\n         case (token.FN) {\n             ret parse_fn(p);\n@@ -870,7 +870,7 @@ io fn parse_item(parser p) -> tup(ast.ident, @ast.item) {\n     fail;\n }\n \n-io fn parse_crate(parser p) -> @ast.crate {\n+impure fn parse_crate(parser p) -> @ast.crate {\n     auto lo = p.get_span();\n     auto hi = lo;\n     auto m = parse_mod_items(p, token.EOF);"}, {"sha": "f9f3b0a63a669be3be9e9f76072d12d31ccfc281", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -30,7 +30,7 @@ mod util {\n     mod common;\n }\n \n-auth driver.rustc.main = state;\n+auth driver.rustc.main = impure;\n auth middle.trans = unsafe;\n auth lib.llvm = unsafe;\n "}, {"sha": "4d7a6c037751e06b24632ef47af2462bca24ef8a", "filename": "src/lib/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -12,7 +12,7 @@ import std._vec;\n type hashfn[K] = fn(&K) -> uint;\n type eqfn[K] = fn(&K, &K) -> bool;\n \n-state type hashmap[K, V] = state obj {\n+abs state type hashmap[K, V] = state obj {\n                                  fn size() -> uint;\n                                  fn insert(&K key, &V val) -> bool;\n                                  fn contains_key(&K key) -> bool;"}, {"sha": "77eab003573a683a547e463e5f9af125b2f4e915", "filename": "src/lib/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Flib%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Flib%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsys.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -10,13 +10,13 @@ native \"rust\" mod rustrt {\n     export size_of;\n     export align_of;\n     export refcount;\n-    export gc;\n+    export do_gc;\n \n     fn last_os_error() -> str;\n     fn size_of[T]() -> uint;\n     fn align_of[T]() -> uint;\n     fn refcount[T](@T t) -> uint;\n-    fn gc();\n+    fn do_gc();\n     fn unsupervise();\n }\n "}, {"sha": "d221e6e587b49198a88ffcb6011f971d66d23a98", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -69,7 +69,7 @@ refcount(rust_task *task, type_desc *t, size_t *v) {\n }\n \n extern \"C\" CDECL void\n-gc(rust_task *task) {\n+do_gc(rust_task *task) {\n     task->gc(1);\n }\n "}, {"sha": "57a8e6e86f6d06c5a0cf86dd1672b017fe4455dc", "filename": "src/test/compile-fail/comm-makes-io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Fcompile-fail%2Fcomm-makes-io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Fcompile-fail%2Fcomm-makes-io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcomm-makes-io.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: calculated effect is 'io'\n+// error-pattern: calculated effect is 'impure'\n \n fn main() {\n   let chan[int] c = chan();"}, {"sha": "c322850b6dd19cd8361cd65652fa8acca6861be1", "filename": "src/test/compile-fail/impure-pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -5,7 +5,7 @@\n fn f(int a, int b) : lt(a,b) {\n }\n \n-io fn lt(int a, int b) -> bool {\n+impure fn lt(int a, int b) -> bool {\n   let port[int] p = port();\n   let chan[int] c = chan(p);\n   c <| 10;"}, {"sha": "b07f46e6d20cadfc0b785211d96df8cb1935d04d", "filename": "src/test/compile-fail/io-infects-caller.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Fcompile-fail%2Fio-infects-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Fcompile-fail%2Fio-infects-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fio-infects-caller.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,6 +1,6 @@\n-// error-pattern: calculated effect is 'io'\n+// error-pattern: calculated effect is 'impure'\n \n-io fn foo() {\n+impure fn foo() {\n   let chan[int] c = chan();\n   c <| 10;\n }"}, {"sha": "fb50a54ccbf1608bb38f5890bb49c24d51e68da1", "filename": "src/test/compile-fail/unnecessary-io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Fcompile-fail%2Funnecessary-io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Fcompile-fail%2Funnecessary-io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funnecessary-io.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: calculated effect is ''\n-io fn main() {\n+impure fn main() {\n   log \"hi\";\n }\n\\ No newline at end of file"}, {"sha": "4990f33cf87efa1ca7811b5aceb7267f5f498787", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -6,7 +6,7 @@ fn child() {\n   check (1 == 2);\n }\n \n-io fn main() {\n+impure fn main() {\n   let port[int] p = port();\n   spawn child();\n   let int x;"}, {"sha": "27cffad46d40a4d324f7b01b059f738d873bef0c", "filename": "src/test/run-pass/acyclic-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n \n-io fn f(chan[int] c)\n+impure fn f(chan[int] c)\n {\n   type t = tup(int,int,int);\n \n@@ -23,7 +23,7 @@ io fn f(chan[int] c)\n }\n \n \n-io fn main() {\n+impure fn main() {\n   let port[int] p = port();\n   spawn f(chan(p));\n   let int i;"}, {"sha": "f61bf8951122ef49af99c500122b34d861ec1e06", "filename": "src/test/run-pass/basic-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-1.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,10 +1,10 @@\n // -*- rust -*-\n \n-io fn a(chan[int] c) {\n+impure fn a(chan[int] c) {\n     c <| 10;\n }\n \n-io fn main() {\n+impure fn main() {\n     let port[int] p = port();\n     spawn a(chan(p));\n     spawn b(chan(p));\n@@ -14,7 +14,7 @@ io fn main() {\n //    log \"Finished.\";\n }\n \n-io fn b(chan[int] c) {\n+impure fn b(chan[int] c) {\n //    log \"task b0\";\n //    log \"task b1\";\n //    log \"task b2\";"}, {"sha": "d2b2e240f8d42b0f2a24d9409de3694ce8da5c5f", "filename": "src/test/run-pass/basic-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-2.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,12 +1,12 @@\n // -*- rust -*-\n \n-io fn a(chan[int] c) {\n+impure fn a(chan[int] c) {\n     log \"task a0\";\n     log \"task a1\";\n     c <| 10;\n }\n \n-io fn main() {\n+impure fn main() {\n     let port[int] p = port();\n     spawn a(chan(p));\n     spawn b(chan(p));\n@@ -16,7 +16,7 @@ io fn main() {\n     log \"Finished.\";\n }\n \n-io fn b(chan[int] c) {\n+impure fn b(chan[int] c) {\n     log \"task b0\";\n     log \"task b1\";\n     log \"task b2\";"}, {"sha": "a92247c98322c160af2cd84a613eb96aa01840f1", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n \n-io fn a(chan[int] c) {\n+impure fn a(chan[int] c) {\n   if (true) {\n     log \"task a\";\n     log \"task a\";\n@@ -22,7 +22,7 @@ fn g(int x, str y) -> int {\n   ret z;\n }\n \n-io fn main() {\n+impure fn main() {\n     let int n = 2 + 3 * 7;\n     let str s = \"hello there\";\n     let port[int] p = port();\n@@ -37,7 +37,7 @@ io fn main() {\n     log \"children finished, root finishing\";\n }\n \n-io fn b(chan[int] c) {\n+impure fn b(chan[int] c) {\n   if (true) {\n     log \"task b\";\n     log \"task b\";"}, {"sha": "a6610d57ff0ec4954e286dca88c2a7e082fc32a7", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n \n-io fn main() {\n+impure fn main() {\n   let port[int] p = port();\n   spawn child(chan(p));\n   let int y;\n@@ -10,7 +10,7 @@ io fn main() {\n   check (y == 10);\n }\n \n-io fn child(chan[int] c) {\n+impure fn child(chan[int] c) {\n   c <| 10;\n }\n "}, {"sha": "b5bf8872712adaf210aaf7aff0b412550d5272db", "filename": "src/test/run-pass/lazychan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Flazychan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Flazychan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazychan.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n \n-io fn main() {\n+impure fn main() {\n   let port[int] p = port();\n   auto c = chan(p);\n   let int y;\n@@ -18,6 +18,6 @@ io fn main() {\n   check (y == 10);\n }\n \n-io fn child(chan[int] c) {\n+impure fn child(chan[int] c) {\n   c <| 10;\n }"}, {"sha": "0ae8cc6b387d411a39da2dc5ea732af3c9b3974b", "filename": "src/test/run-pass/lib-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Flib-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Flib-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-map.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -347,5 +347,5 @@ fn main() {\n   test_growth();\n   test_removal();\n \n-  std.sys.rustrt.gc();\n+  std.sys.rustrt.do_gc();\n }"}, {"sha": "d1f54f8fa6cf38b64799f2267b067c517d526222", "filename": "src/test/run-pass/obj-dtor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-dtor.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -5,7 +5,7 @@ obj worker(chan[int] c) {\n   }\n }\n \n-io fn do_work(chan[int] c) {\n+impure fn do_work(chan[int] c) {\n   log \"in child task\";\n   {\n     let worker w = worker(c);\n@@ -20,7 +20,7 @@ io fn do_work(chan[int] c) {\n   }\n }\n \n-io fn main() {\n+impure fn main() {\n   let port[int] p = port();\n   log \"spawning worker\";\n   auto w = spawn do_work(chan(p));"}, {"sha": "067870971893a7bda831f7b2bad06d9ed2b4a310", "filename": "src/test/run-pass/preempt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fpreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Fpreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpreempt.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,6 +1,6 @@\n // This checks that preemption works.\n \n-io fn starve_main(chan[int] alive) {\n+impure fn starve_main(chan[int] alive) {\n   log \"signalling main\";\n   alive <| 1;\n   log \"starving main\";\n@@ -10,7 +10,7 @@ io fn starve_main(chan[int] alive) {\n   }\n }\n \n-io fn main() {\n+impure fn main() {\n   let port[int] alive = port();\n   log \"main started\";\n   let task s = spawn starve_main(chan(alive));"}, {"sha": "085f958e01893b8a5d58de76fa4a711867a813f0", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,14 +1,14 @@\n-io fn main() -> () {\n+impure fn main() -> () {\n     test05();\n }\n \n-io fn test05_start(chan[int] ch) {\n+impure fn test05_start(chan[int] ch) {\n     ch <| 10;\n     ch <| 20;\n     ch <| 30;\n }\n \n-io fn test05() {\n+impure fn test05() {\n     let port[int] po = port();\n     let chan[int] ch = chan(po);\n     spawn test05_start(chan(po));"}, {"sha": "41069c7fd86bd7747c5250d3b7f1fe9fdca090fa", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,9 +1,9 @@\n-io fn start(chan[chan[str]] c) {\n+impure fn start(chan[chan[str]] c) {\n     let port[str] p = port();\n     c <| chan(p);\n }\n \n-io fn main() {\n+impure fn main() {\n     let port[chan[str]] p = port();\n     auto child = spawn \"child\" start(chan(p));\n     auto c <- p;"}, {"sha": "e7cfc24720d9a9f8fc1b9ed8b120a3eb7a3f13ce", "filename": "src/test/run-pass/task-comm-13-thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,7 +1,7 @@\n use std;\n import std._task;\n \n-io fn start(chan[int] c, int start, int number_of_messages) {\n+impure fn start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;\n     while (i < number_of_messages) {\n         c <| start + i;"}, {"sha": "6b29ec1ee2a85ebb745344de99cb61f0485fcaee", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,7 +1,7 @@\n use std;\n import std._task;\n \n-io fn start(chan[int] c, int start, int number_of_messages) {\n+impure fn start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;\n     while (i < number_of_messages) {\n         c <| start + i;"}, {"sha": "31b9460397519d54f0d1cee02cf780352520e6a9", "filename": "src/test/run-pass/task-comm-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,8 +1,8 @@\n-io fn main() -> () {\n+impure fn main() -> () {\n    test00();\n }\n \n-io fn test00() {\n+impure fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}, {"sha": "76606094d0a59a40cb4b47693720db179920baa2", "filename": "src/test/run-pass/task-comm-5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,8 +1,8 @@\n-io fn main() -> () {\n+impure fn main() -> () {\n    test00();\n }\n \n-io fn test00() {\n+impure fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}, {"sha": "4ab9713557c7a286561c007b83d67719ce31cdc0", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,8 +1,8 @@\n-io fn main() -> () {\n+impure fn main() -> () {\n    test00();\n }\n \n-io fn test00() {\n+impure fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}, {"sha": "099f8d6b6d4e07feeba1d8f95023ba09133b9048", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da13c508d83032ca13679e1e122e96d25ac23283/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=da13c508d83032ca13679e1e122e96d25ac23283", "patch": "@@ -1,16 +1,16 @@\n-io fn main() -> () {\n+impure fn main() -> () {\n    test00();\n }\n \n-io fn test00_start(chan[int] c, int start, int number_of_messages) {\n+impure fn test00_start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;\n     while (i < number_of_messages) {\n         c <| start + i;\n         i += 1;\n     }    \n }\n \n-io fn test00() {\n+impure fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}]}