{"sha": "29bc94ff0de00d79aa10c47603701592e1d3e340", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YmM5NGZmMGRlMDBkNzlhYTEwYzQ3NjAzNzAxNTkyZTFkM2UzNDA=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-07-30T22:12:11Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-08-31T01:18:42Z"}, "message": "Handle let-else initializer edge case errors", "tree": {"sha": "ed0f44897097c71bc2085629289a6ba8cfa4375e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed0f44897097c71bc2085629289a6ba8cfa4375e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29bc94ff0de00d79aa10c47603701592e1d3e340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29bc94ff0de00d79aa10c47603701592e1d3e340", "html_url": "https://github.com/rust-lang/rust/commit/29bc94ff0de00d79aa10c47603701592e1d3e340", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29bc94ff0de00d79aa10c47603701592e1d3e340/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f4e86b9ef457ff7b465e73e3aaabfcaa1d9d8e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f4e86b9ef457ff7b465e73e3aaabfcaa1d9d8e1", "html_url": "https://github.com/rust-lang/rust/commit/2f4e86b9ef457ff7b465e73e3aaabfcaa1d9d8e1"}], "stats": {"total": 116, "additions": 101, "deletions": 15}, "files": [{"sha": "6ea3db6d3037252c5a2c371e2a6dabe50aebbf26", "filename": "compiler/rustc_ast/src/util/classify.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/29bc94ff0de00d79aa10c47603701592e1d3e340/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc94ff0de00d79aa10c47603701592e1d3e340/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs?ref=29bc94ff0de00d79aa10c47603701592e1d3e340", "patch": "@@ -23,3 +23,30 @@ pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n             | ast::ExprKind::TryBlock(..)\n     )\n }\n+\n+/// If an expression ends with `}`, returns the innermost expression ending in the `}`\n+pub fn expr_trailing_brace(mut expr: &ast::Expr) -> Option<&ast::Expr> {\n+    use ast::ExprKind::*;\n+\n+    loop {\n+        match &expr.kind {\n+            AddrOf(_, _, e)\n+            | Assign(_, e, _)\n+            | AssignOp(_, _, e)\n+            | Binary(_, _, e)\n+            | Box(e)\n+            | Break(_, Some(e))\n+            | Closure(.., e, _)\n+            | Let(_, e, _)\n+            | Range(_, Some(e), _)\n+            | Ret(Some(e))\n+            | Unary(_, e)\n+            | Yield(Some(e)) => {\n+                expr = e;\n+            }\n+            Async(..) | Block(..) | ForLoop(..) | If(..) | Loop(..) | Match(..) | Struct(..)\n+            | TryBlock(..) | While(..) => break Some(expr),\n+            _ => break None,\n+        }\n+    }\n+}"}, {"sha": "f04ac8dd9426ff4d7b32bc81cf705f56fcb5362f", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/29bc94ff0de00d79aa10c47603701592e1d3e340/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc94ff0de00d79aa10c47603701592e1d3e340/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=29bc94ff0de00d79aa10c47603701592e1d3e340", "patch": "@@ -1,7 +1,7 @@\n use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n-use rustc_ast::util::parser;\n+use rustc_ast::util::{classify, parser};\n use rustc_ast::{ExprKind, StmtKind};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{pluralize, Applicability};\n@@ -382,6 +382,7 @@ enum UnusedDelimsCtx {\n     FunctionArg,\n     MethodArg,\n     AssignedValue,\n+    AssignedValueLetElse,\n     IfCond,\n     WhileCond,\n     ForIterExpr,\n@@ -398,7 +399,9 @@ impl From<UnusedDelimsCtx> for &'static str {\n         match ctx {\n             UnusedDelimsCtx::FunctionArg => \"function argument\",\n             UnusedDelimsCtx::MethodArg => \"method argument\",\n-            UnusedDelimsCtx::AssignedValue => \"assigned value\",\n+            UnusedDelimsCtx::AssignedValue | UnusedDelimsCtx::AssignedValueLetElse => {\n+                \"assigned value\"\n+            }\n             UnusedDelimsCtx::IfCond => \"`if` condition\",\n             UnusedDelimsCtx::WhileCond => \"`while` condition\",\n             UnusedDelimsCtx::ForIterExpr => \"`for` iterator expression\",\n@@ -441,14 +444,26 @@ trait UnusedDelimLint {\n         right_pos: Option<BytePos>,\n     );\n \n-    fn is_expr_delims_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n+    fn is_expr_delims_necessary(\n+        inner: &ast::Expr,\n+        followed_by_block: bool,\n+        followed_by_else: bool,\n+    ) -> bool {\n+        if followed_by_else {\n+            match inner.kind {\n+                ast::ExprKind::Binary(op, ..) if op.node.lazy() => return true,\n+                _ if classify::expr_trailing_brace(inner).is_some() => return true,\n+                _ => {}\n+            }\n+        }\n+\n         // Prevent false-positives in cases like `fn x() -> u8 { ({ 0 } + 1) }`\n         let lhs_needs_parens = {\n             let mut innermost = inner;\n             loop {\n                 if let ExprKind::Binary(_, lhs, _rhs) = &innermost.kind {\n                     innermost = lhs;\n-                    if !rustc_ast::util::classify::expr_requires_semi_to_be_stmt(innermost) {\n+                    if !classify::expr_requires_semi_to_be_stmt(innermost) {\n                         break true;\n                     }\n                 } else {\n@@ -618,15 +633,12 @@ trait UnusedDelimLint {\n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n         match s.kind {\n             StmtKind::Local(ref local) if Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX => {\n-                if let Some(value) = local.kind.init() {\n-                    self.check_unused_delims_expr(\n-                        cx,\n-                        &value,\n-                        UnusedDelimsCtx::AssignedValue,\n-                        false,\n-                        None,\n-                        None,\n-                    );\n+                if let Some((init, els)) = local.kind.init_else_opt() {\n+                    let ctx = match els {\n+                        None => UnusedDelimsCtx::AssignedValue,\n+                        Some(_) => UnusedDelimsCtx::AssignedValueLetElse,\n+                    };\n+                    self.check_unused_delims_expr(cx, init, ctx, false, None, None);\n                 }\n             }\n             StmtKind::Expr(ref expr) => {\n@@ -702,7 +714,8 @@ impl UnusedDelimLint for UnusedParens {\n     ) {\n         match value.kind {\n             ast::ExprKind::Paren(ref inner) => {\n-                if !Self::is_expr_delims_necessary(inner, followed_by_block)\n+                let followed_by_else = ctx == UnusedDelimsCtx::AssignedValueLetElse;\n+                if !Self::is_expr_delims_necessary(inner, followed_by_block, followed_by_else)\n                     && value.attrs.is_empty()\n                     && !value.span.from_expansion()\n                     && (ctx != UnusedDelimsCtx::LetScrutineeExpr\n@@ -941,7 +954,7 @@ impl UnusedDelimLint for UnusedBraces {\n                 // FIXME(const_generics): handle paths when #67075 is fixed.\n                 if let [stmt] = inner.stmts.as_slice() {\n                     if let ast::StmtKind::Expr(ref expr) = stmt.kind {\n-                        if !Self::is_expr_delims_necessary(expr, followed_by_block)\n+                        if !Self::is_expr_delims_necessary(expr, followed_by_block, false)\n                             && (ctx != UnusedDelimsCtx::AnonConst\n                                 || matches!(expr.kind, ast::ExprKind::Lit(_)))\n                             && !cx.sess().source_map().is_multiline(value.span)"}, {"sha": "068bd36af55240c8e2f4c1e3ec1d4b1c7884b7d6", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/29bc94ff0de00d79aa10c47603701592e1d3e340/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc94ff0de00d79aa10c47603701592e1d3e340/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=29bc94ff0de00d79aa10c47603701592e1d3e340", "patch": "@@ -298,6 +298,8 @@ impl<'a> Parser<'a> {\n             Some(init) => {\n                 if self.eat_keyword(kw::Else) {\n                     let els = self.parse_block()?;\n+                    self.check_let_else_init_bool_expr(&init);\n+                    self.check_let_else_init_trailing_brace(&init);\n                     LocalKind::InitElse(init, els)\n                 } else {\n                     LocalKind::Init(init)\n@@ -308,6 +310,50 @@ impl<'a> Parser<'a> {\n         Ok(P(ast::Local { ty, pat, kind, id: DUMMY_NODE_ID, span: lo.to(hi), attrs, tokens: None }))\n     }\n \n+    fn check_let_else_init_bool_expr(&self, init: &ast::Expr) {\n+        if let ast::ExprKind::Binary(op, ..) = init.kind {\n+            if op.node.lazy() {\n+                let suggs = vec![\n+                    (init.span.shrink_to_lo(), \"(\".to_string()),\n+                    (init.span.shrink_to_hi(), \")\".to_string()),\n+                ];\n+                self.struct_span_err(\n+                    init.span,\n+                    &format!(\n+                        \"a `{}` expression cannot be directly assigned in `let...else`\",\n+                        op.node.to_string()\n+                    ),\n+                )\n+                .multipart_suggestion(\n+                    \"wrap the expression in parenthesis\",\n+                    suggs,\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+            }\n+        }\n+    }\n+\n+    fn check_let_else_init_trailing_brace(&self, init: &ast::Expr) {\n+        if let Some(trailing) = classify::expr_trailing_brace(init) {\n+            let err_span = trailing.span.with_lo(trailing.span.hi() - BytePos(1));\n+            let suggs = vec![\n+                (trailing.span.shrink_to_lo(), \"(\".to_string()),\n+                (trailing.span.shrink_to_hi(), \")\".to_string()),\n+            ];\n+            self.struct_span_err(\n+                err_span,\n+                \"right curly brace `}` before `else` in a `let...else` statement not allowed\",\n+            )\n+            .multipart_suggestion(\n+                \"try wrapping the expression in parenthesis\",\n+                suggs,\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+        }\n+    }\n+\n     /// Parses the RHS of a local variable declaration (e.g., `= 14;`).\n     fn parse_initializer(&mut self, eq_optional: bool) -> PResult<'a, Option<P<Expr>>> {\n         let eq_consumed = match self.token.kind {"}]}