{"sha": "94517d397c3812d6b8064078a5b494b9f7a79df7", "node_id": "C_kwDOAAsO6NoAKDk0NTE3ZDM5N2MzODEyZDZiODA2NDA3OGE1YjQ5NGI5ZjdhNzlkZjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-08T13:39:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-08T13:39:58Z"}, "message": "Auto merge of #7938 - camsteffen:visitors, r=xFrednet\n\nIntroduce `expr_visitor` and `expr_visitor_no_bodies`\n\nchangelog: none\n\nA couple utils that satisfy a *lot* of visitor use cases. Factoring in every possible usage would be really big so I just focused on cleaning clippy_utils.", "tree": {"sha": "76107c1f31785a25d6734a16d37e1b55e212fdac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76107c1f31785a25d6734a16d37e1b55e212fdac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94517d397c3812d6b8064078a5b494b9f7a79df7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94517d397c3812d6b8064078a5b494b9f7a79df7", "html_url": "https://github.com/rust-lang/rust/commit/94517d397c3812d6b8064078a5b494b9f7a79df7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94517d397c3812d6b8064078a5b494b9f7a79df7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fcdf819391585804014e1cabfc2dd03073c9169", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fcdf819391585804014e1cabfc2dd03073c9169", "html_url": "https://github.com/rust-lang/rust/commit/6fcdf819391585804014e1cabfc2dd03073c9169"}, {"sha": "2c7b7e8c56849d272dc7acbd5f0ad0ec02c06e52", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c7b7e8c56849d272dc7acbd5f0ad0ec02c06e52", "html_url": "https://github.com/rust-lang/rust/commit/2c7b7e8c56849d272dc7acbd5f0ad0ec02c06e52"}], "stats": {"total": 468, "additions": 160, "deletions": 308}, "files": [{"sha": "8def6529b3bc72e9f0d2c10d5d867d3ebafe7c63", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=94517d397c3812d6b8064078a5b494b9f7a79df7", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::higher::VecArgs;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::usage::UsedAfterExprVisitor;\n-use clippy_utils::{get_enclosing_loop_or_closure, higher, path_to_local_id};\n+use clippy_utils::usage::local_used_after_expr;\n+use clippy_utils::{get_enclosing_loop_or_closure, higher, path_to_local, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n@@ -118,7 +118,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n                             if let ty::Closure(_, substs) = callee_ty.peel_refs().kind();\n                             if substs.as_closure().kind() == ClosureKind::FnMut;\n                             if get_enclosing_loop_or_closure(cx.tcx, expr).is_some()\n-                                || UsedAfterExprVisitor::is_found(cx, callee);\n+                                || path_to_local(callee).map_or(false, |l| local_used_after_expr(cx, l, callee));\n \n                             then {\n                                 // Mutable closure is used after current expr; we cannot consume it."}, {"sha": "bb30accf145429d9208c06b7a420bd9f11c1d11b", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=94517d397c3812d6b8064078a5b494b9f7a79df7", "patch": "@@ -10,7 +10,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_middle::ty::Ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{sym, BytePos, ExpnData, ExpnKind, Span, Symbol};\n+use rustc_span::{sym, ExpnData, ExpnKind, Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -128,7 +128,7 @@ fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symb\n             span_lint_and_then(\n                 cx,\n                 FORMAT_IN_FORMAT_ARGS,\n-                trim_semicolon(cx, call_site),\n+                call_site,\n                 &format!(\"`format!` in `{}!` args\", name),\n                 |diag| {\n                     diag.help(&format!(\n@@ -192,13 +192,6 @@ fn is_aliased(args: &[FormatArgsArg<'_>], i: usize) -> bool {\n         .any(|(j, arg)| i != j && std::ptr::eq(value, arg.value))\n }\n \n-fn trim_semicolon(cx: &LateContext<'_>, span: Span) -> Span {\n-    snippet_opt(cx, span).map_or(span, |snippet| {\n-        let snippet = snippet.trim_end_matches(';');\n-        span.with_hi(span.lo() + BytePos(u32::try_from(snippet.len()).unwrap()))\n-    })\n-}\n-\n fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)\n where\n     I: Iterator<Item = &'tcx Adjustment<'tcx>>,"}, {"sha": "6d7c71d4082f6e8ad06f599ddc8eee83c32906b3", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=94517d397c3812d6b8064078a5b494b9f7a79df7", "patch": "@@ -2,10 +2,10 @@ use clippy_utils::{\n     diagnostics::span_lint_and_sugg,\n     get_async_fn_body, is_async_fn,\n     source::{snippet_with_applicability, snippet_with_context, walk_span_to_context},\n-    visitors::visit_break_exprs,\n+    visitors::expr_visitor_no_bodies,\n };\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::FnKind;\n+use rustc_hir::intravisit::{FnKind, Visitor};\n use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, FnRetTy, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -144,20 +144,24 @@ fn lint_implicit_returns(\n \n         ExprKind::Loop(block, ..) => {\n             let mut add_return = false;\n-            visit_break_exprs(block, |break_expr, dest, sub_expr| {\n-                if dest.target_id.ok() == Some(expr.hir_id) {\n-                    if call_site_span.is_none() && break_expr.span.ctxt() == ctxt {\n-                        // At this point sub_expr can be `None` in async functions which either diverge, or return the\n-                        // unit type.\n-                        if let Some(sub_expr) = sub_expr {\n-                            lint_break(cx, break_expr.span, sub_expr.span);\n+            expr_visitor_no_bodies(|e| {\n+                if let ExprKind::Break(dest, sub_expr) = e.kind {\n+                    if dest.target_id.ok() == Some(expr.hir_id) {\n+                        if call_site_span.is_none() && e.span.ctxt() == ctxt {\n+                            // At this point sub_expr can be `None` in async functions which either diverge, or return\n+                            // the unit type.\n+                            if let Some(sub_expr) = sub_expr {\n+                                lint_break(cx, e.span, sub_expr.span);\n+                            }\n+                        } else {\n+                            // the break expression is from a macro call, add a return to the loop\n+                            add_return = true;\n                         }\n-                    } else {\n-                        // the break expression is from a macro call, add a return to the loop\n-                        add_return = true;\n                     }\n                 }\n-            });\n+                true\n+            })\n+            .visit_block(block);\n             if add_return {\n                 #[allow(clippy::option_if_let_else)]\n                 if let Some(span) = call_site_span {"}, {"sha": "88b1685f52f25172b36858c368680c75bf1d51d0", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=94517d397c3812d6b8064078a5b494b9f7a79df7", "patch": "@@ -632,9 +632,6 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         if let ExprKind::Match(ex, arms, _) = expr.kind {\n             check_match_ref_pats(cx, ex, arms.iter().map(|el| el.pat), expr);\n         }\n-        if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(cx, expr) {\n-            check_match_ref_pats(cx, let_expr, once(let_pat), expr);\n-        }\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {"}, {"sha": "e4e6c5ddbb2346eef8f067b823278ba96c77e1f7", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 20, "deletions": 51, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=94517d397c3812d6b8064078a5b494b9f7a79df7", "patch": "@@ -1,6 +1,7 @@\n #![feature(box_patterns)]\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n+#![feature(let_else)]\n #![feature(rustc_private)]\n #![feature(control_flow_enum)]\n #![recursion_limit = \"512\"]\n@@ -68,7 +69,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n-use rustc_hir::intravisit::{self, walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n@@ -96,6 +97,7 @@ use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n use crate::ty::{can_partially_move_ty, is_copy, is_recursively_primitive_type};\n+use crate::visitors::expr_visitor_no_bodies;\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -1107,63 +1109,30 @@ pub fn contains_name(name: Symbol, expr: &Expr<'_>) -> bool {\n \n /// Returns `true` if `expr` contains a return expression\n pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n-    struct RetCallFinder {\n-        found: bool,\n-    }\n-\n-    impl<'tcx> hir::intravisit::Visitor<'tcx> for RetCallFinder {\n-        type Map = Map<'tcx>;\n-\n-        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-            if self.found {\n-                return;\n-            }\n+    let mut found = false;\n+    expr_visitor_no_bodies(|expr| {\n+        if !found {\n             if let hir::ExprKind::Ret(..) = &expr.kind {\n-                self.found = true;\n-            } else {\n-                hir::intravisit::walk_expr(self, expr);\n+                found = true;\n             }\n         }\n-\n-        fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n-            hir::intravisit::NestedVisitorMap::None\n-        }\n-    }\n-\n-    let mut visitor = RetCallFinder { found: false };\n-    visitor.visit_expr(expr);\n-    visitor.found\n-}\n-\n-struct FindMacroCalls<'a, 'b> {\n-    names: &'a [&'b str],\n-    result: Vec<Span>,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for FindMacroCalls<'a, 'b> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n-            self.result.push(expr.span);\n-        }\n-        // and check sub-expressions\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n+        !found\n+    })\n+    .visit_expr(expr);\n+    found\n }\n \n /// Finds calls of the specified macros in a function body.\n pub fn find_macro_calls(names: &[&str], body: &Body<'_>) -> Vec<Span> {\n-    let mut fmc = FindMacroCalls {\n-        names,\n-        result: Vec::new(),\n-    };\n-    fmc.visit_expr(&body.value);\n-    fmc.result\n+    let mut result = Vec::new();\n+    expr_visitor_no_bodies(|expr| {\n+        if names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n+            result.push(expr.span);\n+        }\n+        true\n+    })\n+    .visit_expr(&body.value);\n+    result\n }\n \n /// Extends the span to the beginning of the spans line, incl. whitespaces."}, {"sha": "17d9a505bc9df7a601c81cd8639b3bcb701ae2ac", "filename": "clippy_utils/src/ptr.rs", "status": "modified", "additions": 18, "deletions": 40, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=94517d397c3812d6b8064078a5b494b9f7a79df7", "patch": "@@ -1,9 +1,9 @@\n use crate::source::snippet;\n+use crate::visitors::expr_visitor_no_bodies;\n use crate::{path_to_local_id, strip_pat_refs};\n-use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Body, BodyId, Expr, ExprKind, HirId, PatKind};\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{Body, BodyId, ExprKind, HirId, PatKind};\n use rustc_lint::LateContext;\n-use rustc_middle::hir::map::Map;\n use rustc_span::Span;\n use std::borrow::Cow;\n \n@@ -30,50 +30,28 @@ fn extract_clone_suggestions<'tcx>(\n     replace: &[(&'static str, &'static str)],\n     body: &'tcx Body<'_>,\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n-    let mut visitor = PtrCloneVisitor {\n-        cx,\n-        id,\n-        replace,\n-        spans: vec![],\n-        abort: false,\n-    };\n-    visitor.visit_body(body);\n-    if visitor.abort { None } else { Some(visitor.spans) }\n-}\n-\n-struct PtrCloneVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    id: HirId,\n-    replace: &'a [(&'static str, &'static str)],\n-    spans: Vec<(Span, Cow<'static, str>)>,\n-    abort: bool,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.abort {\n-            return;\n+    let mut abort = false;\n+    let mut spans = Vec::new();\n+    expr_visitor_no_bodies(|expr| {\n+        if abort {\n+            return false;\n         }\n         if let ExprKind::MethodCall(seg, _, [recv], _) = expr.kind {\n-            if path_to_local_id(recv, self.id) {\n+            if path_to_local_id(recv, id) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n-                    self.abort = true;\n-                    return;\n+                    abort = true;\n+                    return false;\n                 }\n-                for &(fn_name, suffix) in self.replace {\n+                for &(fn_name, suffix) in replace {\n                     if seg.ident.name.as_str() == fn_name {\n-                        self.spans.push((expr.span, snippet(self.cx, recv.span, \"_\") + suffix));\n-                        return;\n+                        spans.push((expr.span, snippet(cx, recv.span, \"_\") + suffix));\n+                        return false;\n                     }\n                 }\n             }\n         }\n-        walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n+        !abort\n+    })\n+    .visit_body(body);\n+    if abort { None } else { Some(spans) }\n }"}, {"sha": "dfe8a66c2a1b53f9b3d48b2352460491b3906454", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 30, "deletions": 79, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=94517d397c3812d6b8064078a5b494b9f7a79df7", "patch": "@@ -1,7 +1,7 @@\n use crate as utils;\n+use crate::visitors::{expr_visitor, expr_visitor_no_bodies};\n use rustc_hir as hir;\n-use rustc_hir::intravisit;\n-use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::HirIdSet;\n use rustc_hir::{Expr, ExprKind, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -148,96 +148,47 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for BindingUsageFinder<'a, 'tcx> {\n     }\n }\n \n-struct ReturnBreakContinueMacroVisitor {\n-    seen_return_break_continue: bool,\n-}\n-\n-impl ReturnBreakContinueMacroVisitor {\n-    fn new() -> ReturnBreakContinueMacroVisitor {\n-        ReturnBreakContinueMacroVisitor {\n-            seen_return_break_continue: false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ReturnBreakContinueMacroVisitor {\n-    type Map = Map<'tcx>;\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-        if self.seen_return_break_continue {\n-            // No need to look farther if we've already seen one of them\n-            return;\n+pub fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n+    let mut seen_return_break_continue = false;\n+    expr_visitor_no_bodies(|ex| {\n+        if seen_return_break_continue {\n+            return false;\n         }\n         match &ex.kind {\n             ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => {\n-                self.seen_return_break_continue = true;\n+                seen_return_break_continue = true;\n             },\n             // Something special could be done here to handle while or for loop\n             // desugaring, as this will detect a break if there's a while loop\n             // or a for loop inside the expression.\n             _ => {\n                 if ex.span.from_expansion() {\n-                    self.seen_return_break_continue = true;\n-                } else {\n-                    rustc_hir::intravisit::walk_expr(self, ex);\n+                    seen_return_break_continue = true;\n                 }\n             },\n         }\n-    }\n-}\n-\n-pub fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n-    let mut recursive_visitor = ReturnBreakContinueMacroVisitor::new();\n-    recursive_visitor.visit_expr(expression);\n-    recursive_visitor.seen_return_break_continue\n-}\n-\n-pub struct UsedAfterExprVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    expr: &'tcx Expr<'tcx>,\n-    definition: HirId,\n-    past_expr: bool,\n-    used_after_expr: bool,\n-}\n-impl<'a, 'tcx> UsedAfterExprVisitor<'a, 'tcx> {\n-    pub fn is_found(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-        utils::path_to_local(expr).map_or(false, |definition| {\n-            let mut visitor = UsedAfterExprVisitor {\n-                cx,\n-                expr,\n-                definition,\n-                past_expr: false,\n-                used_after_expr: false,\n-            };\n-            utils::get_enclosing_block(cx, definition).map_or(false, |block| {\n-                visitor.visit_block(block);\n-                visitor.used_after_expr\n-            })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for UsedAfterExprVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if self.used_after_expr {\n-            return;\n+        !seen_return_break_continue\n+    })\n+    .visit_expr(expression);\n+    seen_return_break_continue\n+}\n+\n+pub fn local_used_after_expr(cx: &LateContext<'_>, local_id: HirId, after: &Expr<'_>) -> bool {\n+    let Some(block) = utils::get_enclosing_block(cx, local_id) else { return false };\n+    let mut used_after_expr = false;\n+    let mut past_expr = false;\n+    expr_visitor(cx, |expr| {\n+        if used_after_expr {\n+            return false;\n         }\n \n-        if expr.hir_id == self.expr.hir_id {\n-            self.past_expr = true;\n-        } else if self.past_expr && utils::path_to_local_id(expr, self.definition) {\n-            self.used_after_expr = true;\n-        } else {\n-            intravisit::walk_expr(self, expr);\n+        if expr.hir_id == after.hir_id {\n+            past_expr = true;\n+        } else if past_expr && utils::path_to_local_id(expr, local_id) {\n+            used_after_expr = true;\n         }\n-    }\n+        !used_after_expr\n+    })\n+    .visit_block(block);\n+    used_after_expr\n }"}, {"sha": "988f6cf1d511338efb6fe8689cc24d5cfafc10c7", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 70, "deletions": 110, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94517d397c3812d6b8064078a5b494b9f7a79df7/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=94517d397c3812d6b8064078a5b494b9f7a79df7", "patch": "@@ -1,38 +1,66 @@\n use crate::path_to_local_id;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{def::Res, Arm, Block, Body, BodyId, Destination, Expr, ExprKind, HirId, Stmt};\n+use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{def::Res, Arm, Block, Body, BodyId, Expr, ExprKind, HirId, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use std::ops::ControlFlow;\n \n-/// returns `true` if expr contains match expr desugared from try\n-fn contains_try(expr: &hir::Expr<'_>) -> bool {\n-    struct TryFinder {\n-        found: bool,\n+/// Convenience method for creating a `Visitor` with just `visit_expr` overridden and nested\n+/// bodies (i.e. closures) are visited.\n+/// If the callback returns `true`, the expr just provided to the callback is walked.\n+#[must_use]\n+pub fn expr_visitor<'tcx>(cx: &LateContext<'tcx>, f: impl FnMut(&'tcx Expr<'tcx>) -> bool) -> impl Visitor<'tcx> {\n+    struct V<'tcx, F> {\n+        hir: Map<'tcx>,\n+        f: F,\n     }\n+    impl<'tcx, F: FnMut(&'tcx Expr<'tcx>) -> bool> Visitor<'tcx> for V<'tcx, F> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::OnlyBodies(self.hir)\n+        }\n \n-    impl<'hir> intravisit::Visitor<'hir> for TryFinder {\n-        type Map = Map<'hir>;\n+        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+            if (self.f)(expr) {\n+                walk_expr(self, expr);\n+            }\n+        }\n+    }\n+    V { hir: cx.tcx.hir(), f }\n+}\n \n-        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-            intravisit::NestedVisitorMap::None\n+/// Convenience method for creating a `Visitor` with just `visit_expr` overridden and nested\n+/// bodies (i.e. closures) are not visited.\n+/// If the callback returns `true`, the expr just provided to the callback is walked.\n+#[must_use]\n+pub fn expr_visitor_no_bodies<'tcx>(f: impl FnMut(&'tcx Expr<'tcx>) -> bool) -> impl Visitor<'tcx> {\n+    struct V<F>(F);\n+    impl<'tcx, F: FnMut(&'tcx Expr<'tcx>) -> bool> Visitor<'tcx> for V<F> {\n+        type Map = intravisit::ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n         }\n \n-        fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n-            if self.found {\n-                return;\n-            }\n-            match expr.kind {\n-                hir::ExprKind::Match(_, _, hir::MatchSource::TryDesugar) => self.found = true,\n-                _ => intravisit::walk_expr(self, expr),\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if (self.0)(e) {\n+                walk_expr(self, e);\n             }\n         }\n     }\n+    V(f)\n+}\n \n-    let mut visitor = TryFinder { found: false };\n-    visitor.visit_expr(expr);\n-    visitor.found\n+/// returns `true` if expr contains match expr desugared from try\n+fn contains_try(expr: &hir::Expr<'_>) -> bool {\n+    let mut found = false;\n+    expr_visitor_no_bodies(|e| {\n+        if !found {\n+            found = matches!(e.kind, hir::ExprKind::Match(_, _, hir::MatchSource::TryDesugar));\n+        }\n+        !found\n+    })\n+    .visit_expr(expr);\n+    found\n }\n \n pub fn find_all_ret_expressions<'hir, F>(_cx: &LateContext<'_>, expr: &'hir hir::Expr<'hir>, callback: F) -> bool\n@@ -165,103 +193,35 @@ visitable_ref!(Stmt, visit_stmt);\n //     }\n // }\n \n-/// Calls the given function for each break expression.\n-pub fn visit_break_exprs<'tcx>(\n-    node: impl Visitable<'tcx>,\n-    f: impl FnMut(&'tcx Expr<'tcx>, Destination, Option<&'tcx Expr<'tcx>>),\n-) {\n-    struct V<F>(F);\n-    impl<'tcx, F: FnMut(&'tcx Expr<'tcx>, Destination, Option<&'tcx Expr<'tcx>>)> Visitor<'tcx> for V<F> {\n-        type Map = ErasedMap<'tcx>;\n-        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-            NestedVisitorMap::None\n-        }\n-\n-        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-            if let ExprKind::Break(dest, sub_expr) = e.kind {\n-                self.0(e, dest, sub_expr);\n-            }\n-            walk_expr(self, e);\n-        }\n-    }\n-\n-    node.visit(&mut V(f));\n-}\n-\n /// Checks if the given resolved path is used in the given body.\n pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n-    struct V<'a, 'tcx> {\n-        cx: &'a LateContext<'tcx>,\n-        res: Res,\n-        found: bool,\n-    }\n-    impl Visitor<'tcx> for V<'_, 'tcx> {\n-        type Map = Map<'tcx>;\n-        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-            NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    let mut found = false;\n+    expr_visitor(cx, |e| {\n+        if found {\n+            return false;\n         }\n \n-        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-            if self.found {\n-                return;\n-            }\n-\n-            if let ExprKind::Path(p) = &e.kind {\n-                if self.cx.qpath_res(p, e.hir_id) == self.res {\n-                    self.found = true;\n-                }\n-            } else {\n-                walk_expr(self, e);\n+        if let ExprKind::Path(p) = &e.kind {\n+            if cx.qpath_res(p, e.hir_id) == res {\n+                found = true;\n             }\n         }\n-    }\n-\n-    let mut v = V { cx, res, found: false };\n-    v.visit_expr(&cx.tcx.hir().body(body).value);\n-    v.found\n-}\n-\n-/// Calls the given function for each usage of the given local.\n-pub fn for_each_local_usage<'tcx, B>(\n-    cx: &LateContext<'tcx>,\n-    visitable: impl Visitable<'tcx>,\n-    id: HirId,\n-    f: impl FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>,\n-) -> ControlFlow<B> {\n-    struct V<'tcx, B, F> {\n-        map: Map<'tcx>,\n-        id: HirId,\n-        f: F,\n-        res: ControlFlow<B>,\n-    }\n-    impl<'tcx, B, F: FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>> Visitor<'tcx> for V<'tcx, B, F> {\n-        type Map = Map<'tcx>;\n-        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-            NestedVisitorMap::OnlyBodies(self.map)\n-        }\n-\n-        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-            if self.res.is_continue() {\n-                if path_to_local_id(e, self.id) {\n-                    self.res = (self.f)(e);\n-                } else {\n-                    walk_expr(self, e);\n-                }\n-            }\n-        }\n-    }\n-\n-    let mut v = V {\n-        map: cx.tcx.hir(),\n-        id,\n-        f,\n-        res: ControlFlow::CONTINUE,\n-    };\n-    visitable.visit(&mut v);\n-    v.res\n+        !found\n+    })\n+    .visit_expr(&cx.tcx.hir().body(body).value);\n+    found\n }\n \n /// Checks if the given local is used.\n pub fn is_local_used(cx: &LateContext<'tcx>, visitable: impl Visitable<'tcx>, id: HirId) -> bool {\n-    for_each_local_usage(cx, visitable, id, |_| ControlFlow::BREAK).is_break()\n+    let mut is_used = false;\n+    let mut visitor = expr_visitor(cx, |expr| {\n+        if !is_used {\n+            is_used = path_to_local_id(expr, id);\n+        }\n+        !is_used\n+    });\n+    visitable.visit(&mut visitor);\n+    drop(visitor);\n+    is_used\n }"}]}