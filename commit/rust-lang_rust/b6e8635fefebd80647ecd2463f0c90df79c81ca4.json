{"sha": "b6e8635fefebd80647ecd2463f0c90df79c81ca4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ZTg2MzVmZWZlYmQ4MDY0N2VjZDI0NjNmMGM5MGRmNzljODFjYTQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-06-02T13:45:56Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-06-06T11:50:13Z"}, "message": "ICH: Make StableHashingContext work with any TyCtxt, not just the global one.", "tree": {"sha": "891428d11ae31409bb0c293186ee6235f748bfb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/891428d11ae31409bb0c293186ee6235f748bfb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6e8635fefebd80647ecd2463f0c90df79c81ca4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e8635fefebd80647ecd2463f0c90df79c81ca4", "html_url": "https://github.com/rust-lang/rust/commit/b6e8635fefebd80647ecd2463f0c90df79c81ca4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6e8635fefebd80647ecd2463f0c90df79c81ca4/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9006db1fb0a543f927398b86cf4475ad3ec332da", "url": "https://api.github.com/repos/rust-lang/rust/commits/9006db1fb0a543f927398b86cf4475ad3ec332da", "html_url": "https://github.com/rust-lang/rust/commit/9006db1fb0a543f927398b86cf4475ad3ec332da"}], "stats": {"total": 447, "additions": 239, "deletions": 208}, "files": [{"sha": "bf47b9bb9d43d5e3b800c46e3efcc1cc7ab6ae3b", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -29,8 +29,8 @@ pub struct CachingCodemapView<'tcx> {\n     time_stamp: usize,\n }\n \n-impl<'tcx> CachingCodemapView<'tcx> {\n-    pub fn new<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CachingCodemapView<'tcx> {\n+impl<'gcx> CachingCodemapView<'gcx> {\n+    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> CachingCodemapView<'gcx> {\n         let codemap = tcx.sess.codemap();\n         let files = codemap.files();\n         let first_file = files[0].clone();"}, {"sha": "2784a7bd024f66553512dd5563979f7b424bb54f", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -33,9 +33,9 @@ use rustc_data_structures::accumulate_vec::AccumulateVec;\n /// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n /// things (e.g. each DefId/DefPath is only hashed once).\n-pub struct StableHashingContext<'a, 'tcx: 'a> {\n-    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    codemap: CachingCodemapView<'tcx>,\n+pub struct StableHashingContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: ty::TyCtxt<'a, 'gcx, 'tcx>,\n+    codemap: CachingCodemapView<'gcx>,\n     hash_spans: bool,\n     hash_bodies: bool,\n     overflow_checks_enabled: bool,\n@@ -51,9 +51,9 @@ pub enum NodeIdHashingMode {\n     HashTraitsInScope,\n }\n \n-impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n \n-    pub fn new(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+    pub fn new(tcx: ty::TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n         let hash_spans_initial = tcx.sess.opts.debuginfo != NoDebugInfo;\n         let check_overflow_initial = tcx.sess.overflow_checks();\n \n@@ -111,7 +111,7 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn tcx(&self) -> ty::TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -131,7 +131,7 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn codemap(&mut self) -> &mut CachingCodemapView<'tcx> {\n+    pub fn codemap(&mut self) -> &mut CachingCodemapView<'gcx> {\n         &mut self.codemap\n     }\n \n@@ -195,9 +195,9 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n }\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::NodeId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::NodeId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::NodeId {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n \n     // Hash a span in a stable way. We can't directly hash the span's BytePos\n     // fields (that would be similar to hashing pointers, since those are just\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n     // Also, hashing filenames is expensive so we avoid doing it twice when the\n     // span starts and ends in the same file, which is almost always the case.\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use syntax_pos::Pos;\n \n@@ -305,15 +305,16 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n     }\n }\n \n-pub fn hash_stable_hashmap<'a, 'tcx, K, V, R, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                                        hasher: &mut StableHasher<W>,\n-                                                        map: &HashMap<K, V, R>,\n-                                                        extract_stable_key: F)\n+pub fn hash_stable_hashmap<'a, 'gcx, 'tcx, K, V, R, SK, F, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &HashMap<K, V, R>,\n+    extract_stable_key: F)\n     where K: Eq + std_hash::Hash,\n-          V: HashStable<StableHashingContext<'a, 'tcx>>,\n+          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n           R: std_hash::BuildHasher,\n-          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n           W: StableHasherResult,\n {\n     let mut keys: Vec<_> = map.keys()\n@@ -327,14 +328,15 @@ pub fn hash_stable_hashmap<'a, 'tcx, K, V, R, SK, F, W>(hcx: &mut StableHashingC\n     }\n }\n \n-pub fn hash_stable_hashset<'a, 'tcx, K, R, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                                     hasher: &mut StableHasher<W>,\n-                                                     set: &HashSet<K, R>,\n-                                                     extract_stable_key: F)\n+pub fn hash_stable_hashset<'a, 'tcx, 'gcx, K, R, SK, F, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    set: &HashSet<K, R>,\n+    extract_stable_key: F)\n     where K: Eq + std_hash::Hash,\n           R: std_hash::BuildHasher,\n-          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n           W: StableHasherResult,\n {\n     let mut keys: Vec<_> = set.iter()\n@@ -344,10 +346,11 @@ pub fn hash_stable_hashset<'a, 'tcx, K, R, SK, F, W>(hcx: &mut StableHashingCont\n     keys.hash_stable(hcx, hasher);\n }\n \n-pub fn hash_stable_nodemap<'a, 'tcx, V, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                           hasher: &mut StableHasher<W>,\n-                                           map: &NodeMap<V>)\n-    where V: HashStable<StableHashingContext<'a, 'tcx>>,\n+pub fn hash_stable_nodemap<'a, 'tcx, 'gcx, V, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &NodeMap<V>)\n+    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n           W: StableHasherResult,\n {\n     hash_stable_hashmap(hcx, hasher, map, |hcx, node_id| {\n@@ -356,14 +359,15 @@ pub fn hash_stable_nodemap<'a, 'tcx, V, W>(hcx: &mut StableHashingContext<'a, 't\n }\n \n \n-pub fn hash_stable_btreemap<'a, 'tcx, K, V, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                                      hasher: &mut StableHasher<W>,\n-                                                      map: &BTreeMap<K, V>,\n-                                                      extract_stable_key: F)\n+pub fn hash_stable_btreemap<'a, 'tcx, 'gcx, K, V, SK, F, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &BTreeMap<K, V>,\n+    extract_stable_key: F)\n     where K: Eq + Ord,\n-          V: HashStable<StableHashingContext<'a, 'tcx>>,\n-          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n           W: StableHasherResult,\n {\n     let mut keys: Vec<_> = map.keys()"}, {"sha": "678ec797a86b17663435ee271c385724b274ee35", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -21,20 +21,20 @@ use syntax::ast;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for DefId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for DefId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::HirId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::HirId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::HirId {\n             owner,\n@@ -55,9 +55,9 @@ impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ItemId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ItemId {\n             id\n@@ -69,9 +69,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ItemId {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItemId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItemId {\n             node_id\n@@ -83,9 +83,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItemId {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItemId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ImplItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItemId {\n             node_id\n@@ -215,9 +215,9 @@ impl_stable_hash_for!(struct hir::TypeBinding {\n     span\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Ty {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Ty {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let node_id_hashing_mode = match self.node {\n             hir::TySlice(..)       |\n@@ -299,9 +299,9 @@ impl_stable_hash_for!(enum hir::FunctionRetTy {\n     Return(t)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitRef {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitRef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitRef {\n             ref path,\n@@ -338,9 +338,9 @@ impl_stable_hash_for!(struct hir::MacroDef {\n });\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Block {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Block {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Block {\n             ref stmts,\n@@ -386,9 +386,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Block {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Pat {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Pat {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let node_id_hashing_mode = match self.node {\n             hir::PatKind::Wild        |\n@@ -529,9 +529,9 @@ impl_stable_hash_for!(enum hir::UnsafeSource {\n     UserProvided\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Expr {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Expr {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n@@ -652,9 +652,9 @@ impl_stable_hash_for!(enum hir::LoopSource {\n     ForLoop\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::MatchSource {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::MatchSource {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use hir::MatchSource;\n \n@@ -703,9 +703,9 @@ impl_stable_hash_for!(enum hir::ScopeTarget {\n     Loop(loop_id_result)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Ident {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Ident {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ast::Ident {\n             ref name,\n@@ -716,9 +716,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Ident {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::TraitItem {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n             id,\n@@ -749,9 +749,9 @@ impl_stable_hash_for!(enum hir::TraitItemKind {\n     Type(bounds, rhs)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::ImplItem {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ImplItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n             id,\n@@ -781,9 +781,9 @@ impl_stable_hash_for!(enum hir::ImplItemKind {\n     Type(t)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Visibility {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Visibility {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -802,9 +802,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Visibility {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Defaultness {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Defaultness {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -823,9 +823,9 @@ impl_stable_hash_for!(enum hir::ImplPolarity {\n     Negative\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Mod {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Mod {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Mod {\n             inner,\n@@ -878,9 +878,9 @@ impl_stable_hash_for!(enum hir::VariantData {\n     Unit(id)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::Item {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Item {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let node_id_hashing_mode = match self.node {\n             hir::ItemExternCrate(..) |\n@@ -961,9 +961,10 @@ impl_stable_hash_for!(struct hir::ImplItemRef {\n     defaultness\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::AssociatedItemKind {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for hir::AssociatedItemKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -1008,9 +1009,9 @@ impl_stable_hash_for!(struct hir::Body {\n     value\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::BodyId {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         if hcx.hash_bodies() {\n             hcx.tcx().hir.body(*self).hash_stable(hcx, hasher);\n@@ -1024,9 +1025,9 @@ impl_stable_hash_for!(struct hir::InlineAsmOutput {\n     is_indirect\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::GlobalAsm {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::GlobalAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::GlobalAsm {\n             asm,\n@@ -1037,9 +1038,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::GlobalAsm {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::InlineAsm {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::InlineAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::InlineAsm {\n             asm,\n@@ -1114,10 +1115,11 @@ impl_stable_hash_for!(enum hir::Constness {\n     NotConst\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for hir::def_id::DefIndex {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         DefId::local(*self).hash_stable(hcx, hasher);\n     }\n@@ -1129,9 +1131,10 @@ impl_stable_hash_for!(struct hir::def::Export {\n     span\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::lang_items::LangItem {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         ::std::hash::Hash::hash(self, hasher);\n     }"}, {"sha": "ae2bea3027d44e977470b868396c27a812d74740", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -32,10 +32,11 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Terminator<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::Terminator<'tcx> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Terminator {\n             ref kind,\n@@ -72,59 +73,61 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Terminator<'t\n }\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Local {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Local {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::BasicBlock {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::BasicBlock {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Field {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Field {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::VisibilityScope {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::VisibilityScope {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Promoted {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Promoted {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::TerminatorKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::TerminatorKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -182,9 +185,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::TerminatorKin\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AssertMessage<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::AssertMessage<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -202,9 +206,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AssertMessage\n \n impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::StatementKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::StatementKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -231,9 +236,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::StatementKind\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Lvalue<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Lvalue<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -250,12 +255,13 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Lvalue<'tcx>\n     }\n }\n \n-impl<'a, 'tcx, B, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Projection<'tcx, B, V>\n-    where B: HashStable<StableHashingContext<'a, 'tcx>>,\n-          V: HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx, B, V> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::Projection<'tcx, B, V>\n+    where B: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Projection {\n             ref base,\n@@ -267,11 +273,12 @@ impl<'a, 'tcx, B, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Project\n     }\n }\n \n-impl<'a, 'tcx, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::ProjectionElem<'tcx, V>\n-    where V: HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx, V> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::ProjectionElem<'tcx, V>\n+    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -302,9 +309,9 @@ impl<'a, 'tcx, V> HashStable<StableHashingContext<'a, 'tcx>> for mir::Projection\n \n impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Operand<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Operand<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -319,9 +326,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Operand<'tcx>\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Rvalue<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Rvalue<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -379,9 +386,10 @@ impl_stable_hash_for!(enum mir::CastKind {\n     Unsize\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::AggregateKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::AggregateKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -435,9 +443,9 @@ impl_stable_hash_for!(enum mir::NullOp {\n \n impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Literal<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Literal<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "995f797df2fbead6a1e2dfcac87eadcc267aa97e", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -27,20 +27,21 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::symbol::InternedString {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::syntax::symbol::InternedString {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let s: &str = &**self;\n         s.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Name {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_str().hash_stable(hcx, hasher);\n     }\n@@ -82,9 +83,10 @@ impl_stable_hash_for!(enum ::syntax::abi::Abi {\n impl_stable_hash_for!(struct ::syntax::attr::Deprecation { since, note });\n impl_stable_hash_for!(struct ::syntax::attr::Stability { level, feature, rustc_depr });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::attr::StabilityLevel {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::syntax::attr::StabilityLevel {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -135,9 +137,9 @@ impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for [ast::Attribute] {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for [ast::Attribute] {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         // Some attributes are always ignored during hashing.\n         let filtered: AccumulateVec<[&ast::Attribute; 8]> = self\n@@ -155,9 +157,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for [ast::Attribute] {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Attribute {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Attribute {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n         debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n@@ -184,9 +186,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ast::Attribute {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenTree {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for tokenstream::TokenTree {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -205,18 +208,19 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::Token\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for tokenstream::TokenStream {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for tokenstream::TokenStream {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         for sub_tt in self.trees() {\n             sub_tt.hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-fn hash_token<'a, 'tcx, W: StableHasherResult>(token: &token::Token,\n-                                               hcx: &mut StableHashingContext<'a, 'tcx>,\n+fn hash_token<'a, 'gcx, 'tcx, W: StableHasherResult>(token: &token::Token,\n+                                               hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                                hasher: &mut StableHasher<W>,\n                                                error_reporting_span: Span) {\n     mem::discriminant(token).hash_stable(hcx, hasher);\n@@ -322,9 +326,9 @@ impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n     NameValue(lit)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for FileMap {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for FileMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let FileMap {\n             ref name,"}, {"sha": "4e78d79ef87378e8d1376a1f4a5b368d7fe7facb", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 53, "deletions": 41, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -19,27 +19,30 @@ use std::mem;\n use syntax_pos::symbol::InternedString;\n use ty;\n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for &'tcx ty::Slice<T>\n-    where T: HashStable<StableHashingContext<'a, 'tcx>> {\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for &'tcx ty::Slice<T>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         (&self[..]).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::subst::Kind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::subst::Kind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_type().hash_stable(hcx, hasher);\n         self.as_region().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -72,9 +75,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::AutoBorrow<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::adjustment::AutoBorrow<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -89,9 +93,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Au\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Adjust<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::adjustment::Adjust<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -122,9 +127,10 @@ impl_stable_hash_for!(enum ty::BorrowKind {\n     MutBorrow\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::UpvarCapture<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::UpvarCapture<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -143,11 +149,11 @@ impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n     abi\n });\n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for ty::Binder<T>\n-    where T: HashStable<StableHashingContext<'a, 'tcx>> + ty::fold::TypeFoldable<'tcx>\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Binder<T>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + ty::fold::TypeFoldable<'tcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.tcx().anonymize_late_bound_regions(self).0.hash_stable(hcx, hasher);\n     }\n@@ -166,12 +172,13 @@ impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n impl_stable_hash_for!(tuple_struct ty::EquatePredicate<'tcx> { t1, t2 });\n impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n \n-impl<'a, 'tcx, A, B> HashStable<StableHashingContext<'a, 'tcx>> for ty::OutlivesPredicate<A, B>\n-    where A: HashStable<StableHashingContext<'a, 'tcx>>,\n-          B: HashStable<StableHashingContext<'a, 'tcx>>,\n+impl<'a, 'gcx, 'tcx, A, B> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::OutlivesPredicate<A, B>\n+    where A: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          B: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         a.hash_stable(hcx, hasher);\n@@ -183,9 +190,9 @@ impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty }\n impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { trait_ref, item_def_id });\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Predicate<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -221,9 +228,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::AdtFlags {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         std_hash::Hash::hash(self, hasher);\n     }\n@@ -248,10 +255,10 @@ impl_stable_hash_for!(struct ty::FieldDef {\n     vis\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n for ::middle::const_val::ConstVal<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ConstVal;\n \n@@ -324,9 +331,9 @@ impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n     Struct(index)\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Generics {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Generics {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Generics {\n             parent,\n@@ -350,9 +357,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Generics {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionParameterDef {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::RegionParameterDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::RegionParameterDef {\n             name,\n@@ -379,12 +387,12 @@ impl_stable_hash_for!(struct ty::TypeParameterDef {\n });\n \n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n for ::middle::resolve_lifetime::Set1<T>\n-    where T: HashStable<StableHashingContext<'a, 'tcx>>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::resolve_lifetime::Set1;\n \n@@ -427,10 +435,11 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtent\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ::middle::region::CodeExtent\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::region::CodeExtent;\n \n@@ -472,10 +481,11 @@ impl_stable_hash_for!(enum ty::BoundRegion {\n     BrEnv\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeVariants<'tcx>\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::TypeVariants<'tcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::TypeVariants::*;\n \n@@ -563,10 +573,11 @@ impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n     mutbl\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::ExistentialPredicate<'tcx>\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::ExistentialPredicate<'tcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -595,9 +606,10 @@ impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n });\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for ty::TypeckTables<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TypeckTables {\n             ref type_dependent_defs,"}, {"sha": "f814f941b06f1aed2dd35a0a18b8c3214e8c3e28", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -73,10 +73,10 @@ macro_rules! __impl_stable_hash_field {\n #[macro_export]\n macro_rules! impl_stable_hash_for {\n     (enum $enum_name:path { $( $variant:ident $( ( $($arg:ident),* ) )* ),* }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $enum_name {\n+        impl<'a, 'gcx, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'gcx, 'tcx>> for $enum_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'gcx, 'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 use $enum_name::*;\n                 ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n@@ -92,10 +92,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $struct_name {\n+        impl<'a, 'gcx, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'gcx, 'tcx>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'gcx, 'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name {\n                     $(ref $field),*\n@@ -106,10 +106,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (tuple_struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx>> for $struct_name {\n+        impl<'a, 'gcx, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'gcx, 'tcx>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'gcx, 'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name (\n                     $(ref $field),*\n@@ -125,11 +125,11 @@ macro_rules! impl_stable_hash_for {\n macro_rules! impl_stable_hash_for_spanned {\n     ($T:path) => (\n \n-        impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::syntax::codemap::Spanned<$T>\n+        impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ::syntax::codemap::Spanned<$T>\n         {\n             #[inline]\n             fn hash_stable<W: StableHasherResult>(&self,\n-                                                  hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                                  hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                                   hasher: &mut StableHasher<W>) {\n                 self.node.hash_stable(hcx, hasher);\n                 self.span.hash_stable(hcx, hasher);"}, {"sha": "73c702fedb8169910fa56cef3681d582def84b92", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -35,9 +35,9 @@ impl serialize::Decodable for Cache {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Cache {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Cache {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           _: &mut StableHasher<W>) {\n         // do nothing\n     }"}, {"sha": "afa2da3d561b776d05461eaee2a218ee6775f1a1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -465,9 +465,9 @@ impl<'tcx> Hash for TyS<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TyS<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::TyS<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TyS {\n             ref sty,\n@@ -1318,9 +1318,9 @@ impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for AdtDef {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for AdtDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::AdtDef {\n             did,"}, {"sha": "7831ae3092f4e43232859e7d2d5abf30b83317eb", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -94,7 +94,7 @@ impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n }\n \n struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n-    hcx: StableHashingContext<'a, 'tcx>,\n+    hcx: StableHashingContext<'a, 'tcx, 'tcx>,\n     hashes: IncrementalHashesMap,\n }\n \n@@ -103,7 +103,7 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n                                               dep_node: DepNode<DefId>,\n                                               hash_bodies: bool,\n                                               item_like: T)\n-        where T: HashStable<StableHashingContext<'a, 'tcx>>\n+        where T: HashStable<StableHashingContext<'a, 'tcx, 'tcx>>\n     {\n         if !hash_bodies && !self.hcx.tcx().sess.opts.build_dep_graph() {\n             // If we just need the hashes in order to compute the SVH, we don't"}, {"sha": "c4116489357afde361dba77a63c0861e3a0bc830", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -23,7 +23,7 @@ use rustc_serialize::Encodable;\n pub struct IsolatedEncoder<'a, 'b: 'a, 'tcx: 'b> {\n     pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    hcx: Option<(StableHashingContext<'b, 'tcx>, StableHasher<Fingerprint>)>,\n+    hcx: Option<(StableHashingContext<'b, 'tcx, 'tcx>, StableHasher<Fingerprint>)>,\n }\n \n impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n@@ -61,7 +61,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             value.hash_stable(hcx, hasher);\n@@ -72,7 +72,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = T>,\n-              T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+              T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             let iter = iter.into_iter();\n@@ -111,7 +111,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     pub fn lazy_seq_ref<'x, I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = &'x T>,\n-              T: 'x + Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+              T: 'x + Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             let iter = iter.into_iter();\n@@ -149,7 +149,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             slice.hash_stable(hcx, hasher);\n@@ -159,7 +159,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             slice.hash_stable(hcx, hasher);"}, {"sha": "9180f9100ad71428d81ca8640c81cb38e06df764", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e8635fefebd80647ecd2463f0c90df79c81ca4/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=b6e8635fefebd80647ecd2463f0c90df79c81ca4", "patch": "@@ -221,11 +221,11 @@ impl<T> Tracked<T> {\n     }\n }\n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for Tracked<T>\n-    where T: HashStable<StableHashingContext<'a, 'tcx>>\n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Tracked<T>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let Tracked {\n             ref state\n@@ -277,9 +277,9 @@ pub struct TraitImpls {\n     pub impls: LazySeq<DefIndex>,\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for TraitImpls {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TraitImpls {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let TraitImpls {\n             trait_id: (krate, def_index),\n@@ -359,9 +359,9 @@ pub enum EntryKind<'tcx> {\n     AssociatedConst(AssociatedContainer, u8),\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for EntryKind<'tcx> {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for EntryKind<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}]}