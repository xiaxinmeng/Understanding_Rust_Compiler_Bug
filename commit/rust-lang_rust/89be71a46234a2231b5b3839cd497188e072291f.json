{"sha": "89be71a46234a2231b5b3839cd497188e072291f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YmU3MWE0NjIzNGEyMjMxYjViMzgzOWNkNDk3MTg4ZTA3MjI5MWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-20T01:31:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-20T01:31:10Z"}, "message": "Auto merge of #55007 - davidtwco:issue-39175, r=petrochenkov\n\nHelp suggests non-existent package std::os::ext::process::CommandExt\n\nFixes #39175.", "tree": {"sha": "4eb815e6ed8daf4f372cc15a128c42b6e7b16921", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eb815e6ed8daf4f372cc15a128c42b6e7b16921"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89be71a46234a2231b5b3839cd497188e072291f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89be71a46234a2231b5b3839cd497188e072291f", "html_url": "https://github.com/rust-lang/rust/commit/89be71a46234a2231b5b3839cd497188e072291f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89be71a46234a2231b5b3839cd497188e072291f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42dde960f95222ffd8c356e0f7841cd22294a6c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/42dde960f95222ffd8c356e0f7841cd22294a6c9", "html_url": "https://github.com/rust-lang/rust/commit/42dde960f95222ffd8c356e0f7841cd22294a6c9"}, {"sha": "4334aaacf1da33ece0b13d845bf280aeddcb512b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4334aaacf1da33ece0b13d845bf280aeddcb512b", "html_url": "https://github.com/rust-lang/rust/commit/4334aaacf1da33ece0b13d845bf280aeddcb512b"}], "stats": {"total": 114, "additions": 104, "deletions": 10}, "files": [{"sha": "46669f1f9434b551db0725e8dfc838598e8f8583", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 64, "deletions": 10, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/89be71a46234a2231b5b3839cd497188e072291f/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89be71a46234a2231b5b3839cd497188e072291f/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=89be71a46234a2231b5b3839cd497188e072291f", "patch": "@@ -10,7 +10,7 @@\n \n use hir::map::DefPathData;\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, DefIdTree, Ty, TyCtxt};\n use middle::cstore::{ExternCrate, ExternCrateSource};\n use syntax::ast;\n use syntax::symbol::{keywords, LocalInternedString, Symbol};\n@@ -219,19 +219,73 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 cur_def_key = self.def_key(parent);\n             }\n \n+            let visible_parent = visible_parent_map.get(&cur_def).cloned();\n+            let actual_parent = self.parent(cur_def);\n+            debug!(\n+                \"try_push_visible_item_path: visible_parent={:?} actual_parent={:?}\",\n+                visible_parent, actual_parent,\n+            );\n+\n             let data = cur_def_key.disambiguated_data.data;\n-            let symbol = data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n-                if let DefPathData::CrateRoot = data { // reexported `extern crate` (#43189)\n-                    self.original_crate_name(cur_def.krate).as_str()\n-                } else {\n-                    Symbol::intern(\"<unnamed>\").as_str()\n-                }\n-            });\n+            let symbol = match data {\n+                // In order to output a path that could actually be imported (valid and visible),\n+                // we need to handle re-exports correctly.\n+                //\n+                // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n+                // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n+                //\n+                // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n+                // private so the \"true\" path to `CommandExt` isn't accessible.\n+                //\n+                // In this case, the `visible_parent_map` will look something like this:\n+                //\n+                // (child) -> (parent)\n+                // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n+                // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n+                // `std::sys::unix::ext` -> `std::os`\n+                //\n+                // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n+                // `std::os`.\n+                //\n+                // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n+                // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n+                // to the parent - resulting in a mangled path like\n+                // `std::os::ext::process::CommandExt`.\n+                //\n+                // Instead, we must detect that there was a re-export and instead print `unix`\n+                // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n+                // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n+                // the visible parent (`std::os`). If these do not match, then we iterate over\n+                // the children of the visible parent (as was done when computing\n+                // `visible_parent_map`), looking for the specific child we currently have and then\n+                // have access to the re-exported name.\n+                DefPathData::Module(module_name) if visible_parent != actual_parent => {\n+                    let mut name: Option<ast::Ident> = None;\n+                    if let Some(visible_parent) = visible_parent {\n+                        for child in self.item_children(visible_parent).iter() {\n+                            if child.def.def_id() == cur_def {\n+                                name = Some(child.ident);\n+                            }\n+                        }\n+                    }\n+                    name.map(|n| n.as_str()).unwrap_or(module_name.as_str())\n+                },\n+                _ => {\n+                    data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n+                        // Re-exported `extern crate` (#43189).\n+                        if let DefPathData::CrateRoot = data {\n+                            self.original_crate_name(cur_def.krate).as_str()\n+                        } else {\n+                            Symbol::intern(\"<unnamed>\").as_str()\n+                        }\n+                    })\n+                },\n+            };\n             debug!(\"try_push_visible_item_path: symbol={:?}\", symbol);\n             cur_path.push(symbol);\n \n-            match visible_parent_map.get(&cur_def) {\n-                Some(&def) => cur_def = def,\n+            match visible_parent {\n+                Some(def) => cur_def = def,\n                 None => return false,\n             };\n         }"}, {"sha": "efe59c31263bcc69f15539d3ee22dd1ec4083bf1", "filename": "src/test/ui/issues/issue-39175.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/89be71a46234a2231b5b3839cd497188e072291f/src%2Ftest%2Fui%2Fissues%2Fissue-39175.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89be71a46234a2231b5b3839cd497188e072291f/src%2Ftest%2Fui%2Fissues%2Fissue-39175.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39175.rs?ref=89be71a46234a2231b5b3839cd497188e072291f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test ignores some platforms as the particular extension trait used\n+// to demonstrate the issue is only available on unix. This is fine as\n+// the fix to suggested paths is not platform-dependent and will apply on\n+// these platforms also.\n+\n+// ignore-windows\n+// ignore-cloudabi\n+// ignore-emscripten\n+\n+use std::process::Command;\n+// use std::os::unix::process::CommandExt;\n+\n+fn main() {\n+    Command::new(\"echo\").arg(\"hello\").exec();\n+}"}, {"sha": "f5611e2e97b3748dac661b43e11133eab9bc9f1d", "filename": "src/test/ui/issues/issue-39175.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/89be71a46234a2231b5b3839cd497188e072291f/src%2Ftest%2Fui%2Fissues%2Fissue-39175.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89be71a46234a2231b5b3839cd497188e072291f/src%2Ftest%2Fui%2Fissues%2Fissue-39175.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39175.stderr?ref=89be71a46234a2231b5b3839cd497188e072291f", "patch": "@@ -0,0 +1,15 @@\n+error[E0599]: no method named `exec` found for type `&mut std::process::Command` in the current scope\n+  --> $DIR/issue-39175.rs:24:39\n+   |\n+LL |     Command::new(\"echo\").arg(\"hello\").exec();\n+   |                                       ^^^^\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   |\n+LL | use std::os::unix::process::CommandExt;\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}]}