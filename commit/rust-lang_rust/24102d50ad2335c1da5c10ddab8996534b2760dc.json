{"sha": "24102d50ad2335c1da5c10ddab8996534b2760dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MTAyZDUwYWQyMzM1YzFkYTVjMTBkZGFiODk5NjUzNGIyNzYwZGM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-13T09:58:31Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-13T10:51:29Z"}, "message": "Obj system? What obj system?\n\nRemoves the obj system from the compiler.\n\nCloses #1484", "tree": {"sha": "42bfbf158afad70719d90de01dfc3b4d886a9a7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42bfbf158afad70719d90de01dfc3b4d886a9a7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24102d50ad2335c1da5c10ddab8996534b2760dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24102d50ad2335c1da5c10ddab8996534b2760dc", "html_url": "https://github.com/rust-lang/rust/commit/24102d50ad2335c1da5c10ddab8996534b2760dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24102d50ad2335c1da5c10ddab8996534b2760dc/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "html_url": "https://github.com/rust-lang/rust/commit/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb"}], "stats": {"total": 2159, "additions": 139, "deletions": 2020}, "files": [{"sha": "9de31c2d014d4c7b65ff4bedbb6c19d227315a92", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -46,7 +46,7 @@ const tydesc_field_cmp_glue: int = 10;\n const tydesc_field_shape: int = 11;\n const tydesc_field_shape_tables: int = 12;\n const tydesc_field_n_params: int = 13;\n-const tydesc_field_obj_params: int = 14;\n+const tydesc_field_obj_params: int = 14; // FIXME unused\n const n_tydesc_fields: int = 15;\n \n const cmp_glue_op_eq: uint = 0u;\n@@ -55,19 +55,6 @@ const cmp_glue_op_lt: uint = 1u;\n \n const cmp_glue_op_le: uint = 2u;\n \n-const obj_field_vtbl: int = 0;\n-\n-const obj_field_box: int = 1;\n-\n-const obj_body_elt_tydesc: int = 0;\n-\n-const obj_body_elt_typarams: int = 1;\n-\n-const obj_body_elt_fields: int = 2;\n-\n-// The base object to which an anonymous object is attached.\n-const obj_body_elt_inner_obj: int = 3;\n-\n // The two halves of a closure: code and environment.\n const fn_field_code: int = 0;\n const fn_field_box: int = 1;"}, {"sha": "0e61fdfa123ebc008230fdf0a6470db7b577e6d8", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -126,18 +126,6 @@ fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n             ebml::end_tag(ebml_w);\n             encode_tag_variant_paths(ebml_w, variants, path, index);\n           }\n-          item_obj(_, tps, ctor_id) {\n-            add_to_index(ebml_w, path, index, it.ident);\n-            ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n-            encode_def_id(ebml_w, local_def(ctor_id));\n-            ebml::end_tag(ebml_w);\n-            add_to_index(ebml_w, path, index, it.ident);\n-            ebml::start_tag(ebml_w, tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n-            encode_def_id(ebml_w, local_def(it.id));\n-            ebml::end_tag(ebml_w);\n-          }\n           item_iface(_, _) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n@@ -366,26 +354,6 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_symbol(ecx, ebml_w, ctor_id);\n         ebml::end_tag(ebml_w);\n       }\n-      item_obj(_, tps, ctor_id) {\n-        let fn_ty = node_id_to_monotype(tcx, ctor_id);\n-\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'y' as u8);\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, ty::ty_fn_ret(tcx, fn_ty));\n-        encode_name(ebml_w, item.ident);\n-        ebml::end_tag(ebml_w);\n-\n-        index += [{val: ctor_id, pos: ebml_w.writer.tell()}];\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(ctor_id));\n-        encode_family(ebml_w, 'f' as u8);\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, fn_ty);\n-        encode_symbol(ecx, ebml_w, ctor_id);\n-        ebml::end_tag(ebml_w);\n-      }\n       item_impl(tps, ifce, _, methods) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));"}, {"sha": "8b5cbc5ff1aa6f207b7b50feef47bb02bba40d2a", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -246,24 +246,6 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         let func = parse_ty_fn(st, conv);\n         ret ty::mk_native_fn(st.tcx, func.inputs, func.output);\n       }\n-      'O' {\n-        assert (next(st) as char == '[');\n-        let methods: [ty::method] = [];\n-        while peek(st) as char != ']' {\n-            let proto;\n-            alt next(st) as char {\n-              'f' { proto = ast::proto_bare; }\n-            }\n-            let name = \"\";\n-            while peek(st) as char != '[' {\n-                name += str::unsafe_from_byte(next(st));\n-            }\n-            methods += [{ident: name, tps: @[],\n-                         fty: {proto: proto with parse_ty_fn(st, conv)}}];\n-        }\n-        st.pos += 1u;\n-        ret ty::mk_obj(st.tcx, methods);\n-      }\n       'r' {\n         assert (next(st) as char == '[');\n         let def = parse_def(st, conv);"}, {"sha": "4e75271c11d5cf27d75f9b4f949e3bd4c40eb8b6", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -157,15 +157,6 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         enc_ty_fn(w, cx, {proto: proto_bare, inputs: args, output: out,\n                           ret_style: return_val, constraints: []});\n       }\n-      ty::ty_obj(methods) {\n-        w.write_str(\"O[\");\n-        for m: ty::method in methods {\n-            enc_proto(w, m.fty.proto);\n-            w.write_str(m.ident);\n-            enc_ty_fn(w, cx, m.fty);\n-        }\n-        w.write_char(']');\n-      }\n       ty::ty_res(def, ty, tps) {\n         w.write_str(\"r[\");\n         w.write_str(cx.ds(def));"}, {"sha": "ce887d301944e052f8d8773b6eeaf629c7875cc6", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -56,8 +56,8 @@ type ctx = {tcx: ty::ctxt,\n             mutable silent: bool};\n \n fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> (copy_map, ref_map) {\n-    // Stores information about object fields and function\n-    // arguments that's otherwise not easily available.\n+    // Stores information about function arguments that's otherwise not easily\n+    // available.\n     let cx = @{tcx: tcx,\n                copy_map: std::map::new_int_hash(),\n                ref_map: std::map::new_int_hash(),\n@@ -521,7 +521,7 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n           }\n           ty::ty_fn({proto: ast::proto_bare., _}) { ret false; }\n           // These may contain anything.\n-          ty::ty_fn(_) | ty::ty_obj(_) { ret true; }\n+          ty::ty_fn(_) | ty::ty_iface(_, _) { ret true; }\n           // A type param may include everything, but can only be\n           // treated as opaque downstream, and is thus safe unless we\n           // saw mutable fields, in which case the whole thing can be\n@@ -536,8 +536,7 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n fn def_is_local(d: ast::def) -> bool {\n     alt d {\n       ast::def_local(_, _) | ast::def_arg(_, _) | ast::def_binding(_) |\n-      ast::def_upvar(_, _, _) | ast::def_self(_) |\n-      ast::def_obj_field(_, _) { true }\n+      ast::def_upvar(_, _, _) | ast::def_self(_) { true }\n       _ { false }\n     }\n }\n@@ -557,10 +556,9 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n           ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int(_) |\n           ty::ty_uint(_) | ty::ty_float(_) | ty::ty_type. | ty::ty_native(_) |\n           ty::ty_ptr(_) { 1u }\n-          ty::ty_box(_) { 3u }\n+          ty::ty_box(_) | ty::ty_iface(_, _) { 3u }\n           ty::ty_constr(t, _) | ty::ty_res(_, t, _) { score_ty(tcx, t) }\n-          ty::ty_fn(_) | ty::ty_native_fn(_, _) |\n-          ty::ty_obj(_) { 4u }\n+          ty::ty_fn(_) | ty::ty_native_fn(_, _) { 4u }\n           ty::ty_str. | ty::ty_vec(_) | ty::ty_param(_, _) { 50u }\n           ty::ty_uniq(mt) { 1u + score_ty(tcx, mt.ty) }\n           ty::ty_tag(_, ts) | ty::ty_tup(ts) {\n@@ -633,17 +631,6 @@ fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool)\n     for d in *base_root.ds {\n         if d.mut { unsafe_ty = some(contains(d.outer_t)); break; }\n     }\n-    alt base_root.ex.node {\n-      ast::expr_path(_) {\n-        alt cx.tcx.def_map.get(base_root.ex.id) {\n-          ast::def_obj_field(_, ast::mut.) {\n-            unsafe_ty = some(mut_contains(ty::expr_ty(cx.tcx, base_root.ex)));\n-          }\n-          _ {}\n-        }\n-      }\n-      _ {}\n-    }\n     ret {ex: base_root.ex, mut: unsafe_ty};\n }\n "}, {"sha": "1af44c8120985c364bcdeabb1761a42e85fc487a", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -6,8 +6,6 @@ import syntax::{visit, codemap};\n \n tag ast_node {\n     node_item(@item);\n-    node_obj_ctor(@item);\n-    node_obj_method(@method);\n     node_native_item(@native_item);\n     node_method(@method);\n     node_expr(@expr);\n@@ -62,12 +60,6 @@ fn map_arm(cx: ctx, arm: arm) {\n fn map_item(cx: ctx, i: @item) {\n     cx.map.insert(i.id, node_item(i));\n     alt i.node {\n-      item_obj(ob, _, ctor_id) {\n-        cx.map.insert(ctor_id, node_obj_ctor(i));\n-        for m in ob.methods {\n-            cx.map.insert(m.id, node_obj_method(m));\n-        }\n-      }\n       item_impl(_, _, _, ms) {\n         for m in ms { cx.map.insert(m.id, node_method(m)); }\n       }\n@@ -85,20 +77,11 @@ fn map_native_item(cx: ctx, i: @native_item) {\n \n fn map_expr(cx: ctx, ex: @expr) {\n     cx.map.insert(ex.id, node_expr(ex));\n-    alt ex.node {\n-      expr_anon_obj(ao) {\n-        for m in ao.methods {\n-            cx.map.insert(m.id, node_obj_method(m));\n-        }\n-      }\n-      _ {}\n-    }\n }\n \n fn node_span(node: ast_node) -> codemap::span {\n     alt node {\n       node_item(item) { item.span }\n-      node_obj_ctor(item) { item.span }\n       node_native_item(nitem) { nitem.span }\n       node_expr(expr) { expr.span }\n     }\n@@ -120,18 +103,6 @@ mod test {\n         assert (node_span(node) == expected);\n     }\n \n-    #[test]\n-    fn test_node_span_obj_ctor() {\n-        let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n-        let node =\n-            node_obj_ctor(@{ident: \"test\",\n-                            attrs: [],\n-                            id: 0,\n-                            node: item_mod({view_items: [], items: []}),\n-                            span: expected});\n-        assert (node_span(node) == expected);\n-    }\n-\n     #[test]\n     fn test_node_span_native_item() {\n         let expected: codemap::span = ast_util::mk_sp(20u, 30u);"}, {"sha": "540728e60224c7d17101e5d073e1e453957825f5", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -727,9 +727,6 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n           }\n         }\n       }\n-      ast_map::node_obj_method(method) | ast_map::node_method(method) {\n-        (method.ident, method.decl.output, method.id)\n-      }\n       ast_map::node_res_ctor(item) {\n         alt item.node { ast::item_res(decl, _, _, _, ctor_id) {\n           (item.ident, decl.output, ctor_id)"}, {"sha": "ebd1d4ff9f4f6a17da6294ac4c9d1a9f2eea32f4", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -3,7 +3,7 @@\n import lib::llvm::True;\n import lib::llvm::llvm::ValueRef;\n import middle::trans;\n-import middle::trans::{get_tydesc, tps_normal};\n+import middle::trans::get_tydesc;\n import middle::trans_common::*;\n import middle::ty;\n import option::none;\n@@ -43,7 +43,7 @@ fn add_gc_root(cx: @block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     bcx = trans::zero_alloca(bcx, llval, ty);\n \n     let ti = none;\n-    let td_r = get_tydesc(bcx, ty, false, tps_normal, ti);\n+    let td_r = get_tydesc(bcx, ty, false, ti);\n     bcx = td_r.result.bcx;\n     let lltydesc = td_r.result.val;\n \n@@ -147,7 +147,7 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n       }\n       ty::ty_constr(sub, _) { ret type_is_gc_relevant(cx, sub); }\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_fn(_) |\n-      ty::ty_native_fn(_, _) | ty::ty_obj(_) | ty::ty_param(_, _) |\n+      ty::ty_native_fn(_, _) | ty::ty_param(_, _) |\n       ty::ty_res(_, _, _) { ret true; }\n       ty::ty_var(_) {\n         fail \"ty_var in type_is_gc_relevant\";"}, {"sha": "51ab1ad3690b65ca91fb106dcd74ad08ce425765", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -8,7 +8,7 @@ import driver::session::session;\n // Kind analysis pass. There are three kinds:\n //\n //  sendable: scalar types, and unique types containing only sendable types\n-//  copyable: boxes, objects, closures, and uniques containing copyable types\n+//  copyable: boxes, closures, and uniques containing copyable types\n //  noncopyable: resources, or unique types containing resources\n //\n // This pass ensures that type parameters are only instantiated with types\n@@ -218,7 +218,7 @@ fn maybe_copy(cx: ctx, ex: @expr) {\n }\n \n fn check_copy_ex(cx: ctx, ex: @expr, _warn: bool) {\n-    if ty::expr_is_lval(cx.method_map, cx.tcx, ex) &&\n+    if ty::expr_is_lval(cx.method_map, ex) &&\n        !cx.last_uses.contains_key(ex.id) {\n         let ty = ty::expr_ty(cx.tcx, ex);\n         check_copy(cx, ty, ex.span);"}, {"sha": "d67e8bf49496546035b815abb2a1224c09ca4c51", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -60,7 +60,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n                     }\n                 }\n               }\n-              ty::ty_obj(_) { }\n+              _ {}\n             }\n             ds += [@{mut: is_mut, kind: field, outer_t: auto_unbox.t}];\n             ds += auto_unbox.ds;\n@@ -201,9 +201,6 @@ fn check_move_rhs(cx: @ctx, src: @expr) {\n     alt src.node {\n       expr_path(p) {\n         alt cx.tcx.def_map.get(src.id) {\n-          def_obj_field(_, _) {\n-            mk_err(cx, src.span, msg_move_out, \"object field\");\n-          }\n           def_self(_) {\n             mk_err(cx, src.span, msg_move_out, \"method self\");\n           }\n@@ -267,7 +264,6 @@ fn is_immutable_def(cx: @ctx, def: def) -> option::t<str> {\n       }\n       def_arg(_, by_ref.) | def_arg(_, by_val.) |\n       def_arg(_, mode_infer.) { some(\"argument\") }\n-      def_obj_field(_, imm.) { some(\"immutable object field\") }\n       def_self(_) { some(\"self argument\") }\n       def_upvar(_, inner, node_id) {\n         let ty = ty::node_id_to_monotype(cx.tcx, node_id);"}, {"sha": "b83588591cd269ea7e4b139ed2a77ea4af631d3c", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 52, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -535,9 +535,6 @@ fn visit_expr_with_scope(x: @ast::expr, sc: scopes, v: vt<scopes>) {\n         v.visit_local(decl, new_sc, v);\n         v.visit_block(blk, new_sc, v);\n       }\n-      ast::expr_anon_obj(_) {\n-        visit::visit_expr(x, cons(scope_method(x.id, []), @sc), v);\n-      }\n       _ { visit::visit_expr(x, sc, v); }\n     }\n }\n@@ -852,9 +849,9 @@ fn def_is_local(d: def) -> bool {\n     }\n }\n \n-fn def_has_obj_scope(d: def) -> bool {\n+fn def_is_self(d: def) -> bool {\n     alt d {\n-      ast::def_obj_field(_, _) | ast::def_self(_) { true }\n+      ast::def_self(_) { true }\n       _ { false }\n     }\n }\n@@ -874,9 +871,6 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n           }\n           scope_item(it) {\n             alt it.node {\n-              ast::item_obj(ob, ty_params, _) {\n-                ret lookup_in_obj(e, name, ob, ty_params, ns, it.id);\n-              }\n               ast::item_impl(tps, _, _, _) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n@@ -935,7 +929,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n     }\n     let left_fn = false;\n     let closing = [];\n-    // Used to determine whether obj fields are in scope\n+    // Used to determine whether self is in scope\n     let left_fn_level2 = false;\n     let sc = sc;\n     while true {\n@@ -945,9 +939,8 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             let fnd = in_scope(e, sp, name, hd, ns);\n             if !is_none(fnd) {\n                 let df = option::get(fnd);\n-                let local = def_is_local(df),\n-                    obj_scope = def_has_obj_scope(df);\n-                if left_fn && local || left_fn_level2 && obj_scope\n+                let local = def_is_local(df), self_scope = def_is_self(df);\n+                if left_fn && local || left_fn_level2 && self_scope\n                    || scope_is_fn(hd) && left_fn && def_is_ty_arg(df) {\n                     let msg = alt ns {\n                       ns_type. {\n@@ -965,7 +958,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                       _ { \"attempted dynamic environment-capture\" }\n                     };\n                     e.sess.span_fatal(sp, msg);\n-                } else if local || obj_scope {\n+                } else if local || self_scope {\n                     let i = vec::len(closing);\n                     while i > 0u {\n                         i -= 1u;\n@@ -1030,24 +1023,6 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n     }\n }\n \n-fn lookup_in_obj(e: env, name: ident, ob: ast::_obj,\n-                 ty_params: [ast::ty_param],\n-                 ns: namespace, id: node_id) -> option::t<def> {\n-    alt ns {\n-      ns_val(val_ty) {\n-        if name == \"self\" && val_ty == ns_any_value\n-           { ret some(ast::def_self(local_def(id))); }\n-        for f: ast::obj_field in ob.fields {\n-            if str::eq(f.ident, name) && val_ty == ns_any_value {\n-                ret some(ast::def_obj_field(local_def(f.id), f.mut));\n-            }\n-        }\n-        ret none::<def>;\n-      }\n-      ns_type. { ret lookup_in_ty_params(e, name, ty_params); }\n-      _ { ret none::<def>; }\n-    }\n-}\n \n fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                    loc_pos: uint, ns: namespace) -> option::t<def> {\n@@ -1166,15 +1141,6 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n           _ { }\n         }\n       }\n-      ast::item_obj(_, _, ctor_id) {\n-        alt ns {\n-          ns_val(ns_any_value.) {\n-            ret some(ast::def_fn(local_def(ctor_id), ast::impure_fn));\n-          }\n-          ns_type. { ret some(ast::def_ty(local_def(i.id))); }\n-          _ { }\n-        }\n-      }\n       _ { }\n     }\n     ret none;\n@@ -1422,7 +1388,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n         alt it.node {\n           ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n           ast::item_native_mod(_) | ast::item_ty(_, _) |\n-          ast::item_res(_, _, _, _, _) | ast::item_obj(_, _, _) |\n+          ast::item_res(_, _, _, _, _) |\n           ast::item_impl(_, _, _, _) | ast::item_iface(_, _) {\n             add_to_index(index, it.ident, mie_item(it));\n           }\n@@ -1470,7 +1436,7 @@ fn index_nmod(md: ast::native_mod) -> mod_index {\n fn ns_for_def(d: def) -> namespace {\n     alt d {\n       ast::def_variant(_, _) { ns_val(ns_a_tag) }\n-      ast::def_fn(_, _) | ast::def_obj_field(_, _) | ast::def_self(_) |\n+      ast::def_fn(_, _) | ast::def_self(_) |\n       ast::def_const(_) | ast::def_arg(_, _) | ast::def_local(_, _) |\n       ast::def_upvar(_, _, _) |  ast::def_native_fn(_, _) | ast::def_self(_)\n         { ns_val(ns_any_value) }\n@@ -1597,15 +1563,6 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n                       \"type parameter\");\n       }\n-      ast::item_obj(ob, ty_params, _) {\n-        fn field_name(field: ast::obj_field) -> ident { ret field.ident; }\n-        ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n-        for m: @ast::method in ob.methods {\n-            check_fn(*e, m.span, m.decl);\n-        }\n-        ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n-                      \"type parameter\");\n-      }\n       ast::item_tag(_, ty_params) {\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n                       \"type parameter\");\n@@ -1687,7 +1644,7 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n                   ast::item_ty(_, _) | ast::item_iface(_, _) {\n                     add_name(types, it.span, it.ident);\n                   }\n-                  ast::item_res(_, _, _, _, _) | ast::item_obj(_, _, _) {\n+                  ast::item_res(_, _, _, _, _) {\n                     add_name(types, it.span, it.ident);\n                     add_name(values, it.span, it.ident);\n                   }"}, {"sha": "b867bd67b8f1ae660a489e02781686477049387e", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -47,7 +47,7 @@ const shape_tag: u8 = 12u8;\n const shape_box: u8 = 13u8;\n const shape_struct: u8 = 17u8;\n const shape_box_fn: u8 = 18u8;\n-const shape_obj: u8 = 19u8;\n+const shape_UNUSED: u8 = 19u8;\n const shape_res: u8 = 20u8;\n const shape_var: u8 = 21u8;\n const shape_uniq: u8 = 22u8;\n@@ -309,8 +309,7 @@ fn add_substr(&dest: [u8], src: [u8]) {\n     dest += src;\n }\n \n-fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n-            is_obj_body: bool) -> [u8] {\n+fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n     let s = [];\n \n     alt ty::struct(ccx.tcx, t) {\n@@ -335,7 +334,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n         s += [shape_vec];\n         add_bool(s, true); // type is POD\n         let unit_ty = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n-        add_substr(s, shape_of(ccx, unit_ty, ty_param_map, is_obj_body));\n+        add_substr(s, shape_of(ccx, unit_ty, ty_param_map));\n       }\n       ty::ty_tag(did, tps) {\n         alt tag_kind(ccx, did) {\n@@ -363,7 +362,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n \n             add_u16(sub, vec::len(tps) as u16);\n             for tp: ty::t in tps {\n-                let subshape = shape_of(ccx, tp, ty_param_map, is_obj_body);\n+                let subshape = shape_of(ccx, tp, ty_param_map);\n                 add_u16(sub, vec::len(subshape) as u16);\n                 sub += subshape;\n             }\n@@ -374,35 +373,34 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n       }\n       ty::ty_box(mt) {\n         s += [shape_box];\n-        add_substr(s, shape_of(ccx, mt.ty, ty_param_map, is_obj_body));\n+        add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n       }\n       ty::ty_uniq(mt) {\n         s += [shape_uniq];\n-        add_substr(s, shape_of(ccx, mt.ty, ty_param_map, is_obj_body));\n+        add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n       }\n       ty::ty_vec(mt) {\n         s += [shape_vec];\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n-        add_substr(s, shape_of(ccx, mt.ty, ty_param_map, is_obj_body));\n+        add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n       }\n       ty::ty_rec(fields) {\n         s += [shape_struct];\n         let sub = [];\n         for f: field in fields {\n-            sub += shape_of(ccx, f.mt.ty, ty_param_map, is_obj_body);\n+            sub += shape_of(ccx, f.mt.ty, ty_param_map);\n         }\n         add_substr(s, sub);\n       }\n       ty::ty_tup(elts) {\n         s += [shape_struct];\n         let sub = [];\n         for elt in elts {\n-            sub += shape_of(ccx, elt, ty_param_map, is_obj_body);\n+            sub += shape_of(ccx, elt, ty_param_map);\n         }\n         add_substr(s, sub);\n       }\n       ty::ty_native_fn(_, _) { s += [shape_u32]; }\n-      ty::ty_obj(_) { s += [shape_obj]; }\n       ty::ty_iface(_, _) { s += [shape_iface]; }\n       ty::ty_res(did, raw_subt, tps) {\n         let subt = ty::substitute_type_params(ccx.tcx, tps, raw_subt);\n@@ -413,24 +411,19 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n         add_u16(s, id as u16);\n         add_u16(s, vec::len(tps) as u16);\n         for tp: ty::t in tps {\n-            add_substr(s, shape_of(ccx, tp, ty_param_map, is_obj_body));\n+            add_substr(s, shape_of(ccx, tp, ty_param_map));\n         }\n-        add_substr(s, shape_of(ccx, subt, ty_param_map, is_obj_body));\n+        add_substr(s, shape_of(ccx, subt, ty_param_map));\n \n       }\n       ty::ty_var(n) {\n         fail \"shape_of ty_var\";\n       }\n       ty::ty_param(n, _) {\n-        if is_obj_body {\n-            // Just write in the parameter number.\n-            s += [shape_var, n as u8];\n-        } else {\n-            // Find the type parameter in the parameter list.\n-            alt vec::position(n, ty_param_map) {\n-              some(i) { s += [shape_var, i as u8]; }\n-              none. { fail \"ty param not found in ty_param_map\"; }\n-            }\n+        // Find the type parameter in the parameter list.\n+        alt vec::position(n, ty_param_map) {\n+          some(i) { s += [shape_var, i as u8]; }\n+          none. { fail \"ty param not found in ty_param_map\"; }\n         }\n       }\n       ty::ty_fn({proto: ast::proto_box., _}) {\n@@ -461,7 +454,7 @@ fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info,\n     while i < ty_param_count { ty_param_map += [i]; i += 1u; }\n \n     let s = [];\n-    for t: ty::t in v.args { s += shape_of(ccx, t, ty_param_map, false); }\n+    for t: ty::t in v.args { s += shape_of(ccx, t, ty_param_map); }\n     ret s;\n }\n "}, {"sha": "f5742b5a9842fe7c621aa3a283cc2e4b6624304f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 69, "deletions": 230, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -2,7 +2,7 @@\n //\n // Some functions here, such as trans_block and trans_expr, return a value --\n // the result of the translation to LLVM -- while others, such as trans_fn,\n-// trans_obj, and trans_item, are called only for the side effect of adding a\n+// trans_impl, and trans_item, are called only for the side effect of adding a\n // particular definition to the LLVM IR output we're producing.\n //\n // Hopefully useful general knowledge about trans:\n@@ -42,8 +42,6 @@ import util::ppaux::{ty_to_str, ty_to_short_str};\n \n import trans_common::*;\n import trans_build::*;\n-\n-import trans_objects::{trans_anon_obj, trans_obj};\n import tvec = trans_vec;\n \n fn type_of_1(bcx: @block_ctxt, t: ty::t) -> TypeRef {\n@@ -81,7 +79,7 @@ fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn type_of_fn(cx: @crate_ctxt, sp: span, is_method: bool, inputs: [ty::arg],\n+fn type_of_fn(cx: @crate_ctxt, sp: span, inputs: [ty::arg],\n               output: ty::t, params: [ty::param_bounds]) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n@@ -90,22 +88,16 @@ fn type_of_fn(cx: @crate_ctxt, sp: span, is_method: bool, inputs: [ty::arg],\n     let out_ty = T_ptr(type_of_inner(cx, sp, output));\n     atys += [out_ty];\n \n-    // Arg 1: Env (closure-bindings / self-obj)\n-    if is_method {\n-        atys += [T_ptr(cx.rust_object_type)];\n-    } else {\n-        atys += [T_opaque_cbox_ptr(cx)];\n-    }\n+    // Arg 1: Environment\n+    atys += [T_opaque_cbox_ptr(cx)];\n \n     // Args >2: ty params, if not acquired via capture...\n-    if !is_method {\n-        for bounds in params {\n-            atys += [T_ptr(cx.tydesc_type)];\n-            for bound in *bounds {\n-                alt bound {\n-                  ty::bound_iface(_) { atys += [T_ptr(T_dict())]; }\n-                  _ {}\n-                }\n+    for bounds in params {\n+        atys += [T_ptr(cx.tydesc_type)];\n+        for bound in *bounds {\n+            alt bound {\n+              ty::bound_iface(_) { atys += [T_ptr(T_dict())]; }\n+              _ {}\n             }\n         }\n     }\n@@ -121,7 +113,7 @@ fn type_of_fn_from_ty(cx: @crate_ctxt, sp: span, fty: ty::t,\n     // by returns_non_ty_var(t). Make that a postcondition\n     // (see Issue #586)\n     let ret_ty = ty::ty_fn_ret(cx.tcx, fty);\n-    ret type_of_fn(cx, sp, false, ty::ty_fn_args(cx.tcx, fty),\n+    ret type_of_fn(cx, sp, ty::ty_fn_args(cx.tcx, fty),\n                    ret_ty, param_bounds);\n }\n \n@@ -179,7 +171,6 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         let nft = native_fn_wrapper_type(cx, sp, [], t);\n         T_fn_pair(cx, nft)\n       }\n-      ty::ty_obj(_) { cx.rust_object_type }\n       ty::ty_iface(_, _) { T_opaque_iface_ptr(cx) }\n       ty::ty_res(_, sub, tps) {\n         let sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n@@ -465,7 +456,7 @@ fn dynastack_alloca(cx: @block_ctxt, t: TypeRef, n: ValueRef, ty: ty::t) ->\n                    n);\n \n     let ti = none;\n-    let lltydesc = get_tydesc(cx, ty, false, tps_normal, ti).result.val;\n+    let lltydesc = get_tydesc(cx, ty, false, ti).result.val;\n \n     let llresult = Call(dy_cx, dynastack_alloc, [llsz, lltydesc]);\n     ret PointerCast(dy_cx, llresult, T_ptr(t));\n@@ -496,11 +487,6 @@ fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n                            [ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)),\n                             ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx))]);\n           }\n-          ty::ty_obj(_) {\n-            ret ty::mk_tup(ccx.tcx,\n-                           [ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)),\n-                            ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx))]);\n-          }\n           ty::ty_res(_, sub, tps) {\n             let sub1 = ty::substitute_type_params(ccx.tcx, tps, sub);\n             ret ty::mk_tup(ccx.tcx,\n@@ -871,7 +857,7 @@ fn trans_malloc_boxed_raw(cx: @block_ctxt, t: ty::t) -> result {\n     let llty = type_of(ccx, sp, box_ptr);\n \n     let ti = none;\n-    let tydesc_result = get_tydesc(bcx, t, true, tps_normal, ti);\n+    let tydesc_result = get_tydesc(bcx, t, true, ti);\n     let lltydesc = tydesc_result.result.val; bcx = tydesc_result.result.bcx;\n \n     let rval = Call(cx, ccx.upcalls.malloc,\n@@ -899,7 +885,7 @@ fn trans_malloc_boxed(cx: @block_ctxt, t: ty::t) ->\n fn field_of_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool, field: int) ->\n    result {\n     let ti = none::<@tydesc_info>;\n-    let tydesc = get_tydesc(cx, t, escapes, tps_normal, ti).result;\n+    let tydesc = get_tydesc(cx, t, escapes, ti).result;\n     ret rslt(tydesc.bcx,\n              GEPi(tydesc.bcx, tydesc.val, [0, field]));\n }\n@@ -936,8 +922,8 @@ fn linearize_ty_params(cx: @block_ctxt, t: ty::t) ->\n \n fn trans_stack_local_derived_tydesc(cx: @block_ctxt, llsz: ValueRef,\n                                     llalign: ValueRef, llroottydesc: ValueRef,\n-                                    llfirstparam: ValueRef, n_params: uint,\n-                                    obj_params: uint) -> ValueRef {\n+                                    llfirstparam: ValueRef, n_params: uint)\n+    -> ValueRef {\n     let llmyroottydesc = alloca(cx, bcx_ccx(cx).tydesc_type);\n \n     // By convention, desc 0 is the root descriptor.\n@@ -954,39 +940,29 @@ fn trans_stack_local_derived_tydesc(cx: @block_ctxt, llsz: ValueRef,\n                    [0, abi::tydesc_field_size]);\n     store_inbounds(cx, llalign, llmyroottydesc,\n                    [0, abi::tydesc_field_align]);\n-    store_inbounds(cx, C_uint(ccx, obj_params), llmyroottydesc,\n+    // FIXME legacy field, can be dropped\n+    store_inbounds(cx, C_uint(ccx, 0u), llmyroottydesc,\n                    [0, abi::tydesc_field_obj_params]);\n     ret llmyroottydesc;\n }\n \n-// Objects store their type parameters differently (in the object itself\n-// rather than in the type descriptor).\n-tag ty_param_storage { tps_normal; tps_obj(uint); }\n-\n fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n-                      storage: ty_param_storage,\n                       &static_ti: option::t<@tydesc_info>) -> result {\n     alt cx.fcx.derived_tydescs.find(t) {\n       some(info) {\n         // If the tydesc escapes in this context, the cached derived\n         // tydesc also has to be one that was marked as escaping.\n-        if !(escapes && !info.escapes) && storage == tps_normal {\n+        if !(escapes && !info.escapes) {\n             ret rslt(cx, info.lltydesc);\n         }\n       }\n       none. {/* fall through */ }\n     }\n \n-    let is_obj_body;\n-    alt storage {\n-        tps_normal. { is_obj_body = false; }\n-        tps_obj(_) { is_obj_body = true; }\n-    }\n-\n     bcx_ccx(cx).stats.n_derived_tydescs += 1u;\n     let bcx = new_raw_block_ctxt(cx.fcx, cx.fcx.llderivedtydescs);\n     let tys = linearize_ty_params(bcx, t);\n-    let root_ti = get_static_tydesc(bcx, t, tys.params, is_obj_body);\n+    let root_ti = get_static_tydesc(bcx, t, tys.params);\n     static_ti = some::<@tydesc_info>(root_ti);\n     lazily_emit_all_tydesc_glue(cx, static_ti);\n     let root = root_ti.tydesc;\n@@ -1022,28 +998,18 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n         PointerCast(bcx, llparamtydescs,\n                     T_ptr(T_ptr(bcx_ccx(bcx).tydesc_type)));\n \n-    // The top bit indicates whether this type descriptor describes an object\n-    // (0) or a function (1).\n-    let obj_params;\n-    alt storage {\n-      tps_normal. { obj_params = 0u; }\n-      tps_obj(np) { obj_params = np; }\n-    }\n-\n     let v;\n     if escapes {\n         let ccx = bcx_ccx(bcx);\n         let td_val =\n             Call(bcx, ccx.upcalls.get_type_desc,\n                  [C_null(T_ptr(T_nil())), sz.val,\n                   align.val, C_uint(ccx, 1u + n_params), llfirstparam,\n-                  C_uint(ccx, obj_params)]);\n+                  C_uint(ccx, 0u)]);\n         v = td_val;\n     } else {\n-        v =\n-            trans_stack_local_derived_tydesc(bcx, sz.val, align.val, root,\n-                                             llfirstparam, n_params,\n-                                             obj_params);\n+        v = trans_stack_local_derived_tydesc(bcx, sz.val, align.val, root,\n+                                             llfirstparam, n_params);\n     }\n     bcx.fcx.derived_tydescs.insert(t, {lltydesc: v, escapes: escapes});\n     ret rslt(cx, v);\n@@ -1052,7 +1018,7 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n type get_tydesc_result = {kind: tydesc_kind, result: result};\n \n fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n-              storage: ty_param_storage, &static_ti: option::t<@tydesc_info>)\n+              &static_ti: option::t<@tydesc_info>)\n    -> get_tydesc_result {\n \n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n@@ -1076,22 +1042,21 @@ fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n     // Does it contain a type param? If so, generate a derived tydesc.\n     if ty::type_contains_params(bcx_tcx(cx), t) {\n         ret {kind: tk_derived,\n-             result: get_derived_tydesc(cx, t, escapes, storage, static_ti)};\n+             result: get_derived_tydesc(cx, t, escapes, static_ti)};\n     }\n     // Otherwise, generate a tydesc if necessary, and return it.\n-    let info = get_static_tydesc(cx, t, [], false);\n-    static_ti = some::<@tydesc_info>(info);\n+    let info = get_static_tydesc(cx, t, []);\n+    static_ti = some(info);\n     ret {kind: tk_static, result: rslt(cx, info.tydesc)};\n }\n \n-fn get_static_tydesc(cx: @block_ctxt, t: ty::t, ty_params: [uint],\n-                     is_obj_body: bool) -> @tydesc_info {\n+fn get_static_tydesc(cx: @block_ctxt, t: ty::t, ty_params: [uint])\n+    -> @tydesc_info {\n     alt bcx_ccx(cx).tydescs.find(t) {\n       some(info) { ret info; }\n       none. {\n         bcx_ccx(cx).stats.n_static_tydescs += 1u;\n-        let info = declare_tydesc(cx.fcx.lcx, cx.sp, t, ty_params,\n-                                  is_obj_body);\n+        let info = declare_tydesc(cx.fcx.lcx, cx.sp, t, ty_params);\n         bcx_ccx(cx).tydescs.insert(t, info);\n         ret info;\n       }\n@@ -1134,9 +1099,8 @@ fn set_glue_inlining(cx: @local_ctxt, f: ValueRef, t: ty::t) {\n \n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-fn declare_tydesc(cx: @local_ctxt, sp: span, t: ty::t, ty_params: [uint],\n-                  is_obj_body: bool) ->\n-   @tydesc_info {\n+fn declare_tydesc(cx: @local_ctxt, sp: span, t: ty::t, ty_params: [uint])\n+    -> @tydesc_info {\n     log(debug, \"+++ declare_tydesc \" + ty_to_str(cx.ccx.tcx, t));\n     let ccx = cx.ccx;\n     let llsize;\n@@ -1171,8 +1135,7 @@ fn declare_tydesc(cx: @local_ctxt, sp: span, t: ty::t, ty_params: [uint],\n           mutable drop_glue: none::<ValueRef>,\n           mutable free_glue: none::<ValueRef>,\n           mutable cmp_glue: none::<ValueRef>,\n-          ty_params: ty_params,\n-          is_obj_body: is_obj_body};\n+          ty_params: ty_params};\n     log(debug, \"--- declare_tydesc \" + ty_to_str(cx.ccx.tcx, t));\n     ret info;\n }\n@@ -1275,8 +1238,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n \n-        let shape = shape::shape_of(ccx, key, ti.ty_params,\n-                                    ti.is_obj_body);\n+        let shape = shape::shape_of(ccx, key, ti.ty_params);\n         let shape_tables =\n             llvm::LLVMConstPointerCast(ccx.shape_cx.llshapetables,\n                                        T_ptr(T_i8()));\n@@ -1389,16 +1351,14 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n       ty::ty_vec(_) | ty::ty_str. {\n         tvec::make_free_glue(bcx, PointerCast(bcx, v, type_of_1(bcx, t)), t)\n       }\n-      ty::ty_obj(_) | ty::ty_iface(_, _) {\n-        // Call through the obj's own fields-drop glue first.\n+      ty::ty_iface(_, _) {\n+        // Call through the box's own fields-drop glue first.\n         // Then free the body.\n-        // (Same code of ifaces, whose layout is similar)\n         let ccx = bcx_ccx(bcx);\n-        let llbox_ty = T_opaque_obj_ptr(ccx);\n+        let llbox_ty = T_opaque_iface_ptr(ccx);\n         let b = PointerCast(bcx, v, llbox_ty);\n         let body = GEPi(bcx, b, [0, abi::box_rc_field_body]);\n-        let tydescptr =\n-            GEPi(bcx, body, [0, abi::obj_body_elt_tydesc]);\n+        let tydescptr = GEPi(bcx, body, [0, 0]);\n         let tydesc = Load(bcx, tydescptr);\n         let ti = none;\n         call_tydesc_glue_full(bcx, body, tydesc,\n@@ -1435,10 +1395,6 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n           ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str. | ty::ty_send_type. {\n             free_ty(bcx, Load(bcx, v0), t)\n           }\n-          ty::ty_obj(_) {\n-            let box_cell = GEPi(bcx, v0, [0, abi::obj_field_box]);\n-            decr_refcnt_maybe_free(bcx, Load(bcx, box_cell), t)\n-          }\n           ty::ty_res(did, inner, tps) {\n             trans_res_drop(bcx, v0, did, inner, tps)\n           }\n@@ -1482,7 +1438,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     let args = [cx.fcx.llretptr, null_env_ptr(cx)];\n     for tp: ty::t in tps {\n         let ti: option::t<@tydesc_info> = none;\n-        let td = get_tydesc(cx, tp, false, tps_normal, ti).result;\n+        let td = get_tydesc(cx, tp, false, ti).result;\n         args += [td.val];\n         cx = td.bcx;\n     }\n@@ -1508,7 +1464,7 @@ fn decr_refcnt_maybe_free(cx: @block_ctxt, box_ptr: ValueRef, t: ty::t)\n     let rc_adj_cx = new_sub_block_ctxt(cx, \"rc--\");\n     let free_cx = new_sub_block_ctxt(cx, \"free\");\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n-    let llbox_ty = T_opaque_obj_ptr(ccx);\n+    let llbox_ty = T_opaque_iface_ptr(ccx);\n     let box_ptr = PointerCast(cx, box_ptr, llbox_ty);\n     let null_test = IsNull(cx, box_ptr);\n     CondBr(cx, null_test, next_cx.llbb, rc_adj_cx.llbb);\n@@ -1738,10 +1694,6 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         }\n         ret next_cx;\n       }\n-      ty::ty_obj(_) {\n-        let box_cell_a = GEPi(cx, av, [0, abi::obj_field_box]);\n-        ret iter_boxpp(cx, box_cell_a, f);\n-      }\n       _ { bcx_ccx(cx).sess.unimpl(\"type in iter_structural_ty\"); }\n     }\n     ret cx;\n@@ -1876,7 +1828,7 @@ fn call_tydesc_glue_full(cx: @block_ctxt, v: ValueRef, tydesc: ValueRef,\n fn call_tydesc_glue(cx: @block_ctxt, v: ValueRef, t: ty::t, field: int) ->\n    @block_ctxt {\n     let ti: option::t<@tydesc_info> = none::<@tydesc_info>;\n-    let {bcx: bcx, val: td} = get_tydesc(cx, t, false, tps_normal, ti).result;\n+    let {bcx: bcx, val: td} = get_tydesc(cx, t, false, ti).result;\n     call_tydesc_glue_full(bcx, v, td, field, ti);\n     ret bcx;\n }\n@@ -1898,7 +1850,7 @@ fn call_cmp_glue(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     let llrawlhsptr = BitCast(bcx, lllhs, T_ptr(T_i8()));\n     let llrawrhsptr = BitCast(bcx, llrhs, T_ptr(T_i8()));\n     let ti = none::<@tydesc_info>;\n-    r = get_tydesc(bcx, t, false, tps_normal, ti).result;\n+    r = get_tydesc(bcx, t, false, ti).result;\n     let lltydesc = r.val;\n     bcx = r.bcx;\n     lazily_emit_tydesc_glue(bcx, abi::tydesc_field_cmp_glue, ti);\n@@ -2591,7 +2543,7 @@ type lval_result = {bcx: @block_ctxt, val: ValueRef, kind: lval_kind};\n tag callee_env {\n     null_env;\n     is_closure;\n-    obj_env(ValueRef);\n+    self_env(ValueRef);\n     dict_env(ValueRef, ValueRef);\n }\n type lval_maybe_callee = {bcx: @block_ctxt,\n@@ -2647,7 +2599,7 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n         for t in tys {\n             // TODO: Doesn't always escape.\n             let ti = none;\n-            let td = get_tydesc(bcx, t, true, tps_normal, ti).result;\n+            let td = get_tydesc(bcx, t, true, ti).result;\n             tis += [ti];\n             bcx = td.bcx;\n             tydescs += [td.val];\n@@ -2702,10 +2654,6 @@ fn trans_local_var(cx: @block_ctxt, def: ast::def) -> local_var_result {\n       ast::def_local(did, _) | ast::def_binding(did) {\n         ret take_local(cx.fcx.lllocals, did.node);\n       }\n-      ast::def_obj_field(did, _) {\n-        assert (cx.fcx.llobjfields.contains_key(did.node));\n-        ret { val: cx.fcx.llobjfields.get(did.node), kind: owned };\n-      }\n       ast::def_self(did) {\n         let slf = option::get(cx.fcx.llself);\n         let ptr = PointerCast(cx, slf.v, T_ptr(type_of_or_i8(cx, slf.t)));\n@@ -2766,35 +2714,6 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n     }\n }\n \n-fn trans_object_field(bcx: @block_ctxt, o: @ast::expr, field: ast::ident)\n-    -> {bcx: @block_ctxt, mthptr: ValueRef, objptr: ValueRef} {\n-    let {bcx, val} = trans_temp_expr(bcx, o);\n-    let {bcx, val, ty} = autoderef(bcx, val, ty::expr_ty(bcx_tcx(bcx), o));\n-    ret trans_object_field_inner(bcx, val, field, ty);\n-}\n-\n-fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n-                            field: ast::ident, o_ty: ty::t)\n-    -> {bcx: @block_ctxt, mthptr: ValueRef, objptr: ValueRef} {\n-    let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n-    let mths = alt ty::struct(tcx, o_ty) { ty::ty_obj(ms) { ms } };\n-\n-    let ix = option::get(ty::method_idx(field, mths));\n-    let vtbl = Load(bcx, GEPi(bcx, o, [0, abi::obj_field_vtbl]));\n-    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n-    vtbl = PointerCast(bcx, vtbl, vtbl_type);\n-\n-    let v = GEPi(bcx, vtbl, [0, ix as int]);\n-    let fn_ty: ty::t = ty::mk_fn(tcx, mths[ix].fty);\n-    let ret_ty = ty::ty_fn_ret(tcx, fn_ty);\n-    // FIXME: constrain ty_obj?\n-    let ll_fn_ty = type_of_fn(ccx, bcx.sp, true,\n-                              ty::ty_fn_args(tcx, fn_ty), ret_ty, []);\n-    v = Load(bcx, PointerCast(bcx, v, T_ptr(T_ptr(ll_fn_ty))));\n-    ret {bcx: bcx, mthptr: v, objptr: o};\n-}\n-\n-\n fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n                    field: ast::ident) -> lval_result {\n     let {bcx, val} = trans_temp_expr(bcx, base);\n@@ -2859,7 +2778,7 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n \n fn expr_is_lval(bcx: @block_ctxt, e: @ast::expr) -> bool {\n     let ccx = bcx_ccx(bcx);\n-    ty::expr_is_lval(ccx.method_map, ccx.tcx, e)\n+    ty::expr_is_lval(ccx.method_map, e)\n }\n \n fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n@@ -2879,11 +2798,6 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n               some(typeck::method_iface(off)) {\n                 ret trans_impl::trans_iface_callee(bcx, e, base, off);\n               }\n-              none. { // An object method\n-                let of = trans_object_field(bcx, base, ident);\n-                ret {bcx: of.bcx, val: of.mthptr, kind: owned,\n-                     env: obj_env(of.objptr), generic: none};\n-              }\n             }\n         }\n       }\n@@ -2948,7 +2862,7 @@ fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n     -> (lval_kind, ValueRef) {\n     alt c.env {\n       is_closure. { (c.kind, c.val) }\n-      obj_env(_) | dict_env(_, _) {\n+      self_env(_) | dict_env(_, _) {\n         fail \"Taking the value of a method does not work yet (issue #435)\";\n       }\n       null_env. {\n@@ -3230,7 +3144,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n         llargs += [PointerCast(cx, llretslot, llretty)];\n     } else { llargs += [llretslot]; }\n \n-    // Arg 1: Env (closure-bindings / self-obj)\n+    // Arg 1: Env (closure-bindings / self value)\n     llargs += [llenv];\n \n     // Args >2: ty_params ...\n@@ -3277,7 +3191,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n       null_env. {\n         llenv = llvm::LLVMGetUndef(T_opaque_cbox_ptr(bcx_ccx(cx)));\n       }\n-      obj_env(e) { llenv = e; }\n+      self_env(e) { llenv = e; }\n       dict_env(dict, e) { llenv = e; dict_param = some(dict); }\n       is_closure. {\n         // It's a closure. Have to fetch the elements\n@@ -3639,9 +3553,6 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         else { ret lval_to_dps(bcx, a, dest); }\n       }\n       ast::expr_cast(val, _) { ret trans_cast(bcx, val, e.id, dest); }\n-      ast::expr_anon_obj(anon_obj) {\n-        ret trans_anon_obj(bcx, e.span, anon_obj, e.id, dest);\n-      }\n       ast::expr_call(f, args, _) {\n         ret trans_call(bcx, f, args, e.id, dest);\n       }\n@@ -3855,7 +3766,7 @@ fn trans_log(lvl: @ast::expr, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n     let log_bcx = sub.bcx;\n \n     let ti = none::<@tydesc_info>;\n-    let r = get_tydesc(log_bcx, e_ty, false, tps_normal, ti).result;\n+    let r = get_tydesc(log_bcx, e_ty, false, ti).result;\n     log_bcx = r.bcx;\n     let lltydesc = r.val;\n \n@@ -4350,8 +4261,6 @@ fn new_local_ctxt(ccx: @crate_ctxt) -> @local_ctxt {\n     let pth: [str] = [];\n     ret @{path: pth,\n           module_path: [ccx.link_meta.name],\n-          obj_typarams: [],\n-          obj_fields: [],\n           ccx: ccx};\n }\n \n@@ -4404,7 +4313,6 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: span, llfndecl: ValueRef,\n           mutable llobstacktoken: none::<ValueRef>,\n           mutable llself: none::<val_self_pair>,\n           llargs: new_int_hash::<local_val>(),\n-          llobjfields: new_int_hash::<ValueRef>(),\n           lllocals: new_int_hash::<local_val>(),\n           llupvars: new_int_hash::<ValueRef>(),\n           mutable lltyparams: [],\n@@ -4440,33 +4348,28 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n     // way.\n     let arg_n = 2u;\n     alt ty_self {\n-      obj_self(tt) | impl_self(tt) {\n+      impl_self(tt) {\n         cx.llself = some({v: cx.llenv, t: tt});\n       }\n       no_self. {}\n     }\n-    alt ty_self {\n-      obj_self(_) {}\n-      _ {\n-        for tp in ty_params {\n-            let lltydesc = llvm::LLVMGetParam(cx.llfn, arg_n), dicts = none;\n-            arg_n += 1u;\n-            for bound in *fcx_tcx(cx).ty_param_bounds.get(tp.id) {\n-                alt bound {\n-                  ty::bound_iface(_) {\n-                    let dict = llvm::LLVMGetParam(cx.llfn, arg_n);\n-                    arg_n += 1u;\n-                    dicts = some(alt dicts {\n-                      none. { [dict] }\n-                      some(ds) { ds + [dict] }\n-                    });\n-                  }\n-                  _ {}\n-                }\n+    for tp in ty_params {\n+        let lltydesc = llvm::LLVMGetParam(cx.llfn, arg_n), dicts = none;\n+        arg_n += 1u;\n+        for bound in *fcx_tcx(cx).ty_param_bounds.get(tp.id) {\n+            alt bound {\n+              ty::bound_iface(_) {\n+                let dict = llvm::LLVMGetParam(cx.llfn, arg_n);\n+                arg_n += 1u;\n+                dicts = some(alt dicts {\n+                    none. { [dict] }\n+                    some(ds) { ds + [dict] }\n+                });\n+              }\n+              _ {}\n             }\n-            cx.lltyparams += [{desc: lltydesc, dicts: dicts}];\n         }\n-      }\n+        cx.lltyparams += [{desc: lltydesc, dicts: dicts}];\n     }\n \n     // Populate the llargs field of the function context with the ValueRefs\n@@ -4517,54 +4420,6 @@ fn arg_tys_of_fn(ccx: @crate_ctxt, id: ast::node_id) -> [ty::arg] {\n     }\n }\n \n-fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n-    let ccx = fcx_ccx(fcx);\n-    let bcx = llstaticallocas_block_ctxt(fcx);\n-    let field_tys: [ty::t] = [];\n-    for f: ast::obj_field in bcx.fcx.lcx.obj_fields {\n-        field_tys += [node_id_type(ccx, f.id)];\n-    }\n-    // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n-    // its magic.\n-\n-    let fields_tup_ty = ty::mk_tup(fcx.lcx.ccx.tcx, field_tys);\n-    let n_typarams = vec::len::<ast::ty_param>(bcx.fcx.lcx.obj_typarams);\n-    let llobj_box_ty: TypeRef = T_obj_ptr(ccx, n_typarams);\n-    let box_cell = GEPi(bcx, llself.v, [0, abi::obj_field_box]);\n-    let box_ptr = Load(bcx, box_cell);\n-    box_ptr = PointerCast(bcx, box_ptr, llobj_box_ty);\n-    let obj_typarams =\n-        GEPi(bcx, box_ptr, [0, abi::box_rc_field_body,\n-                            abi::obj_body_elt_typarams]);\n-\n-    // The object fields immediately follow the type parameters, so we skip\n-    // over them to get the pointer.\n-    let obj_fields =\n-        PointerCast(bcx, GEPi(bcx, obj_typarams, [1]),\n-                    T_ptr(type_of_or_i8(bcx, fields_tup_ty)));\n-\n-    let i: int = 0;\n-    for p: ast::ty_param in fcx.lcx.obj_typarams {\n-        let lltyparam: ValueRef =\n-            GEPi(bcx, obj_typarams, [0, i]);\n-        lltyparam = Load(bcx, lltyparam);\n-        fcx.lltyparams += [{desc: lltyparam, dicts: none}];\n-        i += 1;\n-    }\n-    i = 0;\n-    for f: ast::obj_field in fcx.lcx.obj_fields {\n-        // FIXME: silly check\n-        check type_is_tup_like(bcx, fields_tup_ty);\n-        let rslt = GEP_tup_like(bcx, fields_tup_ty, obj_fields, [0, i]);\n-        bcx = llstaticallocas_block_ctxt(fcx);\n-        let llfield = rslt.val;\n-        fcx.llobjfields.insert(f.id, llfield);\n-        i += 1;\n-    }\n-    fcx.llstaticallocas = bcx.llbb;\n-}\n-\n-\n // Ties up the llstaticallocas -> llloadenv -> llderivedtydescs ->\n // lldynamicallocas -> lltop edges, and builds the return block.\n fn finish_fn(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n@@ -4578,7 +4433,7 @@ fn finish_fn(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n     RetVoid(ret_cx);\n }\n \n-tag self_arg { obj_self(ty::t); impl_self(ty::t); no_self; }\n+tag self_arg { impl_self(ty::t); no_self; }\n \n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n@@ -4592,12 +4447,6 @@ fn trans_closure(cx: @local_ctxt, sp: span, decl: ast::fn_decl,\n     // Set up arguments to the function.\n     let fcx = new_fn_ctxt_w_id(cx, sp, llfndecl, id, decl.cf);\n     create_llargs_for_fn_args(fcx, ty_self, decl.inputs, ty_params);\n-    alt ty_self {\n-      obj_self(_) {\n-          populate_fn_ctxt_from_llself(fcx, option::get(fcx.llself));\n-      }\n-      _ { }\n-    }\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n@@ -4612,7 +4461,7 @@ fn trans_closure(cx: @local_ctxt, sp: span, decl: ast::fn_decl,\n \n     // This call to trans_block is the place where we bridge between\n     // translation calls that don't have a return value (trans_crate,\n-    // trans_mod, trans_item, trans_obj, et cetera) and those that do\n+    // trans_mod, trans_item, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n     if ty::type_is_bot(cx.ccx.tcx, block_ty) ||\n        ty::type_is_nil(cx.ccx.tcx, block_ty) ||\n@@ -5063,12 +4912,6 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n           }\n         }\n       }\n-      ast::item_obj(ob, tps, ctor_id) {\n-        let sub_cx =\n-            @{obj_typarams: tps, obj_fields: ob.fields\n-                 with *extend_path(cx, item.ident)};\n-        trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n-      }\n       ast::item_impl(tps, _, _, ms) {\n         trans_impl::trans_impl(cx, item.ident, ms, item.id, tps);\n       }\n@@ -5180,7 +5023,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mut: ast::imm})};\n         // FIXME: mk_nil should have a postcondition\n         let nt = ty::mk_nil(ccx.tcx);\n-        let llfty = type_of_fn(ccx, sp, false, [vecarg_ty], nt, []);\n+        let llfty = type_of_fn(ccx, sp, [vecarg_ty], nt, []);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::LLVMCCallConv, llfty);\n \n@@ -5278,7 +5121,7 @@ fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span,\n                           x: ty::t) -> TypeRef {\n     alt ty::struct(cx.tcx, x) {\n       ty::ty_native_fn(args, out) {\n-        ret type_of_fn(cx, sp, false, args, out, param_bounds);\n+        ret type_of_fn(cx, sp, args, out, param_bounds);\n       }\n     }\n }\n@@ -5378,9 +5221,6 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n       ast::item_fn(_, tps, _) {\n         register_fn(ccx, i.span, new_pt, \"fn\", tps, i.id);\n       }\n-      ast::item_obj(ob, tps, ctor_id) {\n-        register_fn(ccx, i.span, new_pt, \"obj_ctor\", tps, ctor_id);\n-      }\n       ast::item_impl(tps, _, _, methods) {\n         let name = i.ident + int::str(i.id);\n         for m in methods {\n@@ -5716,7 +5556,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           upcalls:\n               upcall::declare_upcalls(targ_cfg, tn, tydesc_type,\n                                       llmod),\n-          rust_object_type: T_rust_object(),\n           tydesc_type: tydesc_type,\n           int_type: int_type,\n           float_type: float_type,"}, {"sha": "a7db4b22eb8c1b171b375e13190320808279e7bb", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -222,7 +222,7 @@ fn allocate_cbox(bcx: @block_ctxt,\n         let ti = none;\n         let tydesc_ty = if xchgheap { cbox_ty } else { cbox_norc_ty };\n         let {bcx, val:lltydesc} =\n-            get_tydesc(bcx, tydesc_ty, true, tps_normal, ti).result;\n+            get_tydesc(bcx, tydesc_ty, true, ti).result;\n         let malloc = {\n             if xchgheap { ccx.upcalls.shared_malloc}\n             else { ccx.upcalls.malloc }\n@@ -315,7 +315,7 @@ fn store_environment(\n         let ti = none;\n \n         let {result:closure_td, _} =\n-            trans::get_tydesc(bcx, cbox_ty, true, tps_normal, ti);\n+            trans::get_tydesc(bcx, cbox_ty, true, ti);\n         trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n         trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);"}, {"sha": "0368a4c7cdf5206dc6ca3dd7d656ce5f4126a6e8", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 4, "deletions": 37, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -46,8 +46,7 @@ type tydesc_info =\n      mutable drop_glue: option::t<ValueRef>,\n      mutable free_glue: option::t<ValueRef>,\n      mutable cmp_glue: option::t<ValueRef>,\n-     ty_params: [uint],\n-     is_obj_body: bool};\n+     ty_params: [uint]};\n \n /*\n  * A note on nomenclature of linking: \"upcall\", \"extern\" and \"native\".\n@@ -112,7 +111,6 @@ type crate_ctxt =\n      dict_map: typeck::dict_map,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n-     rust_object_type: TypeRef,\n      tydesc_type: TypeRef,\n      int_type: TypeRef,\n      float_type: TypeRef,\n@@ -127,8 +125,6 @@ type crate_ctxt =\n type local_ctxt =\n     {path: [str],\n      module_path: [str],\n-     obj_typarams: [ast::ty_param],\n-     obj_fields: [ast::obj_field],\n      ccx: @crate_ctxt};\n \n // Types used for llself.\n@@ -156,8 +152,7 @@ type fn_ctxt =\n     // Points to the current task.\n \n     // Points to the current environment (bindings of variables to\n-    // values), if this is a regular function; points to the current\n-    // object, if this is a method.\n+    // values), if this is a regular function\n \n     // Points to where the return value of this function should end\n     // up.\n@@ -185,7 +180,7 @@ type fn_ctxt =\n \n     // The token used to clear the dynamic allocas at the end of this frame.\n \n-    // The 'self' object currently in use in this function, if there\n+    // The 'self' value currently in use in this function, if there\n     // is one.\n \n     // If this function is actually a iter, a block containing the\n@@ -196,9 +191,6 @@ type fn_ctxt =\n \n     // Maps arguments to allocas created for them in llallocas.\n \n-    // Maps fields in objects to pointers into the interior of\n-    // llself's body.\n-\n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n \n@@ -240,7 +232,6 @@ type fn_ctxt =\n      mutable llobstacktoken: option::t<ValueRef>,\n      mutable llself: option::t<val_self_pair>,\n      llargs: hashmap<ast::node_id, local_val>,\n-     llobjfields: hashmap<ast::node_id, ValueRef>,\n      lllocals: hashmap<ast::node_id, local_val>,\n      llupvars: hashmap<ast::node_id, ValueRef>,\n      mutable lltyparams: [fn_ty_param],\n@@ -331,7 +322,7 @@ fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n     let nil_res = ty::mk_nil(ccx.tcx);\n     // FIXME: Silly check -- mk_nil should have a postcondition\n     check non_ty_var(ccx, nil_res);\n-    let f_t = type_of_fn(ccx, sp, false,\n+    let f_t = type_of_fn(ccx, sp,\n                          [{mode: ast::by_ref, ty: inner_t}],\n                          nil_res, *param_bounds);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n@@ -566,17 +557,6 @@ fn set_struct_body(t: TypeRef, elts: [TypeRef]) unsafe {\n \n fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n \n-// NB: This will return something different every time it's called. If\n-// you need a generic object type that matches the type of your\n-// existing objects, use ccx.rust_object_type.  Calling\n-// T_rust_object() again will return a different one.\n-fn T_rust_object() -> TypeRef {\n-    let t = T_named_struct(\"rust_object\");\n-    let e = T_ptr(T_empty_struct());\n-    set_struct_body(t, [e, e]);\n-    ret t;\n-}\n-\n // A dict is, in reality, a vtable pointer followed by zero or more pointers\n // to tydescs and other dicts that it closes over. But the types and number of\n // those are rarely known to the code that needs to manipulate them, so they\n@@ -745,19 +725,6 @@ fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n     ret T_struct(vec::init_elt::<TypeRef>(T_ptr(cx.tydesc_type), n));\n }\n \n-fn T_obj_ptr(cx: @crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n-    // This function is not publicly exposed because it returns an incomplete\n-    // type. The dynamically-sized fields follow the captured tydescs.\n-\n-    fn T_obj(cx: @crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n-        ret T_struct([T_ptr(cx.tydesc_type),\n-                      T_captured_tydescs(cx, n_captured_tydescs)]);\n-    }\n-    ret T_ptr(T_box(cx, T_obj(cx, n_captured_tydescs)));\n-}\n-\n-fn T_opaque_obj_ptr(cx: @crate_ctxt) -> TypeRef { ret T_obj_ptr(cx, 0u); }\n-\n fn T_opaque_iface_ptr(cx: @crate_ctxt) -> TypeRef {\n     let tdptr = T_ptr(cx.tydesc_type);\n     T_ptr(T_box(cx, T_struct([tdptr, tdptr, T_i8()])))"}, {"sha": "634b5842839dd5c248e06dfd7365b4a4997391bf", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -65,7 +65,7 @@ fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n fn trans_static_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n                        did: ast::def_id) -> lval_maybe_callee {\n     let {bcx, val} = trans_self_arg(bcx, base);\n-    {env: obj_env(val) with lval_static_fn(bcx, did, e.id)}\n+    {env: self_env(val) with lval_static_fn(bcx, did, e.id)}\n }\n \n fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, m: ty::method)\n@@ -92,7 +92,7 @@ fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n         let tptys = ty::node_id_to_type_params(tcx, fld_expr.id);\n         for t in vec::tail_n(tptys, vec::len(tptys) - vec::len(*method.tps)) {\n             let ti = none;\n-            let td = get_tydesc(bcx, t, true, tps_normal, ti).result;\n+            let td = get_tydesc(bcx, t, true, ti).result;\n             tis += [ti];\n             tydescs += [td.val];\n             bcx = td.bcx;\n@@ -158,8 +158,7 @@ fn trans_vtable(ccx: @crate_ctxt, id: ast::node_id, name: str,\n fn trans_wrapper(ccx: @crate_ctxt, pt: [ast::ident], llfty: TypeRef,\n                  fill: block(ValueRef, @block_ctxt) -> @block_ctxt)\n     -> ValueRef {\n-    let lcx = @{path: pt, module_path: [],\n-                obj_typarams: [], obj_fields: [], ccx: ccx};\n+    let lcx = @{path: pt, module_path: [], ccx: ccx};\n     let name = link::mangle_internal_name_by_path(ccx, pt);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, name, llfty);\n     let fcx = new_fn_ctxt(lcx, ast_util::dummy_sp(), llfn);\n@@ -370,7 +369,7 @@ fn get_dict_ptrs(bcx: @block_ctxt, origin: typeck::dict_origin)\n         let ptrs = [get_vtable(ccx, impl_did)];\n         let origin = 0u, ti = none, bcx = bcx;\n         vec::iter2(*impl_params, tys) {|param, ty|\n-            let rslt = get_tydesc(bcx, ty, true, tps_normal, ti).result;\n+            let rslt = get_tydesc(bcx, ty, true, ti).result;\n             ptrs += [rslt.val];\n             bcx = rslt.bcx;\n             for bound in *param {\n@@ -401,8 +400,7 @@ fn trans_cast(bcx: @block_ctxt, val: @ast::expr, id: ast::node_id, dest: dest)\n     let body_ty = ty::mk_tup(tcx, [ty::mk_type(tcx), ty::mk_type(tcx),\n                                    val_ty]);\n     let ti = none;\n-    let {bcx, val: tydesc} = get_tydesc(bcx, body_ty, true,\n-                                        tps_normal, ti).result;\n+    let {bcx, val: tydesc} = get_tydesc(bcx, body_ty, true, ti).result;\n     lazily_emit_all_tydesc_glue(bcx, ti);\n     let {bcx, box, body: box_body} = trans_malloc_boxed(bcx, body_ty);\n     Store(bcx, tydesc, GEPi(bcx, box_body, [0, 0]));"}, {"sha": "b4edb2b1cf298e3dec374a78603ce24c611b3657", "filename": "src/comp/middle/trans_objects.rs", "status": "removed", "additions": 0, "deletions": 951, "changes": 951, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -1,951 +0,0 @@\n-// Translation of object-related things to LLVM IR.\n-\n-import core::{str, option, vec};\n-import option::{none, some};\n-\n-import lib::llvm::{llvm, True};\n-import lib::llvm::llvm::{TypeRef, ValueRef};\n-\n-import back::abi;\n-import back::link::{mangle_internal_name_by_path,\n-                    mangle_internal_name_by_path_and_seq};\n-import syntax::{ast, ast_util};\n-import syntax::codemap::span;\n-\n-import trans_common::*;\n-import trans::*;\n-import trans_build::*;\n-\n-import driver::session::session;\n-\n-export trans_anon_obj;\n-export trans_obj;\n-\n-// trans_obj: create an LLVM function that is the object constructor for the\n-// object being translated.\n-fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n-             ty_params: [ast::ty_param]) {\n-\n-    // To make a function, we have to create a function context and, inside\n-    // that, a number of block contexts for which code is generated.\n-    let ccx = cx.ccx;\n-    let llctor_decl;\n-    alt ccx.item_ids.find(ctor_id) {\n-      some(x) { llctor_decl = x; }\n-      _ { cx.ccx.sess.span_fatal(sp, \"unbound llctor_decl in trans_obj\"); }\n-    }\n-\n-    // Much like trans_fn, we must create an LLVM function, but since we're\n-    // starting with an ast::_obj rather than an ast::_fn, we have some setup\n-    // work to do.\n-\n-    // The fields of our object will become the arguments to the function\n-    // we're creating.\n-    let fn_args: [ast::arg] = [];\n-    for f: ast::obj_field in ob.fields {\n-        fn_args += [{mode: ast::by_copy, ty: f.ty, ident: f.ident,\n-                     id: f.id}];\n-    }\n-    let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n-\n-    //  Create the first block context in the function and keep a handle on it\n-    //  to pass to finish_fn later.\n-    let bcx = new_top_block_ctxt(fcx);\n-    let lltop = bcx.llbb;\n-\n-    // Both regular arguments and type parameters are handled here.\n-    create_llargs_for_fn_args(fcx, no_self, fn_args, ty_params);\n-    let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n-    bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n-\n-    // Pick up the type of this object by looking at our own output type, that\n-    // is, the output type of the object constructor we're building.\n-    let self_ty = ty::ret_ty_of_fn(ccx.tcx, ctor_id);\n-\n-    // Set up the two-word pair that we're going to return from the object\n-    // constructor we're building.  The two elements of this pair will be a\n-    // vtable pointer and a body pointer.  (llretptr already points to the\n-    // place where this two-word pair should go; it was pre-allocated by the\n-    // caller of the function.)\n-    let pair = bcx.fcx.llretptr;\n-\n-    // Grab onto the first and second elements of the pair.\n-    // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n-    // of 'pair'.\n-    let pair_vtbl = GEPi(bcx, pair, [0, abi::obj_field_vtbl]);\n-    let pair_box = GEPi(bcx, pair, [0, abi::obj_field_box]);\n-\n-    // Make a vtable for this object: a static array of pointers to functions.\n-    // It will be located in the read-only memory of the executable we're\n-    // creating and will contain ValueRefs for all of this object's methods.\n-    // create_vtbl returns a pointer to the vtable, which we store.\n-    let vtbl = create_vtbl(cx, sp, self_ty, ob, ty_params, none, []);\n-    vtbl = PointerCast(bcx, vtbl, T_ptr(T_empty_struct()));\n-\n-    Store(bcx, vtbl, pair_vtbl);\n-\n-    // Next we have to take care of the other half of the pair we're\n-    // returning: a boxed (reference-counted) tuple containing a tydesc,\n-    // typarams, and fields.\n-    let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n-\n-    if vec::len(ty_params) == 0u &&\n-           vec::len(arg_tys) == 0u {\n-        // If the object we're translating has no fields or type parameters,\n-        // there's not much to do.\n-\n-        // Store null into pair, if no args or typarams.\n-        Store(bcx, C_null(llbox_ty), pair_box);\n-    } else {\n-        let obj_fields: [ty::t] = [];\n-        for a: ty::arg in arg_tys { obj_fields += [a.ty]; }\n-\n-        let tps: [ty::t] = [];\n-        let tydesc_ty = ty::mk_type(ccx.tcx);\n-        for tp: ast::ty_param in ty_params { tps += [tydesc_ty]; }\n-\n-        // Synthesize an object body type and hand it off to\n-        // trans_malloc_boxed, which allocates a box, including space for a\n-        // refcount.\n-        let body_ty: ty::t =\n-            create_object_body_type(ccx.tcx, obj_fields, tps, none);\n-\n-        // We have to get this type descriptor now so that\n-        // trans_malloc_boxed() doesn't generate a type descriptor with the\n-        // wrong storage type and override the type descriptor we're about to\n-        // generate.\n-        let ti = none;\n-        let storage = tps_obj(vec::len(ty_params));\n-        let body_td = get_tydesc(bcx, body_ty, true, storage, ti).result;\n-        bcx = body_td.bcx;\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-\n-        let box = trans_malloc_boxed(bcx, body_ty);\n-        bcx = box.bcx;\n-        let body = box.body;\n-\n-        // Put together a tydesc for the body, so that the object can later be\n-        // freed by calling through its tydesc.\n-\n-        // Every object (not just those with type parameters) needs to have a\n-        // tydesc to describe its body, since all objects have unknown type to\n-        // the user of the object.  So the tydesc is needed to keep track of\n-        // the types of the object's fields, so that the fields can be freed\n-        // later.\n-\n-        // postcondition on create_object_body_type?\n-        check type_is_tup_like(bcx, body_ty);\n-        let body_tydesc =\n-            GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_tydesc]);\n-        bcx = body_tydesc.bcx;\n-\n-        check type_is_tup_like(bcx, body_ty);\n-        let r =\n-            GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_typarams]);\n-        bcx = r.bcx;\n-        let body_typarams = r.val;\n-\n-        Store(bcx, body_td.val, body_tydesc.val);\n-\n-        // Copy the object's type parameters and fields into the space we\n-        // allocated for the object body.  (This is something like saving the\n-        // lexical environment of a function in its closure: the \"captured\n-        // typarams\" are any type parameters that are passed to the object\n-        // constructor and are then available to the object's methods.\n-        // Likewise for the object's fields.)\n-\n-        // Copy typarams into captured typarams.\n-        // TODO: can we just get typarams_ty out of body_ty instead?\n-        let typarams_ty: ty::t = ty::mk_tup(ccx.tcx, tps);\n-        let i: int = 0;\n-        for tp: ast::ty_param in ty_params {\n-            let typaram = bcx.fcx.lltyparams[i].desc;\n-            // Silly check\n-            check type_is_tup_like(bcx, typarams_ty);\n-            let capture =\n-                GEP_tup_like(bcx, typarams_ty, body_typarams, [0, i]);\n-            bcx = capture.bcx;\n-            bcx = copy_val(bcx, INIT, capture.val, typaram, tydesc_ty);\n-            i += 1;\n-        }\n-\n-        // Copy args into body fields.\n-        // how to get rid of this check?\n-        check type_is_tup_like(bcx, body_ty);\n-        let body_fields =\n-            GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_fields]);\n-        bcx = body_fields.bcx;\n-        // TODO: can we just get fields_ty out of body_ty instead?\n-        let fields_ty = ty::mk_tup(ccx.tcx, obj_fields);\n-        i = 0;\n-        for f: ast::obj_field in ob.fields {\n-            alt bcx.fcx.llargs.find(f.id) {\n-              some(local_mem(arg)) {\n-                // Silly check\n-                check type_is_tup_like(bcx, fields_ty);\n-                let field =\n-                    GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n-                bcx = memmove_ty(field.bcx, field.val, arg, arg_tys[i].ty);\n-                i += 1;\n-              }\n-            }\n-        }\n-\n-        // Store box ptr in outer pair.\n-        let p = PointerCast(bcx, box.box, llbox_ty);\n-        Store(bcx, p, pair_box);\n-    }\n-    build_return(bcx);\n-\n-    // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(fcx, lltop);\n-}\n-\n-// trans_anon_obj: create and return a pointer to an object.  This code\n-// differs from trans_obj in that, rather than creating an object constructor\n-// function and putting it in the generated code as an object item, we are\n-// instead \"inlining\" the construction of the object and returning the object\n-// itself.\n-fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n-                  id: ast::node_id, dest: trans::dest) -> @block_ctxt {\n-    let bcx = bcx;\n-    if dest == trans::ignore {\n-        alt anon_obj.inner_obj {\n-          some(e) { ret trans::trans_expr(bcx, e, trans::ignore); }\n-          none. { ret bcx; }\n-        }\n-    }\n-\n-    let ccx = bcx_ccx(bcx);\n-\n-    // Fields.  FIXME (part of issue #538): Where do we fill in the field\n-    // *values* from the outer object?\n-    let additional_fields: [ast::anon_obj_field] = [];\n-    let additional_field_vals: [result] = [];\n-    let additional_field_tys: [ty::t] = [];\n-    alt anon_obj.fields {\n-      none. { }\n-      some(fields) {\n-        additional_fields = fields;\n-        for f: ast::anon_obj_field in fields {\n-            additional_field_tys += [node_id_type(ccx, f.id)];\n-            additional_field_vals += [trans_temp_expr(bcx, f.expr)];\n-        }\n-      }\n-    }\n-\n-    // Get the type of the eventual entire anonymous object, possibly with\n-    // extensions.  NB: This type includes both inner and outer methods.\n-    let outer_obj_ty = ty::node_id_to_type(ccx.tcx, id);\n-\n-    // Create a vtable for the anonymous object.\n-\n-    // create_vtbl() wants an ast::_obj and all we have is an ast::anon_obj,\n-    // so we need to roll our own.  NB: wrapper_obj includes only outer\n-    // methods, not inner ones.\n-    let wrapper_obj: ast::_obj =\n-        {fields:\n-             vec::map(additional_fields,\n-                      ast_util::obj_field_from_anon_obj_field),\n-         methods: anon_obj.methods};\n-\n-    let inner_obj_ty: ty::t;\n-    let vtbl;\n-    alt anon_obj.inner_obj {\n-      none. {\n-        // We need a dummy inner_obj_ty for setting up the object body later.\n-        inner_obj_ty = ty::mk_type(ccx.tcx);\n-\n-        // If there's no inner_obj -- that is, if we're creating a new object\n-        // from nothing rather than extending an existing object -- then we\n-        // just pass the outer object to create_vtbl().  Our vtable won't need\n-        // to have any forwarding slots.\n-        vtbl =\n-            create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, [], none,\n-                        additional_field_tys);\n-      }\n-      some(e) {\n-        // TODO: What makes more sense to get the type of an expr -- calling\n-        // ty::expr_ty(ccx.tcx, e) on it or calling\n-        // ty::node_id_to_type(ccx.tcx, id) on its id?\n-        inner_obj_ty = ty::expr_ty(ccx.tcx, e);\n-        //inner_obj_ty = ty::node_id_to_type(ccx.tcx, e.id);\n-\n-        // If there's a inner_obj, we pass its type along to create_vtbl().\n-        // Part of what create_vtbl() will do is take the set difference of\n-        // methods defined on the original and methods being added.  For every\n-        // method defined on the original that does *not* have one with a\n-        // matching name and type being added, we'll need to create a\n-        // forwarding slot.  And, of course, we need to create a normal vtable\n-        // entry for every method being added.\n-        vtbl =\n-            create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, [],\n-                        some(inner_obj_ty), additional_field_tys);\n-      }\n-    }\n-\n-    vtbl = PointerCast(bcx, vtbl, T_ptr(T_empty_struct()));\n-\n-    // Next we have to take care of the other half of the pair we're\n-    // returning: a boxed (reference-counted) tuple containing a tydesc,\n-    // typarams, fields, and a pointer to our inner_obj.\n-    let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n-\n-    let box = C_null(llbox_ty);\n-    if vec::len(additional_fields) > 0u || anon_obj.inner_obj != none {\n-        // Synthesize a type for the object body and hand it off to\n-        // trans_malloc_boxed, which allocates a box, including space for a\n-        // refcount.\n-        let body_ty: ty::t =\n-            create_object_body_type(ccx.tcx, additional_field_tys, [],\n-                                    some(inner_obj_ty));\n-        let box_r = trans_malloc_boxed(bcx, body_ty);\n-        box = box_r.box;\n-        bcx = box_r.bcx;\n-        add_clean_free(bcx, box, false);\n-        let body = box_r.body;\n-\n-        // Put together a tydesc for the body, so that the object can later be\n-        // freed by calling through its tydesc.\n-\n-        // Every object (not just those with type parameters) needs to have a\n-        // tydesc to describe its body, since all objects have unknown type to\n-        // the user of the object.  So the tydesc is needed to keep track of\n-        // the types of the object's fields, so that the fields can be freed\n-        // later.\n-        // postcondition on create_object_body_type?\n-        check type_is_tup_like(bcx, body_ty);\n-        let body_tydesc =\n-            GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_tydesc]);\n-        bcx = body_tydesc.bcx;\n-        let ti = none;\n-        let body_td = get_tydesc(bcx, body_ty, true, tps_normal, ti).result;\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-        bcx = body_td.bcx;\n-        Store(bcx, body_td.val, body_tydesc.val);\n-\n-        // Copy the object's fields into the space we allocated for the object\n-        // body.  (This is something like saving the lexical environment of a\n-        // function in its closure: the fields were passed to the object\n-        // constructor and are now available to the object's methods.\n-        check type_is_tup_like(bcx, body_ty);\n-        let body_fields =\n-            GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_fields]);\n-        bcx = body_fields.bcx;\n-        let i: int = 0;\n-        for f: ast::anon_obj_field in additional_fields {\n-            // FIXME (part of issue #538): make this work eventually, when we\n-            // have additional field exprs in the AST.\n-            load_if_immediate(bcx, additional_field_vals[i].val,\n-                              additional_field_tys[i]);\n-            let fields_ty: ty::t = ty::mk_tup(ccx.tcx, additional_field_tys);\n-            // Silly check\n-            check type_is_tup_like(bcx, fields_ty);\n-            let field = GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n-            bcx = field.bcx;\n-            bcx =\n-                copy_val(bcx, INIT, field.val, additional_field_vals[i].val,\n-                         additional_field_tys[i]);\n-            i += 1;\n-        }\n-\n-        // If there's a inner_obj, copy a pointer to it into the object's\n-        // body.\n-        alt anon_obj.inner_obj {\n-          none. { }\n-          some(e) {\n-            // If inner_obj (the object being extended) exists, translate it.\n-            // Translating inner_obj returns a ValueRef (pointer to a 2-word\n-            // value) wrapped in a result.\n-            check type_is_tup_like(bcx, body_ty);\n-            let {bcx: cx, val: body_inner_obj} = GEP_tup_like\n-                (bcx, body_ty, body, [0, abi::obj_body_elt_inner_obj]);\n-            bcx = trans_expr_save_in(cx, e, body_inner_obj);\n-          }\n-        }\n-        revoke_clean(bcx, box);\n-        box = PointerCast(bcx, box, llbox_ty);\n-    }\n-    let pair = trans::get_dest_addr(dest);\n-    let pair_vtbl = GEPi(bcx, pair, [0, abi::obj_field_vtbl]);\n-    Store(bcx, vtbl, pair_vtbl);\n-    let pair_box = GEPi(bcx, pair, [0, abi::obj_field_box]);\n-    Store(bcx, box, pair_box);\n-    ret bcx;\n-}\n-\n-// Used only inside create_vtbl and create_backwarding_vtbl to distinguish\n-// different kinds of slots we'll have to create.\n-tag vtbl_mthd {\n-\n-    // Normal methods are complete AST nodes, but for forwarding methods, the\n-    // only information we'll have about them is their type.\n-    normal_mthd(@ast::method);\n-    fwding_mthd(@ty::method);\n-}\n-\n-// Alphabetize ast::methods by ident.  A helper for create_vtbl.\n-fn ast_mthd_lteq(&&a: @ast::method, &&b: @ast::method) -> bool {\n-    ret str::lteq(a.ident, b.ident);\n-}\n-\n-// Alphabetize vtbl_mthds by ident.  A helper for create_vtbl.\n-fn vtbl_mthd_lteq(a: vtbl_mthd, b: vtbl_mthd) -> bool {\n-    alt a {\n-      normal_mthd(ma) {\n-        alt b {\n-          normal_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n-          fwding_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n-        }\n-      }\n-      fwding_mthd(ma) {\n-        alt b {\n-          normal_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n-          fwding_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n-        }\n-      }\n-    }\n-}\n-\n-// filtering_fn: Used by create_vtbl to filter a list of methods to remove the\n-// ones that we don't need forwarding slots for.\n-fn filtering_fn(cx: @local_ctxt, m: vtbl_mthd, addtl_meths: [@ast::method]) ->\n-   option::t<vtbl_mthd> {\n-\n-    // Since m is a fwding_mthd, and we're checking to see if it's in\n-    // addtl_meths (which only contains normal_mthds), we can't just check if\n-    // it's a member of addtl_meths.  Instead, we have to go through\n-    // addtl_meths and see if there's some method in it that has the same name\n-    // as m.\n-    alt m {\n-      fwding_mthd(fm) {\n-        for am: @ast::method in addtl_meths {\n-            if str::eq(am.ident, fm.ident) { ret none; }\n-        }\n-        ret some(fwding_mthd(fm));\n-      }\n-      normal_mthd(_) {\n-        cx.ccx.sess.bug(\"create_vtbl(): shouldn't be any \\\n-                        normal_mthds in meths here\");\n-      }\n-    }\n-}\n-\n-// create_vtbl: Create a vtable for a regular object or for an outer anonymous\n-// object, and return a pointer to it.\n-fn create_vtbl(cx: @local_ctxt, sp: span, outer_obj_ty: ty::t, ob: ast::_obj,\n-               ty_params: [ast::ty_param], inner_obj_ty: option::t<ty::t>,\n-               additional_field_tys: [ty::t]) -> ValueRef {\n-\n-    let llmethods: [ValueRef] = [];\n-\n-    alt inner_obj_ty {\n-      none. {\n-        // We're creating a vtable for a regular object, or for an anonymous\n-        // object that doesn't extend an existing one.\n-\n-        // Sort and process all the methods.\n-        let meths =\n-            std::sort::merge_sort(bind ast_mthd_lteq(_, _), ob.methods);\n-\n-        for m: @ast::method in meths {\n-            llmethods +=\n-                [process_normal_mthd(cx, m, outer_obj_ty, ty_params)];\n-        }\n-      }\n-      some(inner_obj_ty) {\n-        // We're creating a vtable for an anonymous object that extends an\n-        // existing one.\n-\n-        // The vtable needs to contain 'forwarding slots' for any methods that\n-        // were on the inner object and are not being overridden by the outer\n-        // one.  To find the set of methods that we need forwarding slots for,\n-        // we take the set difference of { methods on the original object }\n-        // and { methods being added, whether entirely new or overriding }.\n-\n-        let meths: [vtbl_mthd] = [];\n-\n-        // Gather up methods on the inner object.\n-        alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n-          ty::ty_obj(inner_obj_methods) {\n-            for m: ty::method in inner_obj_methods {\n-                meths += [fwding_mthd(@m)];\n-            }\n-          }\n-          _ {\n-            cx.ccx.sess.bug(\"create_vtbl(): trying to extend a \\\n-                            non-object\");\n-          }\n-        }\n-\n-        // Filter out any methods that we don't need forwarding slots for\n-        // because they're being overridden.\n-        let f = bind filtering_fn(cx, _, ob.methods);\n-        meths = vec::filter_map(meths, f);\n-\n-        // And now add the additional ones, both overriding ones and entirely\n-        // new ones.  These will just be normal methods.\n-        for m: @ast::method in ob.methods { meths += [normal_mthd(m)]; }\n-\n-        // Sort all the methods and process them.\n-        meths =\n-            std::sort::merge_sort(bind vtbl_mthd_lteq(_, _), meths);\n-\n-        // To create forwarding methods, we'll need a \"backwarding\" vtbl.  See\n-        // create_backwarding_vtbl and process_bkwding_method for details.\n-        let backwarding_vtbl: ValueRef =\n-            create_backwarding_vtbl(cx, sp, inner_obj_ty, outer_obj_ty);\n-\n-        for m: vtbl_mthd in meths {\n-            alt m {\n-              normal_mthd(nm) {\n-                llmethods +=\n-                    [process_normal_mthd(cx, nm, outer_obj_ty, ty_params)];\n-              }\n-              fwding_mthd(fm) {\n-                llmethods +=\n-                    [process_fwding_mthd(cx, sp, fm, ty_params, inner_obj_ty,\n-                                         backwarding_vtbl,\n-                                         additional_field_tys)];\n-              }\n-            }\n-        }\n-      }\n-    }\n-\n-    ret finish_vtbl(cx, llmethods, \"vtbl\");\n-}\n-\n-// create_backwarding_vtbl: Create a vtable for the inner object of an\n-// anonymous object, so that any self-calls made from the inner object's\n-// methods get redirected appropriately.\n-fn create_backwarding_vtbl(cx: @local_ctxt, sp: span, inner_obj_ty: ty::t,\n-                           outer_obj_ty: ty::t) -> ValueRef {\n-\n-    // This vtbl needs to have slots for all of the methods on an inner\n-    // object, and it needs to forward them to the corresponding slots on the\n-    // outer object.  All we know about either one are their types.\n-\n-    let llmethods: [ValueRef] = [];\n-    let meths: [ty::method] = [];\n-\n-    // Gather up methods on the inner object.\n-    alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n-      ty::ty_obj(inner_obj_methods) {\n-        for m: ty::method in inner_obj_methods { meths += [m]; }\n-      }\n-      _ {\n-        // Shouldn't happen.\n-        cx.ccx.sess.bug(\"create_backwarding_vtbl(): trying to extend a \\\n-                            non-object\");\n-      }\n-    }\n-\n-    // Methods should have already been sorted, so no need to do so again.\n-    for m: ty::method in meths {\n-        // We pass outer_obj_ty to process_fwding_mthd() because it's the one\n-        // being forwarded to.\n-        llmethods += [process_bkwding_mthd(cx, sp, @m, [], outer_obj_ty, [])];\n-    }\n-    ret finish_vtbl(cx, llmethods, \"backwarding_vtbl\");\n-}\n-\n-// finish_vtbl: Given a vector of vtable entries, create the table in\n-// read-only memory and return a pointer to it.\n-fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: str) ->\n-   ValueRef {\n-    let vtbl = C_struct(llmethods);\n-    let vtbl_name = mangle_internal_name_by_path(cx.ccx, cx.path + [name]);\n-    let gvar =\n-        str::as_buf(vtbl_name,\n-                    {|buf|\n-                        llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), buf)\n-                    });\n-    llvm::LLVMSetInitializer(gvar, vtbl);\n-    llvm::LLVMSetGlobalConstant(gvar, True);\n-    llvm::LLVMSetLinkage(gvar,\n-                         lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    ret gvar;\n-}\n-\n-// begin_fn: Set up an LLVM function for backwarding and forwarding functions.\n-fn begin_fn(cx: @local_ctxt, sp: span, m: @ty::method,\n-            ty_params: [ast::ty_param], fn_name: str) -> ValueRef {\n-\n-    // Create a local context that's aware of the name of the method we're\n-    // creating.\n-    let mcx: @local_ctxt = @{path: cx.path + [\"method\", m.ident] with *cx};\n-\n-    // Make up a name for the function.\n-    let s: str =\n-        mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path, fn_name);\n-\n-    // Get the function's type and declare it.\n-    let llfn_ty: TypeRef = type_of_meth(cx.ccx, sp, m, ty_params);\n-    let llfn: ValueRef = decl_internal_cdecl_fn(cx.ccx.llmod, s, llfn_ty);\n-\n-    ret llfn;\n-}\n-\n-// process_bkwding_mthd: Create the backwarding function that appears in a\n-// backwarding vtable slot.\n-//\n-// Backwarding functions are used in situations where method calls dispatch\n-// back through an outer object.  For example, suppose an inner object has\n-// methods foo and bar, and bar contains the call self.foo().  We extend that\n-// object with a foo method that overrides the inner foo.  Now, a call to\n-// outer.bar() should send us to to inner.bar() via a normal forwarding\n-// function, and then to self.foo().  But inner.bar() was already compiled\n-// under the assumption that self.foo() is inner.foo(), when we really want to\n-// reach outer.foo().  So, we give 'self' a vtable of backwarding functions,\n-// one for each method on inner, each of which takes all the same arguments as\n-// the corresponding method on inner does, calls that method on outer, and\n-// returns the value returned from that call.\n-fn process_bkwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n-                        ty_params: [ast::ty_param], outer_obj_ty: ty::t,\n-                        _additional_field_tys: [ty::t]) -> ValueRef {\n-\n-    let llbackwarding_fn = begin_fn(cx, sp, m, ty_params, \"backwarding_fn\");\n-    let fcx = new_fn_ctxt(cx, sp, llbackwarding_fn);\n-    let bcx = new_top_block_ctxt(fcx);\n-    let lltop = bcx.llbb;\n-\n-    // The self-object will arrive in the backwarding function via the\n-    // llenv argument, but we need to jump past the first item in the\n-    // self-stack to get to the one we really want.\n-\n-    // Cast to self-stack's type.\n-    let llenv =\n-        PointerCast(bcx, fcx.llenv,\n-                    T_ptr(T_struct([cx.ccx.rust_object_type,\n-                                    T_ptr(cx.ccx.rust_object_type)])));\n-    let llself_obj_ptr = GEPi(bcx, llenv, [0, 1]);\n-    llself_obj_ptr = Load(bcx, llself_obj_ptr);\n-\n-    // Cast it back to pointer-to-object-type, so LLVM won't complain.\n-    llself_obj_ptr =\n-        PointerCast(bcx, llself_obj_ptr, T_ptr(cx.ccx.rust_object_type));\n-\n-    // The 'llretptr' that will arrive in the backwarding function we're\n-    // creating also needs to be the correct type.  Cast it to the method's\n-    // return type, if necessary.\n-    let llretptr = fcx.llretptr;\n-    let ccx = cx.ccx;\n-    if ty::type_contains_params(ccx.tcx, m.fty.output) {\n-        let m_output = m.fty.output;\n-        check non_ty_var(ccx, m_output);\n-        let llretty = type_of_inner(ccx, sp, m_output);\n-        llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n-    }\n-\n-    // Get the index of the method we want.\n-    let ix: uint = 0u;\n-    alt ty::struct(bcx_tcx(bcx), outer_obj_ty) {\n-      ty::ty_obj(methods) {\n-        ix = option::get(ty::method_idx(m.ident, methods));\n-      }\n-      _ {\n-        // Shouldn't happen.\n-        cx.ccx.sess.bug(\"process_bkwding_mthd(): non-object type passed \\\n-                        as outer_obj_ty\");\n-      }\n-    }\n-\n-    // Pick out the method being backwarded to from the outer object's vtable.\n-    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n-\n-    let llouter_obj_vtbl =\n-        GEPi(bcx, llself_obj_ptr, [0, abi::obj_field_vtbl]);\n-    llouter_obj_vtbl = Load(bcx, llouter_obj_vtbl);\n-    llouter_obj_vtbl = PointerCast(bcx, llouter_obj_vtbl, vtbl_type);\n-\n-    let llouter_mthd =\n-        GEPi(bcx, llouter_obj_vtbl, [0, ix as int]);\n-\n-    // Set up the outer method to be called.\n-    let llouter_mthd_ty = type_of_meth(bcx_ccx(bcx), sp, m, ty_params);\n-    llouter_mthd =\n-        PointerCast(bcx, llouter_mthd, T_ptr(T_ptr(llouter_mthd_ty)));\n-    llouter_mthd = Load(bcx, llouter_mthd);\n-\n-    // Set up the three implicit arguments to the outer method we'll need to\n-    // call.\n-    let llouter_mthd_args: [ValueRef] = [llretptr, llself_obj_ptr];\n-\n-    // Copy the explicit arguments that are being passed into the forwarding\n-    // function (they're in fcx.llargs) to llouter_mthd_args.\n-\n-    let a: uint = 2u; // retptr, env come first\n-    for arg: ty::arg in m.fty.inputs {\n-        llouter_mthd_args += [llvm::LLVMGetParam(llbackwarding_fn, a)];\n-        a += 1u;\n-    }\n-\n-    // And, finally, call the outer method.\n-    Call(bcx, llouter_mthd, llouter_mthd_args);\n-\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n-\n-    ret llbackwarding_fn;\n-\n-}\n-\n-// process_fwding_mthd: Create the forwarding function that appears in a\n-// vtable slot for method calls that need to forward to another object.  A\n-// helper function for create_vtbl.\n-//\n-// Forwarding functions are used for method calls that fall through to an\n-// inner object.  For example, suppose an inner object has method foo and we\n-// extend it with a method bar.  The only version of 'foo' we have is on the\n-// inner object, but we would like to be able to call outer.foo().  So we use\n-// a forwarding function to make the foo method available on the outer object.\n-// It takes all the same arguments as the foo method on the inner object does,\n-// calls inner.foo() with those arguments, and then returns the value returned\n-// from that call.  (The inner object won't exist until run-time, but we know\n-// its type statically.)\n-fn process_fwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n-                       ty_params: [ast::ty_param], inner_obj_ty: ty::t,\n-                       backwarding_vtbl: ValueRef,\n-                       additional_field_tys: [ty::t]) -> ValueRef unsafe {\n-\n-    // Create a new function context and block context for the function,\n-    // holding onto a pointer to the first block.\n-    let llforwarding_fn = begin_fn(cx, sp, m, ty_params, \"forwarding_fn\");\n-    let fcx = new_fn_ctxt(cx, sp, llforwarding_fn);\n-    let bcx = new_top_block_ctxt(fcx);\n-    let lltop = bcx.llbb;\n-\n-    // The outer object will arrive in the forwarding function via the llenv\n-    // argument.\n-    let llself_obj_ptr = fcx.llenv;\n-\n-    // The 'llretptr' that will arrive in the forwarding function we're\n-    // creating also needs to be the correct type.  Cast it to the method's\n-    // return type, if necessary.\n-    let llretptr = fcx.llretptr;\n-    let ccx = cx.ccx;\n-    if ty::type_contains_params(ccx.tcx, m.fty.output) {\n-        let m_output = m.fty.output;\n-        check non_ty_var(ccx, m_output);\n-        let llretty = type_of_inner(ccx, sp, m_output);\n-        llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n-    }\n-\n-    // Now, we have to get the the inner_obj's vtbl out of the self_obj.  This\n-    // is a multi-step process:\n-\n-    // First, grab the box out of the self_obj.  It contains a refcount and a\n-    // body.\n-    let llself_obj_box =\n-        GEPi(bcx, llself_obj_ptr, [0, abi::obj_field_box]);\n-    llself_obj_box = Load(bcx, llself_obj_box);\n-\n-    let ccx = bcx_ccx(bcx);\n-    let llbox_ty = T_opaque_obj_ptr(ccx);\n-    llself_obj_box = PointerCast(bcx, llself_obj_box, llbox_ty);\n-\n-    // Now, reach into the box and grab the body.\n-    let llself_obj_body =\n-        GEPi(bcx, llself_obj_box, [0, abi::box_rc_field_body]);\n-\n-    // Now, we need to figure out exactly what type the body is supposed to be\n-    // cast to.\n-    let body_ty: ty::t =\n-        create_object_body_type(cx.ccx.tcx, additional_field_tys, [],\n-                                some(inner_obj_ty));\n-    // And cast to that type.\n-    // create_object_body_type maybe should have a postcondition...\n-\n-    let cx_ccx = cx.ccx;\n-    check (type_has_static_size(cx_ccx, body_ty));\n-\n-    llself_obj_body =\n-        PointerCast(bcx, llself_obj_body,\n-                    T_ptr(type_of(cx_ccx, sp, body_ty)));\n-\n-    // Now, reach into the body and grab the inner_obj.\n-    check type_is_tup_like(bcx, body_ty);\n-    let llinner_obj =\n-        GEP_tup_like(bcx, body_ty, llself_obj_body,\n-                     [0, abi::obj_body_elt_inner_obj]);\n-    bcx = llinner_obj.bcx;\n-\n-    // And, now, somewhere in inner_obj is a vtable with an entry for the\n-    // method we want.  First, pick out the vtable, and then pluck that\n-    // method's entry out of the vtable so that the forwarding function can\n-    // call it.\n-    let llinner_obj_vtbl =\n-        GEPi(bcx, llinner_obj.val, [0, abi::obj_field_vtbl]);\n-    llinner_obj_vtbl = Load(bcx, llinner_obj_vtbl);\n-\n-    let llinner_obj_body =\n-        GEPi(bcx, llinner_obj.val, [0, abi::obj_field_box]);\n-    llinner_obj_body = Load(bcx, llinner_obj_body);\n-\n-    // Get the index of the method we want.\n-    let ix: uint = 0u;\n-    alt ty::struct(bcx_tcx(bcx), inner_obj_ty) {\n-      ty::ty_obj(methods) {\n-        ix = option::get(ty::method_idx(m.ident, methods));\n-      }\n-      _ {\n-        // Shouldn't happen.\n-        cx.ccx.sess.bug(\"process_fwding_mthd(): non-object type passed \\\n-                        as target_obj_ty\");\n-      }\n-    }\n-\n-    // Pick out the original method from the vtable.\n-    let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n-    llinner_obj_vtbl = PointerCast(bcx, llinner_obj_vtbl, vtbl_type);\n-\n-    let llorig_mthd =\n-        GEPi(bcx, llinner_obj_vtbl, [0, ix as int]);\n-\n-    // Set up the original method to be called.\n-    let llorig_mthd_ty = type_of_meth(bcx_ccx(bcx), sp, m, ty_params);\n-    llorig_mthd = PointerCast(bcx, llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n-    llorig_mthd = Load(bcx, llorig_mthd);\n-\n-    // Set up the self-stack.\n-    let self_stack =\n-        alloca(bcx,\n-               T_struct([cx.ccx.rust_object_type,\n-                         T_ptr(cx.ccx.rust_object_type)]));\n-    self_stack =\n-        populate_self_stack(bcx, self_stack, llself_obj_ptr, backwarding_vtbl,\n-                            llinner_obj_body);\n-\n-    // Cast self_stack back to pointer-to-object-type to make LLVM happy.\n-    self_stack = PointerCast(bcx, self_stack, T_ptr(cx.ccx.rust_object_type));\n-\n-    // Set up the three implicit arguments to the original method we'll need\n-    // to call.\n-    let llorig_mthd_args: [ValueRef] = [llretptr, self_stack];\n-\n-    // Copy the explicit arguments that are being passed into the forwarding\n-    // function (they're in fcx.llargs) to llorig_mthd_args.\n-\n-    let a: uint = 2u; // retptr, env come first\n-    for arg: ty::arg in m.fty.inputs {\n-        llorig_mthd_args += [llvm::LLVMGetParam(llforwarding_fn, a)];\n-        a += 1u;\n-    }\n-\n-    // And, finally, call the original (inner) method.\n-    Call(bcx, llorig_mthd, llorig_mthd_args);\n-\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n-\n-    ret llforwarding_fn;\n-}\n-\n-// create_object_body_type: Synthesize a big structural tuple type for an\n-// object body: [tydesc, [typaram, ...], [field, ...], inner_obj].\n-fn create_object_body_type(tcx: ty::ctxt, fields_ty: [ty::t],\n-                           typarams_ty: [ty::t],\n-                           maybe_inner_obj_ty: option::t<ty::t>) -> ty::t {\n-\n-    let tydesc_ty: ty::t = ty::mk_type(tcx);\n-    let typarams_ty_tup: ty::t = ty::mk_tup(tcx, typarams_ty);\n-    let fields_ty_tup: ty::t = ty::mk_tup(tcx, fields_ty);\n-\n-    let body_ty: ty::t;\n-    alt maybe_inner_obj_ty {\n-      some(inner_obj_ty) {\n-        body_ty =\n-            ty::mk_tup(tcx,\n-                       [tydesc_ty, typarams_ty_tup, fields_ty_tup,\n-                        inner_obj_ty]);\n-      }\n-      none {\n-        body_ty =\n-            ty::mk_tup(tcx, [tydesc_ty, typarams_ty_tup, fields_ty_tup]);\n-      }\n-    }\n-\n-    ret body_ty;\n-}\n-\n-// process_normal_mthd: Create the contents of a normal vtable slot.  A helper\n-// function for create_vtbl.\n-fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n-                       ty_params: [ast::ty_param]) -> ValueRef {\n-\n-    let llfnty = T_nil();\n-    let ccx = cx.ccx;\n-    alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.id)) {\n-      ty::ty_fn(f) {\n-        let out = f.output;\n-        check non_ty_var(ccx, out);\n-        llfnty = type_of_fn(\n-            ccx, m.span, true, f.inputs, out,\n-            vec::map(ty_params, {|p| param_bounds(ccx, p)}));\n-      }\n-    }\n-    let mcx: @local_ctxt =\n-        @{path: cx.path + [\"method\", m.ident] with *cx};\n-    let s: str = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n-    let llfn: ValueRef = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n-\n-    // Every method on an object gets its node_id inserted into the crate-wide\n-    // item_ids map, together with the ValueRef that points to where that\n-    // method's definition will be in the executable.\n-    ccx.item_ids.insert(m.id, llfn);\n-    ccx.item_symbols.insert(m.id, s);\n-    trans_fn(mcx, m.span, m.decl, m.body, llfn, obj_self(self_ty), ty_params,\n-             m.id);\n-\n-    ret llfn;\n-}\n-\n-// Update a self-stack structure ([[wrapper_self_pair], self_pair*]) to\n-// [[backwarding_vtbl*, inner_obj_body*], outer_obj*].\n-//\n-// We do this when we're receiving the outer object in a forwarding function\n-// via the llenv argument, and we want the forwarding function to call a\n-// method on a \"self\" that's inner-obj-shaped, but we also want to hold onto\n-// the outer obj for potential use later by backwarding functions.\n-fn populate_self_stack(bcx: @block_ctxt, self_stack: ValueRef,\n-                       outer_obj: ValueRef, backwarding_vtbl: ValueRef,\n-                       inner_obj_body: ValueRef) -> ValueRef {\n-\n-    // Drop the outer obj into the second slot.\n-    let self_pair_ptr = GEPi(bcx, self_stack, [0, 1]);\n-    Store(bcx, outer_obj, self_pair_ptr);\n-\n-    // Drop in the backwarding vtbl.\n-    let wrapper_pair = GEPi(bcx, self_stack, [0, 0]);\n-    let wrapper_vtbl_ptr = GEPi(bcx, wrapper_pair, [0, 0]);\n-    let backwarding_vtbl_cast =\n-        PointerCast(bcx, backwarding_vtbl, T_ptr(T_empty_struct()));\n-    Store(bcx, backwarding_vtbl_cast, wrapper_vtbl_ptr);\n-\n-    // Drop in the inner obj body.\n-    let wrapper_body_ptr = GEPi(bcx, wrapper_pair, [0, 1]);\n-    Store(bcx, inner_obj_body, wrapper_body_ptr);\n-\n-    ret self_stack;\n-}\n-\n-fn type_of_meth(ccx: @crate_ctxt, sp: span, m: @ty::method,\n-                tps: [ast::ty_param]) -> TypeRef {\n-    let out_ty = m.fty.output;\n-    check non_ty_var(ccx, out_ty);\n-    type_of_fn(ccx, sp, true, m.fty.inputs, out_ty,\n-               vec::map(tps, {|p| param_bounds(ccx, p)}))\n-}\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "1704069a8c6b524916b73ea1865e211d1ba6dbfd", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -6,7 +6,7 @@ import back::abi;\n import trans::{call_memmove, trans_shared_malloc, llsize_of, type_of_or_i8,\n                INIT, copy_val, load_if_immediate, size_of,\n                get_tydesc,\n-               node_id_type, new_sub_block_ctxt, tps_normal, do_spill_noroot,\n+               node_id_type, new_sub_block_ctxt, do_spill_noroot,\n                dest};\n import trans_build::*;\n import trans_common::*;\n@@ -201,7 +201,7 @@ fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     let elt_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let ti = none;\n     let {bcx: bcx, val: td} =\n-        get_tydesc(bcx, elt_ty, false, tps_normal, ti).result;\n+        get_tydesc(bcx, elt_ty, false, ti).result;\n     trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n     let opaque_v = PointerCast(bcx, vptrptr,\n                                T_ptr(T_ptr(ccx.opaque_vec_type)));"}, {"sha": "7d52c5882a3f7f18ec6f1cfce04924c164a14bd6", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -73,7 +73,6 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n              ccx: ccx};\n         find_pre_post_fn(fcx, body);\n       }\n-      item_obj(o, _, _) {for m in o.methods { find_pre_post_method(ccx, m); }}\n       item_impl(_, _, _, ms) { for m in ms { find_pre_post_method(ccx, m); } }\n     }\n }\n@@ -551,15 +550,6 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_break. { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_cont. { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n-      expr_anon_obj(anon_obj) {\n-        alt anon_obj.inner_obj {\n-          some(ex) {\n-            find_pre_post_expr(fcx, ex);\n-            copy_pre_post(fcx.ccx, e.id, ex);\n-          }\n-          none. { clear_pp(expr_pp(fcx.ccx, e)); }\n-        }\n-      }\n     }\n }\n "}, {"sha": "adfc4411adb0d558142e8a64bff7f26a8a377c9c", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -609,12 +609,6 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       }\n       expr_break. { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_cont. { ret pure_exp(fcx.ccx, e.id, pres); }\n-      expr_anon_obj(anon_obj) {\n-        alt anon_obj.inner_obj {\n-          some(wt) { ret find_pre_post_state_sub(fcx, pres, wt, e.id, none); }\n-          none. { ret pure_exp(fcx.ccx, e.id, pres); }\n-        }\n-      }\n     }\n }\n "}, {"sha": "fe6e99dbd8a07c57de52c5728fae40f30ce0d2a6", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 103, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -72,7 +72,6 @@ export mk_mach_float;\n export mk_native;\n export mk_native_fn;\n export mk_nil;\n-export mk_obj;\n export mk_iface;\n export mk_res;\n export mk_param;\n@@ -124,7 +123,6 @@ export ty_str;\n export ty_vec;\n export ty_native;\n export ty_nil;\n-export ty_obj;\n export ty_iface;\n export ty_res;\n export ty_param;\n@@ -138,7 +136,7 @@ export ty_uint;\n export ty_uniq;\n export ty_var;\n export ty_named;\n-export same_type, same_method;\n+export same_type;\n export ty_var_id;\n export ty_param_substs_opt_and_ty_to_monotype;\n export ty_fn_args;\n@@ -266,7 +264,6 @@ tag sty {\n     ty_rec([field]);\n     ty_fn(fn_ty);\n     ty_native_fn([arg], t);\n-    ty_obj([method]);\n     ty_iface(def_id, [t]);\n     ty_res(def_id, t, [t]);\n     ty_tup([t]);\n@@ -298,8 +295,6 @@ tag type_err {\n     terr_record_size(uint, uint);\n     terr_record_mutability;\n     terr_record_fields(ast::ident, ast::ident);\n-    terr_meth_count;\n-    terr_obj_meths(ast::ident, ast::ident);\n     terr_arg_count;\n     terr_mode_mismatch(mode, mode);\n     terr_constr_len(uint, uint);\n@@ -497,12 +492,6 @@ fn mk_raw_ty(cx: ctxt, st: sty) -> @raw_t {\n       ty_native_fn(args, tt) {\n         derive_flags_sig(cx, has_params, has_vars, args, tt);\n       }\n-      ty_obj(meths) {\n-        for m: method in meths {\n-            derive_flags_sig(cx, has_params, has_vars, m.fty.inputs,\n-                             m.fty.output);\n-        }\n-      }\n       ty_res(_, tt, tps) {\n         derive_flags_t(cx, has_params, has_vars, tt);\n         for tt: t in tps { derive_flags_t(cx, has_params, has_vars, tt); }\n@@ -614,8 +603,6 @@ fn mk_native_fn(cx: ctxt, args: [arg], ty: t) -> t {\n     ret gen_ty(cx, ty_native_fn(args, ty));\n }\n \n-fn mk_obj(cx: ctxt, meths: [method]) -> t { ret gen_ty(cx, ty_obj(meths)); }\n-\n fn mk_iface(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n     ret gen_ty(cx, ty_iface(did, tys));\n }\n@@ -705,12 +692,6 @@ fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n         for a: arg in args { walk_ty(cx, walker, a.ty); }\n         walk_ty(cx, walker, ret_ty);\n       }\n-      ty_obj(methods) {\n-        for m: method in methods {\n-            for a: arg in m.fty.inputs { walk_ty(cx, walker, a.ty); }\n-            walk_ty(cx, walker, m.fty.output);\n-        }\n-      }\n       ty_res(_, sub, tps) {\n         walk_ty(cx, walker, sub);\n         for tp: t in tps { walk_ty(cx, walker, tp); }\n@@ -797,18 +778,6 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n         }\n         ty = mk_native_fn(cx, new_args, fold_ty(cx, fld, ret_ty));\n       }\n-      ty_obj(methods) {\n-        let new_methods = vec::map(methods, {|m|\n-            let new_args = vec::map(m.fty.inputs, {|a|\n-                {mode: a.mode, ty: fold_ty(cx, fld, a.ty)}\n-            });\n-            {ident: m.ident, tps: m.tps,\n-             fty: {inputs: new_args,\n-                   output: fold_ty(cx, fld, m.fty.output)\n-                   with m.fty}}\n-        });\n-        ty = mk_obj(cx, new_methods);\n-      }\n       ty_res(did, subty, tps) {\n         let new_tps = [];\n         for tp: t in tps { new_tps += [fold_ty(cx, fld, tp)]; }\n@@ -850,7 +819,7 @@ fn type_is_bool(cx: ctxt, ty: t) -> bool {\n fn type_is_structural(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_rec(_) | ty_tup(_) | ty_tag(_, _) | ty_fn(_) |\n-      ty_native_fn(_, _) | ty_obj(_) | ty_res(_, _, _) { true }\n+      ty_native_fn(_, _) | ty_res(_, _, _) { true }\n       _ { false }\n     }\n }\n@@ -1056,9 +1025,6 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       ty_native(_) | ty_ptr(_) |\n       ty_send_type. | ty_str. | ty_native_fn(_, _) { kind_sendable }\n       ty_type. { kind_copyable }\n-      // FIXME: obj is broken for now, since we aren't asserting\n-      // anything about its fields.\n-      ty_obj(_) { kind_copyable }\n       ty_fn(f) { proto_kind(f.proto) }\n       ty_opaque_closure_ptr(ck_block.) { kind_noncopyable }\n       ty_opaque_closure_ptr(ck_box.) { kind_copyable }\n@@ -1233,7 +1199,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_send_type. | ty_type. | ty_native(_) | ty_ptr(_) { result = true; }\n       // Boxed types\n       ty_str. | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_) |\n-      ty_native_fn(_, _) | ty_obj(_) | ty_iface(_, _) { result = false; }\n+      ty_native_fn(_, _) | ty_iface(_, _) { result = false; }\n       // Structural types\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1417,11 +1383,6 @@ fn hash_type_structure(st: sty) -> uint {\n       // ???\n       ty_fn(f) { ret hash_fn(27u, f.inputs, f.output); }\n       ty_native_fn(args, rty) { ret hash_fn(28u, args, rty); }\n-      ty_obj(methods) {\n-        let h = 29u;\n-        for m: method in methods { h += (h << 5u) + str::hash(m.ident); }\n-        ret h;\n-      }\n       ty_var(v) { ret hash_uint(30u, v as uint); }\n       ty_param(pid, _) { ret hash_uint(31u, pid); }\n       ty_type. { ret 32u; }\n@@ -1670,20 +1631,11 @@ fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n     ret node_id_has_type_params(cx, expr.id);\n }\n \n-fn expr_is_lval(method_map: typeck::method_map, tcx: ty::ctxt,\n-                e: @ast::expr) -> bool {\n+fn expr_is_lval(method_map: typeck::method_map, e: @ast::expr) -> bool {\n     alt e.node {\n       ast::expr_path(_) | ast::expr_index(_, _) |\n       ast::expr_unary(ast::deref., _) { true }\n-      ast::expr_field(base, ident, _) {\n-        method_map.contains_key(e.id) ? false : {\n-            let basety = type_autoderef(tcx, expr_ty(tcx, base));\n-            alt struct(tcx, basety) {\n-              ty_obj(_) { false }\n-              ty_rec(_) { true }\n-            }\n-        }\n-      }\n+      ast::expr_field(base, ident, _) { !method_map.contains_key(e.id) }\n       _ { false }\n     }\n }\n@@ -2060,35 +2012,6 @@ mod unify {\n           err { err }\n         }\n     }\n-    fn unify_obj(cx: @ctxt, expected_meths: [method],\n-                 actual_meths: [method], variance: variance) -> result {\n-        let result_meths: [method] = [];\n-        let i: uint = 0u;\n-        let expected_len: uint = vec::len(expected_meths);\n-        let actual_len: uint = vec::len(actual_meths);\n-        if expected_len != actual_len { ret ures_err(terr_meth_count); }\n-        while i < expected_len {\n-            let e_meth = expected_meths[i];\n-            let a_meth = actual_meths[i];\n-            if !str::eq(e_meth.ident, a_meth.ident) {\n-                ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident));\n-            }\n-            alt unify_fn(cx, e_meth.fty, a_meth.fty, variance) {\n-              ures_ok(tfn) {\n-                alt struct(cx.tcx, tfn) {\n-                  ty_fn(f) {\n-                    result_meths += [{ident: e_meth.ident,\n-                                      tps: a_meth.tps, fty: f}];\n-                  }\n-                }\n-              }\n-              err { ret err; }\n-            }\n-            i += 1u;\n-        }\n-        let t = mk_obj(cx.tcx, result_meths);\n-        ret ures_ok(t);\n-    }\n \n     // If the given type is a variable, returns the structure of that type.\n     fn resolve_type_structure(tcx: ty_ctxt, vb: @var_bindings, typ: t) ->\n@@ -2483,14 +2406,6 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_obj(expected_meths) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_obj(actual_meths) {\n-                ret unify_obj(cx, expected_meths, actual_meths, variance);\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n-            }\n-          }\n           ty::ty_constr(expected_t, expected_constrs) {\n \n             // unify the base types...\n@@ -2600,13 +2515,6 @@ fn same_type(cx: ctxt, a: t, b: t) -> bool {\n       _ { false }\n     }\n }\n-fn same_method(cx: ctxt, a: method, b: method) -> bool {\n-    a.tps == b.tps && a.fty.proto == b.fty.proto && a.ident == b.ident &&\n-    vec::all2(a.fty.inputs, b.fty.inputs,\n-              {|a, b| a.mode == b.mode && same_type(cx, a.ty, b.ty) }) &&\n-    same_type(cx, a.fty.output, b.fty.output) &&\n-    a.fty.ret_style == b.fty.ret_style\n-}\n \n fn type_err_to_str(err: ty::type_err) -> str {\n     alt err {\n@@ -2639,11 +2547,6 @@ fn type_err_to_str(err: ty::type_err) -> str {\n                 \"' but found one with field '\" + a_fld + \"'\";\n       }\n       terr_arg_count. { ret \"incorrect number of function parameters\"; }\n-      terr_meth_count. { ret \"incorrect number of object methods\"; }\n-      terr_obj_meths(e_meth, a_meth) {\n-        ret \"expected an obj with method '\" + e_meth +\n-                \"' but found one with method '\" + a_meth + \"'\";\n-      }\n       terr_mode_mismatch(e_mode, a_mode) {\n         ret \"expected argument mode \" + mode_str(e_mode) + \" but found \" +\n                 mode_str(a_mode);\n@@ -2675,7 +2578,7 @@ fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n \n fn def_has_ty_params(def: ast::def) -> bool {\n     alt def {\n-      ast::def_obj_field(_, _) | ast::def_mod(_) | ast::def_const(_) |\n+      ast::def_mod(_) | ast::def_const(_) |\n       ast::def_arg(_, _) | ast::def_local(_, _) | ast::def_upvar(_, _, _) |\n       ast::def_ty_param(_, _) | ast::def_binding(_) | ast::def_use(_) |\n       ast::def_native_ty(_) | ast::def_self(_) | ast::def_ty(_) { false }"}, {"sha": "c2ac1cea6ed8e3d36fab8c1ca39845b456c1ef1e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 206, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -42,9 +42,8 @@ type dict_map = hashmap<ast::node_id, dict_res>;\n \n type ty_table = hashmap<ast::def_id, ty::t>;\n \n-// Used for typechecking the methods of an object.\n+// Used for typechecking the methods of an impl\n tag self_info {\n-    self_obj([ast::obj_field], ty::t);\n     self_impl(ty::t);\n }\n \n@@ -102,15 +101,10 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n         ret {bounds: @[], ty: typ};\n       }\n-      ast::def_obj_field(id, _) {\n-        assert (fcx.locals.contains_key(id.node));\n-        let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {bounds: @[], ty: typ};\n-      }\n       ast::def_self(id) {\n         alt get_self_info(fcx.ccx) {\n-          some(self_obj(_, obj_t)) | some(self_impl(obj_t)) {\n-            ret {bounds: @[], ty: obj_t};\n+          some(self_impl(impl_t)) {\n+            ret {bounds: @[], ty: impl_t};\n           }\n         }\n       }\n@@ -356,10 +350,6 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n           }\n         }\n       }\n-      ast::ty_obj(meths) {\n-        let ms = vec::map(meths, {|m| ty_of_ty_method(tcx, mode, m) });\n-        typ = ty::mk_obj(tcx, ty::sort_methods(ms));\n-      }\n       ast::ty_constr(t, cs) {\n         let out_cs = [];\n         for constr: @ast::ty_constr in cs {\n@@ -391,11 +381,6 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n       ast::item_fn(decl, tps, _) {\n         ret ty_of_fn(tcx, mode, decl, tps, local_def(it.id));\n       }\n-      ast::item_obj(ob, tps, _) {\n-        let t_obj = ty_of_obj(tcx, mode, it.ident, ob, tps);\n-        tcx.tcache.insert(local_def(it.id), t_obj);\n-        ret t_obj;\n-      }\n       ast::item_ty(t, tps) {\n         alt tcx.tcache.find(local_def(it.id)) {\n           some(tpt) { ret tpt; }\n@@ -541,30 +526,6 @@ fn ty_of_ty_method(tcx: ty::ctxt, mode: mode, m: ast::ty_method)\n     {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n      fty: ty_of_fn_decl(tcx, mode, ast::proto_bare, m.decl)}\n }\n-fn ty_of_obj(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n-        ty_params: [ast::ty_param]) -> ty::ty_param_bounds_and_ty {\n-    let bounds = ty_param_bounds(tcx, mode, ty_params);\n-    let methods = vec::map(ob.methods, {|m| ty_of_method(tcx, mode, m)});\n-    let t_obj = ty::mk_named(tcx, ty::mk_obj(tcx, ty::sort_methods(methods)),\n-                             @id);\n-    ret {bounds: bounds, ty: t_obj};\n-}\n-fn ty_of_obj_ctor(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n-            ctor_id: ast::node_id, ty_params: [ast::ty_param])\n-    -> ty::ty_param_bounds_and_ty {\n-    let t_obj = ty_of_obj(tcx, mode, id, ob, ty_params);\n-    let t_inputs: [arg] = [];\n-    for f: ast::obj_field in ob.fields {\n-        let t_field = ast_ty_to_ty(tcx, mode, f.ty);\n-        t_inputs += [{mode: ast::by_copy, ty: t_field}];\n-    }\n-    let t_fn = ty::mk_fn(tcx, {proto: ast::proto_box,\n-                               inputs: t_inputs, output: t_obj.ty,\n-                               ret_style: ast::return_val, constraints: []});\n-    let tpt = {bounds: ty_param_bounds(tcx, mode, ty_params), ty: t_fn};\n-    tcx.tcache.insert(local_def(ctor_id), tpt);\n-    ret tpt;\n-}\n \n // A convenience function to use a crate_ctxt to resolve names for\n // ast_ty_to_ty.\n@@ -766,38 +727,6 @@ mod collect {\n               _ {}\n             }\n           }\n-          ast::item_obj(object, ty_params, ctor_id) {\n-            // Now we need to call ty_of_obj_ctor(); this is the type that\n-            // we write into the table for this item.\n-            ty_of_item(cx.tcx, m_collect, it);\n-            let tpt = ty_of_obj_ctor(cx.tcx, m_collect, it.ident, object,\n-                                      ctor_id, ty_params);\n-            write::ty_only(cx.tcx, ctor_id, tpt.ty);\n-            // Write the methods into the type table.\n-            //\n-            // FIXME: Inefficient; this ends up calling\n-            // get_obj_method_types() twice. (The first time was above in\n-            // ty_of_obj().)\n-            let m_types = vec::map(object.methods,\n-                                   {|m| ty_of_method(cx.tcx, m_collect, m)});\n-            let i = 0u;\n-            for m in object.methods {\n-                write::ty_only(cx.tcx, m.id,\n-                               ty::mk_fn(cx.tcx, m_types[i].fty));\n-                i += 1u;\n-            }\n-            // Write in the types of the object fields.\n-            //\n-            // FIXME: We want to use uint::range() here, but that causes\n-            // an assertion in trans.\n-            let args = ty::ty_fn_args(cx.tcx, tpt.ty);\n-            i = 0u;\n-            while i < vec::len::<ty::arg>(args) {\n-                let fld = object.fields[i];\n-                write::ty_only(cx.tcx, fld.id, args[i].ty);\n-                i += 1u;\n-            }\n-          }\n           ast::item_res(decl, tps, _, dtor_id, ctor_id) {\n             let {bounds, params} = mk_ty_params(cx.tcx, tps);\n             let t_arg = ty_of_arg(cx.tcx, m_collect, decl.inputs[0]);\n@@ -1190,16 +1119,6 @@ fn gather_locals(ccx: @crate_ctxt,\n             }\n         };\n \n-    // Add object fields, if any.\n-    alt get_self_info(ccx) {\n-      some(self_obj(ofs, _)) {\n-        for f in ofs {\n-            assign(f.id, some(ty::node_id_to_type(ccx.tcx, f.id)));\n-        }\n-      }\n-      _ {}\n-    }\n-\n     // Add formal parameters.\n     let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n     let i = 0u;\n@@ -2323,21 +2242,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               _ {}\n             }\n           }\n-          ty::ty_obj(methods) {\n-            alt ty::method_idx(field, methods) {\n-              some(ix) {\n-                if n_tys > 0u {\n-                    tcx.sess.span_err(expr.span,\n-                                      \"can't provide type parameters \\\n-                                       to an obj method\");\n-                }\n-                write::ty_only_fixup(fcx, id,\n-                                     ty::mk_fn(tcx, methods[ix].fty));\n-                handled = true;\n-              }\n-              _ {}\n-            }\n-          }\n           _ {}\n         }\n         if !handled {\n@@ -2408,104 +2312,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           }\n         }\n       }\n-      ast::expr_anon_obj(ao) {\n-        let fields: [ast::anon_obj_field] = [];\n-        alt ao.fields { none. { } some(v) { fields = v; } }\n-\n-        let method_types: [ty::method] = [];\n-        {\n-            // Outer methods.\n-            for m: @ast::method in ao.methods {\n-                method_types += [ty_of_method(fcx.ccx.tcx, m_check, m)];\n-            }\n-\n-            // Inner methods.\n-\n-            // Typecheck 'inner_obj'.  If it exists, it had better have object\n-            // type.\n-            let inner_obj_methods: [ty::method] = [];\n-            let inner_obj_sty: option::t<ty::sty> = none;\n-            alt ao.inner_obj {\n-              none. { }\n-              some(e) {\n-                // If there's a inner_obj, we push it onto the self_infos\n-                // stack so that self-calls can be checked within its context\n-                // later.\n-                bot |= check_expr(fcx, e);\n-                let inner_obj_ty = expr_ty(tcx, e);\n-                inner_obj_sty = some(structure_of(fcx, e.span, inner_obj_ty));\n-\n-                alt inner_obj_sty {\n-                  none. { }\n-                  some(sty) {\n-                    alt sty {\n-                      ty::ty_obj(ms) { inner_obj_methods = ms; }\n-                      _ {\n-                        // The user is trying to extend a non-object.\n-                        tcx.sess.span_fatal\n-                            (e.span, syntax::print::pprust::expr_to_str(e)\n-                             + \" does not have object type\");\n-                      }\n-                    }\n-                  }\n-                }\n-              }\n-            }\n-\n-            // Whenever an outer method overrides an inner, we need to remove\n-            // that inner from the type.  Filter inner_obj_methods to remove\n-            // any methods that share a name with an outer method.\n-            fn filtering_fn(ccx: @crate_ctxt, m: ty::method,\n-                            outer_obj_methods: [@ast::method]) ->\n-               option::t<ty::method> {\n-\n-                for om: @ast::method in outer_obj_methods {\n-                    if str::eq(om.ident, m.ident) {\n-                        // We'd better be overriding with one of the same\n-                        // type.  Check to make sure.\n-                        let new_type = ty_of_method(ccx.tcx, m_check, om);\n-                        if !ty::same_method(ccx.tcx, new_type, m) {\n-                            ccx.tcx.sess.span_fatal\n-                                (om.span, \"attempted to override method \"\n-                                 + m.ident + \" with one of a different type\");\n-                        }\n-                        ret none;\n-                    }\n-                }\n-                ret some(m);\n-            }\n-\n-            let f = bind filtering_fn(fcx.ccx, _, ao.methods);\n-            inner_obj_methods = vec::filter_map(inner_obj_methods, f);\n-\n-            method_types += inner_obj_methods;\n-        }\n-\n-        let ot = ty::mk_obj(tcx, ty::sort_methods(method_types));\n-\n-        write::ty_only_fixup(fcx, id, ot);\n-\n-        // Write the methods into the node type table.  (This happens in\n-        // collect::convert for regular objects.)\n-        let i = 0u;\n-        while i < vec::len(ao.methods) {\n-            write::ty_only(tcx, ao.methods[i].id,\n-                           ty::mk_fn(tcx, method_types[i].fty));\n-            i += 1u;\n-        }\n-\n-        fcx.ccx.self_infos +=\n-            [self_obj(\n-                vec::map(fields, ast_util::obj_field_from_anon_obj_field),\n-                ot)];\n-        // Typecheck the methods.\n-        for method: @ast::method in ao.methods {\n-            check_method(fcx.ccx, method);\n-        }\n-\n-        // Now remove the info from the stack.\n-        vec::pop(fcx.ccx.self_infos);\n-      }\n       _ { tcx.sess.unimpl(\"expr type in typeck::check_expr\"); }\n     }\n     if bot { write::ty_only_fixup(fcx, expr.id, ty::mk_bot(tcx)); }\n@@ -2832,15 +2638,6 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_res(decl, tps, body, dtor_id, _) {\n         check_fn(ccx, ast::proto_bare, decl, body, dtor_id, none);\n       }\n-      ast::item_obj(ob, tps, _) {\n-        // We're entering an object, so gather up the info we need.\n-        ccx.self_infos += [self_obj(ob.fields,\n-                                    ccx.tcx.tcache.get(local_def(it.id)).ty)];\n-        // Typecheck the methods.\n-        for method: @ast::method in ob.methods { check_method(ccx, method); }\n-        // Now remove the info from the stack.\n-        vec::pop(ccx.self_infos);\n-      }\n       ast::item_impl(tps, _, ty, ms) {\n         ccx.self_infos += [self_impl(ast_ty_to_ty(ccx.tcx, m_check, ty))];\n         for m in ms { check_method(ccx, m); }"}, {"sha": "bc28ea0480a1a3c3ac6407dbf8d50156de6fd7e6", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -18,7 +18,6 @@ mod middle {\n     mod trans_build;\n     mod trans;\n     mod trans_alt;\n-    mod trans_objects;\n     mod trans_uniq;\n     mod trans_closure;\n     mod trans_vec;"}, {"sha": "25d6cda1b7158bde4352ff55ac52032315d2f2b4", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -34,7 +34,6 @@ type ty_param = {ident: ident, id: node_id, bounds: @[ty_param_bound]};\n \n tag def {\n     def_fn(def_id, purity);\n-    def_obj_field(def_id, mutability);\n     def_self(def_id);\n     def_mod(def_id);\n     def_native_mod(def_id);\n@@ -234,7 +233,6 @@ tag expr_ {\n     /* FIXME Would be nice if expr_check desugared\n        to expr_if_check. */\n     expr_if_check(@expr, blk, option::t<@expr>);\n-    expr_anon_obj(anon_obj);\n     expr_mac(mac);\n }\n \n@@ -318,7 +316,6 @@ tag ty_ {\n     ty_chan(@ty);\n     ty_rec([ty_field]);\n     ty_fn(proto, fn_decl);\n-    ty_obj([ty_method]);\n     ty_tup([@ty]);\n     ty_path(@path, node_id);\n     ty_type;\n@@ -389,19 +386,6 @@ tag ret_style {\n type method = {ident: ident, tps: [ty_param], decl: fn_decl, body: blk,\n                id: node_id, span: span};\n \n-type obj_field = {mut: mutability, ty: @ty, ident: ident, id: node_id};\n-type anon_obj_field =\n-    {mut: mutability, ty: @ty, expr: @expr, ident: ident, id: node_id};\n-\n-type _obj = {fields: [obj_field], methods: [@method]};\n-\n-type anon_obj =\n-    // New fields and methods, if they exist.\n-    // inner_obj: the original object being extended, if it exists.\n-    {fields: option::t<[anon_obj_field]>,\n-     methods: [@method],\n-     inner_obj: option::t<@expr>};\n-\n type _mod = {view_items: [@view_item], items: [@item]};\n \n tag native_abi {\n@@ -439,9 +423,6 @@ tag view_item_ {\n     view_item_export([ident], node_id);\n }\n \n-type obj_def_ids = {ty: node_id, ctor: node_id};\n-\n-\n // Meta-data associated with an item\n type attribute = spanned<attribute_>;\n \n@@ -453,8 +434,8 @@ tag attr_style { attr_outer; attr_inner; }\n \n type attribute_ = {style: attr_style, value: meta_item};\n \n-type item =  // For objs and resources, this is the type def_id\n-    {ident: ident, attrs: [attribute], id: node_id, node: item_, span: span};\n+type item = {ident: ident, attrs: [attribute],\n+             id: node_id, node: item_, span: span};\n \n tag item_ {\n     item_const(@ty, @expr);\n@@ -463,7 +444,6 @@ tag item_ {\n     item_native_mod(native_mod);\n     item_ty(@ty, [ty_param]);\n     item_tag([variant], [ty_param]);\n-    item_obj(_obj, [ty_param], /* constructor id */node_id);\n     item_res(fn_decl /* dtor */, [ty_param], blk,\n              node_id /* dtor id */, node_id /* ctor id */);\n     item_iface([ty_param], [ty_method]);"}, {"sha": "d8070aa098d6c0402acab84661b77b53bb6e9393", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -25,7 +25,7 @@ fn variant_def_ids(d: def) -> {tg: def_id, var: def_id} {\n \n fn def_id_of_def(d: def) -> def_id {\n     alt d {\n-      def_fn(id, _) | def_obj_field(id, _) | def_self(id) | def_mod(id) |\n+      def_fn(id, _) | def_self(id) | def_mod(id) |\n       def_native_mod(id) | def_const(id) | def_arg(id, _) | def_local(id, _) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n       def_binding(id) | def_use(id) | def_native_ty(id) |\n@@ -215,10 +215,6 @@ fn default_block(stmts1: [@stmt], expr1: option::t<@expr>, id1: node_id) ->\n     {view_items: [], stmts: stmts1, expr: expr1, id: id1, rules: default_blk}\n }\n \n-fn obj_field_from_anon_obj_field(f: anon_obj_field) -> obj_field {\n-    ret {mut: f.mut, ty: f.ty, ident: f.ident, id: f.id};\n-}\n-\n // This is a convenience function to transfor ternary expressions to if\n // expressions so that they can be treated the same\n fn ternary_to_if(e: @expr) -> @expr {"}, {"sha": "54684bca83b65cbf5c644a1789e0299c4bf4fdf5", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -95,7 +95,6 @@ fn nf_native_mod_dummy(_n: native_mod) -> native_mod { fail; }\n fn nf_variant_dummy(_v: variant) -> variant { fail; }\n fn nf_ident_dummy(&&_i: ident) -> ident { fail; }\n fn nf_path_dummy(&&_p: @path) -> @path { fail; }\n-fn nf_obj_field_dummy(_o: obj_field) -> obj_field { fail; }\n fn nf_local_dummy(&&_o: @local) -> @local { fail; }\n \n /* some little folds that probably aren't useful to have in ast_fold itself*/\n@@ -216,14 +215,6 @@ fn noop_fold_item(&&i: @item, fld: ast_fold) -> @item {\n }\n \n fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n-    fn fold_obj_field_(of: obj_field, fld: ast_fold) -> obj_field {\n-        ret {mut: of.mut,\n-             ty: fld.fold_ty(of.ty),\n-             ident: fld.fold_ident(of.ident),\n-             id: of.id};\n-    }\n-    let fold_obj_field = bind fold_obj_field_(_, fld);\n-\n     ret alt i {\n           item_const(t, e) { item_const(fld.fold_ty(t), fld.fold_expr(e)) }\n           item_fn(decl, typms, body) {\n@@ -236,11 +227,6 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_tag(variants, typms) {\n             item_tag(vec::map(variants, fld.fold_variant), typms)\n           }\n-          item_obj(o, typms, d) {\n-            item_obj({fields: vec::map(o.fields, fold_obj_field),\n-                      methods: vec::map(o.methods, fld.fold_method)},\n-                     typms, d)\n-          }\n           item_impl(tps, ifce, ty, methods) {\n             item_impl(tps, option::map(ifce, fld.fold_ty), fld.fold_ty(ty),\n                       vec::map(methods, fld.fold_method))\n@@ -327,29 +313,6 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n              span: field.span};\n     }\n     let fold_field = bind fold_field_(_, fld);\n-    fn fold_anon_obj_(ao: anon_obj, fld: ast_fold) -> anon_obj {\n-        fn fold_anon_obj_field_(aof: anon_obj_field, fld: ast_fold) ->\n-           anon_obj_field {\n-            ret {mut: aof.mut,\n-                 ty: fld.fold_ty(aof.ty),\n-                 expr: fld.fold_expr(aof.expr),\n-                 ident: fld.fold_ident(aof.ident),\n-                 id: aof.id};\n-        }\n-        let fold_anon_obj_field = bind fold_anon_obj_field_(_, fld);\n-\n-\n-        ret {fields:\n-                 alt ao.fields {\n-                   option::none. { ao.fields }\n-                   option::some(v) {\n-                     option::some(vec::map(v, fold_anon_obj_field))\n-                   }\n-                 },\n-             methods: vec::map(ao.methods, fld.fold_method),\n-             inner_obj: option::map(ao.inner_obj, fld.fold_expr)}\n-    }\n-    let fold_anon_obj = bind fold_anon_obj_(_, fld);\n \n     let fold_mac = bind fold_mac_(_, fld);\n \n@@ -439,7 +402,6 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_if_check(fld.fold_expr(cond), fld.fold_block(tr),\n                           option::map(fl, fld.fold_expr))\n           }\n-          expr_anon_obj(ao) { expr_anon_obj(fold_anon_obj(ao)) }\n           expr_mac(mac) { expr_mac(fold_mac(mac)) }\n         }\n }"}, {"sha": "57f21e6113b82f0c9e8dd73510ed0e979da605ba", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 77, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -139,8 +139,7 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n                  \"cont\", \"ret\", \"be\", \"fail\", \"type\", \"resource\", \"check\",\n                  \"assert\", \"claim\", \"native\", \"fn\", \"pure\",\n                  \"unsafe\", \"block\", \"import\", \"export\", \"let\", \"const\",\n-                 \"log\", \"tag\", \"obj\", \"copy\", \"sendfn\", \"impl\", \"iface\",\n-                 \"enum\"] {\n+                 \"log\", \"copy\", \"sendfn\", \"impl\", \"iface\", \"enum\"] {\n         words.insert(word, ());\n     }\n     words\n@@ -260,12 +259,12 @@ fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n                            constraints: constrs});\n }\n \n-fn parse_ty_methods(p: parser, allow_tps: bool) -> [ast::ty_method] {\n+fn parse_ty_methods(p: parser) -> [ast::ty_method] {\n     parse_seq(token::LBRACE, token::RBRACE, seq_sep_none(), {|p|\n         let flo = p.span.lo;\n         expect_word(p, \"fn\");\n         let ident = parse_value_ident(p);\n-        let tps = allow_tps ? parse_ty_params(p) : [];\n+        let tps = parse_ty_params(p);\n         let f = parse_ty_fn(ast::proto_bare, p), fhi = p.last_span.hi;\n         expect(p, token::SEMI);\n         alt f {\n@@ -490,8 +489,6 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     } else if eat_word(p, \"sendfn\") {\n         //(breaks prettyprinting!) p.warn(\"sendfn is deprecated, use fn~\");\n         t = parse_ty_fn(ast::proto_uniq, p);\n-    } else if eat_word(p, \"obj\") {\n-        t = ast::ty_obj(parse_ty_methods(p, false));\n     } else if p.token == token::MOD_SEP || is_ident(p.token) {\n         let path = parse_path(p);\n         t = ast::ty_path(path, p.get_id());\n@@ -825,35 +822,6 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n     } else if p.token == token::ELLIPSIS {\n         p.bump();\n         ret pexpr(mk_mac_expr(p, lo, p.span.hi, ast::mac_ellipsis));\n-    } else if eat_word(p, \"obj\") {\n-        // Anonymous object\n-\n-        // Only make people type () if they're actually adding new fields\n-        let fields: option::t<[ast::anon_obj_field]> = none;\n-        if p.token == token::LPAREN {\n-            p.bump();\n-            fields =\n-                some(parse_seq_to_end(token::RPAREN, seq_sep(token::COMMA),\n-                                      parse_anon_obj_field, p));\n-        }\n-        let meths: [@ast::method] = [];\n-        let inner_obj: option::t<@ast::expr> = none;\n-        expect(p, token::LBRACE);\n-        while p.token != token::RBRACE {\n-            if eat_word(p, \"with\") {\n-                inner_obj = some(parse_expr(p));\n-            } else { meths += [parse_method(p, false)]; }\n-        }\n-        hi = p.span.hi;\n-        expect(p, token::RBRACE);\n-        // fields and methods may be *additional* or *overriding* fields\n-        // and methods if there's a inner_obj, or they may be the *only*\n-        // fields and methods if there's no inner_obj.\n-\n-        // We don't need to pull \".node\" out of fields because it's not a\n-        // \"spanned\".\n-        let ob = {fields: fields, methods: meths, inner_obj: inner_obj};\n-        ex = ast::expr_anon_obj(ob);\n     } else if eat_word(p, \"bind\") {\n         let e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         fn parse_expr_opt(p: parser) -> option::t<@ast::expr> {\n@@ -1781,55 +1749,20 @@ fn parse_item_fn(p: parser, purity: ast::purity,\n                 ast::item_fn(decl, t.tps, body), attrs);\n }\n \n-fn parse_obj_field(p: parser) -> ast::obj_field {\n-    let mut = parse_mutability(p);\n-    let ident = parse_value_ident(p);\n-    expect(p, token::COLON);\n-    let ty = parse_ty(p, false);\n-    ret {mut: mut, ty: ty, ident: ident, id: p.get_id()};\n-}\n-\n-fn parse_anon_obj_field(p: parser) -> ast::anon_obj_field {\n-    let mut = parse_mutability(p);\n-    let ident = parse_value_ident(p);\n-    expect(p, token::COLON);\n-    let ty = parse_ty(p, false);\n-    expect(p, token::EQ);\n-    let expr = parse_expr(p);\n-    ret {mut: mut, ty: ty, expr: expr, ident: ident, id: p.get_id()};\n-}\n-\n-fn parse_method(p: parser, allow_tps: bool) -> @ast::method {\n+fn parse_method(p: parser) -> @ast::method {\n     let lo = p.span.lo;\n     expect_word(p, \"fn\");\n     let ident = parse_value_ident(p);\n-    let tps = allow_tps ? parse_ty_params(p) : [];\n+    let tps = parse_ty_params(p);\n     let decl = parse_fn_decl(p, ast::impure_fn);\n     let body = parse_block(p);\n     @{ident: ident, tps: tps, decl: decl, body: body,\n       id: p.get_id(), span: ast_util::mk_sp(lo, body.span.hi)}\n }\n \n-fn parse_item_obj(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.last_span.lo;\n-    let ident = parse_value_ident(p);\n-    let ty_params = parse_ty_params(p);\n-    let fields: ast::spanned<[ast::obj_field]> =\n-        parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n-                  parse_obj_field, p);\n-    let meths: [@ast::method] = [];\n-    expect(p, token::LBRACE);\n-    while p.token != token::RBRACE { meths += [parse_method(p, false)]; }\n-    let hi = p.span.hi;\n-    expect(p, token::RBRACE);\n-    let ob: ast::_obj = {fields: fields.node, methods: meths};\n-    ret mk_item(p, lo, hi, ident, ast::item_obj(ob, ty_params, p.get_id()),\n-                attrs);\n-}\n-\n fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo, ident = parse_ident(p),\n-        tps = parse_ty_params(p), meths = parse_ty_methods(p, true);\n+        tps = parse_ty_params(p), meths = parse_ty_methods(p);\n     ret mk_item(p, lo, p.last_span.hi, ident,\n                 ast::item_iface(tps, meths), attrs);\n }\n@@ -1861,7 +1794,7 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     expect_word(p, \"for\");\n     let ty = parse_ty(p, false), meths = [];\n     expect(p, token::LBRACE);\n-    while !eat(p, token::RBRACE) { meths += [parse_method(p, true)]; }\n+    while !eat(p, token::RBRACE) { meths += [parse_method(p)]; }\n     ret mk_item(p, lo, p.last_span.hi, ident,\n                 ast::item_impl(tps, ifce, ty, meths), attrs);\n }\n@@ -2169,9 +2102,6 @@ fn parse_item(p: parser, attrs: [ast::attribute]) -> option::t<@ast::item> {\n         ret some(parse_item_type(p, attrs));\n     } else if eat_word(p, \"tag\") || eat_word(p, \"enum\") {\n         ret some(parse_item_tag(p, attrs));\n-    } else if is_word(p, \"obj\") && p.look_ahead(1u) != token::LPAREN {\n-        p.bump();\n-        ret some(parse_item_obj(p, attrs));\n     } else if eat_word(p, \"iface\") {\n         ret some(parse_item_iface(p, attrs));\n     } else if eat_word(p, \"impl\") {"}, {"sha": "6de712e14bec34e7e9564fead572395b2321b4f7", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -306,12 +306,6 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n       ast::ty_fn(proto, d) {\n         print_ty_fn(s, proto, d, none, none);\n       }\n-      ast::ty_obj(methods) {\n-        head(s, \"obj\");\n-        bopen(s);\n-        for m in methods { print_ty_method(s, m); }\n-        bclose(s, ty.span);\n-      }\n       ast::ty_path(path, _) { print_path(s, path, false); }\n       ast::ty_type. { word(s.s, \"type\"); }\n       ast::ty_constr(t, cs) {\n@@ -438,32 +432,6 @@ fn print_item(s: ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_obj(_obj, params, _) {\n-        head(s, \"obj\");\n-        word(s.s, item.ident);\n-        print_type_params(s, params);\n-        popen(s);\n-        fn print_field(s: ps, field: ast::obj_field) {\n-            ibox(s, indent_unit);\n-            print_mutability(s, field.mut);\n-            word_space(s, field.ident + \":\");\n-            print_type(s, field.ty);\n-            end(s);\n-        }\n-        fn get_span(f: ast::obj_field) -> codemap::span { ret f.ty.span; }\n-        commasep_cmnt(s, consistent, _obj.fields, print_field, get_span);\n-        pclose(s);\n-        space(s.s);\n-        bopen(s);\n-        for meth: @ast::method in _obj.methods {\n-            hardbreak_if_not_bol(s);\n-            maybe_print_comment(s, meth.span.lo);\n-            print_fn(s, meth.decl, meth.ident, meth.tps);\n-            word(s.s, \" \");\n-            print_block(s, meth.body);\n-        }\n-        bclose(s, item.span);\n-      }\n       ast::item_impl(tps, ifce, ty, methods) {\n         head(s, \"impl\");\n         word(s.s, item.ident);\n@@ -972,50 +940,6 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         pclose(s);\n       }\n       ast::expr_mac(m) { print_mac(s, m); }\n-      ast::expr_anon_obj(anon_obj) {\n-        head(s, \"obj\");\n-\n-        // Fields\n-        popen(s);\n-        fn print_field(s: ps, field: ast::anon_obj_field) {\n-            ibox(s, indent_unit);\n-            print_mutability(s, field.mut);\n-            word_space(s, field.ident + \":\");\n-            print_type(s, field.ty);\n-            space(s.s);\n-            word_space(s, \"=\");\n-            print_expr(s, field.expr);\n-            end(s);\n-        }\n-        fn get_span(f: ast::anon_obj_field) -> codemap::span {\n-            ret f.ty.span;\n-        }\n-        alt anon_obj.fields {\n-          none. { }\n-          some(fields) {\n-            commasep_cmnt(s, consistent, fields, print_field, get_span);\n-          }\n-        }\n-        pclose(s);\n-        space(s.s);\n-        bopen(s);\n-\n-        // Methods\n-        for meth: @ast::method in anon_obj.methods {\n-            hardbreak_if_not_bol(s);\n-            maybe_print_comment(s, meth.span.lo);\n-            print_fn(s, meth.decl, meth.ident, meth.tps);\n-            word(s.s, \" \");\n-            print_block(s, meth.body);\n-        }\n-\n-        // With object\n-        alt anon_obj.inner_obj {\n-          none. { }\n-          some(e) { space(s.s); word_space(s, \"with\"); print_expr(s, e); }\n-        }\n-        bclose(s, expr.span);\n-      }\n     }\n     s.ann.post(ann_node);\n     end(s);"}, {"sha": "33233e9158f402eed8e28d684f78c3e2e438f09a", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -126,14 +126,6 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             for va: variant_arg in vr.node.args { v.visit_ty(va.ty, e, v); }\n         }\n       }\n-      item_obj(ob, tps, _) {\n-        v.visit_ty_params(tps, e, v);\n-        for f: obj_field in ob.fields { v.visit_ty(f.ty, e, v); }\n-        for m: @method in ob.methods {\n-            v.visit_fn(fk_method(m.ident, m.tps), m.decl, m.body, m.span,\n-                       m.id, e, v);\n-        }\n-      }\n       item_impl(tps, ifce, ty, methods) {\n         v.visit_ty_params(tps, e, v);\n         alt ifce { some(ty) { v.visit_ty(ty, e, v); } _ {} }\n@@ -172,12 +164,6 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n         }\n         v.visit_ty(decl.output, e, v);\n       }\n-      ty_obj(tmeths) {\n-        for m: ty_method in tmeths {\n-            for a in m.decl.inputs { v.visit_ty(a.ty, e, v); }\n-            v.visit_ty(m.decl.output, e, v);\n-        }\n-      }\n       ty_path(p, _) { visit_path(p, e, v); }\n       ty_type. {/* no-op */ }\n       ty_constr(t, cs) {\n@@ -370,25 +356,6 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       }\n       expr_check(_, x) { v.visit_expr(x, e, v); }\n       expr_assert(x) { v.visit_expr(x, e, v); }\n-      expr_anon_obj(anon_obj) {\n-        alt anon_obj.fields {\n-          none. { }\n-          some(fields) {\n-            for f: anon_obj_field in fields {\n-                v.visit_ty(f.ty, e, v);\n-                v.visit_expr(f.expr, e, v);\n-            }\n-          }\n-        }\n-        alt anon_obj.inner_obj {\n-          none. { }\n-          some(ex) { v.visit_expr(ex, e, v); }\n-        }\n-        for m: @method in anon_obj.methods {\n-            v.visit_fn(fk_method(m.ident, m.tps), m.decl, m.body, m.span,\n-                       m.id, e, v);\n-        }\n-      }\n       expr_mac(mac) { visit_mac(mac, e, v); }\n     }\n }"}, {"sha": "fe6dfc4fd8a1a450de33ea3f6e51e83c3f15a6db", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24102d50ad2335c1da5c10ddab8996534b2760dc/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=24102d50ad2335c1da5c10ddab8996534b2760dc", "patch": "@@ -112,11 +112,6 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         fn_to_str(cx, ast::proto_bare, none, inputs, output,\n                   ast::return_val, [])\n       }\n-      ty_obj(meths) {\n-        let strs = [];\n-        for m: method in meths { strs += [method_to_str(cx, m)]; }\n-        \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\"\n-      }\n       ty_var(v) { \"<T\" + int::str(v) + \">\" }\n       ty_param(id, _) {\n         \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])"}]}