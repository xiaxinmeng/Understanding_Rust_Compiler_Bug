{"sha": "b6bcbf76fdd4da771977c1591eaec3faad05a9f3", "node_id": "C_kwDOAAsO6NoAKGI2YmNiZjc2ZmRkNGRhNzcxOTc3YzE1OTFlYWVjM2ZhYWQwNWE5ZjM", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-11T19:45:45Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-11T19:45:45Z"}, "message": "Prevent futex_wait from reading outdated value", "tree": {"sha": "3b87629ea1eb6d593cbf3612ce415a3ea4907f2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b87629ea1eb6d593cbf3612ce415a3ea4907f2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6bcbf76fdd4da771977c1591eaec3faad05a9f3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKk8OkACgkQGBtJ+fOP\nM3Sc0Av+NQm/TR/ROYPIJws4C9Oi6TPgy+WlQOVKV0hI0ENXxMl1DCpv7ILTx2jz\nDFxbUj/nMs+CX/2DqR80doauEymgr9rOWvdrf3aI2guY4F/0nE1MRB9iXAlcv8HH\nHsy3O9+JGjl4UzFj3z32a75TcEUgM9qNxxbFPCcgAwnpmZsYK623D0vdbrtZAJJK\nzH/xmMRpumzrQzWEkaQnyQJuTAoJyNHTi3lCYkjdE706xuBrIRKFJ2qek63P82TR\nl+apzVKsHjtvzoKE6sxVLBg6qzftTkVUokrG2mrlRmeHadtRyOsys5fiRDNaRBcT\nn93aiVPtcik4NRGieIkjwpHa7w+TXe1/t+vvRdGT0kUmObNhJrPfrH7DX/4Jjvz9\nyldQhRyj4f0gdkFqoLm3HzjUBJqBDiiwqAqbdQb2EWEVQlZLQ5vFZj5evypKp73o\naYLrfZXbTSBbMXkJan+GQuYyOECoEheU0R8+o4v0/lwfG7B6tGT83Ub5O5IhHQ2W\n8EaOZCMX\n=cuu3\n-----END PGP SIGNATURE-----", "payload": "tree 3b87629ea1eb6d593cbf3612ce415a3ea4907f2a\nparent ada7b72a879d79aaa06f0a2a95edd520615da1a2\nauthor Andy Wang <cbeuw.andy@gmail.com> 1654976745 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654976745 +0100\n\nPrevent futex_wait from reading outdated value\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6bcbf76fdd4da771977c1591eaec3faad05a9f3", "html_url": "https://github.com/rust-lang/rust/commit/b6bcbf76fdd4da771977c1591eaec3faad05a9f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6bcbf76fdd4da771977c1591eaec3faad05a9f3/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ada7b72a879d79aaa06f0a2a95edd520615da1a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ada7b72a879d79aaa06f0a2a95edd520615da1a2", "html_url": "https://github.com/rust-lang/rust/commit/ada7b72a879d79aaa06f0a2a95edd520615da1a2"}], "stats": {"total": 70, "additions": 60, "deletions": 10}, "files": [{"sha": "42494da37b799bdb9a8875357d8a31fc68b507d8", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b6bcbf76fdd4da771977c1591eaec3faad05a9f3/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6bcbf76fdd4da771977c1591eaec3faad05a9f3/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=b6bcbf76fdd4da771977c1591eaec3faad05a9f3", "patch": "@@ -126,24 +126,26 @@ pub fn futex<'tcx>(\n                 Align::from_bytes(4).unwrap(),\n                 CheckInAllocMsg::MemoryAccessTest,\n             )?;\n+            // This SeqCst fence is paired with the SeqCst fence in futex_wake.\n+            // Together, they make sure that our read on addr observes the latest\n+            // value in modification order.\n+            //\n+            // If there is another thread which has changed the value of\n+            // addr (to something other than expected) and called futex_wake\n+            // before we get to run, then we must not block our thread\n+            // because there'll be no one to wake us. We must see\n+            // the value changed by the other thread and return without\n+            // actually waiting.\n+            this.atomic_fence(&[], AtomicFenceOp::SeqCst)?;\n             // Read an `i32` through the pointer, regardless of any wrapper types.\n             // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n             // FIXME: this fails if `addr` is not a pointer type.\n-            // The atomic ordering for futex(https://man7.org/linux/man-pages/man2/futex.2.html):\n-            //  \"The load of the value of the futex word is an\n-            //   atomic memory access (i.e., using atomic machine instructions\n-            //   of the respective architecture).  This load, the comparison\n-            //   with the expected value, and starting to sleep are performed\n-            //   atomically and totally ordered with respect to other futex\n-            //   operations on the same futex word.\"\n-            // SeqCst is total order over all operations.\n-            // FIXME: check if this should be changed when weak memory orders are added.\n             let futex_val = this\n                 .read_scalar_at_offset_atomic(\n                     &addr.into(),\n                     0,\n                     this.machine.layouts.i32,\n-                    AtomicReadOp::SeqCst,\n+                    AtomicReadOp::Relaxed,\n                 )?\n                 .to_i32()?;\n             if val == futex_val {\n@@ -203,6 +205,10 @@ pub fn futex<'tcx>(\n                 this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n                 return Ok(());\n             }\n+            // Together with the SeqCst fence in futex_wait, this makes sure that futex_wait\n+            // will see the latest value on addr which could be changed by our caller\n+            // before doing the syscall.\n+            this.atomic_fence(&[], AtomicFenceOp::SeqCst)?;\n             let mut n = 0;\n             for _ in 0..val {\n                 if let Some(thread) = this.futex_wake(addr_usize, bitset) {"}, {"sha": "56aba60d534a62776e576293bdc5c70c7a3c180c", "filename": "tests/pass/concurrency/linux-futex.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b6bcbf76fdd4da771977c1591eaec3faad05a9f3/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6bcbf76fdd4da771977c1591eaec3faad05a9f3/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs?ref=b6bcbf76fdd4da771977c1591eaec3faad05a9f3", "patch": "@@ -6,6 +6,8 @@ extern crate libc;\n \n use std::mem::MaybeUninit;\n use std::ptr;\n+use std::sync::atomic::AtomicI32;\n+use std::sync::atomic::Ordering;\n use std::thread;\n use std::time::{Duration, Instant};\n \n@@ -206,6 +208,47 @@ fn wait_wake_bitset() {\n     t.join().unwrap();\n }\n \n+const FREE: i32 = 0;\n+const HELD: i32 = 1;\n+fn concurrent_wait_wake() {\n+    static FUTEX: AtomicI32 = AtomicI32::new(0);\n+    for _ in 0..100 {\n+        // Suppose the main thread is holding a lock implemented using futex...\n+        FUTEX.store(HELD, Ordering::Relaxed);\n+\n+        let t = thread::spawn(move || {\n+            // If this syscall runs first, then we'll be woken up by\n+            // the main thread's FUTEX_WAKE, and all is fine.\n+            //\n+            // If this sycall runs after the main thread's store\n+            // and FUTEX_WAKE, the syscall must observe that\n+            // the FUTEX is FREE != HELD and return without waiting\n+            // or we'll deadlock.\n+            unsafe {\n+                libc::syscall(\n+                    libc::SYS_futex,\n+                    &FUTEX as *const AtomicI32,\n+                    libc::FUTEX_WAIT,\n+                    HELD,\n+                    ptr::null::<libc::timespec>(),\n+                );\n+            }\n+        });\n+\n+        FUTEX.store(FREE, Ordering::Relaxed);\n+        unsafe {\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &FUTEX as *const AtomicI32,\n+                libc::FUTEX_WAKE,\n+                1,\n+            );\n+        }\n+\n+        t.join().unwrap();\n+    }\n+}\n+\n fn main() {\n     wake_nobody();\n     wake_dangling();\n@@ -214,4 +257,5 @@ fn main() {\n     wait_absolute_timeout();\n     wait_wake();\n     wait_wake_bitset();\n+    concurrent_wait_wake();\n }"}]}