{"sha": "cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjOTdlYWY5ZjkxODFhZWM1YTFiYTY0NTliMjA0ZWQ0YTdmYmE2MmE=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2019-05-10T07:59:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-10T07:59:07Z"}, "message": "Merge pull request #3546 from bash/unreachable-pub\n\nEnable unreachable_pub lint", "tree": {"sha": "ba8c6b6b3bed52da45513c496d66be163c055723", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba8c6b6b3bed52da45513c496d66be163c055723"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc1S9LCRBK7hj4Ov3rIwAAdHIIAGsU2aYt6ynvP0ulJ63lw8FW\nXbIRCpPUl4jEiMHKagfh8UH3smW1PuNDbTWO/W+aGnXnUUkcAttjEQRGquuU4TO1\nlarGdraChGHA4K4NLD6WBZACDUVgs2ehJXv6/fA8NZQPTotF9rqNRINaAo4hlFr9\nOoPgKp4wkr2vysAN3zZSm3+hhaTP1GAARCWgnz6NCidnWbciTE10Dg28vZ2zONO2\nFciChkG5SHHmJh+SElUwgDhPyo2yJKa/bkTrBNMGaCiTQnfwN5jOCW8SDRfGtPi2\nvOh5CkSBB44UVkG1Bj8IOOL2PAASFKcZ40X3K1k94dJEUje8gPjOKOoRE4J3cOg=\n=POSX\n-----END PGP SIGNATURE-----\n", "payload": "tree ba8c6b6b3bed52da45513c496d66be163c055723\nparent 4bc5911348b5b74b4c561325e29111621776de15\nparent d1c1f8e61e5773fdbcb4d548820a543549c4a7b9\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1557475147 +0200\ncommitter GitHub <noreply@github.com> 1557475147 +0200\n\nMerge pull request #3546 from bash/unreachable-pub\n\nEnable unreachable_pub lint"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "html_url": "https://github.com/rust-lang/rust/commit/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bc5911348b5b74b4c561325e29111621776de15", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bc5911348b5b74b4c561325e29111621776de15", "html_url": "https://github.com/rust-lang/rust/commit/4bc5911348b5b74b4c561325e29111621776de15"}, {"sha": "d1c1f8e61e5773fdbcb4d548820a543549c4a7b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1c1f8e61e5773fdbcb4d548820a543549c4a7b9", "html_url": "https://github.com/rust-lang/rust/commit/d1c1f8e61e5773fdbcb4d548820a543549c4a7b9"}], "stats": {"total": 801, "additions": 428, "deletions": 373}, "files": [{"sha": "498d6e4d85114cb592391894d4f0d2c34429b226", "filename": "src/attr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -15,7 +15,7 @@ use crate::types::{rewrite_path, PathContext};\n use crate::utils::{count_newlines, mk_sp};\n \n /// Returns attributes on the given statement.\n-pub fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n+pub(crate) fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n     match stmt.node {\n         ast::StmtKind::Local(ref local) => &local.attrs,\n         ast::StmtKind::Item(ref item) => &item.attrs,\n@@ -24,7 +24,7 @@ pub fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n     }\n }\n \n-pub fn get_span_without_attrs(stmt: &ast::Stmt) -> Span {\n+pub(crate) fn get_span_without_attrs(stmt: &ast::Stmt) -> Span {\n     match stmt.node {\n         ast::StmtKind::Local(ref local) => local.span,\n         ast::StmtKind::Item(ref item) => item.span,\n@@ -37,7 +37,10 @@ pub fn get_span_without_attrs(stmt: &ast::Stmt) -> Span {\n }\n \n /// Returns attributes that are within `outer_span`.\n-pub fn filter_inline_attrs(attrs: &[ast::Attribute], outer_span: Span) -> Vec<ast::Attribute> {\n+pub(crate) fn filter_inline_attrs(\n+    attrs: &[ast::Attribute],\n+    outer_span: Span,\n+) -> Vec<ast::Attribute> {\n     attrs\n         .iter()\n         .filter(|a| outer_span.lo() <= a.span.lo() && a.span.hi() <= outer_span.hi())"}, {"sha": "c4941141a64a4a52e357a31561afd6b652215895", "filename": "src/chains.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -74,7 +74,7 @@ use crate::utils::{\n     trimmed_last_line_width, wrap_str,\n };\n \n-pub fn rewrite_chain(\n+pub(crate) fn rewrite_chain(\n     expr: &ast::Expr,\n     context: &RewriteContext<'_>,\n     shape: Shape,"}, {"sha": "79c59bb1e8cab075e837cfdccce6ca71ec6d151b", "filename": "src/checkstyle.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fcheckstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fcheckstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcheckstyle.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -7,7 +7,7 @@ use crate::rustfmt_diff::{DiffLine, Mismatch};\n ///\n /// Note that emitting checkstyle output is not stable and may removed in a\n /// future version of Rustfmt.\n-pub fn header() -> String {\n+pub(crate) fn header() -> String {\n     let mut xml_heading = String::new();\n     xml_heading.push_str(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n     xml_heading.push_str(\"\\n\");\n@@ -19,11 +19,11 @@ pub fn header() -> String {\n ///\n /// Note that emitting checkstyle output is not stable and may removed in a\n /// future version of Rustfmt.\n-pub fn footer() -> String {\n+pub(crate) fn footer() -> String {\n     \"</checkstyle>\\n\".to_owned()\n }\n \n-pub fn output_checkstyle_file<T>(\n+pub(crate) fn output_checkstyle_file<T>(\n     mut writer: T,\n     filename: &Path,\n     diff: Vec<Mismatch>,"}, {"sha": "8a7f47af44b3aa520458745b2e7097d8bee4b115", "filename": "src/closures.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -23,7 +23,7 @@ use crate::utils::{last_line_width, left_most_sub_expr, stmt_expr, NodeIdExt};\n //     statement without needing a semi-colon), then adding or removing braces\n //     can change whether it is treated as an expression or statement.\n \n-pub fn rewrite_closure(\n+pub(crate) fn rewrite_closure(\n     capture: ast::CaptureBy,\n     asyncness: ast::IsAsync,\n     movability: ast::Movability,\n@@ -286,7 +286,7 @@ fn rewrite_closure_fn_decl(\n \n // Rewriting closure which is placed at the end of the function call's arg.\n // Returns `None` if the reformatted closure 'looks bad'.\n-pub fn rewrite_last_closure(\n+pub(crate) fn rewrite_last_closure(\n     context: &RewriteContext<'_>,\n     expr: &ast::Expr,\n     shape: Shape,\n@@ -351,7 +351,7 @@ pub fn rewrite_last_closure(\n }\n \n /// Returns `true` if the given vector of arguments has more than one `ast::ExprKind::Closure`.\n-pub fn args_have_many_closure(args: &[OverflowableItem<'_>]) -> bool {\n+pub(crate) fn args_have_many_closure(args: &[OverflowableItem<'_>]) -> bool {\n     args.iter()\n         .filter_map(OverflowableItem::to_expr)\n         .filter(|expr| match expr.node {"}, {"sha": "7f7dce1166d09c104293c5c4d2b2d4bed0af047b", "filename": "src/comment.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -25,7 +25,7 @@ fn is_custom_comment(comment: &str) -> bool {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n-pub enum CommentStyle<'a> {\n+pub(crate) enum CommentStyle<'a> {\n     DoubleSlash,\n     TripleSlash,\n     Doc,\n@@ -45,7 +45,7 @@ fn custom_opener(s: &str) -> &str {\n \n impl<'a> CommentStyle<'a> {\n     /// Returns `true` if the commenting style covers a line only.\n-    pub fn is_line_comment(&self) -> bool {\n+    pub(crate) fn is_line_comment(&self) -> bool {\n         match *self {\n             CommentStyle::DoubleSlash\n             | CommentStyle::TripleSlash\n@@ -56,7 +56,7 @@ impl<'a> CommentStyle<'a> {\n     }\n \n     /// Returns `true` if the commenting style can span over multiple lines.\n-    pub fn is_block_comment(&self) -> bool {\n+    pub(crate) fn is_block_comment(&self) -> bool {\n         match *self {\n             CommentStyle::SingleBullet | CommentStyle::DoubleBullet | CommentStyle::Exclamation => {\n                 true\n@@ -66,14 +66,14 @@ impl<'a> CommentStyle<'a> {\n     }\n \n     /// Returns `true` if the commenting style is for documentation.\n-    pub fn is_doc_comment(&self) -> bool {\n+    pub(crate) fn is_doc_comment(&self) -> bool {\n         match *self {\n             CommentStyle::TripleSlash | CommentStyle::Doc => true,\n             _ => false,\n         }\n     }\n \n-    pub fn opener(&self) -> &'a str {\n+    pub(crate) fn opener(&self) -> &'a str {\n         match *self {\n             CommentStyle::DoubleSlash => \"// \",\n             CommentStyle::TripleSlash => \"/// \",\n@@ -85,7 +85,7 @@ impl<'a> CommentStyle<'a> {\n         }\n     }\n \n-    pub fn closer(&self) -> &'a str {\n+    pub(crate) fn closer(&self) -> &'a str {\n         match *self {\n             CommentStyle::DoubleSlash\n             | CommentStyle::TripleSlash\n@@ -96,7 +96,7 @@ impl<'a> CommentStyle<'a> {\n         }\n     }\n \n-    pub fn line_start(&self) -> &'a str {\n+    pub(crate) fn line_start(&self) -> &'a str {\n         match *self {\n             CommentStyle::DoubleSlash => \"// \",\n             CommentStyle::TripleSlash => \"/// \",\n@@ -107,7 +107,7 @@ impl<'a> CommentStyle<'a> {\n         }\n     }\n \n-    pub fn to_str_tuplet(&self) -> (&'a str, &'a str, &'a str) {\n+    pub(crate) fn to_str_tuplet(&self) -> (&'a str, &'a str, &'a str) {\n         (self.opener(), self.closer(), self.line_start())\n     }\n }\n@@ -143,7 +143,7 @@ fn comment_style(orig: &str, normalize_comments: bool) -> CommentStyle<'_> {\n }\n \n /// Returns true if the last line of the passed string finishes with a block-comment.\n-pub fn is_last_comment_block(s: &str) -> bool {\n+pub(crate) fn is_last_comment_block(s: &str) -> bool {\n     s.trim_end().ends_with(\"*/\")\n }\n \n@@ -152,7 +152,7 @@ pub fn is_last_comment_block(s: &str) -> bool {\n /// recovered. If `allow_extend` is true and there is no comment between the two\n /// strings, then they will be put on a single line as long as doing so does not\n /// exceed max width.\n-pub fn combine_strs_with_missing_comments(\n+pub(crate) fn combine_strs_with_missing_comments(\n     context: &RewriteContext<'_>,\n     prev_str: &str,\n     next_str: &str,\n@@ -239,11 +239,11 @@ pub fn combine_strs_with_missing_comments(\n     Some(result)\n }\n \n-pub fn rewrite_doc_comment(orig: &str, shape: Shape, config: &Config) -> Option<String> {\n+pub(crate) fn rewrite_doc_comment(orig: &str, shape: Shape, config: &Config) -> Option<String> {\n     identify_comment(orig, false, shape, config, true)\n }\n \n-pub fn rewrite_comment(\n+pub(crate) fn rewrite_comment(\n     orig: &str,\n     block_style: bool,\n     shape: Shape,\n@@ -845,7 +845,7 @@ fn has_url(s: &str) -> bool {\n \n /// Given the span, rewrite the missing comment inside it if available.\n /// Note that the given span must only include comments (or leading/trailing whitespaces).\n-pub fn rewrite_missing_comment(\n+pub(crate) fn rewrite_missing_comment(\n     span: Span,\n     shape: Shape,\n     context: &RewriteContext<'_>,\n@@ -862,7 +862,7 @@ pub fn rewrite_missing_comment(\n /// Recover the missing comments in the specified span, if available.\n /// The layout of the comments will be preserved as long as it does not break the code\n /// and its total width does not exceed the max width.\n-pub fn recover_missing_comment_in_span(\n+pub(crate) fn recover_missing_comment_in_span(\n     span: Span,\n     shape: Shape,\n     context: &RewriteContext<'_>,\n@@ -964,7 +964,7 @@ fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle<'_>) -> (&'a s\n     }\n }\n \n-pub trait FindUncommented {\n+pub(crate) trait FindUncommented {\n     fn find_uncommented(&self, pat: &str) -> Option<usize>;\n }\n \n@@ -997,7 +997,7 @@ impl FindUncommented for str {\n // is expected to be prefixed by a comment, including delimiters.\n // Good: `/* /* inner */ outer */ code();`\n // Bad:  `code(); // hello\\n world!`\n-pub fn find_comment_end(s: &str) -> Option<usize> {\n+pub(crate) fn find_comment_end(s: &str) -> Option<usize> {\n     let mut iter = CharClasses::new(s.char_indices());\n     for (kind, (i, _c)) in &mut iter {\n         if kind == FullCodeCharKind::Normal || kind == FullCodeCharKind::InString {\n@@ -1014,11 +1014,11 @@ pub fn find_comment_end(s: &str) -> Option<usize> {\n }\n \n /// Returns `true` if text contains any comment.\n-pub fn contains_comment(text: &str) -> bool {\n+pub(crate) fn contains_comment(text: &str) -> bool {\n     CharClasses::new(text.chars()).any(|(kind, _)| kind.is_comment())\n }\n \n-pub struct CharClasses<T>\n+pub(crate) struct CharClasses<T>\n where\n     T: Iterator,\n     T::Item: RichChar,\n@@ -1027,7 +1027,7 @@ where\n     status: CharClassesStatus,\n }\n \n-pub trait RichChar {\n+pub(crate) trait RichChar {\n     fn get_char(&self) -> char;\n }\n \n@@ -1073,7 +1073,7 @@ enum CharClassesStatus {\n \n /// Distinguish between functional part of code and comments\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n-pub enum CodeCharKind {\n+pub(crate) enum CodeCharKind {\n     Normal,\n     Comment,\n }\n@@ -1082,7 +1082,7 @@ pub enum CodeCharKind {\n /// describing opening and closing of comments for ease when chunking\n /// code from tagged characters\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n-pub enum FullCodeCharKind {\n+pub(crate) enum FullCodeCharKind {\n     Normal,\n     /// The first character of a comment, there is only one for a comment (always '/')\n     StartComment,\n@@ -1106,7 +1106,7 @@ pub enum FullCodeCharKind {\n }\n \n impl FullCodeCharKind {\n-    pub fn is_comment(self) -> bool {\n+    pub(crate) fn is_comment(self) -> bool {\n         match self {\n             FullCodeCharKind::StartComment\n             | FullCodeCharKind::InComment\n@@ -1119,7 +1119,7 @@ impl FullCodeCharKind {\n     }\n \n     /// Returns true if the character is inside a comment\n-    pub fn inside_comment(self) -> bool {\n+    pub(crate) fn inside_comment(self) -> bool {\n         match self {\n             FullCodeCharKind::InComment\n             | FullCodeCharKind::StartStringCommented\n@@ -1129,12 +1129,12 @@ impl FullCodeCharKind {\n         }\n     }\n \n-    pub fn is_string(self) -> bool {\n+    pub(crate) fn is_string(self) -> bool {\n         self == FullCodeCharKind::InString || self == FullCodeCharKind::StartString\n     }\n \n     /// Returns true if the character is within a commented string\n-    pub fn is_commented_string(self) -> bool {\n+    pub(crate) fn is_commented_string(self) -> bool {\n         self == FullCodeCharKind::InStringCommented\n             || self == FullCodeCharKind::StartStringCommented\n     }\n@@ -1153,7 +1153,7 @@ where\n     T: Iterator,\n     T::Item: RichChar,\n {\n-    pub fn new(base: T) -> CharClasses<T> {\n+    pub(crate) fn new(base: T) -> CharClasses<T> {\n         CharClasses {\n             base: multipeek(base),\n             status: CharClassesStatus::Normal,\n@@ -1336,13 +1336,13 @@ where\n \n /// An iterator over the lines of a string, paired with the char kind at the\n /// end of the line.\n-pub struct LineClasses<'a> {\n+pub(crate) struct LineClasses<'a> {\n     base: iter::Peekable<CharClasses<std::str::Chars<'a>>>,\n     kind: FullCodeCharKind,\n }\n \n impl<'a> LineClasses<'a> {\n-    pub fn new(s: &'a str) -> Self {\n+    pub(crate) fn new(s: &'a str) -> Self {\n         LineClasses {\n             base: CharClasses::new(s.chars()).peekable(),\n             kind: FullCodeCharKind::Normal,\n@@ -1458,14 +1458,14 @@ impl<'a> Iterator for UngroupedCommentCodeSlices<'a> {\n /// Iterator over an alternating sequence of functional and commented parts of\n /// a string. The first item is always a, possibly zero length, subslice of\n /// functional text. Line style comments contain their ending newlines.\n-pub struct CommentCodeSlices<'a> {\n+pub(crate) struct CommentCodeSlices<'a> {\n     slice: &'a str,\n     last_slice_kind: CodeCharKind,\n     last_slice_end: usize,\n }\n \n impl<'a> CommentCodeSlices<'a> {\n-    pub fn new(slice: &'a str) -> CommentCodeSlices<'a> {\n+    pub(crate) fn new(slice: &'a str) -> CommentCodeSlices<'a> {\n         CommentCodeSlices {\n             slice,\n             last_slice_kind: CodeCharKind::Comment,\n@@ -1536,7 +1536,7 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n \n /// Checks is `new` didn't miss any comment from `span`, if it removed any, return previous text\n /// (if it fits in the width/offset, else return `None`), else return `new`\n-pub fn recover_comment_removed(\n+pub(crate) fn recover_comment_removed(\n     new: String,\n     span: Span,\n     context: &RewriteContext<'_>,\n@@ -1560,7 +1560,7 @@ pub fn recover_comment_removed(\n     }\n }\n \n-pub fn filter_normal_code(code: &str) -> String {\n+pub(crate) fn filter_normal_code(code: &str) -> String {\n     let mut buffer = String::with_capacity(code.len());\n     LineClasses::new(code).for_each(|(kind, line)| match kind {\n         FullCodeCharKind::Normal"}, {"sha": "d14969418ad170a8019655cf34a2887827467f9f", "filename": "src/config/config_type.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fconfig_type.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -2,7 +2,7 @@ use crate::config::file_lines::FileLines;\n use crate::config::options::{IgnoreList, WidthHeuristics};\n \n /// Trait for types that can be used in `Config`.\n-pub trait ConfigType: Sized {\n+pub(crate) trait ConfigType: Sized {\n     /// Returns hint text for use in `Config::print_docs()`. For enum types, this is a\n     /// pipe-separated list of variants; for other types it returns \"<type>\".\n     fn doc_hint() -> String;\n@@ -75,6 +75,7 @@ macro_rules! create_config {\n         use serde::{Deserialize, Serialize};\n \n         #[derive(Clone)]\n+        #[allow(unreachable_pub)]\n         pub struct Config {\n             // if a license_template_path has been specified, successfully read, parsed and compiled\n             // into a regex, it will be stored here\n@@ -91,6 +92,7 @@ macro_rules! create_config {\n         // We first parse into `PartialConfig`, then create a default `Config`\n         // and overwrite the properties with corresponding values from `PartialConfig`.\n         #[derive(Deserialize, Serialize, Clone)]\n+        #[allow(unreachable_pub)]\n         pub struct PartialConfig {\n             $(pub $i: Option<$ty>),+\n         }\n@@ -100,10 +102,12 @@ macro_rules! create_config {\n         // `config.set().option(false)`. It's pretty ugly. Consider replacing\n         // with `config.set_option(false)` if we ever get a stable/usable\n         // `concat_idents!()`.\n+        #[allow(unreachable_pub)]\n         pub struct ConfigSetter<'a>(&'a mut Config);\n \n         impl<'a> ConfigSetter<'a> {\n             $(\n+            #[allow(unreachable_pub)]\n             pub fn $i(&mut self, value: $ty) {\n                 (self.0).$i.2 = value;\n                 match stringify!($i) {\n@@ -117,10 +121,12 @@ macro_rules! create_config {\n \n         // Query each option, returns true if the user set the option, false if\n         // a default was used.\n+        #[allow(unreachable_pub)]\n         pub struct ConfigWasSet<'a>(&'a Config);\n \n         impl<'a> ConfigWasSet<'a> {\n             $(\n+            #[allow(unreachable_pub)]\n             pub fn $i(&self) -> bool {\n                 (self.0).$i.1\n             }\n@@ -129,16 +135,19 @@ macro_rules! create_config {\n \n         impl Config {\n             $(\n+            #[allow(unreachable_pub)]\n             pub fn $i(&self) -> $ty {\n                 self.$i.0.set(true);\n                 self.$i.2.clone()\n             }\n             )+\n \n+            #[allow(unreachable_pub)]\n             pub fn set(&mut self) -> ConfigSetter<'_> {\n                 ConfigSetter(self)\n             }\n \n+            #[allow(unreachable_pub)]\n             pub fn was_set(&self) -> ConfigWasSet<'_> {\n                 ConfigWasSet(self)\n             }\n@@ -185,6 +194,7 @@ macro_rules! create_config {\n                 }\n             }\n \n+            #[allow(unreachable_pub)]\n             pub fn used_options(&self) -> PartialConfig {\n                 PartialConfig {\n                     $(\n@@ -197,6 +207,7 @@ macro_rules! create_config {\n                 }\n             }\n \n+            #[allow(unreachable_pub)]\n             pub fn all_options(&self) -> PartialConfig {\n                 PartialConfig {\n                     $(\n@@ -205,6 +216,7 @@ macro_rules! create_config {\n                 }\n             }\n \n+            #[allow(unreachable_pub)]\n             pub fn override_value(&mut self, key: &str, val: &str)\n             {\n                 match key {\n@@ -228,12 +240,14 @@ macro_rules! create_config {\n                 }\n             }\n \n+            #[allow(unreachable_pub)]\n             pub fn is_hidden_option(name: &str) -> bool {\n                 const HIDE_OPTIONS: [&str; 4] =\n                     [\"verbose\", \"verbose_diff\", \"file_lines\", \"width_heuristics\"];\n                 HIDE_OPTIONS.contains(&name)\n             }\n \n+            #[allow(unreachable_pub)]\n             pub fn print_docs(out: &mut dyn Write, include_unstable: bool) {\n                 use std::cmp;\n                 let max = 0;\n@@ -293,6 +307,7 @@ macro_rules! create_config {\n                 self.ignore.2.add_prefix(dir);\n             }\n \n+            #[allow(unreachable_pub)]\n             /// Returns `true` if the config key was explicitly set and is the default value.\n             pub fn is_default(&self, key: &str) -> bool {\n                 $("}, {"sha": "2eb23bbcec7f1ba4b0f7a8cd2fc6c0d65aa1c18b", "filename": "src/config/license.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fconfig%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fconfig%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Flicense.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -7,7 +7,7 @@ use regex;\n use regex::Regex;\n \n #[derive(Debug)]\n-pub enum LicenseError {\n+pub(crate) enum LicenseError {\n     IO(io::Error),\n     Regex(regex::Error),\n     Parse(String),\n@@ -47,7 +47,7 @@ enum ParsingState {\n \n use self::ParsingState::*;\n \n-pub struct TemplateParser {\n+pub(crate) struct TemplateParser {\n     parsed: String,\n     buffer: String,\n     state: ParsingState,\n@@ -110,7 +110,7 @@ impl TemplateParser {\n     /// \"\n     /// );\n     /// ```\n-    pub fn parse(template: &str) -> Result<String, LicenseError> {\n+    pub(crate) fn parse(template: &str) -> Result<String, LicenseError> {\n         let mut parser = Self::new();\n         for chr in template.chars() {\n             if chr == '\\n' {\n@@ -212,7 +212,7 @@ impl TemplateParser {\n     }\n }\n \n-pub fn load_and_compile_template(path: &str) -> Result<Regex, LicenseError> {\n+pub(crate) fn load_and_compile_template(path: &str) -> Result<Regex, LicenseError> {\n     let mut lt_file = File::open(&path)?;\n     let mut lt_str = String::new();\n     lt_file.read_to_string(&mut lt_str)?;"}, {"sha": "82a7f5fc39a24b2dc52c073e04aa1e1a9b3c47eb", "filename": "src/config/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -8,18 +8,21 @@ use std::{env, fs};\n use regex::Regex;\n \n use crate::config::config_type::ConfigType;\n+#[allow(unreachable_pub)]\n pub use crate::config::file_lines::{FileLines, FileName, Range};\n+#[allow(unreachable_pub)]\n pub use crate::config::lists::*;\n+#[allow(unreachable_pub)]\n pub use crate::config::options::*;\n \n #[macro_use]\n-pub mod config_type;\n+pub(crate) mod config_type;\n #[macro_use]\n-pub mod options;\n+pub(crate) mod options;\n \n-pub mod file_lines;\n-pub mod license;\n-pub mod lists;\n+pub(crate) mod file_lines;\n+pub(crate) mod license;\n+pub(crate) mod lists;\n \n // This macro defines configuration options used in rustfmt. Each option\n // is defined as follows:"}, {"sha": "c4c41fb695742dccf190a55a4ea6ae567f85c908", "filename": "src/expr.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -44,12 +44,12 @@ impl Rewrite for ast::Expr {\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-pub enum ExprType {\n+pub(crate) enum ExprType {\n     Statement,\n     SubExpression,\n }\n \n-pub fn format_expr(\n+pub(crate) fn format_expr(\n     expr: &ast::Expr,\n     expr_type: ExprType,\n     context: &RewriteContext<'_>,\n@@ -386,7 +386,7 @@ pub fn format_expr(\n         })\n }\n \n-pub fn rewrite_array<'a, T: 'a + IntoOverflowableItem<'a>>(\n+pub(crate) fn rewrite_array<'a, T: 'a + IntoOverflowableItem<'a>>(\n     name: &'a str,\n     exprs: impl Iterator<Item = &'a T>,\n     span: Span,\n@@ -492,7 +492,7 @@ fn rewrite_single_line_block(\n     None\n }\n \n-pub fn rewrite_block_with_visitor(\n+pub(crate) fn rewrite_block_with_visitor(\n     context: &RewriteContext<'_>,\n     prefix: &str,\n     block: &ast::Block,\n@@ -581,7 +581,7 @@ impl Rewrite for ast::Stmt {\n }\n \n // Rewrite condition if the given expression has one.\n-pub fn rewrite_cond(\n+pub(crate) fn rewrite_cond(\n     context: &RewriteContext<'_>,\n     expr: &ast::Expr,\n     shape: Shape,\n@@ -1128,7 +1128,7 @@ fn extract_comment(span: Span, context: &RewriteContext<'_>, shape: Shape) -> Op\n     }\n }\n \n-pub fn block_contains_comment(block: &ast::Block, source_map: &SourceMap) -> bool {\n+pub(crate) fn block_contains_comment(block: &ast::Block, source_map: &SourceMap) -> bool {\n     let snippet = source_map.span_to_snippet(block.span).unwrap();\n     contains_comment(&snippet)\n }\n@@ -1137,7 +1137,7 @@ pub fn block_contains_comment(block: &ast::Block, source_map: &SourceMap) -> boo\n // attributes.\n // FIXME: incorrectly returns false when comment is contained completely within\n // the expression.\n-pub fn is_simple_block(\n+pub(crate) fn is_simple_block(\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n     source_map: &SourceMap,\n@@ -1150,7 +1150,7 @@ pub fn is_simple_block(\n \n /// Checks whether a block contains at most one statement or expression, and no\n /// comments or attributes.\n-pub fn is_simple_block_stmt(\n+pub(crate) fn is_simple_block_stmt(\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n     source_map: &SourceMap,\n@@ -1162,7 +1162,7 @@ pub fn is_simple_block_stmt(\n \n /// Checks whether a block contains no statements, expressions, comments, or\n /// inner attributes.\n-pub fn is_empty_block(\n+pub(crate) fn is_empty_block(\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n     source_map: &SourceMap,\n@@ -1172,7 +1172,7 @@ pub fn is_empty_block(\n         && attrs.map_or(true, |a| inner_attributes(a).is_empty())\n }\n \n-pub fn stmt_is_expr(stmt: &ast::Stmt) -> bool {\n+pub(crate) fn stmt_is_expr(stmt: &ast::Stmt) -> bool {\n     match stmt.node {\n         ast::StmtKind::Expr(..) => true,\n         _ => false,\n@@ -1189,15 +1189,15 @@ pub(crate) fn stmt_is_if(stmt: &ast::Stmt) -> bool {\n     }\n }\n \n-pub fn is_unsafe_block(block: &ast::Block) -> bool {\n+pub(crate) fn is_unsafe_block(block: &ast::Block) -> bool {\n     if let ast::BlockCheckMode::Unsafe(..) = block.rules {\n         true\n     } else {\n         false\n     }\n }\n \n-pub fn rewrite_multiple_patterns(\n+pub(crate) fn rewrite_multiple_patterns(\n     context: &RewriteContext<'_>,\n     pats: &[&ast::Pat],\n     shape: Shape,\n@@ -1230,7 +1230,11 @@ pub fn rewrite_multiple_patterns(\n     write_list(&items, &fmt)\n }\n \n-pub fn rewrite_literal(context: &RewriteContext<'_>, l: &ast::Lit, shape: Shape) -> Option<String> {\n+pub(crate) fn rewrite_literal(\n+    context: &RewriteContext<'_>,\n+    l: &ast::Lit,\n+    shape: Shape,\n+) -> Option<String> {\n     match l.node {\n         ast::LitKind::Str(_, ast::StrStyle::Cooked) => rewrite_string_lit(context, l.span, shape),\n         _ => wrap_str(\n@@ -1297,7 +1301,7 @@ fn choose_separator_tactic(context: &RewriteContext<'_>, span: Span) -> Option<S\n     }\n }\n \n-pub fn rewrite_call(\n+pub(crate) fn rewrite_call(\n     context: &RewriteContext<'_>,\n     callee: &str,\n     args: &[ptr::P<ast::Expr>],\n@@ -1315,7 +1319,7 @@ pub fn rewrite_call(\n     )\n }\n \n-pub fn is_simple_expr(expr: &ast::Expr) -> bool {\n+pub(crate) fn is_simple_expr(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Lit(..) => true,\n         ast::ExprKind::Path(ref qself, ref path) => qself.is_none() && path.segments.len() <= 1,\n@@ -1333,11 +1337,11 @@ pub fn is_simple_expr(expr: &ast::Expr) -> bool {\n     }\n }\n \n-pub fn is_every_expr_simple(lists: &[OverflowableItem<'_>]) -> bool {\n+pub(crate) fn is_every_expr_simple(lists: &[OverflowableItem<'_>]) -> bool {\n     lists.iter().all(OverflowableItem::is_simple)\n }\n \n-pub fn can_be_overflowed_expr(\n+pub(crate) fn can_be_overflowed_expr(\n     context: &RewriteContext<'_>,\n     expr: &ast::Expr,\n     args_len: usize,\n@@ -1388,7 +1392,7 @@ pub fn can_be_overflowed_expr(\n     }\n }\n \n-pub fn is_nested_call(expr: &ast::Expr) -> bool {\n+pub(crate) fn is_nested_call(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Call(..) | ast::ExprKind::Mac(..) => true,\n         ast::ExprKind::AddrOf(_, ref expr)\n@@ -1403,7 +1407,7 @@ pub fn is_nested_call(expr: &ast::Expr) -> bool {\n /// Returns `true` if a function call or a method call represented by the given span ends with a\n /// trailing comma. This function is used when rewriting macro, as adding or removing a trailing\n /// comma from macro can potentially break the code.\n-pub fn span_ends_with_comma(context: &RewriteContext<'_>, span: Span) -> bool {\n+pub(crate) fn span_ends_with_comma(context: &RewriteContext<'_>, span: Span) -> bool {\n     let mut result: bool = Default::default();\n     let mut prev_char: char = Default::default();\n     let closing_delimiters = &[')', '}', ']'];\n@@ -1667,7 +1671,7 @@ fn rewrite_struct_lit<'a>(\n     // of space, we should fall back to BlockIndent.\n }\n \n-pub fn wrap_struct_field(\n+pub(crate) fn wrap_struct_field(\n     context: &RewriteContext<'_>,\n     fields_str: &str,\n     shape: Shape,\n@@ -1691,11 +1695,11 @@ pub fn wrap_struct_field(\n     }\n }\n \n-pub fn struct_lit_field_separator(config: &Config) -> &str {\n+pub(crate) fn struct_lit_field_separator(config: &Config) -> &str {\n     colon_spaces(config)\n }\n \n-pub fn rewrite_field(\n+pub(crate) fn rewrite_field(\n     context: &RewriteContext<'_>,\n     field: &ast::Field,\n     shape: Shape,\n@@ -1792,7 +1796,7 @@ fn rewrite_tuple_in_visual_indent_style<'a, T: 'a + IntoOverflowableItem<'a>>(\n     Some(format!(\"({})\", list_str))\n }\n \n-pub fn rewrite_tuple<'a, T: 'a + IntoOverflowableItem<'a>>(\n+pub(crate) fn rewrite_tuple<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &'a RewriteContext<'_>,\n     items: impl Iterator<Item = &'a T>,\n     span: Span,\n@@ -1827,7 +1831,7 @@ pub fn rewrite_tuple<'a, T: 'a + IntoOverflowableItem<'a>>(\n     }\n }\n \n-pub fn rewrite_unary_prefix<R: Rewrite>(\n+pub(crate) fn rewrite_unary_prefix<R: Rewrite>(\n     context: &RewriteContext<'_>,\n     prefix: &str,\n     rewrite: &R,\n@@ -1840,7 +1844,7 @@ pub fn rewrite_unary_prefix<R: Rewrite>(\n \n // FIXME: this is probably not correct for multi-line Rewrites. we should\n // subtract suffix.len() from the last line budget, not the first!\n-pub fn rewrite_unary_suffix<R: Rewrite>(\n+pub(crate) fn rewrite_unary_suffix<R: Rewrite>(\n     context: &RewriteContext<'_>,\n     suffix: &str,\n     rewrite: &R,\n@@ -1885,7 +1889,7 @@ fn rewrite_assignment(\n \n /// Controls where to put the rhs.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum RhsTactics {\n+pub(crate) enum RhsTactics {\n     /// Use heuristics.\n     Default,\n     /// Put the rhs on the next line if it uses multiple line, without extra indentation.\n@@ -1894,7 +1898,7 @@ pub enum RhsTactics {\n \n // The left hand side must contain everything up to, and including, the\n // assignment operator.\n-pub fn rewrite_assign_rhs<S: Into<String>, R: Rewrite>(\n+pub(crate) fn rewrite_assign_rhs<S: Into<String>, R: Rewrite>(\n     context: &RewriteContext<'_>,\n     lhs: S,\n     ex: &R,\n@@ -1903,7 +1907,7 @@ pub fn rewrite_assign_rhs<S: Into<String>, R: Rewrite>(\n     rewrite_assign_rhs_with(context, lhs, ex, shape, RhsTactics::Default)\n }\n \n-pub fn rewrite_assign_rhs_with<S: Into<String>, R: Rewrite>(\n+pub(crate) fn rewrite_assign_rhs_with<S: Into<String>, R: Rewrite>(\n     context: &RewriteContext<'_>,\n     lhs: S,\n     ex: &R,\n@@ -1989,7 +1993,11 @@ fn shape_from_rhs_tactic(\n     }\n }\n \n-pub fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str, rhs_tactics: RhsTactics) -> bool {\n+pub(crate) fn prefer_next_line(\n+    orig_rhs: &str,\n+    next_line_rhs: &str,\n+    rhs_tactics: RhsTactics,\n+) -> bool {\n     rhs_tactics == RhsTactics::ForceNextLineWithoutIndent\n         || !next_line_rhs.contains('\\n')\n         || count_newlines(orig_rhs) > count_newlines(next_line_rhs) + 1\n@@ -2011,7 +2019,7 @@ fn rewrite_expr_addrof(\n     rewrite_unary_prefix(context, operator_str, expr, shape)\n }\n \n-pub fn is_method_call(expr: &ast::Expr) -> bool {\n+pub(crate) fn is_method_call(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::MethodCall(..) => true,\n         ast::ExprKind::AddrOf(_, ref expr)"}, {"sha": "eff7b552fabec40c2455ee830319747bc7112995", "filename": "src/formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -353,7 +353,7 @@ pub(crate) struct ReportedErrors {\n \n impl ReportedErrors {\n     /// Combine two summaries together.\n-    pub fn add(&mut self, other: &ReportedErrors) {\n+    pub(crate) fn add(&mut self, other: &ReportedErrors) {\n         self.has_operational_errors |= other.has_operational_errors;\n         self.has_parsing_errors |= other.has_parsing_errors;\n         self.has_formatting_errors |= other.has_formatting_errors;"}, {"sha": "d8974e12b8f5f4fe07742214ec1f28f2e41ddae2", "filename": "src/ignore_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fignore_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fignore_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fignore_path.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -2,12 +2,12 @@ use ignore::{self, gitignore};\n \n use crate::config::{FileName, IgnoreList};\n \n-pub struct IgnorePathSet {\n+pub(crate) struct IgnorePathSet {\n     ignore_set: gitignore::Gitignore,\n }\n \n impl IgnorePathSet {\n-    pub fn from_ignore_list(ignore_list: &IgnoreList) -> Result<Self, ignore::Error> {\n+    pub(crate) fn from_ignore_list(ignore_list: &IgnoreList) -> Result<Self, ignore::Error> {\n         let mut ignore_builder = gitignore::GitignoreBuilder::new(ignore_list.rustfmt_toml_path());\n \n         for ignore_path in ignore_list {\n@@ -19,7 +19,7 @@ impl IgnorePathSet {\n         })\n     }\n \n-    pub fn is_match(&self, file_name: &FileName) -> bool {\n+    pub(crate) fn is_match(&self, file_name: &FileName) -> bool {\n         match file_name {\n             FileName::Stdin => false,\n             FileName::Real(p) => self"}, {"sha": "1d9eba7b1efc8941aa9c934ac2895eafc8517dff", "filename": "src/imports.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -20,12 +20,12 @@ use crate::visitor::FmtVisitor;\n \n /// Returns a name imported by a `use` declaration.\n /// E.g., returns `Ordering` for `std::cmp::Ordering` and `self` for `std::cmp::self`.\n-pub fn path_to_imported_ident(path: &ast::Path) -> ast::Ident {\n+pub(crate) fn path_to_imported_ident(path: &ast::Path) -> ast::Ident {\n     path.segments.last().unwrap().ident\n }\n \n impl<'a> FmtVisitor<'a> {\n-    pub fn format_import(&mut self, item: &ast::Item, tree: &ast::UseTree) {\n+    pub(crate) fn format_import(&mut self, item: &ast::Item, tree: &ast::UseTree) {\n         let span = item.span();\n         let shape = self.shape();\n         let rw = UseTree::from_ast(\n@@ -84,7 +84,7 @@ impl<'a> FmtVisitor<'a> {\n \n // FIXME we do a lot of allocation to make our own representation.\n #[derive(Clone, Eq, PartialEq)]\n-pub enum UseSegment {\n+pub(crate) enum UseSegment {\n     Ident(String, Option<String>),\n     Slf(Option<String>),\n     Super(Option<String>),\n@@ -94,11 +94,11 @@ pub enum UseSegment {\n }\n \n #[derive(Clone)]\n-pub struct UseTree {\n-    pub path: Vec<UseSegment>,\n-    pub span: Span,\n+pub(crate) struct UseTree {\n+    pub(crate) path: Vec<UseSegment>,\n+    pub(crate) span: Span,\n     // Comment information within nested use tree.\n-    pub list_item: Option<ListItem>,\n+    pub(crate) list_item: Option<ListItem>,\n     // Additional fields for top level use items.\n     // Should we have another struct for top-level use items rather than reusing this?\n     visibility: Option<ast::Visibility>,\n@@ -156,7 +156,7 @@ impl UseSegment {\n     }\n }\n \n-pub fn merge_use_trees(use_trees: Vec<UseTree>) -> Vec<UseTree> {\n+pub(crate) fn merge_use_trees(use_trees: Vec<UseTree>) -> Vec<UseTree> {\n     let mut result = Vec::with_capacity(use_trees.len());\n     for use_tree in use_trees {\n         if use_tree.has_comment() || use_tree.attrs.is_some() {\n@@ -229,7 +229,11 @@ impl fmt::Display for UseTree {\n \n impl UseTree {\n     // Rewrite use tree with `use ` and a trailing `;`.\n-    pub fn rewrite_top_level(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+    pub(crate) fn rewrite_top_level(\n+        &self,\n+        context: &RewriteContext<'_>,\n+        shape: Shape,\n+    ) -> Option<String> {\n         let vis = self.visibility.as_ref().map_or(Cow::from(\"\"), |vis| {\n             crate::utils::format_visibility(context, &vis)\n         });\n@@ -285,7 +289,7 @@ impl UseTree {\n         }\n     }\n \n-    pub fn from_ast_with_normalization(\n+    pub(crate) fn from_ast_with_normalization(\n         context: &RewriteContext<'_>,\n         item: &ast::Item,\n     ) -> Option<UseTree> {\n@@ -416,7 +420,7 @@ impl UseTree {\n     }\n \n     // Do the adjustments that rustfmt does elsewhere to use paths.\n-    pub fn normalize(mut self) -> UseTree {\n+    pub(crate) fn normalize(mut self) -> UseTree {\n         let mut last = self.path.pop().expect(\"Empty use tree?\");\n         // Hack around borrow checker.\n         let mut normalize_sole_list = false;"}, {"sha": "d369b75541ef90fa2756bde652dad1c8073f64ba", "filename": "src/issues.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -65,14 +65,14 @@ enum IssueClassification {\n     None,\n }\n \n-pub struct BadIssueSeeker {\n+pub(crate) struct BadIssueSeeker {\n     state: Seeking,\n     report_todo: ReportTactic,\n     report_fixme: ReportTactic,\n }\n \n impl BadIssueSeeker {\n-    pub fn new(report_todo: ReportTactic, report_fixme: ReportTactic) -> BadIssueSeeker {\n+    pub(crate) fn new(report_todo: ReportTactic, report_fixme: ReportTactic) -> BadIssueSeeker {\n         BadIssueSeeker {\n             state: Seeking::Issue {\n                 todo_idx: 0,\n@@ -83,13 +83,13 @@ impl BadIssueSeeker {\n         }\n     }\n \n-    pub fn is_disabled(&self) -> bool {\n+    pub(crate) fn is_disabled(&self) -> bool {\n         !is_enabled(self.report_todo) && !is_enabled(self.report_fixme)\n     }\n \n     // Check whether or not the current char is conclusive evidence for an\n     // unnumbered TO-DO or FIX-ME.\n-    pub fn inspect(&mut self, c: char) -> Option<Issue> {\n+    pub(crate) fn inspect(&mut self, c: char) -> Option<Issue> {\n         match self.state {\n             Seeking::Issue {\n                 todo_idx,"}, {"sha": "17e67b3f79fba81e0c820e04b76dae812857e8bc", "filename": "src/items.rs", "status": "modified", "additions": 48, "deletions": 41, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -157,7 +157,7 @@ enum BodyElement<'a> {\n }\n \n /// Represents a fn's signature.\n-pub struct FnSig<'a> {\n+pub(crate) struct FnSig<'a> {\n     decl: &'a ast::FnDecl,\n     generics: &'a ast::Generics,\n     abi: abi::Abi,\n@@ -169,7 +169,7 @@ pub struct FnSig<'a> {\n }\n \n impl<'a> FnSig<'a> {\n-    pub fn new(\n+    pub(crate) fn new(\n         decl: &'a ast::FnDecl,\n         generics: &'a ast::Generics,\n         vis: ast::Visibility,\n@@ -186,7 +186,7 @@ impl<'a> FnSig<'a> {\n         }\n     }\n \n-    pub fn from_method_sig(\n+    pub(crate) fn from_method_sig(\n         method_sig: &'a ast::MethodSig,\n         generics: &'a ast::Generics,\n     ) -> FnSig<'a> {\n@@ -202,7 +202,7 @@ impl<'a> FnSig<'a> {\n         }\n     }\n \n-    pub fn from_fn_kind(\n+    pub(crate) fn from_fn_kind(\n         fn_kind: &'a visit::FnKind<'_>,\n         generics: &'a ast::Generics,\n         decl: &'a ast::FnDecl,\n@@ -287,7 +287,7 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n \n-    pub fn format_foreign_mod(&mut self, fm: &ast::ForeignMod, span: Span) {\n+    pub(crate) fn format_foreign_mod(&mut self, fm: &ast::ForeignMod, span: Span) {\n         let item = Item::from_foreign_mod(fm, span, self.config);\n         self.format_item(&item);\n     }\n@@ -298,7 +298,7 @@ impl<'a> FmtVisitor<'a> {\n         self.last_pos = item.span.hi();\n     }\n \n-    pub fn rewrite_fn(\n+    pub(crate) fn rewrite_fn(\n         &mut self,\n         indent: Indent,\n         ident: ast::Ident,\n@@ -341,7 +341,7 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n \n-    pub fn rewrite_required_fn(\n+    pub(crate) fn rewrite_required_fn(\n         &mut self,\n         indent: Indent,\n         ident: ast::Ident,\n@@ -416,19 +416,19 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n \n-    pub fn visit_static(&mut self, static_parts: &StaticParts<'_>) {\n+    pub(crate) fn visit_static(&mut self, static_parts: &StaticParts<'_>) {\n         let rewrite = rewrite_static(&self.get_context(), static_parts, self.block_indent);\n         self.push_rewrite(static_parts.span, rewrite);\n     }\n \n-    pub fn visit_struct(&mut self, struct_parts: &StructParts<'_>) {\n+    pub(crate) fn visit_struct(&mut self, struct_parts: &StructParts<'_>) {\n         let is_tuple = struct_parts.def.is_tuple();\n         let rewrite = format_struct(&self.get_context(), struct_parts, self.block_indent, None)\n             .map(|s| if is_tuple { s + \";\" } else { s });\n         self.push_rewrite(struct_parts.span, rewrite);\n     }\n \n-    pub fn visit_enum(\n+    pub(crate) fn visit_enum(\n         &mut self,\n         ident: ast::Ident,\n         vis: &ast::Visibility,\n@@ -660,7 +660,7 @@ impl<'a> FmtVisitor<'a> {\n     }\n }\n \n-pub fn format_impl(\n+pub(crate) fn format_impl(\n     context: &RewriteContext<'_>,\n     item: &ast::Item,\n     offset: Indent,\n@@ -928,7 +928,7 @@ fn rewrite_trait_ref(\n     ))\n }\n \n-pub struct StructParts<'a> {\n+pub(crate) struct StructParts<'a> {\n     prefix: &'a str,\n     ident: ast::Ident,\n     vis: &'a ast::Visibility,\n@@ -953,7 +953,7 @@ impl<'a> StructParts<'a> {\n         }\n     }\n \n-    pub fn from_item(item: &'a ast::Item) -> Self {\n+    pub(crate) fn from_item(item: &'a ast::Item) -> Self {\n         let (prefix, def, generics) = match item.node {\n             ast::ItemKind::Struct(ref def, ref generics) => (\"struct \", def, generics),\n             ast::ItemKind::Union(ref def, ref generics) => (\"union \", def, generics),\n@@ -987,7 +987,7 @@ fn format_struct(\n     }\n }\n \n-pub fn format_trait(\n+pub(crate) fn format_trait(\n     context: &RewriteContext<'_>,\n     item: &ast::Item,\n     offset: Indent,\n@@ -1149,7 +1149,7 @@ pub fn format_trait(\n     }\n }\n \n-pub fn format_trait_alias(\n+pub(crate) fn format_trait_alias(\n     context: &RewriteContext<'_>,\n     ident: ast::Ident,\n     vis: &ast::Visibility,\n@@ -1191,7 +1191,7 @@ fn format_unit_struct(\n     Some(format!(\"{}{};\", header_str, generics_str))\n }\n \n-pub fn format_struct_struct(\n+pub(crate) fn format_struct_struct(\n     context: &RewriteContext<'_>,\n     struct_parts: &StructParts<'_>,\n     fields: &[ast::StructField],\n@@ -1495,7 +1495,7 @@ fn rewrite_type_item<R: Rewrite>(\n     rewrite_assign_rhs(context, result, rhs, rhs_shape).map(|s| s + \";\")\n }\n \n-pub fn rewrite_type_alias(\n+pub(crate) fn rewrite_type_alias(\n     context: &RewriteContext<'_>,\n     indent: Indent,\n     ident: ast::Ident,\n@@ -1506,7 +1506,7 @@ pub fn rewrite_type_alias(\n     rewrite_type_item(context, indent, \"type\", \" =\", ident, ty, generics, vis)\n }\n \n-pub fn rewrite_existential_type(\n+pub(crate) fn rewrite_existential_type(\n     context: &RewriteContext<'_>,\n     indent: Indent,\n     ident: ast::Ident,\n@@ -1533,7 +1533,7 @@ fn type_annotation_spacing(config: &Config) -> (&str, &str) {\n     )\n }\n \n-pub fn rewrite_struct_field_prefix(\n+pub(crate) fn rewrite_struct_field_prefix(\n     context: &RewriteContext<'_>,\n     field: &ast::StructField,\n ) -> Option<String> {\n@@ -1556,7 +1556,7 @@ impl Rewrite for ast::StructField {\n     }\n }\n \n-pub fn rewrite_struct_field(\n+pub(crate) fn rewrite_struct_field(\n     context: &RewriteContext<'_>,\n     field: &ast::StructField,\n     shape: Shape,\n@@ -1620,7 +1620,7 @@ pub fn rewrite_struct_field(\n     combine_strs_with_missing_comments(context, &attrs_str, field_str, missing_span, shape, false)\n }\n \n-pub struct StaticParts<'a> {\n+pub(crate) struct StaticParts<'a> {\n     prefix: &'a str,\n     vis: &'a ast::Visibility,\n     ident: ast::Ident,\n@@ -1632,7 +1632,7 @@ pub struct StaticParts<'a> {\n }\n \n impl<'a> StaticParts<'a> {\n-    pub fn from_item(item: &'a ast::Item) -> Self {\n+    pub(crate) fn from_item(item: &'a ast::Item) -> Self {\n         let (prefix, ty, mutability, expr) = match item.node {\n             ast::ItemKind::Static(ref ty, mutability, ref expr) => (\"static\", ty, mutability, expr),\n             ast::ItemKind::Const(ref ty, ref expr) => {\n@@ -1652,7 +1652,7 @@ impl<'a> StaticParts<'a> {\n         }\n     }\n \n-    pub fn from_trait_item(ti: &'a ast::TraitItem) -> Self {\n+    pub(crate) fn from_trait_item(ti: &'a ast::TraitItem) -> Self {\n         let (ty, expr_opt) = match ti.node {\n             ast::TraitItemKind::Const(ref ty, ref expr_opt) => (ty, expr_opt),\n             _ => unreachable!(),\n@@ -1669,7 +1669,7 @@ impl<'a> StaticParts<'a> {\n         }\n     }\n \n-    pub fn from_impl_item(ii: &'a ast::ImplItem) -> Self {\n+    pub(crate) fn from_impl_item(ii: &'a ast::ImplItem) -> Self {\n         let (ty, expr) = match ii.node {\n             ast::ImplItemKind::Const(ref ty, ref expr) => (ty, expr),\n             _ => unreachable!(),\n@@ -1739,7 +1739,7 @@ fn rewrite_static(\n     }\n }\n \n-pub fn rewrite_associated_type(\n+pub(crate) fn rewrite_associated_type(\n     ident: ast::Ident,\n     ty_opt: Option<&ptr::P<ast::Ty>>,\n     generics: &ast::Generics,\n@@ -1775,7 +1775,7 @@ pub fn rewrite_associated_type(\n     }\n }\n \n-pub fn rewrite_existential_impl_type(\n+pub(crate) fn rewrite_existential_impl_type(\n     context: &RewriteContext<'_>,\n     ident: ast::Ident,\n     generics: &ast::Generics,\n@@ -1786,7 +1786,7 @@ pub fn rewrite_existential_impl_type(\n         .map(|s| format!(\"existential {}\", s))\n }\n \n-pub fn rewrite_associated_impl_type(\n+pub(crate) fn rewrite_associated_impl_type(\n     ident: ast::Ident,\n     defaultness: ast::Defaultness,\n     ty_opt: Option<&ptr::P<ast::Ty>>,\n@@ -1922,23 +1922,23 @@ fn rewrite_explicit_self(\n     }\n }\n \n-pub fn span_lo_for_arg(arg: &ast::Arg) -> BytePos {\n+pub(crate) fn span_lo_for_arg(arg: &ast::Arg) -> BytePos {\n     if is_named_arg(arg) {\n         arg.pat.span.lo()\n     } else {\n         arg.ty.span.lo()\n     }\n }\n \n-pub fn span_hi_for_arg(context: &RewriteContext<'_>, arg: &ast::Arg) -> BytePos {\n+pub(crate) fn span_hi_for_arg(context: &RewriteContext<'_>, arg: &ast::Arg) -> BytePos {\n     match arg.ty.node {\n         ast::TyKind::Infer if context.snippet(arg.ty.span) == \"_\" => arg.ty.span.hi(),\n         ast::TyKind::Infer if is_named_arg(arg) => arg.pat.span.hi(),\n         _ => arg.ty.span.hi(),\n     }\n }\n \n-pub fn is_named_arg(arg: &ast::Arg) -> bool {\n+pub(crate) fn is_named_arg(arg: &ast::Arg) -> bool {\n     if let ast::PatKind::Ident(_, ident, _) = arg.pat.node {\n         ident != symbol::keywords::Invalid.ident()\n     } else {\n@@ -2245,31 +2245,31 @@ struct WhereClauseOption {\n }\n \n impl WhereClauseOption {\n-    pub fn new(suppress_comma: bool, snuggle: bool) -> WhereClauseOption {\n+    fn new(suppress_comma: bool, snuggle: bool) -> WhereClauseOption {\n         WhereClauseOption {\n             suppress_comma,\n             snuggle,\n             compress_where: false,\n         }\n     }\n \n-    pub fn snuggled(current: &str) -> WhereClauseOption {\n+    fn snuggled(current: &str) -> WhereClauseOption {\n         WhereClauseOption {\n             suppress_comma: false,\n             snuggle: last_line_width(current) == 1,\n             compress_where: false,\n         }\n     }\n \n-    pub fn suppress_comma(&mut self) {\n+    fn suppress_comma(&mut self) {\n         self.suppress_comma = true\n     }\n \n-    pub fn compress_where(&mut self) {\n+    fn compress_where(&mut self) {\n         self.compress_where = true\n     }\n \n-    pub fn snuggle(&mut self) {\n+    fn snuggle(&mut self) {\n         self.snuggle = true\n     }\n }\n@@ -2434,7 +2434,11 @@ fn rewrite_generics(\n     overflow::rewrite_with_angle_brackets(context, ident, params, shape, generics.span)\n }\n \n-pub fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize) -> Option<Shape> {\n+pub(crate) fn generics_shape_from_config(\n+    config: &Config,\n+    shape: Shape,\n+    offset: usize,\n+) -> Option<Shape> {\n     match config.indent_style() {\n         IndentStyle::Visual => shape.visual_indent(1 + offset).sub_width(offset + 2),\n         IndentStyle::Block => {\n@@ -2858,7 +2862,7 @@ impl Rewrite for ast::ForeignItem {\n }\n \n /// Rewrite an inline mod.\n-pub fn rewrite_mod(context: &RewriteContext<'_>, item: &ast::Item) -> String {\n+pub(crate) fn rewrite_mod(context: &RewriteContext<'_>, item: &ast::Item) -> String {\n     let mut result = String::with_capacity(32);\n     result.push_str(&*format_visibility(context, &item.vis));\n     result.push_str(\"mod \");\n@@ -2868,7 +2872,10 @@ pub fn rewrite_mod(context: &RewriteContext<'_>, item: &ast::Item) -> String {\n }\n \n /// Rewrite `extern crate foo;` WITHOUT attributes.\n-pub fn rewrite_extern_crate(context: &RewriteContext<'_>, item: &ast::Item) -> Option<String> {\n+pub(crate) fn rewrite_extern_crate(\n+    context: &RewriteContext<'_>,\n+    item: &ast::Item,\n+) -> Option<String> {\n     assert!(is_extern_crate(item));\n     let new_str = context.snippet(item.span);\n     Some(if contains_comment(new_str) {\n@@ -2880,21 +2887,21 @@ pub fn rewrite_extern_crate(context: &RewriteContext<'_>, item: &ast::Item) -> O\n }\n \n /// Returns `true` for `mod foo;`, false for `mod foo { .. }`.\n-pub fn is_mod_decl(item: &ast::Item) -> bool {\n+pub(crate) fn is_mod_decl(item: &ast::Item) -> bool {\n     match item.node {\n         ast::ItemKind::Mod(ref m) => m.inner.hi() != item.span.hi(),\n         _ => false,\n     }\n }\n \n-pub fn is_use_item(item: &ast::Item) -> bool {\n+pub(crate) fn is_use_item(item: &ast::Item) -> bool {\n     match item.node {\n         ast::ItemKind::Use(_) => true,\n         _ => false,\n     }\n }\n \n-pub fn is_extern_crate(item: &ast::Item) -> bool {\n+pub(crate) fn is_extern_crate(item: &ast::Item) -> bool {\n     match item.node {\n         ast::ItemKind::ExternCrate(..) => true,\n         _ => false,"}, {"sha": "efd88357088bafb6ca0404e468b17a89a456f1a0", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -1,4 +1,5 @@\n #![deny(rust_2018_idioms)]\n+#![warn(unreachable_pub)]\n \n #[macro_use]\n extern crate derive_new;"}, {"sha": "f57a78f9874e7e3a83ef2de088dcf702e981aad5", "filename": "src/lists.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -13,7 +13,7 @@ use crate::shape::{Indent, Shape};\n use crate::utils::{count_newlines, first_line_width, last_line_width, mk_sp, starts_with_newline};\n use crate::visitor::SnippetProvider;\n \n-pub struct ListFormatting<'a> {\n+pub(crate) struct ListFormatting<'a> {\n     tactic: DefinitiveListTactic,\n     separator: &'a str,\n     trailing_separator: SeparatorTactic,\n@@ -32,7 +32,7 @@ pub struct ListFormatting<'a> {\n }\n \n impl<'a> ListFormatting<'a> {\n-    pub fn new(shape: Shape, config: &'a Config) -> Self {\n+    pub(crate) fn new(shape: Shape, config: &'a Config) -> Self {\n         ListFormatting {\n             tactic: DefinitiveListTactic::Vertical,\n             separator: \",\",\n@@ -47,47 +47,47 @@ impl<'a> ListFormatting<'a> {\n         }\n     }\n \n-    pub fn tactic(mut self, tactic: DefinitiveListTactic) -> Self {\n+    pub(crate) fn tactic(mut self, tactic: DefinitiveListTactic) -> Self {\n         self.tactic = tactic;\n         self\n     }\n \n-    pub fn separator(mut self, separator: &'a str) -> Self {\n+    pub(crate) fn separator(mut self, separator: &'a str) -> Self {\n         self.separator = separator;\n         self\n     }\n \n-    pub fn trailing_separator(mut self, trailing_separator: SeparatorTactic) -> Self {\n+    pub(crate) fn trailing_separator(mut self, trailing_separator: SeparatorTactic) -> Self {\n         self.trailing_separator = trailing_separator;\n         self\n     }\n \n-    pub fn separator_place(mut self, separator_place: SeparatorPlace) -> Self {\n+    pub(crate) fn separator_place(mut self, separator_place: SeparatorPlace) -> Self {\n         self.separator_place = separator_place;\n         self\n     }\n \n-    pub fn ends_with_newline(mut self, ends_with_newline: bool) -> Self {\n+    pub(crate) fn ends_with_newline(mut self, ends_with_newline: bool) -> Self {\n         self.ends_with_newline = ends_with_newline;\n         self\n     }\n \n-    pub fn preserve_newline(mut self, preserve_newline: bool) -> Self {\n+    pub(crate) fn preserve_newline(mut self, preserve_newline: bool) -> Self {\n         self.preserve_newline = preserve_newline;\n         self\n     }\n \n-    pub fn nested(mut self, nested: bool) -> Self {\n+    pub(crate) fn nested(mut self, nested: bool) -> Self {\n         self.nested = nested;\n         self\n     }\n \n-    pub fn align_comments(mut self, align_comments: bool) -> Self {\n+    pub(crate) fn align_comments(mut self, align_comments: bool) -> Self {\n         self.align_comments = align_comments;\n         self\n     }\n \n-    pub fn needs_trailing_separator(&self) -> bool {\n+    pub(crate) fn needs_trailing_separator(&self) -> bool {\n         match self.trailing_separator {\n             // We always put separator in front.\n             SeparatorTactic::Always => true,\n@@ -106,7 +106,7 @@ impl AsRef<ListItem> for ListItem {\n }\n \n #[derive(PartialEq, Eq, Debug, Copy, Clone)]\n-pub enum ListItemCommentStyle {\n+pub(crate) enum ListItemCommentStyle {\n     // Try to keep the comment on the same line with the item.\n     SameLine,\n     // Put the comment on the previous or the next line of the item.\n@@ -116,20 +116,20 @@ pub enum ListItemCommentStyle {\n }\n \n #[derive(Debug, Clone)]\n-pub struct ListItem {\n+pub(crate) struct ListItem {\n     // None for comments mean that they are not present.\n-    pub pre_comment: Option<String>,\n-    pub pre_comment_style: ListItemCommentStyle,\n+    pub(crate) pre_comment: Option<String>,\n+    pub(crate) pre_comment_style: ListItemCommentStyle,\n     // Item should include attributes and doc comments. None indicates a failed\n     // rewrite.\n-    pub item: Option<String>,\n-    pub post_comment: Option<String>,\n+    pub(crate) item: Option<String>,\n+    pub(crate) post_comment: Option<String>,\n     // Whether there is extra whitespace before this item.\n-    pub new_lines: bool,\n+    pub(crate) new_lines: bool,\n }\n \n impl ListItem {\n-    pub fn empty() -> ListItem {\n+    pub(crate) fn empty() -> ListItem {\n         ListItem {\n             pre_comment: None,\n             pre_comment_style: ListItemCommentStyle::None,\n@@ -139,11 +139,11 @@ impl ListItem {\n         }\n     }\n \n-    pub fn inner_as_ref(&self) -> &str {\n+    pub(crate) fn inner_as_ref(&self) -> &str {\n         self.item.as_ref().map_or(\"\", |s| s)\n     }\n \n-    pub fn is_different_group(&self) -> bool {\n+    pub(crate) fn is_different_group(&self) -> bool {\n         self.inner_as_ref().contains('\\n')\n             || self.pre_comment.is_some()\n             || self\n@@ -152,7 +152,7 @@ impl ListItem {\n                 .map_or(false, |s| s.contains('\\n'))\n     }\n \n-    pub fn is_multiline(&self) -> bool {\n+    pub(crate) fn is_multiline(&self) -> bool {\n         self.inner_as_ref().contains('\\n')\n             || self\n                 .pre_comment\n@@ -164,7 +164,7 @@ impl ListItem {\n                 .map_or(false, |s| s.contains('\\n'))\n     }\n \n-    pub fn has_single_line_comment(&self) -> bool {\n+    pub(crate) fn has_single_line_comment(&self) -> bool {\n         self.pre_comment\n             .as_ref()\n             .map_or(false, |comment| comment.trim_start().starts_with(\"//\"))\n@@ -174,11 +174,11 @@ impl ListItem {\n                 .map_or(false, |comment| comment.trim_start().starts_with(\"//\"))\n     }\n \n-    pub fn has_comment(&self) -> bool {\n+    pub(crate) fn has_comment(&self) -> bool {\n         self.pre_comment.is_some() || self.post_comment.is_some()\n     }\n \n-    pub fn from_str<S: Into<String>>(s: S) -> ListItem {\n+    pub(crate) fn from_str<S: Into<String>>(s: S) -> ListItem {\n         ListItem {\n             pre_comment: None,\n             pre_comment_style: ListItemCommentStyle::None,\n@@ -203,13 +203,13 @@ impl ListItem {\n \n /// The type of separator for lists.\n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum Separator {\n+pub(crate) enum Separator {\n     Comma,\n     VerticalBar,\n }\n \n impl Separator {\n-    pub fn len(self) -> usize {\n+    pub(crate) fn len(self) -> usize {\n         match self {\n             // 2 = `, `\n             Separator::Comma => 2,\n@@ -219,7 +219,7 @@ impl Separator {\n     }\n }\n \n-pub fn definitive_tactic<I, T>(\n+pub(crate) fn definitive_tactic<I, T>(\n     items: I,\n     tactic: ListTactic,\n     sep: Separator,\n@@ -260,7 +260,7 @@ where\n }\n \n // Format a list of commented items into a string.\n-pub fn write_list<I, T>(items: I, formatting: &ListFormatting<'_>) -> Option<String>\n+pub(crate) fn write_list<I, T>(items: I, formatting: &ListFormatting<'_>) -> Option<String>\n where\n     I: IntoIterator<Item = T> + Clone,\n     T: AsRef<ListItem>,\n@@ -556,7 +556,7 @@ fn post_comment_alignment(item_max_width: Option<usize>, inner_item_len: usize)\n     item_max_width.unwrap_or(0).saturating_sub(inner_item_len)\n }\n \n-pub struct ListItems<'a, I, F1, F2, F3>\n+pub(crate) struct ListItems<'a, I, F1, F2, F3>\n where\n     I: Iterator,\n {\n@@ -572,7 +572,7 @@ where\n     leave_last: bool,\n }\n \n-pub fn extract_pre_comment(pre_snippet: &str) -> (Option<String>, ListItemCommentStyle) {\n+pub(crate) fn extract_pre_comment(pre_snippet: &str) -> (Option<String>, ListItemCommentStyle) {\n     let trimmed_pre_snippet = pre_snippet.trim();\n     let has_block_comment = trimmed_pre_snippet.ends_with(\"*/\");\n     let has_single_line_comment = trimmed_pre_snippet.starts_with(\"//\");\n@@ -599,7 +599,7 @@ pub fn extract_pre_comment(pre_snippet: &str) -> (Option<String>, ListItemCommen\n     }\n }\n \n-pub fn extract_post_comment(\n+pub(crate) fn extract_post_comment(\n     post_snippet: &str,\n     comment_end: usize,\n     separator: &str,\n@@ -629,7 +629,7 @@ pub fn extract_post_comment(\n     }\n }\n \n-pub fn get_comment_end(\n+pub(crate) fn get_comment_end(\n     post_snippet: &str,\n     separator: &str,\n     terminator: &str,\n@@ -682,7 +682,7 @@ pub fn get_comment_end(\n \n // Account for extra whitespace between items. This is fiddly\n // because of the way we divide pre- and post- comments.\n-pub fn has_extra_newline(post_snippet: &str, comment_end: usize) -> bool {\n+pub(crate) fn has_extra_newline(post_snippet: &str, comment_end: usize) -> bool {\n     if post_snippet.is_empty() || comment_end == 0 {\n         return false;\n     }\n@@ -764,7 +764,7 @@ where\n \n #[allow(clippy::too_many_arguments)]\n // Creates an iterator over a list's items with associated comments.\n-pub fn itemize_list<'a, T, I, F1, F2, F3>(\n+pub(crate) fn itemize_list<'a, T, I, F1, F2, F3>(\n     snippet_provider: &'a SnippetProvider<'_>,\n     inner: I,\n     terminator: &'a str,\n@@ -808,7 +808,7 @@ where\n         .fold((0, 0), |acc, l| (acc.0 + 1, acc.1 + l))\n }\n \n-pub fn total_item_width(item: &ListItem) -> usize {\n+pub(crate) fn total_item_width(item: &ListItem) -> usize {\n     comment_len(item.pre_comment.as_ref().map(|x| &(*x)[..]))\n         + comment_len(item.post_comment.as_ref().map(|x| &(*x)[..]))\n         + item.item.as_ref().map_or(0, String::len)\n@@ -830,7 +830,7 @@ fn comment_len(comment: Option<&str>) -> usize {\n }\n \n // Compute horizontal and vertical shapes for a struct-lit-like thing.\n-pub fn struct_lit_shape(\n+pub(crate) fn struct_lit_shape(\n     shape: Shape,\n     context: &RewriteContext<'_>,\n     prefix_width: usize,\n@@ -859,7 +859,7 @@ pub fn struct_lit_shape(\n }\n \n // Compute the tactic for the internals of a struct-lit-like thing.\n-pub fn struct_lit_tactic(\n+pub(crate) fn struct_lit_tactic(\n     h_shape: Option<Shape>,\n     context: &RewriteContext<'_>,\n     items: &[ListItem],\n@@ -878,7 +878,7 @@ pub fn struct_lit_tactic(\n \n // Given a tactic and possible shapes for horizontal and vertical layout,\n // come up with the actual shape to use.\n-pub fn shape_for_tactic(\n+pub(crate) fn shape_for_tactic(\n     tactic: DefinitiveListTactic,\n     h_shape: Option<Shape>,\n     v_shape: Shape,\n@@ -891,7 +891,7 @@ pub fn shape_for_tactic(\n \n // Create a ListFormatting object for formatting the internals of a\n // struct-lit-like thing, that is a series of fields.\n-pub fn struct_lit_formatting<'a>(\n+pub(crate) fn struct_lit_formatting<'a>(\n     shape: Shape,\n     tactic: DefinitiveListTactic,\n     context: &'a RewriteContext<'_>,"}, {"sha": "478b55b4920c77291a1a0d554e302d4efb127c52", "filename": "src/macros.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -41,15 +41,15 @@ use crate::visitor::FmtVisitor;\n const FORCED_BRACKET_MACROS: &[&str] = &[\"vec!\"];\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum MacroPosition {\n+pub(crate) enum MacroPosition {\n     Item,\n     Statement,\n     Expression,\n     Pat,\n }\n \n #[derive(Debug)]\n-pub enum MacroArg {\n+pub(crate) enum MacroArg {\n     Expr(ptr::P<ast::Expr>),\n     Ty(ptr::P<ast::Ty>),\n     Pat(ptr::P<ast::Pat>),\n@@ -201,7 +201,7 @@ impl<'a> Drop for InsideMacroGuard<'a> {\n     }\n }\n \n-pub fn rewrite_macro(\n+pub(crate) fn rewrite_macro(\n     mac: &ast::Mac,\n     extra_ident: Option<ast::Ident>,\n     context: &RewriteContext<'_>,\n@@ -242,7 +242,7 @@ fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n     None\n }\n \n-pub fn rewrite_macro_inner(\n+fn rewrite_macro_inner(\n     mac: &ast::Mac,\n     extra_ident: Option<ast::Ident>,\n     context: &RewriteContext<'_>,\n@@ -453,7 +453,7 @@ pub fn rewrite_macro_inner(\n     }\n }\n \n-pub fn rewrite_macro_def(\n+pub(crate) fn rewrite_macro_def(\n     context: &RewriteContext<'_>,\n     shape: Shape,\n     indent: Indent,\n@@ -736,7 +736,7 @@ struct ParsedMacroArg {\n }\n \n impl ParsedMacroArg {\n-    pub fn rewrite(\n+    fn rewrite(\n         &self,\n         context: &RewriteContext<'_>,\n         shape: Shape,\n@@ -772,7 +772,7 @@ fn last_tok(tt: &TokenTree) -> Token {\n }\n \n impl MacroArgParser {\n-    pub fn new() -> MacroArgParser {\n+    fn new() -> MacroArgParser {\n         MacroArgParser {\n             lo: BytePos(0),\n             hi: BytePos(0),\n@@ -932,7 +932,7 @@ impl MacroArgParser {\n     }\n \n     /// Returns a collection of parsed macro def's arguments.\n-    pub fn parse(mut self, tokens: TokenStream) -> Option<Vec<ParsedMacroArg>> {\n+    fn parse(mut self, tokens: TokenStream) -> Option<Vec<ParsedMacroArg>> {\n         let mut iter = tokens.trees();\n \n         while let Some(tok) = iter.next() {\n@@ -1136,7 +1136,7 @@ fn next_space(tok: &Token) -> SpaceState {\n /// Tries to convert a macro use into a short hand try expression. Returns `None`\n /// when the macro is not an instance of `try!` (or parsing the inner expression\n /// failed).\n-pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext<'_>) -> Option<ast::Expr> {\n+pub(crate) fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext<'_>) -> Option<ast::Expr> {\n     if &mac.node.path.to_string() == \"try\" {\n         let ts: TokenStream = mac.node.tts.clone();\n         let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());"}, {"sha": "2e2c547761685029f08709a0b080a658992fedf4", "filename": "src/matches.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -24,20 +24,16 @@ use crate::utils::{\n \n /// A simple wrapper type against `ast::Arm`. Used inside `write_list()`.\n struct ArmWrapper<'a> {\n-    pub arm: &'a ast::Arm,\n+    arm: &'a ast::Arm,\n     /// `true` if the arm is the last one in match expression. Used to decide on whether we should\n     /// add trailing comma to the match arm when `config.trailing_comma() == Never`.\n-    pub is_last: bool,\n+    is_last: bool,\n     /// Holds a byte position of `|` at the beginning of the arm pattern, if available.\n-    pub beginning_vert: Option<BytePos>,\n+    beginning_vert: Option<BytePos>,\n }\n \n impl<'a> ArmWrapper<'a> {\n-    pub fn new(\n-        arm: &'a ast::Arm,\n-        is_last: bool,\n-        beginning_vert: Option<BytePos>,\n-    ) -> ArmWrapper<'a> {\n+    fn new(arm: &'a ast::Arm, is_last: bool, beginning_vert: Option<BytePos>) -> ArmWrapper<'a> {\n         ArmWrapper {\n             arm,\n             is_last,\n@@ -62,7 +58,7 @@ impl<'a> Rewrite for ArmWrapper<'a> {\n     }\n }\n \n-pub fn rewrite_match(\n+pub(crate) fn rewrite_match(\n     context: &RewriteContext<'_>,\n     cond: &ast::Expr,\n     arms: &[ast::Arm],"}, {"sha": "84246e3ed5159b949c55b478bf543e7772e24b1b", "filename": "src/missed_spans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -34,7 +34,7 @@ impl<'a> FmtVisitor<'a> {\n         self.buffer.is_empty()\n     }\n \n-    pub fn format_missing(&mut self, end: BytePos) {\n+    pub(crate) fn format_missing(&mut self, end: BytePos) {\n         // HACK(topecongiro): we use `format_missing()` to extract a missing comment between\n         // a macro (or similar) and a trailing semicolon. Here we just try to avoid calling\n         // `format_missing_inner` in the common case where there is no such comment.\n@@ -50,7 +50,7 @@ impl<'a> FmtVisitor<'a> {\n         self.format_missing_inner(end, |this, last_snippet, _| this.push_str(last_snippet))\n     }\n \n-    pub fn format_missing_with_indent(&mut self, end: BytePos) {\n+    pub(crate) fn format_missing_with_indent(&mut self, end: BytePos) {\n         let config = self.config;\n         self.format_missing_inner(end, |this, last_snippet, snippet| {\n             this.push_str(last_snippet.trim_end());\n@@ -63,7 +63,7 @@ impl<'a> FmtVisitor<'a> {\n         })\n     }\n \n-    pub fn format_missing_no_indent(&mut self, end: BytePos) {\n+    pub(crate) fn format_missing_no_indent(&mut self, end: BytePos) {\n         self.format_missing_inner(end, |this, last_snippet, _| {\n             this.push_str(last_snippet.trim_end());\n         })"}, {"sha": "3d009b2098bf5f1961a4359cf7601d47b0ccfe8e", "filename": "src/modules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -13,7 +13,7 @@ use crate::utils::contains_skip;\n type FileModMap<'a> = BTreeMap<FileName, (&'a ast::Mod, &'a str)>;\n \n /// Maps each module to the corresponding file.\n-pub struct ModResolver<'a, 'b> {\n+pub(crate) struct ModResolver<'a, 'b> {\n     source_map: &'b source_map::SourceMap,\n     directory: Directory,\n     file_map: FileModMap<'a>,\n@@ -28,7 +28,7 @@ struct Directory {\n \n impl<'a, 'b> ModResolver<'a, 'b> {\n     /// Creates a new `ModResolver`.\n-    pub fn new(\n+    pub(crate) fn new(\n         source_map: &'b source_map::SourceMap,\n         directory_ownership: DirectoryOwnership,\n         is_input_stdin: bool,\n@@ -45,7 +45,7 @@ impl<'a, 'b> ModResolver<'a, 'b> {\n     }\n \n     /// Creates a map that maps a file name to the module in AST.\n-    pub fn visit_crate(mut self, krate: &'a ast::Crate) -> Result<FileModMap<'a>, String> {\n+    pub(crate) fn visit_crate(mut self, krate: &'a ast::Crate) -> Result<FileModMap<'a>, String> {\n         let root_filename = self.source_map.span_to_filename(krate.span);\n         self.directory.path = match root_filename {\n             source_map::FileName::Real(ref path) => path"}, {"sha": "3fe2a2fd25b47926c4e0c308e4852df78bfea94d", "filename": "src/overflow.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -68,7 +68,7 @@ const SPECIAL_ATTR_WHITELIST: &[(&str, usize)] = &[\n ];\n \n #[derive(Debug)]\n-pub enum OverflowableItem<'a> {\n+pub(crate) enum OverflowableItem<'a> {\n     Expr(&'a ast::Expr),\n     GenericParam(&'a ast::GenericParam),\n     MacroArg(&'a MacroArg),\n@@ -103,7 +103,7 @@ impl<'a> OverflowableItem<'a> {\n         }\n     }\n \n-    pub fn map<F, T>(&self, f: F) -> T\n+    pub(crate) fn map<F, T>(&self, f: F) -> T\n     where\n         F: Fn(&dyn IntoOverflowableItem<'a>) -> T,\n     {\n@@ -119,7 +119,7 @@ impl<'a> OverflowableItem<'a> {\n         }\n     }\n \n-    pub fn is_simple(&self) -> bool {\n+    pub(crate) fn is_simple(&self) -> bool {\n         match self {\n             OverflowableItem::Expr(expr) => is_simple_expr(expr),\n             OverflowableItem::MacroArg(MacroArg::Expr(expr)) => is_simple_expr(expr),\n@@ -134,23 +134,23 @@ impl<'a> OverflowableItem<'a> {\n         }\n     }\n \n-    pub fn is_expr(&self) -> bool {\n+    pub(crate) fn is_expr(&self) -> bool {\n         match self {\n             OverflowableItem::Expr(..) => true,\n             OverflowableItem::MacroArg(MacroArg::Expr(..)) => true,\n             _ => false,\n         }\n     }\n \n-    pub fn is_nested_call(&self) -> bool {\n+    pub(crate) fn is_nested_call(&self) -> bool {\n         match self {\n             OverflowableItem::Expr(expr) => is_nested_call(expr),\n             OverflowableItem::MacroArg(MacroArg::Expr(expr)) => is_nested_call(expr),\n             _ => false,\n         }\n     }\n \n-    pub fn to_expr(&self) -> Option<&'a ast::Expr> {\n+    pub(crate) fn to_expr(&self) -> Option<&'a ast::Expr> {\n         match self {\n             OverflowableItem::Expr(expr) => Some(expr),\n             OverflowableItem::MacroArg(macro_arg) => match macro_arg {\n@@ -161,7 +161,7 @@ impl<'a> OverflowableItem<'a> {\n         }\n     }\n \n-    pub fn can_be_overflowed(&self, context: &RewriteContext<'_>, len: usize) -> bool {\n+    pub(crate) fn can_be_overflowed(&self, context: &RewriteContext<'_>, len: usize) -> bool {\n         match self {\n             OverflowableItem::Expr(expr) => can_be_overflowed_expr(context, expr, len),\n             OverflowableItem::MacroArg(macro_arg) => match macro_arg {\n@@ -196,7 +196,7 @@ impl<'a> OverflowableItem<'a> {\n     }\n }\n \n-pub trait IntoOverflowableItem<'a>: Rewrite + Spanned {\n+pub(crate) trait IntoOverflowableItem<'a>: Rewrite + Spanned {\n     fn into_overflowable_item(&'a self) -> OverflowableItem<'a>;\n }\n \n@@ -240,7 +240,7 @@ macro_rules! impl_into_overflowable_item_for_rustfmt_types {\n impl_into_overflowable_item_for_ast_node!(Expr, GenericParam, NestedMetaItem, StructField, Ty);\n impl_into_overflowable_item_for_rustfmt_types!([MacroArg], [SegmentParam, TuplePatField]);\n \n-pub fn into_overflowable_list<'a, T>(\n+pub(crate) fn into_overflowable_list<'a, T>(\n     iter: impl Iterator<Item = &'a T>,\n ) -> impl Iterator<Item = OverflowableItem<'a>>\n where\n@@ -249,7 +249,7 @@ where\n     iter.map(|x| IntoOverflowableItem::into_overflowable_item(x))\n }\n \n-pub fn rewrite_with_parens<'a, T: 'a + IntoOverflowableItem<'a>>(\n+pub(crate) fn rewrite_with_parens<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &'a RewriteContext<'_>,\n     ident: &'a str,\n     items: impl Iterator<Item = &'a T>,\n@@ -273,7 +273,7 @@ pub fn rewrite_with_parens<'a, T: 'a + IntoOverflowableItem<'a>>(\n     .rewrite(shape)\n }\n \n-pub fn rewrite_with_angle_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n+pub(crate) fn rewrite_with_angle_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &'a RewriteContext<'_>,\n     ident: &'a str,\n     items: impl Iterator<Item = &'a T>,\n@@ -295,7 +295,7 @@ pub fn rewrite_with_angle_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n     .rewrite(shape)\n }\n \n-pub fn rewrite_with_square_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n+pub(crate) fn rewrite_with_square_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &'a RewriteContext<'_>,\n     name: &'a str,\n     items: impl Iterator<Item = &'a T>,\n@@ -340,7 +340,7 @@ struct Context<'a> {\n }\n \n impl<'a> Context<'a> {\n-    pub fn new<T: 'a + IntoOverflowableItem<'a>>(\n+    fn new<T: 'a + IntoOverflowableItem<'a>>(\n         context: &'a RewriteContext<'_>,\n         items: impl Iterator<Item = &'a T>,\n         ident: &'a str,\n@@ -766,7 +766,7 @@ fn no_long_items(list: &[ListItem]) -> bool {\n }\n \n /// In case special-case style is required, returns an offset from which we start horizontal layout.\n-pub fn maybe_get_args_offset(\n+pub(crate) fn maybe_get_args_offset(\n     callee_str: &str,\n     args: &[OverflowableItem<'_>],\n ) -> Option<(bool, usize)> {"}, {"sha": "73ff2c0f7ab096f13e3580737953285382893bd0", "filename": "src/patterns.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -30,7 +30,7 @@ use crate::utils::{format_mutability, mk_sp, rewrite_ident};\n ///     - `[small, ntp]`\n ///     - unary tuple constructor `([small, ntp])`\n ///     - `&[small]`\n-pub fn is_short_pattern(pat: &ast::Pat, pat_str: &str) -> bool {\n+pub(crate) fn is_short_pattern(pat: &ast::Pat, pat_str: &str) -> bool {\n     // We also require that the pattern is reasonably 'small' with its literal width.\n     pat_str.len() <= 20 && !pat_str.contains('\\n') && is_short_pattern_inner(pat)\n }\n@@ -256,7 +256,7 @@ impl Rewrite for FieldPat {\n }\n \n #[derive(Debug)]\n-pub enum TuplePatField<'a> {\n+pub(crate) enum TuplePatField<'a> {\n     Pat(&'a ptr::P<ast::Pat>),\n     Dotdot(Span),\n }\n@@ -279,7 +279,7 @@ impl<'a> Spanned for TuplePatField<'a> {\n     }\n }\n \n-pub fn can_be_overflowed_pat(\n+pub(crate) fn can_be_overflowed_pat(\n     context: &RewriteContext<'_>,\n     pat: &TuplePatField<'_>,\n     len: usize,"}, {"sha": "2423fffcbea08c9a7c880e5824d3ea516929dfff", "filename": "src/reorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -272,7 +272,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n     /// Visits and format the given items. Items are reordered If they are\n     /// consecutive and reorderable.\n-    pub fn visit_items_with_reordering(&mut self, mut items: &[&ast::Item]) {\n+    pub(crate) fn visit_items_with_reordering(&mut self, mut items: &[&ast::Item]) {\n         while !items.is_empty() {\n             // If the next item is a `use`, `extern crate` or `mod`, then extract it and any\n             // subsequent items that have the same item kind to be reordered within"}, {"sha": "9a955dbd91b830788ab0be34113e8dbc6436e35f", "filename": "src/rewrite.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -11,7 +11,7 @@ use crate::shape::Shape;\n use crate::visitor::SnippetProvider;\n use crate::FormatReport;\n \n-pub trait Rewrite {\n+pub(crate) trait Rewrite {\n     /// Rewrite self into shape.\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String>;\n }\n@@ -23,44 +23,44 @@ impl<T: Rewrite> Rewrite for ptr::P<T> {\n }\n \n #[derive(Clone)]\n-pub struct RewriteContext<'a> {\n-    pub parse_session: &'a ParseSess,\n-    pub source_map: &'a SourceMap,\n-    pub config: &'a Config,\n-    pub inside_macro: RefCell<bool>,\n+pub(crate) struct RewriteContext<'a> {\n+    pub(crate) parse_session: &'a ParseSess,\n+    pub(crate) source_map: &'a SourceMap,\n+    pub(crate) config: &'a Config,\n+    pub(crate) inside_macro: RefCell<bool>,\n     // Force block indent style even if we are using visual indent style.\n-    pub use_block: RefCell<bool>,\n+    pub(crate) use_block: RefCell<bool>,\n     // When `is_if_else_block` is true, unindent the comment on top\n     // of the `else` or `else if`.\n-    pub is_if_else_block: RefCell<bool>,\n+    pub(crate) is_if_else_block: RefCell<bool>,\n     // When rewriting chain, veto going multi line except the last element\n-    pub force_one_line_chain: RefCell<bool>,\n-    pub snippet_provider: &'a SnippetProvider<'a>,\n+    pub(crate) force_one_line_chain: RefCell<bool>,\n+    pub(crate) snippet_provider: &'a SnippetProvider<'a>,\n     // Used for `format_snippet`\n     pub(crate) macro_rewrite_failure: RefCell<bool>,\n     pub(crate) report: FormatReport,\n-    pub skip_macro_names: RefCell<Vec<String>>,\n+    pub(crate) skip_macro_names: RefCell<Vec<String>>,\n }\n \n impl<'a> RewriteContext<'a> {\n-    pub fn snippet(&self, span: Span) -> &str {\n+    pub(crate) fn snippet(&self, span: Span) -> &str {\n         self.snippet_provider.span_to_snippet(span).unwrap()\n     }\n \n     /// Returns `true` if we should use block indent style for rewriting function call.\n-    pub fn use_block_indent(&self) -> bool {\n+    pub(crate) fn use_block_indent(&self) -> bool {\n         self.config.indent_style() == IndentStyle::Block || *self.use_block.borrow()\n     }\n \n-    pub fn budget(&self, used_width: usize) -> usize {\n+    pub(crate) fn budget(&self, used_width: usize) -> usize {\n         self.config.max_width().saturating_sub(used_width)\n     }\n \n-    pub fn inside_macro(&self) -> bool {\n+    pub(crate) fn inside_macro(&self) -> bool {\n         *self.inside_macro.borrow()\n     }\n \n-    pub fn is_if_else_block(&self) -> bool {\n+    pub(crate) fn is_if_else_block(&self) -> bool {\n         *self.is_if_else_block.borrow()\n     }\n }"}, {"sha": "fd332b12403625769d9f1147cbc8db326b48344c", "filename": "src/rustfmt_diff.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustfmt_diff.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -146,14 +146,14 @@ impl std::str::FromStr for ModifiedLines {\n \n // This struct handles writing output to stdout and abstracts away the logic\n // of printing in color, if it's possible in the executing environment.\n-pub struct OutputWriter {\n+pub(crate) struct OutputWriter {\n     terminal: Option<Box<dyn term::Terminal<Output = io::Stdout>>>,\n }\n \n impl OutputWriter {\n     // Create a new OutputWriter instance based on the caller's preference\n     // for colorized output and the capabilities of the terminal.\n-    pub fn new(color: Color) -> Self {\n+    pub(crate) fn new(color: Color) -> Self {\n         if let Some(t) = term::stdout() {\n             if color.use_colored_tty() && t.supports_color() {\n                 return OutputWriter { terminal: Some(t) };\n@@ -165,7 +165,7 @@ impl OutputWriter {\n     // Write output in the optionally specified color. The output is written\n     // in the specified color if this OutputWriter instance contains a\n     // Terminal in its `terminal` field.\n-    pub fn writeln(&mut self, msg: &str, color: Option<term::color::Color>) {\n+    pub(crate) fn writeln(&mut self, msg: &str, color: Option<term::color::Color>) {\n         match &mut self.terminal {\n             Some(ref mut t) => {\n                 if let Some(color) = color {\n@@ -182,7 +182,7 @@ impl OutputWriter {\n }\n \n // Produces a diff between the expected output and actual output of rustfmt.\n-pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Mismatch> {\n+pub(crate) fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Mismatch> {\n     let mut line_number = 1;\n     let mut line_number_orig = 1;\n     let mut context_queue: VecDeque<&str> = VecDeque::with_capacity(context_size);\n@@ -250,7 +250,7 @@ pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Misma\n     results\n }\n \n-pub fn print_diff<F>(diff: Vec<Mismatch>, get_section_title: F, config: &Config)\n+pub(crate) fn print_diff<F>(diff: Vec<Mismatch>, get_section_title: F, config: &Config)\n where\n     F: Fn(u32) -> String,\n {"}, {"sha": "d8971e05ef93e076304049f3360c63563c3a3b5f", "filename": "src/shape.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshape.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -5,12 +5,12 @@ use std::ops::{Add, Sub};\n use crate::Config;\n \n #[derive(Copy, Clone, Debug)]\n-pub struct Indent {\n+pub(crate) struct Indent {\n     // Width of the block indent, in characters. Must be a multiple of\n     // Config::tab_spaces.\n-    pub block_indent: usize,\n+    pub(crate) block_indent: usize,\n     // Alignment in characters.\n-    pub alignment: usize,\n+    pub(crate) alignment: usize,\n }\n \n // INDENT_BUFFER.len() = 81\n@@ -19,14 +19,14 @@ const INDENT_BUFFER: &str =\n     \"\\n                                                                                \";\n \n impl Indent {\n-    pub fn new(block_indent: usize, alignment: usize) -> Indent {\n+    pub(crate) fn new(block_indent: usize, alignment: usize) -> Indent {\n         Indent {\n             block_indent,\n             alignment,\n         }\n     }\n \n-    pub fn from_width(config: &Config, width: usize) -> Indent {\n+    pub(crate) fn from_width(config: &Config, width: usize) -> Indent {\n         if config.hard_tabs() {\n             let tab_num = width / config.tab_spaces();\n             let alignment = width % config.tab_spaces();\n@@ -36,23 +36,23 @@ impl Indent {\n         }\n     }\n \n-    pub fn empty() -> Indent {\n+    pub(crate) fn empty() -> Indent {\n         Indent::new(0, 0)\n     }\n \n-    pub fn block_only(&self) -> Indent {\n+    pub(crate) fn block_only(&self) -> Indent {\n         Indent {\n             block_indent: self.block_indent,\n             alignment: 0,\n         }\n     }\n \n-    pub fn block_indent(mut self, config: &Config) -> Indent {\n+    pub(crate) fn block_indent(mut self, config: &Config) -> Indent {\n         self.block_indent += config.tab_spaces();\n         self\n     }\n \n-    pub fn block_unindent(mut self, config: &Config) -> Indent {\n+    pub(crate) fn block_unindent(mut self, config: &Config) -> Indent {\n         if self.block_indent < config.tab_spaces() {\n             Indent::new(self.block_indent, 0)\n         } else {\n@@ -61,15 +61,15 @@ impl Indent {\n         }\n     }\n \n-    pub fn width(&self) -> usize {\n+    pub(crate) fn width(&self) -> usize {\n         self.block_indent + self.alignment\n     }\n \n-    pub fn to_string(&self, config: &Config) -> Cow<'static, str> {\n+    pub(crate) fn to_string(&self, config: &Config) -> Cow<'static, str> {\n         self.to_string_inner(config, 1)\n     }\n \n-    pub fn to_string_with_newline(&self, config: &Config) -> Cow<'static, str> {\n+    pub(crate) fn to_string_with_newline(&self, config: &Config) -> Cow<'static, str> {\n         self.to_string_inner(config, 0)\n     }\n \n@@ -137,13 +137,13 @@ impl Sub<usize> for Indent {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub struct Shape {\n-    pub width: usize,\n+pub(crate) struct Shape {\n+    pub(crate) width: usize,\n     // The current indentation of code.\n-    pub indent: Indent,\n+    pub(crate) indent: Indent,\n     // Indentation + any already emitted text on the first line of the current\n     // statement.\n-    pub offset: usize,\n+    pub(crate) offset: usize,\n }\n \n impl Shape {\n@@ -162,30 +162,30 @@ impl Shape {\n     // |<------------>|  max width\n     // |<---->|          indent\n     //        |<--->|    width\n-    pub fn legacy(width: usize, indent: Indent) -> Shape {\n+    pub(crate) fn legacy(width: usize, indent: Indent) -> Shape {\n         Shape {\n             width,\n             indent,\n             offset: indent.alignment,\n         }\n     }\n \n-    pub fn indented(indent: Indent, config: &Config) -> Shape {\n+    pub(crate) fn indented(indent: Indent, config: &Config) -> Shape {\n         Shape {\n             width: config.max_width().saturating_sub(indent.width()),\n             indent,\n             offset: indent.alignment,\n         }\n     }\n \n-    pub fn with_max_width(&self, config: &Config) -> Shape {\n+    pub(crate) fn with_max_width(&self, config: &Config) -> Shape {\n         Shape {\n             width: config.max_width().saturating_sub(self.indent.width()),\n             ..*self\n         }\n     }\n \n-    pub fn visual_indent(&self, extra_width: usize) -> Shape {\n+    pub(crate) fn visual_indent(&self, extra_width: usize) -> Shape {\n         let alignment = self.offset + extra_width;\n         Shape {\n             width: self.width,\n@@ -194,7 +194,7 @@ impl Shape {\n         }\n     }\n \n-    pub fn block_indent(&self, extra_width: usize) -> Shape {\n+    pub(crate) fn block_indent(&self, extra_width: usize) -> Shape {\n         if self.indent.alignment == 0 {\n             Shape {\n                 width: self.width,\n@@ -210,66 +210,66 @@ impl Shape {\n         }\n     }\n \n-    pub fn block_left(&self, width: usize) -> Option<Shape> {\n+    pub(crate) fn block_left(&self, width: usize) -> Option<Shape> {\n         self.block_indent(width).sub_width(width)\n     }\n \n-    pub fn add_offset(&self, extra_width: usize) -> Shape {\n+    pub(crate) fn add_offset(&self, extra_width: usize) -> Shape {\n         Shape {\n             offset: self.offset + extra_width,\n             ..*self\n         }\n     }\n \n-    pub fn block(&self) -> Shape {\n+    pub(crate) fn block(&self) -> Shape {\n         Shape {\n             indent: self.indent.block_only(),\n             ..*self\n         }\n     }\n \n-    pub fn saturating_sub_width(&self, width: usize) -> Shape {\n+    pub(crate) fn saturating_sub_width(&self, width: usize) -> Shape {\n         self.sub_width(width).unwrap_or(Shape { width: 0, ..*self })\n     }\n \n-    pub fn sub_width(&self, width: usize) -> Option<Shape> {\n+    pub(crate) fn sub_width(&self, width: usize) -> Option<Shape> {\n         Some(Shape {\n             width: self.width.checked_sub(width)?,\n             ..*self\n         })\n     }\n \n-    pub fn shrink_left(&self, width: usize) -> Option<Shape> {\n+    pub(crate) fn shrink_left(&self, width: usize) -> Option<Shape> {\n         Some(Shape {\n             width: self.width.checked_sub(width)?,\n             indent: self.indent + width,\n             offset: self.offset + width,\n         })\n     }\n \n-    pub fn offset_left(&self, width: usize) -> Option<Shape> {\n+    pub(crate) fn offset_left(&self, width: usize) -> Option<Shape> {\n         self.add_offset(width).sub_width(width)\n     }\n \n-    pub fn used_width(&self) -> usize {\n+    pub(crate) fn used_width(&self) -> usize {\n         self.indent.block_indent + self.offset\n     }\n \n-    pub fn rhs_overhead(&self, config: &Config) -> usize {\n+    pub(crate) fn rhs_overhead(&self, config: &Config) -> usize {\n         config\n             .max_width()\n             .saturating_sub(self.used_width() + self.width)\n     }\n \n-    pub fn comment(&self, config: &Config) -> Shape {\n+    pub(crate) fn comment(&self, config: &Config) -> Shape {\n         let width = min(\n             self.width,\n             config.comment_width().saturating_sub(self.indent.width()),\n         );\n         Shape { width, ..*self }\n     }\n \n-    pub fn to_string_with_newline(&self, config: &Config) -> Cow<'static, str> {\n+    pub(crate) fn to_string_with_newline(&self, config: &Config) -> Cow<'static, str> {\n         let mut offset_indent = self.indent;\n         offset_indent.alignment = self.offset;\n         offset_indent.to_string_inner(config, 0)"}, {"sha": "a7e0074cd2f0e02ecc3d29b5ba58c232aa0ae8e7", "filename": "src/source_file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fsource_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fsource_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsource_file.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -12,7 +12,7 @@ use crate::rustfmt_diff::{make_diff, print_diff, ModifiedLines};\n use crate::formatting::FileRecord;\n \n // Append a newline to the end of each file.\n-pub fn append_newline(s: &mut String) {\n+pub(crate) fn append_newline(s: &mut String) {\n     s.push_str(\"\\n\");\n }\n \n@@ -38,7 +38,7 @@ where\n     Ok(())\n }\n \n-pub fn write_file<T>(\n+pub(crate) fn write_file<T>(\n     source_map: Option<&SourceMap>,\n     filename: &FileName,\n     formatted_text: &str,"}, {"sha": "757d5f57db3dc0ed87e79e0aeed12ac3d98159ec", "filename": "src/source_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsource_map.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -7,7 +7,7 @@ use crate::comment::FindUncommented;\n use crate::config::file_lines::LineRange;\n use crate::visitor::SnippetProvider;\n \n-pub trait SpanUtils {\n+pub(crate) trait SpanUtils {\n     fn span_after(&self, original: Span, needle: &str) -> BytePos;\n     fn span_after_last(&self, original: Span, needle: &str) -> BytePos;\n     fn span_before(&self, original: Span, needle: &str) -> BytePos;\n@@ -16,7 +16,7 @@ pub trait SpanUtils {\n     fn opt_span_before(&self, original: Span, needle: &str) -> Option<BytePos>;\n }\n \n-pub trait LineRangeUtils {\n+pub(crate) trait LineRangeUtils {\n     /// Returns the `LineRange` that corresponds to `span` in `self`.\n     ///\n     /// # Panics"}, {"sha": "6e687a262c6ac4f3341466fae5dc3a07d3bcd431", "filename": "src/spanned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fspanned.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -9,7 +9,7 @@ use crate::macros::MacroArg;\n use crate::utils::{mk_sp, outer_attributes};\n \n /// Spanned returns a span including attributes, if available.\n-pub trait Spanned {\n+pub(crate) trait Spanned {\n     fn span(&self) -> Span;\n }\n "}, {"sha": "4898c9e425cc41303ef344b6b48cb9b394113462", "filename": "src/string.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -11,24 +11,24 @@ use crate::utils::{unicode_str_width, wrap_str};\n const MIN_STRING: usize = 10;\n \n /// Describes the layout of a piece of text.\n-pub struct StringFormat<'a> {\n+pub(crate) struct StringFormat<'a> {\n     /// The opening sequence of characters for the piece of text\n-    pub opener: &'a str,\n+    pub(crate) opener: &'a str,\n     /// The closing sequence of characters for the piece of text\n-    pub closer: &'a str,\n+    pub(crate) closer: &'a str,\n     /// The opening sequence of characters for a line\n-    pub line_start: &'a str,\n+    pub(crate) line_start: &'a str,\n     /// The closing sequence of characters for a line\n-    pub line_end: &'a str,\n+    pub(crate) line_end: &'a str,\n     /// The allocated box to fit the text into\n-    pub shape: Shape,\n+    pub(crate) shape: Shape,\n     /// Trim trailing whitespaces\n-    pub trim_end: bool,\n-    pub config: &'a Config,\n+    pub(crate) trim_end: bool,\n+    pub(crate) config: &'a Config,\n }\n \n impl<'a> StringFormat<'a> {\n-    pub fn new(shape: Shape, config: &'a Config) -> StringFormat<'a> {\n+    pub(crate) fn new(shape: Shape, config: &'a Config) -> StringFormat<'a> {\n         StringFormat {\n             opener: \"\\\"\",\n             closer: \"\\\"\",\n@@ -61,7 +61,7 @@ impl<'a> StringFormat<'a> {\n     }\n }\n \n-pub fn rewrite_string<'a>(\n+pub(crate) fn rewrite_string<'a>(\n     orig: &str,\n     fmt: &StringFormat<'a>,\n     newline_max_chars: usize,"}, {"sha": "eb90a67d0dc1bee51942d63f1b6c825d4db3c0c6", "filename": "src/types.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -24,14 +24,14 @@ use crate::utils::{\n };\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub enum PathContext {\n+pub(crate) enum PathContext {\n     Expr,\n     Type,\n     Import,\n }\n \n // Does not wrap on simple segments.\n-pub fn rewrite_path(\n+pub(crate) fn rewrite_path(\n     context: &RewriteContext<'_>,\n     path_context: PathContext,\n     qself: Option<&ast::QSelf>,\n@@ -133,7 +133,7 @@ where\n }\n \n #[derive(Debug)]\n-pub enum SegmentParam<'a> {\n+pub(crate) enum SegmentParam<'a> {\n     Const(&'a ast::AnonConst),\n     LifeTime(&'a ast::Lifetime),\n     Type(&'a ast::Ty),\n@@ -827,7 +827,11 @@ fn join_bounds(\n     Some(result)\n }\n \n-pub fn can_be_overflowed_type(context: &RewriteContext<'_>, ty: &ast::Ty, len: usize) -> bool {\n+pub(crate) fn can_be_overflowed_type(\n+    context: &RewriteContext<'_>,\n+    ty: &ast::Ty,\n+    len: usize,\n+) -> bool {\n     match ty.node {\n         ast::TyKind::Tup(..) => context.use_block_indent() && len == 1,\n         ast::TyKind::Rptr(_, ref mutty) | ast::TyKind::Ptr(ref mutty) => {"}, {"sha": "9a0a29dc5c347413bb0a6960d7d4ccd2dc57e8b7", "filename": "src/utils.rs", "status": "modified", "additions": 53, "deletions": 43, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -17,23 +17,23 @@ use crate::config::{Config, Version};\n use crate::rewrite::RewriteContext;\n use crate::shape::{Indent, Shape};\n \n-pub const DEPR_SKIP_ANNOTATION: &str = \"rustfmt_skip\";\n-pub const SKIP_ANNOTATION: &str = \"rustfmt::skip\";\n+pub(crate) const DEPR_SKIP_ANNOTATION: &str = \"rustfmt_skip\";\n+pub(crate) const SKIP_ANNOTATION: &str = \"rustfmt::skip\";\n \n-pub fn rewrite_ident<'a>(context: &'a RewriteContext<'_>, ident: ast::Ident) -> &'a str {\n+pub(crate) fn rewrite_ident<'a>(context: &'a RewriteContext<'_>, ident: ast::Ident) -> &'a str {\n     context.snippet(ident.span)\n }\n \n // Computes the length of a string's last line, minus offset.\n-pub fn extra_offset(text: &str, shape: Shape) -> usize {\n+pub(crate) fn extra_offset(text: &str, shape: Shape) -> usize {\n     match text.rfind('\\n') {\n         // 1 for newline character\n         Some(idx) => text.len().saturating_sub(idx + 1 + shape.used_width()),\n         None => text.len(),\n     }\n }\n \n-pub fn is_same_visibility(a: &Visibility, b: &Visibility) -> bool {\n+pub(crate) fn is_same_visibility(a: &Visibility, b: &Visibility) -> bool {\n     match (&a.node, &b.node) {\n         (\n             VisibilityKind::Restricted { path: p, .. },\n@@ -54,7 +54,10 @@ pub fn is_same_visibility(a: &Visibility, b: &Visibility) -> bool {\n }\n \n // Uses Cow to avoid allocating in the common cases.\n-pub fn format_visibility(context: &RewriteContext<'_>, vis: &Visibility) -> Cow<'static, str> {\n+pub(crate) fn format_visibility(\n+    context: &RewriteContext<'_>,\n+    vis: &Visibility,\n+) -> Cow<'static, str> {\n     match vis.node {\n         VisibilityKind::Public => Cow::from(\"pub \"),\n         VisibilityKind::Inherited => Cow::from(\"\"),\n@@ -78,55 +81,55 @@ pub fn format_visibility(context: &RewriteContext<'_>, vis: &Visibility) -> Cow<\n }\n \n #[inline]\n-pub fn format_async(is_async: ast::IsAsync) -> &'static str {\n+pub(crate) fn format_async(is_async: ast::IsAsync) -> &'static str {\n     match is_async {\n         ast::IsAsync::Async { .. } => \"async \",\n         ast::IsAsync::NotAsync => \"\",\n     }\n }\n \n #[inline]\n-pub fn format_constness(constness: ast::Constness) -> &'static str {\n+pub(crate) fn format_constness(constness: ast::Constness) -> &'static str {\n     match constness {\n         ast::Constness::Const => \"const \",\n         ast::Constness::NotConst => \"\",\n     }\n }\n \n #[inline]\n-pub fn format_defaultness(defaultness: ast::Defaultness) -> &'static str {\n+pub(crate) fn format_defaultness(defaultness: ast::Defaultness) -> &'static str {\n     match defaultness {\n         ast::Defaultness::Default => \"default \",\n         ast::Defaultness::Final => \"\",\n     }\n }\n \n #[inline]\n-pub fn format_unsafety(unsafety: ast::Unsafety) -> &'static str {\n+pub(crate) fn format_unsafety(unsafety: ast::Unsafety) -> &'static str {\n     match unsafety {\n         ast::Unsafety::Unsafe => \"unsafe \",\n         ast::Unsafety::Normal => \"\",\n     }\n }\n \n #[inline]\n-pub fn format_auto(is_auto: ast::IsAuto) -> &'static str {\n+pub(crate) fn format_auto(is_auto: ast::IsAuto) -> &'static str {\n     match is_auto {\n         ast::IsAuto::Yes => \"auto \",\n         ast::IsAuto::No => \"\",\n     }\n }\n \n #[inline]\n-pub fn format_mutability(mutability: ast::Mutability) -> &'static str {\n+pub(crate) fn format_mutability(mutability: ast::Mutability) -> &'static str {\n     match mutability {\n         ast::Mutability::Mutable => \"mut \",\n         ast::Mutability::Immutable => \"\",\n     }\n }\n \n #[inline]\n-pub fn format_abi(abi: abi::Abi, explicit_abi: bool, is_mod: bool) -> Cow<'static, str> {\n+pub(crate) fn format_abi(abi: abi::Abi, explicit_abi: bool, is_mod: bool) -> Cow<'static, str> {\n     if abi == abi::Abi::Rust && !is_mod {\n         Cow::from(\"\")\n     } else if abi == abi::Abi::C && !explicit_abi {\n@@ -138,12 +141,15 @@ pub fn format_abi(abi: abi::Abi, explicit_abi: bool, is_mod: bool) -> Cow<'stati\n \n #[inline]\n // Transform `Vec<syntax::ptr::P<T>>` into `Vec<&T>`\n-pub fn ptr_vec_to_ref_vec<T>(vec: &[ptr::P<T>]) -> Vec<&T> {\n+pub(crate) fn ptr_vec_to_ref_vec<T>(vec: &[ptr::P<T>]) -> Vec<&T> {\n     vec.iter().map(|x| &**x).collect::<Vec<_>>()\n }\n \n #[inline]\n-pub fn filter_attributes(attrs: &[ast::Attribute], style: ast::AttrStyle) -> Vec<ast::Attribute> {\n+pub(crate) fn filter_attributes(\n+    attrs: &[ast::Attribute],\n+    style: ast::AttrStyle,\n+) -> Vec<ast::Attribute> {\n     attrs\n         .iter()\n         .filter(|a| a.style == style)\n@@ -152,50 +158,50 @@ pub fn filter_attributes(attrs: &[ast::Attribute], style: ast::AttrStyle) -> Vec\n }\n \n #[inline]\n-pub fn inner_attributes(attrs: &[ast::Attribute]) -> Vec<ast::Attribute> {\n+pub(crate) fn inner_attributes(attrs: &[ast::Attribute]) -> Vec<ast::Attribute> {\n     filter_attributes(attrs, ast::AttrStyle::Inner)\n }\n \n #[inline]\n-pub fn outer_attributes(attrs: &[ast::Attribute]) -> Vec<ast::Attribute> {\n+pub(crate) fn outer_attributes(attrs: &[ast::Attribute]) -> Vec<ast::Attribute> {\n     filter_attributes(attrs, ast::AttrStyle::Outer)\n }\n \n #[inline]\n-pub fn is_single_line(s: &str) -> bool {\n+pub(crate) fn is_single_line(s: &str) -> bool {\n     s.chars().find(|&c| c == '\\n').is_none()\n }\n \n #[inline]\n-pub fn first_line_contains_single_line_comment(s: &str) -> bool {\n+pub(crate) fn first_line_contains_single_line_comment(s: &str) -> bool {\n     s.lines().next().map_or(false, |l| l.contains(\"//\"))\n }\n \n #[inline]\n-pub fn last_line_contains_single_line_comment(s: &str) -> bool {\n+pub(crate) fn last_line_contains_single_line_comment(s: &str) -> bool {\n     s.lines().last().map_or(false, |l| l.contains(\"//\"))\n }\n \n #[inline]\n-pub fn is_attributes_extendable(attrs_str: &str) -> bool {\n+pub(crate) fn is_attributes_extendable(attrs_str: &str) -> bool {\n     !attrs_str.contains('\\n') && !last_line_contains_single_line_comment(attrs_str)\n }\n \n // The width of the first line in s.\n #[inline]\n-pub fn first_line_width(s: &str) -> usize {\n+pub(crate) fn first_line_width(s: &str) -> usize {\n     unicode_str_width(s.splitn(2, '\\n').next().unwrap_or(\"\"))\n }\n \n // The width of the last line in s.\n #[inline]\n-pub fn last_line_width(s: &str) -> usize {\n+pub(crate) fn last_line_width(s: &str) -> usize {\n     unicode_str_width(s.rsplitn(2, '\\n').next().unwrap_or(\"\"))\n }\n \n // The total used width of the last line.\n #[inline]\n-pub fn last_line_used_width(s: &str, offset: usize) -> usize {\n+pub(crate) fn last_line_used_width(s: &str, offset: usize) -> usize {\n     if s.contains('\\n') {\n         last_line_width(s)\n     } else {\n@@ -204,15 +210,15 @@ pub fn last_line_used_width(s: &str, offset: usize) -> usize {\n }\n \n #[inline]\n-pub fn trimmed_last_line_width(s: &str) -> usize {\n+pub(crate) fn trimmed_last_line_width(s: &str) -> usize {\n     unicode_str_width(match s.rfind('\\n') {\n         Some(n) => s[(n + 1)..].trim(),\n         None => s.trim(),\n     })\n }\n \n #[inline]\n-pub fn last_line_extendable(s: &str) -> bool {\n+pub(crate) fn last_line_extendable(s: &str) -> bool {\n     if s.ends_with(\"\\\"#\") {\n         return true;\n     }\n@@ -250,14 +256,14 @@ fn is_skip_nested(meta_item: &NestedMetaItem) -> bool {\n }\n \n #[inline]\n-pub fn contains_skip(attrs: &[Attribute]) -> bool {\n+pub(crate) fn contains_skip(attrs: &[Attribute]) -> bool {\n     attrs\n         .iter()\n         .any(|a| a.meta().map_or(false, |a| is_skip(&a)))\n }\n \n #[inline]\n-pub fn semicolon_for_expr(context: &RewriteContext<'_>, expr: &ast::Expr) -> bool {\n+pub(crate) fn semicolon_for_expr(context: &RewriteContext<'_>, expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Ret(..) | ast::ExprKind::Continue(..) | ast::ExprKind::Break(..) => {\n             context.config.trailing_semicolon()\n@@ -267,7 +273,7 @@ pub fn semicolon_for_expr(context: &RewriteContext<'_>, expr: &ast::Expr) -> boo\n }\n \n #[inline]\n-pub fn semicolon_for_stmt(context: &RewriteContext<'_>, stmt: &ast::Stmt) -> bool {\n+pub(crate) fn semicolon_for_stmt(context: &RewriteContext<'_>, stmt: &ast::Stmt) -> bool {\n     match stmt.node {\n         ast::StmtKind::Semi(ref expr) => match expr.node {\n             ast::ExprKind::While(..)\n@@ -285,15 +291,15 @@ pub fn semicolon_for_stmt(context: &RewriteContext<'_>, stmt: &ast::Stmt) -> boo\n }\n \n #[inline]\n-pub fn stmt_expr(stmt: &ast::Stmt) -> Option<&ast::Expr> {\n+pub(crate) fn stmt_expr(stmt: &ast::Stmt) -> Option<&ast::Expr> {\n     match stmt.node {\n         ast::StmtKind::Expr(ref expr) => Some(expr),\n         _ => None,\n     }\n }\n \n #[inline]\n-pub fn count_newlines(input: &str) -> usize {\n+pub(crate) fn count_newlines(input: &str) -> usize {\n     // Using bytes to omit UTF-8 decoding\n     bytecount::count(input.as_bytes(), b'\\n')\n }\n@@ -306,7 +312,7 @@ macro_rules! source {\n     };\n }\n \n-pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n+pub(crate) fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n     Span::new(lo, hi, NO_EXPANSION)\n }\n \n@@ -340,7 +346,7 @@ macro_rules! skip_out_of_file_lines_range_visitor {\n \n // Wraps String in an Option. Returns Some when the string adheres to the\n // Rewrite constraints defined for the Rewrite trait and None otherwise.\n-pub fn wrap_str(s: String, max_width: usize, shape: Shape) -> Option<String> {\n+pub(crate) fn wrap_str(s: String, max_width: usize, shape: Shape) -> Option<String> {\n     if is_valid_str(&filter_normal_code(&s), max_width, shape) {\n         Some(s)\n     } else {\n@@ -376,7 +382,7 @@ fn is_valid_str(snippet: &str, max_width: usize, shape: Shape) -> bool {\n }\n \n #[inline]\n-pub fn colon_spaces(config: &Config) -> &'static str {\n+pub(crate) fn colon_spaces(config: &Config) -> &'static str {\n     let before = config.space_before_colon();\n     let after = config.space_after_colon();\n     match (before, after) {\n@@ -388,7 +394,7 @@ pub fn colon_spaces(config: &Config) -> &'static str {\n }\n \n #[inline]\n-pub fn left_most_sub_expr(e: &ast::Expr) -> &ast::Expr {\n+pub(crate) fn left_most_sub_expr(e: &ast::Expr) -> &ast::Expr {\n     match e.node {\n         ast::ExprKind::Call(ref e, _)\n         | ast::ExprKind::Binary(_, ref e, _)\n@@ -405,18 +411,18 @@ pub fn left_most_sub_expr(e: &ast::Expr) -> &ast::Expr {\n }\n \n #[inline]\n-pub fn starts_with_newline(s: &str) -> bool {\n+pub(crate) fn starts_with_newline(s: &str) -> bool {\n     s.starts_with('\\n') || s.starts_with(\"\\r\\n\")\n }\n \n #[inline]\n-pub fn first_line_ends_with(s: &str, c: char) -> bool {\n+pub(crate) fn first_line_ends_with(s: &str, c: char) -> bool {\n     s.lines().next().map_or(false, |l| l.ends_with(c))\n }\n \n // States whether an expression's last line exclusively consists of closing\n // parens, braces, and brackets in its idiomatic formatting.\n-pub fn is_block_expr(context: &RewriteContext<'_>, expr: &ast::Expr, repr: &str) -> bool {\n+pub(crate) fn is_block_expr(context: &RewriteContext<'_>, expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n         ast::ExprKind::Mac(..)\n         | ast::ExprKind::Call(..)\n@@ -448,7 +454,7 @@ pub fn is_block_expr(context: &RewriteContext<'_>, expr: &ast::Expr, repr: &str)\n \n /// Removes trailing spaces from the specified snippet. We do not remove spaces\n /// inside strings or comments.\n-pub fn remove_trailing_white_spaces(text: &str) -> String {\n+pub(crate) fn remove_trailing_white_spaces(text: &str) -> String {\n     let mut buffer = String::with_capacity(text.len());\n     let mut space_buffer = String::with_capacity(128);\n     for (char_kind, c) in CharClasses::new(text.chars()) {\n@@ -503,7 +509,11 @@ pub fn remove_trailing_white_spaces(text: &str) -> String {\n ///     ),\n /// }\n /// ```\n-pub fn trim_left_preserve_layout(orig: &str, indent: Indent, config: &Config) -> Option<String> {\n+pub(crate) fn trim_left_preserve_layout(\n+    orig: &str,\n+    indent: Indent,\n+    config: &Config,\n+) -> Option<String> {\n     let mut lines = LineClasses::new(orig);\n     let first_line = lines.next().map(|(_, s)| s.trim_end().to_owned())?;\n     let mut trimmed_lines = Vec::with_capacity(16);\n@@ -570,12 +580,12 @@ pub fn trim_left_preserve_layout(orig: &str, indent: Indent, config: &Config) ->\n \n /// Based on the given line, determine if the next line can be indented or not.\n /// This allows to preserve the indentation of multi-line literals.\n-pub fn indent_next_line(kind: FullCodeCharKind, line: &str, config: &Config) -> bool {\n+pub(crate) fn indent_next_line(kind: FullCodeCharKind, line: &str, config: &Config) -> bool {\n     !(kind.is_string() || (config.version() == Version::Two && kind.is_commented_string()))\n         || line.ends_with('\\\\')\n }\n \n-pub fn is_empty_line(s: &str) -> bool {\n+pub(crate) fn is_empty_line(s: &str) -> bool {\n     s.is_empty() || s.chars().all(char::is_whitespace)\n }\n \n@@ -605,7 +615,7 @@ pub(crate) fn unicode_str_width(s: &str) -> usize {\n     s.width()\n }\n \n-pub fn get_skip_macro_names(attrs: &[ast::Attribute]) -> Vec<String> {\n+pub(crate) fn get_skip_macro_names(attrs: &[ast::Attribute]) -> Vec<String> {\n     let mut skip_macro_names = vec![];\n     for attr in attrs {\n         // syntax::ast::Path is implemented partialEq"}, {"sha": "62cc7d8b33dd846e351b1151092bd2a686cf1056", "filename": "src/vertical.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -19,7 +19,7 @@ use crate::source_map::SpanUtils;\n use crate::spanned::Spanned;\n use crate::utils::{contains_skip, is_attributes_extendable, mk_sp, rewrite_ident};\n \n-pub trait AlignedItem {\n+pub(crate) trait AlignedItem {\n     fn skip(&self) -> bool;\n     fn get_span(&self) -> Span;\n     fn rewrite_prefix(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String>;\n@@ -107,7 +107,7 @@ impl AlignedItem for ast::Field {\n     }\n }\n \n-pub fn rewrite_with_alignment<T: AlignedItem>(\n+pub(crate) fn rewrite_with_alignment<T: AlignedItem>(\n     fields: &[T],\n     context: &RewriteContext<'_>,\n     shape: Shape,"}, {"sha": "f317e015423922c927f7470802e7e22a477cbb44", "filename": "src/visitor.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "patch": "@@ -27,21 +27,21 @@ use crate::utils::{\n use crate::{ErrorKind, FormatReport, FormattingError};\n \n /// Creates a string slice corresponding to the specified span.\n-pub struct SnippetProvider<'a> {\n+pub(crate) struct SnippetProvider<'a> {\n     /// A pointer to the content of the file we are formatting.\n     big_snippet: &'a str,\n     /// A position of the start of `big_snippet`, used as an offset.\n     start_pos: usize,\n }\n \n impl<'a> SnippetProvider<'a> {\n-    pub fn span_to_snippet(&self, span: Span) -> Option<&str> {\n+    pub(crate) fn span_to_snippet(&self, span: Span) -> Option<&str> {\n         let start_index = span.lo().to_usize().checked_sub(self.start_pos)?;\n         let end_index = span.hi().to_usize().checked_sub(self.start_pos)?;\n         Some(&self.big_snippet[start_index..end_index])\n     }\n \n-    pub fn new(start_pos: BytePos, big_snippet: &'a str) -> Self {\n+    pub(crate) fn new(start_pos: BytePos, big_snippet: &'a str) -> Self {\n         let start_pos = start_pos.to_usize();\n         SnippetProvider {\n             big_snippet,\n@@ -50,24 +50,24 @@ impl<'a> SnippetProvider<'a> {\n     }\n }\n \n-pub struct FmtVisitor<'a> {\n+pub(crate) struct FmtVisitor<'a> {\n     parent_context: Option<&'a RewriteContext<'a>>,\n-    pub parse_session: &'a ParseSess,\n-    pub source_map: &'a SourceMap,\n-    pub buffer: String,\n-    pub last_pos: BytePos,\n+    pub(crate) parse_session: &'a ParseSess,\n+    pub(crate) source_map: &'a SourceMap,\n+    pub(crate) buffer: String,\n+    pub(crate) last_pos: BytePos,\n     // FIXME: use an RAII util or closure for indenting\n-    pub block_indent: Indent,\n-    pub config: &'a Config,\n-    pub is_if_else_block: bool,\n-    pub snippet_provider: &'a SnippetProvider<'a>,\n-    pub line_number: usize,\n+    pub(crate) block_indent: Indent,\n+    pub(crate) config: &'a Config,\n+    pub(crate) is_if_else_block: bool,\n+    pub(crate) snippet_provider: &'a SnippetProvider<'a>,\n+    pub(crate) line_number: usize,\n     /// List of 1-based line ranges which were annotated with skip\n     /// Both bounds are inclusifs.\n-    pub skipped_range: Vec<(usize, usize)>,\n-    pub macro_rewrite_failure: bool,\n+    pub(crate) skipped_range: Vec<(usize, usize)>,\n+    pub(crate) macro_rewrite_failure: bool,\n     pub(crate) report: FormatReport,\n-    pub skip_macro_names: RefCell<Vec<String>>,\n+    pub(crate) skip_macro_names: RefCell<Vec<String>>,\n }\n \n impl<'a> Drop for FmtVisitor<'a> {\n@@ -85,7 +85,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         self.parent_context = Some(context);\n     }\n \n-    pub fn shape(&self) -> Shape {\n+    pub(crate) fn shape(&self) -> Shape {\n         Shape::indented(self.block_indent, self.config)\n     }\n \n@@ -124,7 +124,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n \n-    pub fn visit_block(\n+    pub(crate) fn visit_block(\n         &mut self,\n         b: &ast::Block,\n         inner_attrs: Option<&[ast::Attribute]>,\n@@ -300,7 +300,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         self.visit_block(block, inner_attrs, true)\n     }\n \n-    pub fn visit_item(&mut self, item: &ast::Item) {\n+    pub(crate) fn visit_item(&mut self, item: &ast::Item) {\n         skip_out_of_file_lines_range_visitor!(self, item.span);\n \n         // This is where we bail out if there is a skip attribute. This is only\n@@ -466,7 +466,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         self.skip_macro_names = temp_skip_macro_names;\n     }\n \n-    pub fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+    pub(crate) fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n         skip_out_of_file_lines_range_visitor!(self, ti.span);\n \n         if self.visit_attrs(&ti.attrs, ast::AttrStyle::Outer) {\n@@ -510,7 +510,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n \n-    pub fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+    pub(crate) fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n         skip_out_of_file_lines_range_visitor!(self, ii.span);\n \n         if self.visit_attrs(&ii.attrs, ast::AttrStyle::Outer) {\n@@ -567,7 +567,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         self.push_rewrite(mac.span, rewrite);\n     }\n \n-    pub fn push_str(&mut self, s: &str) {\n+    pub(crate) fn push_str(&mut self, s: &str) {\n         self.line_number += count_newlines(s);\n         self.buffer.push_str(s);\n     }\n@@ -583,12 +583,12 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         self.last_pos = source!(self, span).hi();\n     }\n \n-    pub fn push_rewrite(&mut self, span: Span, rewrite: Option<String>) {\n+    pub(crate) fn push_rewrite(&mut self, span: Span, rewrite: Option<String>) {\n         self.format_missing_with_indent(source!(self, span).lo());\n         self.push_rewrite_inner(span, rewrite);\n     }\n \n-    pub fn push_skipped_with_span(\n+    pub(crate) fn push_skipped_with_span(\n         &mut self,\n         attrs: &[ast::Attribute],\n         item_span: Span,\n@@ -611,7 +611,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         self.skipped_range.push((lo, hi));\n     }\n \n-    pub fn from_context(ctx: &'a RewriteContext<'_>) -> FmtVisitor<'a> {\n+    pub(crate) fn from_context(ctx: &'a RewriteContext<'_>) -> FmtVisitor<'a> {\n         let mut visitor = FmtVisitor::from_source_map(\n             ctx.parse_session,\n             ctx.config,\n@@ -650,16 +650,16 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n \n-    pub fn opt_snippet(&'b self, span: Span) -> Option<&'a str> {\n+    pub(crate) fn opt_snippet(&'b self, span: Span) -> Option<&'a str> {\n         self.snippet_provider.span_to_snippet(span)\n     }\n \n-    pub fn snippet(&'b self, span: Span) -> &'a str {\n+    pub(crate) fn snippet(&'b self, span: Span) -> &'a str {\n         self.opt_snippet(span).unwrap()\n     }\n \n     // Returns true if we should skip the following item.\n-    pub fn visit_attrs(&mut self, attrs: &[ast::Attribute], style: ast::AttrStyle) -> bool {\n+    pub(crate) fn visit_attrs(&mut self, attrs: &[ast::Attribute], style: ast::AttrStyle) -> bool {\n         for attr in attrs {\n             if attr.name() == DEPR_SKIP_ANNOTATION {\n                 let file_name = self.source_map.span_to_filename(attr.span).into();\n@@ -810,13 +810,17 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n \n-    pub fn format_separate_mod(&mut self, m: &ast::Mod, source_file: &source_map::SourceFile) {\n+    pub(crate) fn format_separate_mod(\n+        &mut self,\n+        m: &ast::Mod,\n+        source_file: &source_map::SourceFile,\n+    ) {\n         self.block_indent = Indent::empty();\n         self.walk_mod_items(m);\n         self.format_missing_with_indent(source_file.end_pos);\n     }\n \n-    pub fn skip_empty_lines(&mut self, end_pos: BytePos) {\n+    pub(crate) fn skip_empty_lines(&mut self, end_pos: BytePos) {\n         while let Some(pos) = self\n             .snippet_provider\n             .opt_span_after(mk_sp(self.last_pos, end_pos), \"\\n\")\n@@ -831,7 +835,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n \n-    pub fn with_context<F>(&mut self, f: F) -> Option<String>\n+    pub(crate) fn with_context<F>(&mut self, f: F) -> Option<String>\n     where\n         F: Fn(&RewriteContext<'_>) -> Option<String>,\n     {\n@@ -847,7 +851,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         result\n     }\n \n-    pub fn get_context(&self) -> RewriteContext<'_> {\n+    pub(crate) fn get_context(&self) -> RewriteContext<'_> {\n         RewriteContext {\n             parse_session: self.parse_session,\n             source_map: self.source_map,"}]}