{"sha": "64d171b8a419eb6cb872ab579398eff8a741bbc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZDE3MWI4YTQxOWViNmNiODcyYWI1NzkzOThlZmY4YTc0MWJiYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-17T10:15:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-17T10:15:33Z"}, "message": "Auto merge of #87124 - Andy-Python-Programmer:code_model_uefi_patch, r=petrochenkov\n\nUse small code model for UEFI targets\n\n* Since the code model only applies to the code and not the data and the code model\nonly applies to functions you call through using `call`, `jmp` and data with `lea`, etc\u2026\n\n  If you are calling functions using the function pointers from the UEFI structures the code\n  model does not apply in that case. It\u2019s just related to the address space size of your own binary.\n  Since UEFI (uefi is all relocatable) uses relocatable PEs (relocatable code does not care about the\n  code model) so, we use the small code model here.\n\n* Since applications don't usually take gigabytes of memory, setting the\ntarget to use the small code model should result in better codegen (comparable\nwith majority of other targets).\n\n  Large code models are also known for generating horrible code, for\n  example 16 bytes of code to load a single 8-byte value.\n\nSigned-off-by: Andy-Python-Programmer <andypythonappdeveloper@gmail.com>", "tree": {"sha": "7fdbd2d800f5d4109d388ba4ddc1429c9235cc2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fdbd2d800f5d4109d388ba4ddc1429c9235cc2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64d171b8a419eb6cb872ab579398eff8a741bbc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64d171b8a419eb6cb872ab579398eff8a741bbc6", "html_url": "https://github.com/rust-lang/rust/commit/64d171b8a419eb6cb872ab579398eff8a741bbc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64d171b8a419eb6cb872ab579398eff8a741bbc6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "153df0f6ef0f3ff00b12122774825507fd88169f", "url": "https://api.github.com/repos/rust-lang/rust/commits/153df0f6ef0f3ff00b12122774825507fd88169f", "html_url": "https://github.com/rust-lang/rust/commit/153df0f6ef0f3ff00b12122774825507fd88169f"}, {"sha": "db1e49257e84f065bf14d547c36cb76178b03971", "url": "https://api.github.com/repos/rust-lang/rust/commits/db1e49257e84f065bf14d547c36cb76178b03971", "html_url": "https://github.com/rust-lang/rust/commit/db1e49257e84f065bf14d547c36cb76178b03971"}], "stats": {"total": 8, "additions": 2, "deletions": 6}, "files": [{"sha": "be0e62bea0228055fd6be794f760415e48f4bf80", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_uefi.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64d171b8a419eb6cb872ab579398eff8a741bbc6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_uefi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64d171b8a419eb6cb872ab579398eff8a741bbc6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_uefi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_uefi.rs?ref=64d171b8a419eb6cb872ab579398eff8a741bbc6", "patch": "@@ -5,7 +5,7 @@\n // The win64 ABI is used. It differs from the sysv64 ABI, so we must use a windows target with\n // LLVM. \"x86_64-unknown-windows\" is used to get the minimal subset of windows-specific features.\n \n-use crate::spec::{CodeModel, Target};\n+use crate::spec::Target;\n \n pub fn target() -> Target {\n     let mut base = super::uefi_msvc_base::opts();\n@@ -19,15 +19,11 @@ pub fn target() -> Target {\n     // to leave these uninitialized, thus triggering exceptions if we make use of them. Which is\n     // why we avoid them and instead use soft-floats. This is also what GRUB and friends did so\n     // far.\n+    //\n     // If you initialize FP units yourself, you can override these flags with custom linker\n     // arguments, thus giving you access to full MMX/SSE acceleration.\n     base.features = \"-mmx,-sse,+soft-float\".to_string();\n \n-    // UEFI systems run without a host OS, hence we cannot assume any code locality. We must tell\n-    // LLVM to expect code to reference any address in the address-space. The \"large\" code-model\n-    // places no locality-restrictions, so it fits well here.\n-    base.code_model = Some(CodeModel::Large);\n-\n     Target {\n         llvm_target: \"x86_64-unknown-windows\".to_string(),\n         pointer_width: 64,"}]}