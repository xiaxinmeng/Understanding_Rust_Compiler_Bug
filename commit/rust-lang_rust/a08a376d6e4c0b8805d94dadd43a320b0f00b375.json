{"sha": "a08a376d6e4c0b8805d94dadd43a320b0f00b375", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwOGEzNzZkNmU0YzBiODgwNWQ5NGRhZGQ0M2EzMjBiMGYwMGIzNzU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-05-20T21:15:39Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-20T23:57:37Z"}, "message": "Make controlflow part of a function type\n\nChange ty_fn to have a controlflow field. A 'controlflow' is\nessentially a bit of data that says whether or not this function\nnever returns to the caller (if it never returns, that means it calls\n\"fail\" or another \"never-returns\" function on every control path).\n\nAlso add syntax for annotating functions that never return:\n\nfn foo() -> ! {\n   fail;\n}\n\nfor example. Functions marked with ! implicitly have a result type of\nty_bot, which is a new type that this commit also adds.", "tree": {"sha": "2275100c990c9d774e61f784bbd5e8d98f8f5cbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2275100c990c9d774e61f784bbd5e8d98f8f5cbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a08a376d6e4c0b8805d94dadd43a320b0f00b375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a08a376d6e4c0b8805d94dadd43a320b0f00b375", "html_url": "https://github.com/rust-lang/rust/commit/a08a376d6e4c0b8805d94dadd43a320b0f00b375", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a08a376d6e4c0b8805d94dadd43a320b0f00b375/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dd2877975efd0dd9ed8debe202c8e9d48810f48", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dd2877975efd0dd9ed8debe202c8e9d48810f48", "html_url": "https://github.com/rust-lang/rust/commit/3dd2877975efd0dd9ed8debe202c8e9d48810f48"}], "stats": {"total": 334, "additions": 213, "deletions": 121}, "files": [{"sha": "db625124be45309bd0d23ce49734c4f95a084d97", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -307,7 +307,8 @@ type mt = rec(@ty ty, mutability mut);\n type ty_field = rec(ident ident, mt mt);\n type ty_arg = rec(mode mode, @ty ty);\n type ty_method = rec(proto proto, ident ident,\n-                     vec[ty_arg] inputs, @ty output);\n+                     vec[ty_arg] inputs, @ty output,\n+                     controlflow cf);\n type ty = spanned[ty_];\n tag ty_ {\n     ty_nil;\n@@ -330,7 +331,7 @@ tag ty_ {\n     ty_chan(@ty);\n     ty_tup(vec[mt]);\n     ty_rec(vec[ty_field]);\n-    ty_fn(proto, vec[ty_arg], @ty);\n+    ty_fn(proto, vec[ty_arg], @ty, controlflow);\n     ty_obj(vec[ty_method]);\n     ty_path(path, ann);\n     ty_type;"}, {"sha": "da6d3b11316349c977707e270cfd1becc0f724b1", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -13,6 +13,8 @@ import middle::ty;\n import back::x86;\n import util::common;\n import util::common::span;\n+import util::common::a_bang;\n+import util::common::a_ty;\n \n import std::str;\n import std::uint;\n@@ -47,6 +49,8 @@ type str_def = fn(str) -> ast::def_id;\n type pstate = rec(vec[u8] data, int crate,\n                   mutable uint pos, uint len, ty::ctxt tcx);\n \n+type ty_or_bang = util::common::ty_or_bang[ty::t];\n+\n fn peek(@pstate st) -> u8 {\n     ret st.data.(st.pos);\n }\n@@ -64,9 +68,17 @@ fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len,\n     ret result;\n }\n \n+fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n+    alt (peek(st) as char) {\n+        case ('!') { auto ignore = next(st); ret a_bang[ty::t]; }\n+        case (_)   { ret a_ty[ty::t](parse_ty(st, sd)); }\n+    }\n+}\n+\n fn parse_ty(@pstate st, str_def sd) -> ty::t {\n     alt (next(st) as char) {\n         case ('n') { ret ty::mk_nil(st.tcx); }\n+        case ('z') { ret ty::mk_bot(st.tcx); }\n         case ('b') { ret ty::mk_bool(st.tcx); }\n         case ('i') { ret ty::mk_int(st.tcx); }\n         case ('u') { ret ty::mk_uint(st.tcx); }\n@@ -127,11 +139,11 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         }\n         case ('F') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_fn, func._0, func._1);\n+            ret ty::mk_fn(st.tcx, ast::proto_fn, func._0, func._1, func._2);\n         }\n         case ('W') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_iter, func._0, func._1);\n+            ret ty::mk_fn(st.tcx, ast::proto_iter, func._0, func._1, func._2);\n         }\n         case ('N') {\n             auto abi;\n@@ -159,9 +171,10 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n                 }\n                 auto func = parse_ty_fn(st, sd);\n                 methods += [rec(proto=proto,\n-                                   ident=name,\n-                                   inputs=func._0,\n-                                   output=func._1)];\n+                                ident=name,\n+                                inputs=func._0,\n+                                output=func._1,\n+                                cf=func._2)];\n             }\n             st.pos += 1u;\n             ret ty::mk_obj(st.tcx, methods);\n@@ -240,7 +253,8 @@ fn parse_hex(@pstate st) -> uint {\n     ret n;\n }\n \n-fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t) {\n+fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t,\n+                                              ast::controlflow) {\n     assert (next(st) as char == '[');\n     let vec[ty::arg] inputs = [];\n     while (peek(st) as char != ']') {\n@@ -252,7 +266,15 @@ fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t) {\n         inputs += [rec(mode=mode, ty=parse_ty(st, sd))];\n     }\n     st.pos = st.pos + 1u;\n-    ret tup(inputs, parse_ty(st, sd));\n+    auto res = parse_ty_or_bang(st, sd);\n+    alt (res) {\n+        case (a_bang[ty::t]) {\n+            ret tup(inputs, ty::mk_bot(st.tcx), ast::noreturn);\n+        }\n+        case (a_ty[ty::t](?t)) {\n+            ret tup(inputs, t, ast::return);\n+        }\n+    }\n }\n \n \n@@ -550,7 +572,7 @@ fn get_tag_variants(ty::ctxt tcx, ast::def_id def)\n         auto ctor_ty = item_type(item, external_crate_id, tcx);\n         let vec[ty::t] arg_tys = [];\n         alt (ty::struct(tcx, ctor_ty)) {\n-            case (ty::ty_fn(_, ?args, _)) {\n+            case (ty::ty_fn(_, ?args, _, _)) {\n                 for (ty::arg a in args) {\n                     arg_tys += [a.ty];\n                 }"}, {"sha": "80397f2a65bbcd552abafa8984a639c65cc8200d", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -12,6 +12,8 @@ import util::common::filename;\n import util::common::span;\n import util::common::new_str_hash;\n import util::data::interner;\n+import util::common::a_bang;\n+import util::common::a_ty;\n \n tag restriction {\n     UNRESTRICTED;\n@@ -23,10 +25,7 @@ tag file_type {\n     SOURCE_FILE;\n }\n \n-tag ty_or_bang {\n-    a_ty(@ast::ty);\n-    a_bang;\n-}\n+type ty_or_bang = util::common::ty_or_bang[@ast::ty];\n \n state type parser =\n     state obj {\n@@ -351,14 +350,24 @@ fn parse_ty_fn(ast::proto proto, &parser p, uint lo)\n     parse_constrs(p);\n \n     let @ast::ty output;\n+    auto cf = ast::return;\n     if (p.peek() == token::RARROW) {\n         p.bump();\n-        output = parse_ty(p);\n+        auto tmp = parse_ty_or_bang(p);\n+        alt (tmp) {\n+            case (a_ty[@ast::ty](?t)) {\n+                output = t;\n+            }\n+            case (a_bang[@ast::ty]) {\n+                output = @spanned(lo, inputs.span.hi, ast::ty_bot);\n+                cf = ast::noreturn;\n+            }\n+        }\n     } else {\n         output = @spanned(lo, inputs.span.hi, ast::ty_nil);\n     }\n \n-    ret ast::ty_fn(proto, inputs.node, output);\n+    ret ast::ty_fn(proto, inputs.node, output, cf);\n }\n \n fn parse_proto(&parser p) -> ast::proto {\n@@ -377,9 +386,9 @@ fn parse_ty_obj(&parser p, &mutable uint hi) -> ast::ty_ {\n         auto f = parse_ty_fn(proto, p, flo);\n         expect(p, token::SEMI);\n         alt (f) {\n-            case (ast::ty_fn(?proto, ?inputs, ?output)) {\n+            case (ast::ty_fn(?proto, ?inputs, ?output, ?cf)) {\n                 ret rec(proto=proto, ident=ident,\n-                        inputs=inputs, output=output);\n+                        inputs=inputs, output=output, cf=cf);\n             }\n         }\n         fail;\n@@ -457,8 +466,8 @@ fn parse_ty_constrs(@ast::ty t, &parser p) -> @ast::ty {\n \n fn parse_ty_or_bang(&parser p) -> ty_or_bang {\n     alt (p.peek()) {\n-        case (token::NOT) { p.bump(); ret a_bang; }\n-        case (_)         { ret a_ty(parse_ty(p)); }\n+        case (token::NOT) { p.bump(); ret a_bang[@ast::ty]; }\n+        case (_)         { ret a_ty[@ast::ty](parse_ty(p)); }\n     }\n }\n \n@@ -530,15 +539,15 @@ fn parse_ty(&parser p) -> @ast::ty {\n         auto flo = p.get_last_lo_pos();\n         t = parse_ty_fn(ast::proto_fn, p, flo);\n         alt (t) {\n-            case (ast::ty_fn(_, _, ?out)) {\n+            case (ast::ty_fn(_, _, ?out, _)) {\n                 hi = out.span.hi;\n             }\n         }\n     } else if (eat_word(p, \"iter\")) {\n         auto flo = p.get_last_lo_pos();\n         t = parse_ty_fn(ast::proto_iter, p, flo);\n         alt (t) {\n-            case (ast::ty_fn(_, _, ?out)) {\n+            case (ast::ty_fn(_, _, ?out, _)) {\n                 hi = out.span.hi;\n             }\n         }\n@@ -1735,15 +1744,16 @@ fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n         p.bump();\n         res = parse_ty_or_bang(p);\n     } else {\n-        res = a_ty(@spanned(inputs.span.lo, inputs.span.hi, ast::ty_nil));\n+        res = a_ty[@ast::ty](@spanned(inputs.span.lo, inputs.span.hi,\n+                                      ast::ty_nil));\n     }\n \n     alt (res) {\n-        case (a_ty(?t)) {\n+        case (a_ty[@ast::ty](?t)) {\n             ret rec(inputs=inputs.node, output=t,\n               purity=purity, cf=ast::return);\n         }\n-        case (a_bang) {\n+        case (a_bang[@ast::ty]) {\n             ret rec(inputs=inputs.node,\n                     output=@spanned(p.get_lo_pos(),\n                                     p.get_hi_pos(), ast::ty_bot),"}, {"sha": "9d48d50b4e65a1ae7f2caa5c6de0b317eb6c436f", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -67,7 +67,7 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp,\n          ast::proto proto,\n          &vec[rec(ast::mode mode, @ty ty)] inputs,\n-         &@ty output) -> @ty)                     fold_ty_fn,\n+         &@ty output, &controlflow cf) -> @ty)    fold_ty_fn,\n \n      (fn(&ENV e, &span sp, &ast::path p,\n          &ann a) -> @ty)                          fold_ty_path,\n@@ -423,12 +423,12 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n             let vec[ast::ty_method] meths_ = [];\n             for (ast::ty_method m in meths) {\n                 auto tfn = fold_ty_fn(env_, fld, t.span, m.proto,\n-                                      m.inputs, m.output);\n+                                      m.inputs, m.output, m.cf);\n                 alt (tfn.node) {\n-                    case (ast::ty_fn(?p, ?ins, ?out)) {\n+                    case (ast::ty_fn(?p, ?ins, ?out, ?cf)) {\n                         vec::push[ast::ty_method]\n                             (meths_, rec(proto=p, inputs=ins,\n-                                         output=out with m));\n+                                         output=out, cf=cf with m));\n                     }\n                 }\n             }\n@@ -440,8 +440,8 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n             ret fld.fold_ty_path(env_, t.span, pth_, ann);\n         }\n \n-        case (ast::ty_fn(?proto, ?inputs, ?output)) {\n-            ret fold_ty_fn(env_, fld, t.span, proto, inputs, output);\n+        case (ast::ty_fn(?proto, ?inputs, ?output, ?cf)) {\n+            ret fold_ty_fn(env_, fld, t.span, proto, inputs, output, cf);\n         }\n \n         case (ast::ty_chan(?ty)) {\n@@ -459,15 +459,15 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n fn fold_ty_fn[ENV](&ENV env, &ast_fold[ENV] fld, &span sp,\n                    ast::proto proto,\n                    &vec[rec(ast::mode mode, @ty ty)] inputs,\n-                   &@ty output) -> @ty {\n+                   &@ty output, &controlflow cf) -> @ty {\n     auto output_ = fold_ty(env, fld, output);\n     let vec[rec(ast::mode mode, @ty ty)] inputs_ = [];\n     for (rec(ast::mode mode, @ty ty) input in inputs) {\n         auto ty_ = fold_ty(env, fld, input.ty);\n         auto input_ = rec(ty=ty_ with input);\n         inputs_ += [input_];\n     }\n-    ret fld.fold_ty_fn(env, sp, proto, inputs_, output_);\n+    ret fld.fold_ty_fn(env, sp, proto, inputs_, output_, cf);\n }\n \n fn fold_decl[ENV](&ENV env, &ast_fold[ENV] fld, &@decl d) -> @decl {\n@@ -1264,8 +1264,8 @@ fn identity_fold_ty_obj[ENV](&ENV env, &span sp,\n fn identity_fold_ty_fn[ENV](&ENV env, &span sp,\n                             ast::proto proto,\n                             &vec[rec(ast::mode mode, @ty ty)] inputs,\n-                            &@ty output) -> @ty {\n-    ret @respan(sp, ast::ty_fn(proto, inputs, output));\n+                            &@ty output, &controlflow cf) -> @ty {\n+    ret @respan(sp, ast::ty_fn(proto, inputs, output, cf));\n }\n \n fn identity_fold_ty_path[ENV](&ENV env, &span sp, &ast::path p,\n@@ -1742,7 +1742,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_ty_tup     = bind identity_fold_ty_tup[ENV](_,_,_),\n          fold_ty_rec     = bind identity_fold_ty_rec[ENV](_,_,_),\n          fold_ty_obj     = bind identity_fold_ty_obj[ENV](_,_,_),\n-         fold_ty_fn      = bind identity_fold_ty_fn[ENV](_,_,_,_,_),\n+         fold_ty_fn      = bind identity_fold_ty_fn[ENV](_,_,_,_,_,_),\n          fold_ty_path    = bind identity_fold_ty_path[ENV](_,_,_,_),\n          fold_ty_chan    = bind identity_fold_ty_chan[ENV](_,_,_),\n          fold_ty_port    = bind identity_fold_ty_port[ENV](_,_,_),"}, {"sha": "97b2f3d7c4a316df81a5c77d8085af7b17dc8fb9", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -144,6 +144,7 @@ mod Encode {\n     fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n         alt (st) {\n             case (ty::ty_nil) { w.write_char('n'); }\n+            case (ty::ty_bot) { w.write_char('z'); }\n             case (ty::ty_bool) { w.write_char('b'); }\n             case (ty::ty_int) { w.write_char('i'); }\n             case (ty::ty_uint) { w.write_char('u'); }\n@@ -193,9 +194,9 @@ mod Encode {\n                 }\n                 w.write_char(']');\n             }\n-            case (ty::ty_fn(?proto,?args,?out)) {\n+            case (ty::ty_fn(?proto,?args,?out,?cf)) {\n                 enc_proto(w, proto);\n-                enc_ty_fn(w, cx, args, out);\n+                enc_ty_fn(w, cx, args, out, cf);\n             }\n             case (ty::ty_native_fn(?abi,?args,?out)) {\n                 w.write_char('N');\n@@ -207,14 +208,14 @@ mod Encode {\n                     case (ast::native_abi_cdecl) { w.write_char('c'); }\n                     case (ast::native_abi_llvm) { w.write_char('l'); }\n                 }\n-                enc_ty_fn(w, cx, args, out);\n+                enc_ty_fn(w, cx, args, out, ast::return);\n             }\n             case (ty::ty_obj(?methods)) {\n                 w.write_str(\"O[\");\n                 for (ty::method m in methods) {\n                     enc_proto(w, m.proto);\n                     w.write_str(m.ident);\n-                    enc_ty_fn(w, cx, m.inputs, m.output);\n+                    enc_ty_fn(w, cx, m.inputs, m.output, m.cf);\n                 }\n                 w.write_char(']');\n             }\n@@ -250,14 +251,22 @@ mod Encode {\n         }\n     }\n \n-    fn enc_ty_fn(&io::writer w, &@ctxt cx, &vec[ty::arg] args, &ty::t out) {\n+    fn enc_ty_fn(&io::writer w, &@ctxt cx, &vec[ty::arg] args, &ty::t out,\n+                 &ast::controlflow cf) {\n         w.write_char('[');\n         for (ty::arg arg in args) {\n             if (arg.mode == ty::mo_alias) { w.write_char('&'); }\n             enc_ty(w, cx, arg.ty);\n         }\n         w.write_char(']');\n-        enc_ty(w, cx, out);\n+        alt (cf) {\n+            case (ast::noreturn) {\n+                w.write_char('!');\n+            }\n+            case (_) {\n+                enc_ty(w, cx, out);\n+            }\n+        }\n     }\n \n }"}, {"sha": "9bcfd77d251d197ea9d5f6112530981c4c27c596", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -807,7 +807,7 @@ fn type_of_inner(&@crate_ctxt cx, &ast::span sp, &ty::t t) -> TypeRef {\n             }\n             llty = T_struct(tys);\n         }\n-        case (ty::ty_fn(?proto, ?args, ?out)) {\n+        case (ty::ty_fn(?proto, ?args, ?out, _)) {\n             llty = T_fn_pair(cx.tn, type_of_fn(cx, sp, proto, args, out, 0u));\n         }\n         case (ty::ty_native_fn(?abi, ?args, ?out)) {\n@@ -882,7 +882,7 @@ fn type_of_arg(@local_ctxt cx, &ast::span sp, &ty::arg arg) -> TypeRef {\n fn type_of_ty_param_count_and_ty(@local_ctxt lcx, &ast::span sp,\n                                  &ty::ty_param_count_and_ty tpt) -> TypeRef {\n     alt (ty::struct(lcx.ccx.tcx, tpt._1)) {\n-        case (ty::ty_fn(?proto, ?inputs, ?output)) {\n+        case (ty::ty_fn(?proto, ?inputs, ?output, _)) {\n             auto llfnty = type_of_fn(lcx.ccx, sp, proto,\n                                      inputs, output, tpt._0);\n             ret T_fn_pair(lcx.ccx.tn, llfnty);\n@@ -2114,7 +2114,7 @@ fn make_free_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n             rslt = trans_non_gc_free(cx_, b);\n         }\n \n-        case (ty::ty_fn(_,_,_)) {\n+        case (ty::ty_fn(_,_,_,_)) {\n \n             auto box_cell =\n                 cx.build.GEP(v0,\n@@ -2186,7 +2186,7 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n             rslt = decr_refcnt_maybe_free(cx, box_cell, v0, t);\n         }\n \n-        case (ty::ty_fn(_,_,_)) {\n+        case (ty::ty_fn(_,_,_,_)) {\n \n             auto box_cell =\n                 cx.build.GEP(v0,\n@@ -2650,7 +2650,7 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n                     // N-ary variant.\n                     auto fn_ty = variant.ctor_ty;\n                     alt (ty::struct(bcx.fcx.lcx.ccx.tcx, fn_ty)) {\n-                        case (ty::ty_fn(_, ?args, _)) {\n+                        case (ty::ty_fn(_, ?args, _, _)) {\n                             auto j = 0;\n                             for (ty::arg a in args) {\n                                 auto v = [C_int(0), C_int(j as int)];\n@@ -2700,7 +2700,7 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n \n             ret res(next_cx, C_nil());\n         }\n-        case (ty::ty_fn(_,_,_)) {\n+        case (ty::ty_fn(_,_,_,_)) {\n             auto box_cell_a =\n                 cx.build.GEP(av,\n                              [C_int(0),\n@@ -4386,7 +4386,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n         case (ast::def_variant(?tid, ?vid)) {\n             auto v_tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, vid);\n             alt (ty::struct(cx.fcx.lcx.ccx.tcx, v_tyt._1)) {\n-                case (ty::ty_fn(_, _, _)) {\n+                case (ty::ty_fn(_, _, _, _)) {\n                     // N-ary variant.\n                     ret lval_generic_fn(cx, v_tyt, vid, ann);\n                 }\n@@ -4429,7 +4429,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n             ret lval_generic_fn(cx, tyt, did, ann);\n         }\n         case (_) {\n-            cx.fcx.lcx.ccx.sess.unimpl(\"def variant in trans\");\n+            cx.fcx.lcx.ccx.sess.span_unimpl(cx.sp, \"def variant in trans\");\n         }\n     }\n }\n@@ -6578,7 +6578,7 @@ fn is_terminated(&@block_ctxt cx) -> bool {\n \n fn arg_tys_of_fn(&@crate_ctxt ccx, ast::ann ann) -> vec[ty::arg] {\n     alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx.node_types, ann))) {\n-        case (ty::ty_fn(_, ?arg_tys, _)) {\n+        case (ty::ty_fn(_, ?arg_tys, _, _)) {\n             ret arg_tys;\n         }\n     }\n@@ -6587,7 +6587,7 @@ fn arg_tys_of_fn(&@crate_ctxt ccx, ast::ann ann) -> vec[ty::arg] {\n \n fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty::t t) -> ty::t {\n     alt (ty::struct(ccx.tcx, t)) {\n-        case (ty::ty_fn(_, _, ?ret_ty)) {\n+        case (ty::ty_fn(_, _, ?ret_ty, _)) {\n             ret ret_ty;\n         }\n     }\n@@ -6739,7 +6739,7 @@ fn trans_vtbl(@local_ctxt cx,\n \n         auto llfnty = T_nil();\n         alt (ty::struct(cx.ccx.tcx, node_ann_type(cx.ccx, m.node.ann))) {\n-            case (ty::ty_fn(?proto, ?inputs, ?output)) {\n+            case (ty::ty_fn(?proto, ?inputs, ?output, _)) {\n                 llfnty = type_of_fn_full(cx.ccx, m.span, proto,\n                                          some[TypeRef](llself_ty),\n                                          inputs, output,\n@@ -7099,7 +7099,7 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &ast::span sp,\n     auto llfty;\n     auto llpairty;\n     alt (ty::struct(ccx.tcx, node_ann_type(ccx, ann))) {\n-        case (ty::ty_fn(?proto, ?inputs, ?output)) {\n+        case (ty::ty_fn(?proto, ?inputs, ?output, _)) {\n             llfty = type_of_fn(ccx, sp, proto, inputs, output,\n                                vec::len[ast::ty_param](ty_params));\n             llpairty = T_fn_pair(ccx.tn, llfty);"}, {"sha": "99d293914aa0e4068933b347cd646a6419e19590", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -381,20 +381,16 @@ fn controlflow_def_id(&crate_ctxt ccx, &def_id d) -> controlflow {\n     }\n }\n \n-/* conservative approximation: uses the mapping if e refers to a known\n-   function or method, assumes returning otherwise.\n-   There's no case for fail b/c we assume e is the callee and it\n-   seems unlikely that one would apply \"fail\" to arguments. */\n+/* Use e's type to determine whether it returns.\n+ If it has a function type with a ! annotation,\n+the answer is noreturn. */\n fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n-    auto f = expr_ann(e).id;\n-    alt (ccx.tcx.def_map.find(f)) {\n-        case (some[def](def_fn(?d))) { \n-            ret controlflow_def_id(ccx, d); \n+    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx.node_types,\n+                                             expr_ann(e)))) {\n+        case (ty::ty_fn(_,_,_,?cf)) {\n+            ret cf;\n         }\n-        case (some[def](def_obj_field(?d))) { \n-            ret controlflow_def_id(ccx, d);\n-        }\n-        case (_)                            {\n+        case (_) {\n             ret return;\n         }\n     }"}, {"sha": "b92b7fb61db7d0a30f4cd6884f5b458cd72e1347", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 65, "deletions": 30, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -13,6 +13,7 @@ import std::option::some;\n import driver::session;\n import front::ast;\n import front::ast::mutability;\n+import front::ast::controlflow;\n import front::creader;\n import middle::metadata;\n import util::common;\n@@ -49,7 +50,8 @@ type field = rec(ast::ident ident, mt mt);\n type method = rec(ast::proto proto,\n                   ast::ident ident,\n                   vec[arg] inputs,\n-                  t output);\n+                  t output,\n+                  controlflow cf);\n \n tag any_item {\n     any_item_rust(@ast::item);\n@@ -76,7 +78,7 @@ type ty_ctxt = ctxt;    // Needed for disambiguation from unify::ctxt.\n // Convert from method type to function type.  Pretty easy; we just drop\n // 'ident'.\n fn method_ty_to_fn_ty(&ctxt cx, method m) -> t {\n-    ret mk_fn(cx, m.proto, m.inputs, m.output);\n+    ret mk_fn(cx, m.proto, m.inputs, m.output, m.cf);\n }\n \n // Never construct these manually. These are interned.\n@@ -113,7 +115,7 @@ tag sty {\n     ty_task;\n     ty_tup(vec[mt]);\n     ty_rec(vec[field]);\n-    ty_fn(ast::proto, vec[arg], t);\n+    ty_fn(ast::proto, vec[arg], t, controlflow);\n     ty_native_fn(ast::native_abi, vec[arg], t);\n     ty_obj(vec[method]);\n     ty_var(int);                                    // ephemeral type var\n@@ -135,6 +137,7 @@ type unify_handler = obj {\n \n tag type_err {\n     terr_mismatch;\n+    terr_controlflow_mismatch;\n     terr_box_mutability;\n     terr_vec_mutability;\n     terr_tuple_size(uint, uint);\n@@ -358,7 +361,7 @@ fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] cname) -> raw_t {\n             }\n         }\n \n-        case (ty_fn(_, ?args, ?tt)) {\n+        case (ty_fn(_, ?args, ?tt, _)) {\n             derive_flags_sig(cx, has_params, has_bound_params,\n                              has_vars, has_locals, args, tt);\n         }\n@@ -462,8 +465,9 @@ fn mk_imm_tup(&ctxt cx, &vec[t] tys) -> t {\n \n fn mk_rec(&ctxt cx, &vec[field] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n-fn mk_fn(&ctxt cx, &ast::proto proto, &vec[arg] args, &t ty) -> t {\n-    ret gen_ty(cx, ty_fn(proto, args, ty));\n+fn mk_fn(&ctxt cx, &ast::proto proto, &vec[arg] args, &t ty,\n+         &controlflow cf) -> t {\n+    ret gen_ty(cx, ty_fn(proto, args, ty, cf));\n }\n \n fn mk_native_fn(&ctxt cx, &ast::native_abi abi, &vec[arg] args, &t ty) -> t {\n@@ -635,7 +639,7 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             }\n         }\n \n-        case (ty_fn(?proto, ?inputs, ?output)) {\n+        case (ty_fn(?proto, ?inputs, ?output, _)) {\n             s += fn_to_str(cx, proto, none[ast::ident], inputs, output);\n         }\n \n@@ -721,7 +725,7 @@ fn walk_ty(&ctxt cx, ty_walk walker, t ty) {\n                 walk_ty(cx, walker, fl.mt.ty);\n             }\n         }\n-        case (ty_fn(?proto, ?args, ?ret_ty)) {\n+        case (ty_fn(?proto, ?args, ?ret_ty, _)) {\n             for (arg a in args) {\n                 walk_ty(cx, walker, a.ty);\n             }\n@@ -805,14 +809,14 @@ fn fold_ty(&ctxt cx, ty_fold fld, t ty_0) -> t {\n             }\n             ty = copy_cname(cx, mk_rec(cx, new_fields), ty);\n         }\n-        case (ty_fn(?proto, ?args, ?ret_ty)) {\n+        case (ty_fn(?proto, ?args, ?ret_ty, ?cf)) {\n             let vec[arg] new_args = [];\n             for (arg a in args) {\n                 auto new_ty = fold_ty(cx, fld, a.ty);\n                 new_args += [rec(mode=a.mode, ty=new_ty)];\n             }\n             ty = copy_cname(cx, mk_fn(cx, proto, new_args,\n-                                      fold_ty(cx, fld, ret_ty)), ty);\n+                                      fold_ty(cx, fld, ret_ty), cf), ty);\n         }\n         case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n             let vec[arg] new_args = [];\n@@ -832,8 +836,8 @@ fn fold_ty(&ctxt cx, ty_fold fld, t ty_0) -> t {\n                                         ty=fold_ty(cx, fld, a.ty))];\n                 }\n                 new_methods += [rec(proto=m.proto, ident=m.ident,\n-                                       inputs=new_args,\n-                                       output=fold_ty(cx, fld, m.output))];\n+                               inputs=new_args,\n+                               output=fold_ty(cx, fld, m.output), cf=m.cf)];\n             }\n             ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n         }\n@@ -885,7 +889,7 @@ fn type_is_structural(&ctxt cx, &t ty) -> bool {\n         case (ty_tup(_))    { ret true; }\n         case (ty_rec(_))    { ret true; }\n         case (ty_tag(_,_))  { ret true; }\n-        case (ty_fn(_,_,_)) { ret true; }\n+        case (ty_fn(_,_,_,_)) { ret true; }\n         case (ty_obj(_))    { ret true; }\n         case (_)            { ret false; }\n     }\n@@ -1206,7 +1210,7 @@ fn hash_type_structure(&sty st) -> uint {\n             }\n             ret h;\n         }\n-        case (ty_fn(_, ?args, ?rty)) { ret hash_fn(25u, args, rty); }\n+        case (ty_fn(_, ?args, ?rty, _)) { ret hash_fn(25u, args, rty); }\n         case (ty_native_fn(_, ?args, ?rty)) { ret hash_fn(26u, args, rty); }\n         case (ty_obj(?methods)) {\n             auto h = 27u;\n@@ -1405,10 +1409,11 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 case (_) { ret false; }\n             }\n         }\n-        case (ty_fn(?p_a, ?args_a, ?rty_a)) {\n+        case (ty_fn(?p_a, ?args_a, ?rty_a, ?cf_a)) {\n             alt (b) {\n-                case (ty_fn(?p_b, ?args_b, ?rty_b)) {\n+                case (ty_fn(?p_b, ?args_b, ?rty_b, ?cf_b)) {\n                     ret p_a == p_b &&\n+                        cf_a == cf_b &&\n                         equal_fn(args_a, rty_a, args_b, rty_b);\n                 }\n                 case (_) { ret false; }\n@@ -1635,15 +1640,15 @@ fn type_contains_bound_params(&ctxt cx, &t typ) -> bool {\n \n fn ty_fn_args(&ctxt cx, &t fty) -> vec[arg] {\n     alt (struct(cx, fty)) {\n-        case (ty::ty_fn(_, ?a, _)) { ret a; }\n+        case (ty::ty_fn(_, ?a, _, _)) { ret a; }\n         case (ty::ty_native_fn(_, ?a, _)) { ret a; }\n     }\n     fail;\n }\n \n fn ty_fn_proto(&ctxt cx, &t fty) -> ast::proto {\n     alt (struct(cx, fty)) {\n-        case (ty::ty_fn(?p, _, _)) { ret p; }\n+        case (ty::ty_fn(?p, _, _, _)) { ret p; }\n     }\n     fail;\n }\n@@ -1657,15 +1662,15 @@ fn ty_fn_abi(&ctxt cx, &t fty) -> ast::native_abi {\n \n fn ty_fn_ret(&ctxt cx, &t fty) -> t {\n     alt (struct(cx, fty)) {\n-        case (ty::ty_fn(_, _, ?r)) { ret r; }\n+        case (ty::ty_fn(_, _, ?r, _)) { ret r; }\n         case (ty::ty_native_fn(_, _, ?r)) { ret r; }\n     }\n     fail;\n }\n \n fn is_fn_ty(&ctxt cx, &t fty) -> bool {\n     alt (struct(cx, fty)) {\n-        case (ty::ty_fn(_, _, _)) { ret true; }\n+        case (ty::ty_fn(_, _, _, _)) { ret true; }\n         case (ty::ty_native_fn(_, _, _)) { ret true; }\n         case (_) { ret false; }\n     }\n@@ -2088,12 +2093,32 @@ mod unify {\n                 &t expected,\n                 &t actual,\n                 &vec[arg] expected_inputs, &t expected_output,\n-                &vec[arg] actual_inputs, &t actual_output)\n+                &vec[arg] actual_inputs, &t actual_output,\n+                &controlflow expected_cf, &controlflow actual_cf)\n         -> result {\n \n         if (e_proto != a_proto) {\n             ret ures_err(terr_mismatch, expected, actual);\n         }\n+        alt (expected_cf) {\n+            case (ast::return) { } // ok\n+            case (ast::noreturn) {\n+                alt (actual_cf) {\n+                    case (ast::noreturn) {\n+                        // ok\n+                    }\n+                    case (_) {\n+                        /* even though typestate checking is mostly\n+                           responsible for checking control flow annotations,\n+                           this check is necessary to ensure that the\n+                           annotation in an object method matches the\n+                           declared object type */\n+                        ret ures_err(terr_controlflow_mismatch,\n+                                     expected, actual);\n+                    }\n+                }\n+            }\n+        }\n         auto t = unify_fn_common(cx, expected, actual,\n                                  expected_inputs, expected_output,\n                                  actual_inputs, actual_output);\n@@ -2102,7 +2127,8 @@ mod unify {\n                 ret r;\n             }\n             case (fn_common_res_ok(?result_ins, ?result_out)) {\n-                auto t2 = mk_fn(cx.tcx, e_proto, result_ins, result_out);\n+                auto t2 = mk_fn(cx.tcx, e_proto, result_ins, result_out,\n+                                actual_cf);\n                 ret ures_ok(t2);\n             }\n         }\n@@ -2160,14 +2186,16 @@ mod unify {\n                           e_meth.proto, a_meth.proto,\n                           expected, actual,\n                           e_meth.inputs, e_meth.output,\n-                          a_meth.inputs, a_meth.output);\n+                          a_meth.inputs, a_meth.output,\n+                          e_meth.cf, a_meth.cf);\n         alt (r) {\n             case (ures_ok(?tfn)) {\n                 alt (struct(cx.tcx, tfn)) {\n-                    case (ty_fn(?proto, ?ins, ?out)) {\n+                    case (ty_fn(?proto, ?ins, ?out, ?cf)) {\n                         result_meths += [rec(inputs = ins,\n-                                                output = out\n-                                                with e_meth)];\n+                                             output = out,\n+                                             cf     = cf\n+                                             with e_meth)];\n                     }\n                 }\n             }\n@@ -2539,13 +2567,16 @@ mod unify {\n                 }\n             }\n \n-            case (ty::ty_fn(?ep, ?expected_inputs, ?expected_output)) {\n+            case (ty::ty_fn(?ep, ?expected_inputs,\n+                            ?expected_output, ?expected_cf)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty::ty_fn(?ap, ?actual_inputs, ?actual_output)) {\n+                    case (ty::ty_fn(?ap, ?actual_inputs,\n+                                    ?actual_output, ?actual_cf)) {\n                         ret unify_fn(cx, ep, ap,\n                                      expected, actual,\n                                      expected_inputs, expected_output,\n-                                     actual_inputs, actual_output);\n+                                     actual_inputs, actual_output,\n+                                     expected_cf, actual_cf);\n                     }\n \n                     case (_) {\n@@ -2732,6 +2763,10 @@ fn type_err_to_str(&ty::type_err err) -> str {\n         case (terr_mismatch) {\n             ret \"types differ\";\n         }\n+        case (terr_controlflow_mismatch) {\n+            ret \"returning function used where non-returning function\"\n+                + \" was expected\";\n+        }\n         case (terr_box_mutability) {\n             ret \"boxed values differ in mutability\";\n         }\n@@ -2911,7 +2946,7 @@ fn lookup_item_type(ctxt cx, ast::def_id did) -> ty_param_count_and_ty {\n \n fn ret_ty_of_fn_ty(ty_ctxt tcx, t a_ty) -> t {\n     alt (ty::struct(tcx, a_ty)) {\n-        case (ty::ty_fn(_, _, ?ret_ty)) {\n+        case (ty::ty_fn(_, _, ?ret_ty, _)) {\n             ret ret_ty;\n         }\n         case (_) {"}, {"sha": "de47fce619d864915bb5f40d97d91ed6f552500d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -314,11 +314,11 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             typ = ty::mk_rec(tcx, flds);\n         }\n \n-        case (ast::ty_fn(?proto, ?inputs, ?output)) {\n+        case (ast::ty_fn(?proto, ?inputs, ?output, ?cf)) {\n             auto f = bind ast_arg_to_arg(tcx, getter, _);\n             auto i = vec::map[ast::ty_arg, arg](f, inputs);\n             auto out_ty = ast_ty_to_ty(tcx, getter, output);\n-            typ = ty::mk_fn(tcx, proto, i, out_ty);\n+            typ = ty::mk_fn(tcx, proto, i, out_ty, cf);\n         }\n \n         case (ast::ty_path(?path, ?ann)) {\n@@ -346,11 +346,13 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             for (ast::ty_method m in meths) {\n                 auto ins = vec::map[ast::ty_arg, arg](f, m.inputs);\n                 auto out = ast_ty_to_ty(tcx, getter, m.output);\n-                vec::push[ty::method](tmeths,\n+                let ty::method new_m =\n                                   rec(proto=m.proto,\n                                       ident=m.ident,\n                                       inputs=ins,\n-                                      output=out));\n+                                      output=out,\n+                                      cf=m.cf);\n+                vec::push[ty::method](tmeths, new_m);\n             }\n \n             typ = ty::mk_obj(tcx, ty::sort_methods(tmeths));\n@@ -458,7 +460,7 @@ mod collect {\n                      &ast::def_id def_id) -> ty::ty_param_count_and_ty {\n         auto input_tys = vec::map[ast::arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n-        auto t_fn = ty::mk_fn(cx.tcx, proto, input_tys, output_ty);\n+        auto t_fn = ty::mk_fn(cx.tcx, proto, input_tys, output_ty, decl.cf);\n         auto ty_param_count = vec::len[ast::ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         cx.tcx.tcache.insert(def_id, tpt);\n@@ -513,7 +515,7 @@ mod collect {\n         auto inputs = vec::map[ast::arg,arg](f, m.node.meth.decl.inputs);\n         auto output = convert(m.node.meth.decl.output);\n         ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n-                inputs=inputs, output=output);\n+                inputs=inputs, output=output, cf=m.node.meth.decl.cf);\n     }\n \n     fn ty_of_obj(@ctxt cx,\n@@ -542,7 +544,8 @@ mod collect {\n             vec::push[arg](t_inputs, rec(mode=ty::mo_alias, ty=t_field));\n         }\n \n-        auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1);\n+        auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1,\n+                              ast::return);\n \n         auto tpt = tup(t_obj._0, t_fn);\n         cx.tcx.tcache.insert(ctor_id, tpt);\n@@ -675,7 +678,8 @@ mod collect {\n                     args += [rec(mode=ty::mo_alias, ty=arg_ty)];\n                 }\n                 auto tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n-                result_ty = ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t);\n+                result_ty = ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t,\n+                                      ast::return);\n             }\n \n             auto tpt = tup(ty_param_count, result_ty);\n@@ -782,7 +786,7 @@ mod collect {\n                         // TODO: typechecker botch\n                         let vec[arg] no_args = [];\n                         auto t = ty::mk_fn(cx.tcx, ast::proto_fn, no_args,\n-                                           ty::mk_nil(cx.tcx));\n+                                           ty::mk_nil(cx.tcx), ast::return);\n                         write::ty_only(cx.tcx, m.node.ann.id, t);\n                     }\n                 }\n@@ -1073,7 +1077,7 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n \n     auto tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt (struct(ccx.tcx, tpt._1)) {\n-        case (ty::ty_fn(_, ?ins, _)) {\n+        case (ty::ty_fn(_, ?ins, _, _)) {\n             // N-ary variant.\n             for (ty::arg arg in ins) {\n                 auto arg_ty = bind_params_in_type(ccx.tcx, arg.ty);\n@@ -1660,7 +1664,7 @@ fn check_pat(&@stmt_ctxt scx, &@ast::pat pat) {\n \n             alt (struct(scx.fcx.ccx.tcx, t)) {\n                 // N-ary variants have function types.\n-                case (ty::ty_fn(_, ?args, ?tag_ty)) {\n+                case (ty::ty_fn(_, ?args, ?tag_ty, _)) {\n                     auto arg_len = vec::len[arg](args);\n                     auto subpats_len = vec::len[@ast::pat](subpats);\n                     if (arg_len != subpats_len) {\n@@ -1798,8 +1802,8 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         auto rt_0 = next_ty_var(scx);\n         auto t_0;\n         alt (struct(scx.fcx.ccx.tcx, expr_ty(scx.fcx.ccx.tcx, f))) {\n-            case (ty::ty_fn(?proto, _, _))   {\n-                t_0 = ty::mk_fn(scx.fcx.ccx.tcx, proto, arg_tys_0, rt_0);\n+            case (ty::ty_fn(?proto, _, _, ?cf))   {\n+                t_0 = ty::mk_fn(scx.fcx.ccx.tcx, proto, arg_tys_0, rt_0, cf);\n             }\n             case (ty::ty_native_fn(?abi, _, _))   {\n                 t_0 = ty::mk_native_fn(scx.fcx.ccx.tcx, abi, arg_tys_0, rt_0);\n@@ -2236,8 +2240,9 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             let vec[ty::arg] arg_tys_1 = [];\n             auto rt_1;\n             auto fty = expr_ty(scx.fcx.ccx.tcx, f);\n+            auto t_1;\n             alt (struct(scx.fcx.ccx.tcx, fty)) {\n-                case (ty::ty_fn(?proto, ?arg_tys, ?rt)) {\n+                case (ty::ty_fn(?proto, ?arg_tys, ?rt, ?cf)) {\n                     proto_1 = proto;\n                     rt_1 = rt;\n \n@@ -2253,14 +2258,14 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                         }\n                         i += 1u;\n                     }\n+                    t_1 = ty::mk_fn(scx.fcx.ccx.tcx, proto_1, arg_tys_1, rt_1,\n+                                    cf);\n                 }\n                 case (_) {\n                     log_err \"LHS of bind expr didn't have a function type?!\";\n                     fail;\n                 }\n             }\n-\n-            auto t_1 = ty::mk_fn(scx.fcx.ccx.tcx, proto_1, arg_tys_1, rt_1);\n             write::ty_only_fixup(scx, a.id, t_1);\n         }\n \n@@ -2277,7 +2282,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             auto rt_1 = ty::mk_nil(scx.fcx.ccx.tcx); // FIXME: typestate botch\n             auto fty = expr_ty(scx.fcx.ccx.tcx, f);\n             alt (struct(scx.fcx.ccx.tcx, fty)) {\n-                case (ty::ty_fn(_,_,?rt))           { rt_1 = rt; }\n+                case (ty::ty_fn(_,_,?rt,_))         { rt_1 = rt; }\n                 case (ty::ty_native_fn(_, _, ?rt))  { rt_1 = rt; }\n                 case (_) {\n                     log_err \"LHS of call expr didn't have a function type?!\";\n@@ -2321,7 +2326,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             // Check the return type\n             auto fty = expr_ty(scx.fcx.ccx.tcx, f);\n             alt (struct(scx.fcx.ccx.tcx, fty)) {\n-                case (ty::ty_fn(_,_,?rt)) {\n+                case (ty::ty_fn(_,_,?rt,_)) {\n                     alt (struct(scx.fcx.ccx.tcx, rt)) {\n                         case (ty::ty_nil) {\n                             // This is acceptable\n@@ -2485,7 +2490,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     }\n                     auto meth = methods.(ix);\n                     auto t = ty::mk_fn(scx.fcx.ccx.tcx, meth.proto,\n-                                       meth.inputs, meth.output);\n+                                       meth.inputs, meth.output, meth.cf);\n                     write::ty_only_fixup(scx, a.id, t);\n                 }\n "}, {"sha": "cac5fd0ea353355941637eeff0fd2dbc8949b91b", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -163,7 +163,7 @@ fn walk_ty(&ast_visitor v, @ast::ty t) {\n                 walk_ty(v, f.mt.ty);\n             }\n         }\n-        case (ast::ty_fn(_, ?args, ?out)) {\n+        case (ast::ty_fn(_, ?args, ?out, _)) {\n             for (ast::ty_arg a in args) {\n                 walk_ty(v, a.ty);\n             }"}, {"sha": "d104e862dc8078d07a564830b1bd01d38c3138f5", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -137,6 +137,7 @@ fn print_type(ps s, &@ast::ty ty) {\n     alt (ty.node) {\n         case (ast::ty_nil) {wrd(s.s, \"()\");}\n         case (ast::ty_bool) {wrd(s.s, \"bool\");}\n+        case (ast::ty_bot) {wrd(s.s, \"_|_\");}\n         case (ast::ty_int) {wrd(s.s, \"int\");}\n         case (ast::ty_uint) {wrd(s.s, \"uint\");}\n         case (ast::ty_float) {wrd(s.s, \"float\");}\n@@ -188,15 +189,15 @@ fn print_type(ps s, &@ast::ty ty) {\n             for (ast::ty_method m in methods) {\n                 hbox(s);\n                 print_ty_fn(s, m.proto, option::some[str](m.ident),\n-                            m.inputs, m.output);\n+                            m.inputs, m.output, m.cf);\n                 wrd(s.s, \";\");\n                 end(s.s);\n                 line(s.s);\n             }\n             bclose_c(s, ty.span);\n         }\n-        case (ast::ty_fn(?proto,?inputs,?output)) {\n-            print_ty_fn(s, proto, option::none[str], inputs, output);\n+        case (ast::ty_fn(?proto,?inputs,?output,?cf)) {\n+            print_ty_fn(s, proto, option::none[str], inputs, output, cf);\n         }\n         case (ast::ty_path(?path,_)) {\n             print_path(s, path);\n@@ -978,7 +979,8 @@ fn print_string(ps s, str st) {\n }\n \n fn print_ty_fn(ps s, ast::proto proto, option::t[str] id,\n-               vec[ast::ty_arg] inputs, @ast::ty output) {\n+               vec[ast::ty_arg] inputs, @ast::ty output,\n+               ast::controlflow cf) {\n     if (proto == ast::proto_fn) {wrd(s.s, \"fn\");}\n     else {wrd(s.s, \"iter\");}\n     alt (id) {\n@@ -998,7 +1000,14 @@ fn print_ty_fn(ps s, ast::proto proto, option::t[str] id,\n         space(s.s);\n         hbox(s);\n         wrd1(s, \"->\");\n-        print_type(s, output);\n+        alt (cf) {\n+            case (ast::return) {\n+                print_type(s, output);\n+            }\n+            case (ast::noreturn) {\n+                wrd1(s, \"!\");\n+            }\n+        }\n         end(s.s);\n     }\n }"}, {"sha": "4e0714cd42927cb6150e8b1a3121dbe584962ff5", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08a376d6e4c0b8805d94dadd43a320b0f00b375/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=a08a376d6e4c0b8805d94dadd43a320b0f00b375", "patch": "@@ -45,6 +45,11 @@ tag ty_mach {\n     ty_f64;\n }\n \n+tag ty_or_bang[T] {\n+    a_ty(T);\n+    a_bang;\n+}\n+\n fn ty_mach_to_str(ty_mach tm) -> str {\n     alt (tm) {\n         case (ty_u8) { ret \"u8\"; }"}]}