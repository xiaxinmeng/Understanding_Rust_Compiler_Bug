{"sha": "8a8431133e1d859fe6a168cc20288d48957d97fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhODQzMTEzM2UxZDg1OWZlNmExNjhjYzIwMjg4ZDQ4OTU3ZDk3ZmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-03T18:48:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-03T18:48:43Z"}, "message": "Merge #9775\n\n9775: internal: extract_assist is aware of the expression owner r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "688c4bd15a8a9241e3b1e1f81d9fcd8d7bd5e1ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/688c4bd15a8a9241e3b1e1f81d9fcd8d7bd5e1ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a8431133e1d859fe6a168cc20288d48957d97fe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhCY+LCRBK7hj4Ov3rIwAABxkIAJ0IQcqv7FMpYbetKU6AtBwf\nbQO78GN9/eE2x5cjJUruLljuDUc6PK2hIwMldUT96a4U6tOx6Tw4lpEwp4LIVJVS\nPEuE1Rt1FoBk++L+T8VSKPubMsI+i4GcS8H8kvq8Mscz1D37P4FjTEGPBjJXECEL\n1mRR7r9JqaTMbzpagt4bKKQK6bfTbNXbseNaLf2r5O1hD0xSg9GTjJBTBKEYbFJz\nRnXQuwSajZGN10NbhWaa3AgE9hiMQrjA1W27yoImCqHu1veiqT/THiUYF/0e5sC8\ndrifmbinpgeQvVHmM6W76m7EQIlz/09XBL0Wsb4x5aIrRZurssYP9cvg5bAogQE=\n=W8i6\n-----END PGP SIGNATURE-----\n", "payload": "tree 688c4bd15a8a9241e3b1e1f81d9fcd8d7bd5e1ac\nparent 09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0\nparent 29c4ae6f9abd4648e8ad24061a0d8e6e05c5a163\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628016523 +0000\ncommitter GitHub <noreply@github.com> 1628016523 +0000\n\nMerge #9775\n\n9775: internal: extract_assist is aware of the expression owner r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a8431133e1d859fe6a168cc20288d48957d97fe", "html_url": "https://github.com/rust-lang/rust/commit/8a8431133e1d859fe6a168cc20288d48957d97fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a8431133e1d859fe6a168cc20288d48957d97fe/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0", "html_url": "https://github.com/rust-lang/rust/commit/09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0"}, {"sha": "29c4ae6f9abd4648e8ad24061a0d8e6e05c5a163", "url": "https://api.github.com/repos/rust-lang/rust/commits/29c4ae6f9abd4648e8ad24061a0d8e6e05c5a163", "html_url": "https://github.com/rust-lang/rust/commit/29c4ae6f9abd4648e8ad24061a0d8e6e05c5a163"}], "stats": {"total": 213, "additions": 114, "deletions": 99}, "files": [{"sha": "661ef6b7c41cb2e5a46335f9ce60639654c056ad", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a8431133e1d859fe6a168cc20288d48957d97fe/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8431133e1d859fe6a168cc20288d48957d97fe/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=8a8431133e1d859fe6a168cc20288d48957d97fe", "patch": "@@ -1391,8 +1391,13 @@ impl Const {\n         db.const_data(self.id).name.clone()\n     }\n \n-    pub fn type_ref(self, db: &dyn HirDatabase) -> TypeRef {\n-        db.const_data(self.id).type_ref.as_ref().clone()\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        let data = db.const_data(self.id);\n+        let resolver = self.id.resolver(db.upcast());\n+        let krate = self.id.lookup(db.upcast()).container.krate(db);\n+        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n+        let ty = ctx.lower_ty(&data.type_ref);\n+        Type::new_with_resolver_inner(db, krate.id, &resolver, ty)\n     }\n }\n \n@@ -1421,6 +1426,15 @@ impl Static {\n     pub fn is_mut(self, db: &dyn HirDatabase) -> bool {\n         db.static_data(self.id).mutable\n     }\n+\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        let data = db.static_data(self.id);\n+        let resolver = self.id.resolver(db.upcast());\n+        let krate = self.id.lookup(db.upcast()).container.krate();\n+        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n+        let ty = ctx.lower_ty(&data.type_ref);\n+        Type::new_with_resolver_inner(db, krate, &resolver, ty)\n+    }\n }\n \n impl HasVisibility for Static {"}, {"sha": "2ff1511f528e3187daa451ef9844908f5999da11", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 98, "deletions": 97, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/8a8431133e1d859fe6a168cc20288d48957d97fe/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8431133e1d859fe6a168cc20288d48957d97fe/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=8a8431133e1d859fe6a168cc20288d48957d97fe", "patch": "@@ -71,7 +71,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         syntax::NodeOrToken::Token(t) => t.parent()?,\n     };\n     let body = extraction_target(&node, range)?;\n-    let mods = body.analyze_container()?;\n+    let container_info = body.analyze_container(&ctx.sema)?;\n \n     let (locals_used, self_param) = body.analyze(&ctx.sema);\n \n@@ -80,7 +80,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     let module = ctx.sema.scope(&insert_after).module()?;\n \n     let ret_ty = body.return_ty(ctx)?;\n-    let control_flow = body.external_control_flow(ctx)?;\n+    let control_flow = body.external_control_flow(ctx, &container_info)?;\n     let ret_values = body.ret_values(ctx, node.parent().as_ref().unwrap_or(&node));\n \n     let target_range = body.text_range();\n@@ -93,7 +93,6 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n             let outliving_locals: Vec<_> = ret_values.collect();\n             if stdx::never!(!outliving_locals.is_empty() && !ret_ty.is_unit()) {\n                 // We should not have variables that outlive body if we have expression block\n-                stdx::never!();\n                 return;\n             }\n \n@@ -107,7 +106,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n                 ret_ty,\n                 body,\n                 outliving_locals,\n-                mods,\n+                mods: container_info,\n             };\n \n             let new_indent = IndentLevel::from_node(&insert_after);\n@@ -177,7 +176,7 @@ struct Function {\n     ret_ty: RetType,\n     body: FunctionBody,\n     outliving_locals: Vec<OutlivedLocal>,\n-    mods: Modifiers,\n+    mods: ContainerInfo,\n }\n \n #[derive(Debug)]\n@@ -213,16 +212,22 @@ enum Anchor {\n     Method,\n }\n \n+// FIXME: ControlFlow and ContainerInfo both track some function modifiers, feels like these two should\n+// probably be merged somehow.\n #[derive(Debug)]\n struct ControlFlow {\n     kind: Option<FlowKind>,\n     is_async: bool,\n+    is_unsafe: bool,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-struct Modifiers {\n+/// The thing whose expression we are extracting from. Can be a function, const, static, const arg, ...\n+#[derive(Clone, Debug)]\n+struct ContainerInfo {\n     is_const: bool,\n     is_in_tail: bool,\n+    /// The function's return type, const's type etc.\n+    ret_type: Option<hir::Type>,\n }\n \n /// Control flow that is exported from extracted function\n@@ -244,10 +249,6 @@ enum FlowKind {\n     Try {\n         kind: TryKind,\n     },\n-    TryReturn {\n-        expr: ast::Expr,\n-        kind: TryKind,\n-    },\n     /// Break with value (`break $expr;`)\n     Break(Option<ast::Expr>),\n     /// Continue\n@@ -295,7 +296,7 @@ struct OutlivedLocal {\n struct LocalUsages(ide_db::search::UsageSearchResult);\n \n impl LocalUsages {\n-    fn find(ctx: &AssistContext, var: Local) -> Self {\n+    fn find_local_usages(ctx: &AssistContext, var: Local) -> Self {\n         Self(\n             Definition::Local(var)\n                 .usages(&ctx.sema)\n@@ -395,7 +396,7 @@ impl FlowKind {\n         match self {\n             FlowKind::Return(_) => make::expr_return(expr),\n             FlowKind::Break(_) => make::expr_break(expr),\n-            FlowKind::Try { .. } | FlowKind::TryReturn { .. } => {\n+            FlowKind::Try { .. } => {\n                 stdx::never!(\"cannot have result handler with try\");\n                 expr.unwrap_or_else(|| make::expr_return(None))\n             }\n@@ -408,9 +409,7 @@ impl FlowKind {\n \n     fn expr_ty(&self, ctx: &AssistContext) -> Option<hir::Type> {\n         match self {\n-            FlowKind::Return(Some(expr))\n-            | FlowKind::Break(Some(expr))\n-            | FlowKind::TryReturn { expr, .. } => {\n+            FlowKind::Return(Some(expr)) | FlowKind::Break(Some(expr)) => {\n                 ctx.sema.type_of_expr(expr).map(TypeInfo::adjusted)\n             }\n             FlowKind::Try { .. } => {\n@@ -620,57 +619,58 @@ impl FunctionBody {\n         (res, self_param)\n     }\n \n-    fn analyze_container(&self) -> Option<Modifiers> {\n-        let mut is_const = false;\n-        let container_expr = self.parent()?.ancestors().find_map(|it| {\n-            // double Option as we want to short circuit\n-            let res = match_ast! {\n-                match it {\n-                    ast::ClosureExpr(closure) => closure.body(),\n+    fn analyze_container(&self, sema: &Semantics<RootDatabase>) -> Option<ContainerInfo> {\n+        let mut ancestors = self.parent()?.ancestors();\n+        let infer_expr_opt = |expr| sema.type_of_expr(&expr?).map(TypeInfo::adjusted);\n+        let (is_const, expr, ty) = loop {\n+            let anc = ancestors.next()?;\n+            break match_ast! {\n+                match anc {\n+                    ast::ClosureExpr(closure) => (false, closure.body(), infer_expr_opt(closure.body())),\n                     ast::EffectExpr(effect) => {\n-                        is_const = effect.const_token().is_some();\n-                        effect.block_expr().map(ast::Expr::BlockExpr)\n+                        let (constness, block) = match effect.effect() {\n+                            ast::Effect::Const(_) => (true, effect.block_expr()),\n+                            ast::Effect::Try(_) => (false, effect.block_expr()),\n+                            ast::Effect::Label(label) if label.lifetime().is_some() => (false, effect.block_expr()),\n+                            _ => continue,\n+                        };\n+                        let expr = block.map(ast::Expr::BlockExpr);\n+                        (constness, expr.clone(), infer_expr_opt(expr))\n                     },\n                     ast::Fn(fn_) => {\n-                        is_const = fn_.const_token().is_some();\n-                        fn_.body().map(ast::Expr::BlockExpr)\n+                        (fn_.const_token().is_some(), fn_.body().map(ast::Expr::BlockExpr), Some(sema.to_def(&fn_)?.ret_type(sema.db)))\n                     },\n                     ast::Static(statik) => {\n-                        is_const = true;\n-                        statik.body()\n+                        (true, statik.body(), Some(sema.to_def(&statik)?.ty(sema.db)))\n                     },\n                     ast::ConstArg(ca) => {\n-                        is_const = true;\n-                        ca.expr()\n+                        (true, ca.expr(), infer_expr_opt(ca.expr()))\n                     },\n                     ast::Const(konst) => {\n-                        is_const = true;\n-                        konst.body()\n+                        (true, konst.body(), Some(sema.to_def(&konst)?.ty(sema.db)))\n                     },\n                     ast::ConstParam(cp) => {\n-                        is_const = true;\n-                        cp.default_val()\n+                        (true, cp.default_val(), Some(sema.to_def(&cp)?.ty(sema.db)))\n                     },\n                     ast::ConstBlockPat(cbp) => {\n-                        is_const = true;\n-                        cbp.block_expr().map(ast::Expr::BlockExpr)\n+                        let expr = cbp.block_expr().map(ast::Expr::BlockExpr);\n+                        (true, expr.clone(), infer_expr_opt(expr))\n                     },\n-                    ast::Variant(__) => None,\n-                    ast::Meta(__) => None,\n-                    _ => return None,\n+                    ast::Variant(__) => return None,\n+                    ast::Meta(__) => return None,\n+                    _ => continue,\n                 }\n             };\n-            Some(res)\n-        })??;\n-        let container_tail = match container_expr {\n+        };\n+        let container_tail = match expr? {\n             ast::Expr::BlockExpr(block) => block.tail_expr(),\n             expr => Some(expr),\n         };\n         let is_in_tail =\n             container_tail.zip(self.tail_expr()).map_or(false, |(container_tail, body_tail)| {\n                 container_tail.syntax().text_range().contains_range(body_tail.syntax().text_range())\n             });\n-        Some(Modifiers { is_in_tail, is_const })\n+        Some(ContainerInfo { is_in_tail, is_const, ret_type: ty })\n     }\n \n     fn return_ty(&self, ctx: &AssistContext) -> Option<RetType> {\n@@ -694,30 +694,44 @@ impl FunctionBody {\n     }\n \n     /// Analyses the function body for external control flow.\n-    fn external_control_flow(&self, ctx: &AssistContext) -> Option<ControlFlow> {\n+    fn external_control_flow(\n+        &self,\n+        ctx: &AssistContext,\n+        container_info: &ContainerInfo,\n+    ) -> Option<ControlFlow> {\n         let mut ret_expr = None;\n         let mut try_expr = None;\n         let mut break_expr = None;\n         let mut continue_expr = None;\n         let mut is_async = false;\n+        let mut _is_unsafe = false;\n \n+        let mut unsafe_depth = 0;\n         let mut loop_depth = 0;\n \n         self.preorder_expr(&mut |expr| {\n             let expr = match expr {\n                 WalkEvent::Enter(e) => e,\n-                WalkEvent::Leave(\n-                    ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_),\n-                ) => {\n-                    loop_depth -= 1;\n+                WalkEvent::Leave(expr) => {\n+                    match expr {\n+                        ast::Expr::LoopExpr(_)\n+                        | ast::Expr::ForExpr(_)\n+                        | ast::Expr::WhileExpr(_) => loop_depth -= 1,\n+                        ast::Expr::EffectExpr(effect) if effect.unsafe_token().is_some() => {\n+                            unsafe_depth -= 1\n+                        }\n+                        _ => (),\n+                    }\n                     return false;\n                 }\n-                WalkEvent::Leave(_) => return false,\n             };\n             match expr {\n                 ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) => {\n                     loop_depth += 1;\n                 }\n+                ast::Expr::EffectExpr(effect) if effect.unsafe_token().is_some() => {\n+                    unsafe_depth += 1\n+                }\n                 ast::Expr::ReturnExpr(it) => {\n                     ret_expr = Some(it);\n                 }\n@@ -731,31 +745,21 @@ impl FunctionBody {\n                     continue_expr = Some(it);\n                 }\n                 ast::Expr::AwaitExpr(_) => is_async = true,\n+                // FIXME: Do unsafe analysis on expression, sem highlighting knows this so we should be able\n+                // to just lift that out of there\n+                // expr if unsafe_depth ==0 && expr.is_unsafe => is_unsafe = true,\n                 _ => {}\n             }\n             false\n         });\n \n         let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n-            (Some(e), None, None, None) => {\n-                let func = e.syntax().ancestors().find_map(ast::Fn::cast)?;\n-                let def = ctx.sema.to_def(&func)?;\n-                let ret_ty = def.ret_type(ctx.db());\n+            (Some(_), _, None, None) => {\n+                let ret_ty = container_info.ret_type.clone()?;\n                 let kind = TryKind::of_ty(ret_ty, ctx)?;\n \n                 Some(FlowKind::Try { kind })\n             }\n-            (Some(_), Some(r), None, None) => match r.expr() {\n-                Some(expr) => {\n-                    if let Some(kind) = expr_err_kind(&expr, ctx) {\n-                        Some(FlowKind::TryReturn { expr, kind })\n-                    } else {\n-                        cov_mark::hit!(external_control_flow_try_and_return_non_err);\n-                        return None;\n-                    }\n-                }\n-                None => return None,\n-            },\n             (Some(_), _, _, _) => {\n                 cov_mark::hit!(external_control_flow_try_and_bc);\n                 return None;\n@@ -774,7 +778,7 @@ impl FunctionBody {\n             (None, None, None, None) => None,\n         };\n \n-        Some(ControlFlow { kind, is_async })\n+        Some(ControlFlow { kind, is_async, is_unsafe: _is_unsafe })\n     }\n     /// find variables that should be extracted as params\n     ///\n@@ -796,7 +800,7 @@ impl FunctionBody {\n                 }\n             })\n             .map(|var| {\n-                let usages = LocalUsages::find(ctx, var);\n+                let usages = LocalUsages::find_local_usages(ctx, var);\n                 let ty = var.ty(ctx.db());\n                 let is_copy = ty.is_copy(ctx.db());\n                 Param {\n@@ -972,7 +976,7 @@ fn local_outlives_body(\n     local: Local,\n     parent: &SyntaxNode,\n ) -> Option<OutlivedLocal> {\n-    let usages = LocalUsages::find(ctx, local);\n+    let usages = LocalUsages::find_local_usages(ctx, local);\n     let mut has_mut_usages = false;\n     let mut any_outlives = false;\n     for usage in usages.iter() {\n@@ -1007,24 +1011,6 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n     }\n }\n \n-/// Checks is expr is `Err(_)` or `None`\n-fn expr_err_kind(expr: &ast::Expr, ctx: &AssistContext) -> Option<TryKind> {\n-    let func_name = match expr {\n-        ast::Expr::CallExpr(call_expr) => call_expr.expr()?,\n-        ast::Expr::PathExpr(_) => expr.clone(),\n-        _ => return None,\n-    };\n-    let text = func_name.syntax().text();\n-\n-    if text == \"Err\" {\n-        Some(TryKind::Result { ty: ctx.sema.type_of_expr(expr).map(TypeInfo::original)? })\n-    } else if text == \"None\" {\n-        Some(TryKind::Option)\n-    } else {\n-        None\n-    }\n-}\n-\n /// find where to put extracted function definition\n ///\n /// Function should be put right after returned node\n@@ -1133,9 +1119,7 @@ impl FlowHandler {\n                         FlowKind::Return(_) | FlowKind::Break(_) => {\n                             FlowHandler::IfOption { action }\n                         }\n-                        FlowKind::Try { kind } | FlowKind::TryReturn { kind, .. } => {\n-                            FlowHandler::Try { kind: kind.clone() }\n-                        }\n+                        FlowKind::Try { kind } => FlowHandler::Try { kind: kind.clone() },\n                     }\n                 } else {\n                     match flow_kind {\n@@ -1145,9 +1129,7 @@ impl FlowHandler {\n                         FlowKind::Return(_) | FlowKind::Break(_) => {\n                             FlowHandler::MatchResult { err: action }\n                         }\n-                        FlowKind::Try { kind } | FlowKind::TryReturn { kind, .. } => {\n-                            FlowHandler::Try { kind: kind.clone() }\n-                        }\n+                        FlowKind::Try { kind } => FlowHandler::Try { kind: kind.clone() },\n                     }\n                 }\n             }\n@@ -1241,22 +1223,25 @@ fn format_function(\n     let body = make_body(ctx, old_indent, new_indent, fun);\n     let const_kw = if fun.mods.is_const { \"const \" } else { \"\" };\n     let async_kw = if fun.control_flow.is_async { \"async \" } else { \"\" };\n+    let unsafe_kw = if fun.control_flow.is_unsafe { \"unsafe \" } else { \"\" };\n     match ctx.config.snippet_cap {\n         Some(_) => format_to!(\n             fn_def,\n-            \"\\n\\n{}{}{}fn $0{}{}\",\n+            \"\\n\\n{}{}{}{}fn $0{}{}\",\n             new_indent,\n             const_kw,\n             async_kw,\n+            unsafe_kw,\n             fun.name,\n             params\n         ),\n         None => format_to!(\n             fn_def,\n-            \"\\n\\n{}{}{}fn {}{}\",\n+            \"\\n\\n{}{}{}{}fn {}{}\",\n             new_indent,\n             const_kw,\n             async_kw,\n+            unsafe_kw,\n             fun.name,\n             params\n         ),\n@@ -1510,7 +1495,7 @@ fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode)\n             continue;\n         }\n \n-        let usages = LocalUsages::find(ctx, param.var);\n+        let usages = LocalUsages::find_local_usages(ctx, param.var);\n         let usages = usages\n             .iter()\n             .filter(|reference| syntax.text_range().contains_range(reference.range))\n@@ -3752,8 +3737,7 @@ fn foo() -> Option<()> {\n \n     #[test]\n     fn try_and_return_ok() {\n-        cov_mark::check!(external_control_flow_try_and_return_non_err);\n-        check_assist_not_applicable(\n+        check_assist(\n             extract_function,\n             r#\"\n //- minicore: result\n@@ -3767,6 +3751,23 @@ fn foo() -> Result<(), i64> {\n     let h = 1 + m;\n     Ok(())\n }\n+\"#,\n+            r#\"\n+fn foo() -> Result<(), i64> {\n+    let n = 1;\n+    let m = fun_name()?;\n+    let h = 1 + m;\n+    Ok(())\n+}\n+\n+fn $0fun_name() -> Result<i32, i64> {\n+    let k = foo()?;\n+    if k == 42 {\n+        return Ok(1);\n+    }\n+    let m = k + 1;\n+    Ok(m)\n+}\n \"#,\n         );\n     }"}]}