{"sha": "90904204d6218ecb4bdfb36015759ade77b10f4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwOTA0MjA0ZDYyMThlY2I0YmRmYjM2MDE1NzU5YWRlNzdiMTBmNGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-22T04:21:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-22T04:21:46Z"}, "message": "Auto merge of #27185 - pnkfelix:test-cyclic-collections, r=alexcrichton\n\nThis test attempts to exercise cyclic structure in much of `std::collections`\r\n\r\n(as much as is possible; e.g. things like `EnumSet` and `BitVec` do not really support carrying references at all, so trying to represent cyclic structure within them dooes not really make sense.)\r\n\r\nThis work should land before we make future revisions to `dropck`; that is, I am attempting to catch potential regressions to cases where we supported cyclic structure circa Rust 1.2.", "tree": {"sha": "9b572790ade6726bb3af5a8ec94317676c05ee77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b572790ade6726bb3af5a8ec94317676c05ee77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90904204d6218ecb4bdfb36015759ade77b10f4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90904204d6218ecb4bdfb36015759ade77b10f4b", "html_url": "https://github.com/rust-lang/rust/commit/90904204d6218ecb4bdfb36015759ade77b10f4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90904204d6218ecb4bdfb36015759ade77b10f4b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d33cab1b1fa4943a4bf37baa8c7421e672df10c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d33cab1b1fa4943a4bf37baa8c7421e672df10c7", "html_url": "https://github.com/rust-lang/rust/commit/d33cab1b1fa4943a4bf37baa8c7421e672df10c7"}, {"sha": "4128583939a71d48d0e9ec948516e039ead8117d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4128583939a71d48d0e9ec948516e039ead8117d", "html_url": "https://github.com/rust-lang/rust/commit/4128583939a71d48d0e9ec948516e039ead8117d"}], "stats": {"total": 759, "additions": 759, "deletions": 0}, "files": [{"sha": "b4f9b3f9458096746ef486cbe9d0bedc7f938fdb", "filename": "src/test/run-pass/dropck_legal_cycles.rs", "status": "added", "additions": 759, "deletions": 0, "changes": 759, "blob_url": "https://github.com/rust-lang/rust/blob/90904204d6218ecb4bdfb36015759ade77b10f4b/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90904204d6218ecb4bdfb36015759ade77b10f4b/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs?ref=90904204d6218ecb4bdfb36015759ade77b10f4b", "patch": "@@ -0,0 +1,759 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test exercises cases where cyclic structure is legal,\n+// including when the cycles go through data-structures such\n+// as `Vec` or `TypedArena`.\n+//\n+// The intent is to cover as many such cases as possible, ensuring\n+// that if the compiler did not complain circa Rust 1.x (1.2 as of\n+// this writing), then it will continue to not complain in the future.\n+//\n+// Note that while some of the tests are only exercising using the\n+// given collection as a \"backing store\" for a set of nodes that hold\n+// the actual cycle (and thus the cycle does not go through the\n+// collection itself in such cases), in general we *do* want to make\n+// sure to have at least one example exercising a cycle that goes\n+// through the collection, for every collection type that supports\n+// this.\n+\n+#![feature(vecmap)]\n+\n+use std::cell::Cell;\n+use std::cmp::Ordering;\n+use std::collections::BinaryHeap;\n+use std::collections::HashMap;\n+use std::collections::LinkedList;\n+use std::collections::VecDeque;\n+use std::collections::VecMap;\n+use std::collections::btree_map::BTreeMap;\n+use std::collections::btree_set::BTreeSet;\n+use std::hash::{Hash, Hasher};\n+\n+const PRINT: bool = false;\n+\n+pub fn main() {\n+    let c_orig = ContextData {\n+        curr_depth: 0,\n+        max_depth: 3,\n+        visited: 0,\n+        max_visits: 1000,\n+        skipped: 0,\n+        curr_mark: 0,\n+        saw_prev_marked: false,\n+    };\n+\n+    // Cycle 1: { v[0] -> v[1], v[1] -> v[0] };\n+    // does not exercise `v` itself\n+    let v: Vec<S> = vec![Named::new(\"s0\"),\n+                         Named::new(\"s1\")];\n+    v[0].next.set(Some(&v[1]));\n+    v[1].next.set(Some(&v[0]));\n+\n+    let mut c = c_orig.clone();\n+    c.curr_mark = 10;\n+    assert!(!c.saw_prev_marked);\n+    v[0].for_each_child(&mut c);\n+    assert!(c.saw_prev_marked);\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 2: { v[0] -> v, v[1] -> v }\n+    let v: V = Named::new(\"v\");\n+    v.contents[0].set(Some(&v));\n+    v.contents[1].set(Some(&v));\n+\n+    let mut c = c_orig.clone();\n+    c.curr_mark = 20;\n+    assert!(!c.saw_prev_marked);\n+    v.for_each_child(&mut c);\n+    assert!(c.saw_prev_marked);\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 3: { hk0 -> hv0, hv0 -> hk0, hk1 -> hv1, hv1 -> hk1 };\n+    // does not exercise `h` itself\n+\n+    let mut h: HashMap<H,H> = HashMap::new();\n+    h.insert(Named::new(\"hk0\"), Named::new(\"hv0\"));\n+    h.insert(Named::new(\"hk1\"), Named::new(\"hv1\"));\n+    for (key, val) in h.iter() {\n+        val.next.set(Some(key));\n+        key.next.set(Some(val));\n+    }\n+\n+    let mut c = c_orig.clone();\n+    c.curr_mark = 30;\n+    for (key, _) in h.iter() {\n+        c.curr_mark += 1;\n+        c.saw_prev_marked = false;\n+        key.for_each_child(&mut c);\n+        assert!(c.saw_prev_marked);\n+    }\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 4: { h -> (hmk0,hmv0,hmk1,hmv1), {hmk0,hmv0,hmk1,hmv1} -> h }\n+\n+    let mut h: HashMap<HM,HM> = HashMap::new();\n+    h.insert(Named::new(\"hmk0\"), Named::new(\"hmv0\"));\n+    h.insert(Named::new(\"hmk0\"), Named::new(\"hmv0\"));\n+    for (key, val) in h.iter() {\n+        val.contents.set(Some(&h));\n+        key.contents.set(Some(&h));\n+    }\n+\n+    let mut c = c_orig.clone();\n+    c.max_depth = 2;\n+    c.curr_mark = 40;\n+    for (key, _) in h.iter() {\n+        c.curr_mark += 1;\n+        c.saw_prev_marked = false;\n+        key.for_each_child(&mut c);\n+        assert!(c.saw_prev_marked);\n+        // break;\n+    }\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 5: { vd[0] -> vd[1], vd[1] -> vd[0] };\n+    // does not exercise vd itself\n+    let mut vd: VecDeque<S> = VecDeque::new();\n+    vd.push_back(Named::new(\"d0\"));\n+    vd.push_back(Named::new(\"d1\"));\n+    vd[0].next.set(Some(&vd[1]));\n+    vd[1].next.set(Some(&vd[0]));\n+\n+    let mut c = c_orig.clone();\n+    c.curr_mark = 50;\n+    assert!(!c.saw_prev_marked);\n+    vd[0].for_each_child(&mut c);\n+    assert!(c.saw_prev_marked);\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 6: { vd -> (vd0, vd1), {vd0, vd1} -> vd }\n+    let mut vd: VecDeque<VD> = VecDeque::new();\n+    vd.push_back(Named::new(\"vd0\"));\n+    vd.push_back(Named::new(\"vd1\"));\n+    vd[0].contents.set(Some(&vd));\n+    vd[1].contents.set(Some(&vd));\n+\n+    let mut c = c_orig.clone();\n+    c.curr_mark = 60;\n+    assert!(!c.saw_prev_marked);\n+    vd[0].for_each_child(&mut c);\n+    assert!(c.saw_prev_marked);\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 7: { vm -> (vm0, vm1), {vm0, vm1} -> vm }\n+    let mut vm: VecMap<VM> = VecMap::new();\n+    vm.insert(0, Named::new(\"vm0\"));\n+    vm.insert(1, Named::new(\"vm1\"));\n+    vm[0].contents.set(Some(&vm));\n+    vm[1].contents.set(Some(&vm));\n+\n+    let mut c = c_orig.clone();\n+    c.curr_mark = 70;\n+    assert!(!c.saw_prev_marked);\n+    vm[0].for_each_child(&mut c);\n+    assert!(c.saw_prev_marked);\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 8: { ll -> (ll0, ll1), {ll0, ll1} -> ll }\n+    let mut ll: LinkedList<LL> = LinkedList::new();\n+    ll.push_back(Named::new(\"ll0\"));\n+    ll.push_back(Named::new(\"ll1\"));\n+    for e in &ll {\n+        e.contents.set(Some(&ll));\n+    }\n+\n+    let mut c = c_orig.clone();\n+    c.curr_mark = 80;\n+    for e in &ll {\n+        c.curr_mark += 1;\n+        c.saw_prev_marked = false;\n+        e.for_each_child(&mut c);\n+        assert!(c.saw_prev_marked);\n+        // break;\n+    }\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 9: { bh -> (bh0, bh1), {bh0, bh1} -> bh }\n+    let mut bh: BinaryHeap<BH> = BinaryHeap::new();\n+    bh.push(Named::new(\"bh0\"));\n+    bh.push(Named::new(\"bh1\"));\n+    for b in bh.iter() {\n+        b.contents.set(Some(&bh));\n+    }\n+\n+    let mut c = c_orig.clone();\n+    c.curr_mark = 90;\n+    for b in &bh {\n+        c.curr_mark += 1;\n+        c.saw_prev_marked = false;\n+        b.for_each_child(&mut c);\n+        assert!(c.saw_prev_marked);\n+        // break;\n+    }\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 10: { btm -> (btk0, btv1), {bt0, bt1} -> btm }\n+    let mut btm: BTreeMap<BTM, BTM> = BTreeMap::new();\n+    btm.insert(Named::new(\"btk0\"), Named::new(\"btv0\"));\n+    btm.insert(Named::new(\"btk1\"), Named::new(\"btv1\"));\n+    for (k, v) in btm.iter() {\n+        k.contents.set(Some(&btm));\n+        v.contents.set(Some(&btm));\n+    }\n+\n+    let mut c = c_orig.clone();\n+    c.curr_mark = 100;\n+    for (k, _) in &btm {\n+        c.curr_mark += 1;\n+        c.saw_prev_marked = false;\n+        k.for_each_child(&mut c);\n+        assert!(c.saw_prev_marked);\n+        // break;\n+    }\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 10: { bts -> (bts0, bts1), {bts0, bts1} -> btm }\n+    let mut bts: BTreeSet<BTS> = BTreeSet::new();\n+    bts.insert(Named::new(\"bts0\"));\n+    bts.insert(Named::new(\"bts1\"));\n+    for v in bts.iter() {\n+        v.contents.set(Some(&bts));\n+    }\n+\n+    let mut c = c_orig.clone();\n+    c.curr_mark = 100;\n+    for b in &bts {\n+        c.curr_mark += 1;\n+        c.saw_prev_marked = false;\n+        b.for_each_child(&mut c);\n+        assert!(c.saw_prev_marked);\n+        // break;\n+    }\n+}\n+\n+trait Named {\n+    fn new(&'static str) -> Self;\n+    fn name(&self) -> &str;\n+}\n+\n+trait Marked<M> {\n+    fn mark(&self) -> M;\n+    fn set_mark(&self, mark: M);\n+}\n+\n+struct S<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    next: Cell<Option<&'a S<'a>>>,\n+}\n+\n+impl<'a> Named for S<'a> {\n+    fn new<'b>(name: &'static str) -> S<'b> {\n+        S { name: name, mark: Cell::new(0), next: Cell::new(None) }\n+    }\n+    fn name(&self) -> &str { self.name }\n+}\n+\n+impl<'a> Marked<u32> for S<'a> {\n+    fn mark(&self) -> u32 { self.mark.get() }\n+    fn set_mark(&self, mark: u32) { self.mark.set(mark); }\n+}\n+\n+struct V<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    contents: Vec<Cell<Option<&'a V<'a>>>>,\n+}\n+\n+impl<'a> Named for V<'a> {\n+    fn new<'b>(name: &'static str) -> V<'b> {\n+        V { name: name,\n+            mark: Cell::new(0),\n+            contents: vec![Cell::new(None), Cell::new(None)]\n+        }\n+    }\n+    fn name(&self) -> &str { self.name }\n+}\n+\n+impl<'a> Marked<u32> for V<'a> {\n+    fn mark(&self) -> u32 { self.mark.get() }\n+    fn set_mark(&self, mark: u32) { self.mark.set(mark); }\n+}\n+\n+#[derive(Eq)]\n+struct H<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    next: Cell<Option<&'a H<'a>>>,\n+}\n+\n+impl<'a> Named for H<'a> {\n+    fn new<'b>(name: &'static str) -> H<'b> {\n+        H { name: name, mark: Cell::new(0), next: Cell::new(None) }\n+    }\n+    fn name(&self) -> &str { self.name }\n+}\n+\n+impl<'a> Marked<u32> for H<'a> {\n+    fn mark(&self) -> u32 { self.mark.get() }\n+    fn set_mark(&self, mark: u32) { self.mark.set(mark); }\n+}\n+\n+impl<'a> PartialEq for H<'a> {\n+    fn eq(&self, rhs: &H<'a>) -> bool {\n+        self.name == rhs.name\n+    }\n+}\n+\n+impl<'a> Hash for H<'a> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.name.hash(state)\n+    }\n+}\n+\n+#[derive(Eq)]\n+struct HM<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    contents: Cell<Option<&'a HashMap<HM<'a>, HM<'a>>>>,\n+}\n+\n+impl<'a> Named for HM<'a> {\n+    fn new<'b>(name: &'static str) -> HM<'b> {\n+        HM { name: name,\n+             mark: Cell::new(0),\n+             contents: Cell::new(None)\n+        }\n+    }\n+    fn name(&self) -> &str { self.name }\n+}\n+\n+impl<'a> Marked<u32> for HM<'a> {\n+    fn mark(&self) -> u32 { self.mark.get() }\n+    fn set_mark(&self, mark: u32) { self.mark.set(mark); }\n+}\n+\n+impl<'a> PartialEq for HM<'a> {\n+    fn eq(&self, rhs: &HM<'a>) -> bool {\n+        self.name == rhs.name\n+    }\n+}\n+\n+impl<'a> Hash for HM<'a> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.name.hash(state)\n+    }\n+}\n+\n+\n+struct VD<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    contents: Cell<Option<&'a VecDeque<VD<'a>>>>,\n+}\n+\n+impl<'a> Named for VD<'a> {\n+    fn new<'b>(name: &'static str) -> VD<'b> {\n+        VD { name: name,\n+             mark: Cell::new(0),\n+             contents: Cell::new(None)\n+        }\n+    }\n+    fn name(&self) -> &str { self.name }\n+}\n+\n+impl<'a> Marked<u32> for VD<'a> {\n+    fn mark(&self) -> u32 { self.mark.get() }\n+    fn set_mark(&self, mark: u32) { self.mark.set(mark); }\n+}\n+\n+struct VM<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    contents: Cell<Option<&'a VecMap<VM<'a>>>>,\n+}\n+\n+impl<'a> Named for VM<'a> {\n+    fn new<'b>(name: &'static str) -> VM<'b> {\n+        VM { name: name,\n+             mark: Cell::new(0),\n+             contents: Cell::new(None)\n+        }\n+    }\n+    fn name(&self) -> &str { self.name }\n+}\n+\n+impl<'a> Marked<u32> for VM<'a> {\n+    fn mark(&self) -> u32 { self.mark.get() }\n+    fn set_mark(&self, mark: u32) { self.mark.set(mark); }\n+}\n+\n+struct LL<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    contents: Cell<Option<&'a LinkedList<LL<'a>>>>,\n+}\n+\n+impl<'a> Named for LL<'a> {\n+    fn new<'b>(name: &'static str) -> LL<'b> {\n+        LL { name: name,\n+             mark: Cell::new(0),\n+             contents: Cell::new(None)\n+        }\n+    }\n+    fn name(&self) -> &str { self.name }\n+}\n+\n+impl<'a> Marked<u32> for LL<'a> {\n+    fn mark(&self) -> u32 { self.mark.get() }\n+    fn set_mark(&self, mark: u32) { self.mark.set(mark); }\n+}\n+\n+struct BH<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    contents: Cell<Option<&'a BinaryHeap<BH<'a>>>>,\n+}\n+\n+impl<'a> Named for BH<'a> {\n+    fn new<'b>(name: &'static str) -> BH<'b> {\n+        BH { name: name,\n+             mark: Cell::new(0),\n+             contents: Cell::new(None)\n+        }\n+    }\n+    fn name(&self) -> &str { self.name }\n+}\n+\n+impl<'a> Marked<u32> for BH<'a> {\n+    fn mark(&self) -> u32 { self.mark.get() }\n+    fn set_mark(&self, mark: u32) { self.mark.set(mark); }\n+}\n+\n+impl<'a> Eq for BH<'a> { }\n+\n+impl<'a> PartialEq for BH<'a> {\n+    fn eq(&self, rhs: &BH<'a>) -> bool {\n+        self.name == rhs.name\n+    }\n+}\n+\n+impl<'a> PartialOrd for BH<'a> {\n+    fn partial_cmp(&self, rhs: &BH<'a>) -> Option<Ordering> {\n+        Some(self.cmp(rhs))\n+    }\n+}\n+\n+impl<'a> Ord for BH<'a> {\n+    fn cmp(&self, rhs: &BH<'a>) -> Ordering {\n+        self.name.cmp(rhs.name)\n+    }\n+}\n+\n+struct BTM<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    contents: Cell<Option<&'a BTreeMap<BTM<'a>, BTM<'a>>>>,\n+}\n+\n+impl<'a> Named for BTM<'a> {\n+    fn new<'b>(name: &'static str) -> BTM<'b> {\n+        BTM { name: name,\n+             mark: Cell::new(0),\n+             contents: Cell::new(None)\n+        }\n+    }\n+    fn name(&self) -> &str { self.name }\n+}\n+\n+impl<'a> Marked<u32> for BTM<'a> {\n+    fn mark(&self) -> u32 { self.mark.get() }\n+    fn set_mark(&self, mark: u32) { self.mark.set(mark); }\n+}\n+\n+impl<'a> Eq for BTM<'a> { }\n+\n+impl<'a> PartialEq for BTM<'a> {\n+    fn eq(&self, rhs: &BTM<'a>) -> bool {\n+        self.name == rhs.name\n+    }\n+}\n+\n+impl<'a> PartialOrd for BTM<'a> {\n+    fn partial_cmp(&self, rhs: &BTM<'a>) -> Option<Ordering> {\n+        Some(self.cmp(rhs))\n+    }\n+}\n+\n+impl<'a> Ord for BTM<'a> {\n+    fn cmp(&self, rhs: &BTM<'a>) -> Ordering {\n+        self.name.cmp(rhs.name)\n+    }\n+}\n+\n+struct BTS<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    contents: Cell<Option<&'a BTreeSet<BTS<'a>>>>,\n+}\n+\n+impl<'a> Named for BTS<'a> {\n+    fn new<'b>(name: &'static str) -> BTS<'b> {\n+        BTS { name: name,\n+             mark: Cell::new(0),\n+             contents: Cell::new(None)\n+        }\n+    }\n+    fn name(&self) -> &str { self.name }\n+}\n+\n+impl<'a> Marked<u32> for BTS<'a> {\n+    fn mark(&self) -> u32 { self.mark.get() }\n+    fn set_mark(&self, mark: u32) { self.mark.set(mark); }\n+}\n+\n+impl<'a> Eq for BTS<'a> { }\n+\n+impl<'a> PartialEq for BTS<'a> {\n+    fn eq(&self, rhs: &BTS<'a>) -> bool {\n+        self.name == rhs.name\n+    }\n+}\n+\n+impl<'a> PartialOrd for BTS<'a> {\n+    fn partial_cmp(&self, rhs: &BTS<'a>) -> Option<Ordering> {\n+        Some(self.cmp(rhs))\n+    }\n+}\n+\n+impl<'a> Ord for BTS<'a> {\n+    fn cmp(&self, rhs: &BTS<'a>) -> Ordering {\n+        self.name.cmp(rhs.name)\n+    }\n+}\n+\n+\n+trait Context {\n+    fn should_act(&self) -> bool;\n+    fn increase_visited(&mut self);\n+    fn increase_skipped(&mut self);\n+    fn increase_depth(&mut self);\n+    fn decrease_depth(&mut self);\n+}\n+\n+trait PrePost<T> {\n+    fn pre(&mut self, &T);\n+    fn post(&mut self, &T);\n+    fn hit_limit(&mut self, &T);\n+}\n+\n+trait Children<'a> {\n+    fn for_each_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<Self>, Self: Sized;\n+\n+    fn descend_into_self<C>(&self, context: &mut C)\n+        where C: Context + PrePost<Self>, Self: Sized\n+    {\n+        context.pre(self);\n+        if context.should_act() {\n+            context.increase_visited();\n+            context.increase_depth();\n+            self.for_each_child(context);\n+            context.decrease_depth();\n+        } else {\n+            context.hit_limit(self);\n+            context.increase_skipped();\n+        }\n+        context.post(self);\n+    }\n+\n+    fn descend<'b, C>(&self, c: &Cell<Option<&'b Self>>, context: &mut C)\n+        where C: Context + PrePost<Self>, Self: Sized\n+    {\n+        if let Some(r) = c.get() {\n+            r.descend_into_self(context);\n+        }\n+    }\n+}\n+\n+impl<'a> Children<'a> for S<'a> {\n+    fn for_each_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<S<'a>>\n+    {\n+        self.descend(&self.next, context);\n+    }\n+}\n+\n+impl<'a> Children<'a> for V<'a> {\n+    fn for_each_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<V<'a>>\n+    {\n+        for r in &self.contents {\n+            self.descend(r, context);\n+        }\n+    }\n+}\n+\n+impl<'a> Children<'a> for H<'a> {\n+    fn for_each_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<H<'a>>\n+    {\n+        self.descend(&self.next, context);\n+    }\n+}\n+\n+impl<'a> Children<'a> for HM<'a> {\n+    fn for_each_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<HM<'a>>\n+    {\n+        if let Some(ref hm) = self.contents.get() {\n+            for (k, v) in hm.iter() {\n+                for r in &[k, v] {\n+                    r.descend_into_self(context);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Children<'a> for VD<'a> {\n+    fn for_each_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<VD<'a>>\n+    {\n+        if let Some(ref vd) = self.contents.get() {\n+            for r in vd.iter() {\n+                r.descend_into_self(context);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Children<'a> for VM<'a> {\n+    fn for_each_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<VM<'a>>\n+    {\n+        if let Some(ref vd) = self.contents.get() {\n+            for (_idx, r) in vd.iter() {\n+                r.descend_into_self(context);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Children<'a> for LL<'a> {\n+    fn for_each_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<LL<'a>>\n+    {\n+        if let Some(ref ll) = self.contents.get() {\n+            for r in ll.iter() {\n+                r.descend_into_self(context);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Children<'a> for BH<'a> {\n+    fn for_each_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<BH<'a>>\n+    {\n+        if let Some(ref bh) = self.contents.get() {\n+            for r in bh.iter() {\n+                r.descend_into_self(context);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Children<'a> for BTM<'a> {\n+    fn for_each_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<BTM<'a>>\n+    {\n+        if let Some(ref bh) = self.contents.get() {\n+            for (k, v) in bh.iter() {\n+                for r in &[k, v] {\n+                    r.descend_into_self(context);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Children<'a> for BTS<'a> {\n+    fn for_each_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<BTS<'a>>\n+    {\n+        if let Some(ref bh) = self.contents.get() {\n+            for r in bh.iter() {\n+                r.descend_into_self(context);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+struct ContextData {\n+    curr_depth: usize,\n+    max_depth: usize,\n+    visited: usize,\n+    max_visits: usize,\n+    skipped: usize,\n+    curr_mark: u32,\n+    saw_prev_marked: bool,\n+}\n+\n+impl Context for ContextData {\n+    fn should_act(&self) -> bool {\n+        self.curr_depth < self.max_depth && self.visited < self.max_visits\n+    }\n+    fn increase_visited(&mut self) { self.visited += 1; }\n+    fn increase_skipped(&mut self) { self.skipped += 1; }\n+    fn increase_depth(&mut self) {  self.curr_depth += 1; }\n+    fn decrease_depth(&mut self) {  self.curr_depth -= 1; }\n+}\n+\n+impl<T:Named+Marked<u32>> PrePost<T> for ContextData {\n+    fn pre(&mut self, t: &T) {\n+        for _ in 0..self.curr_depth {\n+            if PRINT { print!(\" \"); }\n+        }\n+        if PRINT { println!(\"prev {}\", t.name()); }\n+        if t.mark() == self.curr_mark {\n+            for _ in 0..self.curr_depth {\n+                if PRINT { print!(\" \"); }\n+            }\n+            if PRINT { println!(\"(probably previously marked)\"); }\n+            self.saw_prev_marked = true;\n+        }\n+        t.set_mark(self.curr_mark);\n+    }\n+    fn post(&mut self, t: &T) {\n+        for _ in 0..self.curr_depth {\n+            if PRINT { print!(\" \"); }\n+        }\n+        if PRINT { println!(\"post {}\", t.name()); }\n+    }\n+    fn hit_limit(&mut self, t: &T) {\n+        for _ in 0..self.curr_depth {\n+            if PRINT { print!(\" \"); }\n+        }\n+        if PRINT { println!(\"LIMIT {}\", t.name()); }\n+    }\n+}"}]}