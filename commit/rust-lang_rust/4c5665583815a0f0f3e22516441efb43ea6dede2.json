{"sha": "4c5665583815a0f0f3e22516441efb43ea6dede2", "node_id": "C_kwDOAAsO6NoAKDRjNTY2NTU4MzgxNWEwZjBmM2UyMjUxNjQ0MWVmYjQzZWE2ZGVkZTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-14T12:06:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-14T12:06:50Z"}, "message": "Auto merge of #100525 - Dylan-DPC:rollup-4cp6nu0, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #99582 (Delay a span bug if we see ty/const generic params during writeback)\n - #99861 (orphan check: rationalize our handling of constants)\n - #100026 (Add `Iterator::array_chunks` (take N+1))\n - #100115 (Suggest removing `let` if `const let` or `let const` is used)\n - #100126 (rustc_target: Update some old naming around self contained linking)\n - #100487 (`assert_{inhabited,zero_valid,uninit_valid}` intrinsics are safe)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d63a94dc1432882fa5856a412d0c28d40e978cfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d63a94dc1432882fa5856a412d0c28d40e978cfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c5665583815a0f0f3e22516441efb43ea6dede2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c5665583815a0f0f3e22516441efb43ea6dede2", "html_url": "https://github.com/rust-lang/rust/commit/4c5665583815a0f0f3e22516441efb43ea6dede2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c5665583815a0f0f3e22516441efb43ea6dede2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fbc08e2ce64dee45a29cb6133da6b32366268aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fbc08e2ce64dee45a29cb6133da6b32366268aa", "html_url": "https://github.com/rust-lang/rust/commit/2fbc08e2ce64dee45a29cb6133da6b32366268aa"}, {"sha": "9de9786ef84f09b367d99bcce6e59a4ed75acd64", "url": "https://api.github.com/repos/rust-lang/rust/commits/9de9786ef84f09b367d99bcce6e59a4ed75acd64", "html_url": "https://github.com/rust-lang/rust/commit/9de9786ef84f09b367d99bcce6e59a4ed75acd64"}], "stats": {"total": 767, "additions": 673, "deletions": 94}, "files": [{"sha": "7f6947e3c79d8c9b33554f82c0de64ceb5df59d1", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -20,7 +20,7 @@ use rustc_session::utils::NativeLibKind;\n use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n use rustc_span::DebuggerVisualizerFile;\n-use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n+use rustc_target::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n \n@@ -764,15 +764,15 @@ fn link_natively<'a>(\n                 \"Linker does not support -static-pie command line option. Retrying with -static instead.\"\n             );\n             // Mirror `add_(pre,post)_link_objects` to replace CRT objects.\n-            let self_contained = crt_objects_fallback(sess, crate_type);\n+            let self_contained = self_contained(sess, crate_type);\n             let opts = &sess.target;\n             let pre_objects = if self_contained {\n-                &opts.pre_link_objects_fallback\n+                &opts.pre_link_objects_self_contained\n             } else {\n                 &opts.pre_link_objects\n             };\n             let post_objects = if self_contained {\n-                &opts.post_link_objects_fallback\n+                &opts.post_link_objects_self_contained\n             } else {\n                 &opts.post_link_objects\n             };\n@@ -1556,26 +1556,26 @@ fn detect_self_contained_mingw(sess: &Session) -> bool {\n     true\n }\n \n-/// Whether we link to our own CRT objects instead of relying on gcc to pull them.\n+/// Various toolchain components used during linking are used from rustc distribution\n+/// instead of being found somewhere on the host system.\n /// We only provide such support for a very limited number of targets.\n-fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n+fn self_contained(sess: &Session, crate_type: CrateType) -> bool {\n     if let Some(self_contained) = sess.opts.cg.link_self_contained {\n         return self_contained;\n     }\n \n-    match sess.target.crt_objects_fallback {\n+    match sess.target.link_self_contained {\n+        LinkSelfContainedDefault::False => false,\n+        LinkSelfContainedDefault::True => true,\n         // FIXME: Find a better heuristic for \"native musl toolchain is available\",\n         // based on host and linker path, for example.\n         // (https://github.com/rust-lang/rust/pull/71769#issuecomment-626330237).\n-        Some(CrtObjectsFallback::Musl) => sess.crt_static(Some(crate_type)),\n-        Some(CrtObjectsFallback::Mingw) => {\n+        LinkSelfContainedDefault::Musl => sess.crt_static(Some(crate_type)),\n+        LinkSelfContainedDefault::Mingw => {\n             sess.host == sess.target\n                 && sess.target.vendor != \"uwp\"\n                 && detect_self_contained_mingw(&sess)\n         }\n-        // FIXME: Figure out cases in which WASM needs to link with a native toolchain.\n-        Some(CrtObjectsFallback::Wasm) => true,\n-        None => false,\n     }\n }\n \n@@ -1592,7 +1592,7 @@ fn add_pre_link_objects(\n     let opts = &sess.target;\n     let empty = Default::default();\n     let objects = if self_contained {\n-        &opts.pre_link_objects_fallback\n+        &opts.pre_link_objects_self_contained\n     } else if !(sess.target.os == \"fuchsia\" && flavor == LinkerFlavor::Gcc) {\n         &opts.pre_link_objects\n     } else {\n@@ -1610,9 +1610,11 @@ fn add_post_link_objects(\n     link_output_kind: LinkOutputKind,\n     self_contained: bool,\n ) {\n-    let opts = &sess.target;\n-    let objects =\n-        if self_contained { &opts.post_link_objects_fallback } else { &opts.post_link_objects };\n+    let objects = if self_contained {\n+        &sess.target.post_link_objects_self_contained\n+    } else {\n+        &sess.target.post_link_objects\n+    };\n     for obj in objects.get(&link_output_kind).iter().copied().flatten() {\n         cmd.add_object(&get_object_file_path(sess, obj, self_contained));\n     }\n@@ -1891,12 +1893,12 @@ fn linker_with_args<'a>(\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n ) -> Result<Command, ErrorGuaranteed> {\n-    let crt_objects_fallback = crt_objects_fallback(sess, crate_type);\n+    let self_contained = self_contained(sess, crate_type);\n     let cmd = &mut *super::linker::get_linker(\n         sess,\n         path,\n         flavor,\n-        crt_objects_fallback,\n+        self_contained,\n         &codegen_results.crate_info.target_cpu,\n     );\n     let link_output_kind = link_output_kind(sess, crate_type);\n@@ -1923,7 +1925,7 @@ fn linker_with_args<'a>(\n     // ------------ Object code and libraries, order-dependent ------------\n \n     // Pre-link CRT objects.\n-    add_pre_link_objects(cmd, sess, flavor, link_output_kind, crt_objects_fallback);\n+    add_pre_link_objects(cmd, sess, flavor, link_output_kind, self_contained);\n \n     add_linked_symbol_object(\n         cmd,\n@@ -2033,7 +2035,7 @@ fn linker_with_args<'a>(\n         cmd,\n         sess,\n         link_output_kind,\n-        crt_objects_fallback,\n+        self_contained,\n         flavor,\n         crate_type,\n         codegen_results,\n@@ -2049,7 +2051,7 @@ fn linker_with_args<'a>(\n     // ------------ Object code and libraries, order-dependent ------------\n \n     // Post-link CRT objects.\n-    add_post_link_objects(cmd, sess, link_output_kind, crt_objects_fallback);\n+    add_post_link_objects(cmd, sess, link_output_kind, self_contained);\n \n     // ------------ Late order-dependent options ------------\n \n@@ -2066,7 +2068,7 @@ fn add_order_independent_options(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     link_output_kind: LinkOutputKind,\n-    crt_objects_fallback: bool,\n+    self_contained: bool,\n     flavor: LinkerFlavor,\n     crate_type: CrateType,\n     codegen_results: &CodegenResults,\n@@ -2098,7 +2100,7 @@ fn add_order_independent_options(\n     // Make the binary compatible with data execution prevention schemes.\n     cmd.add_no_exec();\n \n-    if crt_objects_fallback {\n+    if self_contained {\n         cmd.no_crt_objects();\n     }\n \n@@ -2127,7 +2129,7 @@ fn add_order_independent_options(\n \n     cmd.linker_plugin_lto();\n \n-    add_library_search_dirs(cmd, sess, crt_objects_fallback);\n+    add_library_search_dirs(cmd, sess, self_contained);\n \n     cmd.output_filename(out_filename);\n "}, {"sha": "83fab0829a106d4a3348db1a91238660dd877bed", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -1162,6 +1162,16 @@ impl<'a> Parser<'a> {\n                     Applicability::MaybeIncorrect,\n                 )\n                 .emit();\n+        } else if self.eat_keyword(kw::Let) {\n+            let span = self.prev_token.span;\n+            self.struct_span_err(const_span.to(span), \"`const` and `let` are mutually exclusive\")\n+                .span_suggestion(\n+                    const_span.to(span),\n+                    \"remove `let`\",\n+                    \"const\",\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .emit();\n         }\n     }\n "}, {"sha": "6990d0782b772925dc25f350426d86dbf395c0b7", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -247,6 +247,22 @@ impl<'a> Parser<'a> {\n     /// Parses a local variable declaration.\n     fn parse_local(&mut self, attrs: AttrVec) -> PResult<'a, P<Local>> {\n         let lo = self.prev_token.span;\n+\n+        if self.token.is_keyword(kw::Const) && self.look_ahead(1, |t| t.is_ident()) {\n+            self.struct_span_err(\n+                lo.to(self.token.span),\n+                \"`const` and `let` are mutually exclusive\",\n+            )\n+            .span_suggestion(\n+                lo.to(self.token.span),\n+                \"remove `let`\",\n+                \"const\",\n+                Applicability::MaybeIncorrect,\n+            )\n+            .emit();\n+            self.bump();\n+        }\n+\n         let (pat, colon) = self.parse_pat_before_ty(None, RecoverComma::Yes, \"`let` bindings\")?;\n \n         let (err, ty) = if colon {"}, {"sha": "c126390f5a908dd80234871252ce842168ba5b47", "filename": "compiler/rustc_target/src/spec/crt_objects.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fcrt_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fcrt_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fcrt_objects.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -63,7 +63,7 @@ pub(super) fn all(obj: &'static str) -> CrtObjects {\n     ])\n }\n \n-pub(super) fn pre_musl_fallback() -> CrtObjects {\n+pub(super) fn pre_musl_self_contained() -> CrtObjects {\n     new(&[\n         (LinkOutputKind::DynamicNoPicExe, &[\"crt1.o\", \"crti.o\", \"crtbegin.o\"]),\n         (LinkOutputKind::DynamicPicExe, &[\"Scrt1.o\", \"crti.o\", \"crtbeginS.o\"]),\n@@ -74,7 +74,7 @@ pub(super) fn pre_musl_fallback() -> CrtObjects {\n     ])\n }\n \n-pub(super) fn post_musl_fallback() -> CrtObjects {\n+pub(super) fn post_musl_self_contained() -> CrtObjects {\n     new(&[\n         (LinkOutputKind::DynamicNoPicExe, &[\"crtend.o\", \"crtn.o\"]),\n         (LinkOutputKind::DynamicPicExe, &[\"crtendS.o\", \"crtn.o\"]),\n@@ -85,7 +85,7 @@ pub(super) fn post_musl_fallback() -> CrtObjects {\n     ])\n }\n \n-pub(super) fn pre_mingw_fallback() -> CrtObjects {\n+pub(super) fn pre_mingw_self_contained() -> CrtObjects {\n     new(&[\n         (LinkOutputKind::DynamicNoPicExe, &[\"crt2.o\", \"rsbegin.o\"]),\n         (LinkOutputKind::DynamicPicExe, &[\"crt2.o\", \"rsbegin.o\"]),\n@@ -96,7 +96,7 @@ pub(super) fn pre_mingw_fallback() -> CrtObjects {\n     ])\n }\n \n-pub(super) fn post_mingw_fallback() -> CrtObjects {\n+pub(super) fn post_mingw_self_contained() -> CrtObjects {\n     all(\"rsend.o\")\n }\n \n@@ -108,7 +108,7 @@ pub(super) fn post_mingw() -> CrtObjects {\n     all(\"rsend.o\")\n }\n \n-pub(super) fn pre_wasi_fallback() -> CrtObjects {\n+pub(super) fn pre_wasi_self_contained() -> CrtObjects {\n     // Use crt1-command.o instead of crt1.o to enable support for new-style\n     // commands. See https://reviews.llvm.org/D81689 for more info.\n     new(&[\n@@ -120,37 +120,41 @@ pub(super) fn pre_wasi_fallback() -> CrtObjects {\n     ])\n }\n \n-pub(super) fn post_wasi_fallback() -> CrtObjects {\n+pub(super) fn post_wasi_self_contained() -> CrtObjects {\n     new(&[])\n }\n \n-/// Which logic to use to determine whether to fall back to the \"self-contained\" mode or not.\n+/// Which logic to use to determine whether to use self-contained linking mode\n+/// if `-Clink-self-contained` is not specified explicitly.\n #[derive(Clone, Copy, PartialEq, Hash, Debug)]\n-pub enum CrtObjectsFallback {\n+pub enum LinkSelfContainedDefault {\n+    False,\n+    True,\n     Musl,\n     Mingw,\n-    Wasm,\n }\n \n-impl FromStr for CrtObjectsFallback {\n+impl FromStr for LinkSelfContainedDefault {\n     type Err = ();\n \n-    fn from_str(s: &str) -> Result<CrtObjectsFallback, ()> {\n+    fn from_str(s: &str) -> Result<LinkSelfContainedDefault, ()> {\n         Ok(match s {\n-            \"musl\" => CrtObjectsFallback::Musl,\n-            \"mingw\" => CrtObjectsFallback::Mingw,\n-            \"wasm\" => CrtObjectsFallback::Wasm,\n+            \"false\" => LinkSelfContainedDefault::False,\n+            \"true\" | \"wasm\" => LinkSelfContainedDefault::True,\n+            \"musl\" => LinkSelfContainedDefault::Musl,\n+            \"mingw\" => LinkSelfContainedDefault::Mingw,\n             _ => return Err(()),\n         })\n     }\n }\n \n-impl ToJson for CrtObjectsFallback {\n+impl ToJson for LinkSelfContainedDefault {\n     fn to_json(&self) -> Json {\n         match *self {\n-            CrtObjectsFallback::Musl => \"musl\",\n-            CrtObjectsFallback::Mingw => \"mingw\",\n-            CrtObjectsFallback::Wasm => \"wasm\",\n+            LinkSelfContainedDefault::False => \"false\",\n+            LinkSelfContainedDefault::True => \"true\",\n+            LinkSelfContainedDefault::Musl => \"musl\",\n+            LinkSelfContainedDefault::Mingw => \"mingw\",\n         }\n         .to_json()\n     }"}, {"sha": "61553e71b4500ae4dea3910a6910bf57e9524bf1", "filename": "compiler/rustc_target/src/spec/linux_musl_base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_musl_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_musl_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_musl_base.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -1,13 +1,13 @@\n-use crate::spec::crt_objects::{self, CrtObjectsFallback};\n+use crate::spec::crt_objects::{self, LinkSelfContainedDefault};\n use crate::spec::TargetOptions;\n \n pub fn opts() -> TargetOptions {\n     let mut base = super::linux_base::opts();\n \n     base.env = \"musl\".into();\n-    base.pre_link_objects_fallback = crt_objects::pre_musl_fallback();\n-    base.post_link_objects_fallback = crt_objects::post_musl_fallback();\n-    base.crt_objects_fallback = Some(CrtObjectsFallback::Musl);\n+    base.pre_link_objects_self_contained = crt_objects::pre_musl_self_contained();\n+    base.post_link_objects_self_contained = crt_objects::post_musl_self_contained();\n+    base.link_self_contained = LinkSelfContainedDefault::Musl;\n \n     // These targets statically link libc by default\n     base.crt_static_default = true;"}, {"sha": "0b49edc232c06afc2aa77e6b9ba53a5adba8b4e5", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -37,7 +37,7 @@\n use crate::abi::Endian;\n use crate::json::{Json, ToJson};\n use crate::spec::abi::{lookup as lookup_abi, Abi};\n-use crate::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n+use crate::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::symbol::{sym, Symbol};\n@@ -1172,13 +1172,10 @@ pub struct TargetOptions {\n     /// Objects to link before and after all other object code.\n     pub pre_link_objects: CrtObjects,\n     pub post_link_objects: CrtObjects,\n-    /// Same as `(pre|post)_link_objects`, but when we fail to pull the objects with help of the\n-    /// target's native gcc and fall back to the \"self-contained\" mode and pull them manually.\n-    /// See `crt_objects.rs` for some more detailed documentation.\n-    pub pre_link_objects_fallback: CrtObjects,\n-    pub post_link_objects_fallback: CrtObjects,\n-    /// Which logic to use to determine whether to fall back to the \"self-contained\" mode or not.\n-    pub crt_objects_fallback: Option<CrtObjectsFallback>,\n+    /// Same as `(pre|post)_link_objects`, but when self-contained linking mode is enabled.\n+    pub pre_link_objects_self_contained: CrtObjects,\n+    pub post_link_objects_self_contained: CrtObjects,\n+    pub link_self_contained: LinkSelfContainedDefault,\n \n     /// Linker arguments that are unconditionally passed after any\n     /// user-defined but before post-link objects. Standard platform\n@@ -1554,9 +1551,9 @@ impl Default for TargetOptions {\n             relro_level: RelroLevel::None,\n             pre_link_objects: Default::default(),\n             post_link_objects: Default::default(),\n-            pre_link_objects_fallback: Default::default(),\n-            post_link_objects_fallback: Default::default(),\n-            crt_objects_fallback: None,\n+            pre_link_objects_self_contained: Default::default(),\n+            post_link_objects_self_contained: Default::default(),\n+            link_self_contained: LinkSelfContainedDefault::False,\n             late_link_args: LinkArgs::new(),\n             late_link_args_dynamic: LinkArgs::new(),\n             late_link_args_static: LinkArgs::new(),\n@@ -1977,20 +1974,20 @@ impl Target {\n                 Ok::<(), String>(())\n             } );\n \n-            ($key_name:ident, crt_objects_fallback) => ( {\n-                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.remove(&name).and_then(|o| o.as_str().and_then(|s| {\n-                    match s.parse::<CrtObjectsFallback>() {\n-                        Ok(fallback) => base.$key_name = Some(fallback),\n-                        _ => return Some(Err(format!(\"'{}' is not a valid CRT objects fallback. \\\n-                                                      Use 'musl', 'mingw' or 'wasm'\", s))),\n+            ($key_name:ident = $json_name:expr, link_self_contained) => ( {\n+                let name = $json_name;\n+                obj.remove(name).and_then(|o| o.as_str().and_then(|s| {\n+                    match s.parse::<LinkSelfContainedDefault>() {\n+                        Ok(lsc_default) => base.$key_name = lsc_default,\n+                        _ => return Some(Err(format!(\"'{}' is not a valid `-Clink-self-contained` default. \\\n+                                                      Use 'false', 'true', 'musl' or 'mingw'\", s))),\n                     }\n                     Some(Ok(()))\n                 })).unwrap_or(Ok(()))\n             } );\n-            ($key_name:ident, link_objects) => ( {\n-                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(val) = obj.remove(&name) {\n+            ($key_name:ident = $json_name:expr, link_objects) => ( {\n+                let name = $json_name;\n+                if let Some(val) = obj.remove(name) {\n                     let obj = val.as_object().ok_or_else(|| format!(\"{}: expected a \\\n                         JSON object with fields per CRT object kind.\", name))?;\n                     let mut args = CrtObjects::new();\n@@ -2112,11 +2109,11 @@ impl Target {\n         key!(linker_flavor, LinkerFlavor)?;\n         key!(linker, optional);\n         key!(lld_flavor, LldFlavor)?;\n-        key!(pre_link_objects, link_objects);\n-        key!(post_link_objects, link_objects);\n-        key!(pre_link_objects_fallback, link_objects);\n-        key!(post_link_objects_fallback, link_objects);\n-        key!(crt_objects_fallback, crt_objects_fallback)?;\n+        key!(pre_link_objects = \"pre-link-objects\", link_objects);\n+        key!(post_link_objects = \"post-link-objects\", link_objects);\n+        key!(pre_link_objects_self_contained = \"pre-link-objects-fallback\", link_objects);\n+        key!(post_link_objects_self_contained = \"post-link-objects-fallback\", link_objects);\n+        key!(link_self_contained = \"crt-objects-fallback\", link_self_contained)?;\n         key!(pre_link_args, link_args);\n         key!(late_link_args, link_args);\n         key!(late_link_args_dynamic, link_args);\n@@ -2357,9 +2354,9 @@ impl ToJson for Target {\n         target_option_val!(lld_flavor);\n         target_option_val!(pre_link_objects);\n         target_option_val!(post_link_objects);\n-        target_option_val!(pre_link_objects_fallback);\n-        target_option_val!(post_link_objects_fallback);\n-        target_option_val!(crt_objects_fallback);\n+        target_option_val!(pre_link_objects_self_contained, \"pre-link-objects-fallback\");\n+        target_option_val!(post_link_objects_self_contained, \"post-link-objects-fallback\");\n+        target_option_val!(link_self_contained, \"crt-objects-fallback\");\n         target_option_val!(link_args - pre_link_args);\n         target_option_val!(link_args - late_link_args);\n         target_option_val!(link_args - late_link_args_dynamic);"}, {"sha": "03e579aee0a96f042c7188a704c10d54cfb608f4", "filename": "compiler/rustc_target/src/spec/tests/tests_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -110,9 +110,9 @@ impl Target {\n         }\n \n         assert!(\n-            (self.pre_link_objects_fallback.is_empty()\n-                && self.post_link_objects_fallback.is_empty())\n-                || self.crt_objects_fallback.is_some()\n+            (self.pre_link_objects_self_contained.is_empty()\n+                && self.post_link_objects_self_contained.is_empty())\n+                || self.link_self_contained != LinkSelfContainedDefault::False\n         );\n \n         // If your target really needs to deviate from the rules below,"}, {"sha": "9c30487f4abe796debeffff725252b07b49a4ce4", "filename": "compiler/rustc_target/src/spec/wasm32_wasi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_wasi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_wasi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_wasi.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -82,8 +82,8 @@ pub fn target() -> Target {\n     options.linker_flavor = LinkerFlavor::Lld(LldFlavor::Wasm);\n     options.add_pre_link_args(LinkerFlavor::Gcc, &[\"--target=wasm32-wasi\"]);\n \n-    options.pre_link_objects_fallback = crt_objects::pre_wasi_fallback();\n-    options.post_link_objects_fallback = crt_objects::post_wasi_fallback();\n+    options.pre_link_objects_self_contained = crt_objects::pre_wasi_self_contained();\n+    options.post_link_objects_self_contained = crt_objects::post_wasi_self_contained();\n \n     // Right now this is a bit of a workaround but we're currently saying that\n     // the target by default has a static crt which we're taking as a signal"}, {"sha": "28a07701eae74ec2bb2b2b3ca9e0d07a4535f5f7", "filename": "compiler/rustc_target/src/spec/wasm_base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -1,4 +1,4 @@\n-use super::crt_objects::CrtObjectsFallback;\n+use super::crt_objects::LinkSelfContainedDefault;\n use super::{cvs, LinkerFlavor, LldFlavor, PanicStrategy, RelocModel, TargetOptions, TlsModel};\n \n pub fn options() -> TargetOptions {\n@@ -96,7 +96,8 @@ pub fn options() -> TargetOptions {\n \n         pre_link_args,\n \n-        crt_objects_fallback: Some(CrtObjectsFallback::Wasm),\n+        // FIXME: Figure out cases in which WASM needs to link with a native toolchain.\n+        link_self_contained: LinkSelfContainedDefault::True,\n \n         // This has no effect in LLVM 8 or prior, but in LLVM 9 and later when\n         // PIC code is implemented this has quite a drastic effect if it stays"}, {"sha": "0107f7a52c6ffebc0e2f04e5c1b5215f989e0c70", "filename": "compiler/rustc_target/src/spec/windows_gnu_base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnu_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnu_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnu_base.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -1,4 +1,4 @@\n-use crate::spec::crt_objects::{self, CrtObjectsFallback};\n+use crate::spec::crt_objects::{self, LinkSelfContainedDefault};\n use crate::spec::{cvs, LinkerFlavor, TargetOptions};\n \n pub fn opts() -> TargetOptions {\n@@ -76,9 +76,9 @@ pub fn opts() -> TargetOptions {\n         pre_link_args,\n         pre_link_objects: crt_objects::pre_mingw(),\n         post_link_objects: crt_objects::post_mingw(),\n-        pre_link_objects_fallback: crt_objects::pre_mingw_fallback(),\n-        post_link_objects_fallback: crt_objects::post_mingw_fallback(),\n-        crt_objects_fallback: Some(CrtObjectsFallback::Mingw),\n+        pre_link_objects_self_contained: crt_objects::pre_mingw_self_contained(),\n+        post_link_objects_self_contained: crt_objects::post_mingw_self_contained(),\n+        link_self_contained: LinkSelfContainedDefault::Mingw,\n         late_link_args,\n         late_link_args_dynamic,\n         late_link_args_static,"}, {"sha": "a54b36262b2e083ee5b9e34f594979e825f2167b", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -734,7 +734,21 @@ impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n         result\n     }\n \n-    // FIXME: Constants should participate in orphan checking.\n+    /// All possible values for a constant parameter already exist\n+    /// in the crate defining the trait, so they are always non-local[^1].\n+    ///\n+    /// Because there's no way to have an impl where the first local\n+    /// generic argument is a constant, we also don't have to fail\n+    /// the orphan check when encountering a parameter or a generic constant.\n+    ///\n+    /// This means that we can completely ignore constants during the orphan check.\n+    ///\n+    /// See `src/test/ui/coherence/const-generics-orphan-check-ok.rs` for examples.\n+    ///\n+    /// [^1]: This might not hold for function pointers or trait objects in the future.\n+    /// As these should be quite rare as const arguments and especially rare as impl\n+    /// parameters, allowing uncovered const parameters in impls seems more useful\n+    /// than allowing `impl<T> Trait<local_fn_ptr, T> for i32` to compile.\n     fn visit_const(&mut self, _c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         ControlFlow::CONTINUE\n     }"}, {"sha": "05686be5d4b3dfb081f327b2ab2d615053ce4a5c", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -69,6 +69,9 @@ pub fn intrinsic_operation_unsafety(intrinsic: Symbol) -> hir::Unsafety {\n         // to note that it's safe to call, since\n         // safe extern fns are otherwise unprecedented.\n         sym::abort\n+        | sym::assert_inhabited\n+        | sym::assert_zero_valid\n+        | sym::assert_uninit_valid\n         | sym::size_of\n         | sym::min_align_of\n         | sym::needs_drop"}, {"sha": "ebf1f5061835fd041bcd1fddda76fcf20d5e35a2", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -292,6 +292,17 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         intravisit::walk_expr(self, e);\n     }\n \n+    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n+        match &p.kind {\n+            hir::GenericParamKind::Lifetime { .. } => {\n+                // Nothing to write back here\n+            }\n+            hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => {\n+                self.tcx().sess.delay_span_bug(p.span, format!(\"unexpected generic param: {p:?}\"));\n+            }\n+        }\n+    }\n+\n     fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n         self.visit_node_id(b.span, b.hir_id);\n         intravisit::walk_block(self, b);"}, {"sha": "9b479a9f8adfb9d478610e7ca03cfa7b045d10c5", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -0,0 +1,182 @@\n+use crate::array;\n+use crate::iter::{ByRefSized, FusedIterator, Iterator};\n+use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n+\n+/// An iterator over `N` elements of the iterator at a time.\n+///\n+/// The chunks do not overlap. If `N` does not divide the length of the\n+/// iterator, then the last up to `N-1` elements will be omitted.\n+///\n+/// This `struct` is created by the [`array_chunks`][Iterator::array_chunks]\n+/// method on [`Iterator`]. See its documentation for more.\n+#[derive(Debug, Clone)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+pub struct ArrayChunks<I: Iterator, const N: usize> {\n+    iter: I,\n+    remainder: Option<array::IntoIter<I::Item, N>>,\n+}\n+\n+impl<I, const N: usize> ArrayChunks<I, N>\n+where\n+    I: Iterator,\n+{\n+    #[track_caller]\n+    pub(in crate::iter) fn new(iter: I) -> Self {\n+        assert!(N != 0, \"chunk size must be non-zero\");\n+        Self { iter, remainder: None }\n+    }\n+\n+    /// Returns an iterator over the remaining elements of the original iterator\n+    /// that are not going to be returned by this iterator. The returned\n+    /// iterator will yield at most `N-1` elements.\n+    #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+    #[inline]\n+    pub fn into_remainder(self) -> Option<array::IntoIter<I::Item, N>> {\n+        self.remainder\n+    }\n+}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+impl<I, const N: usize> Iterator for ArrayChunks<I, N>\n+where\n+    I: Iterator,\n+{\n+    type Item = [I::Item; N];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.try_for_each(ControlFlow::Break).break_value()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        (lower / N, upper.map(|n| n / N))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count() / N\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        let mut acc = init;\n+        loop {\n+            match self.iter.next_chunk() {\n+                Ok(chunk) => acc = f(acc, chunk)?,\n+                Err(remainder) => {\n+                    // Make sure to not override `self.remainder` with an empty array\n+                    // when `next` is called after `ArrayChunks` exhaustion.\n+                    self.remainder.get_or_insert(remainder);\n+\n+                    break try { acc };\n+                }\n+            }\n+        }\n+    }\n+\n+    fn fold<B, F>(mut self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        self.try_fold(init, NeverShortCircuit::wrap_mut_2(f)).0\n+    }\n+}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+impl<I, const N: usize> DoubleEndedIterator for ArrayChunks<I, N>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.try_rfold((), |(), x| ControlFlow::Break(x)).break_value()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        // We are iterating from the back we need to first handle the remainder.\n+        self.next_back_remainder();\n+\n+        let mut acc = init;\n+        let mut iter = ByRefSized(&mut self.iter).rev();\n+\n+        // NB remainder is handled by `next_back_remainder`, so\n+        // `next_chunk` can't return `Err` with non-empty remainder\n+        // (assuming correct `I as ExactSizeIterator` impl).\n+        while let Ok(mut chunk) = iter.next_chunk() {\n+            // FIXME: do not do double reverse\n+            //        (we could instead add `next_chunk_back` for example)\n+            chunk.reverse();\n+            acc = f(acc, chunk)?\n+        }\n+\n+        try { acc }\n+    }\n+\n+    fn rfold<B, F>(mut self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        self.try_rfold(init, NeverShortCircuit::wrap_mut_2(f)).0\n+    }\n+}\n+\n+impl<I, const N: usize> ArrayChunks<I, N>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    /// Updates `self.remainder` such that `self.iter.len` is divisible by `N`.\n+    fn next_back_remainder(&mut self) {\n+        // Make sure to not override `self.remainder` with an empty array\n+        // when `next_back` is called after `ArrayChunks` exhaustion.\n+        if self.remainder.is_some() {\n+            return;\n+        }\n+\n+        // We use the `ExactSizeIterator` implementation of the underlying\n+        // iterator to know how many remaining elements there are.\n+        let rem = self.iter.len() % N;\n+\n+        // Take the last `rem` elements out of `self.iter`.\n+        let mut remainder =\n+            // SAFETY: `unwrap_err` always succeeds because x % N < N for all x.\n+            unsafe { self.iter.by_ref().rev().take(rem).next_chunk().unwrap_err_unchecked() };\n+\n+        // We used `.rev()` above, so we need to re-reverse the reminder\n+        remainder.as_mut_slice().reverse();\n+        self.remainder = Some(remainder);\n+    }\n+}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+impl<I, const N: usize> FusedIterator for ArrayChunks<I, N> where I: FusedIterator {}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+impl<I, const N: usize> ExactSizeIterator for ArrayChunks<I, N>\n+where\n+    I: ExactSizeIterator,\n+{\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.iter.len() / N\n+    }\n+\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        self.iter.len() < N\n+    }\n+}"}, {"sha": "bf4fabad32a373e333c4f06443a3df6f0d5f0c1c", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -1,6 +1,7 @@\n use crate::iter::{InPlaceIterable, Iterator};\n use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, NeverShortCircuit, Residual, Try};\n \n+mod array_chunks;\n mod by_ref_sized;\n mod chain;\n mod cloned;\n@@ -32,6 +33,9 @@ pub use self::{\n     scan::Scan, skip::Skip, skip_while::SkipWhile, take::Take, take_while::TakeWhile, zip::Zip,\n };\n \n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+pub use self::array_chunks::ArrayChunks;\n+\n #[unstable(feature = \"std_internals\", issue = \"none\")]\n pub use self::by_ref_sized::ByRefSized;\n "}, {"sha": "9514466bd0c050d9969a64a6d161fdd9310fd498", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -398,6 +398,8 @@ pub use self::traits::{\n \n #[stable(feature = \"iter_zip\", since = \"1.59.0\")]\n pub use self::adapters::zip;\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+pub use self::adapters::ArrayChunks;\n #[unstable(feature = \"std_internals\", issue = \"none\")]\n pub use self::adapters::ByRefSized;\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]"}, {"sha": "b2d08f4b0f67bf456692e0c34fdf954ef357c1c0", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -5,7 +5,7 @@ use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, Residual, Try};\n use super::super::try_process;\n use super::super::ByRefSized;\n use super::super::TrustedRandomAccessNoCoerce;\n-use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n+use super::super::{ArrayChunks, Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n use super::super::{FromIterator, Intersperse, IntersperseWith, Product, Sum, Zip};\n use super::super::{\n@@ -3316,6 +3316,49 @@ pub trait Iterator {\n         Cycle::new(self)\n     }\n \n+    /// Returns an iterator over `N` elements of the iterator at a time.\n+    ///\n+    /// The chunks do not overlap. If `N` does not divide the length of the\n+    /// iterator, then the last up to `N-1` elements will be omitted and can be\n+    /// retrieved from the [`.into_remainder()`][ArrayChunks::into_remainder]\n+    /// function of the iterator.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `N` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_array_chunks)]\n+    ///\n+    /// let mut iter = \"lorem\".chars().array_chunks();\n+    /// assert_eq!(iter.next(), Some(['l', 'o']));\n+    /// assert_eq!(iter.next(), Some(['r', 'e']));\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.into_remainder().unwrap().as_slice(), &['m']);\n+    /// ```\n+    ///\n+    /// ```\n+    /// #![feature(iter_array_chunks)]\n+    ///\n+    /// let data = [1, 1, 2, -2, 6, 0, 3, 1];\n+    /// //          ^-----^  ^------^\n+    /// for [x, y, z] in data.iter().array_chunks() {\n+    ///     assert_eq!(x + y + z, 4);\n+    /// }\n+    /// ```\n+    #[track_caller]\n+    #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+    fn array_chunks<const N: usize>(self) -> ArrayChunks<Self, N>\n+    where\n+        Self: Sized,\n+    {\n+        ArrayChunks::new(self)\n+    }\n+\n     /// Sums the elements of an iterator.\n     ///\n     /// Takes each element, adds them together, and returns the result."}, {"sha": "4e9d89e1e580f688c0d1d95afe636c8cf48a1bff", "filename": "library/core/tests/iter/adapters/array_chunks.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -0,0 +1,179 @@\n+use core::cell::Cell;\n+use core::iter::{self, Iterator};\n+\n+use super::*;\n+\n+#[test]\n+fn test_iterator_array_chunks_infer() {\n+    let xs = [1, 1, 2, -2, 6, 0, 3, 1];\n+    for [a, b, c] in xs.iter().copied().array_chunks() {\n+        assert_eq!(a + b + c, 4);\n+    }\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_clone_and_drop() {\n+    let count = Cell::new(0);\n+    let mut it = (0..5).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    assert_eq!(it.by_ref().count(), 1);\n+    assert_eq!(count.get(), 3);\n+    let mut it2 = it.clone();\n+    assert_eq!(count.get(), 3);\n+    assert_eq!(it.into_remainder().unwrap().len(), 2);\n+    assert_eq!(count.get(), 5);\n+    assert!(it2.next().is_none());\n+    assert_eq!(it2.into_remainder().unwrap().len(), 2);\n+    assert_eq!(count.get(), 7);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_remainder() {\n+    let mut it = (0..11).array_chunks::<4>();\n+    assert_eq!(it.next(), Some([0, 1, 2, 3]));\n+    assert_eq!(it.next(), Some([4, 5, 6, 7]));\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.into_remainder().unwrap().as_slice(), &[8, 9, 10]);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_size_hint() {\n+    let it = (0..6).array_chunks::<1>();\n+    assert_eq!(it.size_hint(), (6, Some(6)));\n+\n+    let it = (0..6).array_chunks::<3>();\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+\n+    let it = (0..6).array_chunks::<5>();\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+\n+    let it = (0..6).array_chunks::<7>();\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+\n+    let it = (1..).array_chunks::<2>();\n+    assert_eq!(it.size_hint(), (usize::MAX / 2, None));\n+\n+    let it = (1..).filter(|x| x % 2 != 0).array_chunks::<2>();\n+    assert_eq!(it.size_hint(), (0, None));\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_count() {\n+    let it = (0..6).array_chunks::<1>();\n+    assert_eq!(it.count(), 6);\n+\n+    let it = (0..6).array_chunks::<3>();\n+    assert_eq!(it.count(), 2);\n+\n+    let it = (0..6).array_chunks::<5>();\n+    assert_eq!(it.count(), 1);\n+\n+    let it = (0..6).array_chunks::<7>();\n+    assert_eq!(it.count(), 0);\n+\n+    let it = (0..6).filter(|x| x % 2 == 0).array_chunks::<2>();\n+    assert_eq!(it.count(), 1);\n+\n+    let it = iter::empty::<i32>().array_chunks::<2>();\n+    assert_eq!(it.count(), 0);\n+\n+    let it = [(); usize::MAX].iter().array_chunks::<2>();\n+    assert_eq!(it.count(), usize::MAX / 2);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_next_and_next_back() {\n+    let mut it = (0..11).array_chunks::<3>();\n+    assert_eq!(it.next(), Some([0, 1, 2]));\n+    assert_eq!(it.next_back(), Some([6, 7, 8]));\n+    assert_eq!(it.next(), Some([3, 4, 5]));\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.into_remainder().unwrap().as_slice(), &[9, 10]);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_rev_remainder() {\n+    let mut it = (0..11).array_chunks::<4>();\n+    {\n+        let mut it = it.by_ref().rev();\n+        assert_eq!(it.next(), Some([4, 5, 6, 7]));\n+        assert_eq!(it.next(), Some([0, 1, 2, 3]));\n+        assert_eq!(it.next(), None);\n+        assert_eq!(it.next(), None);\n+    }\n+    assert_eq!(it.into_remainder().unwrap().as_slice(), &[8, 9, 10]);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_try_fold() {\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result: Result<_, ()> = it.by_ref().try_fold(0, |acc, _item| Ok(acc + 1));\n+    assert_eq!(result, Ok(3));\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 10);\n+\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result = it.by_ref().try_fold(0, |acc, _item| if acc < 2 { Ok(acc + 1) } else { Err(acc) });\n+    assert_eq!(result, Err(2));\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 9);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_fold() {\n+    let result = (1..11).array_chunks::<3>().fold(0, |acc, [a, b, c]| {\n+        assert_eq!(acc + 1, a);\n+        assert_eq!(acc + 2, b);\n+        assert_eq!(acc + 3, c);\n+        acc + 3\n+    });\n+    assert_eq!(result, 9);\n+\n+    let count = Cell::new(0);\n+    let result =\n+        (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>().fold(0, |acc, _item| acc + 1);\n+    assert_eq!(result, 3);\n+    assert_eq!(count.get(), 10);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_try_rfold() {\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result: Result<_, ()> = it.try_rfold(0, |acc, _item| Ok(acc + 1));\n+    assert_eq!(result, Ok(3));\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 10);\n+\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result = it.try_rfold(0, |acc, _item| if acc < 2 { Ok(acc + 1) } else { Err(acc) });\n+    assert_eq!(result, Err(2));\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 10);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_rfold() {\n+    let result = (1..11).array_chunks::<3>().rfold(0, |acc, [a, b, c]| {\n+        assert_eq!(10 - (acc + 1), c);\n+        assert_eq!(10 - (acc + 2), b);\n+        assert_eq!(10 - (acc + 3), a);\n+        acc + 3\n+    });\n+    assert_eq!(result, 9);\n+\n+    let count = Cell::new(0);\n+    let result =\n+        (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>().rfold(0, |acc, _item| acc + 1);\n+    assert_eq!(result, 3);\n+    assert_eq!(count.get(), 10);\n+}"}, {"sha": "96539c0c394e2e683720fc0d8b44aa5e688e40b0", "filename": "library/core/tests/iter/adapters/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -1,3 +1,4 @@\n+mod array_chunks;\n mod chain;\n mod cloned;\n mod copied;\n@@ -183,3 +184,25 @@ impl Clone for CountClone {\n         ret\n     }\n }\n+\n+#[derive(Debug, Clone)]\n+struct CountDrop<'a> {\n+    dropped: bool,\n+    count: &'a Cell<usize>,\n+}\n+\n+impl<'a> CountDrop<'a> {\n+    pub fn new(count: &'a Cell<usize>) -> Self {\n+        Self { dropped: false, count }\n+    }\n+}\n+\n+impl Drop for CountDrop<'_> {\n+    fn drop(&mut self) {\n+        if self.dropped {\n+            panic!(\"double drop\");\n+        }\n+        self.dropped = true;\n+        self.count.set(self.count.get() + 1);\n+    }\n+}"}, {"sha": "09f1500f564cf6ce1fb9e3c54b85e2788c39c939", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -62,6 +62,7 @@\n #![feature(slice_partition_dedup)]\n #![feature(int_log)]\n #![feature(iter_advance_by)]\n+#![feature(iter_array_chunks)]\n #![feature(iter_collect_into)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_intersperse)]"}, {"sha": "72ad6185d3761bfc5908b37a963363eb2eb6ade0", "filename": "src/test/ui/closures/binder/disallow-const.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -0,0 +1,6 @@\n+#![feature(closure_lifetime_binder)]\n+\n+fn main() {\n+    for<const N: i32> || -> () {};\n+    //~^ ERROR only lifetime parameters can be used in this context\n+}"}, {"sha": "3c3b43d8cf34275d4dc300de79c155a293337564", "filename": "src/test/ui/closures/binder/disallow-const.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.stderr?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -0,0 +1,8 @@\n+error: only lifetime parameters can be used in this context\n+  --> $DIR/disallow-const.rs:4:15\n+   |\n+LL |     for<const N: i32> || -> () {};\n+   |               ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "bbe3d8488d9825685f20473488f52c19f6b9d76c", "filename": "src/test/ui/closures/binder/disallow-ty.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -0,0 +1,6 @@\n+#![feature(closure_lifetime_binder)]\n+\n+fn main() {\n+    for<T> || -> () {};\n+    //~^ ERROR only lifetime parameters can be used in this context\n+}"}, {"sha": "51b6773edea9897e7a85454a20f0cbfc168874ad", "filename": "src/test/ui/closures/binder/disallow-ty.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.stderr?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -0,0 +1,8 @@\n+error: only lifetime parameters can be used in this context\n+  --> $DIR/disallow-ty.rs:4:9\n+   |\n+LL |     for<T> || -> () {};\n+   |         ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "a44eb14f8e4cf53dd74bb184c25a63827f9a7dc8", "filename": "src/test/ui/coherence/auxiliary/trait-with-const-param.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Ftrait-with-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Ftrait-with-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Ftrait-with-const-param.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -0,0 +1 @@\n+pub trait Trait<const N: usize, T> {}"}, {"sha": "217e8aed234b11efee6c131ec050d16d8f42eca9", "filename": "src/test/ui/coherence/const-generics-orphan-check-ok.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fcoherence%2Fconst-generics-orphan-check-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fcoherence%2Fconst-generics-orphan-check-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fconst-generics-orphan-check-ok.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+// aux-build:trait-with-const-param.rs\n+extern crate trait_with_const_param;\n+use trait_with_const_param::*;\n+\n+// Trivial case, const param after local type.\n+struct Local1;\n+impl<const N: usize, T> Trait<N, T> for Local1 {}\n+\n+// Concrete consts behave the same as foreign types,\n+// so this also trivially works.\n+impl Trait<3, Local1> for i32 {}\n+\n+// This case isn't as trivial as we would forbid type\n+// parameters here, we do allow const parameters though.\n+//\n+// The reason that type parameters are forbidden for\n+// `impl<T> Trait<T, LocalInA> for i32 {}` is that another\n+// downstream crate can add `impl<T> Trait<LocalInB, T> for i32`.\n+// As these two impls would overlap we forbid any impls which\n+// have a type parameter in front of a local type.\n+//\n+// With const parameters this issue does not exist as there are no\n+// constants local to another downstream crate.\n+struct Local2;\n+impl<const N: usize> Trait<N, Local2> for i32 {}\n+\n+fn main() {}"}, {"sha": "3ce3e1bdbac0f9b6d4b30c12bce22173e38b0c0a", "filename": "src/test/ui/consts/assert-type-intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -13,10 +13,10 @@ fn main() {\n     const _BAD1: () = unsafe {\n         MaybeUninit::<!>::uninit().assume_init();\n     };\n-    const _BAD2: () = unsafe {\n+    const _BAD2: () = {\n         intrinsics::assert_uninit_valid::<bool>();\n     };\n-    const _BAD3: () = unsafe {\n+    const _BAD3: () = {\n         intrinsics::assert_zero_valid::<&'static i32>();\n     };\n }"}, {"sha": "6eab10197b8553af4e006a64e6741a361bbda8bc", "filename": "src/test/ui/consts/assert-type-intrinsics.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.stderr?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -13,7 +13,7 @@ LL |         MaybeUninit::<!>::uninit().assume_init();\n error: any use of this value will cause an error\n   --> $DIR/assert-type-intrinsics.rs:17:9\n    |\n-LL |     const _BAD2: () = unsafe {\n+LL |     const _BAD2: () = {\n    |     ---------------\n LL |         intrinsics::assert_uninit_valid::<bool>();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to leave type `bool` uninitialized, which is invalid\n@@ -24,7 +24,7 @@ LL |         intrinsics::assert_uninit_valid::<bool>();\n error: any use of this value will cause an error\n   --> $DIR/assert-type-intrinsics.rs:20:9\n    |\n-LL |     const _BAD3: () = unsafe {\n+LL |     const _BAD3: () = {\n    |     ---------------\n LL |         intrinsics::assert_zero_valid::<&'static i32>();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to zero-initialize type `&i32`, which is invalid\n@@ -51,7 +51,7 @@ Future breakage diagnostic:\n error: any use of this value will cause an error\n   --> $DIR/assert-type-intrinsics.rs:17:9\n    |\n-LL |     const _BAD2: () = unsafe {\n+LL |     const _BAD2: () = {\n    |     ---------------\n LL |         intrinsics::assert_uninit_valid::<bool>();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to leave type `bool` uninitialized, which is invalid\n@@ -64,7 +64,7 @@ Future breakage diagnostic:\n error: any use of this value will cause an error\n   --> $DIR/assert-type-intrinsics.rs:20:9\n    |\n-LL |     const _BAD3: () = unsafe {\n+LL |     const _BAD3: () = {\n    |     ---------------\n LL |         intrinsics::assert_zero_valid::<&'static i32>();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to zero-initialize type `&i32`, which is invalid"}, {"sha": "64ab6f62b77f38530d237d02fd24272623c41f05", "filename": "src/test/ui/parser/issue-99910-const-let-mutually-exclusive.fixed", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fparser%2Fissue-99910-const-let-mutually-exclusive.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fparser%2Fissue-99910-const-let-mutually-exclusive.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-99910-const-let-mutually-exclusive.fixed?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+\n+fn main() {\n+    const _FOO: i32 = 123;\n+    //~^ ERROR const` and `let` are mutually exclusive\n+    const _BAR: i32 = 123;\n+    //~^ ERROR `const` and `let` are mutually exclusive\n+}"}, {"sha": "50520971ffb32bb6f68cb62c53917b96f33a5ff7", "filename": "src/test/ui/parser/issue-99910-const-let-mutually-exclusive.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fparser%2Fissue-99910-const-let-mutually-exclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fparser%2Fissue-99910-const-let-mutually-exclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-99910-const-let-mutually-exclusive.rs?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+\n+fn main() {\n+    const let _FOO: i32 = 123;\n+    //~^ ERROR const` and `let` are mutually exclusive\n+    let const _BAR: i32 = 123;\n+    //~^ ERROR `const` and `let` are mutually exclusive\n+}"}, {"sha": "72377fc379cac8c525d02399cd95fa6a1af699ac", "filename": "src/test/ui/parser/issue-99910-const-let-mutually-exclusive.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fparser%2Fissue-99910-const-let-mutually-exclusive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c5665583815a0f0f3e22516441efb43ea6dede2/src%2Ftest%2Fui%2Fparser%2Fissue-99910-const-let-mutually-exclusive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-99910-const-let-mutually-exclusive.stderr?ref=4c5665583815a0f0f3e22516441efb43ea6dede2", "patch": "@@ -0,0 +1,14 @@\n+error: `const` and `let` are mutually exclusive\n+  --> $DIR/issue-99910-const-let-mutually-exclusive.rs:4:5\n+   |\n+LL |     const let _FOO: i32 = 123;\n+   |     ^^^^^^^^^ help: remove `let`: `const`\n+\n+error: `const` and `let` are mutually exclusive\n+  --> $DIR/issue-99910-const-let-mutually-exclusive.rs:6:5\n+   |\n+LL |     let const _BAR: i32 = 123;\n+   |     ^^^^^^^^^ help: remove `let`: `const`\n+\n+error: aborting due to 2 previous errors\n+"}]}