{"sha": "56126fb149ea810db234e210893833e97a5c8e36", "node_id": "C_kwDOAAsO6NoAKDU2MTI2ZmIxNDllYTgxMGRiMjM0ZTIxMDg5MzgzM2U5N2E1YzhlMzY", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2022-11-30T15:43:09Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2022-11-30T17:43:54Z"}, "message": "Extract llvm datalayout parsing out of spec module", "tree": {"sha": "636f2aa4459fe0082e271c9b1884552909911e6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/636f2aa4459fe0082e271c9b1884552909911e6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56126fb149ea810db234e210893833e97a5c8e36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56126fb149ea810db234e210893833e97a5c8e36", "html_url": "https://github.com/rust-lang/rust/commit/56126fb149ea810db234e210893833e97a5c8e36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56126fb149ea810db234e210893833e97a5c8e36/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90711a86e5bdd4b0b65d293f0c2c48fd2db761b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/90711a86e5bdd4b0b65d293f0c2c48fd2db761b3", "html_url": "https://github.com/rust-lang/rust/commit/90711a86e5bdd4b0b65d293f0c2c48fd2db761b3"}], "stats": {"total": 188, "additions": 98, "deletions": 90}, "files": [{"sha": "85693259cd0153eb02fbb6b0b8424a9fe69a7124", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/56126fb149ea810db234e210893833e97a5c8e36/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56126fb149ea810db234e210893833e97a5c8e36/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=56126fb149ea810db234e210893833e97a5c8e36", "patch": "@@ -211,6 +211,102 @@ pub enum TargetDataLayoutErrors<'a> {\n }\n \n impl TargetDataLayout {\n+    /// Parse data layout from an [llvm data layout string](https://llvm.org/docs/LangRef.html#data-layout)\n+    ///\n+    /// This function doesn't fill `c_enum_min_size` and it will always be `I32` since it can not be\n+    /// determined from llvm string.\n+    pub fn parse_from_llvm_datalayout_string<'a>(\n+        input: &'a str,\n+    ) -> Result<TargetDataLayout, TargetDataLayoutErrors<'a>> {\n+        // Parse an address space index from a string.\n+        let parse_address_space = |s: &'a str, cause: &'a str| {\n+            s.parse::<u32>().map(AddressSpace).map_err(|err| {\n+                TargetDataLayoutErrors::InvalidAddressSpace { addr_space: s, cause, err }\n+            })\n+        };\n+\n+        // Parse a bit count from a string.\n+        let parse_bits = |s: &'a str, kind: &'a str, cause: &'a str| {\n+            s.parse::<u64>().map_err(|err| TargetDataLayoutErrors::InvalidBits {\n+                kind,\n+                bit: s,\n+                cause,\n+                err,\n+            })\n+        };\n+\n+        // Parse a size string.\n+        let size = |s: &'a str, cause: &'a str| parse_bits(s, \"size\", cause).map(Size::from_bits);\n+\n+        // Parse an alignment string.\n+        let align = |s: &[&'a str], cause: &'a str| {\n+            if s.is_empty() {\n+                return Err(TargetDataLayoutErrors::MissingAlignment { cause });\n+            }\n+            let align_from_bits = |bits| {\n+                Align::from_bits(bits)\n+                    .map_err(|err| TargetDataLayoutErrors::InvalidAlignment { cause, err })\n+            };\n+            let abi = parse_bits(s[0], \"alignment\", cause)?;\n+            let pref = s.get(1).map_or(Ok(abi), |pref| parse_bits(pref, \"alignment\", cause))?;\n+            Ok(AbiAndPrefAlign { abi: align_from_bits(abi)?, pref: align_from_bits(pref)? })\n+        };\n+\n+        let mut dl = TargetDataLayout::default();\n+        let mut i128_align_src = 64;\n+        for spec in input.split('-') {\n+            let spec_parts = spec.split(':').collect::<Vec<_>>();\n+\n+            match &*spec_parts {\n+                [\"e\"] => dl.endian = Endian::Little,\n+                [\"E\"] => dl.endian = Endian::Big,\n+                [p] if p.starts_with('P') => {\n+                    dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n+                }\n+                [\"a\", ref a @ ..] => dl.aggregate_align = align(a, \"a\")?,\n+                [\"f32\", ref a @ ..] => dl.f32_align = align(a, \"f32\")?,\n+                [\"f64\", ref a @ ..] => dl.f64_align = align(a, \"f64\")?,\n+                [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n+                    dl.pointer_size = size(s, p)?;\n+                    dl.pointer_align = align(a, p)?;\n+                }\n+                [s, ref a @ ..] if s.starts_with('i') => {\n+                    let Ok(bits) = s[1..].parse::<u64>() else {\n+                        size(&s[1..], \"i\")?; // For the user error.\n+                        continue;\n+                    };\n+                    let a = align(a, s)?;\n+                    match bits {\n+                        1 => dl.i1_align = a,\n+                        8 => dl.i8_align = a,\n+                        16 => dl.i16_align = a,\n+                        32 => dl.i32_align = a,\n+                        64 => dl.i64_align = a,\n+                        _ => {}\n+                    }\n+                    if bits >= i128_align_src && bits <= 128 {\n+                        // Default alignment for i128 is decided by taking the alignment of\n+                        // largest-sized i{64..=128}.\n+                        i128_align_src = bits;\n+                        dl.i128_align = a;\n+                    }\n+                }\n+                [s, ref a @ ..] if s.starts_with('v') => {\n+                    let v_size = size(&s[1..], \"v\")?;\n+                    let a = align(a, s)?;\n+                    if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {\n+                        v.1 = a;\n+                        continue;\n+                    }\n+                    // No existing entry, add a new one.\n+                    dl.vector_align.push((v_size, a));\n+                }\n+                _ => {} // Ignore everything else.\n+            }\n+        }\n+        Ok(dl)\n+    }\n+\n     /// Returns exclusive upper bound on object size.\n     ///\n     /// The theoretical maximum object size is defined as the maximum positive `isize` value."}, {"sha": "78315afa759561080a7f479c8e595d5046a2c975", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 90, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/56126fb149ea810db234e210893833e97a5c8e36/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56126fb149ea810db234e210893833e97a5c8e36/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=56126fb149ea810db234e210893833e97a5c8e36", "patch": "@@ -35,10 +35,7 @@\n //! to the list specified by the target, rather than replace.\n \n use crate::abi::call::Conv;\n-use crate::abi::{\n-    AbiAndPrefAlign, AddressSpace, Align, Endian, Integer, Size, TargetDataLayout,\n-    TargetDataLayoutErrors,\n-};\n+use crate::abi::{Endian, Integer, Size, TargetDataLayout, TargetDataLayoutErrors};\n use crate::json::{Json, ToJson};\n use crate::spec::abi::{lookup as lookup_abi, Abi};\n use crate::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n@@ -1322,92 +1319,7 @@ pub struct Target {\n \n impl Target {\n     pub fn parse_data_layout<'a>(&'a self) -> Result<TargetDataLayout, TargetDataLayoutErrors<'a>> {\n-        // Parse an address space index from a string.\n-        let parse_address_space = |s: &'a str, cause: &'a str| {\n-            s.parse::<u32>().map(AddressSpace).map_err(|err| {\n-                TargetDataLayoutErrors::InvalidAddressSpace { addr_space: s, cause, err }\n-            })\n-        };\n-\n-        // Parse a bit count from a string.\n-        let parse_bits = |s: &'a str, kind: &'a str, cause: &'a str| {\n-            s.parse::<u64>().map_err(|err| TargetDataLayoutErrors::InvalidBits {\n-                kind,\n-                bit: s,\n-                cause,\n-                err,\n-            })\n-        };\n-\n-        // Parse a size string.\n-        let size = |s: &'a str, cause: &'a str| parse_bits(s, \"size\", cause).map(Size::from_bits);\n-\n-        // Parse an alignment string.\n-        let align = |s: &[&'a str], cause: &'a str| {\n-            if s.is_empty() {\n-                return Err(TargetDataLayoutErrors::MissingAlignment { cause });\n-            }\n-            let align_from_bits = |bits| {\n-                Align::from_bits(bits)\n-                    .map_err(|err| TargetDataLayoutErrors::InvalidAlignment { cause, err })\n-            };\n-            let abi = parse_bits(s[0], \"alignment\", cause)?;\n-            let pref = s.get(1).map_or(Ok(abi), |pref| parse_bits(pref, \"alignment\", cause))?;\n-            Ok(AbiAndPrefAlign { abi: align_from_bits(abi)?, pref: align_from_bits(pref)? })\n-        };\n-\n-        let mut dl = TargetDataLayout::default();\n-        let mut i128_align_src = 64;\n-        for spec in self.data_layout.split('-') {\n-            let spec_parts = spec.split(':').collect::<Vec<_>>();\n-\n-            match &*spec_parts {\n-                [\"e\"] => dl.endian = Endian::Little,\n-                [\"E\"] => dl.endian = Endian::Big,\n-                [p] if p.starts_with('P') => {\n-                    dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n-                }\n-                [\"a\", ref a @ ..] => dl.aggregate_align = align(a, \"a\")?,\n-                [\"f32\", ref a @ ..] => dl.f32_align = align(a, \"f32\")?,\n-                [\"f64\", ref a @ ..] => dl.f64_align = align(a, \"f64\")?,\n-                [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n-                    dl.pointer_size = size(s, p)?;\n-                    dl.pointer_align = align(a, p)?;\n-                }\n-                [s, ref a @ ..] if s.starts_with('i') => {\n-                    let Ok(bits) = s[1..].parse::<u64>() else {\n-                        size(&s[1..], \"i\")?; // For the user error.\n-                        continue;\n-                    };\n-                    let a = align(a, s)?;\n-                    match bits {\n-                        1 => dl.i1_align = a,\n-                        8 => dl.i8_align = a,\n-                        16 => dl.i16_align = a,\n-                        32 => dl.i32_align = a,\n-                        64 => dl.i64_align = a,\n-                        _ => {}\n-                    }\n-                    if bits >= i128_align_src && bits <= 128 {\n-                        // Default alignment for i128 is decided by taking the alignment of\n-                        // largest-sized i{64..=128}.\n-                        i128_align_src = bits;\n-                        dl.i128_align = a;\n-                    }\n-                }\n-                [s, ref a @ ..] if s.starts_with('v') => {\n-                    let v_size = size(&s[1..], \"v\")?;\n-                    let a = align(a, s)?;\n-                    if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {\n-                        v.1 = a;\n-                        continue;\n-                    }\n-                    // No existing entry, add a new one.\n-                    dl.vector_align.push((v_size, a));\n-                }\n-                _ => {} // Ignore everything else.\n-            }\n-        }\n+        let mut dl = TargetDataLayout::parse_from_llvm_datalayout_string(&self.data_layout)?;\n \n         // Perform consistency checks against the Target information.\n         if dl.endian != self.endian {"}]}