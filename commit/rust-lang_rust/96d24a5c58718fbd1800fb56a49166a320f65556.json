{"sha": "96d24a5c58718fbd1800fb56a49166a320f65556", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZDI0YTVjNTg3MThmYmQxODAwZmI1NmE0OTE2NmEzMjBmNjU1NTY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-07-03T02:22:54Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-07-04T03:21:00Z"}, "message": "rustc: remove MethodOrigin::Object and use traits::VtableObject instead.", "tree": {"sha": "8012228db8716237f0934af73f9a9309fdaa9c85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8012228db8716237f0934af73f9a9309fdaa9c85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96d24a5c58718fbd1800fb56a49166a320f65556", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96d24a5c58718fbd1800fb56a49166a320f65556", "html_url": "https://github.com/rust-lang/rust/commit/96d24a5c58718fbd1800fb56a49166a320f65556", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96d24a5c58718fbd1800fb56a49166a320f65556/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5447e13aae877d9a8454e5e69de373cf32f8ee7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5447e13aae877d9a8454e5e69de373cf32f8ee7", "html_url": "https://github.com/rust-lang/rust/commit/a5447e13aae877d9a8454e5e69de373cf32f8ee7"}], "stats": {"total": 371, "additions": 144, "deletions": 227}, "files": [{"sha": "971774336c8b30ce4234ac8fa8dcf7901b4909fe", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=96d24a5c58718fbd1800fb56a49166a320f65556", "patch": "@@ -630,15 +630,8 @@ pub enum MethodOrigin {\n     /// Inherent impl method call.\n     Inherent,\n \n-    /// Statically dispatched trait method call.\n-    Trait,\n-\n-    /// Dynamically dispatched trait method call.\n-    /// The usize is the index into the actual runtime vtable.\n-    /// The vtable is formed by concatenating together the method lists of\n-    /// the base object trait and all supertraits; this is the index into\n-    /// that vtable.\n-    Object(usize)\n+    /// Trait method call.\n+    Trait\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "4f315b56815c696eebed32953fd2414327a5eae7", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=96d24a5c58718fbd1800fb56a49166a320f65556", "patch": "@@ -852,7 +852,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             }\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            ty::MethodOrigin::Trait | ty::MethodOrigin::Object(_) => {\n+            ty::MethodOrigin::Trait => {\n                 let method = self.tcx.impl_or_trait_item(callee.def_id);\n                 self.report_error(self.ensure_public(span, method.container().id(),\n                                                      None, \"source trait\"));"}, {"sha": "d0f9456b11c3d9a8fa4e46d606cc635bd2a71a19", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=96d24a5c58718fbd1800fb56a49166a320f65556", "patch": "@@ -892,7 +892,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             ty::MethodOrigin::Inherent => {\n                 (Some(method_callee.def_id), None)\n             }\n-            ty::MethodOrigin::Trait | ty::MethodOrigin::Object(_) => {\n+            ty::MethodOrigin::Trait => {\n                 (None, Some(method_callee.def_id))\n             }\n         };"}, {"sha": "dc5b6cf7db883835baa6102986b15cff92c8a4a4", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 50, "deletions": 89, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=96d24a5c58718fbd1800fb56a49166a320f65556", "patch": "@@ -22,7 +22,6 @@ use arena::TypedArena;\n use back::link;\n use session;\n use llvm::{self, ValueRef, get_params};\n-use metadata::csearch;\n use middle::def;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n@@ -66,7 +65,7 @@ pub struct MethodData {\n pub enum CalleeData<'tcx> {\n     // Constructor for enum variant/tuple-like-struct\n     // i.e. Some, Ok\n-    NamedTupleConstructor(subst::Substs<'tcx>, ty::Disr),\n+    NamedTupleConstructor(ty::Disr),\n \n     // Represents a (possibly monomorphized) top-level fn item or method\n     // item. Note that this is just the fn-ptr and is not a Rust closure\n@@ -81,6 +80,7 @@ pub enum CalleeData<'tcx> {\n pub struct Callee<'blk, 'tcx: 'blk> {\n     pub bcx: Block<'blk, 'tcx>,\n     pub data: CalleeData<'tcx>,\n+    pub ty: Ty<'tcx>\n }\n \n fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n@@ -104,11 +104,11 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n         let DatumBlock { bcx, datum, .. } = expr::trans(bcx, expr);\n         match datum.ty.sty {\n             ty::TyBareFn(..) => {\n-                let llval = datum.to_llscalarish(bcx);\n-                return Callee {\n+                Callee {\n                     bcx: bcx,\n-                    data: Fn(llval),\n-                };\n+                    ty: datum.ty,\n+                    data: Fn(datum.to_llscalarish(bcx))\n+                }\n             }\n             _ => {\n                 bcx.tcx().sess.span_bug(\n@@ -119,12 +119,13 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n         }\n     }\n \n-    fn fn_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, llfn: ValueRef)\n+    fn fn_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, datum: Datum<'tcx, Rvalue>)\n                              -> Callee<'blk, 'tcx> {\n-        return Callee {\n+        Callee {\n             bcx: bcx,\n-            data: Fn(llfn),\n-        };\n+            data: Fn(datum.val),\n+            ty: datum.ty\n+        }\n     }\n \n     fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -143,12 +144,10 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     _ => false\n                 }\n             } => {\n-                let substs = common::node_id_substs(bcx.ccx(),\n-                                                    ExprId(ref_expr.id),\n-                                                    bcx.fcx.param_substs);\n                 Callee {\n                     bcx: bcx,\n-                    data: NamedTupleConstructor(substs, 0)\n+                    data: NamedTupleConstructor(0),\n+                    ty: expr_ty\n                 }\n             }\n             def::DefFn(did, _) if match expr_ty.sty {\n@@ -159,40 +158,36 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                                                     ExprId(ref_expr.id),\n                                                     bcx.fcx.param_substs);\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-                Callee { bcx: bcx, data: Intrinsic(def_id.node, substs) }\n+                Callee { bcx: bcx, data: Intrinsic(def_id.node, substs), ty: expr_ty }\n             }\n             def::DefFn(did, _) | def::DefMethod(did, def::FromImpl(_)) => {\n                 fn_callee(bcx, trans_fn_ref(bcx.ccx(), did, ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs).val)\n+                                            bcx.fcx.param_substs))\n             }\n             def::DefMethod(meth_did, def::FromTrait(trait_did)) => {\n                 fn_callee(bcx, meth::trans_static_method_callee(bcx.ccx(),\n                                                                 meth_did,\n                                                                 trait_did,\n                                                                 ref_expr.id,\n-                                                                bcx.fcx.param_substs).val)\n+                                                                bcx.fcx.param_substs))\n             }\n             def::DefVariant(tid, vid, _) => {\n                 let vinfo = bcx.tcx().enum_variant_with_id(tid, vid);\n-                let substs = common::node_id_substs(bcx.ccx(),\n-                                                    ExprId(ref_expr.id),\n-                                                    bcx.fcx.param_substs);\n \n                 // Nullary variants are not callable\n                 assert!(!vinfo.args.is_empty());\n \n                 Callee {\n                     bcx: bcx,\n-                    data: NamedTupleConstructor(substs, vinfo.disr_val)\n+                    data: NamedTupleConstructor(vinfo.disr_val),\n+                    ty: expr_ty\n                 }\n             }\n             def::DefStruct(_) => {\n-                let substs = common::node_id_substs(bcx.ccx(),\n-                                                    ExprId(ref_expr.id),\n-                                                    bcx.fcx.param_substs);\n                 Callee {\n                     bcx: bcx,\n-                    data: NamedTupleConstructor(substs, 0)\n+                    data: NamedTupleConstructor(0),\n+                    ty: expr_ty\n                 }\n             }\n             def::DefStatic(..) |\n@@ -232,21 +227,6 @@ pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     trans_fn_ref_with_substs(ccx, def_id, node, param_substs, substs)\n }\n \n-fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                  def_id: ast::DefId,\n-                                                  ref_id: ast::NodeId,\n-                                                  substs: subst::Substs<'tcx>)\n-                                                  -> Callee<'blk, 'tcx> {\n-    Callee {\n-        bcx: bcx,\n-        data: Fn(trans_fn_ref_with_substs(bcx.ccx(),\n-                                          def_id,\n-                                          ExprId(ref_id),\n-                                          bcx.fcx.param_substs,\n-                                          substs).val),\n-    }\n-}\n-\n /// Translates an adapter that implements the `Fn` trait for a fn\n /// pointer. This is basically the equivalent of something like:\n ///\n@@ -356,12 +336,13 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\"))\n     );\n \n-    bcx = trans_call_inner(bcx,\n-                           DebugLoc::None,\n-                           bare_fn_ty,\n-                           |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n-                           ArgVals(&llargs[(self_idx + 1)..]),\n-                           dest).bcx;\n+    bcx = trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n+        Callee {\n+            bcx: bcx,\n+            data: Fn(llfnpointer),\n+            ty: bare_fn_ty\n+        }\n+    }, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n@@ -586,17 +567,16 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call<'a, 'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n+pub fn trans_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   call_expr: &ast::Expr,\n                                   f: &ast::Expr,\n                                   args: CallArgs<'a, 'tcx>,\n                                   dest: expr::Dest)\n                                   -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_call\");\n-    trans_call_inner(in_cx,\n+    trans_call_inner(bcx,\n                      call_expr.debug_loc(),\n-                     common::expr_ty_adjusted(in_cx, f),\n-                     |cx, _| trans(cx, f),\n+                     |bcx, _| trans(bcx, f),\n                      args,\n                      Some(dest)).bcx\n }\n@@ -610,22 +590,9 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_expr={:?})\", call_expr);\n     let method_call = MethodCall::expr(call_expr.id);\n-    let method_ty = match bcx.tcx().tables.borrow().method_map.get(&method_call) {\n-        Some(method) => match method.origin {\n-            ty::MethodOrigin::Object(_) => match method.ty.sty {\n-                ty::TyBareFn(_, ref fty) => {\n-                    bcx.tcx().mk_fn(None, meth::opaque_method_ty(bcx.tcx(), fty))\n-                }\n-                _ => method.ty\n-            },\n-            _ => method.ty\n-        },\n-        None => panic!(\"method not found in trans_method_call\")\n-    };\n     trans_call_inner(\n         bcx,\n         call_expr.debug_loc(),\n-        common::monomorphize_type(bcx, method_ty),\n         |cx, arg_cleanup_scope| {\n             meth::trans_method_callee(cx, method_call, Some(rcvr), arg_cleanup_scope)\n         },\n@@ -639,22 +606,18 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    dest: Option<expr::Dest>,\n                                    debug_loc: DebugLoc)\n                                    -> Result<'blk, 'tcx> {\n-    let fty = if did.krate == ast::LOCAL_CRATE {\n-        bcx.tcx().node_id_to_type(did.node)\n-    } else {\n-        csearch::get_type(bcx.tcx(), did).ty\n-    };\n-    callee::trans_call_inner(bcx,\n-                             debug_loc,\n-                             fty,\n-                             |bcx, _| {\n-                                trans_fn_ref_with_substs_to_callee(bcx,\n-                                                                   did,\n-                                                                   0,\n-                                                                   subst::Substs::trans_empty())\n-                             },\n-                             ArgVals(args),\n-                             dest)\n+    callee::trans_call_inner(bcx, debug_loc, |bcx, _| {\n+        let datum = trans_fn_ref_with_substs(bcx.ccx(),\n+                                             did,\n+                                             ExprId(0),\n+                                             bcx.fcx.param_substs,\n+                                             subst::Substs::trans_empty());\n+        Callee {\n+            bcx: bcx,\n+            data: Fn(datum.val),\n+            ty: datum.ty\n+        }\n+    }, ArgVals(args), dest)\n }\n \n /// This behemoth of a function translates function calls. Unfortunately, in order to generate more\n@@ -669,7 +632,6 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// somewhere. Nonetheless we return the actual return value of the function.\n pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                            debug_loc: DebugLoc,\n-                                           callee_ty: Ty<'tcx>,\n                                            get_callee: F,\n                                            args: CallArgs<'a, 'tcx>,\n                                            dest: Option<expr::Dest>)\n@@ -690,7 +652,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let callee = get_callee(bcx, cleanup::CustomScope(arg_cleanup_scope));\n     let mut bcx = callee.bcx;\n \n-    let (abi, ret_ty) = match callee_ty.sty {\n+    let (abi, ret_ty) = match callee.ty.sty {\n         ty::TyBareFn(_, ref f) => {\n             let output = bcx.tcx().erase_late_bound_regions(&f.sig.output());\n             (f.abi, output)\n@@ -716,18 +678,17 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                 }\n             };\n \n-            return intrinsic::trans_intrinsic_call(bcx, node, callee_ty,\n+            return intrinsic::trans_intrinsic_call(bcx, node, callee.ty,\n                                                    arg_cleanup_scope, args,\n                                                    dest.unwrap(), substs,\n                                                    call_info);\n         }\n-        NamedTupleConstructor(substs, disr) => {\n+        NamedTupleConstructor(disr) => {\n             assert!(dest.is_some());\n             fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n \n-            let ctor_ty = callee_ty.subst(bcx.tcx(), &substs);\n             return base::trans_named_tuple_constructor(bcx,\n-                                                       ctor_ty,\n+                                                       callee.ty,\n                                                        disr,\n                                                        args,\n                                                        dest.unwrap(),\n@@ -802,7 +763,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         // Push the arguments.\n         bcx = trans_args(bcx,\n                          args,\n-                         callee_ty,\n+                         callee.ty,\n                          &mut llargs,\n                          cleanup::CustomScope(arg_cleanup_scope),\n                          llself.is_some(),\n@@ -814,7 +775,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         let (llret, b) = base::invoke(bcx,\n                                       llfn,\n                                       &llargs[..],\n-                                      callee_ty,\n+                                      callee.ty,\n                                       debug_loc);\n         bcx = b;\n         llresult = llret;\n@@ -843,15 +804,15 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         };\n         bcx = trans_args(bcx,\n                          args,\n-                         callee_ty,\n+                         callee.ty,\n                          &mut llargs,\n                          cleanup::CustomScope(arg_cleanup_scope),\n                          false,\n                          abi);\n         fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n         bcx = foreign::trans_native_call(bcx,\n-                                         callee_ty,\n+                                         callee.ty,\n                                          llfn,\n                                          opt_llretslot.unwrap(),\n                                          &llargs[..],"}, {"sha": "d813e9dbf40fab9ca75b4c9d21f04697c9817557", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=96d24a5c58718fbd1800fb56a49166a320f65556", "patch": "@@ -429,12 +429,13 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let callee_data = TraitItem(MethodData { llfn: llreffn,\n                                              llself: env_datum.val });\n \n-    bcx = callee::trans_call_inner(bcx,\n-                                   DebugLoc::None,\n-                                   llref_fn_ty,\n-                                   |bcx, _| Callee { bcx: bcx, data: callee_data },\n-                                   ArgVals(&llargs[(self_idx + 1)..]),\n-                                   dest).bcx;\n+    bcx = callee::trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n+        Callee {\n+            bcx: bcx,\n+            data: callee_data,\n+            ty: llref_fn_ty\n+        }\n+    }, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n \n     fcx.pop_custom_cleanup_scope(self_scope);\n "}, {"sha": "7722cb322c9e6e59f9b6829fa780c1b007063f33", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=96d24a5c58718fbd1800fb56a49166a320f65556", "patch": "@@ -1947,15 +1947,8 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    dest: Option<Dest>,\n                                    autoref: bool)\n                                    -> Result<'blk, 'tcx> {\n-    let method_ty = bcx.tcx()\n-                       .tables\n-                       .borrow()\n-                       .method_map\n-                       .get(&method_call).unwrap().ty;\n-\n     callee::trans_call_inner(bcx,\n                              expr.debug_loc(),\n-                             monomorphize_type(bcx, method_ty),\n                              |bcx, arg_cleanup_scope| {\n                                 meth::trans_method_callee(bcx,\n                                                           method_call,\n@@ -1974,20 +1967,11 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                          -> Block<'blk, 'tcx> {\n     debug!(\"trans_overloaded_call {}\", expr.id);\n     let method_call = MethodCall::expr(expr.id);\n-    let method_type = bcx.tcx()\n-                         .tables\n-                         .borrow()\n-                         .method_map\n-                         .get(&method_call)\n-                         .unwrap()\n-                         .ty;\n     let mut all_args = vec!(callee);\n     all_args.extend(args.iter().map(|e| &**e));\n     unpack_result!(bcx,\n                    callee::trans_call_inner(bcx,\n                                             expr.debug_loc(),\n-                                            monomorphize_type(bcx,\n-                                                              method_type),\n                                             |bcx, arg_cleanup_scope| {\n                                                 meth::trans_method_callee(\n                                                     bcx,"}, {"sha": "ece5682c6ba9bc30459552afa422a7231412c8c6", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 80, "deletions": 94, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=96d24a5c58718fbd1800fb56a49166a320f65556", "patch": "@@ -39,7 +39,6 @@ use trans::type_of::*;\n use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::MethodCall;\n \n-use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n use syntax::{ast, attr, visit};\n use syntax::codemap::DUMMY_SP;\n@@ -119,12 +118,14 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match origin {\n         ty::MethodOrigin::Inherent => {\n             debug!(\"trans_method_callee: static, {:?}\", method_id);\n+            let datum = callee::trans_fn_ref(bcx.ccx(),\n+                                             method_id,\n+                                             MethodCallKey(method_call),\n+                                             bcx.fcx.param_substs);\n             Callee {\n                 bcx: bcx,\n-                data: Fn(callee::trans_fn_ref(bcx.ccx(),\n-                                              method_id,\n-                                              MethodCallKey(method_call),\n-                                              bcx.fcx.param_substs).val),\n+                data: Fn(datum.val),\n+                ty: datum.ty\n             }\n         }\n \n@@ -149,26 +150,27 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             debug!(\"origin = {:?}\", origin);\n             trans_monomorphized_callee(bcx,\n                                        method_call,\n+                                       self_expr,\n                                        trait_def_id,\n                                        method_id,\n-                                       origin)\n+                                       method_ty,\n+                                       origin,\n+                                       arg_cleanup_scope)\n         }\n+    }\n+}\n \n-        ty::MethodOrigin::Object(vtable_index) => {\n-            let self_expr = match self_expr {\n-                Some(self_expr) => self_expr,\n-                None => {\n-                    bcx.sess().span_bug(bcx.tcx().map.span(method_call.expr_id),\n-                                        \"self expr wasn't provided for trait object \\\n-                                         callee (trying to call overloaded op?)\")\n-                }\n-            };\n-            trans_trait_callee(bcx,\n-                               monomorphize_type(bcx, method_ty),\n-                               vtable_index,\n-                               self_expr,\n-                               arg_cleanup_scope)\n-        }\n+fn method_offset_in_object_vtable<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                        object_ty: Ty<'tcx>,\n+                                        method_id: ast::DefId)\n+                                        -> usize {\n+    if let ty::TyTrait(ref data) = object_ty.sty {\n+        let trait_ref = data.principal_trait_ref_with_self_ty(tcx, object_ty);\n+        traits::get_vtable_index_of_object_method(tcx, trait_ref, method_id)\n+    } else {\n+        tcx.sess.bug(&format!(\n+            \"trans::methd::object_ty_to_trait_ref() called on non-object: {:?}\",\n+            object_ty));\n     }\n }\n \n@@ -237,8 +239,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                              Vec::new()));\n     let trait_substs = tcx.mk_substs(trait_substs);\n     debug!(\"trait_substs={:?}\", trait_substs);\n-    let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n-                                              substs: trait_substs });\n+    let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, trait_substs));\n     let vtbl = fulfill_obligation(ccx,\n                                   DUMMY_SP,\n                                   trait_ref);\n@@ -284,12 +285,11 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      callee_substs)\n         }\n         traits::VtableObject(ref data) => {\n-            let (llfn, ty) =\n-                trans_object_shim(ccx,\n-                                  data.object_ty,\n-                                  data.upcast_trait_ref.clone(),\n-                                  method_id);\n-            immediate_rvalue(llfn, ty)\n+            let idx = method_offset_in_object_vtable(tcx, data.object_ty, method_id);\n+            trans_object_shim(ccx,\n+                              data.upcast_trait_ref.clone(),\n+                              method_id,\n+                              idx)\n         }\n         _ => {\n             tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\",\n@@ -322,9 +322,12 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n \n fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           method_call: MethodCall,\n+                                          self_expr: Option<&ast::Expr>,\n                                           trait_id: ast::DefId,\n                                           method_id: ast::DefId,\n-                                          vtable: traits::Vtable<'tcx, ()>)\n+                                          method_ty: Ty<'tcx>,\n+                                          vtable: traits::Vtable<'tcx, ()>,\n+                                          arg_cleanup_scope: cleanup::ScopeId)\n                                           -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n     match vtable {\n@@ -347,13 +350,13 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     bcx, MethodCallKey(method_call), vtable_impl.substs);\n \n             // translate the function\n-            let llfn = trans_fn_ref_with_substs(bcx.ccx(),\n-                                                mth_id,\n-                                                MethodCallKey(method_call),\n-                                                bcx.fcx.param_substs,\n-                                                callee_substs).val;\n+            let datum = trans_fn_ref_with_substs(bcx.ccx(),\n+                                                 mth_id,\n+                                                 MethodCallKey(method_call),\n+                                                 bcx.fcx.param_substs,\n+                                                 callee_substs);\n \n-            Callee { bcx: bcx, data: Fn(llfn) }\n+            Callee { bcx: bcx, data: Fn(datum.val), ty: datum.ty }\n         }\n         traits::VtableClosure(vtable_closure) => {\n             // The substitutions should have no type parameters remaining\n@@ -368,19 +371,31 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             Callee {\n                 bcx: bcx,\n                 data: Fn(llfn),\n+                ty: monomorphize_type(bcx, method_ty)\n             }\n         }\n         traits::VtableFnPointer(fn_ty) => {\n             let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n             let llfn = trans_fn_pointer_shim(bcx.ccx(), trait_closure_kind, fn_ty);\n-            Callee { bcx: bcx, data: Fn(llfn) }\n+            Callee {\n+                bcx: bcx,\n+                data: Fn(llfn),\n+                ty: monomorphize_type(bcx, method_ty)\n+            }\n         }\n         traits::VtableObject(ref data) => {\n-            let (llfn, _) = trans_object_shim(bcx.ccx(),\n-                                              data.object_ty,\n-                                              data.upcast_trait_ref.clone(),\n-                                              method_id);\n-            Callee { bcx: bcx, data: Fn(llfn) }\n+            let idx = method_offset_in_object_vtable(bcx.tcx(), data.object_ty, method_id);\n+            if let Some(self_expr) = self_expr {\n+                if let ty::TyBareFn(_, ref fty) = monomorphize_type(bcx, method_ty).sty {\n+                    let ty = bcx.tcx().mk_fn(None, opaque_method_ty(bcx.tcx(), fty));\n+                    return trans_trait_callee(bcx, ty, idx, self_expr, arg_cleanup_scope);\n+                }\n+            }\n+            let datum = trans_object_shim(bcx.ccx(),\n+                                          data.upcast_trait_ref.clone(),\n+                                          method_id,\n+                                          idx);\n+            Callee { bcx: bcx, data: Fn(datum.val), ty: datum.ty }\n         }\n         traits::VtableBuiltin(..) |\n         traits::VtableDefaultImpl(..) |\n@@ -434,7 +449,7 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// object. Objects are represented as a pair, so we first evaluate the self expression and then\n /// extract the self data and vtable out of the pair.\n fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  method_ty: Ty<'tcx>,\n+                                  opaque_fn_ty: Ty<'tcx>,\n                                   vtable_index: usize,\n                                   self_expr: &ast::Expr,\n                                   arg_cleanup_scope: cleanup::ScopeId)\n@@ -467,51 +482,39 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let llself = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_ADDR]));\n     let llvtable = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_EXTRA]));\n-    trans_trait_callee_from_llval(bcx, method_ty, vtable_index, llself, llvtable)\n+    trans_trait_callee_from_llval(bcx, opaque_fn_ty, vtable_index, llself, llvtable)\n }\n \n /// Same as `trans_trait_callee()` above, except that it is given a by-ref pointer to the object\n /// pair.\n-pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                 callee_ty: Ty<'tcx>,\n-                                                 vtable_index: usize,\n-                                                 llself: ValueRef,\n-                                                 llvtable: ValueRef)\n-                                                 -> Callee<'blk, 'tcx> {\n+fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                             opaque_fn_ty: Ty<'tcx>,\n+                                             vtable_index: usize,\n+                                             llself: ValueRef,\n+                                             llvtable: ValueRef)\n+                                             -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_trait_callee\");\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n     debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llself={}, llvtable={})\",\n-           callee_ty,\n+           opaque_fn_ty,\n            vtable_index,\n            bcx.val_to_string(llself),\n            bcx.val_to_string(llvtable));\n \n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n-    let llcallee_ty = match callee_ty.sty {\n-        ty::TyBareFn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n-            let fake_sig =\n-                ty::Binder(ty::FnSig {\n-                    inputs: f.sig.0.inputs[1..].to_vec(),\n-                    output: f.sig.0.output,\n-                    variadic: f.sig.0.variadic,\n-                });\n-            type_of_rust_fn(ccx, Some(Type::i8p(ccx)), &fake_sig, f.abi)\n-        }\n-        _ => {\n-            ccx.sess().bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n-        }\n-    };\n     let mptr = Load(bcx, GEPi(bcx, llvtable, &[vtable_index + VTABLE_OFFSET]));\n+    let llcallee_ty = type_of_fn_from_ty(ccx, opaque_fn_ty);\n \n-    return Callee {\n+    Callee {\n         bcx: bcx,\n         data: TraitItem(MethodData {\n             llfn: PointerCast(bcx, mptr, llcallee_ty.ptr_to()),\n             llself: PointerCast(bcx, llself, Type::i8p(ccx)),\n-        })\n-    };\n+        }),\n+        ty: opaque_fn_ty\n+    }\n }\n \n /// Generate a shim function that allows an object type like `SomeTrait` to\n@@ -538,30 +541,18 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// that go through this shim function.\n fn trans_object_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n-    object_ty: Ty<'tcx>,\n     upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-    method_id: ast::DefId)\n-    -> (ValueRef, Ty<'tcx>)\n+    method_id: ast::DefId,\n+    vtable_index: usize)\n+    -> Datum<'tcx, Rvalue>\n {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_object_shim(object_ty={:?}, upcast_trait_ref={:?}, method_id={:?})\",\n-           object_ty,\n+    debug!(\"trans_object_shim(upcast_trait_ref={:?}, method_id={:?})\",\n            upcast_trait_ref,\n            method_id);\n \n-    let object_trait_ref =\n-        match object_ty.sty {\n-            ty::TyTrait(ref data) => {\n-                data.principal_trait_ref_with_self_ty(tcx, object_ty)\n-            }\n-            _ => {\n-                tcx.sess.bug(&format!(\"trans_object_shim() called on non-object: {:?}\",\n-                                      object_ty));\n-            }\n-        };\n-\n     // Upcast to the trait in question and extract out the substitutions.\n     let upcast_trait_ref = tcx.erase_late_bound_regions(&upcast_trait_ref);\n     let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n@@ -617,26 +608,21 @@ fn trans_object_shim<'a, 'tcx>(\n         fcx.llretslotptr.get().map(\n             |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n \n-    let method_offset_in_vtable =\n-        traits::get_vtable_index_of_object_method(bcx.tcx(),\n-                                                  object_trait_ref.clone(),\n-                                                  method_id);\n     debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n-           method_offset_in_vtable);\n+           vtable_index);\n \n     bcx = trans_call_inner(bcx,\n                            DebugLoc::None,\n-                           method_bare_fn_ty,\n                            |bcx, _| trans_trait_callee_from_llval(bcx,\n                                                                   method_bare_fn_ty,\n-                                                                  method_offset_in_vtable,\n+                                                                  vtable_index,\n                                                                   llself, llvtable),\n                            ArgVals(&llargs[(self_idx + 2)..]),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n-    (llfn, method_bare_fn_ty)\n+    immediate_rvalue(llfn, shim_fn_ty)\n }\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n@@ -819,8 +805,8 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n /// Replace the self type (&Self or Box<Self>) with an opaque pointer.\n-pub fn opaque_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n-        -> &'tcx ty::BareFnTy<'tcx> {\n+fn opaque_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n+                          -> &'tcx ty::BareFnTy<'tcx> {\n     let mut inputs = method_ty.sig.0.inputs.clone();\n     inputs[0] = tcx.mk_mut_ptr(tcx.mk_mach_int(ast::TyI8));\n "}, {"sha": "98fe57ec31446f6cfac18a613707bd4f7d6e1fd0", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=96d24a5c58718fbd1800fb56a49166a320f65556", "patch": "@@ -59,7 +59,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let item_ty = ccx.tcx().lookup_item_type(fn_id).ty;\n \n     debug!(\"monomorphic_fn about to subst into {:?}\", item_ty);\n-    let mono_ty = item_ty.subst(ccx.tcx(), psubsts);\n+    let mono_ty = apply_param_substs(ccx.tcx(), psubsts, &item_ty);\n+    debug!(\"mono_ty = {:?} (post-substitution)\", mono_ty);\n \n     match ccx.monomorphized().borrow().get(&hash_id) {\n         Some(&val) => {\n@@ -96,11 +97,6 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    debug!(\"mono_ty = {:?} (post-substitution)\", mono_ty);\n-\n-    let mono_ty = normalize_associated_type(ccx.tcx(), &mono_ty);\n-    debug!(\"mono_ty = {:?} (post-normalization)\", mono_ty);\n-\n     ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n \n     let depth;"}, {"sha": "625db8d8128c07cc105077a494c90242f04a0d25", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d24a5c58718fbd1800fb56a49166a320f65556/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=96d24a5c58718fbd1800fb56a49166a320f65556", "patch": "@@ -230,11 +230,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                            trait_def_id);\n                     let substs = upcast_trait_ref.substs.clone();\n \n-                    let vtable_index =\n-                        traits::get_vtable_index_of_object_method(this.tcx(),\n-                                                                  original_poly_trait_ref,\n-                                                                  pick.item.def_id());\n-                    (substs, ty::MethodOrigin::Object(vtable_index))\n+                    (substs, ty::MethodOrigin::Trait)\n                 })\n             }\n "}]}