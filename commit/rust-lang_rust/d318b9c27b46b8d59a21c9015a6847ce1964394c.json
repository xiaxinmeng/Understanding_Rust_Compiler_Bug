{"sha": "d318b9c27b46b8d59a21c9015a6847ce1964394c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMThiOWMyN2I0NmI4ZDU5YTIxYzkwMTVhNjg0N2NlMTk2NDM5NGM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-16T13:39:53Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:30Z"}, "message": "rustc: move CEnum's signedness into Primitive::Int.", "tree": {"sha": "94759573088619c691dd939b22c7f7b1e1692497", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94759573088619c691dd939b22c7f7b1e1692497"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d318b9c27b46b8d59a21c9015a6847ce1964394c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d318b9c27b46b8d59a21c9015a6847ce1964394c", "html_url": "https://github.com/rust-lang/rust/commit/d318b9c27b46b8d59a21c9015a6847ce1964394c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d318b9c27b46b8d59a21c9015a6847ce1964394c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61c2bd9ca457d421d2388136d40194ac9b9eb477", "url": "https://api.github.com/repos/rust-lang/rust/commits/61c2bd9ca457d421d2388136d40194ac9b9eb477", "html_url": "https://github.com/rust-lang/rust/commit/61c2bd9ca457d421d2388136d40194ac9b9eb477"}], "stats": {"total": 145, "additions": 65, "deletions": 80}, "files": [{"sha": "c7a49b7ae0ae6fb6a62589947b239df83b73a593", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d318b9c27b46b8d59a21c9015a6847ce1964394c", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'tcx> Integer {\n \n         let wanted = align.abi();\n         for &candidate in &[I8, I16, I32, I64] {\n-            let ty = Int(candidate);\n+            let ty = Int(candidate, false);\n             if wanted == ty.align(dl).abi() && wanted == ty.size(dl).bytes() {\n                 return Some(candidate);\n             }\n@@ -577,7 +577,14 @@ impl<'a, 'tcx> Integer {\n /// Fundamental unit of memory access and layout.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Primitive {\n-    Int(Integer),\n+    /// The `bool` is the signedness of the `Integer` type.\n+    ///\n+    /// One would think we would not care about such details this low down,\n+    /// but some ABIs are described in terms of C types and ISAs where the\n+    /// integer arithmetic is done on {sign,zero}-extended registers, e.g.\n+    /// a negative integer passed by zero-extension will appear positive in\n+    /// the callee, and most operations on it will produce the wrong values.\n+    Int(Integer, bool),\n     F32,\n     F64,\n     Pointer\n@@ -588,11 +595,9 @@ impl<'a, 'tcx> Primitive {\n         let dl = cx.data_layout();\n \n         match self {\n-            Int(I1) | Int(I8) => Size::from_bits(8),\n-            Int(I16) => Size::from_bits(16),\n-            Int(I32) | F32 => Size::from_bits(32),\n-            Int(I64) | F64 => Size::from_bits(64),\n-            Int(I128) => Size::from_bits(128),\n+            Int(i, _) => i.size(),\n+            F32 => Size::from_bits(32),\n+            F64 => Size::from_bits(64),\n             Pointer => dl.pointer_size\n         }\n     }\n@@ -601,12 +606,7 @@ impl<'a, 'tcx> Primitive {\n         let dl = cx.data_layout();\n \n         match self {\n-            Int(I1) => dl.i1_align,\n-            Int(I8) => dl.i8_align,\n-            Int(I16) => dl.i16_align,\n-            Int(I32) => dl.i32_align,\n-            Int(I64) => dl.i64_align,\n-            Int(I128) => dl.i128_align,\n+            Int(i, _) => i.align(dl),\n             F32 => dl.f32_align,\n             F64 => dl.f64_align,\n             Pointer => dl.pointer_align\n@@ -615,7 +615,7 @@ impl<'a, 'tcx> Primitive {\n \n     pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n-            Int(i) => i.to_ty(tcx, false),\n+            Int(i, signed) => i.to_ty(tcx, signed),\n             F32 => tcx.types.f32,\n             F64 => tcx.types.f64,\n             Pointer => tcx.mk_mut_ptr(tcx.mk_nil()),\n@@ -1098,7 +1098,6 @@ pub enum Layout {\n     /// C-like enums; basically an integer.\n     CEnum {\n         discr: Primitive,\n-        signed: bool,\n         /// Inclusive discriminant range.\n         /// If min > max, it represents min...u64::MAX followed by 0...max.\n         // FIXME(eddyb) always use the shortest range, e.g. by finding\n@@ -1287,7 +1286,7 @@ impl<'a, 'tcx> Layout {\n                 let metadata = match unsized_part.sty {\n                     ty::TyForeign(..) => return Ok(Scalar(Pointer)),\n                     ty::TySlice(_) | ty::TyStr => {\n-                        Int(dl.ptr_sized_integer())\n+                        Int(dl.ptr_sized_integer(), false)\n                     }\n                     ty::TyDynamic(..) => Pointer,\n                     _ => return Err(LayoutError::Unknown(unsized_part))\n@@ -1298,13 +1297,13 @@ impl<'a, 'tcx> Layout {\n \n         let layout = match ty.sty {\n             // Basic scalars.\n-            ty::TyBool => Scalar(Int(I1)),\n-            ty::TyChar => Scalar(Int(I32)),\n+            ty::TyBool => Scalar(Int(I1, false)),\n+            ty::TyChar => Scalar(Int(I32, false)),\n             ty::TyInt(ity) => {\n-                Scalar(Int(Integer::from_attr(dl, attr::SignedInt(ity))))\n+                Scalar(Int(Integer::from_attr(dl, attr::SignedInt(ity)), true))\n             }\n             ty::TyUint(ity) => {\n-                Scalar(Int(Integer::from_attr(dl, attr::UnsignedInt(ity))))\n+                Scalar(Int(Integer::from_attr(dl, attr::UnsignedInt(ity)), false))\n             }\n             ty::TyFloat(FloatTy::F32) => Scalar(F32),\n             ty::TyFloat(FloatTy::F64) => Scalar(F64),\n@@ -1453,8 +1452,7 @@ impl<'a, 'tcx> Layout {\n                     // grok.\n                     let (discr, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n                     return success(CEnum {\n-                        discr: Int(discr),\n-                        signed,\n+                        discr: Int(discr, signed),\n                         // FIXME: should be u128?\n                         min: min as u64,\n                         max: max as u64\n@@ -1629,8 +1627,8 @@ impl<'a, 'tcx> Layout {\n                     ity = min_ity;\n                 } else {\n                     // Patch up the variants' first few fields.\n-                    let old_ity_size = Int(min_ity).size(dl);\n-                    let new_ity_size = Int(ity).size(dl);\n+                    let old_ity_size = min_ity.size();\n+                    let new_ity_size = ity.size();\n                     for variant in &mut variants {\n                         for i in variant.offsets.iter_mut() {\n                             if *i <= old_ity_size {\n@@ -1646,7 +1644,7 @@ impl<'a, 'tcx> Layout {\n                 }\n \n                 General {\n-                    discr: Int(ity),\n+                    discr: Int(ity, false),\n                     variants,\n                     size,\n                     align,\n@@ -2417,9 +2415,8 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout\n             FatPointer(ref metadata) => {\n                 metadata.hash_stable(hcx, hasher);\n             }\n-            CEnum { discr, signed, min, max } => {\n+            CEnum { discr, min, max } => {\n                 discr.hash_stable(hcx, hasher);\n-                signed.hash_stable(hcx, hasher);\n                 min.hash_stable(hcx, hasher);\n                 max.hash_stable(hcx, hasher);\n             }\n@@ -2505,7 +2502,7 @@ impl_stable_hash_for!(enum ::ty::layout::Integer {\n });\n \n impl_stable_hash_for!(enum ::ty::layout::Primitive {\n-    Int(integer),\n+    Int(integer, signed),\n     F32,\n     F64,\n     Pointer"}, {"sha": "93cfd967643f34a9a042858aa230bf7268c724f4", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=d318b9c27b46b8d59a21c9015a6847ce1964394c", "patch": "@@ -288,7 +288,7 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n             // The primitive for this algorithm.\n             layout::Abi::Scalar(value) => {\n                 let kind = match value {\n-                    layout::Int(_) |\n+                    layout::Int(..) |\n                     layout::Pointer => RegKind::Integer,\n                     layout::F32 |\n                     layout::F64 => RegKind::Float\n@@ -467,24 +467,18 @@ impl<'a, 'tcx> ArgType<'tcx> {\n \n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n-        let (i, signed) = match *self.layout {\n-            Layout::Scalar(layout::Int(i)) if self.layout.ty.is_integral() => {\n-                (i, self.layout.ty.is_signed())\n+        match self.layout.abi {\n+            layout::Abi::Scalar(layout::Int(i, signed)) => {\n+                if i.size().bits() < bits {\n+                    self.attrs.set(if signed {\n+                        ArgAttribute::SExt\n+                    } else {\n+                        ArgAttribute::ZExt\n+                    });\n+                }\n             }\n \n-            // Rust enum types that map onto C enums also need to follow\n-            // the target ABI zero-/sign-extension rules.\n-            Layout::CEnum { discr: layout::Int(i), signed, .. } => (i, signed),\n-\n-            _ => return\n-        };\n-\n-        if i.size().bits() < bits {\n-            self.attrs.set(if signed {\n-                ArgAttribute::SExt\n-            } else {\n-                ArgAttribute::ZExt\n-            });\n+            _ => {}\n         }\n     }\n "}, {"sha": "de42676a90d1df0641eead164e3580a29c9accf2", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=d318b9c27b46b8d59a21c9015a6847ce1964394c", "patch": "@@ -230,9 +230,3 @@ pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     result\n }\n \n-pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n-    match *l {\n-        layout::CEnum { signed, .. }=> signed,\n-        _ => false,\n-    }\n-}"}, {"sha": "f2208e4909e02af633c2112292b5844a057bd50b", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=d318b9c27b46b8d59a21c9015a6847ce1964394c", "patch": "@@ -67,7 +67,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n         match layout.abi {\n             layout::Abi::Scalar(value) => {\n                 let reg = match value {\n-                    layout::Int(_) |\n+                    layout::Int(..) |\n                     layout::Pointer => Class::Int,\n                     layout::F32 |\n                     layout::F64 => Class::Sse"}, {"sha": "aad6f3446ee377950fd7bb8da56ba66fd1728291", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=d318b9c27b46b8d59a21c9015a6847ce1964394c", "patch": "@@ -1451,7 +1451,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n         .collect();\n \n-    let discriminant_type_metadata = |discr: layout::Primitive, signed: bool| {\n+    let discriminant_type_metadata = |discr: layout::Primitive| {\n         let disr_type_key = (enum_def_id, discr);\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n                                                                  .borrow()\n@@ -1462,12 +1462,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let (discriminant_size, discriminant_align) =\n                     (discr.size(cx), discr.align(cx));\n                 let discriminant_base_type_metadata =\n-                    type_metadata(cx,\n-                                  match discr {\n-                                    layout::Int(i) => i.to_ty(cx.tcx(), signed),\n-                                    _ => discr.to_ty(cx.tcx())\n-                                  },\n-                                  syntax_pos::DUMMY_SP);\n+                    type_metadata(cx, discr.to_ty(cx.tcx()), syntax_pos::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n                 let name = CString::new(discriminant_name.as_bytes()).unwrap();\n@@ -1496,11 +1491,11 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let type_rep = cx.layout_of(enum_type);\n \n     let discriminant_type_metadata = match *type_rep {\n-        layout::CEnum { discr, signed, .. } => {\n-            return FinalMetadata(discriminant_type_metadata(discr, signed))\n+        layout::CEnum { discr, .. } => {\n+            return FinalMetadata(discriminant_type_metadata(discr))\n         },\n         layout::NullablePointer { .. } | layout::Univariant { .. } => None,\n-        layout::General { discr, .. } => Some(discriminant_type_metadata(discr, false)),\n+        layout::General { discr, .. } => Some(discriminant_type_metadata(discr)),\n         ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n     };\n "}, {"sha": "c677352c2789750a30f8a414a9d403b35a5f556c", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=d318b9c27b46b8d59a21c9015a6847ce1964394c", "patch": "@@ -23,7 +23,7 @@ use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc_apfloat::{ieee, Float, Status};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use {adt, base};\n+use base;\n use abi::{self, Abi};\n use callee;\n use builder::Builder;\n@@ -683,11 +683,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                         let ll_t_out = self.ccx.immediate_llvm_type_of(cast_ty);\n                         let llval = operand.llval;\n-                        let signed = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n-                            let l = self.ccx.layout_of(operand.ty);\n-                            adt::is_discr_signed(&l)\n-                        } else {\n-                            operand.ty.is_signed()\n+                        let signed = match self.ccx.layout_of(operand.ty).abi {\n+                            layout::Abi::Scalar(layout::Int(_, signed)) => signed,\n+                            _ => false\n                         };\n \n                         unsafe {"}, {"sha": "4ad6e985e7aa1b64516ec8514afdf06743599828", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=d318b9c27b46b8d59a21c9015a6847ce1964394c", "patch": "@@ -352,7 +352,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n     /// Helper for cases where the discriminant is simply loaded.\n     fn load_discr(self, bcx: &Builder, discr: layout::Primitive, min: u64, max: u64) -> ValueRef {\n-        if let layout::Int(ity) = discr {\n+        if let layout::Int(ity, _) = discr {\n             let bits = ity.size().bits();\n             assert!(bits <= 64);\n             let bits = bits as usize;\n@@ -380,25 +380,30 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let l = bcx.ccx.layout_of(self.ty.to_ty(bcx.tcx()));\n \n         let cast_to = bcx.ccx.immediate_llvm_type_of(cast_to);\n-        let val = match *l {\n+        let (val, discr) = match *l {\n             layout::Univariant { .. } |\n             layout::UntaggedUnion { .. } => return C_uint(cast_to, 0),\n             layout::CEnum { discr, min, max, .. } => {\n-                self.load_discr(bcx, discr, min, max)\n+                (self.load_discr(bcx, discr, min, max), discr)\n             }\n             layout::General { discr, ref variants, .. } => {\n                 let ptr = self.project_field(bcx, 0);\n-                ptr.load_discr(bcx, discr, 0, variants.len() as u64 - 1)\n+                (ptr.load_discr(bcx, discr, 0, variants.len() as u64 - 1), discr)\n             }\n             layout::NullablePointer { nndiscr, .. } => {\n                 let ptr = self.project_field(bcx, 0);\n                 let lldiscr = bcx.load(ptr.llval, ptr.alignment.non_abi());\n                 let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n-                bcx.icmp(cmp, lldiscr, C_null(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx()))))\n+                (bcx.icmp(cmp, lldiscr, C_null(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx())))),\n+                 layout::Int(layout::I1, false))\n             },\n             _ => bug!(\"{} is not an enum\", l.ty)\n         };\n-        bcx.intcast(val, cast_to, adt::is_discr_signed(&l))\n+        let signed = match discr {\n+            layout::Int(_, signed) => signed,\n+            _ => false\n+        };\n+        bcx.intcast(val, cast_to, signed)\n     }\n \n     /// Set the discriminant for a new value of the given case of the given"}, {"sha": "b931d9a2549018624ec80bcb8bcf290fa75f1be5", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d318b9c27b46b8d59a21c9015a6847ce1964394c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=d318b9c27b46b8d59a21c9015a6847ce1964394c", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::layout::{Layout, LayoutOf};\n+use rustc::ty::layout::{self, Layout, LayoutOf};\n use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n@@ -276,7 +276,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let ll_t_out = bcx.ccx.immediate_llvm_type_of(cast_ty);\n                         let llval = operand.immediate();\n                         let l = bcx.ccx.layout_of(operand.ty);\n-                        let signed = if let Layout::CEnum { signed, min, max, .. } = *l {\n+\n+                        if let Layout::CEnum { min, max, .. } = *l {\n                             if max > min {\n                                 // We want `table[e as usize]` to not\n                                 // have bound checks, and this is the most\n@@ -285,13 +286,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 base::call_assume(&bcx, bcx.icmp(\n                                     llvm::IntULE,\n                                     llval,\n-                                    C_uint(common::val_ty(llval), max)\n+                                    C_uint(ll_t_in, max)\n                                 ));\n                             }\n+                        }\n \n-                            signed\n-                        } else {\n-                            operand.ty.is_signed()\n+                        let signed = match l.abi {\n+                            layout::Abi::Scalar(layout::Int(_, signed)) => signed,\n+                            _ => false\n                         };\n \n                         let newval = match (r_t_in, r_t_out) {"}]}