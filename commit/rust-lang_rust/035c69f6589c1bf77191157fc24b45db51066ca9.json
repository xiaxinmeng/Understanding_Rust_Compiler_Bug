{"sha": "035c69f6589c1bf77191157fc24b45db51066ca9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNWM2OWY2NTg5YzFiZjc3MTkxMTU3ZmMyNGI0NWRiNTEwNjZjYTk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-24T13:27:05Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T16:12:49Z"}, "message": "switch validation to use operand, not mplace\n\nthis means we can get rid of the public allocate_op, and make OpTy only\nconstructible in librustc_mir", "tree": {"sha": "1bd128e1845969625accb226e7c798d965e9cca5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bd128e1845969625accb226e7c798d965e9cca5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/035c69f6589c1bf77191157fc24b45db51066ca9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/035c69f6589c1bf77191157fc24b45db51066ca9", "html_url": "https://github.com/rust-lang/rust/commit/035c69f6589c1bf77191157fc24b45db51066ca9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/035c69f6589c1bf77191157fc24b45db51066ca9/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5baea64af47147258a1cad1cc54ebce1524eb83", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5baea64af47147258a1cad1cc54ebce1524eb83", "html_url": "https://github.com/rust-lang/rust/commit/a5baea64af47147258a1cad1cc54ebce1524eb83"}], "stats": {"total": 185, "additions": 84, "deletions": 101}, "files": [{"sha": "ed9d6ca440c01c4cdc314dc9b60f4104dabfef27", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=035c69f6589c1bf77191157fc24b45db51066ca9", "patch": "@@ -1614,21 +1614,15 @@ fn validate_const<'a, 'tcx>(\n     gid: ::rustc::mir::interpret::GlobalId<'tcx>,\n     what: &str,\n ) {\n-    let mut ecx = ::rustc_mir::interpret::mk_eval_cx(tcx, gid.instance, param_env).unwrap();\n+    let ecx = ::rustc_mir::interpret::mk_eval_cx(tcx, gid.instance, param_env).unwrap();\n     let result = (|| {\n-        use rustc_target::abi::LayoutOf;\n-        use rustc_mir::interpret::OpTy;\n-\n-        let op = ecx.const_value_to_op(constant.val)?;\n-        let layout = ecx.layout_of(constant.ty)?;\n-        let place = ecx.allocate_op(OpTy { op, layout })?.into();\n-\n-        let mut todo = vec![(place, Vec::new())];\n+        let op = ecx.const_to_op(constant)?;\n+        let mut todo = vec![(op, Vec::new())];\n         let mut seen = FxHashSet();\n-        seen.insert(place);\n-        while let Some((place, mut path)) = todo.pop() {\n-            ecx.validate_mplace(\n-                place,\n+        seen.insert(op);\n+        while let Some((op, mut path)) = todo.pop() {\n+            ecx.validate_operand(\n+                op,\n                 &mut path,\n                 &mut seen,\n                 &mut todo,"}, {"sha": "5ed8bc875c2a24fc9e0fffe1867ccc38a5a40189", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=035c69f6589c1bf77191157fc24b45db51066ca9", "patch": "@@ -120,13 +120,6 @@ pub fn op_to_const<'tcx>(\n     };\n     Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, op.layout.ty))\n }\n-pub fn const_to_op<'tcx>(\n-    ecx: &mut EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n-    cnst: &'tcx ty::Const<'tcx>,\n-) -> EvalResult<'tcx, OpTy<'tcx>> {\n-    let op = ecx.const_value_to_op(cnst.val)?;\n-    Ok(OpTy { op, layout: ecx.layout_of(cnst.ty)? })\n-}\n \n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -351,10 +344,10 @@ pub fn const_field<'a, 'tcx>(\n     value: &'tcx ty::Const<'tcx>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     trace!(\"const_field: {:?}, {:?}, {:?}\", instance, field, value);\n-    let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let result = (|| {\n         // get the operand again\n-        let op = const_to_op(&mut ecx, value)?;\n+        let op = ecx.const_to_op(value)?;\n         // downcast\n         let down = match variant {\n             None => op,\n@@ -383,8 +376,8 @@ pub fn const_variant_index<'a, 'tcx>(\n     val: &'tcx ty::Const<'tcx>,\n ) -> EvalResult<'tcx, usize> {\n     trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n-    let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n-    let op = const_to_op(&mut ecx, val)?;\n+    let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    let op = ecx.const_to_op(val)?;\n     ecx.read_discriminant_as_variant_index(op)\n }\n "}, {"sha": "8c0cb0b7a4152792cc5ce00867a27ce2482f927b", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=035c69f6589c1bf77191157fc24b45db51066ca9", "patch": "@@ -11,9 +11,10 @@\n //! Functions concerning immediate values and operands, and reading from operands.\n //! All high-level functions to read from memory work on operands as sources.\n \n+use std::hash::{Hash, Hasher};\n use std::convert::TryInto;\n \n-use rustc::mir;\n+use rustc::{mir, ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -150,7 +151,7 @@ impl Operand {\n \n #[derive(Copy, Clone, Debug)]\n pub struct OpTy<'tcx> {\n-    pub op: Operand,\n+    crate op: Operand, // ideally we'd make this private, but we are not there yet\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -182,6 +183,20 @@ impl<'tcx> From<ValTy<'tcx>> for OpTy<'tcx> {\n     }\n }\n \n+// Validation needs to hash OpTy, but we cannot hash Layout -- so we just hash the type\n+impl<'tcx> Hash for OpTy<'tcx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.op.hash(state);\n+        self.layout.ty.hash(state);\n+    }\n+}\n+impl<'tcx> PartialEq for OpTy<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.op == other.op && self.layout.ty == other.layout.ty\n+    }\n+}\n+impl<'tcx> Eq for OpTy<'tcx> {}\n+\n impl<'tcx> OpTy<'tcx> {\n     #[inline]\n     pub fn from_ptr(ptr: Pointer, align: Align, layout: TyLayout<'tcx>) -> Self {\n@@ -492,7 +507,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     // Also used e.g. when miri runs into a constant.\n-    pub fn const_value_to_op(\n+    pub(super) fn const_value_to_op(\n         &self,\n         val: ConstValue<'tcx>,\n     ) -> EvalResult<'tcx, Operand> {\n@@ -516,6 +531,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 Ok(Operand::Immediate(Value::Scalar(x.into()))),\n         }\n     }\n+    pub fn const_to_op(\n+        &self,\n+        cnst: &ty::Const<'tcx>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        let op = self.const_value_to_op(cnst.val)?;\n+        Ok(OpTy { op, layout: self.layout_of(cnst.ty)? })\n+    }\n \n     pub(super) fn global_to_op(&self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, Operand> {\n         let cv = self.const_eval(gid)?;"}, {"sha": "6d8d1a1e8ff4a4cb4c8501eb96aa46938fc51511", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 19, "deletions": 46, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=035c69f6589c1bf77191157fc24b45db51066ca9", "patch": "@@ -12,7 +12,6 @@\n //! into a place.\n //! All high-level functions to write to memory work on places as destinations.\n \n-use std::hash::{Hash, Hasher};\n use std::convert::TryFrom;\n \n use rustc::mir;\n@@ -159,20 +158,6 @@ impl<'tcx> MPlaceTy<'tcx> {\n     }\n }\n \n-// Validation needs to hash MPlaceTy, but we cannot hash Layout -- so we just hash the type\n-impl<'tcx> Hash for MPlaceTy<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.mplace.hash(state);\n-        self.layout.ty.hash(state);\n-    }\n-}\n-impl<'tcx> PartialEq for MPlaceTy<'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.mplace == other.mplace && self.layout.ty == other.layout.ty\n-    }\n-}\n-impl<'tcx> Eq for MPlaceTy<'tcx> {}\n-\n impl<'tcx> OpTy<'tcx> {\n     #[inline(always)]\n     pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx>, Value> {\n@@ -681,20 +666,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         let mplace = match place.place {\n             Place::Local { frame, local } => {\n-                // FIXME: Consider not doing anything for a ZST, and just returning\n-                // a fake pointer?\n-\n-                // We need the layout of the local.  We can NOT use the layout we got,\n-                // that might e.g. be a downcast variant!\n-                let local_layout = self.layout_of_local(frame, local)?;\n-                // Make sure it has a place\n-                let rval = *self.stack[frame].locals[local].access()?;\n-                let mplace = self.allocate_op(OpTy { op: rval, layout: local_layout })?.mplace;\n-                // This might have allocated the flag\n-                *self.stack[frame].locals[local].access_mut()? =\n-                    Operand::Indirect(mplace);\n-                // done\n-                mplace\n+                match *self.stack[frame].locals[local].access()? {\n+                    Operand::Indirect(mplace) => mplace,\n+                    Operand::Immediate(value) => {\n+                        // We need to make an allocation.\n+                        // FIXME: Consider not doing anything for a ZST, and just returning\n+                        // a fake pointer?  Are we even called for ZST?\n+\n+                        // We need the layout of the local.  We can NOT use the layout we got,\n+                        // that might e.g. be a downcast variant!\n+                        let local_layout = self.layout_of_local(frame, local)?;\n+                        let ptr = self.allocate(local_layout, MemoryKind::Stack)?;\n+                        self.write_value_to_mplace(value, ptr)?;\n+                        let mplace = ptr.mplace;\n+                        // Update the local\n+                        *self.stack[frame].locals[local].access_mut()? =\n+                            Operand::Indirect(mplace);\n+                        mplace\n+                    }\n+                }\n             }\n             Place::Ptr(mplace) => mplace\n         };\n@@ -712,23 +702,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n     }\n \n-    /// Make a place for an operand, allocating if needed\n-    pub fn allocate_op(\n-        &mut self,\n-        OpTy { op, layout }: OpTy<'tcx>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n-        trace!(\"allocate_op: {:?}\", op);\n-        Ok(match op {\n-            Operand::Indirect(mplace) => MPlaceTy { mplace, layout },\n-            Operand::Immediate(value) => {\n-                // FIXME: Is stack always right here?\n-                let ptr = self.allocate(layout, MemoryKind::Stack)?;\n-                self.write_value_to_mplace(value, ptr)?;\n-                ptr\n-            },\n-        })\n-    }\n-\n     pub fn write_discriminant_value(\n         &mut self,\n         variant_index: usize,"}, {"sha": "af191ce3adcc81645da899c0c7334ebcf422457a", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=035c69f6589c1bf77191157fc24b45db51066ca9", "patch": "@@ -19,7 +19,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    MPlaceTy, Machine, EvalContext\n+    OpTy, Machine, EvalContext\n };\n \n macro_rules! validation_failure{\n@@ -187,19 +187,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    /// This function checks the memory where `dest` points to.  The place must be sized\n-    /// (i.e., dest.extra == PlaceExtra::None).\n+    /// This function checks the data at `op`.  The operand must be sized.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     /// The `path` may be pushed to, but the part that is present when the function\n     /// starts must not be changed!\n-    pub fn validate_mplace(\n+    pub fn validate_operand(\n         &self,\n-        dest: MPlaceTy<'tcx>,\n+        dest: OpTy<'tcx>,\n         path: &mut Vec<PathElem>,\n-        seen: &mut FxHashSet<(MPlaceTy<'tcx>)>,\n-        todo: &mut Vec<(MPlaceTy<'tcx>, Vec<PathElem>)>,\n+        seen: &mut FxHashSet<(OpTy<'tcx>)>,\n+        todo: &mut Vec<(OpTy<'tcx>, Vec<PathElem>)>,\n     ) -> EvalResult<'tcx> {\n-        self.memory.dump_alloc(dest.to_ptr()?.alloc_id);\n         trace!(\"validate_mplace: {:?}, {:#?}\", *dest, dest.layout);\n \n         // Find the right variant.  We have to handle this as a prelude, not via\n@@ -210,16 +208,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             layout::Variants::Tagged { ref tag, .. } => {\n                 let size = tag.value.size(self);\n                 // we first read the tag value as scalar, to be able to validate it\n-                let tag_mplace = self.mplace_field(dest, 0)?;\n-                let tag_value = self.read_scalar(tag_mplace.into())?;\n+                let tag_mplace = self.operand_field(dest, 0)?;\n+                let tag_value = self.read_scalar(tag_mplace)?;\n                 path.push(PathElem::Tag);\n                 self.validate_scalar(\n                     tag_value, size, tag, &path, tag_mplace.layout.ty\n                 )?;\n                 path.pop(); // remove the element again\n                 // then we read it again to get the index, to continue\n                 let variant = self.read_discriminant_as_variant_index(dest.into())?;\n-                let inner_dest = self.mplace_downcast(dest, variant)?;\n+                let inner_dest = self.operand_downcast(dest, variant)?;\n                 // Put the variant projection onto the path, as a field\n                 path.push(PathElem::Field(dest.layout.ty\n                                           .ty_adt_def()\n@@ -251,7 +249,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     // expectation.\n                     layout::Abi::Scalar(ref scalar_layout) => {\n                         let size = scalar_layout.value.size(self);\n-                        let value = self.read_value(dest.into())?;\n+                        let value = self.read_value(dest)?;\n                         let scalar = value.to_scalar_or_undef();\n                         self.validate_scalar(scalar, size, scalar_layout, &path, dest.layout.ty)?;\n                         if scalar_layout.value == Primitive::Pointer {\n@@ -267,11 +265,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                 }\n                                 if value.layout.ty.builtin_deref(false).is_some() {\n                                     trace!(\"Recursing below ptr {:#?}\", value);\n-                                    let ptr_place = self.ref_to_mplace(value)?;\n-                                    // we have not encountered this pointer+layout\n-                                    // combination before\n-                                    if seen.insert(ptr_place) {\n-                                        todo.push((ptr_place, path_clone_and_deref(path)));\n+                                    let ptr_op = self.ref_to_mplace(value)?.into();\n+                                    // we have not encountered this pointer+layout combination\n+                                    // before.\n+                                    if seen.insert(ptr_op) {\n+                                        todo.push((ptr_op, path_clone_and_deref(path)));\n                                     }\n                                 }\n                             }\n@@ -286,11 +284,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n             },\n             layout::FieldPlacement::Array { .. } => {\n-                for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n-                    let field = field?;\n-                    path.push(PathElem::ArrayElem(i));\n-                    self.validate_mplace(field, path, seen, todo)?;\n-                    path.truncate(path_len);\n+                // Skips for ZSTs; we could have an empty array as an immediate\n+                if !dest.layout.is_zst() {\n+                    let dest = dest.to_mem_place(); // arrays cannot be immediate\n+                    for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n+                        let field = field?;\n+                        path.push(PathElem::ArrayElem(i));\n+                        self.validate_operand(field.into(), path, seen, todo)?;\n+                        path.truncate(path_len);\n+                    }\n                 }\n             },\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n@@ -311,7 +313,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             _ => return Err(err),\n                         }\n                     };\n-                    let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n+                    let unpacked_ptr = self.unpack_unsized_mplace(ptr)?.into();\n                     // for safe ptrs, recursively check it\n                     if !dest.layout.ty.is_unsafe_ptr() {\n                         trace!(\"Recursing below fat ptr {:?} (unpacked: {:?})\", ptr, unpacked_ptr);\n@@ -322,9 +324,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 } else {\n                     // Not a pointer, perform regular aggregate handling below\n                     for i in 0..offsets.len() {\n-                        let field = self.mplace_field(dest, i as u64)?;\n+                        let field = self.operand_field(dest, i as u64)?;\n                         path.push(self.aggregate_field_path_elem(dest.layout.ty, variant, i));\n-                        self.validate_mplace(field, path, seen, todo)?;\n+                        self.validate_operand(field, path, seen, todo)?;\n                         path.truncate(path_len);\n                     }\n                     // FIXME: For a TyStr, check that this is valid UTF-8."}, {"sha": "ac0ed72d066347b49f6d343eb1f5a485117233dd", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035c69f6589c1bf77191157fc24b45db51066ca9/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=035c69f6589c1bf77191157fc24b45db51066ca9", "patch": "@@ -257,10 +257,9 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match self.ecx.const_value_to_op(c.literal.val) {\n+        match self.ecx.const_to_op(c.literal) {\n             Ok(op) => {\n-                let layout = self.tcx.layout_of(self.param_env.and(c.literal.ty)).ok()?;\n-                Some((OpTy { op, layout }, c.span))\n+                Some((op, c.span))\n             },\n             Err(error) => {\n                 let (stacktrace, span) = self.ecx.generate_stacktrace(None);"}]}