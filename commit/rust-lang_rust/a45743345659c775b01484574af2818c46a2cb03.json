{"sha": "a45743345659c775b01484574af2818c46a2cb03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NTc0MzM0NTY1OWM3NzViMDE0ODQ1NzRhZjI4MThjNDZhMmNiMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-03T12:20:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-03T12:20:42Z"}, "message": "Auto merge of #63234 - Centril:rollup-h9t731z, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #62954 (Fix typo in Delimited::open_tt)\n - #63146 (Cleanup syntax::attr)\n - #63218 (rustbuild: RISC-V is no longer an experimental LLVM target)\n - #63227 (dead_code: Properly inspect fields in struct patterns with type relative paths)\n - #63229 (A bit of Miri error cleanup)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d67ee435402185e455f061464f9bba447abb7c1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d67ee435402185e455f061464f9bba447abb7c1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a45743345659c775b01484574af2818c46a2cb03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a45743345659c775b01484574af2818c46a2cb03", "html_url": "https://github.com/rust-lang/rust/commit/a45743345659c775b01484574af2818c46a2cb03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a45743345659c775b01484574af2818c46a2cb03/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e917f48382c6afaf50568263b89d35fba5d98e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e917f48382c6afaf50568263b89d35fba5d98e4", "html_url": "https://github.com/rust-lang/rust/commit/8e917f48382c6afaf50568263b89d35fba5d98e4"}, {"sha": "42dfdc5aa56aaeda1e4c54c2508ca2212070f797", "url": "https://api.github.com/repos/rust-lang/rust/commits/42dfdc5aa56aaeda1e4c54c2508ca2212070f797", "html_url": "https://github.com/rust-lang/rust/commit/42dfdc5aa56aaeda1e4c54c2508ca2212070f797"}], "stats": {"total": 1031, "additions": 360, "deletions": 671}, "files": [{"sha": "6816eaeaa9486e66e99465094a1c4dce76e2a5ab", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -57,14 +57,13 @@\n # support. You'll need to write a target specification at least, and most\n # likely, teach rustc about the C ABI of the target. Get in touch with the\n # Rust team and file an issue if you need assistance in porting!\n-#targets = \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;MSP430;Sparc;NVPTX;Hexagon\"\n+#targets = \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86\"\n \n # LLVM experimental targets to build support for. These targets are specified in\n # the same format as above, but since these targets are experimental, they are\n # not built by default and the experimental Rust compilation targets that depend\n-# on them will not work unless the user opts in to building them. By default the\n-# `WebAssembly` and `RISCV` targets are enabled when compiling LLVM from scratch.\n-#experimental-targets = \"WebAssembly;RISCV\"\n+# on them will not work unless the user opts in to building them.\n+#experimental-targets = \"\"\n \n # Cap the number of parallel linker invocations when compiling LLVM.\n # This can be useful when building LLVM with debug info, which significantly"}, {"sha": "5a5f4ac72520444c44812996bf6a0a582f673665", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -75,7 +75,7 @@ pub struct Config {\n     pub llvm_link_shared: bool,\n     pub llvm_clang_cl: Option<String>,\n     pub llvm_targets: Option<String>,\n-    pub llvm_experimental_targets: String,\n+    pub llvm_experimental_targets: Option<String>,\n     pub llvm_link_jobs: Option<u32>,\n     pub llvm_version_suffix: Option<String>,\n     pub llvm_use_linker: Option<String>,\n@@ -524,8 +524,7 @@ impl Config {\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n             set(&mut config.llvm_link_shared, llvm.link_shared);\n             config.llvm_targets = llvm.targets.clone();\n-            config.llvm_experimental_targets = llvm.experimental_targets.clone()\n-                .unwrap_or_else(|| \"WebAssembly;RISCV\".to_string());\n+            config.llvm_experimental_targets = llvm.experimental_targets.clone();\n             config.llvm_link_jobs = llvm.link_jobs;\n             config.llvm_version_suffix = llvm.version_suffix.clone();\n             config.llvm_clang_cl = llvm.clang_cl.clone();"}, {"sha": "f02def3e1b05dcf0c32a94c7237af828903d0a65", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -125,14 +125,18 @@ impl Step for Llvm {\n         } else {\n             match builder.config.llvm_targets {\n                 Some(ref s) => s,\n-                None => \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;MSP430;Sparc;NVPTX;Hexagon\",\n+                None => \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\\\n+                         Sparc;SystemZ;WebAssembly;X86\",\n             }\n         };\n \n         let llvm_exp_targets = if self.emscripten {\n             \"\"\n         } else {\n-            &builder.config.llvm_experimental_targets[..]\n+            match builder.config.llvm_experimental_targets {\n+                Some(ref s) => s,\n+                None => \"\",\n+            }\n         };\n \n         let assertions = if builder.config.llvm_assertions {\"ON\"} else {\"OFF\"};"}, {"sha": "8be4d16998276f91e4cc63e065304780fd3ef071", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -59,7 +59,6 @@ extern crate rustc_plugin;\n use syntax::parse::token::{self, Token};\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n-use syntax::ext::build::AstBuilder;  // A trait for expr_usize.\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n@@ -164,13 +163,6 @@ can continue and find further errors.\n To print syntax fragments for debugging, you can use `span_note` together with\n `syntax::print::pprust::*_to_string`.\n \n-The example above produced an integer literal using `AstBuilder::expr_usize`.\n-As an alternative to the `AstBuilder` trait, `libsyntax` provides a set of\n-quasiquote macros. They are undocumented and very rough around the edges.\n-However, the implementation may be a good starting point for an improved\n-quasiquote as an ordinary plugin library.\n-\n-\n # Lint plugins\n \n Plugins can extend [Rust's lint"}, {"sha": "f76de96cd10dae141198766fc8601e82b9fb1895", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -5168,7 +5168,7 @@ impl<'a> LoweringContext<'a> {\n                         let uc_nested = attr::mk_nested_word_item(uc_ident);\n                         attr::mk_list_item(e.span, allow_ident, vec![uc_nested])\n                     };\n-                    attr::mk_spanned_attr_outer(e.span, attr::mk_attr_id(), allow)\n+                    attr::mk_attr_outer(allow)\n                 };\n                 let attrs = vec![attr];\n "}, {"sha": "fefb3dc076d79f45abfe7a8f9a400b7a0c7c8f9a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -269,8 +269,9 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         match pat.node {\n-            PatKind::Struct(hir::QPath::Resolved(_, ref path), ref fields, _) => {\n-                self.handle_field_pattern_match(pat, path.res, fields);\n+            PatKind::Struct(ref path, ref fields, _) => {\n+                let res = self.tables.qpath_res(path, pat.hir_id);\n+                self.handle_field_pattern_match(pat, res, fields);\n             }\n             PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);"}, {"sha": "6a8cd9b46ae4a1ed8e704281bd25bdcc3cd4ae01", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -341,16 +341,16 @@ impl fmt::Debug for InvalidProgramInfo<'tcx> {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum UndefinedBehaviourInfo {\n+pub enum UndefinedBehaviorInfo {\n     /// Handle cases which for which we do not have a fixed variant.\n     Ub(String),\n     /// Unreachable code was executed.\n     Unreachable,\n }\n \n-impl fmt::Debug for UndefinedBehaviourInfo {\n+impl fmt::Debug for UndefinedBehaviorInfo {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use UndefinedBehaviourInfo::*;\n+        use UndefinedBehaviorInfo::*;\n         match self {\n             Ub(ref msg) =>\n                 write!(f, \"{}\", msg),\n@@ -363,7 +363,7 @@ impl fmt::Debug for UndefinedBehaviourInfo {\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsupportedOpInfo<'tcx> {\n     /// Handle cases which for which we do not have a fixed variant.\n-    Unimplemented(String),\n+    Unsupported(String),\n \n     // -- Everything below is not classified yet --\n     FunctionAbiMismatch(Abi, Abi),\n@@ -390,20 +390,14 @@ pub enum UnsupportedOpInfo<'tcx> {\n     ReadUndefBytes(Size),\n     DeadLocal,\n     InvalidBoolOp(mir::BinOp),\n-    InlineAsm,\n     UnimplementedTraitSelection,\n     CalledClosureAsFunction,\n     NoMirFor(String),\n-    /// This variant is used by machines to signal their own errors that do not\n-    /// match an existing variant.\n-    MachineError(String),\n     DerefFunctionPointer,\n     ExecuteMemory,\n-    Intrinsic(String),\n     InvalidChar(u128),\n     OutOfTls,\n     TlsOutOfBounds,\n-    AbiViolation(String),\n     AlignmentCheckFailed {\n         required: Align,\n         has: Align,\n@@ -513,8 +507,6 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n                     initializer\"),\n             AssumptionNotHeld =>\n                 write!(f, \"`assume` argument was false\"),\n-            InlineAsm =>\n-                write!(f, \"miri does not support inline assembly\"),\n             ReallocateNonBasePtr =>\n                 write!(f, \"tried to reallocate with a pointer not to the beginning of an \\\n                     existing object\"),\n@@ -537,10 +529,7 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n             HeapAllocNonPowerOfTwoAlignment(_) =>\n                 write!(f, \"tried to re-, de-, or allocate heap memory with alignment that is \\\n                     not a power of two\"),\n-            MachineError(ref msg) |\n-            Unimplemented(ref msg) |\n-            AbiViolation(ref msg) |\n-            Intrinsic(ref msg) =>\n+            Unsupported(ref msg) =>\n                 write!(f, \"{}\", msg),\n         }\n     }\n@@ -572,7 +561,7 @@ pub enum InterpError<'tcx> {\n     /// The program panicked.\n     Panic(PanicInfo<u64>),\n     /// The program caused undefined behavior.\n-    UndefinedBehaviour(UndefinedBehaviourInfo),\n+    UndefinedBehavior(UndefinedBehaviorInfo),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n     /// but the interpreter is not sure).\n     Unsupported(UnsupportedOpInfo<'tcx>),\n@@ -603,7 +592,7 @@ impl fmt::Debug for InterpError<'_> {\n                 write!(f, \"{:?}\", msg),\n             InvalidProgram(ref msg) =>\n                 write!(f, \"{:?}\", msg),\n-            UndefinedBehaviour(ref msg) =>\n+            UndefinedBehavior(ref msg) =>\n                 write!(f, \"{:?}\", msg),\n             ResourceExhaustion(ref msg) =>\n                 write!(f, \"{:?}\", msg),"}, {"sha": "65f4c9c47d0a94975e6ddd51296637d490ea9b04", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -21,8 +21,8 @@ macro_rules! err_inval {\n #[macro_export]\n macro_rules! err_ub {\n     ($($tt:tt)*) => {\n-        $crate::mir::interpret::InterpError::UndefinedBehaviour(\n-            $crate::mir::interpret::UndefinedBehaviourInfo::$($tt)*\n+        $crate::mir::interpret::InterpError::UndefinedBehavior(\n+            $crate::mir::interpret::UndefinedBehaviorInfo::$($tt)*\n         )\n     };\n }\n@@ -50,6 +50,11 @@ macro_rules! throw_unsup {\n     ($($tt:tt)*) => { return Err(err_unsup!($($tt)*).into()) };\n }\n \n+#[macro_export]\n+macro_rules! throw_unsup_format {\n+    ($($tt:tt)*) => { throw_unsup!(Unsupported(format!($($tt)*))) };\n+}\n+\n #[macro_export]\n macro_rules! throw_inval {\n     ($($tt:tt)*) => { return Err(err_inval!($($tt)*).into()) };\n@@ -60,6 +65,11 @@ macro_rules! throw_ub {\n     ($($tt:tt)*) => { return Err(err_ub!($($tt)*).into()) };\n }\n \n+#[macro_export]\n+macro_rules! throw_ub_format {\n+    ($($tt:tt)*) => { throw_ub!(Ub(format!($($tt)*))) };\n+}\n+\n #[macro_export]\n macro_rules! throw_panic {\n     ($($tt:tt)*) => { return Err(err_panic!($($tt)*).into()) };\n@@ -78,7 +88,7 @@ mod pointer;\n pub use self::error::{\n     InterpErrorInfo, InterpResult, InterpError, AssertMessage, ConstEvalErr, struct_error,\n     FrameInfo, ConstEvalRawResult, ConstEvalResult, ErrorHandled, PanicInfo, UnsupportedOpInfo,\n-    InvalidProgramInfo, ResourceExhaustionInfo, UndefinedBehaviourInfo,\n+    InvalidProgramInfo, ResourceExhaustionInfo, UndefinedBehaviorInfo,\n };\n \n pub use self::value::{Scalar, ScalarMaybeUndef, RawConst, ConstValue};"}, {"sha": "935187dd0667bb1b6cf3e99699e5d9d25fec1b5d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -980,14 +980,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     fn get_attributes(&self, item: &Entry<'tcx>, sess: &Session) -> Vec<ast::Attribute> {\n-        item.attributes\n-            .decode((self, sess))\n-            .map(|mut attr| {\n-                // Need new unique IDs: old thread-local IDs won't map to new threads.\n-                attr.id = attr::mk_attr_id();\n-                attr\n-            })\n-            .collect()\n+        item.attributes.decode((self, sess)).collect()\n     }\n \n     // Translate a DefId from the current compilation environment to a DefId"}, {"sha": "b3b85be05e614388e89e1b0eb9100e1d1c849333", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -181,17 +181,17 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     Ok(ret)\n }\n \n-impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n-    fn into(self) -> InterpErrorInfo<'tcx> {\n-        err_unsup!(MachineError(self.to_string())).into()\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n enum ConstEvalError {\n     NeedsRfc(String),\n }\n \n+impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n+    fn into(self) -> InterpErrorInfo<'tcx> {\n+        err_unsup!(Unsupported(self.to_string())).into()\n+    }\n+}\n+\n impl fmt::Display for ConstEvalError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::ConstEvalError::*;\n@@ -341,7 +341,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         debug!(\"eval_fn_call: {:?}\", instance);\n         // Only check non-glue functions\n         if let ty::InstanceDef::Item(def_id) = instance.def {\n-            // Execution might have wandered off into other crates, so we cannot to a stability-\n+            // Execution might have wandered off into other crates, so we cannot do a stability-\n             // sensitive check here.  But we can at least rule out functions that are not const\n             // at all.\n             if !ecx.tcx.is_const_fn_raw(def_id) {\n@@ -352,7 +352,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     ecx.goto_block(ret)?; // fully evaluated and done\n                     Ok(None)\n                 } else {\n-                    throw_unsup!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n+                    throw_unsup_format!(\"calling non-const function `{}`\", instance)\n                 };\n             }\n         }"}, {"sha": "8e3450656abfba31d61549aae24efaaf52340eff", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -198,7 +198,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-            _ => throw_unsup!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n+            _ => bug!(\"invalid int to {:?} cast\", dest_layout.ty),\n         }\n     }\n "}, {"sha": "89c5be137a4e520a69fa218baf67fbecdfc479ee", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -98,11 +98,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let bits = self.read_scalar(args[0])?.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-                    _ => Err(err_unsup!(TypeNotPrimitive(ty)))?,\n+                    _ => throw_unsup!(TypeNotPrimitive(ty)),\n                 };\n                 let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if bits == 0 {\n-                        throw_unsup!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)))\n+                        throw_ub_format!(\"`{}` called on 0\", intrinsic_name);\n                     }\n                     numeric_intrinsic(intrinsic_name.trim_end_matches(\"_nonzero\"), bits, kind)?\n                 } else {\n@@ -187,10 +187,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (val, overflowed) = self.binary_op(bin_op, l, r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n-                    let r_val =  r.to_scalar()?.to_bits(layout.size)?;\n-                    throw_unsup!(\n-                        Intrinsic(format!(\"Overflowing shift by {} in {}\", r_val, intrinsic_name))\n-                    )\n+                    let r_val = r.to_scalar()?.to_bits(layout.size)?;\n+                    throw_ub_format!(\"Overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n                 }\n                 self.write_scalar(val, dest)?;\n             }"}, {"sha": "d1deb2e49bda3c70b607b1fab8b91cabf18c47ad", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -66,9 +66,9 @@ impl<'tcx, Other> FnVal<'tcx, Other> {\n         match self {\n             FnVal::Instance(instance) =>\n                 Ok(instance),\n-            FnVal::Other(_) => throw_unsup!(MachineError(format!(\n-                \"Expected instance function pointer, got 'other' pointer\"\n-            ))),\n+            FnVal::Other(_) => throw_unsup_format!(\n+                \"'foreign' function pointers are not supported in this context\"\n+            ),\n         }\n     }\n }\n@@ -834,9 +834,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset) ||\n                         (dest.offset <= src.offset && dest.offset + size > src.offset)\n                     {\n-                        throw_unsup!(Intrinsic(\n-                            \"copy_nonoverlapping called on overlapping ranges\".to_string(),\n-                        ))\n+                        throw_ub_format!(\n+                            \"copy_nonoverlapping called on overlapping ranges\"\n+                        )\n                     }\n                 }\n "}, {"sha": "e638ebcc34265ce50e5608886b1ef323c882d4e2", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -147,15 +147,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // For the remaining ops, the types must be the same on both sides\n         if left_layout.ty != right_layout.ty {\n-            let msg = format!(\n-                \"unimplemented asymmetric binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n+            bug!(\n+                \"invalid asymmetric binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n                 bin_op,\n-                l,\n-                left_layout.ty,\n-                r,\n-                right_layout.ty\n-            );\n-            throw_unsup!(Unimplemented(msg))\n+                l, left_layout.ty,\n+                r, right_layout.ty,\n+            )\n         }\n \n         // Operations that need special treatment for signed integers\n@@ -243,14 +240,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             _ => {\n-                let msg = format!(\n-                    \"unimplemented binary op {:?}: {:?}, {:?} (both {:?})\",\n+                bug!(\n+                    \"invalid binary op {:?}: {:?}, {:?} (both {:?})\",\n                     bin_op,\n                     l,\n                     r,\n                     right_layout.ty,\n-                );\n-                throw_unsup!(Unimplemented(msg))\n+                )\n             }\n         };\n "}, {"sha": "d152e2b50fa1b05decd65da3e72211f7e176b115", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -121,7 +121,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // size of MIR constantly.\n             Nop => {}\n \n-            InlineAsm { .. } => throw_unsup!(InlineAsm),\n+            InlineAsm { .. } => throw_unsup_format!(\"inline assembly is not supported\"),\n         }\n \n         self.stack[frame_idx].stmt += 1;"}, {"sha": "a0c6fb026dd4b53358830fc9487c702017046d03", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -88,8 +88,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         (FnVal::Instance(self.resolve(def_id, substs)?), sig.abi())\n                     },\n                     _ => {\n-                        let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n-                        throw_unsup!(Unimplemented(msg))\n+                        bug!(\"invalid callee of type {:?}\", func.layout.ty)\n                     }\n                 };\n                 let args = self.eval_operands(args)?;"}, {"sha": "38d26d0ba50a483ee94f9699334f9b6b35d3bf42", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -260,7 +260,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 match diagnostic.error {\n                     Exit(_) => bug!(\"the CTFE program cannot exit\"),\n                     Unsupported(_)\n-                    | UndefinedBehaviour(_)\n+                    | UndefinedBehavior(_)\n                     | InvalidProgram(_)\n                     | ResourceExhaustion(_) => {\n                         // Ignore these errors."}, {"sha": "246c8f4b91f2d8034e6f274953b7796f870bd798", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -2109,9 +2109,7 @@ pub enum AttrStyle {\n     Inner,\n }\n \n-#[derive(\n-    Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialOrd, Ord, Copy,\n-)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord, Copy)]\n pub struct AttrId(pub usize);\n \n impl Idx for AttrId {\n@@ -2123,6 +2121,18 @@ impl Idx for AttrId {\n     }\n }\n \n+impl rustc_serialize::Encodable for AttrId {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_unit()\n+    }\n+}\n+\n+impl rustc_serialize::Decodable for AttrId {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<AttrId, D::Error> {\n+        d.read_nil().map(|_| crate::attr::mk_attr_id())\n+    }\n+}\n+\n /// Metadata associated with an item.\n /// Doc-comments are promoted to attributes that have `is_sugared_doc = true`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "5fb513783fbaac3fe64d6a79b9b9addd94f18ffd", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -3,7 +3,6 @@\n use crate::ast::{self, Attribute, MetaItem, NestedMetaItem};\n use crate::early_buffered_lints::BufferedEarlyLintId;\n use crate::ext::base::ExtCtxt;\n-use crate::ext::build::AstBuilder;\n use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n@@ -929,7 +928,7 @@ pub fn find_transparency(\n pub fn check_builtin_macro_attribute(ecx: &ExtCtxt<'_>, meta_item: &MetaItem, name: Symbol) {\n     // All the built-in macro attributes are \"words\" at the moment.\n     let template = AttributeTemplate { word: true, list: None, name_value_str: None };\n-    let attr = ecx.attribute(meta_item.span, meta_item.clone());\n+    let attr = ecx.attribute(meta_item.clone());\n     check_builtin_attribute(ecx.parse_sess, &attr, name, template);\n }\n "}, {"sha": "3e56136b171083ad03ac51727090bf8cf9e1a74b", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -6,9 +6,10 @@ pub use builtin::*;\n pub use IntType::*;\n pub use ReprAttr::*;\n pub use StabilityLevel::*;\n+pub use crate::ast::Attribute;\n \n use crate::ast;\n-use crate::ast::{AttrId, Attribute, AttrStyle, Name, Ident, Path, PathSegment};\n+use crate::ast::{AttrId, AttrStyle, Name, Ident, Path, PathSegment};\n use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n@@ -328,13 +329,14 @@ impl Attribute {\n             let meta = mk_name_value_item_str(\n                 Ident::with_empty_ctxt(sym::doc),\n                 dummy_spanned(Symbol::intern(&strip_doc_comment_decoration(&comment.as_str()))));\n-            let mut attr = if self.style == ast::AttrStyle::Outer {\n-                mk_attr_outer(self.span, self.id, meta)\n-            } else {\n-                mk_attr_inner(self.span, self.id, meta)\n-            };\n-            attr.is_sugared_doc = true;\n-            f(&attr)\n+            f(&Attribute {\n+                id: self.id,\n+                style: self.style,\n+                path: meta.path,\n+                tokens: meta.node.tokens(meta.span),\n+                is_sugared_doc: true,\n+                span: self.span,\n+            })\n         } else {\n             f(self)\n         }\n@@ -376,46 +378,36 @@ pub fn mk_attr_id() -> AttrId {\n     AttrId(id)\n }\n \n-/// Returns an inner attribute with the given value.\n-pub fn mk_attr_inner(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n-    mk_spanned_attr_inner(span, id, item)\n-}\n-\n /// Returns an inner attribute with the given value and span.\n-pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n+pub fn mk_attr_inner(item: MetaItem) -> Attribute {\n     Attribute {\n-        id,\n+        id: mk_attr_id(),\n         style: ast::AttrStyle::Inner,\n         path: item.path,\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n-        span: sp,\n+        span: item.span,\n     }\n }\n \n-/// Returns an outer attribute with the given value.\n-pub fn mk_attr_outer(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n-    mk_spanned_attr_outer(span, id, item)\n-}\n-\n /// Returns an outer attribute with the given value and span.\n-pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n+pub fn mk_attr_outer(item: MetaItem) -> Attribute {\n     Attribute {\n-        id,\n+        id: mk_attr_id(),\n         style: ast::AttrStyle::Outer,\n         path: item.path,\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n-        span: sp,\n+        span: item.span,\n     }\n }\n \n-pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n+pub fn mk_sugared_doc_attr(text: Symbol, span: Span) -> Attribute {\n     let style = doc_comment_style(&text.as_str());\n     let lit_kind = LitKind::Str(text, ast::StrStyle::Cooked);\n     let lit = Lit::from_lit_kind(lit_kind, span);\n     Attribute {\n-        id,\n+        id: mk_attr_id(),\n         style,\n         path: Path::from_ident(Ident::with_empty_ctxt(sym::doc).with_span_pos(span)),\n         tokens: MetaItemKind::NameValue(lit).tokens(span),"}, {"sha": "80591ad304df0200f398029e13b5483467d8bba3", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -4,7 +4,6 @@ use std::env;\n use crate::ast::{self, Ident, Name};\n use crate::source_map;\n use crate::ext::base::{ExtCtxt, MacEager, MacResult};\n-use crate::ext::build::AstBuilder;\n use crate::parse::token::{self, Token};\n use crate::ptr::P;\n use crate::symbol::kw;"}, {"sha": "b4b15ba31b713d78fd8e24f020a2a0addf5920ec", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 135, "deletions": 404, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -9,295 +9,20 @@ use crate::ThinVec;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span};\n \n-pub trait AstBuilder {\n-    // Paths\n-    fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;\n-    fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path;\n-    fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;\n-    fn path_all(&self, sp: Span,\n-                global: bool,\n-                idents: Vec<ast::Ident>,\n-                args: Vec<ast::GenericArg>,\n-                constraints: Vec<ast::AssocTyConstraint>)\n-        -> ast::Path;\n-\n-    fn qpath(&self, self_type: P<ast::Ty>,\n-             trait_path: ast::Path,\n-             ident: ast::Ident)\n-             -> (ast::QSelf, ast::Path);\n-    fn qpath_all(&self, self_type: P<ast::Ty>,\n-                trait_path: ast::Path,\n-                ident: ast::Ident,\n-                args: Vec<ast::GenericArg>,\n-                constraints: Vec<ast::AssocTyConstraint>)\n-                -> (ast::QSelf, ast::Path);\n-\n-    // types and consts\n-    fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy;\n-\n-    fn ty(&self, span: Span, ty: ast::TyKind) -> P<ast::Ty>;\n-    fn ty_path(&self, path: ast::Path) -> P<ast::Ty>;\n-    fn ty_ident(&self, span: Span, idents: ast::Ident) -> P<ast::Ty>;\n-    fn anon_const(&self, span: Span, expr: ast::ExprKind) -> ast::AnonConst;\n-    fn const_ident(&self, span: Span, idents: ast::Ident) -> ast::AnonConst;\n-\n-    fn ty_rptr(&self, span: Span,\n-               ty: P<ast::Ty>,\n-               lifetime: Option<ast::Lifetime>,\n-               mutbl: ast::Mutability) -> P<ast::Ty>;\n-    fn ty_ptr(&self, span: Span,\n-              ty: P<ast::Ty>,\n-              mutbl: ast::Mutability) -> P<ast::Ty>;\n-\n-    fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n-\n-    fn typaram(&self,\n-               span: Span,\n-               id: ast::Ident,\n-               attrs: Vec<ast::Attribute>,\n-               bounds: ast::GenericBounds,\n-               default: Option<P<ast::Ty>>) -> ast::GenericParam;\n-\n-    fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n-    fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef;\n-    fn trait_bound(&self, path: ast::Path) -> ast::GenericBound;\n-    fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime;\n-    fn lifetime_def(&self,\n-                    span: Span,\n-                    ident: ast::Ident,\n-                    attrs: Vec<ast::Attribute>,\n-                    bounds: ast::GenericBounds)\n-                    -> ast::GenericParam;\n-\n-    // Statements\n-    fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt;\n-    fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt;\n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: P<ast::Expr>) -> ast::Stmt;\n-    fn stmt_let_typed(&self,\n-                      sp: Span,\n-                      mutbl: bool,\n-                      ident: ast::Ident,\n-                      typ: P<ast::Ty>,\n-                      ex: P<ast::Expr>)\n-                      -> ast::Stmt;\n-    fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt;\n-    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt;\n-\n-    // Blocks\n-    fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block>;\n-    fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n-\n-    // Expressions\n-    fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr>;\n-    fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;\n-    fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr>;\n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n-\n-    fn expr_self(&self, span: Span) -> P<ast::Expr>;\n-    fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n-                   lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr>;\n-    fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n-    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr>;\n-\n-    fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n-    fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n-    fn expr_field_access(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n-    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>,\n-                             idx: usize) -> P<ast::Expr>;\n-    fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n-    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident>,\n-                        args: Vec<P<ast::Expr>> ) -> P<ast::Expr>;\n-    fn expr_method_call(&self, span: Span,\n-                        expr: P<ast::Expr>, ident: ast::Ident,\n-                        args: Vec<P<ast::Expr>> ) -> P<ast::Expr>;\n-    fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr>;\n-    fn expr_cast(&self, sp: Span, expr: P<ast::Expr>, ty: P<ast::Ty>) -> P<ast::Expr>;\n-\n-    fn field_imm(&self, span: Span, name: Ident, e: P<ast::Expr>) -> ast::Field;\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field>) -> P<ast::Expr>;\n-    fn expr_struct_ident(&self, span: Span, id: ast::Ident,\n-                         fields: Vec<ast::Field>) -> P<ast::Expr>;\n-\n-    fn expr_lit(&self, sp: Span, lit: ast::LitKind) -> P<ast::Expr>;\n-\n-    fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr>;\n-    fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr>;\n-    fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr>;\n-    fn expr_u16(&self, sp: Span, u: u16) -> P<ast::Expr>;\n-    fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr>;\n-    fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr>;\n-\n-    fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n-    fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr>;\n-    fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n-    fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr>;\n-\n-    fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n-    fn expr_none(&self, sp: Span) -> P<ast::Expr>;\n-\n-    fn expr_break(&self, sp: Span) -> P<ast::Expr>;\n-\n-    fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n-\n-    fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr>;\n-    fn expr_unreachable(&self, span: Span) -> P<ast::Expr>;\n-\n-    fn expr_ok(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n-    fn expr_err(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n-    fn expr_try(&self, span: Span, head: P<ast::Expr>) -> P<ast::Expr>;\n-\n-    fn pat(&self, span: Span, pat: PatKind) -> P<ast::Pat>;\n-    fn pat_wild(&self, span: Span) -> P<ast::Pat>;\n-    fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat>;\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat>;\n-\n-    fn pat_ident_binding_mode(&self,\n-                              span: Span,\n-                              ident: ast::Ident,\n-                              bm: ast::BindingMode) -> P<ast::Pat>;\n-    fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat>;\n-    fn pat_tuple_struct(&self, span: Span, path: ast::Path,\n-                        subpats: Vec<P<ast::Pat>>) -> P<ast::Pat>;\n-    fn pat_struct(&self, span: Span, path: ast::Path,\n-                  field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat>;\n-    fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat>;\n-\n-    fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n-    fn pat_none(&self, span: Span) -> P<ast::Pat>;\n-\n-    fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n-    fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n-\n-    fn arm(&self, span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm;\n-    fn arm_unreachable(&self, span: Span) -> ast::Arm;\n-\n-    fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm> ) -> P<ast::Expr>;\n-    fn expr_if(&self, span: Span,\n-               cond: P<ast::Expr>, then: P<ast::Expr>, els: Option<P<ast::Expr>>) -> P<ast::Expr>;\n-    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr>;\n-\n-    fn lambda_fn_decl(&self,\n-                      span: Span,\n-                      fn_decl: P<ast::FnDecl>,\n-                      body: P<ast::Expr>,\n-                      fn_decl_span: Span)\n-                      -> P<ast::Expr>;\n-\n-    fn lambda(&self, span: Span, ids: Vec<ast::Ident>, body: P<ast::Expr>) -> P<ast::Expr>;\n-    fn lambda0(&self, span: Span, body: P<ast::Expr>) -> P<ast::Expr>;\n-    fn lambda1(&self, span: Span, body: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n-\n-    fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident>,\n-                    blk: Vec<ast::Stmt>) -> P<ast::Expr>;\n-    fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr>;\n-    fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n-                      ident: ast::Ident) -> P<ast::Expr>;\n-\n-    // Items\n-    fn item(&self, span: Span,\n-            name: Ident, attrs: Vec<ast::Attribute> , node: ast::ItemKind) -> P<ast::Item>;\n-\n-    fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n-    // FIXME: unused `self`\n-    fn fn_decl(&self, inputs: Vec<ast::Arg> , output: ast::FunctionRetTy) -> P<ast::FnDecl>;\n-\n-    fn item_fn_poly(&self,\n-                    span: Span,\n-                    name: Ident,\n-                    inputs: Vec<ast::Arg> ,\n-                    output: P<ast::Ty>,\n-                    generics: Generics,\n-                    body: P<ast::Block>) -> P<ast::Item>;\n-    fn item_fn(&self,\n-               span: Span,\n-               name: Ident,\n-               inputs: Vec<ast::Arg> ,\n-               output: P<ast::Ty>,\n-               body: P<ast::Block>) -> P<ast::Item>;\n-\n-    fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant;\n-    fn item_enum_poly(&self,\n-                      span: Span,\n-                      name: Ident,\n-                      enum_definition: ast::EnumDef,\n-                      generics: Generics) -> P<ast::Item>;\n-    fn item_enum(&self, span: Span, name: Ident, enum_def: ast::EnumDef) -> P<ast::Item>;\n-\n-    fn item_struct_poly(&self,\n-                        span: Span,\n-                        name: Ident,\n-                        struct_def: ast::VariantData,\n-                        generics: Generics) -> P<ast::Item>;\n-    fn item_struct(&self, span: Span, name: Ident, struct_def: ast::VariantData) -> P<ast::Item>;\n-\n-    fn item_mod(&self, span: Span, inner_span: Span,\n-                name: Ident, attrs: Vec<ast::Attribute>,\n-                items: Vec<P<ast::Item>>) -> P<ast::Item>;\n-\n-    fn item_extern_crate(&self, span: Span, name: Ident) -> P<ast::Item>;\n-\n-    fn item_static(&self,\n-                   span: Span,\n-                   name: Ident,\n-                   ty: P<ast::Ty>,\n-                   mutbl: ast::Mutability,\n-                   expr: P<ast::Expr>)\n-                   -> P<ast::Item>;\n-\n-    fn item_const(&self,\n-                   span: Span,\n-                   name: Ident,\n-                   ty: P<ast::Ty>,\n-                   expr: P<ast::Expr>)\n-                   -> P<ast::Item>;\n-\n-    fn item_ty_poly(&self,\n-                    span: Span,\n-                    name: Ident,\n-                    ty: P<ast::Ty>,\n-                    generics: Generics) -> P<ast::Item>;\n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item>;\n-\n-    fn attribute(&self, sp: Span, mi: ast::MetaItem) -> ast::Attribute;\n-\n-    fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem;\n-\n-    fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem;\n-\n-    fn meta_list(&self,\n-                 sp: Span,\n-                 name: ast::Name,\n-                 mis: Vec<ast::NestedMetaItem> )\n-                 -> ast::MetaItem;\n-    fn meta_name_value(&self,\n-                       sp: Span,\n-                       name: ast::Name,\n-                       value: ast::LitKind)\n-                       -> ast::MetaItem;\n-\n-    fn item_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::UseTree>) -> P<ast::Item>;\n-    fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item>;\n-    fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        ident: Option<ast::Ident>, path: ast::Path) -> P<ast::Item>;\n-    fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item>;\n-    fn item_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item>;\n-}\n+// Left so that Cargo tests don't break, this can be removed once those no longer use it\n+pub trait AstBuilder {}\n \n-impl<'a> AstBuilder for ExtCtxt<'a> {\n-    fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n+impl<'a> ExtCtxt<'a> {\n+    pub fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n         self.path_all(span, false, strs, vec![], vec![])\n     }\n-    fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n+    pub fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n         self.path(span, vec![id])\n     }\n-    fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n+    pub fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n         self.path_all(span, true, strs, vec![], vec![])\n     }\n-    fn path_all(&self,\n+    pub fn path_all(&self,\n                 span: Span,\n                 global: bool,\n                 mut idents: Vec<ast::Ident> ,\n@@ -330,7 +55,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     /// Constructs a qualified path.\n     ///\n     /// Constructs a path like `<self_type as trait_path>::ident`.\n-    fn qpath(&self,\n+    pub fn qpath(&self,\n              self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n              ident: ast::Ident)\n@@ -341,7 +66,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     /// Constructs a qualified path.\n     ///\n     /// Constructs a path like `<self_type as trait_path>::ident<'a, T, A = Bar>`.\n-    fn qpath_all(&self,\n+    pub fn qpath_all(&self,\n                  self_type: P<ast::Ty>,\n                  trait_path: ast::Path,\n                  ident: ast::Ident,\n@@ -363,33 +88,33 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }, path)\n     }\n \n-    fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy {\n+    pub fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy {\n         ast::MutTy {\n             ty,\n             mutbl,\n         }\n     }\n \n-    fn ty(&self, span: Span, ty: ast::TyKind) -> P<ast::Ty> {\n+    pub fn ty(&self, span: Span, ty: ast::TyKind) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n             span,\n             node: ty\n         })\n     }\n \n-    fn ty_path(&self, path: ast::Path) -> P<ast::Ty> {\n+    pub fn ty_path(&self, path: ast::Path) -> P<ast::Ty> {\n         self.ty(path.span, ast::TyKind::Path(None, path))\n     }\n \n     // Might need to take bounds as an argument in the future, if you ever want\n     // to generate a bounded existential trait type.\n-    fn ty_ident(&self, span: Span, ident: ast::Ident)\n+    pub fn ty_ident(&self, span: Span, ident: ast::Ident)\n         -> P<ast::Ty> {\n         self.ty_path(self.path_ident(span, ident))\n     }\n \n-    fn anon_const(&self, span: Span, expr: ast::ExprKind) -> ast::AnonConst {\n+    pub fn anon_const(&self, span: Span, expr: ast::ExprKind) -> ast::AnonConst {\n         ast::AnonConst {\n             id: ast::DUMMY_NODE_ID,\n             value: P(ast::Expr {\n@@ -401,11 +126,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn const_ident(&self, span: Span, ident: ast::Ident) -> ast::AnonConst {\n+    pub fn const_ident(&self, span: Span, ident: ast::Ident) -> ast::AnonConst {\n         self.anon_const(span, ast::ExprKind::Path(None, self.path_ident(span, ident)))\n     }\n \n-    fn ty_rptr(&self,\n+    pub fn ty_rptr(&self,\n                span: Span,\n                ty: P<ast::Ty>,\n                lifetime: Option<ast::Lifetime>,\n@@ -415,7 +140,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 ast::TyKind::Rptr(lifetime, self.ty_mt(ty, mutbl)))\n     }\n \n-    fn ty_ptr(&self,\n+    pub fn ty_ptr(&self,\n               span: Span,\n               ty: P<ast::Ty>,\n               mutbl: ast::Mutability)\n@@ -424,11 +149,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 ast::TyKind::Ptr(self.ty_mt(ty, mutbl)))\n     }\n \n-    fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n+    pub fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n         self.ty(span, ast::TyKind::Infer)\n     }\n \n-    fn typaram(&self,\n+    pub fn typaram(&self,\n                span: Span,\n                ident: ast::Ident,\n                attrs: Vec<ast::Attribute>,\n@@ -445,31 +170,31 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn trait_ref(&self, path: ast::Path) -> ast::TraitRef {\n+    pub fn trait_ref(&self, path: ast::Path) -> ast::TraitRef {\n         ast::TraitRef {\n             path,\n             ref_id: ast::DUMMY_NODE_ID,\n         }\n     }\n \n-    fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef {\n+    pub fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef {\n         ast::PolyTraitRef {\n             bound_generic_params: Vec::new(),\n             trait_ref: self.trait_ref(path),\n             span,\n         }\n     }\n \n-    fn trait_bound(&self, path: ast::Path) -> ast::GenericBound {\n+    pub fn trait_bound(&self, path: ast::Path) -> ast::GenericBound {\n         ast::GenericBound::Trait(self.poly_trait_ref(path.span, path),\n                                  ast::TraitBoundModifier::None)\n     }\n \n-    fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime {\n+    pub fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime {\n         ast::Lifetime { id: ast::DUMMY_NODE_ID, ident: ident.with_span_pos(span) }\n     }\n \n-    fn lifetime_def(&self,\n+    pub fn lifetime_def(&self,\n                     span: Span,\n                     ident: ast::Ident,\n                     attrs: Vec<ast::Attribute>,\n@@ -485,23 +210,23 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n+    pub fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n             span: expr.span,\n             node: ast::StmtKind::Expr(expr),\n         }\n     }\n \n-    fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt {\n+    pub fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n             span: expr.span,\n             node: ast::StmtKind::Semi(expr),\n         }\n     }\n \n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n+    pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n                 ex: P<ast::Expr>) -> ast::Stmt {\n         let pat = if mutbl {\n             let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mutable);\n@@ -524,7 +249,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn stmt_let_typed(&self,\n+    pub fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n@@ -553,7 +278,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     // Generates `let _: Type;`, which is usually used for type assertions.\n-    fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n+    pub fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n         let local = P(ast::Local {\n             pat: self.pat_wild(span),\n             ty: Some(ty),\n@@ -569,22 +294,22 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n+    pub fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::StmtKind::Item(item),\n             span: sp,\n         }\n     }\n \n-    fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n+    pub fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n         self.block(expr.span, vec![ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n             span: expr.span,\n             node: ast::StmtKind::Expr(expr),\n         }])\n     }\n-    fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block> {\n+    pub fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block> {\n         P(ast::Block {\n            stmts,\n            id: ast::DUMMY_NODE_ID,\n@@ -593,7 +318,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr> {\n+    pub fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n             node,\n@@ -602,72 +327,76 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn expr_path(&self, path: ast::Path) -> P<ast::Expr> {\n+    pub fn expr_path(&self, path: ast::Path) -> P<ast::Expr> {\n         self.expr(path.span, ast::ExprKind::Path(None, path))\n     }\n \n     /// Constructs a `QPath` expression.\n-    fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> {\n+    pub fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Path(Some(qself), path))\n     }\n \n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {\n+    pub fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {\n         self.expr_path(self.path_ident(span, id))\n     }\n-    fn expr_self(&self, span: Span) -> P<ast::Expr> {\n+    pub fn expr_self(&self, span: Span) -> P<ast::Expr> {\n         self.expr_ident(span, Ident::with_empty_ctxt(kw::SelfLower))\n     }\n \n-    fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n+    pub fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n                    lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Binary(Spanned { node: op, span: sp }, lhs, rhs))\n     }\n \n-    fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr_unary(sp, UnOp::Deref, e)\n     }\n-    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Unary(op, e))\n     }\n \n-    fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n+    pub fn expr_field_access(\n+        &self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident,\n+    ) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Field(expr, ident.with_span_pos(sp)))\n     }\n-    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n+    pub fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n         let ident = Ident::from_str(&idx.to_string()).with_span_pos(sp);\n         self.expr(sp, ast::ExprKind::Field(expr, ident))\n     }\n-    fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Immutable, e))\n     }\n-    fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Mutable, e))\n     }\n \n-    fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_call(\n+        &self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>,\n+    ) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Call(expr, args))\n     }\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident,\n+    pub fn expr_call_ident(&self, span: Span, id: ast::Ident,\n                        args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Call(self.expr_ident(span, id), args))\n     }\n-    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n+    pub fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n                       args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n-    fn expr_method_call(&self, span: Span,\n+    pub fn expr_method_call(&self, span: Span,\n                         expr: P<ast::Expr>,\n                         ident: ast::Ident,\n                         mut args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         args.insert(0, expr);\n         let segment = ast::PathSegment::from_ident(ident.with_span_pos(span));\n         self.expr(span, ast::ExprKind::MethodCall(segment, args))\n     }\n-    fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n+    pub fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(b.span, ast::ExprKind::Block(b, None))\n     }\n-    fn field_imm(&self, span: Span, ident: Ident, e: P<ast::Expr>) -> ast::Field {\n+    pub fn field_imm(&self, span: Span, ident: Ident, e: P<ast::Expr>) -> ast::Field {\n         ast::Field {\n             ident: ident.with_span_pos(span),\n             expr: e,\n@@ -676,23 +405,25 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             attrs: ThinVec::new(),\n         }\n     }\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field>) -> P<ast::Expr> {\n+    pub fn expr_struct(\n+        &self, span: Span, path: ast::Path, fields: Vec<ast::Field>\n+    ) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Struct(path, fields, None))\n     }\n-    fn expr_struct_ident(&self, span: Span,\n+    pub fn expr_struct_ident(&self, span: Span,\n                          id: ast::Ident, fields: Vec<ast::Field>) -> P<ast::Expr> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, span: Span, lit_kind: ast::LitKind) -> P<ast::Expr> {\n+    pub fn expr_lit(&self, span: Span, lit_kind: ast::LitKind) -> P<ast::Expr> {\n         let lit = ast::Lit::from_lit_kind(lit_kind, span);\n         self.expr(span, ast::ExprKind::Lit(lit))\n     }\n-    fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n+    pub fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n         self.expr_lit(span, ast::LitKind::Int(i as u128,\n                                               ast::LitIntType::Unsigned(ast::UintTy::Usize)))\n     }\n-    fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr> {\n+    pub fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr> {\n         if i < 0 {\n             let i = (-i) as u128;\n             let lit_ty = ast::LitIntType::Signed(ast::IntTy::Isize);\n@@ -703,59 +434,59 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                                                 ast::LitIntType::Signed(ast::IntTy::Isize)))\n         }\n     }\n-    fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n+    pub fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Int(u as u128,\n                                             ast::LitIntType::Unsigned(ast::UintTy::U32)))\n     }\n-    fn expr_u16(&self, sp: Span, u: u16) -> P<ast::Expr> {\n+    pub fn expr_u16(&self, sp: Span, u: u16) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Int(u as u128,\n                                             ast::LitIntType::Unsigned(ast::UintTy::U16)))\n     }\n-    fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n+    pub fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Int(u as u128, ast::LitIntType::Unsigned(ast::UintTy::U8)))\n     }\n-    fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n+    pub fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Bool(value))\n     }\n \n-    fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Array(exprs))\n     }\n-    fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr> {\n+    pub fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr> {\n         self.expr_call_global(sp, self.std_path(&[sym::vec, sym::Vec, sym::new]),\n                               Vec::new())\n     }\n-    fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n-    fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr> {\n+    pub fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Str(s, ast::StrStyle::Cooked))\n     }\n \n-    fn expr_cast(&self, sp: Span, expr: P<ast::Expr>, ty: P<ast::Ty>) -> P<ast::Expr> {\n+    pub fn expr_cast(&self, sp: Span, expr: P<ast::Expr>, ty: P<ast::Ty>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Cast(expr, ty))\n     }\n \n-    fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n         self.expr_call_global(sp, some, vec![expr])\n     }\n \n-    fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n+    pub fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n         let none = self.std_path(&[sym::option, sym::Option, sym::None]);\n         let none = self.path_global(sp, none);\n         self.expr_path(none)\n     }\n \n-    fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n+    pub fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Break(None, None))\n     }\n \n-    fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n \n-    fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n+    pub fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n         let loc = self.source_map().lookup_char_pos(span.lo());\n         let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name.to_string()));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n@@ -770,21 +501,21 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 expr_loc_ptr])\n     }\n \n-    fn expr_unreachable(&self, span: Span) -> P<ast::Expr> {\n+    pub fn expr_unreachable(&self, span: Span) -> P<ast::Expr> {\n         self.expr_fail(span, Symbol::intern(\"internal error: entered unreachable code\"))\n     }\n \n-    fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n         self.expr_call_global(sp, ok, vec![expr])\n     }\n \n-    fn expr_err(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn expr_err(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n         self.expr_call_global(sp, err, vec![expr])\n     }\n \n-    fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n         let ok_path = self.path_global(sp, ok);\n         let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n@@ -814,67 +545,67 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n \n-    fn pat(&self, span: Span, pat: PatKind) -> P<ast::Pat> {\n+    pub fn pat(&self, span: Span, pat: PatKind) -> P<ast::Pat> {\n         P(ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span })\n     }\n-    fn pat_wild(&self, span: Span) -> P<ast::Pat> {\n+    pub fn pat_wild(&self, span: Span) -> P<ast::Pat> {\n         self.pat(span, PatKind::Wild)\n     }\n-    fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat> {\n+    pub fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Lit(expr))\n     }\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat> {\n+    pub fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat> {\n         let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Immutable);\n         self.pat_ident_binding_mode(span, ident, binding_mode)\n     }\n \n-    fn pat_ident_binding_mode(&self,\n+    pub fn pat_ident_binding_mode(&self,\n                               span: Span,\n                               ident: ast::Ident,\n                               bm: ast::BindingMode) -> P<ast::Pat> {\n         let pat = PatKind::Ident(bm, ident.with_span_pos(span), None);\n         self.pat(span, pat)\n     }\n-    fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat> {\n+    pub fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat> {\n         self.pat(span, PatKind::Path(None, path))\n     }\n-    fn pat_tuple_struct(&self, span: Span, path: ast::Path,\n+    pub fn pat_tuple_struct(&self, span: Span, path: ast::Path,\n                         subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::TupleStruct(path, subpats))\n     }\n-    fn pat_struct(&self, span: Span, path: ast::Path,\n+    pub fn pat_struct(&self, span: Span, path: ast::Path,\n                   field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Struct(path, field_pats, false))\n     }\n-    fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n+    pub fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Tuple(pats))\n     }\n \n-    fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n+    pub fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n         let path = self.path_global(span, some);\n         self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n-    fn pat_none(&self, span: Span) -> P<ast::Pat> {\n+    pub fn pat_none(&self, span: Span) -> P<ast::Pat> {\n         let some = self.std_path(&[sym::option, sym::Option, sym::None]);\n         let path = self.path_global(span, some);\n         self.pat_path(span, path)\n     }\n \n-    fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n+    pub fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n         let path = self.path_global(span, some);\n         self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n-    fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n+    pub fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[sym::result, sym::Result, sym::Err]);\n         let path = self.path_global(span, some);\n         self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n-    fn arm(&self, span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {\n+    pub fn arm(&self, span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec![],\n             pats,\n@@ -884,25 +615,25 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn arm_unreachable(&self, span: Span) -> ast::Arm {\n+    pub fn arm_unreachable(&self, span: Span) -> ast::Arm {\n         self.arm(span, vec![self.pat_wild(span)], self.expr_unreachable(span))\n     }\n \n-    fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n+    pub fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n         self.expr(span, ast::ExprKind::Match(arg, arms))\n     }\n \n-    fn expr_if(&self, span: Span, cond: P<ast::Expr>,\n+    pub fn expr_if(&self, span: Span, cond: P<ast::Expr>,\n                then: P<ast::Expr>, els: Option<P<ast::Expr>>) -> P<ast::Expr> {\n         let els = els.map(|x| self.expr_block(self.block_expr(x)));\n         self.expr(span, ast::ExprKind::If(cond, self.block_expr(then), els))\n     }\n \n-    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr> {\n+    pub fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Loop(block, None))\n     }\n \n-    fn lambda_fn_decl(&self,\n+    pub fn lambda_fn_decl(&self,\n                       span: Span,\n                       fn_decl: P<ast::FnDecl>,\n                       body: P<ast::Expr>,\n@@ -916,7 +647,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                                                fn_decl_span))\n     }\n \n-    fn lambda(&self,\n+    pub fn lambda(&self,\n               span: Span,\n               ids: Vec<ast::Ident>,\n               body: P<ast::Expr>)\n@@ -937,30 +668,30 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                                                span))\n     }\n \n-    fn lambda0(&self, span: Span, body: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn lambda0(&self, span: Span, body: P<ast::Expr>) -> P<ast::Expr> {\n         self.lambda(span, Vec::new(), body)\n     }\n \n-    fn lambda1(&self, span: Span, body: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n+    pub fn lambda1(&self, span: Span, body: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda(span, vec![ident], body)\n     }\n \n-    fn lambda_stmts(&self,\n+    pub fn lambda_stmts(&self,\n                     span: Span,\n                     ids: Vec<ast::Ident>,\n                     stmts: Vec<ast::Stmt>)\n                     -> P<ast::Expr> {\n         self.lambda(span, ids, self.expr_block(self.block(span, stmts)))\n     }\n-    fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> {\n+    pub fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> {\n         self.lambda0(span, self.expr_block(self.block(span, stmts)))\n     }\n-    fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n+    pub fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda1(span, self.expr_block(self.block(span, stmts)), ident)\n     }\n \n-    fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Arg {\n+    pub fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Arg {\n         let arg_pat = self.pat_ident(span, ident);\n         ast::Arg {\n             attrs: ThinVec::default(),\n@@ -972,15 +703,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     // FIXME: unused `self`\n-    fn fn_decl(&self, inputs: Vec<ast::Arg>, output: ast::FunctionRetTy) -> P<ast::FnDecl> {\n+    pub fn fn_decl(&self, inputs: Vec<ast::Arg>, output: ast::FunctionRetTy) -> P<ast::FnDecl> {\n         P(ast::FnDecl {\n             inputs,\n             output,\n             c_variadic: false\n         })\n     }\n \n-    fn item(&self, span: Span, name: Ident,\n+    pub fn item(&self, span: Span, name: Ident,\n             attrs: Vec<ast::Attribute>, node: ast::ItemKind) -> P<ast::Item> {\n         // FIXME: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n@@ -995,7 +726,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn item_fn_poly(&self,\n+    pub fn item_fn_poly(&self,\n                     span: Span,\n                     name: Ident,\n                     inputs: Vec<ast::Arg> ,\n@@ -1016,7 +747,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               body))\n     }\n \n-    fn item_fn(&self,\n+    pub fn item_fn(&self,\n                span: Span,\n                name: Ident,\n                inputs: Vec<ast::Arg> ,\n@@ -1032,7 +763,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             body)\n     }\n \n-    fn variant(&self, span: Span, ident: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n+    pub fn variant(&self, span: Span, ident: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n         let fields: Vec<_> = tys.into_iter().map(|ty| {\n             ast::StructField {\n                 span: ty.span,\n@@ -1060,19 +791,19 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                })\n     }\n \n-    fn item_enum_poly(&self, span: Span, name: Ident,\n+    pub fn item_enum_poly(&self, span: Span, name: Ident,\n                       enum_definition: ast::EnumDef,\n                       generics: Generics) -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemKind::Enum(enum_definition, generics))\n     }\n \n-    fn item_enum(&self, span: Span, name: Ident,\n+    pub fn item_enum(&self, span: Span, name: Ident,\n                  enum_definition: ast::EnumDef) -> P<ast::Item> {\n         self.item_enum_poly(span, name, enum_definition,\n                             Generics::default())\n     }\n \n-    fn item_struct(&self, span: Span, name: Ident,\n+    pub fn item_struct(&self, span: Span, name: Ident,\n                    struct_def: ast::VariantData) -> P<ast::Item> {\n         self.item_struct_poly(\n             span,\n@@ -1082,12 +813,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         )\n     }\n \n-    fn item_struct_poly(&self, span: Span, name: Ident,\n+    pub fn item_struct_poly(&self, span: Span, name: Ident,\n         struct_def: ast::VariantData, generics: Generics) -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemKind::Struct(struct_def, generics))\n     }\n \n-    fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n+    pub fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n                 attrs: Vec<ast::Attribute>,\n                 items: Vec<P<ast::Item>>) -> P<ast::Item> {\n         self.item(\n@@ -1102,11 +833,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         )\n     }\n \n-    fn item_extern_crate(&self, span: Span, name: Ident) -> P<ast::Item> {\n+    pub fn item_extern_crate(&self, span: Span, name: Ident) -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemKind::ExternCrate(None))\n     }\n \n-    fn item_static(&self,\n+    pub fn item_static(&self,\n                    span: Span,\n                    name: Ident,\n                    ty: P<ast::Ty>,\n@@ -1116,7 +847,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.item(span, name, Vec::new(), ast::ItemKind::Static(ty, mutbl, expr))\n     }\n \n-    fn item_const(&self,\n+    pub fn item_const(&self,\n                   span: Span,\n                   name: Ident,\n                   ty: P<ast::Ty>,\n@@ -1125,39 +856,39 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.item(span, name, Vec::new(), ast::ItemKind::Const(ty, expr))\n     }\n \n-    fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n+    pub fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n                     generics: Generics) -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemKind::Ty(ty, generics))\n     }\n \n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item> {\n+    pub fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item> {\n         self.item_ty_poly(span, name, ty, Generics::default())\n     }\n \n-    fn attribute(&self, sp: Span, mi: ast::MetaItem) -> ast::Attribute {\n-        attr::mk_spanned_attr_outer(sp, attr::mk_attr_id(), mi)\n+    pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {\n+        attr::mk_attr_outer(mi)\n     }\n \n-    fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem {\n-        attr::mk_word_item(Ident::with_empty_ctxt(w).with_span_pos(sp))\n+    pub fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem {\n+        attr::mk_word_item(Ident::new(w, sp))\n     }\n \n-    fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem {\n-        attr::mk_nested_word_item(Ident::with_empty_ctxt(w).with_span_pos(sp))\n+    pub fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem {\n+        attr::mk_nested_word_item(Ident::new(w, sp))\n     }\n \n-    fn meta_list(&self, sp: Span, name: ast::Name, mis: Vec<ast::NestedMetaItem>)\n+    pub fn meta_list(&self, sp: Span, name: ast::Name, mis: Vec<ast::NestedMetaItem>)\n                  -> ast::MetaItem {\n-        attr::mk_list_item(sp, Ident::with_empty_ctxt(name).with_span_pos(sp), mis)\n+        attr::mk_list_item(sp, Ident::new(name, sp), mis)\n     }\n \n-    fn meta_name_value(&self, span: Span, name: ast::Name, lit_kind: ast::LitKind)\n+    pub fn meta_name_value(&self, span: Span, name: ast::Name, lit_kind: ast::LitKind)\n                        -> ast::MetaItem {\n-        attr::mk_name_value_item(span, Ident::with_empty_ctxt(name).with_span_pos(span),\n+        attr::mk_name_value_item(span, Ident::new(name, span),\n                                  lit_kind, span)\n     }\n \n-    fn item_use(&self, sp: Span,\n+    pub fn item_use(&self, sp: Span,\n                 vis: ast::Visibility, vp: P<ast::UseTree>) -> P<ast::Item> {\n         P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n@@ -1170,11 +901,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item> {\n+    pub fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item> {\n         self.item_use_simple_(sp, vis, None, path)\n     }\n \n-    fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n+    pub fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         rename: Option<ast::Ident>, path: ast::Path) -> P<ast::Item> {\n         self.item_use(sp, vis, P(ast::UseTree {\n             span: sp,\n@@ -1183,7 +914,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }))\n     }\n \n-    fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n+    pub fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n                      path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item> {\n         let imports = imports.iter().map(|id| {\n             (ast::UseTree {\n@@ -1200,7 +931,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }))\n     }\n \n-    fn item_use_glob(&self, sp: Span,\n+    pub fn item_use_glob(&self, sp: Span,\n                      vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item> {\n         self.item_use(sp, vis, P(ast::UseTree {\n             span: sp,"}, {"sha": "1e9e16d72f8297dab1add89b8c4d60b2918ff2cc", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -1340,10 +1340,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             }\n \n             let meta = attr::mk_list_item(DUMMY_SP, Ident::with_empty_ctxt(sym::doc), items);\n-            match at.style {\n-                ast::AttrStyle::Inner => *at = attr::mk_spanned_attr_inner(at.span, at.id, meta),\n-                ast::AttrStyle::Outer => *at = attr::mk_spanned_attr_outer(at.span, at.id, meta),\n-            }\n+            *at = attr::Attribute {\n+                span: at.span,\n+                id: at.id,\n+                style: at.style,\n+                path: meta.path,\n+                tokens: meta.node.tokens(meta.span),\n+                is_sugared_doc: false,\n+            };\n         } else {\n             noop_visit_attribute(at, self)\n         }"}, {"sha": "ec708994fad8616de0d5fa0a648ca10749038393", "filename": "src/libsyntax/ext/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -2,7 +2,6 @@ use crate::ast::{self, ItemKind, Attribute, Mac};\n use crate::attr::{mark_used, mark_known, HasAttrs};\n use crate::errors::{Applicability, FatalError};\n use crate::ext::base::{self, *};\n-use crate::ext::build::AstBuilder;\n use crate::ext::proc_macro_server;\n use crate::parse::{self, token};\n use crate::parse::parser::PathStyle;\n@@ -239,11 +238,11 @@ crate fn add_derived_markers<T: HasAttrs>(\n     item.visit_attrs(|attrs| {\n         if names.contains(&sym::Eq) && names.contains(&sym::PartialEq) {\n             let meta = cx.meta_word(span, sym::structural_match);\n-            attrs.push(cx.attribute(span, meta));\n+            attrs.push(cx.attribute(meta));\n         }\n         if names.contains(&sym::Copy) {\n             let meta = cx.meta_word(span, sym::rustc_copy_clone_marker);\n-            attrs.push(cx.attribute(span, meta));\n+            attrs.push(cx.attribute(meta));\n         }\n     });\n }"}, {"sha": "ce695df77757264292ba19143ca199e921b257ec", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -751,7 +751,7 @@ impl TokenSet {\n }\n \n // Checks that `matcher` is internally consistent and that it\n-// can legally by followed by a token N, for all N in `follow`.\n+// can legally be followed by a token `N`, for all `N` in `follow`.\n // (If `follow` is empty, then it imposes no constraint on\n // the `matcher`.)\n //"}, {"sha": "cad94a0e4c12050b21a277f80be52025b39ea47b", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -27,7 +27,7 @@ impl Delimited {\n         let open_span = if span.is_dummy() {\n             span\n         } else {\n-            span.with_lo(span.lo() + BytePos(self.delim.len() as u32))\n+            span.with_hi(span.lo() + BytePos(self.delim.len() as u32))\n         };\n         TokenTree::token(token::OpenDelim(self.delim), open_span)\n     }"}, {"sha": "a42da1123600a999fb6ac1343a2fa6cd3524f52f", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -53,7 +53,7 @@ impl<'a> Parser<'a> {\n                     just_parsed_doc_comment = false;\n                 }\n                 token::DocComment(s) => {\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, self.token.span);\n+                    let attr = attr::mk_sugared_doc_attr(s, self.token.span);\n                     if attr.style != ast::AttrStyle::Outer {\n                         let mut err = self.fatal(\"expected outer doc comment\");\n                         err.note(\"inner doc comments like this (starting with \\\n@@ -239,7 +239,7 @@ impl<'a> Parser<'a> {\n                 }\n                 token::DocComment(s) => {\n                     // we need to get the position of this token before we bump.\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, self.token.span);\n+                    let attr = attr::mk_sugared_doc_attr(s, self.token.span);\n                     if attr.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n                         self.bump();"}, {"sha": "880dd6e164982f4cb5dced000f4d92690c76d0f8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -6395,15 +6395,8 @@ impl<'a> Parser<'a> {\n                     self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n                 // Record that we fetched the mod from an external file\n                 if warn {\n-                    let attr = Attribute {\n-                        id: attr::mk_attr_id(),\n-                        style: ast::AttrStyle::Outer,\n-                        path: ast::Path::from_ident(\n-                            Ident::with_empty_ctxt(sym::warn_directory_ownership)),\n-                        tokens: TokenStream::empty(),\n-                        is_sugared_doc: false,\n-                        span: DUMMY_SP,\n-                    };\n+                    let attr = attr::mk_attr_outer(\n+                        attr::mk_word_item(Ident::with_empty_ctxt(sym::warn_directory_ownership)));\n                     attr::mark_known(&attr);\n                     attrs.push(attr);\n                 }"}, {"sha": "f3989be45ddc4e6940e34c2dcd09b24a9e141a69", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -126,12 +126,12 @@ pub fn print_crate<'a>(cm: &'a SourceMap,\n         let pi_nested = attr::mk_nested_word_item(ast::Ident::with_empty_ctxt(sym::prelude_import));\n         let list = attr::mk_list_item(\n             DUMMY_SP, ast::Ident::with_empty_ctxt(sym::feature), vec![pi_nested]);\n-        let fake_attr = attr::mk_attr_inner(DUMMY_SP, attr::mk_attr_id(), list);\n+        let fake_attr = attr::mk_attr_inner(list);\n         s.print_attribute(&fake_attr);\n \n         // #![no_std]\n         let no_std_meta = attr::mk_word_item(ast::Ident::with_empty_ctxt(sym::no_std));\n-        let fake_attr = attr::mk_attr_inner(DUMMY_SP, attr::mk_attr_id(), no_std_meta);\n+        let fake_attr = attr::mk_attr_inner(no_std_meta);\n         s.print_attribute(&fake_attr);\n     }\n "}, {"sha": "b10d8fcd357c422fcb3a218b83c356864ec6c6b5", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -3,7 +3,6 @@ use errors::{Applicability, DiagnosticBuilder};\n use syntax::ast::{self, *};\n use syntax::source_map::Spanned;\n use syntax::ext::base::*;\n-use syntax::ext::build::AstBuilder;\n use syntax::parse::token::{self, TokenKind};\n use syntax::parse::parser::Parser;\n use syntax::print::pprust;"}, {"sha": "84830e6ddda1a0855e70ff06ff4544713402d249", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -6,7 +6,6 @@ use errors::DiagnosticBuilder;\n \n use syntax::ast;\n use syntax::ext::base::{self, *};\n-use syntax::ext::build::AstBuilder;\n use syntax::attr;\n use syntax::tokenstream;\n use syntax::parse::token;"}, {"sha": "f1d079eb05379fb22d803c86cdf9ad9acabbb652", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -1,6 +1,5 @@\n use syntax::ast;\n use syntax::ext::base;\n-use syntax::ext::build::AstBuilder;\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n "}, {"sha": "2340238aaea41bb94b9b86cdbe6455d38df882cf", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -5,7 +5,6 @@ use crate::deriving::generic::ty::*;\n use syntax::ast::{self, Expr, GenericArg, Generics, ItemKind, MetaItem, VariantData};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n@@ -77,7 +76,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n     }\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(span, inline)];\n+    let attrs = vec![cx.attribute(inline)];\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),"}, {"sha": "0c34599814a79fa49a54a989bdd583095b5c51d3", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -4,7 +4,6 @@ use crate::deriving::generic::ty::*;\n \n use syntax::ast::{self, Expr, MetaItem, GenericArg};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::{sym, Symbol};\n use syntax_pos::Span;\n@@ -17,7 +16,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt<'_>,\n     let inline = cx.meta_word(span, sym::inline);\n     let hidden = cx.meta_list_item_word(span, sym::hidden);\n     let doc = cx.meta_list(span, sym::doc, vec![hidden]);\n-    let attrs = vec![cx.attribute(span, inline), cx.attribute(span, doc)];\n+    let attrs = vec![cx.attribute(inline), cx.attribute(doc)];\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),"}, {"sha": "885cfee35658a8bc0e4f9e9035403e7d8626b7fc", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -4,7 +4,6 @@ use crate::deriving::generic::ty::*;\n \n use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n@@ -15,7 +14,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt<'_>,\n                            item: &Annotatable,\n                            push: &mut dyn FnMut(Annotatable)) {\n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(span, inline)];\n+    let attrs = vec![cx.attribute(inline)];\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),"}, {"sha": "337f7c5cfe238e3b6fb34e6d26949219b4c4fa64", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -4,7 +4,6 @@ use crate::deriving::generic::ty::*;\n \n use syntax::ast::{BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n@@ -63,7 +62,7 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n     macro_rules! md {\n         ($name:expr, $f:ident) => { {\n             let inline = cx.meta_word(span, sym::inline);\n-            let attrs = vec![cx.attribute(span, inline)];\n+            let attrs = vec![cx.attribute(inline)];\n             MethodDef {\n                 name: $name,\n                 generics: LifetimeBounds::empty(),"}, {"sha": "0ec30f5924fbe273ef24129976d51d1222325003", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -6,7 +6,6 @@ use crate::deriving::generic::ty::*;\n \n use syntax::ast::{self, BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::{sym, Symbol};\n use syntax_pos::Span;\n@@ -19,7 +18,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt<'_>,\n     macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, sym::inline);\n-            let attrs = vec![cx.attribute(span, inline)];\n+            let attrs = vec![cx.attribute(inline)];\n             MethodDef {\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n@@ -43,7 +42,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt<'_>,\n                                     PathKind::Std));\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(span, inline)];\n+    let attrs = vec![cx.attribute(inline)];\n \n     let partial_cmp_def = MethodDef {\n         name: \"partial_cmp\","}, {"sha": "0f709630bf41eafda3a4289c7dd839e804bbee36", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::thin_vec::ThinVec;\n use syntax::ast::{self, Ident};\n use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, Span};"}, {"sha": "293c5a1e7e71b867bed4c2dccdba687f8c93fca9", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -7,7 +7,6 @@ use crate::deriving::generic::ty::*;\n use syntax::ast;\n use syntax::ast::{Expr, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;"}, {"sha": "2fdea10b76f5170a4c3ea84b17acd93f9c3b664f", "filename": "src/libsyntax_ext/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -4,7 +4,6 @@ use crate::deriving::generic::ty::*;\n \n use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, DummyResult, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym};\n use syntax::span_err;\n@@ -16,7 +15,7 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt<'_>,\n                                item: &Annotatable,\n                                push: &mut dyn FnMut(Annotatable)) {\n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(span, inline)];\n+    let attrs = vec![cx.attribute(inline)];\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),"}, {"sha": "6d0d3b96a56d669eb33ba5084b411578433fe28d", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -88,7 +88,6 @@ use crate::deriving::generic::ty::*;\n \n use syntax::ast::{Expr, ExprKind, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;"}, {"sha": "4a0c4a39f785b0c50f38d826536d9588e5e16acb", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -187,7 +187,6 @@ use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n use syntax::ast::{VariantData, GenericParamKind, GenericArg};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::source_map::{self, respan};\n use syntax::util::map_in_place::MapInPlace;\n use syntax::ptr::P;\n@@ -666,14 +665,13 @@ impl<'a> TraitDef<'a> {\n         let path = cx.path_all(self.span, false, vec![type_ident], self_params, vec![]);\n         let self_type = cx.ty_path(path);\n \n-        let attr = cx.attribute(self.span,\n-                                cx.meta_word(self.span, sym::automatically_derived));\n+        let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n         let unused_qual = {\n             let word = cx.meta_list_item_word(self.span, Symbol::intern(\"unused_qualifications\"));\n-            cx.attribute(self.span, cx.meta_list(self.span, sym::allow, vec![word]))\n+            cx.attribute(cx.meta_list(self.span, sym::allow, vec![word]))\n         };\n \n         let mut a = vec![attr, unused_qual];"}, {"sha": "399829eaefd14be930e2e48b78e03a30b341a7e0", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -6,7 +6,6 @@ pub use Ty::*;\n \n use syntax::ast::{self, Expr, GenericParamKind, Generics, Ident, SelfKind, GenericArg};\n use syntax::ext::base::ExtCtxt;\n-use syntax::ext::build::AstBuilder;\n use syntax::source_map::{respan, DUMMY_SP};\n use syntax::ptr::P;\n use syntax_pos::Span;"}, {"sha": "9787722e81dd065827da3c6f41a80c14b480219d", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -4,7 +4,6 @@ use crate::deriving::generic::ty::*;\n \n use syntax::ast::{Expr, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::sym;\n use syntax_pos::Span;"}, {"sha": "8cd2853e5383ddb81fccccd982ce99d44f54758f", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -2,7 +2,6 @@\n \n use syntax::ast::{self, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt, MultiItemModifier};\n-use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;"}, {"sha": "39fc90decc92abccbc511e0fca9633554a60045b", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -5,7 +5,6 @@\n \n use syntax::ast::{self, Ident, GenericArg};\n use syntax::ext::base::{self, *};\n-use syntax::ext::build::AstBuilder;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n use syntax::tokenstream;"}, {"sha": "2a299cc4f9241c28c0bd1ea6d4ec800701f6aea6", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -8,7 +8,6 @@ use errors::Applicability;\n \n use syntax::ast;\n use syntax::ext::base::{self, *};\n-use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, sym};"}, {"sha": "f788b5138043337452e3d052ea27a155c1de68e0", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -3,7 +3,6 @@ use syntax::ast::{self, Arg, Attribute, Expr, FnHeader, Generics, Ident};\n use syntax::attr::check_builtin_macro_attribute;\n use syntax::ext::allocator::{AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym, Symbol};\n@@ -110,7 +109,7 @@ impl AllocFnFactory<'_, '_> {\n     fn attrs(&self) -> Vec<Attribute> {\n         let special = sym::rustc_std_internal_symbol;\n         let special = self.cx.meta_word(self.span, special);\n-        vec![self.cx.attribute(self.span, special)]\n+        vec![self.cx.attribute(special)]\n     }\n \n     fn arg_ty("}, {"sha": "a725f5e46ad1c813a5cb11b9c05a85ae80f029de", "filename": "src/libsyntax_ext/plugin_macro_defs.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -16,14 +16,8 @@ use syntax_pos::hygiene::{ExpnId, ExpnInfo, ExpnKind, MacroKind};\n use std::mem;\n \n fn plugin_macro_def(name: Name, span: Span) -> P<Item> {\n-    let rustc_builtin_macro = Attribute {\n-        id: attr::mk_attr_id(),\n-        style: AttrStyle::Outer,\n-        path: Path::from_ident(Ident::new(sym::rustc_builtin_macro, span)),\n-        tokens: TokenStream::empty(),\n-        is_sugared_doc: false,\n-        span,\n-    };\n+    let rustc_builtin_macro = attr::mk_attr_outer(\n+        attr::mk_word_item(Ident::new(sym::rustc_builtin_macro, span)));\n \n     let parens: TreeAndJoint = TokenTree::Delimited(\n         DelimSpan::from_single(span), token::Paren, TokenStream::empty()"}, {"sha": "7913a7442edc74eccaa3b4ffd5a60d32f8c1f004", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -4,7 +4,6 @@ use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::source_map::{ExpnInfo, ExpnKind, respan};\n use syntax::ext::base::{ExtCtxt, MacroKind};\n-use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::ext::hygiene::ExpnId;\n use syntax::ext::proc_macro::is_proc_macro_attr;\n@@ -337,7 +336,7 @@ fn mk_decls(\n \n     let hidden = cx.meta_list_item_word(span, sym::hidden);\n     let doc = cx.meta_list(span, sym::doc, vec![hidden]);\n-    let doc_hidden = cx.attribute(span, doc);\n+    let doc_hidden = cx.attribute(doc);\n \n     let proc_macro = Ident::with_empty_ctxt(sym::proc_macro);\n     let krate = cx.item(span,\n@@ -394,7 +393,7 @@ fn mk_decls(\n         cx.expr_vec_slice(span, decls),\n     ).map(|mut i| {\n         let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);\n-        i.attrs.push(cx.attribute(span, attr));\n+        i.attrs.push(cx.attribute(attr));\n         i.vis = respan(span, ast::VisibilityKind::Public);\n         i\n     });"}, {"sha": "2c8d53a23155071efce24cc046d95012289fb4c6", "filename": "src/libsyntax_ext/source_util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fsource_util.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -1,6 +1,5 @@\n use syntax::{ast, panictry};\n use syntax::ext::base::{self, *};\n-use syntax::ext::build::AstBuilder;\n use syntax::parse::{self, token, DirectoryOwnership};\n use syntax::print::pprust;\n use syntax::ptr::P;"}, {"sha": "68b13bdd171a9982c9d08dab7f7e71e11ec78730", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -4,7 +4,6 @@ use syntax::ext::hygiene::{ExpnId, MacroKind};\n use syntax::ptr::P;\n use syntax::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n use syntax::symbol::{Ident, Symbol, kw, sym};\n-use syntax::tokenstream::TokenStream;\n use syntax_pos::DUMMY_SP;\n \n use std::iter;\n@@ -41,8 +40,6 @@ pub fn inject(\n         };\n         krate.module.items.insert(0, P(ast::Item {\n             attrs: vec![attr::mk_attr_outer(\n-                DUMMY_SP,\n-                attr::mk_attr_id(),\n                 attr::mk_word_item(ast::Ident::with_empty_ctxt(sym::macro_use))\n             )],\n             vis: dummy_spanned(ast::VisibilityKind::Inherited),\n@@ -64,14 +61,8 @@ pub fn inject(\n     ));\n \n     krate.module.items.insert(0, P(ast::Item {\n-        attrs: vec![ast::Attribute {\n-            style: ast::AttrStyle::Outer,\n-            path: ast::Path::from_ident(ast::Ident::new(sym::prelude_import, span)),\n-            tokens: TokenStream::empty(),\n-            id: attr::mk_attr_id(),\n-            is_sugared_doc: false,\n-            span,\n-        }],\n+        attrs: vec![attr::mk_attr_outer(\n+            attr::mk_word_item(ast::Ident::new(sym::prelude_import, span)))],\n         vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {"}, {"sha": "993ef25752757ae24bad867fc6d9a46acef4d93d", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -4,7 +4,6 @@\n use syntax::ast;\n use syntax::attr::{self, check_builtin_macro_attribute};\n use syntax::ext::base::*;\n-use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::print::pprust;\n use syntax::source_map::respan;\n@@ -36,8 +35,7 @@ pub fn expand_test_case(\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n         item.ident = item.ident.gensym();\n         item.attrs.push(\n-            ecx.attribute(sp,\n-                ecx.meta_word(sp, sym::rustc_test_marker))\n+            ecx.attribute(ecx.meta_word(sp, sym::rustc_test_marker))\n         );\n         item\n     });\n@@ -150,11 +148,11 @@ pub fn expand_test_or_bench(\n     let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name, sp).gensym(),\n         vec![\n             // #[cfg(test)]\n-            cx.attribute(attr_sp, cx.meta_list(attr_sp, sym::cfg, vec![\n+            cx.attribute(cx.meta_list(attr_sp, sym::cfg, vec![\n                 cx.meta_list_item_word(attr_sp, sym::test)\n             ])),\n             // #[rustc_test_marker]\n-            cx.attribute(attr_sp, cx.meta_word(attr_sp, sym::rustc_test_marker)),\n+            cx.attribute(cx.meta_word(attr_sp, sym::rustc_test_marker)),\n         ],\n         // const $ident: test::TestDescAndFn =\n         ast::ItemKind::Const(cx.ty(sp, ast::TyKind::Path(None, test_path(\"TestDescAndFn\"))),"}, {"sha": "4b3903c7ad7d37a851430707c0e33ad029b028bd", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -6,7 +6,6 @@ use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::entry::{self, EntryPointType};\n use syntax::ext::base::{ExtCtxt, Resolver};\n-use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::ext::hygiene::{ExpnId, MacroKind};\n use syntax::feature_gate::Features;\n@@ -160,9 +159,7 @@ impl MutVisitor for EntryPointCleaner {\n                     let dc_nested = attr::mk_nested_word_item(Ident::from_str(\"dead_code\"));\n                     let allow_dead_code_item = attr::mk_list_item(DUMMY_SP, allow_ident,\n                                                                   vec![dc_nested]);\n-                    let allow_dead_code = attr::mk_attr_outer(DUMMY_SP,\n-                                                              attr::mk_attr_id(),\n-                                                              allow_dead_code_item);\n+                    let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n \n                     ast::Item {\n                         id,\n@@ -295,7 +292,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n \n     // #![main]\n     let main_meta = ecx.meta_word(sp, sym::main);\n-    let main_attr = ecx.attribute(sp, main_meta);\n+    let main_attr = ecx.attribute(main_meta);\n \n     // extern crate test as test_gensym\n     let test_extern_stmt = ecx.stmt_item(sp, ecx.item(sp,"}, {"sha": "f3cd2397b28fe3ddd769129dc809fae931df6308", "filename": "src/test/ui-fulldeps/auxiliary/plugin-args.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fplugin-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fplugin-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fplugin-args.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -11,7 +11,6 @@ extern crate rustc_driver;\n \n use std::borrow::ToOwned;\n use syntax::ast;\n-use syntax::ext::build::AstBuilder;\n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacEager};\n use syntax::print::pprust;"}, {"sha": "77fa5c2cd78981de6881d9550e6838ebc26dba64", "filename": "src/test/ui-fulldeps/auxiliary/roman-numerals.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Froman-numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Froman-numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Froman-numerals.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -18,7 +18,6 @@ extern crate rustc_driver;\n use syntax::parse::token::{self, Token};\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n-use syntax::ext::build::AstBuilder;  // A trait for expr_usize.\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n "}, {"sha": "d569c6a201b2b5a756ca90655196b4b69371dd78", "filename": "src/test/ui/consts/const-int-unchecked.stderr", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -4,7 +4,7 @@ error: any use of this value will cause an error\n LL | const SHL_U8: u8 = unsafe { intrinsics::unchecked_shl(5_u8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                             |\n-   |                             Overflowing shift by 8 in unchecked_shl\n+   |                             Overflowing shift by 8 in `unchecked_shl`\n    |\n    = note: `#[deny(const_err)]` on by default\n \n@@ -14,311 +14,311 @@ error: any use of this value will cause an error\n LL | const SHL_U16: u16 = unsafe { intrinsics::unchecked_shl(5_u16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 16 in unchecked_shl\n+   |                               Overflowing shift by 16 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:18:31\n    |\n LL | const SHL_U32: u32 = unsafe { intrinsics::unchecked_shl(5_u32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 32 in unchecked_shl\n+   |                               Overflowing shift by 32 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:20:31\n    |\n LL | const SHL_U64: u64 = unsafe { intrinsics::unchecked_shl(5_u64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 64 in unchecked_shl\n+   |                               Overflowing shift by 64 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:22:33\n    |\n LL | const SHL_U128: u128 = unsafe { intrinsics::unchecked_shl(5_u128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 128 in unchecked_shl\n+   |                                 Overflowing shift by 128 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:27:29\n    |\n LL | const SHL_I8: i8 = unsafe { intrinsics::unchecked_shl(5_i8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                             |\n-   |                             Overflowing shift by 8 in unchecked_shl\n+   |                             Overflowing shift by 8 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:29:31\n    |\n LL | const SHL_I16: i16 = unsafe { intrinsics::unchecked_shl(5_16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 16 in unchecked_shl\n+   |                               Overflowing shift by 16 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:31:31\n    |\n LL | const SHL_I32: i32 = unsafe { intrinsics::unchecked_shl(5_i32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 32 in unchecked_shl\n+   |                               Overflowing shift by 32 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:33:31\n    |\n LL | const SHL_I64: i64 = unsafe { intrinsics::unchecked_shl(5_i64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 64 in unchecked_shl\n+   |                               Overflowing shift by 64 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:35:33\n    |\n LL | const SHL_I128: i128 = unsafe { intrinsics::unchecked_shl(5_i128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 128 in unchecked_shl\n+   |                                 Overflowing shift by 128 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:40:33\n    |\n LL | const SHL_I8_NEG: i8 = unsafe { intrinsics::unchecked_shl(5_i8, -1) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 255 in unchecked_shl\n+   |                                 Overflowing shift by 255 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:42:35\n    |\n LL | const SHL_I16_NEG: i16 = unsafe { intrinsics::unchecked_shl(5_16, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 65535 in unchecked_shl\n+   |                                   Overflowing shift by 65535 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:44:35\n    |\n LL | const SHL_I32_NEG: i32 = unsafe { intrinsics::unchecked_shl(5_i32, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 4294967295 in unchecked_shl\n+   |                                   Overflowing shift by 4294967295 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:46:35\n    |\n LL | const SHL_I64_NEG: i64 = unsafe { intrinsics::unchecked_shl(5_i64, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 18446744073709551615 in unchecked_shl\n+   |                                   Overflowing shift by 18446744073709551615 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:48:37\n    |\n LL | const SHL_I128_NEG: i128 = unsafe { intrinsics::unchecked_shl(5_i128, -1) };\n    | ------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                     |\n-   |                                     Overflowing shift by 340282366920938463463374607431768211455 in unchecked_shl\n+   |                                     Overflowing shift by 340282366920938463463374607431768211455 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:54:40\n    |\n LL | const SHL_I8_NEG_RANDOM: i8 = unsafe { intrinsics::unchecked_shl(5_i8, -6) };\n    | ---------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                        |\n-   |                                        Overflowing shift by 250 in unchecked_shl\n+   |                                        Overflowing shift by 250 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:56:42\n    |\n LL | const SHL_I16_NEG_RANDOM: i16 = unsafe { intrinsics::unchecked_shl(5_16, -13) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 65523 in unchecked_shl\n+   |                                          Overflowing shift by 65523 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:58:42\n    |\n LL | const SHL_I32_NEG_RANDOM: i32 = unsafe { intrinsics::unchecked_shl(5_i32, -25) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 4294967271 in unchecked_shl\n+   |                                          Overflowing shift by 4294967271 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:60:42\n    |\n LL | const SHL_I64_NEG_RANDOM: i64 = unsafe { intrinsics::unchecked_shl(5_i64, -30) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 18446744073709551586 in unchecked_shl\n+   |                                          Overflowing shift by 18446744073709551586 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:62:44\n    |\n LL | const SHL_I128_NEG_RANDOM: i128 = unsafe { intrinsics::unchecked_shl(5_i128, -93) };\n    | -------------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                            |\n-   |                                            Overflowing shift by 340282366920938463463374607431768211363 in unchecked_shl\n+   |                                            Overflowing shift by 340282366920938463463374607431768211363 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:69:29\n    |\n LL | const SHR_U8: u8 = unsafe { intrinsics::unchecked_shr(5_u8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                             |\n-   |                             Overflowing shift by 8 in unchecked_shr\n+   |                             Overflowing shift by 8 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:71:31\n    |\n LL | const SHR_U16: u16 = unsafe { intrinsics::unchecked_shr(5_u16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 16 in unchecked_shr\n+   |                               Overflowing shift by 16 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:73:31\n    |\n LL | const SHR_U32: u32 = unsafe { intrinsics::unchecked_shr(5_u32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 32 in unchecked_shr\n+   |                               Overflowing shift by 32 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:75:31\n    |\n LL | const SHR_U64: u64 = unsafe { intrinsics::unchecked_shr(5_u64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 64 in unchecked_shr\n+   |                               Overflowing shift by 64 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:77:33\n    |\n LL | const SHR_U128: u128 = unsafe { intrinsics::unchecked_shr(5_u128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 128 in unchecked_shr\n+   |                                 Overflowing shift by 128 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:82:29\n    |\n LL | const SHR_I8: i8 = unsafe { intrinsics::unchecked_shr(5_i8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                             |\n-   |                             Overflowing shift by 8 in unchecked_shr\n+   |                             Overflowing shift by 8 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:84:31\n    |\n LL | const SHR_I16: i16 = unsafe { intrinsics::unchecked_shr(5_16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 16 in unchecked_shr\n+   |                               Overflowing shift by 16 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:86:31\n    |\n LL | const SHR_I32: i32 = unsafe { intrinsics::unchecked_shr(5_i32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 32 in unchecked_shr\n+   |                               Overflowing shift by 32 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:88:31\n    |\n LL | const SHR_I64: i64 = unsafe { intrinsics::unchecked_shr(5_i64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 64 in unchecked_shr\n+   |                               Overflowing shift by 64 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:90:33\n    |\n LL | const SHR_I128: i128 = unsafe { intrinsics::unchecked_shr(5_i128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 128 in unchecked_shr\n+   |                                 Overflowing shift by 128 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:95:33\n    |\n LL | const SHR_I8_NEG: i8 = unsafe { intrinsics::unchecked_shr(5_i8, -1) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 255 in unchecked_shr\n+   |                                 Overflowing shift by 255 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:97:35\n    |\n LL | const SHR_I16_NEG: i16 = unsafe { intrinsics::unchecked_shr(5_16, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 65535 in unchecked_shr\n+   |                                   Overflowing shift by 65535 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:99:35\n    |\n LL | const SHR_I32_NEG: i32 = unsafe { intrinsics::unchecked_shr(5_i32, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 4294967295 in unchecked_shr\n+   |                                   Overflowing shift by 4294967295 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:101:35\n    |\n LL | const SHR_I64_NEG: i64 = unsafe { intrinsics::unchecked_shr(5_i64, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 18446744073709551615 in unchecked_shr\n+   |                                   Overflowing shift by 18446744073709551615 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:103:37\n    |\n LL | const SHR_I128_NEG: i128 = unsafe { intrinsics::unchecked_shr(5_i128, -1) };\n    | ------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                     |\n-   |                                     Overflowing shift by 340282366920938463463374607431768211455 in unchecked_shr\n+   |                                     Overflowing shift by 340282366920938463463374607431768211455 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:109:40\n    |\n LL | const SHR_I8_NEG_RANDOM: i8 = unsafe { intrinsics::unchecked_shr(5_i8, -6) };\n    | ---------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                        |\n-   |                                        Overflowing shift by 250 in unchecked_shr\n+   |                                        Overflowing shift by 250 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:111:42\n    |\n LL | const SHR_I16_NEG_RANDOM: i16 = unsafe { intrinsics::unchecked_shr(5_16, -13) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 65523 in unchecked_shr\n+   |                                          Overflowing shift by 65523 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:113:42\n    |\n LL | const SHR_I32_NEG_RANDOM: i32 = unsafe { intrinsics::unchecked_shr(5_i32, -25) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 4294967271 in unchecked_shr\n+   |                                          Overflowing shift by 4294967271 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:115:42\n    |\n LL | const SHR_I64_NEG_RANDOM: i64 = unsafe { intrinsics::unchecked_shr(5_i64, -30) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 18446744073709551586 in unchecked_shr\n+   |                                          Overflowing shift by 18446744073709551586 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:117:44\n    |\n LL | const SHR_I128_NEG_RANDOM: i128 = unsafe { intrinsics::unchecked_shr(5_i128, -93) };\n    | -------------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                            |\n-   |                                            Overflowing shift by 340282366920938463463374607431768211363 in unchecked_shr\n+   |                                            Overflowing shift by 340282366920938463463374607431768211363 in `unchecked_shr`\n \n error: aborting due to 40 previous errors\n "}, {"sha": "61ae79d235ee53f0f3fccd1e6a1559e7992f9d17", "filename": "src/test/ui/macros/macro-follow.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Ftest%2Fui%2Fmacros%2Fmacro-follow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Ftest%2Fui%2Fmacros%2Fmacro-follow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-follow.stderr?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -1,24 +1,24 @@\n error: `$p:pat` is followed by `(`, which is not allowed for `pat` fragments\n-  --> $DIR/macro-follow.rs:8:14\n+  --> $DIR/macro-follow.rs:8:13\n    |\n LL |     ($p:pat ()) => {};\n-   |              ^ not allowed after `pat` fragments\n+   |             ^ not allowed after `pat` fragments\n    |\n    = note: allowed there are: `=>`, `,`, `=`, `|`, `if` or `in`\n \n error: `$p:pat` is followed by `[`, which is not allowed for `pat` fragments\n-  --> $DIR/macro-follow.rs:9:14\n+  --> $DIR/macro-follow.rs:9:13\n    |\n LL |     ($p:pat []) => {};\n-   |              ^ not allowed after `pat` fragments\n+   |             ^ not allowed after `pat` fragments\n    |\n    = note: allowed there are: `=>`, `,`, `=`, `|`, `if` or `in`\n \n error: `$p:pat` is followed by `{`, which is not allowed for `pat` fragments\n-  --> $DIR/macro-follow.rs:10:14\n+  --> $DIR/macro-follow.rs:10:13\n    |\n LL |     ($p:pat {}) => {};\n-   |              ^ not allowed after `pat` fragments\n+   |             ^ not allowed after `pat` fragments\n    |\n    = note: allowed there are: `=>`, `,`, `=`, `|`, `if` or `in`\n \n@@ -135,26 +135,26 @@ LL |     ($p:pat $m:meta) => {};\n    = note: allowed there are: `=>`, `,`, `=`, `|`, `if` or `in`\n \n error: `$e:expr` is followed by `(`, which is not allowed for `expr` fragments\n-  --> $DIR/macro-follow.rs:28:15\n+  --> $DIR/macro-follow.rs:28:14\n    |\n LL |     ($e:expr ()) => {};\n-   |               ^ not allowed after `expr` fragments\n+   |              ^ not allowed after `expr` fragments\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$e:expr` is followed by `[`, which is not allowed for `expr` fragments\n-  --> $DIR/macro-follow.rs:29:15\n+  --> $DIR/macro-follow.rs:29:14\n    |\n LL |     ($e:expr []) => {};\n-   |               ^ not allowed after `expr` fragments\n+   |              ^ not allowed after `expr` fragments\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$e:expr` is followed by `{`, which is not allowed for `expr` fragments\n-  --> $DIR/macro-follow.rs:30:15\n+  --> $DIR/macro-follow.rs:30:14\n    |\n LL |     ($e:expr {}) => {};\n-   |               ^ not allowed after `expr` fragments\n+   |              ^ not allowed after `expr` fragments\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n \n@@ -303,10 +303,10 @@ LL |     ($e:expr $m:meta) => {};\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$t:ty` is followed by `(`, which is not allowed for `ty` fragments\n-  --> $DIR/macro-follow.rs:53:13\n+  --> $DIR/macro-follow.rs:53:12\n    |\n LL |     ($t:ty ()) => {};\n-   |             ^ not allowed after `ty` fragments\n+   |            ^ not allowed after `ty` fragments\n    |\n    = note: allowed there are: `{`, `[`, `=>`, `,`, `>`, `=`, `:`, `;`, `|`, `as` or `where`\n \n@@ -407,26 +407,26 @@ LL |     ($t:ty $m:meta) => {};\n    = note: allowed there are: `{`, `[`, `=>`, `,`, `>`, `=`, `:`, `;`, `|`, `as` or `where`\n \n error: `$s:stmt` is followed by `(`, which is not allowed for `stmt` fragments\n-  --> $DIR/macro-follow.rs:71:15\n+  --> $DIR/macro-follow.rs:71:14\n    |\n LL |     ($s:stmt ()) => {};\n-   |               ^ not allowed after `stmt` fragments\n+   |              ^ not allowed after `stmt` fragments\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$s:stmt` is followed by `[`, which is not allowed for `stmt` fragments\n-  --> $DIR/macro-follow.rs:72:15\n+  --> $DIR/macro-follow.rs:72:14\n    |\n LL |     ($s:stmt []) => {};\n-   |               ^ not allowed after `stmt` fragments\n+   |              ^ not allowed after `stmt` fragments\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$s:stmt` is followed by `{`, which is not allowed for `stmt` fragments\n-  --> $DIR/macro-follow.rs:73:15\n+  --> $DIR/macro-follow.rs:73:14\n    |\n LL |     ($s:stmt {}) => {};\n-   |               ^ not allowed after `stmt` fragments\n+   |              ^ not allowed after `stmt` fragments\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n \n@@ -575,10 +575,10 @@ LL |     ($s:stmt $m:meta) => {};\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$p:path` is followed by `(`, which is not allowed for `path` fragments\n-  --> $DIR/macro-follow.rs:95:15\n+  --> $DIR/macro-follow.rs:95:14\n    |\n LL |     ($p:path ()) => {};\n-   |               ^ not allowed after `path` fragments\n+   |              ^ not allowed after `path` fragments\n    |\n    = note: allowed there are: `{`, `[`, `=>`, `,`, `>`, `=`, `:`, `;`, `|`, `as` or `where`\n "}, {"sha": "66fb8dd0deaf425239ae33c23b00898586ac883e", "filename": "src/test/ui/type-alias-enum-variants/issue-63151-dead-code-lint-fields-in-patterns.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a45743345659c775b01484574af2818c46a2cb03/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fissue-63151-dead-code-lint-fields-in-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a45743345659c775b01484574af2818c46a2cb03/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fissue-63151-dead-code-lint-fields-in-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fissue-63151-dead-code-lint-fields-in-patterns.rs?ref=a45743345659c775b01484574af2818c46a2cb03", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+\n+// Regression test for the issue #63151:\n+// Spurious unused field warning when matching variants under a `Self` scope\n+//\n+// This test checks that the `dead_code` lint properly inspects fields\n+// in struct patterns that use a type relative path.\n+\n+#![deny(dead_code)]\n+\n+enum Enum {\n+    Variant { field: usize }\n+}\n+\n+impl Enum {\n+    fn read_field(self) -> usize {\n+        match self {\n+            Self::Variant { field } => field\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let e = Enum::Variant { field: 42 };\n+    println!(\"{}\", e.read_field());\n+}"}]}