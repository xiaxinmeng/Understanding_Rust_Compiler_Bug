{"sha": "e7158dc8f174126780ac6caa864bccede5dda262", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MTU4ZGM4ZjE3NDEyNjc4MGFjNmNhYTg2NGJjY2VkZTVkZGEyNjI=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-26T00:49:45Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-28T16:05:43Z"}, "message": "s/cx.span_lint/span_lint(cx, /", "tree": {"sha": "dfb27cf1cb90fb4ee848eb6d8289c40c9e831070", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfb27cf1cb90fb4ee848eb6d8289c40c9e831070"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7158dc8f174126780ac6caa864bccede5dda262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7158dc8f174126780ac6caa864bccede5dda262", "html_url": "https://github.com/rust-lang/rust/commit/e7158dc8f174126780ac6caa864bccede5dda262", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7158dc8f174126780ac6caa864bccede5dda262/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d5e3f311841617eba62089212c1b43120c13921", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d5e3f311841617eba62089212c1b43120c13921", "html_url": "https://github.com/rust-lang/rust/commit/2d5e3f311841617eba62089212c1b43120c13921"}], "stats": {"total": 41, "additions": 23, "deletions": 18}, "files": [{"sha": "5a787ba6dbaf1e08c14e604274f37b4c91056b9e", "filename": "src/misc.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7158dc8f174126780ac6caa864bccede5dda262/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7158dc8f174126780ac6caa864bccede5dda262/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=e7158dc8f174126780ac6caa864bccede5dda262", "patch": "@@ -312,7 +312,7 @@ impl LateLintPass for ModuloOne {\n         if let ExprBinary(ref cmp, _, ref right) = expr.node {\n             if let Spanned {node: BinOp_::BiRem, ..} = *cmp {\n                 if is_integer_literal(right, 1) {\n-                    cx.span_lint(MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n+                    span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }\n             }\n         }\n@@ -347,11 +347,12 @@ impl LateLintPass for PatternPass {\n     fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n         if let PatKind::Ident(_, ref ident, Some(ref right)) = pat.node {\n             if right.node == PatKind::Wild {\n-                cx.span_lint(REDUNDANT_PATTERN,\n-                             pat.span,\n-                             &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n-                                      ident.node.name,\n-                                      ident.node.name));\n+                span_lint(cx,\n+                          REDUNDANT_PATTERN,\n+                          pat.span,\n+                          &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n+                                   ident.node.name,\n+                                   ident.node.name));\n             }\n         }\n     }\n@@ -408,10 +409,11 @@ impl LateLintPass for UsedUnderscoreBinding {\n             _ => false,\n         };\n         if needs_lint {\n-            cx.span_lint(USED_UNDERSCORE_BINDING,\n-                         expr.span,\n-                         \"used binding which is prefixed with an underscore. A leading underscore signals that a \\\n-                          binding will not be used.\");\n+            span_lint(cx,\n+                      USED_UNDERSCORE_BINDING,\n+                      expr.span,\n+                      \"used binding which is prefixed with an underscore. A leading underscore signals that a \\\n+                       binding will not be used.\");\n         }\n     }\n }"}, {"sha": "23bd3d1103cef27bb60d9fc7a11c43dbff3ee1f6", "filename": "src/ranges.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e7158dc8f174126780ac6caa864bccede5dda262/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7158dc8f174126780ac6caa864bccede5dda262/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=e7158dc8f174126780ac6caa864bccede5dda262", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n-use utils::{is_integer_literal, match_type, snippet, unsugar_range, UnsugaredRange};\n+use utils::{is_integer_literal, match_type, snippet, span_lint, unsugar_range, UnsugaredRange};\n \n /// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never terminates.\n ///\n@@ -41,10 +41,11 @@ impl LateLintPass for StepByZero {\n             // Range with step_by(0).\n             if name.as_str() == \"step_by\" && args.len() == 2 && is_range(cx, &args[0]) &&\n                is_integer_literal(&args[1], 0) {\n-                cx.span_lint(RANGE_STEP_BY_ZERO,\n-                             expr.span,\n-                             \"Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` \\\n-                              instead\")\n+                span_lint(cx,\n+                          RANGE_STEP_BY_ZERO,\n+                          expr.span,\n+                          \"Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` \\\n+                           instead\");\n             } else if name.as_str() == \"zip\" && args.len() == 2 {\n                 let iter = &args[0].node;\n                 let zip_arg = &args[1];\n@@ -64,9 +65,11 @@ impl LateLintPass for StepByZero {\n                         let ExprPath(_, Path { segments: ref len_path, .. }) = len_args[0].node,\n                         iter_path == len_path\n                      ], {\n-                        cx.span_lint(RANGE_ZIP_WITH_LEN, expr.span,\n-                                     &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n-                                              snippet(cx, iter_args[0].span, \"_\")));\n+                        span_lint(cx,\n+                                  RANGE_ZIP_WITH_LEN,\n+                                  expr.span,\n+                                  &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n+                                           snippet(cx, iter_args[0].span, \"_\")));\n                     }\n                 }\n             }"}]}