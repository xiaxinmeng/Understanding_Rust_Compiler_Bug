{"sha": "25d68344932f740c4f4cbbb454ef65f9e33aca59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZDY4MzQ0OTMyZjc0MGM0ZjRjYmJiNDU0ZWY2NWY5ZTMzYWNhNTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-29T01:46:55Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-01T18:13:08Z"}, "message": "rustc_codegen_llvm: replace `fn noname()` with `const UNNAMED`.", "tree": {"sha": "e30dcd2af23ca2f9c888acf54ae522c3b3dec730", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e30dcd2af23ca2f9c888acf54ae522c3b3dec730"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25d68344932f740c4f4cbbb454ef65f9e33aca59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25d68344932f740c4f4cbbb454ef65f9e33aca59", "html_url": "https://github.com/rust-lang/rust/commit/25d68344932f740c4f4cbbb454ef65f9e33aca59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25d68344932f740c4f4cbbb454ef65f9e33aca59/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "268e64641fad89ef1911694f2f4a5e12ee72a37f", "url": "https://api.github.com/repos/rust-lang/rust/commits/268e64641fad89ef1911694f2f4a5e12ee72a37f", "html_url": "https://github.com/rust-lang/rust/commit/268e64641fad89ef1911694f2f4a5e12ee72a37f"}], "stats": {"total": 99, "additions": 52, "deletions": 47}, "files": [{"sha": "f37fd0cb833826d742eb6fe5844c4cacc01d0682", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/25d68344932f740c4f4cbbb454ef65f9e33aca59/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68344932f740c4f4cbbb454ef65f9e33aca59/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=25d68344932f740c4f4cbbb454ef65f9e33aca59", "patch": "@@ -20,6 +20,7 @@ use rustc_codegen_ssa::mir::operand::{OperandValue, OperandRef};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n+use std::ffi::CStr;\n use std::ops::{Deref, Range};\n use std::ptr;\n use std::iter::TrustedLen;\n@@ -39,12 +40,15 @@ impl Drop for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-// This is a really awful way to get a zero-length c-string, but better (and a\n-// lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n-fn noname() -> *const c_char {\n-    static CNULL: c_char = 0;\n-    &CNULL\n-}\n+// FIXME(eddyb) use a checked constructor when they become `const fn`.\n+const EMPTY_C_STR: &CStr = unsafe {\n+    CStr::from_bytes_with_nul_unchecked(b\"\\0\")\n+};\n+\n+/// Empty string, to be used where LLVM expects an instruction name, indicating\n+/// that the instruction is to be left unnamed (i.e. numbered, in textual IR).\n+// FIXME(eddyb) pass `&CStr` directly to FFI once it's a thin pointer.\n+const UNNAMED: *const c_char = EMPTY_C_STR.as_ptr();\n \n impl BackendTypes for Builder<'_, 'll, 'tcx> {\n     type Value = <CodegenCx<'ll, 'tcx> as BackendTypes>::Value;\n@@ -104,7 +108,7 @@ macro_rules! builder_methods_for_value_instructions {\n     ($($name:ident($($arg:ident),*) => $llvm_capi:ident),+ $(,)?) => {\n         $(fn $name(&mut self, $($arg: &'ll Value),*) -> &'ll Value {\n             unsafe {\n-                llvm::$llvm_capi(self.llbuilder, $($arg,)* noname())\n+                llvm::$llvm_capi(self.llbuilder, $($arg,)* UNNAMED)\n             }\n         })*\n     }\n@@ -227,7 +231,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                                       then,\n                                       catch,\n                                       bundle,\n-                                      noname())\n+                                      UNNAMED)\n         }\n     }\n \n@@ -265,39 +269,39 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn fadd_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname());\n+            let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, UNNAMED);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n \n     fn fsub_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname());\n+            let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, UNNAMED);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n \n     fn fmul_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname());\n+            let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, UNNAMED);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n \n     fn fdiv_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname());\n+            let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, UNNAMED);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n \n     fn frem_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname());\n+            let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, UNNAMED);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n@@ -388,7 +392,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n         unsafe {\n             let alloca = if name.is_empty() {\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty, noname())\n+                llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED)\n             } else {\n                 let name = SmallCStr::new(name);\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty,\n@@ -406,7 +410,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                         align: Align) -> &'ll Value {\n         unsafe {\n             let alloca = if name.is_empty() {\n-                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, noname())\n+                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED)\n             } else {\n                 let name = SmallCStr::new(name);\n                 llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len,\n@@ -419,15 +423,15 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn load(&mut self, ptr: &'ll Value, align: Align) -> &'ll Value {\n         unsafe {\n-            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n+            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, UNNAMED);\n             llvm::LLVMSetAlignment(load, align.bytes() as c_uint);\n             load\n         }\n     }\n \n     fn volatile_load(&mut self, ptr: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n+            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, UNNAMED);\n             llvm::LLVMSetVolatile(load, llvm::True);\n             load\n         }\n@@ -443,7 +447,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             let load = llvm::LLVMRustBuildAtomicLoad(\n                 self.llbuilder,\n                 ptr,\n-                noname(),\n+                UNNAMED,\n                 AtomicOrdering::from_generic(order),\n             );\n             // LLVM requires the alignment of atomic loads to be at least the size of the type.\n@@ -646,88 +650,88 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n-                               indices.len() as c_uint, noname())\n+                               indices.len() as c_uint, UNNAMED)\n         }\n     }\n \n     fn inbounds_gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n-                self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, noname())\n+                self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, UNNAMED)\n         }\n     }\n \n     fn struct_gep(&mut self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n-            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n+            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, UNNAMED)\n         }\n     }\n \n     /* Casts */\n     fn trunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn sext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n+            llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,UNNAMED)\n         }\n     }\n \n     fn uitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn sitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn fptrunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn fpext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn ptrtoint(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn inttoptr(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     fn bitcast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n@@ -740,21 +744,21 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn pointercast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n     /* Comparisons */\n     fn icmp(&mut self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         let op = llvm::IntPredicate::from_generic(op);\n         unsafe {\n-            llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n+            llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, UNNAMED)\n         }\n     }\n \n     fn fcmp(&mut self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n+            llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, UNNAMED)\n         }\n     }\n \n@@ -822,20 +826,20 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         else_val: &'ll Value,\n     ) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, noname())\n+            llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, UNNAMED)\n         }\n     }\n \n     #[allow(dead_code)]\n     fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n+            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, UNNAMED)\n         }\n     }\n \n     fn extract_element(&mut self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n+            llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, UNNAMED)\n         }\n     }\n \n@@ -852,7 +856,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn extract_value(&mut self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n-            llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n+            llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, UNNAMED)\n         }\n     }\n \n@@ -861,15 +865,15 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n-                                       noname())\n+                                       UNNAMED)\n         }\n     }\n \n     fn landing_pad(&mut self, ty: &'ll Type, pers_fn: &'ll Value,\n                        num_clauses: usize) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn,\n-                                      num_clauses as c_uint, noname())\n+                                      num_clauses as c_uint, UNNAMED)\n         }\n     }\n \n@@ -1039,14 +1043,14 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 llfn,\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n-                bundle, noname()\n+                bundle, UNNAMED\n             )\n         }\n     }\n \n     fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, UNNAMED)\n         }\n     }\n \n@@ -1128,7 +1132,7 @@ impl Builder<'a, 'll, 'tcx> {\n         idx: &'ll Value,\n     ) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n+            llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, UNNAMED)\n         }\n     }\n \n@@ -1139,7 +1143,7 @@ impl Builder<'a, 'll, 'tcx> {\n         mask: &'ll Value,\n     ) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n+            llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, UNNAMED)\n         }\n     }\n \n@@ -1281,7 +1285,7 @@ impl Builder<'a, 'll, 'tcx> {\n \n     pub fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         unsafe {\n-            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n+            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, UNNAMED)\n         }\n     }\n \n@@ -1304,7 +1308,7 @@ impl Builder<'a, 'll, 'tcx> {\n     fn phi(&mut self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n         assert_eq!(vals.len(), bbs.len());\n         let phi = unsafe {\n-            llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n+            llvm::LLVMBuildPhi(self.llbuilder, ty, UNNAMED)\n         };\n         unsafe {\n             llvm::LLVMAddIncoming(phi, vals.as_ptr(),"}, {"sha": "b13d8df5525e9f40dd115739c4f342924fb118b2", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25d68344932f740c4f4cbbb454ef65f9e33aca59/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68344932f740c4f4cbbb454ef65f9e33aca59/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=25d68344932f740c4f4cbbb454ef65f9e33aca59", "patch": "@@ -8,6 +8,7 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(const_cstr_unchecked)]\n #![feature(crate_visibility_modifier)]\n #![feature(custom_attribute)]\n #![feature(extern_types)]"}]}