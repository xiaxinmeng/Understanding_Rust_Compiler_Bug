{"sha": "d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "node_id": "C_kwDOAAsO6NoAKGQ0ZGUxZjIzMGNhMzBiN2NlMDhmYmY0NTNkYWViZjhiMmU3ZmZjYzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-25T00:46:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-25T00:46:04Z"}, "message": "Auto merge of #93368 - eddyb:diagbld-guarantee, r=estebank\n\nrustc_errors: let `DiagnosticBuilder::emit` return a \"guarantee of emission\".\n\nThat is, `DiagnosticBuilder` is now generic over the return type of `.emit()`, so we'll now have:\n* `DiagnosticBuilder<ErrorReported>` for error (incl. fatal/bug) diagnostics\n  * can only be created via a `const L: Level`-generic constructor, that limits allowed variants via a `where` clause, so not even `rustc_errors` can accidentally bypass this limitation\n  * asserts `diagnostic.is_error()` on emission, just in case the construction restriction was bypassed (e.g. by replacing the whole `Diagnostic` inside `DiagnosticBuilder`)\n  * `.emit()` returns `ErrorReported`, as a \"proof\" token that `.emit()` was called\n    (though note that this isn't a real guarantee until after completing the work on\n     #69426)\n* `DiagnosticBuilder<()>` for everything else (warnings, notes, etc.)\n  * can also be obtained from other `DiagnosticBuilder`s by calling `.forget_guarantee()`\n\nThis PR is a companion to other ongoing work, namely:\n* #69426\n  and it's ongoing implementation:\n  #93222\n  the API changes in this PR are needed to get statically-checked \"only errors produce `ErrorReported` from `.emit()`\", but doesn't itself provide any really strong guarantees without those other `ErrorReported` changes\n* #93244\n  would make the choices of API changes (esp. naming) in this PR fit better overall\n\nIn order to be able to let `.emit()` return anything trustable, several changes had to be made:\n* `Diagnostic`'s `level` field is now private to `rustc_errors`, to disallow arbitrary \"downgrade\"s from \"some kind of error\" to \"warning\" (or anything else that doesn't cause compilation to fail)\n  * it's still possible to replace the whole `Diagnostic` inside the `DiagnosticBuilder`, sadly, that's harder to fix, but it's unlikely enough that we can paper over it with asserts on `.emit()`\n* `.cancel()` now consumes `DiagnosticBuilder`, preventing `.emit()` calls on a cancelled diagnostic\n  * it's also now done internally, through `DiagnosticBuilder`-private state, instead of having a `Level::Cancelled` variant that can be read (or worse, written) by the user\n  * this removes a hazard of calling `.cancel()` on an error then continuing to attach details to it, and even expect to be able to `.emit()` it\n  * warnings were switched to *only* `can_emit_warnings` on emission (instead of pre-cancelling early)\n  * `struct_dummy` was removed (as it relied on a pre-`Cancelled` `Diagnostic`)\n* since `.emit()` doesn't consume the `DiagnosticBuilder` <sub>(I tried and gave up, it's much more work than this PR)</sub>,\n  we have to make `.emit()` idempotent wrt the guarantees it returns\n  * thankfully, `err.emit(); err.emit();` can return `ErrorReported` both times, as the second `.emit()` call has no side-effects *only* because the first one did do the appropriate emission\n* `&mut Diagnostic` is now used in a lot of function signatures, which used to take `&mut DiagnosticBuilder` (in the interest of not having to make those functions generic)\n  * the APIs were already mostly identical, allowing for low-effort porting to this new setup\n  * only some of the suggestion methods needed some rework, to have the extra `DiagnosticBuilder` functionality on the `Diagnostic` methods themselves (that change is also present in #93259)\n  * `.emit()`/`.cancel()` aren't available, but IMO calling them from an \"error decorator/annotator\" function isn't a good practice, and can lead to strange behavior (from the caller's perspective)\n  * `.downgrade_to_delayed_bug()` was added, letting you convert any `.is_error()` diagnostic into a `delay_span_bug` one (which works because in both cases the guarantees available are the same)\n\nThis PR should ideally be reviewed commit-by-commit, since there is a lot of fallout in each.\n\nr? `@estebank` cc `@Manishearth` `@nikomatsakis` `@mark-i-m`", "tree": {"sha": "922a1d8bf2850b2f35dda5bc6cc14e9194c375c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/922a1d8bf2850b2f35dda5bc6cc14e9194c375c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "html_url": "https://github.com/rust-lang/rust/commit/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e82f35492ea5c78e19609bf4468f0a686d9a756", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e82f35492ea5c78e19609bf4468f0a686d9a756", "html_url": "https://github.com/rust-lang/rust/commit/4e82f35492ea5c78e19609bf4468f0a686d9a756"}, {"sha": "b7e95dee65c35db8f8e07046d445b12d92cbae12", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7e95dee65c35db8f8e07046d445b12d92cbae12", "html_url": "https://github.com/rust-lang/rust/commit/b7e95dee65c35db8f8e07046d445b12d92cbae12"}], "stats": {"total": 2640, "additions": 1497, "deletions": 1143}, "files": [{"sha": "e2b6a48a9e867772ce0e9aad159d9a9f35a47fb4", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,9 +1,13 @@\n-use rustc_errors::{struct_span_err, DiagnosticBuilder, DiagnosticId};\n+use rustc_errors::{struct_span_err, DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::{MultiSpan, Span};\n \n impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n-    crate fn cannot_move_when_borrowed(&self, span: Span, desc: &str) -> DiagnosticBuilder<'cx> {\n+    crate fn cannot_move_when_borrowed(\n+        &self,\n+        span: Span,\n+        desc: &str,\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         struct_span_err!(self, span, E0505, \"cannot move out of {} because it is borrowed\", desc,)\n     }\n \n@@ -13,7 +17,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         desc: &str,\n         borrow_span: Span,\n         borrow_desc: &str,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n@@ -32,7 +36,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         span: Span,\n         verb: &str,\n         desc: &str,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         struct_span_err!(\n             self,\n             span,\n@@ -51,7 +55,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         old_loan_span: Span,\n         old_opt_via: &str,\n         old_load_end_span: Option<Span>,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let via =\n             |msg: &str| if msg.is_empty() { \"\".to_string() } else { format!(\" (via {})\", msg) };\n         let mut err = struct_span_err!(\n@@ -99,7 +103,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         desc: &str,\n         old_loan_span: Span,\n         old_load_end_span: Option<Span>,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n@@ -132,7 +136,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         noun_old: &str,\n         old_opt_via: &str,\n         previous_end_span: Option<Span>,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n@@ -164,7 +168,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         old_opt_via: &str,\n         previous_end_span: Option<Span>,\n         second_borrow_desc: &str,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n@@ -200,7 +204,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         kind_old: &str,\n         msg_old: &str,\n         old_load_end_span: Option<Span>,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let via =\n             |msg: &str| if msg.is_empty() { \"\".to_string() } else { format!(\" (via {})\", msg) };\n         let mut err = struct_span_err!(\n@@ -243,7 +247,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         span: Span,\n         borrow_span: Span,\n         desc: &str,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n@@ -262,20 +266,20 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         span: Span,\n         desc: &str,\n         is_arg: bool,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let msg = if is_arg { \"to immutable argument\" } else { \"twice to immutable variable\" };\n         struct_span_err!(self, span, E0384, \"cannot assign {} {}\", msg, desc)\n     }\n \n-    crate fn cannot_assign(&self, span: Span, desc: &str) -> DiagnosticBuilder<'cx> {\n+    crate fn cannot_assign(&self, span: Span, desc: &str) -> DiagnosticBuilder<'cx, ErrorReported> {\n         struct_span_err!(self, span, E0594, \"cannot assign to {}\", desc)\n     }\n \n     crate fn cannot_move_out_of(\n         &self,\n         move_from_span: Span,\n         move_from_desc: &str,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         struct_span_err!(self, move_from_span, E0507, \"cannot move out of {}\", move_from_desc,)\n     }\n \n@@ -287,7 +291,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         move_from_span: Span,\n         ty: Ty<'_>,\n         is_index: Option<bool>,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let type_name = match (&ty.kind(), is_index) {\n             (&ty::Array(_, _), Some(true)) | (&ty::Array(_, _), None) => \"array\",\n             (&ty::Slice(_), _) => \"slice\",\n@@ -309,7 +313,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         move_from_span: Span,\n         container_ty: Ty<'_>,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let mut err = struct_span_err!(\n             self,\n             move_from_span,\n@@ -327,7 +331,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         verb: &str,\n         optional_adverb_for_moved: &str,\n         moved_path: Option<String>,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let moved_path = moved_path.map(|mp| format!(\": `{}`\", mp)).unwrap_or_default();\n \n         struct_span_err!(\n@@ -346,7 +350,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         span: Span,\n         path: &str,\n         reason: &str,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{}\", path, reason,)\n     }\n \n@@ -357,7 +361,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         immutable_place: &str,\n         immutable_section: &str,\n         action: &str,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let mut err = struct_span_err!(\n             self,\n             mutate_span,\n@@ -376,7 +380,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         span: Span,\n         yield_span: Span,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n@@ -387,7 +391,10 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_borrow_across_destructor(&self, borrow_span: Span) -> DiagnosticBuilder<'cx> {\n+    crate fn cannot_borrow_across_destructor(\n+        &self,\n+        borrow_span: Span,\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         struct_span_err!(\n             self,\n             borrow_span,\n@@ -400,7 +407,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         span: Span,\n         path: &str,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         struct_span_err!(self, span, E0597, \"{} does not live long enough\", path,)\n     }\n \n@@ -410,7 +417,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         return_kind: &str,\n         reference_desc: &str,\n         path_desc: &str,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n@@ -435,7 +442,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         closure_kind: &str,\n         borrowed_path: &str,\n         capture_span: Span,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let mut err = struct_span_err!(\n             self,\n             closure_span,\n@@ -454,11 +461,14 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     crate fn thread_local_value_does_not_live_long_enough(\n         &self,\n         span: Span,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         struct_span_err!(self, span, E0712, \"thread-local variable borrowed past end of function\",)\n     }\n \n-    crate fn temporary_value_borrowed_for_too_long(&self, span: Span) -> DiagnosticBuilder<'cx> {\n+    crate fn temporary_value_borrowed_for_too_long(\n+        &self,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         struct_span_err!(self, span, E0716, \"temporary value dropped while borrowed\",)\n     }\n \n@@ -467,7 +477,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         sp: S,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         self.infcx.tcx.sess.struct_span_err_with_code(sp, msg, code)\n     }\n }\n@@ -476,7 +486,7 @@ crate fn borrowed_data_escapes_closure<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     escape_span: Span,\n     escapes_from: &str,\n-) -> DiagnosticBuilder<'tcx> {\n+) -> DiagnosticBuilder<'tcx, ErrorReported> {\n     struct_span_err!(\n         tcx.sess,\n         escape_span,"}, {"sha": "3ef002bf7402715fb24b5663b1d85a6f413b3615", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,4 +1,4 @@\n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::{DiagnosticBuilder, ErrorReported};\n use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_infer::infer::region_constraints::Constraint;\n@@ -120,7 +120,11 @@ impl<'tcx, F, G> ToUniverseInfo<'tcx> for Canonical<'tcx, type_op::custom::Custo\n trait TypeOpInfo<'tcx> {\n     /// Returns an error to be reported if rerunning the type op fails to\n     /// recover the error's cause.\n-    fn fallback_error(&self, tcx: TyCtxt<'tcx>, span: Span) -> DiagnosticBuilder<'tcx>;\n+    fn fallback_error(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported>;\n \n     fn base_universe(&self) -> ty::UniverseIndex;\n \n@@ -130,7 +134,7 @@ trait TypeOpInfo<'tcx> {\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n-    ) -> Option<DiagnosticBuilder<'tcx>>;\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>>;\n \n     fn report_error(\n         &self,\n@@ -188,7 +192,11 @@ struct PredicateQuery<'tcx> {\n }\n \n impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n-    fn fallback_error(&self, tcx: TyCtxt<'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn fallback_error(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let mut err = tcx.sess.struct_span_err(span, \"higher-ranked lifetime error\");\n         err.note(&format!(\"could not prove {}\", self.canonical_query.value.value.predicate));\n         err\n@@ -204,7 +212,7 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         tcx.infer_ctxt().enter_with_canonical(\n             cause.span,\n             &self.canonical_query,\n@@ -231,7 +239,11 @@ impl<'tcx, T> TypeOpInfo<'tcx> for NormalizeQuery<'tcx, T>\n where\n     T: Copy + fmt::Display + TypeFoldable<'tcx> + 'tcx,\n {\n-    fn fallback_error(&self, tcx: TyCtxt<'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn fallback_error(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let mut err = tcx.sess.struct_span_err(span, \"higher-ranked lifetime error\");\n         err.note(&format!(\"could not normalize `{}`\", self.canonical_query.value.value.value));\n         err\n@@ -247,7 +259,7 @@ where\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         tcx.infer_ctxt().enter_with_canonical(\n             cause.span,\n             &self.canonical_query,\n@@ -288,7 +300,11 @@ struct AscribeUserTypeQuery<'tcx> {\n }\n \n impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n-    fn fallback_error(&self, tcx: TyCtxt<'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn fallback_error(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         // FIXME: This error message isn't great, but it doesn't show up in the existing UI tests,\n         // and is only the fallback when the nice error fails. Consider improving this some more.\n         tcx.sess.struct_span_err(span, \"higher-ranked lifetime error\")\n@@ -304,7 +320,7 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         tcx.infer_ctxt().enter_with_canonical(\n             cause.span,\n             &self.canonical_query,\n@@ -329,7 +345,7 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     placeholder_region: ty::Region<'tcx>,\n     error_region: Option<ty::Region<'tcx>>,\n-) -> Option<DiagnosticBuilder<'tcx>> {\n+) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n     let tcx = infcx.tcx;\n \n     // We generally shouldn't have errors here because the query was"}, {"sha": "cd1f73d52981879fea12a24433044479f2e9d390", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,7 +1,7 @@\n use either::Either;\n use rustc_const_eval::util::{CallDesugaringKind, CallKind};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n@@ -507,7 +507,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         (place, _span): (Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.args_or_use();\n \n@@ -554,7 +554,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         (place, span): (Place<'tcx>, Span),\n         gen_borrow_kind: BorrowKind,\n         issued_borrow: &BorrowData<'tcx>,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let issued_spans = self.retrieve_borrow_spans(issued_borrow);\n         let issued_span = issued_spans.args_or_use();\n \n@@ -782,7 +782,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     #[instrument(level = \"debug\", skip(self, err))]\n     fn suggest_using_local_if_applicable(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         location: Location,\n         (place, span): (Place<'tcx>, Span),\n         gen_borrow_kind: BorrowKind,\n@@ -855,7 +855,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn suggest_split_at_mut_if_applicable(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         place: Place<'tcx>,\n         borrowed_place: Place<'tcx>,\n     ) {\n@@ -1120,7 +1120,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         drop_span: Span,\n         borrow_spans: UseSpans<'tcx>,\n         explanation: BorrowExplanation,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         debug!(\n             \"report_local_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}, {:?}\\\n@@ -1298,7 +1298,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         drop_span: Span,\n         borrow_span: Span,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         debug!(\n             \"report_thread_local_value_does_not_live_long_enough(\\\n              {:?}, {:?}\\\n@@ -1325,7 +1325,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow_spans: UseSpans<'tcx>,\n         proper_span: Span,\n         explanation: BorrowExplanation,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         debug!(\n             \"report_temporary_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}\\\n@@ -1384,7 +1384,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         return_span: Span,\n         category: ConstraintCategory,\n         opt_place_desc: Option<&String>,\n-    ) -> Option<DiagnosticBuilder<'cx>> {\n+    ) -> Option<DiagnosticBuilder<'cx, ErrorReported>> {\n         let return_kind = match category {\n             ConstraintCategory::Return(_) => \"return\",\n             ConstraintCategory::Yield => \"yield\",\n@@ -1483,7 +1483,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         category: ConstraintCategory,\n         constraint_span: Span,\n         captured_var: &str,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let tcx = self.infcx.tcx;\n         let args_span = use_span.args_or_use();\n \n@@ -1560,7 +1560,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         upvar_span: Span,\n         upvar_name: &str,\n         escape_span: Span,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'cx, ErrorReported> {\n         let tcx = self.infcx.tcx;\n \n         let (_, escapes_from) = tcx.article_and_description(self.mir_def_id().to_def_id());\n@@ -1835,7 +1835,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.buffer_error(err);\n     }\n \n-    fn explain_deref_coercion(&mut self, loan: &BorrowData<'tcx>, err: &mut DiagnosticBuilder<'_>) {\n+    fn explain_deref_coercion(&mut self, loan: &BorrowData<'tcx>, err: &mut Diagnostic) {\n         let tcx = self.infcx.tcx;\n         if let (\n             Some(Terminator { kind: TerminatorKind::Call { from_hir_call: false, .. }, .. }),\n@@ -2362,11 +2362,7 @@ enum AnnotatedBorrowFnSignature<'tcx> {\n impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     /// Annotate the provided diagnostic with information about borrow from the fn signature that\n     /// helps explain.\n-    pub(crate) fn emit(\n-        &self,\n-        cx: &mut MirBorrowckCtxt<'_, 'tcx>,\n-        diag: &mut DiagnosticBuilder<'_>,\n-    ) -> String {\n+    pub(crate) fn emit(&self, cx: &mut MirBorrowckCtxt<'_, 'tcx>, diag: &mut Diagnostic) -> String {\n         match self {\n             &AnnotatedBorrowFnSignature::Closure { argument_ty, argument_span } => {\n                 diag.span_label("}, {"sha": "da6610c002efc4312eaf4f15e9bbdd7e36cbdedc", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -3,7 +3,7 @@\n use std::collections::VecDeque;\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::{\n@@ -60,7 +60,7 @@ impl BorrowExplanation {\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         local_names: &IndexVec<Local, Option<Symbol>>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         borrow_desc: &str,\n         borrow_span: Option<Span>,\n         multiple_borrow_span: Option<(Span, Span)>,\n@@ -275,7 +275,7 @@ impl BorrowExplanation {\n     }\n     pub(crate) fn add_lifetime_bound_suggestion_to_diagnostic(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         category: &ConstraintCategory,\n         span: Span,\n         region_name: &RegionName,"}, {"sha": "754856043b3b52a2ead6b50751526dca021b464f", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,7 +1,7 @@\n //! Borrow checker diagnostics.\n \n use rustc_const_eval::util::call_kind;\n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n@@ -57,7 +57,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         location: Location,\n         place: PlaceRef<'tcx>,\n-        diag: &mut DiagnosticBuilder<'_>,\n+        diag: &mut Diagnostic,\n     ) {\n         debug!(\"add_moved_or_invoked_closure_note: location={:?} place={:?}\", location, place);\n         let mut target = place.local_or_deref_local();\n@@ -409,7 +409,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Add a note that a type does not implement `Copy`\n     pub(super) fn note_type_does_not_implement_copy(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         place_desc: &str,\n         ty: Ty<'tcx>,\n         span: Option<Span>,\n@@ -609,23 +609,15 @@ impl UseSpans<'_> {\n     }\n \n     // Add a span label to the arguments of the closure, if it exists.\n-    pub(super) fn args_span_label(\n-        self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        message: impl Into<String>,\n-    ) {\n+    pub(super) fn args_span_label(self, err: &mut Diagnostic, message: impl Into<String>) {\n         if let UseSpans::ClosureUse { args_span, .. } = self {\n             err.span_label(args_span, message);\n         }\n     }\n \n     // Add a span label to the use of the captured variable, if it exists.\n     // only adds label to the `path_span`\n-    pub(super) fn var_span_label_path_only(\n-        self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        message: impl Into<String>,\n-    ) {\n+    pub(super) fn var_span_label_path_only(self, err: &mut Diagnostic, message: impl Into<String>) {\n         if let UseSpans::ClosureUse { path_span, .. } = self {\n             err.span_label(path_span, message);\n         }\n@@ -634,7 +626,7 @@ impl UseSpans<'_> {\n     // Add a span label to the use of the captured variable, if it exists.\n     pub(super) fn var_span_label(\n         self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         message: impl Into<String>,\n         kind_desc: impl Into<String>,\n     ) {"}, {"sha": "66f4c28a36d6644ff0a175b966a37b91c08351e3", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,5 +1,5 @@\n use rustc_const_eval::util::CallDesugaringKind;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::*;\n use rustc_middle::ty;\n@@ -271,7 +271,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         &mut self,\n         place: Place<'tcx>,\n         span: Span,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'a, ErrorReported> {\n         let description = if place.projection.len() == 1 {\n             format!(\"static item {}\", self.describe_any_place(place.as_ref()))\n         } else {\n@@ -293,7 +293,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         deref_target_place: Place<'tcx>,\n         span: Span,\n         use_spans: Option<UseSpans<'tcx>>,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'a, ErrorReported> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n@@ -441,12 +441,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err\n     }\n \n-    fn add_move_hints(\n-        &self,\n-        error: GroupedMoveError<'tcx>,\n-        err: &mut DiagnosticBuilder<'a>,\n-        span: Span,\n-    ) {\n+    fn add_move_hints(&self, error: GroupedMoveError<'tcx>, err: &mut Diagnostic, span: Span) {\n         match error {\n             GroupedMoveError::MovesFromPlace { mut binds_to, move_from, .. } => {\n                 if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n@@ -505,7 +500,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn add_move_error_suggestions(&self, err: &mut DiagnosticBuilder<'a>, binds_to: &[Local]) {\n+    fn add_move_error_suggestions(&self, err: &mut Diagnostic, binds_to: &[Local]) {\n         let mut suggestions: Vec<(Span, &str, String)> = Vec::new();\n         for local in binds_to {\n             let bind_to = &self.body.local_decls[*local];\n@@ -541,7 +536,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn add_move_error_details(&self, err: &mut DiagnosticBuilder<'a>, binds_to: &[Local]) {\n+    fn add_move_error_details(&self, err: &mut Diagnostic, binds_to: &[Local]) {\n         for (j, local) in binds_to.iter().enumerate() {\n             let bind_to = &self.body.local_decls[*local];\n             let binding_span = bind_to.source_info.span;"}, {"sha": "2c9bd8ea96e9ade9896172aed3ee3d64824b858e", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -17,7 +17,7 @@ use rustc_span::{BytePos, Span};\n use crate::diagnostics::BorrowedContentSource;\n use crate::MirBorrowckCtxt;\n use rustc_const_eval::util::collect_writes::FindAssignments;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub(crate) enum AccessKind {\n@@ -689,7 +689,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         tcx: TyCtxt<'_>,\n         id: &hir::def_id::DefId,\n         the_place_err: PlaceRef<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n     ) {\n         let closure_local_def_id = id.expect_local();\n         let tables = tcx.typeck(closure_local_def_id);\n@@ -754,7 +754,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n     // Attempt to search similar mutable associated items for suggestion.\n     // In the future, attempt in all path but initially for RHS of for_loop\n-    fn suggest_similar_mut_method_for_for_loop(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest_similar_mut_method_for_for_loop(&self, err: &mut Diagnostic) {\n         use hir::{\n             BodyId, Expr,\n             ExprKind::{Block, Call, DropTemps, Match, MethodCall},\n@@ -843,7 +843,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     }\n \n     /// Targeted error when encountering an `FnMut` closure where an `Fn` closure was expected.\n-    fn expected_fn_found_fn_mut_call(&self, err: &mut DiagnosticBuilder<'_>, sp: Span, act: &str) {\n+    fn expected_fn_found_fn_mut_call(&self, err: &mut Diagnostic, sp: Span, act: &str) {\n         err.span_label(sp, format!(\"cannot {}\", act));\n \n         let hir = self.infcx.tcx.hir();"}, {"sha": "de50f907eff6f982b4d514d206afbd6dfd8bea0a", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -2,7 +2,7 @@\n //! outlives constraints.\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::Diagnostic;\n use rustc_middle::ty::RegionVid;\n use smallvec::SmallVec;\n use std::collections::BTreeMap;\n@@ -162,7 +162,7 @@ impl OutlivesSuggestionBuilder {\n         &mut self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n         errci: &ErrorConstraintInfo,\n-        diag: &mut DiagnosticBuilder<'_>,\n+        diag: &mut Diagnostic,\n     ) {\n         // Emit an intermediate note.\n         let fr_name = self.region_vid_to_name(mbcx, errci.fr);\n@@ -256,6 +256,6 @@ impl OutlivesSuggestionBuilder {\n         diag.sort_span = mir_span.shrink_to_hi();\n \n         // Buffer the diagnostic\n-        mbcx.buffer_error(diag);\n+        mbcx.buffer_non_error_diag(diag);\n     }\n }"}, {"sha": "64f05f6004f530760ff202c58af3f79c81b2ad95", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,6 +1,6 @@\n //! Error reporting machinery for lifetime errors.\n \n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_infer::infer::{\n     error_reporting::nice_region_error::NiceRegionError,\n     error_reporting::unexpected_hidden_region_diagnostic, NllRegionVariableOrigin,\n@@ -392,7 +392,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         &self,\n         errci: &ErrorConstraintInfo,\n         kind: ReturnConstraint,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n         let mut diag = self\n@@ -469,7 +469,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// LL |     ref_obj(x)\n     ///    |     ^^^^^^^^^^ `x` escapes the function body here\n     /// ```\n-    fn report_escaping_data_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n+    fn report_escaping_data_error(\n+        &self,\n+        errci: &ErrorConstraintInfo,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n         let fr_name_and_span = self.regioncx.get_var_name_and_span_for_region(\n@@ -570,7 +573,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ///    |     ^^^^^^^^^^^^^^ function was supposed to return data with lifetime `'a` but it\n     ///    |                    is returning data with lifetime `'b`\n     /// ```\n-    fn report_general_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n+    fn report_general_error(\n+        &self,\n+        errci: &ErrorConstraintInfo,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let ErrorConstraintInfo {\n             fr,\n             fr_is_local,\n@@ -632,7 +638,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn add_static_impl_trait_suggestion(\n         &self,\n-        diag: &mut DiagnosticBuilder<'tcx>,\n+        diag: &mut Diagnostic,\n         fr: RegionVid,\n         // We need to pass `fr_name` - computing it again will label it twice.\n         fr_name: RegionName,"}, {"sha": "c9395492c9e066d2711a14ca5e12c709df7d094a", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,7 +1,7 @@\n use std::fmt::{self, Display};\n use std::iter;\n \n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_middle::ty::print::RegionHighlightMode;\n@@ -98,7 +98,7 @@ impl RegionName {\n         }\n     }\n \n-    crate fn highlight_region_name(&self, diag: &mut DiagnosticBuilder<'_>) {\n+    crate fn highlight_region_name(&self, diag: &mut Diagnostic) {\n         match &self.source {\n             RegionNameSource::NamedFreeRegion(span)\n             | RegionNameSource::NamedEarlyBoundRegion(span) => {"}, {"sha": "590c5799ff6179d34b6889a7bc722b4103095223", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -379,7 +379,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // Convert any reservation warnings into lints.\n     let reservation_warnings = mem::take(&mut mbcx.reservation_warnings);\n     for (_, (place, span, location, bk, borrow)) in reservation_warnings {\n-        let mut initial_diag = mbcx.report_conflicting_borrow(location, (place, span), bk, &borrow);\n+        let initial_diag = mbcx.report_conflicting_borrow(location, (place, span), bk, &borrow);\n \n         let scope = mbcx.body.source_info(location).scope;\n         let lint_root = match &mbcx.body.source_scopes[scope].local_data {\n@@ -398,7 +398,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n                 diag.message = initial_diag.styled_message().clone();\n                 diag.span = initial_diag.span.clone();\n \n-                mbcx.buffer_error(diag);\n+                mbcx.buffer_non_error_diag(diag);\n             },\n         );\n         initial_diag.cancel();\n@@ -2293,8 +2293,8 @@ mod error {\n         /// when errors in the map are being re-added to the error buffer so that errors with the\n         /// same primary span come out in a consistent order.\n         buffered_move_errors:\n-            BTreeMap<Vec<MoveOutIndex>, (PlaceRef<'tcx>, DiagnosticBuilder<'tcx>)>,\n-        /// Errors to be reported buffer\n+            BTreeMap<Vec<MoveOutIndex>, (PlaceRef<'tcx>, DiagnosticBuilder<'tcx, ErrorReported>)>,\n+        /// Diagnostics to be reported buffer.\n         buffered: Vec<Diagnostic>,\n         /// Set to Some if we emit an error during borrowck\n         tainted_by_errors: Option<ErrorReported>,\n@@ -2309,27 +2309,37 @@ mod error {\n             }\n         }\n \n-        pub fn buffer_error(&mut self, t: DiagnosticBuilder<'_>) {\n+        // FIXME(eddyb) this is a suboptimal API because `tainted_by_errors` is\n+        // set before any emission actually happens (weakening the guarantee).\n+        pub fn buffer_error(&mut self, t: DiagnosticBuilder<'_, ErrorReported>) {\n             self.tainted_by_errors = Some(ErrorReported {});\n             t.buffer(&mut self.buffered);\n         }\n \n+        pub fn buffer_non_error_diag(&mut self, t: DiagnosticBuilder<'_, ()>) {\n+            t.buffer(&mut self.buffered);\n+        }\n+\n         pub fn set_tainted_by_errors(&mut self) {\n             self.tainted_by_errors = Some(ErrorReported {});\n         }\n     }\n \n     impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n-        pub fn buffer_error(&mut self, t: DiagnosticBuilder<'_>) {\n+        pub fn buffer_error(&mut self, t: DiagnosticBuilder<'_, ErrorReported>) {\n             self.errors.buffer_error(t);\n         }\n \n+        pub fn buffer_non_error_diag(&mut self, t: DiagnosticBuilder<'_, ()>) {\n+            self.errors.buffer_non_error_diag(t);\n+        }\n+\n         pub fn buffer_move_error(\n             &mut self,\n             move_out_indices: Vec<MoveOutIndex>,\n-            place_and_err: (PlaceRef<'tcx>, DiagnosticBuilder<'tcx>),\n+            place_and_err: (PlaceRef<'tcx>, DiagnosticBuilder<'tcx, ErrorReported>),\n         ) -> bool {\n-            if let Some((_, mut diag)) =\n+            if let Some((_, diag)) =\n                 self.errors.buffered_move_errors.insert(move_out_indices, place_and_err)\n             {\n                 // Cancel the old diagnostic so we don't ICE\n@@ -2365,7 +2375,7 @@ mod error {\n         pub fn has_move_error(\n             &self,\n             move_out_indices: &[MoveOutIndex],\n-        ) -> Option<&(PlaceRef<'tcx>, DiagnosticBuilder<'cx>)> {\n+        ) -> Option<&(PlaceRef<'tcx>, DiagnosticBuilder<'cx, ErrorReported>)> {\n             self.errors.buffered_move_errors.get(move_out_indices)\n         }\n     }"}, {"sha": "a2736fd1156646f02443be87f8e30fd4b1b0dbd9", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -417,7 +417,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n         err.note(&format!(\"Inferred opaque type values:\\n{:#?}\", opaque_type_values));\n     }\n \n-    errors.buffer_error(err);\n+    errors.buffer_non_error_diag(err);\n }\n \n fn for_each_region_constraint("}, {"sha": "3f0ce7dea00fb0a81f08da36caa217300e21771e", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -5,6 +5,7 @@ use rustc_data_structures::binary_search_util;\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n+use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::CRATE_HIR_ID;\n use rustc_index::vec::IndexVec;\n@@ -510,7 +511,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Adds annotations for `#[rustc_regions]`; see `UniversalRegions::annotate`.\n-    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n+    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n         self.universal_regions.annotate(tcx, err)\n     }\n "}, {"sha": "478dbe31fba7e41b619a002eee53ec0b6ed8fad5", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -14,7 +14,7 @@\n \n use either::Either;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n@@ -336,7 +336,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// that this region imposes on others. The methods in this file\n     /// handle the part about dumping the inference context internal\n     /// state.\n-    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut DiagnosticBuilder<'_>) {\n+    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n         match self.defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n                 err.note(&format!("}, {"sha": "57ef46475ddd860e3f4423bf37cba037b0f04596", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, PResult};\n use rustc_expand::base::{self, *};\n use rustc_parse::parser::Parser;\n use rustc_parse_format as parse;\n@@ -30,7 +30,7 @@ fn parse_args<'a>(\n     sp: Span,\n     tts: TokenStream,\n     is_global_asm: bool,\n-) -> Result<AsmArgs, DiagnosticBuilder<'a>> {\n+) -> PResult<'a, AsmArgs> {\n     let mut p = ecx.new_parser_from_tts(tts);\n     let sess = &ecx.sess.parse_sess;\n     parse_asm_args(&mut p, sess, sp, is_global_asm)\n@@ -43,7 +43,7 @@ pub fn parse_asm_args<'a>(\n     sess: &'a ParseSess,\n     sp: Span,\n     is_global_asm: bool,\n-) -> Result<AsmArgs, DiagnosticBuilder<'a>> {\n+) -> PResult<'a, AsmArgs> {\n     let diag = &sess.span_diagnostic;\n \n     if p.token == token::Eof {\n@@ -390,7 +390,7 @@ fn parse_options<'a>(\n     p: &mut Parser<'a>,\n     args: &mut AsmArgs,\n     is_global_asm: bool,\n-) -> Result<(), DiagnosticBuilder<'a>> {\n+) -> PResult<'a, ()> {\n     let span_start = p.prev_token.span;\n \n     p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n@@ -431,10 +431,7 @@ fn parse_options<'a>(\n     Ok(())\n }\n \n-fn parse_clobber_abi<'a>(\n-    p: &mut Parser<'a>,\n-    args: &mut AsmArgs,\n-) -> Result<(), DiagnosticBuilder<'a>> {\n+fn parse_clobber_abi<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> PResult<'a, ()> {\n     let span_start = p.prev_token.span;\n \n     p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n@@ -501,7 +498,7 @@ fn parse_clobber_abi<'a>(\n fn parse_reg<'a>(\n     p: &mut Parser<'a>,\n     explicit_reg: &mut bool,\n-) -> Result<ast::InlineAsmRegOrRegClass, DiagnosticBuilder<'a>> {\n+) -> PResult<'a, ast::InlineAsmRegOrRegClass> {\n     p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n     let result = match p.token.uninterpolate().kind {\n         token::Ident(name, false) => ast::InlineAsmRegOrRegClass::RegClass(name),"}, {"sha": "a984980dea9bf79fbb8f2bb91286d0fbf315aa03", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, PResult};\n use rustc_expand::base::*;\n use rustc_parse::parser::Parser;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -83,11 +83,7 @@ struct Assert {\n     custom_message: Option<TokenStream>,\n }\n \n-fn parse_assert<'a>(\n-    cx: &mut ExtCtxt<'a>,\n-    sp: Span,\n-    stream: TokenStream,\n-) -> Result<Assert, DiagnosticBuilder<'a>> {\n+fn parse_assert<'a>(cx: &mut ExtCtxt<'a>, sp: Span, stream: TokenStream) -> PResult<'a, Assert> {\n     let mut parser = cx.new_parser_from_tts(stream);\n \n     if parser.token == token::Eof {"}, {"sha": "1e1cf917c6093942c358e2711013113183b8b22a", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -6,7 +6,7 @@ use rustc_ast as ast;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_attr as attr;\n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::PResult;\n use rustc_expand::base::{self, *};\n use rustc_span::Span;\n \n@@ -29,11 +29,7 @@ pub fn expand_cfg(\n     }\n }\n \n-fn parse_cfg<'a>(\n-    cx: &mut ExtCtxt<'a>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Result<ast::MetaItem, DiagnosticBuilder<'a>> {\n+fn parse_cfg<'a>(cx: &mut ExtCtxt<'a>, sp: Span, tts: TokenStream) -> PResult<'a, ast::MetaItem> {\n     let mut p = cx.new_parser_from_tts(tts);\n \n     if p.token == token::Eof {"}, {"sha": "31213412d45f209e069d979dc8e6a8d839a8817d", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{token, BlockCheckMode, UnsafeSource};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, Applicability, DiagnosticBuilder};\n+use rustc_errors::{pluralize, Applicability, PResult};\n use rustc_expand::base::{self, *};\n use rustc_parse_format as parse;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -130,7 +130,7 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> Result<(P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, usize>), DiagnosticBuilder<'a>> {\n+) -> PResult<'a, (P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, usize>)> {\n     let mut args = Vec::<P<ast::Expr>>::new();\n     let mut names = FxHashMap::<Symbol, usize>::default();\n "}, {"sha": "7ee0fb9b817caab2fb49c397160484abc5248156", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -376,9 +376,13 @@ fn get_test_runner(\n     match &*meta_list {\n         [single] => match single.meta_item() {\n             Some(meta_item) if meta_item.is_word() => return Some(meta_item.path.clone()),\n-            _ => sd.struct_span_err(span, \"`test_runner` argument must be a path\").emit(),\n+            _ => {\n+                sd.struct_span_err(span, \"`test_runner` argument must be a path\").emit();\n+            }\n         },\n-        _ => sd.struct_span_err(span, \"`#![test_runner(..)]` accepts exactly 1 argument\").emit(),\n+        _ => {\n+            sd.struct_span_err(span, \"`#![test_runner(..)]` accepts exactly 1 argument\").emit();\n+        }\n     }\n     None\n }"}, {"sha": "55ea0c4d7270607a3272a945214b9655206404c8", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1709,7 +1709,7 @@ impl Emitter for SharedEmitter {\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n             msg: diag.message(),\n             code: diag.code.clone(),\n-            lvl: diag.level,\n+            lvl: diag.level(),\n         })));\n         for child in &diag.children {\n             drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n@@ -1753,7 +1753,7 @@ impl SharedEmitterMain {\n                     let msg = msg.strip_prefix(\"error: \").unwrap_or(&msg);\n \n                     let mut err = match level {\n-                        Level::Error { lint: false } => sess.struct_err(&msg),\n+                        Level::Error { lint: false } => sess.struct_err(&msg).forget_guarantee(),\n                         Level::Warning => sess.struct_warn(&msg),\n                         Level::Note => sess.struct_note_without_error(&msg),\n                         _ => bug!(\"Invalid inline asm diagnostic level\"),"}, {"sha": "3bd092263c13aec01f72892102c50e22b98d047d", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,7 +1,7 @@\n use std::error::Error;\n use std::fmt;\n \n-use rustc_errors::{DiagnosticBuilder, ErrorReported};\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::ty::{layout::LayoutError, query::TyCtxtAt, ConstInt};\n@@ -94,13 +94,13 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         &self,\n         tcx: TyCtxtAt<'tcx>,\n         message: &str,\n-        emit: impl FnOnce(DiagnosticBuilder<'_>),\n+        decorate: impl FnOnce(&mut Diagnostic),\n     ) -> ErrorHandled {\n-        self.struct_generic(tcx, message, emit, None)\n+        self.struct_generic(tcx, message, decorate, None)\n     }\n \n     pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n-        self.struct_error(tcx, message, |mut e| e.emit())\n+        self.struct_error(tcx, message, |_| {})\n     }\n \n     pub fn report_as_lint(\n@@ -113,7 +113,7 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         self.struct_generic(\n             tcx,\n             message,\n-            |mut lint: DiagnosticBuilder<'_>| {\n+            |lint: &mut Diagnostic| {\n                 // Apply the span.\n                 if let Some(span) = span {\n                     let primary_spans = lint.span.primary_spans().to_vec();\n@@ -127,7 +127,6 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                         }\n                     }\n                 }\n-                lint.emit();\n             },\n             Some(lint_root),\n         )\n@@ -136,20 +135,19 @@ impl<'tcx> ConstEvalErr<'tcx> {\n     /// Create a diagnostic for this const eval error.\n     ///\n     /// Sets the message passed in via `message` and adds span labels with detailed error\n-    /// information before handing control back to `emit` to do any final processing.\n-    /// It's the caller's responsibility to call emit(), stash(), etc. within the `emit`\n-    /// function to dispose of the diagnostic properly.\n+    /// information before handing control back to `decorate` to do any final annotations,\n+    /// after which the diagnostic is emitted.\n     ///\n     /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n     /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n     fn struct_generic(\n         &self,\n         tcx: TyCtxtAt<'tcx>,\n         message: &str,\n-        emit: impl FnOnce(DiagnosticBuilder<'_>),\n+        decorate: impl FnOnce(&mut Diagnostic),\n         lint_root: Option<hir::HirId>,\n     ) -> ErrorHandled {\n-        let finish = |mut err: DiagnosticBuilder<'_>, span_msg: Option<String>| {\n+        let finish = |err: &mut Diagnostic, span_msg: Option<String>| {\n             trace!(\"reporting const eval failure at {:?}\", self.span);\n             if let Some(span_msg) = span_msg {\n                 err.span_label(self.span, span_msg);\n@@ -188,8 +186,8 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                 }\n                 flush_last_line(last_frame, times);\n             }\n-            // Let the caller finish the job.\n-            emit(err)\n+            // Let the caller attach any additional information it wants.\n+            decorate(err);\n         };\n \n         // Special handling for certain errors\n@@ -206,8 +204,9 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                 // The `message` makes little sense here, this is a more serious error than the\n                 // caller thinks anyway.\n                 // See <https://github.com/rust-lang/rust/pull/63152>.\n-                finish(struct_error(tcx, &self.error.to_string()), None);\n-                return ErrorHandled::Reported(ErrorReported);\n+                let mut err = struct_error(tcx, &self.error.to_string());\n+                finish(&mut err, None);\n+                return ErrorHandled::Reported(err.emit());\n             }\n             _ => {}\n         };\n@@ -223,13 +222,18 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                 rustc_session::lint::builtin::CONST_ERR,\n                 hir_id,\n                 tcx.span,\n-                |lint| finish(lint.build(message), Some(err_msg)),\n+                |lint| {\n+                    let mut lint = lint.build(message);\n+                    finish(&mut lint, Some(err_msg));\n+                    lint.emit();\n+                },\n             );\n             ErrorHandled::Linted\n         } else {\n             // Report as hard error.\n-            finish(struct_error(tcx, message), Some(err_msg));\n-            ErrorHandled::Reported(ErrorReported)\n+            let mut err = struct_error(tcx, message);\n+            finish(&mut err, Some(err_msg));\n+            ErrorHandled::Reported(err.emit())\n         }\n     }\n }"}, {"sha": "dad572741049b1aac840648f1865fb5418a068ff", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -361,7 +361,7 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                 Err(err.struct_error(\n                     ecx.tcx,\n                     \"it is undefined behavior to use this value\",\n-                    |mut diag| {\n+                    |diag| {\n                         diag.note(note_on_undefined_behavior_error());\n                         diag.note(&format!(\n                             \"the raw bytes of the constant ({}\",\n@@ -370,7 +370,6 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                                 ecx.tcx.global_alloc(alloc_id).unwrap_memory()\n                             )\n                         ));\n-                        diag.emit();\n                     },\n                 ))\n             } else {"}, {"sha": "5738b38d443a0e31d15b2791cfab3e889f4f7c0d", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 147, "deletions": 37, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,6 +1,6 @@\n //! Concrete error types for all operations which may be invalid in a certain const context.\n \n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -47,7 +47,11 @@ pub trait NonConstOp<'tcx>: std::fmt::Debug {\n         DiagnosticImportance::Primary\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx>;\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported>;\n }\n \n #[derive(Debug)]\n@@ -61,7 +65,11 @@ impl<'tcx> NonConstOp<'tcx> for FloatingPointOp {\n         }\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_fn_floating_point_arithmetic,\n@@ -75,7 +83,11 @@ impl<'tcx> NonConstOp<'tcx> for FloatingPointOp {\n #[derive(Debug)]\n pub struct FnCallIndirect;\n impl<'tcx> NonConstOp<'tcx> for FnCallIndirect {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         ccx.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\")\n     }\n }\n@@ -91,11 +103,15 @@ pub struct FnCallNonConst<'tcx> {\n }\n \n impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, _: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        _: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let FnCallNonConst { caller, callee, substs, span, from_hir_call } = *self;\n         let ConstCx { tcx, param_env, .. } = *ccx;\n \n-        let diag_trait = |mut err, self_ty: Ty<'_>, trait_id| {\n+        let diag_trait = |err, self_ty: Ty<'_>, trait_id| {\n             let trait_ref = TraitRef::from_method(tcx, trait_id, substs);\n \n             match self_ty.kind() {\n@@ -115,7 +131,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                         suggest_constraining_type_param(\n                             tcx,\n                             generics,\n-                            &mut err,\n+                            err,\n                             &param_ty.name.as_str(),\n                             &constraint,\n                             None,\n@@ -146,8 +162,6 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                 }\n                 _ => {}\n             }\n-\n-            err\n         };\n \n         let call_kind = call_kind(tcx, ccx.param_env, callee, substs, span, from_hir_call, None);\n@@ -162,7 +176,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                     };\n                 }\n \n-                let err = match kind {\n+                let mut err = match kind {\n                     CallDesugaringKind::ForLoopIntoIter => {\n                         error!(\"cannot convert `{}` into an iterator in {}s\")\n                     }\n@@ -177,7 +191,8 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                     }\n                 };\n \n-                diag_trait(err, self_ty, kind.trait_def_id(tcx))\n+                diag_trait(&mut err, self_ty, kind.trait_def_id(tcx));\n+                err\n             }\n             CallKind::FnCall { fn_trait_id, self_ty } => {\n                 let mut err = struct_span_err!(\n@@ -212,7 +227,8 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                     _ => {}\n                 }\n \n-                diag_trait(err, self_ty, fn_trait_id)\n+                diag_trait(&mut err, self_ty, fn_trait_id);\n+                err\n             }\n             CallKind::Operator { trait_id, self_ty, .. } => {\n                 let mut err = struct_span_err!(\n@@ -262,7 +278,8 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                     }\n                 }\n \n-                diag_trait(err, self_ty, trait_id)\n+                diag_trait(&mut err, self_ty, trait_id);\n+                err\n             }\n             CallKind::DerefCoercion { deref_target, deref_target_ty, self_ty } => {\n                 let mut err = struct_span_err!(\n@@ -281,7 +298,8 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                     err.span_note(deref_target, \"deref defined here\");\n                 }\n \n-                diag_trait(err, self_ty, tcx.lang_items().deref_trait().unwrap())\n+                diag_trait(&mut err, self_ty, tcx.lang_items().deref_trait().unwrap());\n+                err\n             }\n             _ => struct_span_err!(\n                 ccx.tcx.sess,\n@@ -310,7 +328,11 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n pub struct FnCallUnstable(pub DefId, pub Option<Symbol>);\n \n impl<'tcx> NonConstOp<'tcx> for FnCallUnstable {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let FnCallUnstable(def_id, feature) = *self;\n \n         let mut err = ccx.tcx.sess.struct_span_err(\n@@ -344,7 +366,11 @@ impl<'tcx> NonConstOp<'tcx> for FnPtrCast {\n         }\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_fn_fn_ptr_basics,\n@@ -365,7 +391,11 @@ impl<'tcx> NonConstOp<'tcx> for Generator {\n         }\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let msg = format!(\"{}s are not allowed in {}s\", self.0, ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n             feature_err(&ccx.tcx.sess.parse_sess, sym::const_async_blocks, span, &msg)\n@@ -378,7 +408,11 @@ impl<'tcx> NonConstOp<'tcx> for Generator {\n #[derive(Debug)]\n pub struct HeapAllocation;\n impl<'tcx> NonConstOp<'tcx> for HeapAllocation {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -402,7 +436,11 @@ impl<'tcx> NonConstOp<'tcx> for HeapAllocation {\n #[derive(Debug)]\n pub struct InlineAsm;\n impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -418,7 +456,11 @@ pub struct LiveDrop {\n     pub dropped_at: Option<Span>,\n }\n impl<'tcx> NonConstOp<'tcx> for LiveDrop {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -446,7 +488,11 @@ impl<'tcx> NonConstOp<'tcx> for TransientCellBorrow {\n         // not additionally emit a feature gate error if activating the feature gate won't work.\n         DiagnosticImportance::Secondary\n     }\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_refs_to_cell,\n@@ -462,7 +508,11 @@ impl<'tcx> NonConstOp<'tcx> for TransientCellBorrow {\n /// it in the future for static items.\n pub struct CellBorrow;\n impl<'tcx> NonConstOp<'tcx> for CellBorrow {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -509,7 +559,11 @@ impl<'tcx> NonConstOp<'tcx> for MutBorrow {\n         DiagnosticImportance::Secondary\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let raw = match self.0 {\n             hir::BorrowKind::Raw => \"raw \",\n             hir::BorrowKind::Ref => \"\",\n@@ -548,7 +602,11 @@ impl<'tcx> NonConstOp<'tcx> for TransientMutBorrow {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let raw = match self.0 {\n             hir::BorrowKind::Raw => \"raw \",\n             hir::BorrowKind::Ref => \"\",\n@@ -575,7 +633,11 @@ impl<'tcx> NonConstOp<'tcx> for MutDeref {\n         DiagnosticImportance::Secondary\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n@@ -589,7 +651,11 @@ impl<'tcx> NonConstOp<'tcx> for MutDeref {\n #[derive(Debug)]\n pub struct PanicNonStr;\n impl<'tcx> NonConstOp<'tcx> for PanicNonStr {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         ccx.tcx.sess.struct_span_err(\n             span,\n             \"argument to `panic!()` in a const context must have type `&str`\",\n@@ -603,7 +669,11 @@ impl<'tcx> NonConstOp<'tcx> for PanicNonStr {\n #[derive(Debug)]\n pub struct RawPtrComparison;\n impl<'tcx> NonConstOp<'tcx> for RawPtrComparison {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let mut err = ccx\n             .tcx\n             .sess\n@@ -623,7 +693,11 @@ impl<'tcx> NonConstOp<'tcx> for RawMutPtrDeref {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n@@ -639,7 +713,11 @@ impl<'tcx> NonConstOp<'tcx> for RawMutPtrDeref {\n #[derive(Debug)]\n pub struct RawPtrToIntCast;\n impl<'tcx> NonConstOp<'tcx> for RawPtrToIntCast {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let mut err = ccx\n             .tcx\n             .sess\n@@ -664,7 +742,11 @@ impl<'tcx> NonConstOp<'tcx> for StaticAccess {\n         }\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -690,7 +772,11 @@ impl<'tcx> NonConstOp<'tcx> for StaticAccess {\n #[derive(Debug)]\n pub struct ThreadLocalAccess;\n impl<'tcx> NonConstOp<'tcx> for ThreadLocalAccess {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(\n+        &self,\n+        ccx: &ConstCx<'_, 'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -721,7 +807,11 @@ pub mod ty {\n             }\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_mut_refs,\n@@ -751,7 +841,11 @@ pub mod ty {\n             }\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_fn_ptr_basics,\n@@ -768,7 +862,11 @@ pub mod ty {\n             Status::Unstable(sym::const_impl_trait)\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_impl_trait,\n@@ -798,7 +896,11 @@ pub mod ty {\n             }\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n             let mut err = feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_trait_bound,\n@@ -837,7 +939,11 @@ pub mod ty {\n             }\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n             let mut err = feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_trait_bound,\n@@ -864,7 +970,11 @@ pub mod ty {\n             Status::Unstable(sym::const_trait_bound_opt_out)\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_trait_bound_opt_out,"}, {"sha": "7d7ab1ed4e5e6e26752ef3cb0f50abb10fd8b0e3", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -66,12 +66,14 @@ fn source_string(file: Lrc<SourceFile>, line: &Line) -> String {\n /// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n fn annotation_type_for_level(level: Level) -> AnnotationType {\n     match level {\n-        Level::Bug | Level::Fatal | Level::Error { .. } => AnnotationType::Error,\n+        Level::Bug | Level::DelayedBug | Level::Fatal | Level::Error { .. } => {\n+            AnnotationType::Error\n+        }\n         Level::Warning => AnnotationType::Warning,\n         Level::Note => AnnotationType::Note,\n         Level::Help => AnnotationType::Help,\n-        // FIXME(#59346): Not sure how to map these two levels\n-        Level::Cancelled | Level::FailureNote => AnnotationType::Error,\n+        // FIXME(#59346): Not sure how to map this level\n+        Level::FailureNote => AnnotationType::Error,\n         Level::Allow => panic!(\"Should not call with Allow\"),\n     }\n }"}, {"sha": "6d6ada86428db4fab448da52c7040f7e0483f6ae", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -19,7 +19,10 @@ pub struct SuggestionsDisabled;\n #[must_use]\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct Diagnostic {\n-    pub level: Level,\n+    // NOTE(eddyb) this is private to disallow arbitrary after-the-fact changes,\n+    // outside of what methods in this crate themselves allow.\n+    crate level: Level,\n+\n     pub message: Vec<(String, Style)>,\n     pub code: Option<DiagnosticId>,\n     pub span: MultiSpan,\n@@ -117,11 +120,20 @@ impl Diagnostic {\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn level(&self) -> Level {\n+        self.level\n+    }\n+\n     pub fn is_error(&self) -> bool {\n         match self.level {\n-            Level::Bug | Level::Fatal | Level::Error { .. } | Level::FailureNote => true,\n+            Level::Bug\n+            | Level::DelayedBug\n+            | Level::Fatal\n+            | Level::Error { .. }\n+            | Level::FailureNote => true,\n \n-            Level::Warning | Level::Note | Level::Help | Level::Cancelled | Level::Allow => false,\n+            Level::Warning | Level::Note | Level::Help | Level::Allow => false,\n         }\n     }\n \n@@ -139,15 +151,26 @@ impl Diagnostic {\n         }\n     }\n \n-    /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n-    /// canceled or it will panic when dropped).\n-    pub fn cancel(&mut self) {\n-        self.level = Level::Cancelled;\n-    }\n+    /// Delay emission of this diagnostic as a bug.\n+    ///\n+    /// This can be useful in contexts where an error indicates a bug but\n+    /// typically this only happens when other compilation errors have already\n+    /// happened. In those cases this can be used to defer emission of this\n+    /// diagnostic as a bug in the compiler only if no other errors have been\n+    /// emitted.\n+    ///\n+    /// In the meantime, though, callsites are required to deal with the \"bug\"\n+    /// locally in whichever way makes the most sense.\n+    #[track_caller]\n+    pub fn downgrade_to_delayed_bug(&mut self) -> &mut Self {\n+        assert!(\n+            self.is_error(),\n+            \"downgrade_to_delayed_bug: cannot downgrade {:?} to DelayedBug: not an error\",\n+            self.level\n+        );\n+        self.level = Level::DelayedBug;\n \n-    /// Check if this diagnostic [was cancelled][Self::cancel()].\n-    pub fn cancelled(&self) -> bool {\n-        self.level == Level::Cancelled\n+        self\n     }\n \n     /// Adds a span/label to be included in the resulting snippet.\n@@ -163,6 +186,20 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Labels all the given spans with the provided label.\n+    /// See [`Self::span_label()`] for more information.\n+    pub fn span_labels(\n+        &mut self,\n+        spans: impl IntoIterator<Item = Span>,\n+        label: impl AsRef<str>,\n+    ) -> &mut Self {\n+        let label = label.as_ref();\n+        for span in spans {\n+            self.span_label(span, label);\n+        }\n+        self\n+    }\n+\n     pub fn replace_span_with(&mut self, after: Span) -> &mut Self {\n         let before = self.span.clone();\n         self.set_span(after);\n@@ -174,7 +211,7 @@ impl Diagnostic {\n         self\n     }\n \n-    crate fn note_expected_found(\n+    pub fn note_expected_found(\n         &mut self,\n         expected_label: &dyn fmt::Display,\n         expected: DiagnosticStyledString,\n@@ -184,7 +221,7 @@ impl Diagnostic {\n         self.note_expected_found_extra(expected_label, expected, found_label, found, &\"\", &\"\")\n     }\n \n-    crate fn note_unsuccessful_coercion(\n+    pub fn note_unsuccessful_coercion(\n         &mut self,\n         expected: DiagnosticStyledString,\n         found: DiagnosticStyledString,\n@@ -274,33 +311,33 @@ impl Diagnostic {\n \n     /// Prints the span with a note above it.\n     /// This is like [`Diagnostic::note()`], but it gets its own span.\n-    crate fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    pub fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Note, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a warning attached to this diagnostic.\n-    crate fn warn(&mut self, msg: &str) -> &mut Self {\n+    pub fn warn(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with a warning above it.\n     /// This is like [`Diagnostic::warn()`], but it gets its own span.\n-    crate fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a help message attached to this diagnostic.\n-    crate fn help(&mut self, msg: &str) -> &mut Self {\n+    pub fn help(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with some help above it.\n     /// This is like [`Diagnostic::help()`], but it gets its own span.\n-    crate fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    pub fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, sp.into(), None);\n         self\n     }\n@@ -634,7 +671,7 @@ impl Diagnostic {\n         self.code.clone()\n     }\n \n-    crate fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self {\n+    pub fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self {\n         self.message[0] = (msg.into(), Style::NoStyle);\n         self\n     }"}, {"sha": "49305d22684176e93da3578977b957c2de43dcc7", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 253, "deletions": 101, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,9 +1,10 @@\n-use crate::{Diagnostic, DiagnosticId, DiagnosticStyledString};\n+use crate::{Diagnostic, DiagnosticId, DiagnosticStyledString, ErrorReported};\n use crate::{Handler, Level, StashKey};\n use rustc_lint_defs::Applicability;\n \n use rustc_span::{MultiSpan, Span};\n use std::fmt::{self, Debug};\n+use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n use std::thread::panicking;\n use tracing::debug;\n@@ -15,8 +16,25 @@ use tracing::debug;\n /// extending `HandlerFlags`, accessed via `self.handler.flags`.\n #[must_use]\n #[derive(Clone)]\n-pub struct DiagnosticBuilder<'a> {\n-    handler: &'a Handler,\n+pub struct DiagnosticBuilder<'a, G: EmissionGuarantee> {\n+    inner: DiagnosticBuilderInner<'a>,\n+    _marker: PhantomData<G>,\n+}\n+\n+/// This type exists only for `DiagnosticBuilder::forget_guarantee`, because it:\n+/// 1. lacks the `G` parameter and therefore `DiagnosticBuilder<G1>` can be\n+///    converted into `DiagnosticBuilder<G2>` while reusing the `inner` field\n+/// 2. can implement the `Drop` \"bomb\" instead of `DiagnosticBuilder`, as it\n+///    contains all of the data (`state` + `diagnostic`) of `DiagnosticBuilder`\n+///\n+/// The `diagnostic` field is not `Copy` and can't be moved out of whichever\n+/// type implements the `Drop` \"bomb\", but because of the above two facts, that\n+/// never needs to happen - instead, the whole `inner: DiagnosticBuilderInner`\n+/// can be moved out of a `DiagnosticBuilder` and into another.\n+#[must_use]\n+#[derive(Clone)]\n+struct DiagnosticBuilderInner<'a> {\n+    state: DiagnosticBuilderState<'a>,\n \n     /// `Diagnostic` is a large type, and `DiagnosticBuilder` is often used as a\n     /// return value, especially within the frequently-used `PResult` type.\n@@ -25,6 +43,161 @@ pub struct DiagnosticBuilder<'a> {\n     diagnostic: Box<Diagnostic>,\n }\n \n+#[derive(Clone)]\n+enum DiagnosticBuilderState<'a> {\n+    /// Initial state of a `DiagnosticBuilder`, before `.emit()` or `.cancel()`.\n+    ///\n+    /// The `Diagnostic` will be emitted through this `Handler`.\n+    Emittable(&'a Handler),\n+\n+    /// State of a `DiagnosticBuilder`, after `.emit()` or *during* `.cancel()`.\n+    ///\n+    /// The `Diagnostic` will be ignored when calling `.emit()`, and it can be\n+    /// assumed that `.emit()` was previously called, to end up in this state.\n+    ///\n+    /// While this is also used by `.cancel()`, this state is only observed by\n+    /// the `Drop` `impl` of `DiagnosticBuilderInner`, as `.cancel()` takes\n+    /// `self` by-value specifically to prevent any attempts to `.emit()`.\n+    ///\n+    // FIXME(eddyb) currently this doesn't prevent extending the `Diagnostic`,\n+    // despite that being potentially lossy, if important information is added\n+    // *after* the original `.emit()` call.\n+    AlreadyEmittedOrDuringCancellation,\n+}\n+\n+// `DiagnosticBuilderState` should be pointer-sized.\n+rustc_data_structures::static_assert_size!(\n+    DiagnosticBuilderState<'_>,\n+    std::mem::size_of::<&Handler>()\n+);\n+\n+/// Trait for types that `DiagnosticBuilder::emit` can return as a \"guarantee\"\n+/// (or \"proof\") token that the emission happened.\n+pub trait EmissionGuarantee: Sized {\n+    /// Implementation of `DiagnosticBuilder::emit`, fully controlled by each\n+    /// `impl` of `EmissionGuarantee`, to make it impossible to create a value\n+    /// of `Self` without actually performing the emission.\n+    #[track_caller]\n+    fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self;\n+}\n+\n+/// Private module for sealing the `IsError` helper trait.\n+mod sealed_level_is_error {\n+    use crate::Level;\n+\n+    /// Sealed helper trait for statically checking that a `Level` is an error.\n+    crate trait IsError<const L: Level> {}\n+\n+    impl IsError<{ Level::Bug }> for () {}\n+    impl IsError<{ Level::DelayedBug }> for () {}\n+    impl IsError<{ Level::Fatal }> for () {}\n+    // NOTE(eddyb) `Level::Error { lint: true }` is also an error, but lints\n+    // don't need error guarantees, as their levels are always dynamic.\n+    impl IsError<{ Level::Error { lint: false } }> for () {}\n+}\n+\n+impl<'a> DiagnosticBuilder<'a, ErrorReported> {\n+    /// Convenience function for internal use, clients should use one of the\n+    /// `struct_*` methods on [`Handler`].\n+    crate fn new_guaranteeing_error<const L: Level>(handler: &'a Handler, message: &str) -> Self\n+    where\n+        (): sealed_level_is_error::IsError<L>,\n+    {\n+        Self {\n+            inner: DiagnosticBuilderInner {\n+                state: DiagnosticBuilderState::Emittable(handler),\n+                diagnostic: Box::new(Diagnostic::new_with_code(L, None, message)),\n+            },\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    /// Discard the guarantee `.emit()` would return, in favor of having the\n+    /// type `DiagnosticBuilder<'a, ()>`. This may be necessary whenever there\n+    /// is a common codepath handling both errors and warnings.\n+    pub fn forget_guarantee(self) -> DiagnosticBuilder<'a, ()> {\n+        DiagnosticBuilder { inner: self.inner, _marker: PhantomData }\n+    }\n+}\n+\n+// FIXME(eddyb) make `ErrorReported` impossible to create outside `.emit()`.\n+impl EmissionGuarantee for ErrorReported {\n+    fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self {\n+        match db.inner.state {\n+            // First `.emit()` call, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                db.inner.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+\n+                handler.emit_diagnostic(&db.inner.diagnostic);\n+\n+                // Only allow a guarantee if the `level` wasn't switched to a\n+                // non-error - the field isn't `pub`, but the whole `Diagnostic`\n+                // can be overwritten with a new one, thanks to `DerefMut`.\n+                assert!(\n+                    db.inner.diagnostic.is_error(),\n+                    \"emitted non-error ({:?}) diagnostic \\\n+                     from `DiagnosticBuilder<ErrorReported>`\",\n+                    db.inner.diagnostic.level,\n+                );\n+                ErrorReported\n+            }\n+            // `.emit()` was previously called, disallowed from repeating it,\n+            // but can take advantage of the previous `.emit()`'s guarantee\n+            // still being applicable (i.e. as a form of idempotency).\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {\n+                // Only allow a guarantee if the `level` wasn't switched to a\n+                // non-error - the field isn't `pub`, but the whole `Diagnostic`\n+                // can be overwritten with a new one, thanks to `DerefMut`.\n+                assert!(\n+                    db.inner.diagnostic.is_error(),\n+                    \"`DiagnosticBuilder<ErrorReported>`'s diagnostic \\\n+                     became non-error ({:?}), after original `.emit()`\",\n+                    db.inner.diagnostic.level,\n+                );\n+                ErrorReported\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> DiagnosticBuilder<'a, ()> {\n+    /// Convenience function for internal use, clients should use one of the\n+    /// `struct_*` methods on [`Handler`].\n+    crate fn new(handler: &'a Handler, level: Level, message: &str) -> Self {\n+        let diagnostic = Diagnostic::new_with_code(level, None, message);\n+        Self::new_diagnostic(handler, diagnostic)\n+    }\n+\n+    /// Creates a new `DiagnosticBuilder` with an already constructed\n+    /// diagnostic.\n+    crate fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n+        debug!(\"Created new diagnostic\");\n+        Self {\n+            inner: DiagnosticBuilderInner {\n+                state: DiagnosticBuilderState::Emittable(handler),\n+                diagnostic: Box::new(diagnostic),\n+            },\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+// FIXME(eddyb) should there be a `Option<ErrorReported>` impl as well?\n+impl EmissionGuarantee for () {\n+    fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self {\n+        match db.inner.state {\n+            // First `.emit()` call, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                db.inner.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+\n+                handler.emit_diagnostic(&db.inner.diagnostic);\n+            }\n+            // `.emit()` was previously called, disallowed from repeating it.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n+        }\n+    }\n+}\n+\n /// In general, the `DiagnosticBuilder` uses deref to allow access to\n /// the fields and methods of the embedded `diagnostic` in a\n /// transparent way. *However,* many of the methods are intended to\n@@ -55,60 +228,54 @@ macro_rules! forward {\n         $(#[$attrs])*\n         #[doc = concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\")]\n         pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n-            self.diagnostic.$n($($name),*);\n-            self\n-        }\n-    };\n-\n-    // Forward pattern for &mut self -> &mut Self, with generic parameters.\n-    (\n-        $(#[$attrs:meta])*\n-        pub fn $n:ident<$($generic:ident: $bound:path),*>(\n-            &mut self,\n-            $($name:ident: $ty:ty),*\n-            $(,)?\n-        ) -> &mut Self\n-    ) => {\n-        $(#[$attrs])*\n-        #[doc = concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\")]\n-        pub fn $n<$($generic: $bound),*>(&mut self, $($name: $ty),*) -> &mut Self {\n-            self.diagnostic.$n($($name),*);\n+            self.inner.diagnostic.$n($($name),*);\n             self\n         }\n     };\n }\n \n-impl<'a> Deref for DiagnosticBuilder<'a> {\n+impl<G: EmissionGuarantee> Deref for DiagnosticBuilder<'_, G> {\n     type Target = Diagnostic;\n \n     fn deref(&self) -> &Diagnostic {\n-        &self.diagnostic\n+        &self.inner.diagnostic\n     }\n }\n \n-impl<'a> DerefMut for DiagnosticBuilder<'a> {\n+impl<G: EmissionGuarantee> DerefMut for DiagnosticBuilder<'_, G> {\n     fn deref_mut(&mut self) -> &mut Diagnostic {\n-        &mut self.diagnostic\n+        &mut self.inner.diagnostic\n     }\n }\n \n-impl<'a> DiagnosticBuilder<'a> {\n+impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n     /// Emit the diagnostic.\n-    pub fn emit(&mut self) {\n-        self.handler.emit_diagnostic(&self);\n-        self.cancel();\n+    #[track_caller]\n+    pub fn emit(&mut self) -> G {\n+        G::diagnostic_builder_emit_producing_guarantee(self)\n     }\n \n     /// Emit the diagnostic unless `delay` is true,\n     /// in which case the emission will be delayed as a bug.\n     ///\n     /// See `emit` and `delay_as_bug` for details.\n-    pub fn emit_unless(&mut self, delay: bool) {\n+    #[track_caller]\n+    pub fn emit_unless(&mut self, delay: bool) -> G {\n         if delay {\n-            self.delay_as_bug();\n-        } else {\n-            self.emit();\n+            self.downgrade_to_delayed_bug();\n         }\n+        self.emit()\n+    }\n+\n+    /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n+    /// cancelled or it will panic when dropped).\n+    ///\n+    /// This method takes `self` by-value to disallow calling `.emit()` on it,\n+    /// which may be expected to *guarantee* the emission of an error, either\n+    /// at the time of the call, or through a prior `.emit()` call.\n+    pub fn cancel(mut self) {\n+        self.inner.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+        drop(self);\n     }\n \n     /// Stashes diagnostic for possible later improvement in a different,\n@@ -123,21 +290,28 @@ impl<'a> DiagnosticBuilder<'a> {\n     }\n \n     /// Converts the builder to a `Diagnostic` for later emission,\n-    /// unless handler has disabled such buffering.\n+    /// unless handler has disabled such buffering, or `.emit()` was called.\n     pub fn into_diagnostic(mut self) -> Option<(Diagnostic, &'a Handler)> {\n-        if self.handler.flags.dont_buffer_diagnostics\n-            || self.handler.flags.treat_err_as_bug.is_some()\n-        {\n+        let handler = match self.inner.state {\n+            // No `.emit()` calls, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => handler,\n+            // `.emit()` was previously called, nothing we can do.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {\n+                return None;\n+            }\n+        };\n+\n+        if handler.flags.dont_buffer_diagnostics || handler.flags.treat_err_as_bug.is_some() {\n             self.emit();\n             return None;\n         }\n \n-        let handler = self.handler;\n+        // Take the `Diagnostic` by replacing it with a dummy.\n+        let dummy = Diagnostic::new(Level::Allow, \"\");\n+        let diagnostic = std::mem::replace(&mut *self.inner.diagnostic, dummy);\n \n-        // We must use `Level::Cancelled` for `dummy` to avoid an ICE about an\n-        // unused diagnostic.\n-        let dummy = Diagnostic::new(Level::Cancelled, \"\");\n-        let diagnostic = std::mem::replace(&mut *self.diagnostic, dummy);\n+        // Disable the ICE on `Drop`.\n+        self.cancel();\n \n         // Logging here is useful to help track down where in logs an error was\n         // actually emitted.\n@@ -162,12 +336,18 @@ impl<'a> DiagnosticBuilder<'a> {\n     ///\n     /// In the meantime, though, callsites are required to deal with the \"bug\"\n     /// locally in whichever way makes the most sense.\n+    #[track_caller]\n     pub fn delay_as_bug(&mut self) {\n-        self.level = Level::Bug;\n-        self.handler.delay_as_bug((*self.diagnostic).clone());\n-        self.cancel();\n+        self.downgrade_to_delayed_bug();\n+        self.emit();\n     }\n \n+    forward!(\n+        #[track_caller]\n+        pub fn downgrade_to_delayed_bug(&mut self,) -> &mut Self\n+    );\n+\n+    forward!(\n     /// Appends a labeled span to the diagnostic.\n     ///\n     /// Labels are used to convey additional context for the diagnostic's primary span. They will\n@@ -180,24 +360,16 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// the diagnostic was constructed. However, the label span is *not* considered a\n     /// [\"primary span\"][`MultiSpan`]; only the `Span` supplied when creating the diagnostic is\n     /// primary.\n-    pub fn span_label(&mut self, span: Span, label: impl Into<String>) -> &mut Self {\n-        self.diagnostic.span_label(span, label);\n-        self\n-    }\n+    pub fn span_label(&mut self, span: Span, label: impl Into<String>) -> &mut Self);\n \n+    forward!(\n     /// Labels all the given spans with the provided label.\n     /// See [`Diagnostic::span_label()`] for more information.\n     pub fn span_labels(\n         &mut self,\n         spans: impl IntoIterator<Item = Span>,\n         label: impl AsRef<str>,\n-    ) -> &mut Self {\n-        let label = label.as_ref();\n-        for span in spans {\n-            self.diagnostic.span_label(span, label);\n-        }\n-        self\n-    }\n+    ) -> &mut Self);\n \n     forward!(pub fn note_expected_found(\n         &mut self,\n@@ -224,17 +396,17 @@ impl<'a> DiagnosticBuilder<'a> {\n     ) -> &mut Self);\n \n     forward!(pub fn note(&mut self, msg: &str) -> &mut Self);\n-    forward!(pub fn span_note<S: Into<MultiSpan>>(\n+    forward!(pub fn span_note(\n         &mut self,\n-        sp: S,\n+        sp: impl Into<MultiSpan>,\n         msg: &str,\n     ) -> &mut Self);\n     forward!(pub fn warn(&mut self, msg: &str) -> &mut Self);\n-    forward!(pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self);\n+    forward!(pub fn span_warn(&mut self, sp: impl Into<MultiSpan>, msg: &str) -> &mut Self);\n     forward!(pub fn help(&mut self, msg: &str) -> &mut Self);\n-    forward!(pub fn span_help<S: Into<MultiSpan>>(\n+    forward!(pub fn span_help(\n         &mut self,\n-        sp: S,\n+        sp: impl Into<MultiSpan>,\n         msg: &str,\n     ) -> &mut Self);\n     forward!(pub fn set_is_lint(&mut self,) -> &mut Self);\n@@ -308,55 +480,35 @@ impl<'a> DiagnosticBuilder<'a> {\n         applicability: Applicability,\n     ) -> &mut Self);\n \n-    forward!(pub fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self);\n-    forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n+    forward!(pub fn set_primary_message(&mut self, msg: impl Into<String>) -> &mut Self);\n+    forward!(pub fn set_span(&mut self, sp: impl Into<MultiSpan>) -> &mut Self);\n     forward!(pub fn code(&mut self, s: DiagnosticId) -> &mut Self);\n-\n-    /// Convenience function for internal use, clients should use one of the\n-    /// `struct_*` methods on [`Handler`].\n-    crate fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder::new_with_code(handler, level, None, message)\n-    }\n-\n-    /// Convenience function for internal use, clients should use one of the\n-    /// `struct_*` methods on [`Handler`].\n-    crate fn new_with_code(\n-        handler: &'a Handler,\n-        level: Level,\n-        code: Option<DiagnosticId>,\n-        message: &str,\n-    ) -> DiagnosticBuilder<'a> {\n-        let diagnostic = Diagnostic::new_with_code(level, code, message);\n-        DiagnosticBuilder::new_diagnostic(handler, diagnostic)\n-    }\n-\n-    /// Creates a new `DiagnosticBuilder` with an already constructed\n-    /// diagnostic.\n-    crate fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> DiagnosticBuilder<'a> {\n-        debug!(\"Created new diagnostic\");\n-        DiagnosticBuilder { handler, diagnostic: Box::new(diagnostic) }\n-    }\n }\n \n-impl<'a> Debug for DiagnosticBuilder<'a> {\n+impl<G: EmissionGuarantee> Debug for DiagnosticBuilder<'_, G> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.diagnostic.fmt(f)\n+        self.inner.diagnostic.fmt(f)\n     }\n }\n \n-/// Destructor bomb - a `DiagnosticBuilder` must be either emitted or canceled\n+/// Destructor bomb - a `DiagnosticBuilder` must be either emitted or cancelled\n /// or we emit a bug.\n-impl<'a> Drop for DiagnosticBuilder<'a> {\n+impl Drop for DiagnosticBuilderInner<'_> {\n     fn drop(&mut self) {\n-        if !panicking() && !self.cancelled() {\n-            let mut db = DiagnosticBuilder::new(\n-                self.handler,\n-                Level::Bug,\n-                \"the following error was constructed but not emitted\",\n-            );\n-            db.emit();\n-            self.emit();\n-            panic!();\n+        match self.state {\n+            // No `.emit()` or `.cancel()` calls.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                if !panicking() {\n+                    handler.emit_diagnostic(&Diagnostic::new(\n+                        Level::Bug,\n+                        \"the following error was constructed but not emitted\",\n+                    ));\n+                    handler.emit_diagnostic(&self.diagnostic);\n+                    panic!();\n+                }\n+            }\n+            // `.emit()` was previously called, or maybe we're during `.cancel()`.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n         }\n     }\n }"}, {"sha": "463308c27b25a92e62d9fbe3b951fab1970f41e6", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 95, "deletions": 83, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -9,6 +9,8 @@\n #![feature(let_else)]\n #![feature(nll)]\n #![cfg_attr(not(bootstrap), allow(rustc::potential_query_instability))]\n+#![feature(adt_const_params)]\n+#![allow(incomplete_features)]\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -52,7 +54,7 @@ mod snippet;\n mod styled_buffer;\n pub use snippet::Style;\n \n-pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n+pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a, ErrorReported>>;\n \n // `PResult` is used a lot. Make sure it doesn't unintentionally get bigger.\n // (See also the comment on `DiagnosticBuilder`'s `diagnostic` field.)\n@@ -491,10 +493,15 @@ impl Drop for HandlerInner {\n             self.flush_delayed(bugs, \"no errors encountered even though `delay_span_bug` issued\");\n         }\n \n+        // FIXME(eddyb) this explains what `delayed_good_path_bugs` are!\n+        // They're `delayed_span_bugs` but for \"require some diagnostic happened\"\n+        // instead of \"require some error happened\". Sadly that isn't ideal, as\n+        // lints can be `#[allow]`'d, potentially leading to this triggering.\n+        // Also, \"good path\" should be replaced with a better naming.\n         if !self.has_any_message() {\n             let bugs = std::mem::replace(&mut self.delayed_good_path_bugs, Vec::new());\n             self.flush_delayed(\n-                bugs.into_iter().map(DelayedDiagnostic::decorate).collect(),\n+                bugs.into_iter().map(DelayedDiagnostic::decorate),\n                 \"no warnings or errors encountered even though `delayed_good_path_bugs` issued\",\n             );\n         }\n@@ -604,7 +611,7 @@ impl Handler {\n     }\n \n     /// Steal a previously stashed diagnostic with the given `Span` and `StashKey` as the key.\n-    pub fn steal_diagnostic(&self, span: Span, key: StashKey) -> Option<DiagnosticBuilder<'_>> {\n+    pub fn steal_diagnostic(&self, span: Span, key: StashKey) -> Option<DiagnosticBuilder<'_, ()>> {\n         self.inner\n             .borrow_mut()\n             .stashed_diagnostics\n@@ -617,33 +624,17 @@ impl Handler {\n         self.inner.borrow_mut().emit_stashed_diagnostics();\n     }\n \n-    /// Construct a dummy builder with `Level::Cancelled`.\n-    ///\n-    /// Using this will neither report anything to the user (e.g. a warning),\n-    /// nor will compilation cancel as a result.\n-    pub fn struct_dummy(&self) -> DiagnosticBuilder<'_> {\n-        DiagnosticBuilder::new(self, Level::Cancelled, \"\")\n-    }\n-\n-    /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n-    ///\n-    /// The builder will be canceled if warnings cannot be emitted.\n-    pub fn struct_span_warn(&self, span: impl Into<MultiSpan>, msg: &str) -> DiagnosticBuilder<'_> {\n-        let mut result = self.struct_warn(msg);\n-        result.set_span(span);\n-        result\n-    }\n-\n     /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n     ///\n-    /// This will \"force\" the warning meaning it will not be canceled even\n-    /// if warnings cannot be emitted.\n-    pub fn struct_span_force_warn(\n+    /// Attempting to `.emit()` the builder will only emit if either:\n+    /// * `can_emit_warnings` is `true`\n+    /// * `is_force_warn` was set in `DiagnosticId::Lint`\n+    pub fn struct_span_warn(\n         &self,\n         span: impl Into<MultiSpan>,\n         msg: &str,\n-    ) -> DiagnosticBuilder<'_> {\n-        let mut result = self.struct_force_warn(msg);\n+    ) -> DiagnosticBuilder<'_, ()> {\n+        let mut result = self.struct_warn(msg);\n         result.set_span(span);\n         result\n     }\n@@ -653,7 +644,7 @@ impl Handler {\n         &self,\n         span: impl Into<MultiSpan>,\n         msg: &str,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'_, ()> {\n         let mut result = self.struct_allow(msg);\n         result.set_span(span);\n         result\n@@ -666,38 +657,32 @@ impl Handler {\n         span: impl Into<MultiSpan>,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'_, ()> {\n         let mut result = self.struct_span_warn(span, msg);\n         result.code(code);\n         result\n     }\n \n     /// Construct a builder at the `Warning` level with the `msg`.\n     ///\n-    /// The builder will be canceled if warnings cannot be emitted.\n-    pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n-        if !self.flags.can_emit_warnings {\n-            result.cancel();\n-        }\n-        result\n-    }\n-\n-    /// Construct a builder at the `Warning` level with the `msg`.\n-    ///\n-    /// This will \"force\" a warning meaning it will not be canceled even\n-    /// if warnings cannot be emitted.\n-    pub fn struct_force_warn(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+    /// Attempting to `.emit()` the builder will only emit if either:\n+    /// * `can_emit_warnings` is `true`\n+    /// * `is_force_warn` was set in `DiagnosticId::Lint`\n+    pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Warning, msg)\n     }\n \n     /// Construct a builder at the `Allow` level with the `msg`.\n-    pub fn struct_allow(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_allow(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Allow, msg)\n     }\n \n     /// Construct a builder at the `Error` level at the given `span` and with the `msg`.\n-    pub fn struct_span_err(&self, span: impl Into<MultiSpan>, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_span_err(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         let mut result = self.struct_err(msg);\n         result.set_span(span);\n         result\n@@ -709,26 +694,30 @@ impl Handler {\n         span: impl Into<MultiSpan>,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         let mut result = self.struct_span_err(span, msg);\n         result.code(code);\n         result\n     }\n \n     /// Construct a builder at the `Error` level with the `msg`.\n     // FIXME: This method should be removed (every error should have an associated error code).\n-    pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_> {\n-        DiagnosticBuilder::new(self, Level::Error { lint: false }, msg)\n+    pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_, ErrorReported> {\n+        DiagnosticBuilder::new_guaranteeing_error::<{ Level::Error { lint: false } }>(self, msg)\n     }\n \n     /// This should only be used by `rustc_middle::lint::struct_lint_level`. Do not use it for hard errors.\n     #[doc(hidden)]\n-    pub fn struct_err_lint(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_err_lint(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Error { lint: true }, msg)\n     }\n \n     /// Construct a builder at the `Error` level with the `msg` and the `code`.\n-    pub fn struct_err_with_code(&self, msg: &str, code: DiagnosticId) -> DiagnosticBuilder<'_> {\n+    pub fn struct_err_with_code(\n+        &self,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         let mut result = self.struct_err(msg);\n         result.code(code);\n         result\n@@ -739,7 +728,7 @@ impl Handler {\n         &self,\n         span: impl Into<MultiSpan>,\n         msg: &str,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         let mut result = self.struct_fatal(msg);\n         result.set_span(span);\n         result\n@@ -751,24 +740,24 @@ impl Handler {\n         span: impl Into<MultiSpan>,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         let mut result = self.struct_span_fatal(span, msg);\n         result.code(code);\n         result\n     }\n \n     /// Construct a builder at the `Error` level with the `msg`.\n-    pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_> {\n-        DiagnosticBuilder::new(self, Level::Fatal, msg)\n+    pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_, ErrorReported> {\n+        DiagnosticBuilder::new_guaranteeing_error::<{ Level::Fatal }>(self, msg)\n     }\n \n     /// Construct a builder at the `Help` level with the `msg`.\n-    pub fn struct_help(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_help(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Help, msg)\n     }\n \n     /// Construct a builder at the `Note` level with the `msg`.\n-    pub fn struct_note_without_error(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_note_without_error(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Note, msg)\n     }\n \n@@ -815,6 +804,8 @@ impl Handler {\n         self.inner.borrow_mut().delay_span_bug(span, msg)\n     }\n \n+    // FIXME(eddyb) note the comment inside `impl Drop for HandlerInner`, that's\n+    // where the explanation of what \"good path\" is (also, it should be renamed).\n     pub fn delay_good_path_bug(&self, msg: &str) {\n         self.inner.borrow_mut().delay_good_path_bug(msg)\n     }\n@@ -827,7 +818,7 @@ impl Handler {\n         self.emit_diag_at_span(Diagnostic::new(Note, msg), span);\n     }\n \n-    pub fn span_note_diag(&self, span: Span, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn span_note_diag(&self, span: Span, msg: &str) -> DiagnosticBuilder<'_, ()> {\n         let mut db = DiagnosticBuilder::new(self, Note, msg);\n         db.set_span(span);\n         db\n@@ -915,10 +906,6 @@ impl Handler {\n     pub fn emit_unused_externs(&self, lint_level: &str, unused_externs: &[&str]) {\n         self.inner.borrow_mut().emit_unused_externs(lint_level, unused_externs)\n     }\n-\n-    pub fn delay_as_bug(&self, diagnostic: Diagnostic) {\n-        self.inner.borrow_mut().delay_as_bug(diagnostic)\n-    }\n }\n \n impl HandlerInner {\n@@ -936,9 +923,18 @@ impl HandlerInner {\n         diags.iter().for_each(|diag| self.emit_diagnostic(diag));\n     }\n \n+    // FIXME(eddyb) this should ideally take `diagnostic` by value.\n     fn emit_diagnostic(&mut self, diagnostic: &Diagnostic) {\n-        if diagnostic.cancelled() {\n-            return;\n+        if diagnostic.level == Level::DelayedBug {\n+            // FIXME(eddyb) this should check for `has_errors` and stop pushing\n+            // once *any* errors were emitted (and truncate `delayed_span_bugs`\n+            // when an error is first emitted, also), but maybe there's a case\n+            // in which that's not sound? otherwise this is really inefficient.\n+            self.delayed_span_bugs.push(diagnostic.clone());\n+\n+            if !self.flags.report_delayed_bugs {\n+                return;\n+            }\n         }\n \n         if diagnostic.has_future_breakage() {\n@@ -1119,14 +1115,16 @@ impl HandlerInner {\n             // FIXME: don't abort here if report_delayed_bugs is off\n             self.span_bug(sp, msg);\n         }\n-        let mut diagnostic = Diagnostic::new(Level::Bug, msg);\n+        let mut diagnostic = Diagnostic::new(Level::DelayedBug, msg);\n         diagnostic.set_span(sp.into());\n         diagnostic.note(&format!(\"delayed at {}\", std::panic::Location::caller()));\n-        self.delay_as_bug(diagnostic)\n+        self.emit_diagnostic(&diagnostic)\n     }\n \n+    // FIXME(eddyb) note the comment inside `impl Drop for HandlerInner`, that's\n+    // where the explanation of what \"good path\" is (also, it should be renamed).\n     fn delay_good_path_bug(&mut self, msg: &str) {\n-        let diagnostic = Diagnostic::new(Level::Bug, msg);\n+        let diagnostic = Diagnostic::new(Level::DelayedBug, msg);\n         if self.flags.report_delayed_bugs {\n             self.emit_diagnostic(&diagnostic);\n         }\n@@ -1160,20 +1158,34 @@ impl HandlerInner {\n         panic::panic_any(ExplicitBug);\n     }\n \n-    fn delay_as_bug(&mut self, diagnostic: Diagnostic) {\n-        if self.flags.report_delayed_bugs {\n-            self.emit_diagnostic(&diagnostic);\n-        }\n-        self.delayed_span_bugs.push(diagnostic);\n-    }\n+    fn flush_delayed(&mut self, bugs: impl IntoIterator<Item = Diagnostic>, explanation: &str) {\n+        let mut no_bugs = true;\n+        for mut bug in bugs {\n+            if no_bugs {\n+                // Put the overall explanation before the `DelayedBug`s, to\n+                // frame them better (e.g. separate warnings from them).\n+                self.emit_diagnostic(&Diagnostic::new(Bug, explanation));\n+                no_bugs = false;\n+            }\n+\n+            // \"Undelay\" the `DelayedBug`s (into plain `Bug`s).\n+            if bug.level != Level::DelayedBug {\n+                // NOTE(eddyb) not panicking here because we're already producing\n+                // an ICE, and the more information the merrier.\n+                bug.note(&format!(\n+                    \"`flushed_delayed` got diagnostic with level {:?}, \\\n+                     instead of the expected `DelayedBug`\",\n+                    bug.level,\n+                ));\n+            }\n+            bug.level = Level::Bug;\n \n-    fn flush_delayed(&mut self, bugs: Vec<Diagnostic>, explanation: &str) {\n-        let has_bugs = !bugs.is_empty();\n-        for bug in bugs {\n             self.emit_diagnostic(&bug);\n         }\n-        if has_bugs {\n-            panic!(\"{}\", explanation);\n+\n+        // Panic with `ExplicitBug` to avoid \"unexpected panic\" messages.\n+        if !no_bugs {\n+            panic::panic_any(ExplicitBug);\n         }\n     }\n \n@@ -1224,9 +1236,10 @@ impl DelayedDiagnostic {\n     }\n }\n \n-#[derive(Copy, PartialEq, Clone, Hash, Debug, Encodable, Decodable)]\n+#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug, Encodable, Decodable)]\n pub enum Level {\n     Bug,\n+    DelayedBug,\n     Fatal,\n     Error {\n         /// If this error comes from a lint, don't abort compilation even when abort_if_errors() is called.\n@@ -1235,7 +1248,6 @@ pub enum Level {\n     Warning,\n     Note,\n     Help,\n-    Cancelled,\n     FailureNote,\n     Allow,\n }\n@@ -1250,7 +1262,7 @@ impl Level {\n     fn color(self) -> ColorSpec {\n         let mut spec = ColorSpec::new();\n         match self {\n-            Bug | Fatal | Error { .. } => {\n+            Bug | DelayedBug | Fatal | Error { .. } => {\n                 spec.set_fg(Some(Color::Red)).set_intense(true);\n             }\n             Warning => {\n@@ -1263,20 +1275,19 @@ impl Level {\n                 spec.set_fg(Some(Color::Cyan)).set_intense(true);\n             }\n             FailureNote => {}\n-            Allow | Cancelled => unreachable!(),\n+            Allow => unreachable!(),\n         }\n         spec\n     }\n \n     pub fn to_str(self) -> &'static str {\n         match self {\n-            Bug => \"error: internal compiler error\",\n+            Bug | DelayedBug => \"error: internal compiler error\",\n             Fatal | Error { .. } => \"error\",\n             Warning => \"warning\",\n             Note => \"note\",\n             Help => \"help\",\n             FailureNote => \"failure-note\",\n-            Cancelled => panic!(\"Shouldn't call on cancelled error\"),\n             Allow => panic!(\"Shouldn't call on allowed error\"),\n         }\n     }\n@@ -1286,9 +1297,10 @@ impl Level {\n     }\n }\n \n+// FIXME(eddyb) this doesn't belong here AFAICT, should be moved to callsite.\n pub fn add_elided_lifetime_in_path_suggestion(\n     source_map: &SourceMap,\n-    db: &mut DiagnosticBuilder<'_>,\n+    diag: &mut Diagnostic,\n     n: usize,\n     path_span: Span,\n     incl_angl_brckt: bool,\n@@ -1320,7 +1332,7 @@ pub fn add_elided_lifetime_in_path_suggestion(\n             (insertion_span, anon_lts)\n         }\n     };\n-    db.span_suggestion(\n+    diag.span_suggestion(\n         replace_span,\n         &format!(\"indicate the anonymous lifetime{}\", pluralize!(n)),\n         suggestion,"}, {"sha": "4e951ad9d4b6d062df5d58f86ec28c7bdee516e2", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -10,7 +10,7 @@ use rustc_ast::{self as ast, AstLike, Attribute, Item, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, Stability};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n-use rustc_errors::{Applicability, DiagnosticBuilder, ErrorReported};\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorReported, PResult};\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::BuiltinLintDiagnostics;\n use rustc_parse::{self, nt_to_tokenstream, parser, MACRO_ARGUMENTS};\n@@ -1072,7 +1072,11 @@ impl<'a> ExtCtxt<'a> {\n         self.current_expansion.id.expansion_cause()\n     }\n \n-    pub fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'a, ErrorReported> {\n         self.sess.parse_sess.span_diagnostic.struct_span_err(sp, msg)\n     }\n \n@@ -1130,11 +1134,7 @@ impl<'a> ExtCtxt<'a> {\n     /// This unifies the logic used for resolving `include_X!`.\n     ///\n     /// FIXME: move this to `rustc_builtin_macros` and make it private.\n-    pub fn resolve_path(\n-        &self,\n-        path: impl Into<PathBuf>,\n-        span: Span,\n-    ) -> Result<PathBuf, DiagnosticBuilder<'a>> {\n+    pub fn resolve_path(&self, path: impl Into<PathBuf>, span: Span) -> PResult<'a, PathBuf> {\n         let path = path.into();\n \n         // Relative paths are resolved relative to the file in which they are found\n@@ -1174,7 +1174,7 @@ pub fn expr_to_spanned_string<'a>(\n     cx: &'a mut ExtCtxt<'_>,\n     expr: P<ast::Expr>,\n     err_msg: &str,\n-) -> Result<(Symbol, ast::StrStyle, Span), Option<(DiagnosticBuilder<'a>, bool)>> {\n+) -> Result<(Symbol, ast::StrStyle, Span), Option<(DiagnosticBuilder<'a, ErrorReported>, bool)>> {\n     // Perform eager expansion on the expression.\n     // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`.\n     let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();\n@@ -1233,7 +1233,9 @@ pub fn check_zero_tts(cx: &ExtCtxt<'_>, sp: Span, tts: TokenStream, name: &str)\n pub fn parse_expr(p: &mut parser::Parser<'_>) -> Option<P<ast::Expr>> {\n     match p.parse_expr() {\n         Ok(e) => return Some(e),\n-        Err(mut err) => err.emit(),\n+        Err(mut err) => {\n+            err.emit();\n+        }\n     }\n     while p.token != token::Eof {\n         p.bump();"}, {"sha": "4af7d2b7ec6fd1905faeba009795b4ebc0d759e2", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -16,7 +16,7 @@ use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder};\n use rustc_feature::Features;\n use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n@@ -49,11 +49,7 @@ crate struct ParserAnyMacro<'a> {\n     is_local: bool,\n }\n \n-crate fn annotate_err_with_kind(\n-    err: &mut DiagnosticBuilder<'_>,\n-    kind: AstFragmentKind,\n-    span: Span,\n-) {\n+crate fn annotate_err_with_kind(err: &mut Diagnostic, kind: AstFragmentKind, span: Span) {\n     match kind {\n         AstFragmentKind::Ty => {\n             err.span_label(span, \"this macro call doesn't expand to a type\");\n@@ -66,7 +62,7 @@ crate fn annotate_err_with_kind(\n }\n \n fn emit_frag_parse_err(\n-    mut e: DiagnosticBuilder<'_>,\n+    mut e: DiagnosticBuilder<'_, rustc_errors::ErrorReported>,\n     parser: &Parser<'_>,\n     orig_parser: &mut Parser<'_>,\n     site_span: Span,\n@@ -99,7 +95,7 @@ fn emit_frag_parse_err(\n     match kind {\n         // Try a statement if an expression is wanted but failed and suggest adding `;` to call.\n         AstFragmentKind::Expr => match parse_ast_fragment(orig_parser, AstFragmentKind::Stmts) {\n-            Err(mut err) => err.cancel(),\n+            Err(err) => err.cancel(),\n             Ok(_) => {\n                 e.note(\n                     \"the macro call doesn't expand to an expression, but it can expand to a statement\","}, {"sha": "1ce3766579bd9f1e4990a9f804bc8ac6c7eb6250", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,7 +1,7 @@\n use crate::base::ModuleData;\n use rustc_ast::ptr::P;\n use rustc_ast::{token, Attribute, Inline, Item};\n-use rustc_errors::{struct_span_err, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorReported};\n use rustc_parse::new_parser_from_file;\n use rustc_parse::validate_attr;\n use rustc_session::parse::ParseSess;\n@@ -39,7 +39,7 @@ pub enum ModError<'a> {\n     ModInBlock(Option<Ident>),\n     FileNotFound(Ident, PathBuf, PathBuf),\n     MultipleCandidates(Ident, PathBuf, PathBuf),\n-    ParserError(DiagnosticBuilder<'a>),\n+    ParserError(DiagnosticBuilder<'a, ErrorReported>),\n }\n \n crate fn parse_external_mod(\n@@ -242,7 +242,7 @@ pub fn default_submod_path<'a>(\n }\n \n impl ModError<'_> {\n-    fn report(self, sess: &Session, span: Span) {\n+    fn report(self, sess: &Session, span: Span) -> ErrorReported {\n         let diag = &sess.parse_sess.span_diagnostic;\n         match self {\n             ModError::CircularInclusion(file_paths) => {"}, {"sha": "869cada400f0fe8069b8cfffb034c3e4c104c266", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -446,7 +446,9 @@ impl server::TokenStream for Rustc<'_, '_> {\n             }\n             expr\n         };\n-        let expr = expr.map_err(|mut err| err.emit())?;\n+        let expr = expr.map_err(|mut err| {\n+            err.emit();\n+        })?;\n \n         // Perform eager expansion on the expression.\n         let expr = self"}, {"sha": "317481a037de6d5ceecdf1b358f0fae5daeb61f8", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -58,7 +58,7 @@ use crate::traits::{\n };\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, struct_span_err};\n+use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorReported};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -85,7 +85,7 @@ pub mod nice_region_error;\n \n pub(super) fn note_and_explain_region<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     prefix: &str,\n     region: ty::Region<'tcx>,\n     suffix: &str,\n@@ -118,7 +118,7 @@ pub(super) fn note_and_explain_region<'tcx>(\n \n fn explain_free_region<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     prefix: &str,\n     region: ty::Region<'tcx>,\n     suffix: &str,\n@@ -194,7 +194,7 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n }\n \n fn emit_msg_span(\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     prefix: &str,\n     description: String,\n     span: Option<Span>,\n@@ -210,7 +210,7 @@ fn emit_msg_span(\n }\n \n fn label_msg_span(\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     prefix: &str,\n     description: String,\n     span: Option<Span>,\n@@ -230,7 +230,7 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     span: Span,\n     hidden_ty: Ty<'tcx>,\n     hidden_region: ty::Region<'tcx>,\n-) -> DiagnosticBuilder<'tcx> {\n+) -> DiagnosticBuilder<'tcx, ErrorReported> {\n     let mut err = struct_span_err!(\n         tcx.sess,\n         span,\n@@ -471,11 +471,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Adds a note if the types come from similarly named crates\n-    fn check_and_note_conflicting_crates(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        terr: &TypeError<'tcx>,\n-    ) {\n+    fn check_and_note_conflicting_crates(&self, err: &mut Diagnostic, terr: &TypeError<'tcx>) {\n         use hir::def_id::CrateNum;\n         use rustc_hir::definitions::DisambiguatedDefPathData;\n         use ty::print::Printer;\n@@ -557,7 +553,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let report_path_match = |err: &mut DiagnosticBuilder<'_>, did1: DefId, did2: DefId| {\n+        let report_path_match = |err: &mut Diagnostic, did1: DefId, did2: DefId| {\n             // Only external crates, if either is from a local\n             // module we could have false positives\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n@@ -598,7 +594,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     fn note_error_origin(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         cause: &ObligationCause<'tcx>,\n         exp_found: Option<ty::error::ExpectedFound<Ty<'tcx>>>,\n         terr: &TypeError<'tcx>,\n@@ -792,7 +788,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     fn suggest_boxing_for_return_impl_trait(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         return_sp: Span,\n         arm_spans: impl Iterator<Item = Span>,\n     ) {\n@@ -1436,7 +1432,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// E0271, like `src/test/ui/issues/issue-39970.stderr`.\n     pub fn note_type_err(\n         &self,\n-        diag: &mut DiagnosticBuilder<'tcx>,\n+        diag: &mut Diagnostic,\n         cause: &ObligationCause<'tcx>,\n         secondary_span: Option<(Span, String)>,\n         mut values: Option<ValuePairs<'tcx>>,\n@@ -1483,14 +1479,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 types_visitor\n             }\n \n-            fn report(&self, err: &mut DiagnosticBuilder<'_>) {\n+            fn report(&self, err: &mut Diagnostic) {\n                 self.add_labels_for_types(err, \"expected\", &self.expected);\n                 self.add_labels_for_types(err, \"found\", &self.found);\n             }\n \n             fn add_labels_for_types(\n                 &self,\n-                err: &mut DiagnosticBuilder<'_>,\n+                err: &mut Diagnostic,\n                 target: &str,\n                 types: &FxHashMap<TyCategory, FxHashSet<Span>>,\n             ) {\n@@ -1601,7 +1597,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     Some((expected, found)) => Some((expected, found)),\n                     None => {\n                         // Derived error. Cancel the emitter.\n-                        diag.cancel();\n+                        // NOTE(eddyb) this was `.cancel()`, but `diag`\n+                        // is borrowed, so we can't fully defuse it.\n+                        diag.downgrade_to_delayed_bug();\n                         return;\n                     }\n                 };\n@@ -1817,7 +1815,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         cause: &ObligationCause<'tcx>,\n         exp_span: Span,\n         exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut DiagnosticBuilder<'tcx>,\n+        diag: &mut Diagnostic,\n     ) {\n         debug!(\n             \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n@@ -1905,7 +1903,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         cause: &ObligationCause<'tcx>,\n         exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut DiagnosticBuilder<'tcx>,\n+        diag: &mut Diagnostic,\n     ) {\n         debug!(\n             \"suggest_accessing_field_where_appropriate(cause={:?}, exp_found={:?})\",\n@@ -1954,7 +1952,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut DiagnosticBuilder<'tcx>,\n+        diag: &mut Diagnostic,\n     ) {\n         if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n             (exp_found.expected.kind(), exp_found.found.kind())\n@@ -2015,7 +2013,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         trace: TypeTrace<'tcx>,\n         terr: &TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         use crate::traits::ObligationCauseCode::MatchExpressionArm;\n \n         debug!(\"report_and_explain_type_error(trace={:?}, terr={:?})\", trace, terr);\n@@ -2107,7 +2105,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     fn emit_tuple_wrap_err(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         span: Span,\n         found: Ty<'tcx>,\n         expected_fields: &List<Ty<'tcx>>,\n@@ -2223,7 +2221,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'a, ErrorReported> {\n         let hir = self.tcx.hir();\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n@@ -2339,7 +2337,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         fn binding_suggestion<'tcx, S: fmt::Display>(\n-            err: &mut DiagnosticBuilder<'tcx>,\n+            err: &mut Diagnostic,\n             type_param_span: Option<(Span, bool, bool)>,\n             bound_kind: GenericKind<'tcx>,\n             sub: S,\n@@ -2373,7 +2371,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         let new_binding_suggestion =\n-            |err: &mut DiagnosticBuilder<'tcx>,\n+            |err: &mut Diagnostic,\n              type_param_span: Option<(Span, bool, bool)>,\n              bound_kind: GenericKind<'tcx>| {\n                 let msg = \"consider introducing an explicit lifetime bound\";\n@@ -2649,7 +2647,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     fn report_inference_failure(\n         &self,\n         var_origin: RegionVariableOrigin,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let br_string = |br: ty::BoundRegionKind| {\n             let mut s = match br {\n                 ty::BrNamed(_, name) => name.to_string(),"}, {"sha": "067f19bbe9426c2f1333ce57e3784a477b33daae", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,6 +1,8 @@\n use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::infer::{InferCtxt, Symbol};\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{\n+    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorReported,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace};\n use rustc_hir::def_id::DefId;\n@@ -195,7 +197,7 @@ impl UseDiagnostic<'_> {\n         }\n     }\n \n-    fn attach_note(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn attach_note(&self, err: &mut Diagnostic) {\n         match *self {\n             Self::TryConversion { pre_ty, post_ty, .. } => {\n                 let intro = \"`?` implicitly converts the error value\";\n@@ -224,7 +226,7 @@ impl UseDiagnostic<'_> {\n \n /// Suggest giving an appropriate return type to a closure expression.\n fn closure_return_type_suggestion(\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     output: &FnRetTy<'_>,\n     body: &Body<'_>,\n     ret: &str,\n@@ -488,7 +490,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         arg: GenericArg<'tcx>,\n         impl_candidates: Vec<ty::TraitRef<'tcx>>,\n         error_code: TypeAnnotationNeeded,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let arg = self.resolve_vars_if_possible(arg);\n         let arg_data = self.extract_inference_diagnostics_data(arg, None);\n \n@@ -868,7 +870,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         segment: &hir::PathSegment<'_>,\n         e: &Expr<'_>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n     ) {\n         if let (Some(typeck_results), None) = (self.in_progress_typeck_results, &segment.args) {\n             let borrow = typeck_results.borrow();\n@@ -913,7 +915,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         kind: hir::GeneratorKind,\n         span: Span,\n         ty: Ty<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let ty = self.resolve_vars_if_possible(ty);\n         let data = self.extract_inference_diagnostics_data(ty.into(), None);\n "}, {"sha": "bbbb0f79acc3e305e17e781924a29a955bdba07d", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -7,7 +7,7 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::SubregionOrigin;\n \n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::{GenericParamKind, Ty};\n use rustc_middle::ty::Region;\n@@ -156,7 +156,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         sub: Region<'tcx>,\n         ty_sup: &Ty<'_>,\n         ty_sub: &Ty<'_>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n     ) {\n         if let (\n             hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },"}, {"sha": "a8b878ae344a21024fb57dfe9340c8848b66e241", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -46,7 +46,7 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'tcx>> {\n+    pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         // Due to the improved diagnostics returned by the MIR borrow checker, only a subset of\n         // the nice region errors are required when running under the MIR borrow checker.\n         self.try_report_named_anon_conflict().or_else(|| self.try_report_placeholder_conflict())"}, {"sha": "825aadaad9a0cf3526223d2ebd02f849fa84a9d6", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -2,13 +2,15 @@\n //! where one region is named and the other is anonymous.\n use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_middle::ty;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n-    pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'tcx>> {\n+    pub(super) fn try_report_named_anon_conflict(\n+        &self,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         let (span, sub, sup) = self.regions()?;\n \n         debug!("}, {"sha": "5ce5d44e51d15431e943498a1736875cf1b0d6c9", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -4,7 +4,7 @@ use crate::infer::ValuePairs;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::intern::Interned;\n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::error::ExpectedFound;\n@@ -17,7 +17,9 @@ use std::fmt::{self, Write};\n impl<'tcx> NiceRegionError<'_, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit a descriptive diagnostic error.\n-    pub(super) fn try_report_placeholder_conflict(&self) -> Option<DiagnosticBuilder<'tcx>> {\n+    pub(super) fn try_report_placeholder_conflict(\n+        &self,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         match &self.error {\n             ///////////////////////////////////////////////////////////////////////////\n             // NB. The ordering of cases in this match is very\n@@ -153,7 +155,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         sub_placeholder: Option<Region<'tcx>>,\n         sup_placeholder: Option<Region<'tcx>>,\n         value_pairs: &ValuePairs<'tcx>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         let (expected_substs, found_substs, trait_def_id) = match value_pairs {\n             ValuePairs::TraitRefs(ExpectedFound { expected, found })\n                 if expected.def_id == found.def_id =>\n@@ -201,7 +203,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         trait_def_id: DefId,\n         expected_substs: SubstsRef<'tcx>,\n         actual_substs: SubstsRef<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let span = cause.span(self.tcx());\n         let msg = format!(\n             \"implementation of `{}` is not general enough\",\n@@ -306,7 +308,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n     /// due to the number of combinations we have to deal with.\n     fn explain_actual_impl_that_was_found(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         sub_placeholder: Option<Region<'tcx>>,\n         sup_placeholder: Option<Region<'tcx>>,\n         has_sub: Option<usize>,"}, {"sha": "210743d7cef7e8d3184c9e7157d5638f0787563c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -5,7 +5,7 @@ use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_data_structures::stable_set::FxHashSet;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorReported};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{self as hir, GenericBound, Item, ItemKind, Lifetime, LifetimeName, Node, TyKind};\n@@ -286,7 +286,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n pub fn suggest_new_region_bound(\n     tcx: TyCtxt<'_>,\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     fn_returns: Vec<&rustc_hir::Ty<'_>>,\n     lifetime_name: String,\n     arg: Option<String>,\n@@ -483,7 +483,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// `'static` obligation. Suggest relaxing that implicit bound.\n     fn find_impl_on_dyn_trait(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         ty: Ty<'_>,\n         ctxt: &UnifyReceiverContext<'tcx>,\n     ) -> bool {\n@@ -514,7 +514,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n     fn suggest_constrain_dyn_trait_in_impl(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         found_dids: &FxHashSet<DefId>,\n         ident: Ident,\n         self_ty: &hir::Ty<'_>,"}, {"sha": "5dc8c8946085661b7a427902c8684d6589305286", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,16 +1,12 @@\n use crate::infer::error_reporting::{note_and_explain_region, ObligationCauseExt};\n use crate::infer::{self, InferCtxt, SubregionOrigin};\n-use rustc_errors::{struct_span_err, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_middle::traits::ObligationCauseCode;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{self, Region};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub(super) fn note_region_origin(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        origin: &SubregionOrigin<'tcx>,\n-    ) {\n+    pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n         let mut label_or_note = |span, msg| {\n             let sub_count = err.children.iter().filter(|d| d.span.is_dummy()).count();\n             let expanded_sub_count = err.children.iter().filter(|d| !d.span.is_dummy()).count();\n@@ -113,7 +109,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n         sup: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         match origin {\n             infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n@@ -405,7 +401,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         placeholder_origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n         sup: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         // I can't think how to do better than this right now. -nikomatsakis\n         debug!(?placeholder_origin, ?sub, ?sup, \"report_placeholder_failure\");\n         match placeholder_origin {"}, {"sha": "95608f413d5389bd62be29bc7ff4a1aac5dbec9b", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::Rollback;\n use rustc_data_structures::unify as ut;\n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::{DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n@@ -1475,19 +1475,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         sp: Span,\n         mk_diag: M,\n         actual_ty: Ty<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx>\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported>\n     where\n-        M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n+        M: FnOnce(String) -> DiagnosticBuilder<'tcx, ErrorReported>,\n     {\n         let actual_ty = self.resolve_vars_if_possible(actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n+        let mut err = mk_diag(self.ty_to_string(actual_ty));\n+\n         // Don't report an error if actual type is `Error`.\n         if actual_ty.references_error() {\n-            return self.tcx.sess.diagnostic().struct_dummy();\n+            err.downgrade_to_delayed_bug();\n         }\n \n-        mk_diag(self.ty_to_string(actual_ty))\n+        err\n     }\n \n     pub fn report_mismatched_types(\n@@ -1496,7 +1498,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n         err: TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let trace = TypeTrace::types(cause, true, expected, actual);\n         self.report_and_explain_type_error(trace, &err)\n     }\n@@ -1507,7 +1509,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         expected: ty::Const<'tcx>,\n         actual: ty::Const<'tcx>,\n         err: TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let trace = TypeTrace::consts(cause, true, expected, actual);\n         self.report_and_explain_type_error(trace, &err)\n     }"}, {"sha": "35430849290e78982321ae89b8a8dfe817f28fe0", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -2,7 +2,7 @@ use super::ObjectSafetyViolation;\n \n use crate::infer::InferCtxt;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::TyCtxt;\n@@ -17,7 +17,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         impl_item_def_id: DefId,\n         trait_item_def_id: DefId,\n         requirement: &dyn fmt::Display,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let msg = \"impl has stricter requirements than trait\";\n         let sp = self.tcx.sess.source_map().guess_head_span(error_span);\n \n@@ -40,7 +40,7 @@ pub fn report_object_safety_error<'tcx>(\n     span: Span,\n     trait_def_id: DefId,\n     violations: &[ObjectSafetyViolation],\n-) -> DiagnosticBuilder<'tcx> {\n+) -> DiagnosticBuilder<'tcx, ErrorReported> {\n     let trait_str = tcx.def_path_str(trait_def_id);\n     let trait_span = tcx.hir().get_if_local(trait_def_id).and_then(|node| match node {\n         hir::Node::Item(item) => Some(item.ident.span),"}, {"sha": "2083526232423474f263231fe78dfbf9c8cd1cb2", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -102,7 +102,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n                 }\n \n                 match maybe_new_parser_from_source_str(&sess, filename, s.to_string()) {\n-                    Ok(mut parser) => match &mut parser.parse_meta_item() {\n+                    Ok(mut parser) => match parser.parse_meta_item() {\n                         Ok(meta_item) if parser.token == token::Eof => {\n                             if meta_item.path.segments.len() != 1 {\n                                 error!(\"argument key must be an identifier\");\n@@ -121,7 +121,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n                         Ok(..) => {}\n                         Err(err) => err.cancel(),\n                     },\n-                    Err(errs) => errs.into_iter().for_each(|mut err| err.cancel()),\n+                    Err(errs) => drop(errs),\n                 }\n \n                 // If the user tried to use a key=\"value\" flag, but is missing the quotes, provide\n@@ -165,7 +165,7 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n             }\n \n             match maybe_new_parser_from_source_str(&sess, filename, s.to_string()) {\n-                Ok(mut parser) => match &mut parser.parse_meta_item() {\n+                Ok(mut parser) => match parser.parse_meta_item() {\n                     Ok(meta_item) if parser.token == token::Eof => {\n                         if let Some(args) = meta_item.meta_item_list() {\n                             if meta_item.has_name(sym::names) {\n@@ -214,7 +214,7 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                     Ok(..) => {}\n                     Err(err) => err.cancel(),\n                 },\n-                Err(errs) => errs.into_iter().for_each(|mut err| err.cancel()),\n+                Err(errs) => drop(errs),\n             }\n \n             error!("}, {"sha": "46b90baa5858a267a5f9e51e68fb6cf71ed0c696", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -31,7 +31,7 @@ use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticStyledString};\n use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -1476,17 +1476,17 @@ impl TypeAliasBounds {\n         }\n     }\n \n-    fn suggest_changing_assoc_types(ty: &hir::Ty<'_>, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest_changing_assoc_types(ty: &hir::Ty<'_>, err: &mut Diagnostic) {\n         // Access to associates types should use `<T as Bound>::Assoc`, which does not need a\n         // bound.  Let's see if this type does that.\n \n         // We use a HIR visitor to walk the type.\n         use rustc_hir::intravisit::{self, Visitor};\n-        struct WalkAssocTypes<'a, 'db> {\n-            err: &'a mut DiagnosticBuilder<'db>,\n+        struct WalkAssocTypes<'a> {\n+            err: &'a mut Diagnostic,\n         }\n-        impl<'a, 'db, 'v> Visitor<'v> for WalkAssocTypes<'a, 'db> {\n-            fn visit_qpath(&mut self, qpath: &'v hir::QPath<'v>, id: hir::HirId, span: Span) {\n+        impl Visitor<'_> for WalkAssocTypes<'_> {\n+            fn visit_qpath(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) {\n                 if TypeAliasBounds::is_type_variable_assoc(qpath) {\n                     self.err.span_help(\n                         span,"}, {"sha": "ac0f4bd8a4d72fd0dac92c5246706ba137e911cf", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -319,14 +319,15 @@ impl LintStore {\n     ) {\n         let (tool_name, lint_name_only) = parse_lint_and_tool_name(lint_name);\n         if lint_name_only == crate::WARNINGS.name_lower() && level == Level::ForceWarn {\n-            return struct_span_err!(\n+            struct_span_err!(\n                 sess,\n                 DUMMY_SP,\n                 E0602,\n                 \"`{}` lint group is not supported with \u00b4--force-warn\u00b4\",\n                 crate::WARNINGS.name_lower()\n             )\n             .emit();\n+            return;\n         }\n         let db = match self.check_lint_name(lint_name_only, tool_name, registered_tools) {\n             CheckLintNameResult::Ok(_) => None,\n@@ -339,7 +340,7 @@ impl LintStore {\n                     err.help(&format!(\"did you mean: `{}`\", suggestion));\n                 }\n \n-                Some(err)\n+                Some(err.forget_guarantee())\n             }\n             CheckLintNameResult::Tool(result) => match result {\n                 Err((Some(_), new_name)) => Some(sess.struct_warn(&format!(\n@@ -350,13 +351,16 @@ impl LintStore {\n                 ))),\n                 _ => None,\n             },\n-            CheckLintNameResult::NoTool => Some(struct_span_err!(\n-                sess,\n-                DUMMY_SP,\n-                E0602,\n-                \"unknown lint tool: `{}`\",\n-                tool_name.unwrap()\n-            )),\n+            CheckLintNameResult::NoTool => Some(\n+                struct_span_err!(\n+                    sess,\n+                    DUMMY_SP,\n+                    E0602,\n+                    \"unknown lint tool: `{}`\",\n+                    tool_name.unwrap()\n+                )\n+                .forget_guarantee(),\n+            ),\n         };\n \n         if let Some(mut db) = db {"}, {"sha": "d7cdb08d81714c3cc940832ebd96a23784775e1c", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -3,7 +3,7 @@ use crate::late::unerased_lint_store;\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::{intravisit, HirId};\n use rustc_middle::hir::nested_filter;\n@@ -150,48 +150,49 @@ impl<'s> LintLevelsBuilder<'s> {\n                     fcw_warning, specs, old_src, id_name\n                 );\n \n-                let decorate_diag_builder = |mut diag_builder: DiagnosticBuilder<'_>| {\n-                    diag_builder.span_label(src.span(), \"overruled by previous forbid\");\n+                let decorate_diag = |diag: &mut Diagnostic| {\n+                    diag.span_label(src.span(), \"overruled by previous forbid\");\n                     match old_src {\n                         LintLevelSource::Default => {\n-                            diag_builder.note(&format!(\n+                            diag.note(&format!(\n                                 \"`forbid` lint level is the default for {}\",\n                                 id.to_string()\n                             ));\n                         }\n                         LintLevelSource::Node(_, forbid_source_span, reason) => {\n-                            diag_builder.span_label(forbid_source_span, \"`forbid` level set here\");\n+                            diag.span_label(forbid_source_span, \"`forbid` level set here\");\n                             if let Some(rationale) = reason {\n-                                diag_builder.note(rationale.as_str());\n+                                diag.note(rationale.as_str());\n                             }\n                         }\n                         LintLevelSource::CommandLine(_, _) => {\n-                            diag_builder.note(\"`forbid` lint level was set on command line\");\n+                            diag.note(\"`forbid` lint level was set on command line\");\n                         }\n                     }\n-                    diag_builder.emit();\n                 };\n                 if !fcw_warning {\n-                    let diag_builder = struct_span_err!(\n+                    let mut diag_builder = struct_span_err!(\n                         self.sess,\n                         src.span(),\n                         E0453,\n                         \"{}({}) incompatible with previous forbid\",\n                         level.as_str(),\n                         src.name(),\n                     );\n-                    decorate_diag_builder(diag_builder);\n+                    decorate_diag(&mut diag_builder);\n+                    diag_builder.emit();\n                 } else {\n                     self.struct_lint(\n                         FORBIDDEN_LINT_GROUPS,\n                         Some(src.span().into()),\n                         |diag_builder| {\n-                            let diag_builder = diag_builder.build(&format!(\n+                            let mut diag_builder = diag_builder.build(&format!(\n                                 \"{}({}) incompatible with previous forbid\",\n                                 level.as_str(),\n                                 src.name(),\n                             ));\n-                            decorate_diag_builder(diag_builder);\n+                            decorate_diag(&mut diag_builder);\n+                            diag_builder.emit();\n                         },\n                     );\n                 }"}, {"sha": "9a7784ca72fc61488549e97bf527142ffac5f4c9", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -232,7 +232,7 @@ impl<'a> SessionDiagnosticDerive<'a> {\n                 fn into_diagnostic(\n                     self,\n                     #sess: &'__session_diagnostic_sess rustc_session::Session\n-                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess> {\n+                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess, rustc_errors::ErrorReported> {\n                     #implementation\n                 }\n             }"}, {"sha": "dce1b35c6b8897084c8ad06384278f9b75ee9590", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -243,7 +243,9 @@ impl Collector<'_> {\n         if matches!(lib.kind, NativeLibKind::Framework { .. }) && !is_osx {\n             let msg = \"native frameworks are only available on macOS targets\";\n             match span {\n-                Some(span) => struct_span_err!(self.tcx.sess, span, E0455, \"{}\", msg).emit(),\n+                Some(span) => {\n+                    struct_span_err!(self.tcx.sess, span, E0455, \"{}\", msg).emit();\n+                }\n                 None => self.tcx.sess.err(msg),\n             }\n         }"}, {"sha": "35e1558600d5b3fc2b76f37601fea1aacf6d2737", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -2,7 +2,7 @@ use std::cmp;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticId};\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_query_system::ich::StableHashingContext;\n@@ -186,28 +186,28 @@ impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n     }\n }\n \n-pub struct LintDiagnosticBuilder<'a>(DiagnosticBuilder<'a>);\n+pub struct LintDiagnosticBuilder<'a>(DiagnosticBuilder<'a, ()>);\n \n impl<'a> LintDiagnosticBuilder<'a> {\n     /// Return the inner DiagnosticBuilder, first setting the primary message to `msg`.\n-    pub fn build(mut self, msg: &str) -> DiagnosticBuilder<'a> {\n+    pub fn build(mut self, msg: &str) -> DiagnosticBuilder<'a, ()> {\n         self.0.set_primary_message(msg);\n         self.0.set_is_lint();\n         self.0\n     }\n \n     /// Create a LintDiagnosticBuilder from some existing DiagnosticBuilder.\n-    pub fn new(err: DiagnosticBuilder<'a>) -> LintDiagnosticBuilder<'a> {\n+    pub fn new(err: DiagnosticBuilder<'a, ()>) -> LintDiagnosticBuilder<'a> {\n         LintDiagnosticBuilder(err)\n     }\n }\n \n-pub fn explain_lint_level_source<'s>(\n-    sess: &'s Session,\n+pub fn explain_lint_level_source(\n+    sess: &Session,\n     lint: &'static Lint,\n     level: Level,\n     src: LintLevelSource,\n-    err: &mut DiagnosticBuilder<'s>,\n+    err: &mut Diagnostic,\n ) {\n     let name = lint.name_lower();\n     match src {\n@@ -314,10 +314,8 @@ pub fn struct_lint_level<'s, 'd>(\n                     return;\n                 }\n             }\n-            (Level::Warn, Some(span)) => sess.struct_span_warn(span, \"\"),\n-            (Level::Warn, None) => sess.struct_warn(\"\"),\n-            (Level::ForceWarn, Some(span)) => sess.struct_span_force_warn(span, \"\"),\n-            (Level::ForceWarn, None) => sess.struct_force_warn(\"\"),\n+            (Level::Warn | Level::ForceWarn, Some(span)) => sess.struct_span_warn(span, \"\"),\n+            (Level::Warn | Level::ForceWarn, None) => sess.struct_warn(\"\"),\n             (Level::Deny | Level::Forbid, Some(span)) => {\n                 let mut builder = sess.diagnostic().struct_err_lint(\"\");\n                 builder.set_span(span);"}, {"sha": "ff19c33d8e8e1784de156268921c5823ad3ec803", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -7,7 +7,7 @@ use crate::ty::{self, DefIdTree, TyCtxt};\n use rustc_ast::NodeId;\n use rustc_attr::{self as attr, ConstStability, Deprecation, Stability};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_feature::GateIssue;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n@@ -167,7 +167,7 @@ pub fn deprecation_in_effect(depr: &Deprecation) -> bool {\n }\n \n pub fn deprecation_suggestion(\n-    diag: &mut DiagnosticBuilder<'_>,\n+    diag: &mut Diagnostic,\n     kind: &str,\n     suggestion: Option<Symbol>,\n     span: Span,"}, {"sha": "31468ce73bfc5b4fc162286e3d5ed14c9b2d4bc1", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -36,7 +36,10 @@ TrivialTypeFoldableAndLiftImpls! {\n pub type EvalToAllocationRawResult<'tcx> = Result<ConstAlloc<'tcx>, ErrorHandled>;\n pub type EvalToConstValueResult<'tcx> = Result<ConstValue<'tcx>, ErrorHandled>;\n \n-pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'tcx> {\n+pub fn struct_error<'tcx>(\n+    tcx: TyCtxtAt<'tcx>,\n+    msg: &str,\n+) -> DiagnosticBuilder<'tcx, ErrorReported> {\n     struct_span_err!(tcx.sess, tcx.span, E0080, \"{}\", msg)\n }\n "}, {"sha": "072e6346cdec945b7dd6e0c8cc8be6402ff44efb", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -15,7 +15,7 @@ use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n \n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_span::symbol::Symbol;\n@@ -841,7 +841,7 @@ impl ObjectSafetyViolation {\n         }\n     }\n \n-    pub fn solution(&self, err: &mut DiagnosticBuilder<'_>) {\n+    pub fn solution(&self, err: &mut Diagnostic) {\n         match *self {\n             ObjectSafetyViolation::SizedSelf(_) | ObjectSafetyViolation::SupertraitSelf(_) => {}\n             ObjectSafetyViolation::Method("}, {"sha": "58cf9fa7a8943e0ba393f636ceb2b8fc5d430d2c", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -7,7 +7,7 @@ use crate::ty::{\n     ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n };\n \n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n@@ -129,7 +129,7 @@ impl<'tcx> Ty<'tcx> {\n \n pub fn suggest_arbitrary_trait_bound(\n     generics: &hir::Generics<'_>,\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     param_name: &str,\n     constraint: &str,\n ) -> bool {\n@@ -159,7 +159,7 @@ pub fn suggest_arbitrary_trait_bound(\n \n fn suggest_removing_unsized_bound(\n     generics: &hir::Generics<'_>,\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     param_name: &str,\n     param: &hir::GenericParam<'_>,\n     def_id: Option<DefId>,\n@@ -266,7 +266,7 @@ fn suggest_removing_unsized_bound(\n pub fn suggest_constraining_type_param(\n     tcx: TyCtxt<'_>,\n     generics: &hir::Generics<'_>,\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     param_name: &str,\n     constraint: &str,\n     def_id: Option<DefId>,"}, {"sha": "708bd64578c3a69bc29968f2c5ba52d1141e1cc6", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -3,7 +3,7 @@ use crate::ty::diagnostics::suggest_constraining_type_param;\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n-use rustc_errors::{pluralize, DiagnosticBuilder};\n+use rustc_errors::{pluralize, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::{sym, Symbol};\n@@ -347,7 +347,8 @@ impl<'tcx> Ty<'tcx> {\n impl<'tcx> TyCtxt<'tcx> {\n     pub fn note_and_explain_type_err(\n         self,\n-        db: &mut DiagnosticBuilder<'_>,\n+        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n+        db: &mut Diagnostic,\n         err: &TypeError<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         sp: Span,\n@@ -584,7 +585,8 @@ impl<T> Trait<T> for X {\n \n     fn suggest_constraint(\n         self,\n-        db: &mut DiagnosticBuilder<'_>,\n+        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n+        db: &mut Diagnostic,\n         msg: &str,\n         body_owner_def_id: DefId,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n@@ -671,7 +673,8 @@ impl<T> Trait<T> for X {\n     ///    fn that returns the type.\n     fn expected_projection(\n         self,\n-        db: &mut DiagnosticBuilder<'_>,\n+        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n+        db: &mut Diagnostic,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n         values: &ExpectedFound<Ty<'tcx>>,\n         body_owner_def_id: DefId,\n@@ -766,7 +769,8 @@ fn foo(&self) -> Self::T { String::new() }\n     /// a return type. This can occur when dealing with `TryStream` (#71035).\n     fn suggest_constraining_opaque_associated_type(\n         self,\n-        db: &mut DiagnosticBuilder<'_>,\n+        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n+        db: &mut Diagnostic,\n         msg: &str,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n         ty: Ty<'tcx>,\n@@ -802,7 +806,8 @@ fn foo(&self) -> Self::T { String::new() }\n \n     fn point_at_methods_that_satisfy_associated_type(\n         self,\n-        db: &mut DiagnosticBuilder<'_>,\n+        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n+        db: &mut Diagnostic,\n         assoc_container_id: DefId,\n         current_method_ident: Option<Symbol>,\n         proj_ty_item_def_id: DefId,\n@@ -857,7 +862,8 @@ fn foo(&self) -> Self::T { String::new() }\n \n     fn point_at_associated_type(\n         self,\n-        db: &mut DiagnosticBuilder<'_>,\n+        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n+        db: &mut Diagnostic,\n         body_owner_def_id: DefId,\n         found: Ty<'tcx>,\n     ) -> bool {\n@@ -921,7 +927,8 @@ fn foo(&self) -> Self::T { String::new() }\n     /// type is defined on a supertrait of the one present in the bounds.\n     fn constrain_generic_bound_associated_type_structured_suggestion(\n         self,\n-        db: &mut DiagnosticBuilder<'_>,\n+        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n+        db: &mut Diagnostic,\n         trait_ref: &ty::TraitRef<'tcx>,\n         bounds: hir::GenericBounds<'_>,\n         assoc: &ty::AssocItem,\n@@ -958,7 +965,8 @@ fn foo(&self) -> Self::T { String::new() }\n     /// associated type to a given type `ty`.\n     fn constrain_associated_type_structured_suggestion(\n         self,\n-        db: &mut DiagnosticBuilder<'_>,\n+        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n+        db: &mut Diagnostic,\n         span: Span,\n         assoc: &ty::AssocItem,\n         assoc_substs: &[ty::GenericArg<'tcx>],"}, {"sha": "2663ed9049da93ec455c2face64c6d8cd94574e4", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -6,7 +6,9 @@ use super::{PatCtxt, PatternError};\n \n use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n-use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{\n+    error_code, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorReported,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::*;\n use rustc_hir::def_id::DefId;\n@@ -36,7 +38,11 @@ crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     visitor.visit_body(tcx.hir().body(body_id));\n }\n \n-fn create_e0004(sess: &Session, sp: Span, error_message: String) -> DiagnosticBuilder<'_> {\n+fn create_e0004(\n+    sess: &Session,\n+    sp: Span,\n+    error_message: String,\n+) -> DiagnosticBuilder<'_, ErrorReported> {\n     struct_span_err!(sess, sp, E0004, \"{}\", &error_message)\n }\n \n@@ -281,12 +287,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n \n /// A path pattern was interpreted as a constant, not a new variable.\n /// This caused an irrefutable match failure in e.g. `let`.\n-fn const_not_var(\n-    err: &mut DiagnosticBuilder<'_>,\n-    tcx: TyCtxt<'_>,\n-    pat: &Pat<'_>,\n-    path: &hir::Path<'_>,\n-) {\n+fn const_not_var(err: &mut Diagnostic, tcx: TyCtxt<'_>, pat: &Pat<'_>, path: &hir::Path<'_>) {\n     let descr = path.res.descr();\n     err.span_label(\n         pat.span,\n@@ -594,7 +595,7 @@ crate fn pattern_not_covered_label(\n /// Point at the definition of non-covered `enum` variants.\n fn adt_defined_here<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     ty: Ty<'tcx>,\n     witnesses: &[DeconstructedPat<'p, 'tcx>],\n ) {"}, {"sha": "8731669b10958cae895d4ed66593b20f76e7cfbc", "filename": "compiler/rustc_mir_transform/src/check_const_item_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n         place: &Place<'tcx>,\n         const_item: DefId,\n         location: Location,\n-        decorate: impl for<'b> FnOnce(LintDiagnosticBuilder<'b>) -> DiagnosticBuilder<'b>,\n+        decorate: impl for<'b> FnOnce(LintDiagnosticBuilder<'b>) -> DiagnosticBuilder<'b, ()>,\n     ) {\n         // Don't lint on borrowing/assigning when a dereference is involved.\n         // If we 'leave' the temporary via a dereference, we must"}, {"sha": "3212fc39fb9c253e4eeadda60637065d92b7f95b", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -3,7 +3,9 @@ use rustc_ast::ast::{self, AttrStyle};\n use rustc_ast::token::{self, CommentKind, Token, TokenKind};\n use rustc_ast::tokenstream::{Spacing, TokenStream};\n use rustc_ast::util::unicode::contains_text_flow_control_chars;\n-use rustc_errors::{error_code, Applicability, DiagnosticBuilder, FatalError, PResult};\n+use rustc_errors::{\n+    error_code, Applicability, DiagnosticBuilder, ErrorReported, FatalError, PResult,\n+};\n use rustc_lexer::unescape::{self, Mode};\n use rustc_lexer::{Base, DocStyle, RawStrError};\n use rustc_session::lint::builtin::{\n@@ -127,7 +129,7 @@ impl<'a> StringReader<'a> {\n         to_pos: BytePos,\n         m: &str,\n         c: char,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'a, ErrorReported> {\n         self.sess\n             .span_diagnostic\n             .struct_span_fatal(self.mk_sp(from_pos, to_pos), &format!(\"{}: {}\", m, escaped_char(c)))"}, {"sha": "c7d166319eac8621af1a56109eb99ab1ac4f52c5", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -144,7 +144,7 @@ pub(crate) fn emit_unescape_error(\n                     c.escape_default().to_string(),\n                     Applicability::MachineApplicable,\n                 )\n-                .emit()\n+                .emit();\n         }\n         EscapeError::BareCarriageReturn => {\n             let msg = if mode.in_double_quotes() {\n@@ -292,16 +292,18 @@ pub(crate) fn emit_unescape_error(\n                 .span_label(span, \"must have at most 6 hex digits\")\n                 .emit();\n         }\n-        EscapeError::UnclosedUnicodeEscape => handler\n-            .struct_span_err(span, \"unterminated unicode escape\")\n-            .span_label(span, \"missing a closing `}`\")\n-            .span_suggestion_verbose(\n-                span.shrink_to_hi(),\n-                \"terminate the unicode escape\",\n-                \"}\".to_string(),\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit(),\n+        EscapeError::UnclosedUnicodeEscape => {\n+            handler\n+                .struct_span_err(span, \"unterminated unicode escape\")\n+                .span_label(span, \"missing a closing `}`\")\n+                .span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    \"terminate the unicode escape\",\n+                    \"}\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .emit();\n+        }\n         EscapeError::NoBraceInUnicodeEscape => {\n             let msg = \"incorrect unicode escape sequence\";\n             let mut diag = handler.struct_span_err(span, msg);\n@@ -347,7 +349,7 @@ pub(crate) fn emit_unescape_error(\n         }\n         EscapeError::ZeroChars => {\n             let msg = \"empty character literal\";\n-            handler.struct_span_err(span, msg).span_label(span, msg).emit()\n+            handler.struct_span_err(span, msg).span_label(span, msg).emit();\n         }\n         EscapeError::LoneSlash => {\n             let msg = \"invalid trailing slash in literal\";"}, {"sha": "1d63b79adc53a8a93040303b125378f40f132fcb", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -3,7 +3,7 @@\n \n use super::StringReader;\n use crate::token;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_span::{symbol::kw, BytePos, Pos, Span};\n \n #[rustfmt::skip] // for line breaks\n@@ -336,7 +336,7 @@ pub(super) fn check_for_substitution<'a>(\n     reader: &StringReader<'a>,\n     pos: BytePos,\n     ch: char,\n-    err: &mut DiagnosticBuilder<'a>,\n+    err: &mut Diagnostic,\n ) -> Option<token::TokenKind> {\n     let Some(&(_u_char, u_name, ascii_char)) = UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch) else {\n         return None;"}, {"sha": "379e47077ea18b85377618fbcfc6ab8b3b1879f7", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -3,7 +3,7 @@ use rustc_ast as ast;\n use rustc_ast::attr;\n use rustc_ast::token::{self, Nonterminal};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{error_code, DiagnosticBuilder, PResult};\n+use rustc_errors::{error_code, Diagnostic, PResult};\n use rustc_span::{sym, BytePos, Span};\n use std::convert::TryInto;\n \n@@ -147,7 +147,7 @@ impl<'a> Parser<'a> {\n \n     fn annotate_following_item_if_applicable(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         span: Span,\n         attr_type: OuterAttributeType,\n     ) -> Option<Span> {\n@@ -165,7 +165,7 @@ impl<'a> Parser<'a> {\n         loop {\n             // skip any other attributes, we want the item\n             if snapshot.token.kind == token::Pound {\n-                if let Err(mut err) = snapshot.parse_attribute(InnerAttrPolicy::Permitted) {\n+                if let Err(err) = snapshot.parse_attribute(InnerAttrPolicy::Permitted) {\n                     err.cancel();\n                     return Some(replacement_span);\n                 }\n@@ -206,7 +206,7 @@ impl<'a> Parser<'a> {\n                 );\n                 return None;\n             }\n-            Err(mut item_err) => {\n+            Err(item_err) => {\n                 item_err.cancel();\n             }\n             Ok(None) => {}\n@@ -412,12 +412,12 @@ impl<'a> Parser<'a> {\n     fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n         match self.parse_unsuffixed_lit() {\n             Ok(lit) => return Ok(ast::NestedMetaItem::Literal(lit)),\n-            Err(ref mut err) => err.cancel(),\n+            Err(err) => err.cancel(),\n         }\n \n         match self.parse_meta_item() {\n             Ok(mi) => return Ok(ast::NestedMetaItem::MetaItem(mi)),\n-            Err(ref mut err) => err.cancel(),\n+            Err(err) => err.cancel(),\n         }\n \n         let found = pprust::token_to_string(&self.token);"}, {"sha": "f1c2dcf10e8696b52513690405f01bb06bc65e67", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -16,7 +16,7 @@ use rustc_ast::{\n };\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{pluralize, struct_span_err};\n+use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorReported};\n use rustc_errors::{Applicability, DiagnosticBuilder, Handler, PResult};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, Ident};\n@@ -53,7 +53,11 @@ pub enum Error {\n }\n \n impl Error {\n-    fn span_err(self, sp: impl Into<MultiSpan>, handler: &Handler) -> DiagnosticBuilder<'_> {\n+    fn span_err(\n+        self,\n+        sp: impl Into<MultiSpan>,\n+        handler: &Handler,\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         match self {\n             Error::UselessDocComment => {\n                 let mut err = struct_span_err!(\n@@ -151,11 +155,19 @@ impl AttemptLocalParseRecovery {\n }\n \n impl<'a> Parser<'a> {\n-    pub(super) fn span_err<S: Into<MultiSpan>>(&self, sp: S, err: Error) -> DiagnosticBuilder<'a> {\n+    pub(super) fn span_err<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        err: Error,\n+    ) -> DiagnosticBuilder<'a, ErrorReported> {\n         err.span_err(sp, self.diagnostic())\n     }\n \n-    pub fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        m: &str,\n+    ) -> DiagnosticBuilder<'a, ErrorReported> {\n         self.sess.span_diagnostic.struct_span_err(sp, m)\n     }\n \n@@ -171,7 +183,7 @@ impl<'a> Parser<'a> {\n         self.sess.source_map().span_to_snippet(span)\n     }\n \n-    pub(super) fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n+    pub(super) fn expected_ident_found(&self) -> DiagnosticBuilder<'a, ErrorReported> {\n         let mut err = self.struct_span_err(\n             self.token.span,\n             &format!(\"expected identifier, found {}\", super::token_descr(&self.token)),\n@@ -393,7 +405,7 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n-    fn check_too_many_raw_str_terminators(&mut self, err: &mut DiagnosticBuilder<'_>) -> bool {\n+    fn check_too_many_raw_str_terminators(&mut self, err: &mut Diagnostic) -> bool {\n         match (&self.prev_token.kind, &self.token.kind) {\n             (\n                 TokenKind::Literal(Lit {\n@@ -461,12 +473,12 @@ impl<'a> Parser<'a> {\n                     tail.could_be_bare_literal = true;\n                     Ok(tail)\n                 }\n-                (Err(mut err), Ok(tail)) => {\n+                (Err(err), Ok(tail)) => {\n                     // We have a block tail that contains a somehow valid type ascription expr.\n                     err.cancel();\n                     Ok(tail)\n                 }\n-                (Err(mut snapshot_err), Err(err)) => {\n+                (Err(snapshot_err), Err(err)) => {\n                     // We don't know what went wrong, emit the normal error.\n                     snapshot_err.cancel();\n                     self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n@@ -483,7 +495,7 @@ impl<'a> Parser<'a> {\n \n     pub fn maybe_annotate_with_ascription(\n         &mut self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         maybe_expected_semicolon: bool,\n     ) {\n         if let Some((sp, likely_path)) = self.last_type_ascription.take() {\n@@ -537,7 +549,7 @@ impl<'a> Parser<'a> {\n     /// Eats and discards tokens until one of `kets` is encountered. Respects token trees,\n     /// passes through any errors encountered. Used for error recovery.\n     pub(super) fn eat_to_tokens(&mut self, kets: &[&TokenKind]) {\n-        if let Err(ref mut err) =\n+        if let Err(err) =\n             self.parse_seq_to_before_tokens(kets, SeqSep::none(), TokenExpectType::Expect, |p| {\n                 Ok(p.parse_token_tree())\n             })\n@@ -703,7 +715,7 @@ impl<'a> Parser<'a> {\n                         *self = snapshot;\n                     }\n                 }\n-                Err(mut err) => {\n+                Err(err) => {\n                     // We couldn't parse generic parameters, unlikely to be a turbofish. Rely on\n                     // generic parse error instead.\n                     err.cancel();\n@@ -717,7 +729,7 @@ impl<'a> Parser<'a> {\n     /// encounter a parse error when encountering the first `,`.\n     pub(super) fn check_mistyped_turbofish_with_multiple_type_params(\n         &mut self,\n-        mut e: DiagnosticBuilder<'a>,\n+        mut e: DiagnosticBuilder<'a, ErrorReported>,\n         expr: &mut P<Expr>,\n     ) -> PResult<'a, ()> {\n         if let ExprKind::Binary(binop, _, _) = &expr.kind {\n@@ -744,14 +756,14 @@ impl<'a> Parser<'a> {\n                                             self.mk_expr_err(expr.span.to(self.prev_token.span));\n                                         return Ok(());\n                                     }\n-                                    Err(mut err) => {\n+                                    Err(err) => {\n                                         *expr = self.mk_expr_err(expr.span);\n                                         err.cancel();\n                                     }\n                                 }\n                             }\n                         }\n-                        Err(mut err) => {\n+                        Err(err) => {\n                             err.cancel();\n                         }\n                         _ => {}\n@@ -767,7 +779,7 @@ impl<'a> Parser<'a> {\n     /// parenthesising the leftmost comparison.\n     fn attempt_chained_comparison_suggestion(\n         &mut self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         inner_op: &Expr,\n         outer_op: &Spanned<AssocOp>,\n     ) -> bool /* advanced the cursor */ {\n@@ -821,7 +833,7 @@ impl<'a> Parser<'a> {\n                             enclose(r1.span, r2.span);\n                             true\n                         }\n-                        Err(mut expr_err) => {\n+                        Err(expr_err) => {\n                             expr_err.cancel();\n                             *self = snapshot;\n                             false\n@@ -838,7 +850,7 @@ impl<'a> Parser<'a> {\n                             enclose(l1.span, r1.span);\n                             true\n                         }\n-                        Err(mut expr_err) => {\n+                        Err(expr_err) => {\n                             expr_err.cancel();\n                             *self = snapshot;\n                             false\n@@ -890,7 +902,7 @@ impl<'a> Parser<'a> {\n                     \"comparison operators cannot be chained\",\n                 );\n \n-                let suggest = |err: &mut DiagnosticBuilder<'_>| {\n+                let suggest = |err: &mut Diagnostic| {\n                     err.span_suggestion_verbose(\n                         op.span.shrink_to_lo(),\n                         TURBOFISH_SUGGESTION_STR,\n@@ -938,7 +950,7 @@ impl<'a> Parser<'a> {\n                                 // `ExprKind::Err` placeholder.\n                                 mk_err_expr(self, inner_op.span.to(self.prev_token.span))\n                             }\n-                            Err(mut expr_err) => {\n+                            Err(expr_err) => {\n                                 expr_err.cancel();\n                                 // Not entirely sure now, but we bubble the error up with the\n                                 // suggestion.\n@@ -1439,7 +1451,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn recover_closing_delimiter(\n         &mut self,\n         tokens: &[TokenKind],\n-        mut err: DiagnosticBuilder<'a>,\n+        mut err: DiagnosticBuilder<'a, ErrorReported>,\n     ) -> PResult<'a, bool> {\n         let mut pos = None;\n         // We want to use the last closing delim that would apply.\n@@ -1637,7 +1649,7 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn parameter_without_type(\n         &mut self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         pat: P<ast::Pat>,\n         require_name: bool,\n         first_param: bool,\n@@ -1810,7 +1822,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn expected_expression_found(&self) -> DiagnosticBuilder<'a> {\n+    pub(super) fn expected_expression_found(&self) -> DiagnosticBuilder<'a, ErrorReported> {\n         let (span, msg) = match (&self.token.kind, self.subparser_name) {\n             (&token::Eof, Some(origin)) => {\n                 let sp = self.sess.source_map().next_point(self.prev_token.span);\n@@ -1946,17 +1958,14 @@ impl<'a> Parser<'a> {\n         Ok(expr)\n     }\n \n-    fn recover_const_param_decl(\n-        &mut self,\n-        ty_generics: Option<&Generics>,\n-    ) -> PResult<'a, Option<GenericArg>> {\n+    fn recover_const_param_decl(&mut self, ty_generics: Option<&Generics>) -> Option<GenericArg> {\n         let snapshot = self.clone();\n         let param = match self.parse_const_param(vec![]) {\n             Ok(param) => param,\n-            Err(mut err) => {\n+            Err(err) => {\n                 err.cancel();\n                 *self = snapshot;\n-                return Err(err);\n+                return None;\n             }\n         };\n         let mut err =\n@@ -1977,16 +1986,16 @@ impl<'a> Parser<'a> {\n         }\n         let value = self.mk_expr_err(param.span());\n         err.emit();\n-        return Ok(Some(GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value })));\n+        Some(GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value }))\n     }\n \n     pub fn recover_const_param_declaration(\n         &mut self,\n         ty_generics: Option<&Generics>,\n     ) -> PResult<'a, Option<GenericArg>> {\n         // We have to check for a few different cases.\n-        if let Ok(arg) = self.recover_const_param_decl(ty_generics) {\n-            return Ok(arg);\n+        if let Some(arg) = self.recover_const_param_decl(ty_generics) {\n+            return Ok(Some(arg));\n         }\n \n         // We haven't consumed `const` yet.\n@@ -2019,7 +2028,7 @@ impl<'a> Parser<'a> {\n     pub fn recover_const_arg(\n         &mut self,\n         start: Span,\n-        mut err: DiagnosticBuilder<'a>,\n+        mut err: DiagnosticBuilder<'a, ErrorReported>,\n     ) -> PResult<'a, GenericArg> {\n         let is_op = AssocOp::from_token(&self.token)\n             .and_then(|op| {\n@@ -2085,7 +2094,7 @@ impl<'a> Parser<'a> {\n                     return Ok(GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value }));\n                 }\n             }\n-            Err(mut err) => {\n+            Err(err) => {\n                 err.cancel();\n             }\n         }\n@@ -2099,7 +2108,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn incorrect_move_async_order_found(\n         &self,\n         move_async_span: Span,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'a, ErrorReported> {\n         let mut err =\n             self.struct_span_err(move_async_span, \"the order of `move` and `async` is incorrect\");\n         err.span_suggestion_verbose(\n@@ -2139,7 +2148,7 @@ impl<'a> Parser<'a> {\n             Err(mut err) => {\n                 self.bump(); // Skip the `:`.\n                 match self.parse_pat_no_top_alt(expected) {\n-                    Err(mut inner_err) => {\n+                    Err(inner_err) => {\n                         // Carry on as if we had not done anything, callers will emit a\n                         // reasonable error.\n                         inner_err.cancel();\n@@ -2246,7 +2255,7 @@ impl<'a> Parser<'a> {\n         // suggestion-enhanced error here rather than choking on the comma later.\n         let comma_span = self.token.span;\n         self.bump();\n-        if let Err(mut err) = self.skip_pat_list() {\n+        if let Err(err) = self.skip_pat_list() {\n             // We didn't expect this to work anyway; we just wanted to advance to the\n             // end of the comma-sequence so we know the span to suggest parenthesizing.\n             err.cancel();"}, {"sha": "c6919779ffd35e7c1c693c89315377d050c79766", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -17,7 +17,7 @@ use rustc_ast::{self as ast, AttrStyle, AttrVec, CaptureBy, ExprField, Lit, UnOp\n use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty, TyKind};\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{Applicability, DiagnosticBuilder, PResult};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported, PResult};\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::edition::LATEST_STABLE_EDITION;\n@@ -684,7 +684,7 @@ impl<'a> Parser<'a> {\n         let parser_snapshot_before_type = self.clone();\n         let cast_expr = match self.parse_as_cast_ty() {\n             Ok(rhs) => mk_expr(self, lhs, rhs),\n-            Err(mut type_err) => {\n+            Err(type_err) => {\n                 // Rewind to before attempting to parse the type with generics, to recover\n                 // from situations like `x as usize < y` in which we first tried to parse\n                 // `usize < y` as a type with generic arguments.\n@@ -717,7 +717,7 @@ impl<'a> Parser<'a> {\n                                     .emit();\n                                 return Ok(expr);\n                             }\n-                            Err(mut err) => {\n+                            Err(err) => {\n                                 err.cancel();\n                                 *self = snapshot;\n                             }\n@@ -773,7 +773,7 @@ impl<'a> Parser<'a> {\n \n                         expr\n                     }\n-                    Err(mut path_err) => {\n+                    Err(path_err) => {\n                         // Couldn't parse as a path, return original error and parser state.\n                         path_err.cancel();\n                         *self = parser_snapshot_after_type;\n@@ -1127,7 +1127,7 @@ impl<'a> Parser<'a> {\n         snapshot: Option<(Self, ExprKind)>,\n     ) -> Option<P<Expr>> {\n         match (seq.as_mut(), snapshot) {\n-            (Err(ref mut err), Some((mut snapshot, ExprKind::Path(None, path)))) => {\n+            (Err(err), Some((mut snapshot, ExprKind::Path(None, path)))) => {\n                 let name = pprust::path_to_string(&path);\n                 snapshot.bump(); // `(`\n                 match snapshot.parse_struct_fields(path, false, token::Paren) {\n@@ -1138,11 +1138,12 @@ impl<'a> Parser<'a> {\n                         let close_paren = self.prev_token.span;\n                         let span = lo.to(self.prev_token.span);\n                         if !fields.is_empty() {\n-                            err.cancel();\n-                            let mut err = self.struct_span_err(\n+                            let replacement_err = self.struct_span_err(\n                                 span,\n                                 \"invalid `struct` delimiters or `fn` call arguments\",\n                             );\n+                            mem::replace(err, replacement_err).cancel();\n+\n                             err.multipart_suggestion(\n                                 &format!(\"if `{}` is a struct, use braces as delimiters\", name),\n                                 vec![\n@@ -1166,7 +1167,9 @@ impl<'a> Parser<'a> {\n                         return Some(self.mk_expr_err(span));\n                     }\n                     Ok(_) => {}\n-                    Err(mut err) => err.emit(),\n+                    Err(mut err) => {\n+                        err.emit();\n+                    }\n                 }\n             }\n             _ => {}\n@@ -1622,9 +1625,11 @@ impl<'a> Parser<'a> {\n                 };\n                 if let Some(expr) = expr {\n                     if matches!(expr.kind, ExprKind::Err) {\n-                        self.diagnostic()\n-                            .delay_span_bug(self.token.span, &\"invalid interpolated expression\");\n-                        return self.diagnostic().struct_dummy();\n+                        let mut err = self\n+                            .diagnostic()\n+                            .struct_span_err(self.token.span, &\"invalid interpolated expression\");\n+                        err.downgrade_to_delayed_bug();\n+                        return err;\n                     }\n                 }\n             }\n@@ -1816,6 +1821,7 @@ impl<'a> Parser<'a> {\n                 err\n             } else {\n                 self.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n+                    .forget_guarantee()\n             };\n             err.span_label(sp, format!(\"invalid suffix `{}`\", suf));\n             err.emit();\n@@ -1876,7 +1882,7 @@ impl<'a> Parser<'a> {\n                 *self = snapshot;\n                 Some(self.mk_expr_err(arr.span))\n             }\n-            Err(mut e) => {\n+            Err(e) => {\n                 e.cancel();\n                 None\n             }\n@@ -2097,9 +2103,9 @@ impl<'a> Parser<'a> {\n     fn error_missing_if_then_block(\n         &self,\n         if_span: Span,\n-        err: Option<DiagnosticBuilder<'a>>,\n+        err: Option<DiagnosticBuilder<'a, ErrorReported>>,\n         binop_span: Option<Span>,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'a, ErrorReported> {\n         let msg = \"this `if` expression has a condition, but no block\";\n \n         let mut err = if let Some(mut err) = err {\n@@ -2379,7 +2385,7 @@ impl<'a> Parser<'a> {\n                         return Some(err(self, stmts));\n                     }\n                 }\n-                Err(mut err) => {\n+                Err(err) => {\n                     err.cancel();\n                 }\n             }\n@@ -2396,7 +2402,7 @@ impl<'a> Parser<'a> {\n                 }\n                 // We couldn't parse either yet another statement missing it's\n                 // enclosing block nor the next arm's pattern or closing brace.\n-                Err(mut stmt_err) => {\n+                Err(stmt_err) => {\n                     stmt_err.cancel();\n                     *self = start_snapshot;\n                     break;\n@@ -2653,7 +2659,7 @@ impl<'a> Parser<'a> {\n         let mut base = ast::StructRest::None;\n         let mut recover_async = false;\n \n-        let mut async_block_err = |e: &mut DiagnosticBuilder<'_>, span: Span| {\n+        let mut async_block_err = |e: &mut Diagnostic, span: Span| {\n             recover_async = true;\n             e.span_label(span, \"`async` blocks are only allowed in Rust 2018 or later\");\n             e.help(&format!(\"set `edition = \\\"{}\\\"` in `Cargo.toml`\", LATEST_STABLE_EDITION));"}, {"sha": "1b9eeab0298624efb5de6ce9d2e818715520ab92", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -130,7 +130,7 @@ impl<'a> Parser<'a> {\n                                 // FIXME - try to continue parsing other generics?\n                                 return Ok((None, TrailingToken::None));\n                             }\n-                            Err(mut err) => {\n+                            Err(err) => {\n                                 err.cancel();\n                                 // FIXME - maybe we should overwrite 'self' outside of `collect_tokens`?\n                                 *this = snapshot;"}, {"sha": "bd349e89482efbe6e52b875c0ff32f04e8fc3385", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::{EnumDef, FieldDef, Generics, TraitRef, Ty, TyKind, Variant, Vari\n use rustc_ast::{FnHeader, ForeignItem, Path, PathSegment, Visibility, VisibilityKind};\n use rustc_ast::{MacArgs, MacCall, MacDelimiter};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability, PResult, StashKey};\n+use rustc_errors::{struct_span_err, Applicability, ErrorReported, PResult, StashKey};\n use rustc_span::edition::{Edition, LATEST_STABLE_EDITION};\n use rustc_span::lev_distance::lev_distance;\n use rustc_span::source_map::{self, Span};\n@@ -801,7 +801,7 @@ impl<'a> Parser<'a> {\n         before_where_clause_span: Span,\n         after_predicates: &[WherePredicate],\n         after_where_clause_span: Span,\n-    ) {\n+    ) -> ErrorReported {\n         let mut err =\n             self.struct_span_err(after_where_clause_span, \"where clause not allowed here\");\n         if !after_predicates.is_empty() {\n@@ -1114,7 +1114,7 @@ impl<'a> Parser<'a> {\n         // Only try to recover if this is implementing a trait for a type\n         let mut impl_info = match self.parse_item_impl(attrs, defaultness) {\n             Ok(impl_info) => impl_info,\n-            Err(mut recovery_error) => {\n+            Err(recovery_error) => {\n                 // Recovery failed, raise the \"expected identifier\" error\n                 recovery_error.cancel();\n                 return Err(err);\n@@ -1476,7 +1476,9 @@ impl<'a> Parser<'a> {\n                             // after the comma\n                             self.eat(&token::Comma);\n                             // `check_trailing_angle_brackets` already emitted a nicer error\n-                            err.cancel();\n+                            // NOTE(eddyb) this was `.cancel()`, but `err`\n+                            // gets returned, so we can't fully defuse it.\n+                            err.downgrade_to_delayed_bug();\n                         }\n                     }\n                 }\n@@ -2073,7 +2075,7 @@ impl<'a> Parser<'a> {\n                         if let Ok(snippet) = self.span_to_snippet(sp) {\n                             let current_vis = match self.parse_visibility(FollowedByType::No) {\n                                 Ok(v) => v,\n-                                Err(mut d) => {\n+                                Err(d) => {\n                                     d.cancel();\n                                     return Err(err);\n                                 }\n@@ -2216,7 +2218,7 @@ impl<'a> Parser<'a> {\n                     // If this is a C-variadic argument and we hit an error, return the error.\n                     Err(err) if this.token == token::DotDotDot => return Err(err),\n                     // Recover from attempting to parse the argument as a type without pattern.\n-                    Err(mut err) => {\n+                    Err(err) => {\n                         err.cancel();\n                         *this = parser_snapshot_before_ty;\n                         this.recover_arg_parse()?\n@@ -2358,7 +2360,7 @@ impl<'a> Parser<'a> {\n         match self\n             .parse_outer_attributes()\n             .and_then(|_| self.parse_self_param())\n-            .map_err(|mut e| e.cancel())\n+            .map_err(|e| e.cancel())\n         {\n             Ok(Some(_)) => \"method\",\n             _ => \"function\","}, {"sha": "d8e6d5037bbd81d79cef0501809b02ac7b89b3aa", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -32,7 +32,7 @@ use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::PResult;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, FatalError};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported, FatalError};\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{MultiSpan, Span, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -849,7 +849,7 @@ impl<'a> Parser<'a> {\n                                     v.push(t);\n                                     continue;\n                                 }\n-                                Err(mut e) => {\n+                                Err(e) => {\n                                     // Parsing failed, therefore it must be something more serious\n                                     // than just a missing separator.\n                                     expect_err.emit();\n@@ -877,7 +877,7 @@ impl<'a> Parser<'a> {\n     fn recover_missing_braces_around_closure_body(\n         &mut self,\n         closure_spans: ClosureSpans,\n-        mut expect_err: DiagnosticBuilder<'_>,\n+        mut expect_err: DiagnosticBuilder<'_, ErrorReported>,\n     ) -> PResult<'a, ()> {\n         let initial_semicolon = self.token.span;\n \n@@ -1429,7 +1429,7 @@ impl<'a> Parser<'a> {\n crate fn make_unclosed_delims_error(\n     unmatched: UnmatchedBrace,\n     sess: &ParseSess,\n-) -> Option<DiagnosticBuilder<'_>> {\n+) -> Option<DiagnosticBuilder<'_, ErrorReported>> {\n     // `None` here means an `Eof` was found. We already emit those errors elsewhere, we add them to\n     // `unmatched_braces` only for error recovery in the `Parser`.\n     let found_delim = unmatched.found_delim?;"}, {"sha": "d41298711459f961c167b73252ad9dd777365389", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::{\n     PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n };\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, PResult};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported, PResult};\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n \n@@ -655,7 +655,7 @@ impl<'a> Parser<'a> {\n \n     fn fatal_unexpected_non_pat(\n         &mut self,\n-        mut err: DiagnosticBuilder<'a>,\n+        err: DiagnosticBuilder<'a, ErrorReported>,\n         expected: Expected,\n     ) -> PResult<'a, P<Pat>> {\n         err.cancel();\n@@ -722,7 +722,7 @@ impl<'a> Parser<'a> {\n             // Ensure the user doesn't receive unhelpful unexpected token errors\n             self.bump();\n             if self.is_pat_range_end_start(0) {\n-                let _ = self.parse_pat_range_end().map_err(|mut e| e.cancel());\n+                let _ = self.parse_pat_range_end().map_err(|e| e.cancel());\n             }\n \n             self.error_inclusive_range_with_extra_equals(span_with_eq);\n@@ -886,7 +886,7 @@ impl<'a> Parser<'a> {\n         let mut fields = Vec::new();\n         let mut etc = false;\n         let mut ate_comma = true;\n-        let mut delayed_err: Option<DiagnosticBuilder<'a>> = None;\n+        let mut delayed_err: Option<DiagnosticBuilder<'a, ErrorReported>> = None;\n         let mut etc_span = None;\n \n         while self.token != token::CloseDelim(token::Brace) {"}, {"sha": "b5857e0597055cd7b347c9865797c8e7a7871444", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -394,7 +394,7 @@ impl<'a> Parser<'a> {\n         debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n         match self.parse_angle_args(ty_generics) {\n             Ok(args) => Ok(args),\n-            Err(mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n+            Err(e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n                 // Swap `self` with our backup of the parser state before attempting to parse\n                 // generic arguments.\n                 let snapshot = mem::replace(self, snapshot.unwrap());"}, {"sha": "6b195285243fd7a7fe9ea1d2f3693a3ff114604a", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -18,7 +18,7 @@ use rustc_ast::{\n };\n use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, Local, Stmt};\n use rustc_ast::{StmtKind, DUMMY_NODE_ID};\n-use rustc_errors::{Applicability, DiagnosticBuilder, PResult};\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorReported, PResult};\n use rustc_span::source_map::{BytePos, Span};\n use rustc_span::symbol::{kw, sym};\n \n@@ -296,7 +296,7 @@ impl<'a> Parser<'a> {\n                 // extra noise.\n                 init\n             }\n-            (Err(mut init_err), Some((snapshot, _, ty_err))) => {\n+            (Err(init_err), Some((snapshot, _, ty_err))) => {\n                 // init error, ty error\n                 init_err.cancel();\n                 // Couldn't parse the type nor the initializer, only raise the type error and\n@@ -414,7 +414,10 @@ impl<'a> Parser<'a> {\n         Ok(block)\n     }\n \n-    fn error_block_no_opening_brace_msg(&mut self, msg: &str) -> DiagnosticBuilder<'a> {\n+    fn error_block_no_opening_brace_msg(\n+        &mut self,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'a, ErrorReported> {\n         let sp = self.token.span;\n         let mut e = self.struct_span_err(sp, msg);\n         let do_not_suggest_help = self.token.is_keyword(kw::In) || self.token == token::Colon;\n@@ -449,7 +452,7 @@ impl<'a> Parser<'a> {\n                     );\n                 }\n             }\n-            Err(mut e) => {\n+            Err(e) => {\n                 self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n                 e.cancel();\n             }"}, {"sha": "0b01f9e927f33e77d520e8e8a40fd554e5d5bc44", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -345,7 +345,8 @@ impl<'a> Parser<'a> {\n         let lt_no_plus = self.check_lifetime() && !self.look_ahead(1, |t| t.is_like_plus());\n         let bounds = self.parse_generic_bounds_common(allow_plus, None)?;\n         if lt_no_plus {\n-            self.struct_span_err(lo, \"lifetime in trait object type must be followed by `+`\").emit()\n+            self.struct_span_err(lo, \"lifetime in trait object type must be followed by `+`\")\n+                .emit();\n         }\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }"}, {"sha": "68efbbb74c300c6385e06edc243170cca683d78e", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -2095,7 +2095,7 @@ fn check_invalid_crate_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n                             rustc_errors::Applicability::MachineApplicable,\n                         );\n                     }\n-                    err.emit()\n+                    err.emit();\n                 }\n             }\n         }"}, {"sha": "0fdbdb7b08d0083b80f7a31ac9fb0f160a6266e4", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -219,7 +219,9 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n             required_gates.iter().copied().filter(|&g| !features.enabled(g)).collect();\n \n         match missing_gates.as_slice() {\n-            [] => struct_span_err!(tcx.sess, span, E0744, \"{}\", msg).emit(),\n+            [] => {\n+                struct_span_err!(tcx.sess, span, E0744, \"{}\", msg).emit();\n+            }\n \n             [missing_primary, ref missing_secondary @ ..] => {\n                 let mut err = feature_err(&tcx.sess.parse_sess, *missing_primary, span, &msg);"}, {"sha": "b2129ce9f24fc63a149cea3798e4cf194f2de907", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -118,7 +118,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n             err.note(&format!(\"source type: `{}` ({})\", from, skeleton_string(from, sk_from)))\n                 .note(&format!(\"target type: `{}` ({})\", to, skeleton_string(to, sk_to)));\n         }\n-        err.emit()\n+        err.emit();\n     }\n \n     fn is_thin_ptr_ty(&self, ty: Ty<'tcx>) -> bool {"}, {"sha": "91b6ea038350793eec9d0635820a3243e4458167", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -7,7 +7,7 @@ use crate::query::caches::QueryCache;\n use crate::query::{QueryCacheStore, QueryContext, QueryState};\n \n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::{DiagnosticBuilder, ErrorReported};\n use std::fmt::Debug;\n use std::hash::Hash;\n \n@@ -27,7 +27,7 @@ pub struct QueryVtable<CTX: QueryContext, K, V> {\n \n     pub compute: fn(CTX::DepContext, K) -> V,\n     pub hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n-    pub handle_cycle_error: fn(CTX, DiagnosticBuilder<'_>) -> V,\n+    pub handle_cycle_error: fn(CTX, DiagnosticBuilder<'_, ErrorReported>) -> V,\n     pub try_load_from_disk: Option<fn(CTX, SerializedDepNodeIndex) -> Option<V>>,\n }\n "}, {"sha": "260fc3bff4471968ea5314aaee61d1cd120990c4", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -4,7 +4,7 @@ use crate::query::{QueryContext, QueryStackFrame};\n use rustc_hir::def::DefKind;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, Handler, Level};\n+use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, ErrorReported, Handler, Level};\n use rustc_session::Session;\n use rustc_span::Span;\n \n@@ -530,7 +530,7 @@ pub fn deadlock<CTX: QueryContext>(tcx: CTX, registry: &rayon_core::Registry) {\n pub(crate) fn report_cycle<'a>(\n     sess: &'a Session,\n     CycleError { usage, cycle: stack }: CycleError,\n-) -> DiagnosticBuilder<'a> {\n+) -> DiagnosticBuilder<'a, ErrorReported> {\n     assert!(!stack.is_empty());\n \n     let fix_span = |span: Span, query: &QueryStackFrame| {"}, {"sha": "23df0d4dcd439b81fa203fc144d56ec8a5a5bc29", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::sharded::{get_shard_index_by_hash, Sharded};\n use rustc_data_structures::sync::{Lock, LockGuard};\n use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::{DiagnosticBuilder, FatalError};\n+use rustc_errors::{DiagnosticBuilder, ErrorReported, FatalError};\n use rustc_session::Session;\n use rustc_span::{Span, DUMMY_SP};\n use std::cell::Cell;\n@@ -143,7 +143,7 @@ where\n fn mk_cycle<CTX, V, R>(\n     tcx: CTX,\n     error: CycleError,\n-    handle_cycle_error: fn(CTX, DiagnosticBuilder<'_>) -> V,\n+    handle_cycle_error: fn(CTX, DiagnosticBuilder<'_, ErrorReported>) -> V,\n     cache: &dyn crate::query::QueryStorage<Value = V, Stored = R>,\n ) -> R\n where"}, {"sha": "2c3ddae9cb4bb38d43f69cdab2b965359f5ac308", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1070,8 +1070,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                             .emit();\n                     }\n                 }\n-                let ill_formed =\n-                    |span| struct_span_err!(self.r.session, span, E0466, \"bad macro import\").emit();\n+                let ill_formed = |span| {\n+                    struct_span_err!(self.r.session, span, E0466, \"bad macro import\").emit();\n+                };\n                 match attr.meta() {\n                     Some(meta) => match meta.kind {\n                         MetaItemKind::Word => {"}, {"sha": "b366473cb30c08c4d312ecc0b508078ac93d775b", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -3,7 +3,7 @@ use std::ptr;\n use rustc_ast::{self as ast, Path};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind};\n@@ -110,7 +110,7 @@ impl<'a> Resolver<'a> {\n         &self,\n         span: Span,\n         resolution_error: ResolutionError<'_>,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         match resolution_error {\n             ResolutionError::GenericParamsFromOuterFunction(outer_res, has_generic_params) => {\n                 let mut err = struct_span_err!(\n@@ -624,7 +624,10 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn report_vis_error(&self, vis_resolution_error: VisResolutionError<'_>) {\n+    crate fn report_vis_error(\n+        &self,\n+        vis_resolution_error: VisResolutionError<'_>,\n+    ) -> ErrorReported {\n         match vis_resolution_error {\n             VisResolutionError::Relative2018(span, path) => {\n                 let mut err = self.session.struct_span_err(\n@@ -1031,7 +1034,7 @@ impl<'a> Resolver<'a> {\n \n     crate fn unresolved_macro_suggestions(\n         &mut self,\n-        err: &mut DiagnosticBuilder<'a>,\n+        err: &mut Diagnostic,\n         macro_kind: MacroKind,\n         parent_scope: &ParentScope<'a>,\n         ident: Ident,\n@@ -1120,7 +1123,7 @@ impl<'a> Resolver<'a> {\n \n     crate fn add_typo_suggestion(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         suggestion: Option<TypoSuggestion>,\n         span: Span,\n     ) -> bool {\n@@ -1817,7 +1820,7 @@ fn find_span_immediately_after_crate_name(\n crate fn show_candidates(\n     definitions: &rustc_hir::definitions::Definitions,\n     session: &Session,\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     // This is `None` if all placement locations are inside expansions\n     use_placement_span: Option<Span>,\n     candidates: &[ImportSuggestion],"}, {"sha": "91695257137cb3811b6bd5edfa83358de854e422", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -2001,13 +2001,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // into a single one.\n             let mut parent_err = this.r.into_struct_error(parent_err.span, parent_err.node);\n \n-            parent_err.cancel();\n-\n             err.message = take(&mut parent_err.message);\n             err.code = take(&mut parent_err.code);\n             err.children = take(&mut parent_err.children);\n \n-            drop(parent_err);\n+            parent_err.cancel();\n \n             let def_id = this.parent_scope.module.nearest_parent_mod();\n "}, {"sha": "b71776c161531ec270f9afe3a3cadd6d2297cfa4", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -12,7 +12,9 @@ use rustc_ast::{\n };\n use rustc_ast_pretty::pprust::path_segment_to_string;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{\n+    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorReported,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n@@ -133,7 +135,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         span: Span,\n         source: PathSource<'_>,\n         res: Option<Res>,\n-    ) -> (DiagnosticBuilder<'a>, Vec<ImportSuggestion>) {\n+    ) -> (DiagnosticBuilder<'a, ErrorReported>, Vec<ImportSuggestion>) {\n         let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n         let ns = source.namespace();\n         let is_expected = &|res| source.is_expected(res);\n@@ -606,11 +608,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         (err, candidates)\n     }\n \n-    fn detect_assoct_type_constraint_meant_as_path(\n-        &self,\n-        base_span: Span,\n-        err: &mut DiagnosticBuilder<'_>,\n-    ) {\n+    fn detect_assoct_type_constraint_meant_as_path(&self, base_span: Span, err: &mut Diagnostic) {\n         let Some(ty) = self.diagnostic_metadata.current_type_path else { return; };\n         let TyKind::Path(_, path) = &ty.kind else { return; };\n         for segment in &path.segments {\n@@ -675,11 +673,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     }\n \n     /// Given `where <T as Bar>::Baz: String`, suggest `where T: Bar<Baz = String>`.\n-    fn restrict_assoc_type_in_where_clause(\n-        &mut self,\n-        span: Span,\n-        err: &mut DiagnosticBuilder<'_>,\n-    ) -> bool {\n+    fn restrict_assoc_type_in_where_clause(&mut self, span: Span, err: &mut Diagnostic) -> bool {\n         // Detect that we are actually in a `where` predicate.\n         let (bounded_ty, bounds, where_span) =\n             if let Some(ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n@@ -875,7 +869,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     /// Returns `true` if able to provide context-dependent help.\n     fn smart_resolve_context_dependent_help(\n         &mut self,\n-        err: &mut DiagnosticBuilder<'a>,\n+        err: &mut Diagnostic,\n         span: Span,\n         source: PathSource<'_>,\n         res: Res,\n@@ -885,7 +879,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         let ns = source.namespace();\n         let is_expected = &|res| source.is_expected(res);\n \n-        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.kind {\n+        let path_sep = |err: &mut Diagnostic, expr: &Expr| match expr.kind {\n             ExprKind::Field(_, ident) => {\n                 err.span_suggestion(\n                     expr.span,\n@@ -908,7 +902,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             _ => false,\n         };\n \n-        let find_span = |source: &PathSource<'_>, err: &mut DiagnosticBuilder<'_>| {\n+        let find_span = |source: &PathSource<'_>, err: &mut Diagnostic| {\n             match source {\n                 PathSource::Expr(Some(Expr { span, kind: ExprKind::Call(_, _), .. }))\n                 | PathSource::TupleStruct(span, _) => {\n@@ -1066,7 +1060,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     })\n                     .unwrap_or(false)\n                 {\n-                    err.delay_as_bug();\n+                    err.downgrade_to_delayed_bug();\n                     // We already suggested changing `:` into `::` during parsing.\n                     return false;\n                 }\n@@ -1435,7 +1429,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         start.to(sm.next_point(start))\n     }\n \n-    fn type_ascription_suggestion(&self, err: &mut DiagnosticBuilder<'_>, base_span: Span) -> bool {\n+    fn type_ascription_suggestion(&self, err: &mut Diagnostic, base_span: Span) -> bool {\n         let sm = self.r.session.source_map();\n         let base_snippet = sm.span_to_snippet(base_span);\n         if let Some(&sp) = self.diagnostic_metadata.current_type_ascription.last() {\n@@ -1472,7 +1466,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                                 .borrow_mut()\n                                 .insert(colon_sp)\n                             {\n-                                err.delay_as_bug();\n+                                err.downgrade_to_delayed_bug();\n                             }\n                         }\n                         if let Ok(base_snippet) = base_snippet {\n@@ -1577,7 +1571,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     /// Adds a suggestion for using an enum's variant when an enum is used instead.\n     fn suggest_using_enum_variant(\n         &mut self,\n-        err: &mut DiagnosticBuilder<'a>,\n+        err: &mut Diagnostic,\n         source: PathSource<'_>,\n         def_id: DefId,\n         span: Span,\n@@ -1825,7 +1819,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         &self,\n         spans: Vec<Span>,\n         count: usize,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         struct_span_err!(\n             self.tcx.sess,\n             spans,\n@@ -1910,7 +1904,8 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n     /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n     crate fn report_elision_failure(\n         &mut self,\n-        db: &mut DiagnosticBuilder<'_>,\n+        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n+        db: &mut Diagnostic,\n         params: &[ElisionFailureInfo],\n     ) -> bool {\n         let mut m = String::new();\n@@ -2059,7 +2054,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n \n     crate fn add_missing_lifetime_specifiers_label(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         mut spans_with_counts: Vec<(Span, usize)>,\n         lifetime_names: &FxHashSet<Symbol>,\n         lifetime_spans: Vec<Span>,\n@@ -2090,7 +2085,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         }\n \n         let suggest_existing =\n-            |err: &mut DiagnosticBuilder<'_>,\n+            |err: &mut Diagnostic,\n              name: &str,\n              formatters: Vec<Option<Box<dyn Fn(&str) -> String>>>| {\n                 if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n@@ -2174,7 +2169,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                     Applicability::MaybeIncorrect,\n                 );\n             };\n-        let suggest_new = |err: &mut DiagnosticBuilder<'_>, suggs: Vec<Option<String>>| {\n+        let suggest_new = |err: &mut Diagnostic, suggs: Vec<Option<String>>| {\n             for missing in self.missing_named_lifetime_spots.iter().rev() {\n                 let mut introduce_suggestion = vec![];\n                 let msg;"}, {"sha": "23a8189f62fd83c3e53578623317b71784eb0703", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -9,7 +9,7 @@\n use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n use rustc_ast::walk_list;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n@@ -1572,6 +1572,7 @@ fn signal_shadowing_problem(tcx: TyCtxt<'_>, name: Symbol, orig: Original, shado\n             name,\n             orig.kind.desc()\n         )\n+        .forget_guarantee()\n     } else {\n         // shadowing involving a label is only a warning, due to issues with\n         // labels and lifetimes not being macro-hygienic.\n@@ -1873,7 +1874,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     // or from `fn rah<'a>(T<'a>)` to `fn rah(T<'_>)`\n     fn suggest_eliding_single_use_lifetime(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         def_id: DefId,\n         lifetime: &hir::Lifetime,\n     ) {"}, {"sha": "4823b889207f145e42626716e89285bb879c5a6d", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -40,7 +40,7 @@ use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n@@ -713,7 +713,7 @@ struct PrivacyError<'a> {\n }\n \n struct UseError<'a> {\n-    err: DiagnosticBuilder<'a>,\n+    err: DiagnosticBuilder<'a, ErrorReported>,\n     /// Candidates which user could `use` to access the missing type.\n     candidates: Vec<ImportSuggestion>,\n     /// The `DefId` of the module to place the use-statements in.\n@@ -3173,7 +3173,7 @@ impl<'a> Resolver<'a> {\n     /// ```\n     fn add_suggestion_for_rename_of_use(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         name: Symbol,\n         import: &Import<'_>,\n         binding_span: Span,\n@@ -3252,7 +3252,7 @@ impl<'a> Resolver<'a> {\n     /// as characters expected by span manipulations won't be present.\n     fn add_suggestion_for_duplicate_nested_use(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         import: &Import<'_>,\n         binding_span: Span,\n     ) {"}, {"sha": "e287764a52abcc4aaf64420c3df1beac2c419168", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::node_id::NodeId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n-use rustc_errors::{error_code, Applicability, DiagnosticBuilder};\n+use rustc_errors::{error_code, Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_feature::{find_feature_issue, GateIssue, UnstableFeatures};\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::ExpnId;\n@@ -82,7 +82,7 @@ pub fn feature_err<'a>(\n     feature: Symbol,\n     span: impl Into<MultiSpan>,\n     explain: &str,\n-) -> DiagnosticBuilder<'a> {\n+) -> DiagnosticBuilder<'a, ErrorReported> {\n     feature_err_issue(sess, feature, span, GateIssue::Language, explain)\n }\n \n@@ -96,7 +96,7 @@ pub fn feature_err_issue<'a>(\n     span: impl Into<MultiSpan>,\n     issue: GateIssue,\n     explain: &str,\n-) -> DiagnosticBuilder<'a> {\n+) -> DiagnosticBuilder<'a, ErrorReported> {\n     let mut err = sess.span_diagnostic.struct_span_err_with_code(span, explain, error_code!(E0658));\n \n     if let Some(n) = find_feature_issue(feature, issue) {\n@@ -243,7 +243,7 @@ impl ParseSess {\n \n     /// Extend an error with a suggestion to wrap an expression with parentheses to allow the\n     /// parser to continue parsing the following operation as part of the same expression.\n-    pub fn expr_parentheses_needed(&self, err: &mut DiagnosticBuilder<'_>, span: Span) {\n+    pub fn expr_parentheses_needed(&self, err: &mut Diagnostic, span: Span) {\n         err.multipart_suggestion(\n             \"parentheses are required to parse this as an expression\",\n             vec![(span.shrink_to_lo(), \"(\".to_string()), (span.shrink_to_hi(), \")\".to_string())],"}, {"sha": "b72be735ce485088b1992b4dbd2b84dfb4c5c9df", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -19,7 +19,7 @@ use rustc_errors::annotate_snippet_emitter_writer::AnnotateSnippetEmitterWriter;\n use rustc_errors::emitter::{Emitter, EmitterWriter, HumanReadableErrorType};\n use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n-use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorReported};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n use rustc_span::edition::Edition;\n@@ -221,7 +221,7 @@ enum DiagnosticBuilderMethod {\n pub trait SessionDiagnostic<'a> {\n     /// Write out as a diagnostic out of `sess`.\n     #[must_use]\n-    fn into_diagnostic(self, sess: &'a Session) -> DiagnosticBuilder<'a>;\n+    fn into_diagnostic(self, sess: &'a Session) -> DiagnosticBuilder<'a, ErrorReported>;\n }\n \n /// Diagnostic message ID, used by `Session.one_time_diagnostics` to avoid\n@@ -303,66 +303,76 @@ impl Session {\n         self.crate_types.set(crate_types).expect(\"`crate_types` was initialized twice\")\n     }\n \n-    pub fn struct_span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'_> {\n-        self.diagnostic().struct_span_warn(sp, msg)\n-    }\n-    pub fn struct_span_force_warn<S: Into<MultiSpan>>(\n+    pub fn struct_span_warn<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: &str,\n-    ) -> DiagnosticBuilder<'_> {\n-        self.diagnostic().struct_span_force_warn(sp, msg)\n+    ) -> DiagnosticBuilder<'_, ()> {\n+        self.diagnostic().struct_span_warn(sp, msg)\n     }\n     pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_warn_with_code(sp, msg, code)\n     }\n-    pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_warn(msg)\n     }\n-    pub fn struct_force_warn(&self, msg: &str) -> DiagnosticBuilder<'_> {\n-        self.diagnostic().struct_force_warn(msg)\n-    }\n-    pub fn struct_span_allow<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_span_allow<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_allow(sp, msg)\n     }\n-    pub fn struct_allow(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_allow(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_allow(msg)\n     }\n-    pub fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_span_err<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         self.diagnostic().struct_span_err(sp, msg)\n     }\n     pub fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         self.diagnostic().struct_span_err_with_code(sp, msg, code)\n     }\n     // FIXME: This method should be removed (every error should have an associated error code).\n-    pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_, ErrorReported> {\n         self.diagnostic().struct_err(msg)\n     }\n-    pub fn struct_err_with_code(&self, msg: &str, code: DiagnosticId) -> DiagnosticBuilder<'_> {\n+    pub fn struct_err_with_code(\n+        &self,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         self.diagnostic().struct_err_with_code(msg, code)\n     }\n-    pub fn struct_span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_span_fatal<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         self.diagnostic().struct_span_fatal(sp, msg)\n     }\n     pub fn struct_span_fatal_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         self.diagnostic().struct_span_fatal_with_code(sp, msg, code)\n     }\n-    pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_, ErrorReported> {\n         self.diagnostic().struct_fatal(msg)\n     }\n \n@@ -396,7 +406,7 @@ impl Session {\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().err(msg)\n     }\n-    pub fn emit_err<'a>(&'a self, err: impl SessionDiagnostic<'a>) {\n+    pub fn emit_err<'a>(&'a self, err: impl SessionDiagnostic<'a>) -> ErrorReported {\n         err.into_diagnostic(self).emit()\n     }\n     #[inline]\n@@ -467,7 +477,7 @@ impl Session {\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n-    pub fn struct_note_without_error(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+    pub fn struct_note_without_error(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_note_without_error(msg)\n     }\n \n@@ -478,9 +488,9 @@ impl Session {\n \n     /// Analogous to calling methods on the given `DiagnosticBuilder`, but\n     /// deduplicates on lint ID, span (if any), and message for this `Session`\n-    fn diag_once<'a, 'b>(\n-        &'a self,\n-        diag_builder: &'b mut DiagnosticBuilder<'a>,\n+    fn diag_once(\n+        &self,\n+        diag: &mut Diagnostic,\n         method: DiagnosticBuilderMethod,\n         msg_id: DiagnosticMessageId,\n         message: &str,\n@@ -491,39 +501,33 @@ impl Session {\n         if fresh {\n             match method {\n                 DiagnosticBuilderMethod::Note => {\n-                    diag_builder.note(message);\n+                    diag.note(message);\n                 }\n                 DiagnosticBuilderMethod::SpanNote => {\n                     let span = span_maybe.expect(\"`span_note` needs a span\");\n-                    diag_builder.span_note(span, message);\n+                    diag.span_note(span, message);\n                 }\n             }\n         }\n     }\n \n-    pub fn diag_span_note_once<'a, 'b>(\n-        &'a self,\n-        diag_builder: &'b mut DiagnosticBuilder<'a>,\n+    pub fn diag_span_note_once(\n+        &self,\n+        diag: &mut Diagnostic,\n         msg_id: DiagnosticMessageId,\n         span: Span,\n         message: &str,\n     ) {\n-        self.diag_once(\n-            diag_builder,\n-            DiagnosticBuilderMethod::SpanNote,\n-            msg_id,\n-            message,\n-            Some(span),\n-        );\n+        self.diag_once(diag, DiagnosticBuilderMethod::SpanNote, msg_id, message, Some(span));\n     }\n \n-    pub fn diag_note_once<'a, 'b>(\n-        &'a self,\n-        diag_builder: &'b mut DiagnosticBuilder<'a>,\n+    pub fn diag_note_once(\n+        &self,\n+        diag: &mut Diagnostic,\n         msg_id: DiagnosticMessageId,\n         message: &str,\n     ) {\n-        self.diag_once(diag_builder, DiagnosticBuilderMethod::Note, msg_id, message, None);\n+        self.diag_once(diag, DiagnosticBuilderMethod::Note, msg_id, message, None);\n     }\n \n     #[inline]"}, {"sha": "0f6997054b9e065ae391646dacb296c02caa3d8a", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -14,6 +14,7 @@ use crate::traits::{\n     PredicateObligations, SelectionContext,\n };\n //use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::CRATE_HIR_ID;\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -50,7 +51,7 @@ pub struct OverlapResult<'tcx> {\n     pub involves_placeholder: bool,\n }\n \n-pub fn add_placeholder_note(err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n+pub fn add_placeholder_note(err: &mut Diagnostic) {\n     err.note(\n         \"this behavior recently changed as a result of a bug fix; \\\n          see rust-lang/rust#56105 for details\","}, {"sha": "f26f32aabda1d0dfdd434280856f0545111ec183", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 22, "deletions": 39, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -12,7 +12,9 @@ use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCod\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n+use rustc_errors::{\n+    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorReported,\n+};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n@@ -100,7 +102,7 @@ pub trait InferCtxtExt<'tcx> {\n         expected_args: Vec<ArgKind>,\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n-    ) -> DiagnosticBuilder<'tcx>;\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported>;\n }\n \n impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n@@ -1017,7 +1019,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         expected_args: Vec<ArgKind>,\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let kind = if is_closure { \"closure\" } else { \"function\" };\n \n         let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n@@ -1174,7 +1176,7 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n     fn report_similar_impl_candidates(\n         &self,\n         impl_candidates: Vec<ImplCandidate<'tcx>>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n     );\n \n     /// Gets the parent trait chain start\n@@ -1186,11 +1188,7 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n     /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n     /// with the same path as `trait_ref`, a help message about\n     /// a probable version mismatch is added to `err`\n-    fn note_version_mismatch(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::PolyTraitRef<'tcx>,\n-    );\n+    fn note_version_mismatch(&self, err: &mut Diagnostic, trait_ref: &ty::PolyTraitRef<'tcx>);\n \n     /// Creates a `PredicateObligation` with `new_self_ty` replacing the existing type in the\n     /// `trait_ref`.\n@@ -1215,35 +1213,26 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n         pred: ty::PolyTraitRef<'tcx>,\n     ) -> bool;\n \n-    fn note_obligation_cause(\n-        &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n-        obligation: &PredicateObligation<'tcx>,\n-    );\n+    fn note_obligation_cause(&self, err: &mut Diagnostic, obligation: &PredicateObligation<'tcx>);\n \n     fn suggest_unsized_bound_if_applicable(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n     fn annotate_source_of_ambiguity(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         impls: &[DefId],\n         predicate: ty::Predicate<'tcx>,\n     );\n \n-    fn maybe_suggest_unsized_generics(\n-        &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n-        span: Span,\n-        node: Node<'hir>,\n-    );\n+    fn maybe_suggest_unsized_generics(&self, err: &mut Diagnostic, span: Span, node: Node<'hir>);\n \n     fn maybe_indirection_for_unsized(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         item: &'hir Item<'hir>,\n         param: &'hir GenericParam<'hir>,\n     ) -> bool;\n@@ -1572,7 +1561,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_similar_impl_candidates(\n         &self,\n         impl_candidates: Vec<ImplCandidate<'tcx>>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n     ) {\n         if impl_candidates.is_empty() {\n             return;\n@@ -1649,11 +1638,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n     /// with the same path as `trait_ref`, a help message about\n     /// a probable version mismatch is added to `err`\n-    fn note_version_mismatch(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::PolyTraitRef<'tcx>,\n-    ) {\n+    fn note_version_mismatch(&self, err: &mut Diagnostic, trait_ref: &ty::PolyTraitRef<'tcx>) {\n         let get_trait_impl = |trait_def_id| {\n             self.tcx.find_map_relevant_impl(trait_def_id, trait_ref.skip_binder().self_ty(), Some)\n         };\n@@ -1944,7 +1929,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn annotate_source_of_ambiguity(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         impls: &[DefId],\n         predicate: ty::Predicate<'tcx>,\n     ) {\n@@ -1977,7 +1962,9 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             // Avoid complaining about other inference issues for expressions like\n             // `42 >> 1`, where the types are still `{integer}`, but we want to\n             // Do we need `trait_ref.skip_binder().self_ty().is_numeric() &&` too?\n-            err.cancel();\n+            // NOTE(eddyb) this was `.cancel()`, but `err`\n+            // is borrowed, so we can't fully defuse it.\n+            err.downgrade_to_delayed_bug();\n             return;\n         }\n         let post = if post.len() > 4 {\n@@ -2088,11 +2075,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         })\n     }\n \n-    fn note_obligation_cause(\n-        &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n-        obligation: &PredicateObligation<'tcx>,\n-    ) {\n+    fn note_obligation_cause(&self, err: &mut Diagnostic, obligation: &PredicateObligation<'tcx>) {\n         // First, attempt to add note to this error with an async-await-specific\n         // message, and fall back to regular note otherwise.\n         if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n@@ -2110,7 +2093,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn suggest_unsized_bound_if_applicable(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         let (pred, item_def_id, span) = match (\n@@ -2139,7 +2122,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn maybe_suggest_unsized_generics<'hir>(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         span: Span,\n         node: Node<'hir>,\n     ) {\n@@ -2206,7 +2189,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn maybe_indirection_for_unsized<'hir>(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         item: &'hir Item<'hir>,\n         param: &'hir GenericParam<'hir>,\n     ) -> bool {"}, {"sha": "c4fbd25b8338bd523406959034215ca08f53f550", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 55, "deletions": 71, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -10,7 +10,8 @@ use crate::traits::normalize_projection_type;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n-    error_code, pluralize, struct_span_err, Applicability, DiagnosticBuilder, Style,\n+    error_code, pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder,\n+    ErrorReported, Style,\n };\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n@@ -47,64 +48,55 @@ pub enum GeneratorInteriorOrUpvar {\n pub trait InferCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         body_id: hir::HirId,\n     );\n \n     fn suggest_dereferences(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n-    fn get_closure_name(\n-        &self,\n-        def_id: DefId,\n-        err: &mut DiagnosticBuilder<'_>,\n-        msg: &str,\n-    ) -> Option<String>;\n+    fn get_closure_name(&self, def_id: DefId, err: &mut Diagnostic, msg: &str) -> Option<String>;\n \n     fn suggest_fn_call(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         has_custom_message: bool,\n     ) -> bool;\n \n     fn suggest_remove_reference(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n-    fn suggest_remove_await(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n-    );\n+    fn suggest_remove_await(&self, obligation: &PredicateObligation<'tcx>, err: &mut Diagnostic);\n \n     fn suggest_change_mut(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         span: Span,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n@@ -113,15 +105,15 @@ pub trait InferCtxtExt<'tcx> {\n \n     fn suggest_impl_trait(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n \n     fn point_at_returns_when_relevant(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n@@ -131,25 +123,25 @@ pub trait InferCtxtExt<'tcx> {\n         found_span: Option<Span>,\n         expected_ref: ty::PolyTraitRef<'tcx>,\n         found: ty::PolyTraitRef<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx>;\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported>;\n \n     fn suggest_fully_qualified_path(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         def_id: DefId,\n         span: Span,\n         trait_ref: DefId,\n     );\n \n     fn maybe_note_obligation_cause_for_async_await(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> bool;\n \n     fn note_obligation_cause_for_async_await(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         interior_or_upvar_span: GeneratorInteriorOrUpvar,\n         interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         inner_generator_body: Option<&hir::Body<'tcx>>,\n@@ -163,7 +155,7 @@ pub trait InferCtxtExt<'tcx> {\n \n     fn note_obligation_cause_code<T>(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         predicate: &T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n@@ -172,12 +164,12 @@ pub trait InferCtxtExt<'tcx> {\n     ) where\n         T: fmt::Display;\n \n-    fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>);\n+    fn suggest_new_overflow_limit(&self, err: &mut Diagnostic);\n \n     /// Suggest to await before try: future? => future.await?\n     fn suggest_await_before_try(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         span: Span,\n@@ -202,7 +194,7 @@ fn suggest_restriction<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     generics: &hir::Generics<'tcx>,\n     msg: &str,\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     fn_sig: Option<&hir::FnSig<'_>>,\n     projection: Option<&ty::ProjectionTy<'_>>,\n     trait_pred: ty::PolyTraitPredicate<'tcx>,\n@@ -329,7 +321,7 @@ fn suggest_restriction<'tcx>(\n impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n-        mut err: &mut DiagnosticBuilder<'_>,\n+        mut err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         body_id: hir::HirId,\n     ) {\n@@ -493,7 +485,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_dereferences(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         // It only make sense when suggesting dereferences for arguments\n@@ -549,26 +541,20 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// Given a closure's `DefId`, return the given name of the closure.\n     ///\n     /// This doesn't account for reassignments, but it's only used for suggestions.\n-    fn get_closure_name(\n-        &self,\n-        def_id: DefId,\n-        err: &mut DiagnosticBuilder<'_>,\n-        msg: &str,\n-    ) -> Option<String> {\n-        let get_name =\n-            |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind<'_>| -> Option<String> {\n-                // Get the local name of this closure. This can be inaccurate because\n-                // of the possibility of reassignment, but this should be good enough.\n-                match &kind {\n-                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n-                        Some(format!(\"{}\", name))\n-                    }\n-                    _ => {\n-                        err.note(&msg);\n-                        None\n-                    }\n+    fn get_closure_name(&self, def_id: DefId, err: &mut Diagnostic, msg: &str) -> Option<String> {\n+        let get_name = |err: &mut Diagnostic, kind: &hir::PatKind<'_>| -> Option<String> {\n+            // Get the local name of this closure. This can be inaccurate because\n+            // of the possibility of reassignment, but this should be good enough.\n+            match &kind {\n+                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n+                    Some(format!(\"{}\", name))\n                 }\n-            };\n+                _ => {\n+                    err.note(&msg);\n+                    None\n+                }\n+            }\n+        };\n \n         let hir = self.tcx.hir();\n         let hir_id = hir.local_def_id_to_hir_id(def_id.as_local()?);\n@@ -590,7 +576,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_fn_call(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         let self_ty = match trait_pred.self_ty().no_bound_vars() {\n@@ -683,7 +669,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         poly_trait_pred: ty::PolyTraitPredicate<'tcx>,\n         has_custom_message: bool,\n     ) -> bool {\n@@ -817,7 +803,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_remove_reference(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         let span = obligation.cause.span;\n@@ -874,11 +860,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_remove_await(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n-    ) {\n+    fn suggest_remove_await(&self, obligation: &PredicateObligation<'tcx>, err: &mut Diagnostic) {\n         let span = obligation.cause.span;\n \n         if let ObligationCauseCode::AwaitableExpr(hir_id) = obligation.cause.code().peel_derives() {\n@@ -936,7 +918,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_change_mut(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         let points_at_arg = matches!(\n@@ -1012,7 +994,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         span: Span,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n@@ -1063,7 +1045,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// emitted.\n     fn suggest_impl_trait(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n@@ -1256,7 +1238,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn point_at_returns_when_relevant(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         match obligation.cause.code().peel_derives() {\n@@ -1290,7 +1272,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         found_span: Option<Span>,\n         expected_ref: ty::PolyTraitRef<'tcx>,\n         found: ty::PolyTraitRef<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         crate fn build_fn_sig_string<'tcx>(\n             tcx: TyCtxt<'tcx>,\n             trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -1345,7 +1327,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn suggest_fully_qualified_path(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         def_id: DefId,\n         span: Span,\n         trait_ref: DefId,\n@@ -1411,7 +1393,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// Returns `true` if an async-await specific note was added to the diagnostic.\n     fn maybe_note_obligation_cause_for_async_await(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> bool {\n         debug!(\n@@ -1639,7 +1621,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// `maybe_note_obligation_cause_for_async_await`'s documentation comment.\n     fn note_obligation_cause_for_async_await(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         interior_or_upvar_span: GeneratorInteriorOrUpvar,\n         interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         inner_generator_body: Option<&hir::Body<'tcx>>,\n@@ -1896,7 +1878,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn note_obligation_cause_code<T>(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         predicate: &T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n@@ -2133,7 +2115,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_pred);\n                 let ty = parent_trait_ref.skip_binder().self_ty();\n                 if parent_trait_ref.references_error() {\n-                    err.cancel();\n+                    // NOTE(eddyb) this was `.cancel()`, but `err`\n+                    // is borrowed, so we can't fully defuse it.\n+                    err.downgrade_to_delayed_bug();\n                     return;\n                 }\n \n@@ -2412,7 +2396,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest_new_overflow_limit(&self, err: &mut Diagnostic) {\n         let suggested_limit = match self.tcx.recursion_limit() {\n             Limit(0) => Limit(2),\n             limit => limit * 2,\n@@ -2427,7 +2411,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn suggest_await_before_try(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         span: Span,\n@@ -2615,7 +2599,7 @@ impl NextTypeParamName for &[hir::GenericParam<'_>] {\n }\n \n fn suggest_trait_object_return_type_alternatives(\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     ret_ty: Span,\n     trait_obj: &str,\n     is_object_safe: bool,"}, {"sha": "8bcb1ccb5846d42586dc3168dac96015641e5b86", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -29,7 +29,7 @@ use crate::traits::project::ProjectionCacheKeyExt;\n use crate::traits::ProjectionCacheKey;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::ErrorReported;\n+use rustc_errors::{Diagnostic, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n@@ -64,7 +64,7 @@ pub enum IntercrateAmbiguityCause {\n impl IntercrateAmbiguityCause {\n     /// Emits notes when the overlap is caused by complex intercrate ambiguities.\n     /// See #23980 for details.\n-    pub fn add_intercrate_ambiguity_hint(&self, err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n+    pub fn add_intercrate_ambiguity_hint(&self, err: &mut Diagnostic) {\n         err.note(&self.intercrate_ambiguity_hint());\n     }\n "}, {"sha": "acf1c976afcd9c855703e72c6414d014f244307e", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -450,7 +450,7 @@ fn report_conflicting_impls(\n             sg.has_errored = true;\n             if overlap.with_impl.is_local() || !tcx.orphan_check_crate(()).contains(&impl_def_id) {\n                 let err = struct_span_err!(tcx.sess, impl_span, E0119, \"\");\n-                decorate(LintDiagnosticBuilder::new(err));\n+                decorate(LintDiagnosticBuilder::new(err.forget_guarantee()));\n             } else {\n                 tcx.sess.delay_span_bug(impl_span, \"impl should have failed the orphan check\");\n             }"}, {"sha": "f800e7a140297ab3003065160724531c8213eaa5", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,4 +1,4 @@\n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::Diagnostic;\n use rustc_span::Span;\n use smallvec::smallvec;\n use smallvec::SmallVec;\n@@ -43,12 +43,7 @@ impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n \n     /// Adds diagnostic labels to `diag` for the expansion path of a trait through all intermediate\n     /// trait aliases.\n-    pub fn label_with_exp_info(\n-        &self,\n-        diag: &mut DiagnosticBuilder<'_>,\n-        top_label: &str,\n-        use_desc: &str,\n-    ) {\n+    pub fn label_with_exp_info(&self, diag: &mut Diagnostic, top_label: &str, use_desc: &str) {\n         diag.span_label(self.top().1, top_label);\n         if self.path.len() > 1 {\n             for (_, sp) in self.path.iter().rev().skip(1).take(self.path.len() - 2) {"}, {"sha": "b16bf33f06abf9a209048967a01614fa37cd25ba", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -6,7 +6,7 @@ use crate::astconv::{\n use crate::errors::AssocTypeBindingNotAllowed;\n use crate::structured_errors::{GenericArgsInfo, StructuredDiagnostic, WrongNumberOfGenericArgs};\n use rustc_ast::ast::ParamKindOrd;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -49,7 +49,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         }\n \n-        let add_braces_suggestion = |arg: &GenericArg<'_>, err: &mut DiagnosticBuilder<'_>| {\n+        let add_braces_suggestion = |arg: &GenericArg<'_>, err: &mut Diagnostic| {\n             let suggestions = vec![\n                 (arg.span().shrink_to_lo(), String::from(\"{ \")),\n                 (arg.span().shrink_to_hi(), String::from(\" }\")),"}, {"sha": "efa50375c95ea01614c4c17ed8396b75465f637e", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -15,7 +15,7 @@ use crate::middle::resolve_lifetime as rl;\n use crate::require_c_abi_if_c_variadic;\n use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{struct_span_err, Applicability, ErrorReported, FatalError};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -2618,7 +2618,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         constrained_regions: FxHashSet<ty::BoundRegionKind>,\n         referenced_regions: FxHashSet<ty::BoundRegionKind>,\n-        generate_err: impl Fn(&str) -> rustc_errors::DiagnosticBuilder<'tcx>,\n+        generate_err: impl Fn(&str) -> DiagnosticBuilder<'tcx, ErrorReported>,\n     ) {\n         for br in referenced_regions.difference(&constrained_regions) {\n             let br_name = match *br {"}, {"sha": "9529e1528a8b994007974f82d54a2789a4948b5c", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,6 +1,6 @@\n use crate::check::coercion::{AsCoercionSite, CoerceMany};\n use crate::check::{Diverges, Expectation, FnCtxt, Needs};\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n@@ -132,7 +132,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &cause,\n                 Some(&arm.body),\n                 arm_ty,\n-                Some(&mut |err: &mut DiagnosticBuilder<'_>| {\n+                Some(&mut |err: &mut Diagnostic| {\n                     let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n                         Some(ret_coercion) if self.in_tail_expr => {\n                             let ret_ty = ret_coercion.borrow().expected_ty();"}, {"sha": "d5187c109e33d9f9166c2626a05d854ce735134a", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -2,7 +2,7 @@ use super::method::MethodCallee;\n use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n use crate::type_error_struct;\n \n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -277,7 +277,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// likely intention is to call the closure, suggest `(||{})()`. (#55851)\n     fn identify_bad_closure_def_and_call(\n         &self,\n-        err: &mut DiagnosticBuilder<'a>,\n+        err: &mut Diagnostic,\n         hir_id: hir::HirId,\n         callee_node: &hir::ExprKind<'_>,\n         callee_span: Span,\n@@ -304,7 +304,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// likely intention is to create an array containing tuples.\n     fn maybe_suggest_bad_array_definition(\n         &self,\n-        err: &mut DiagnosticBuilder<'a>,\n+        err: &mut Diagnostic,\n         call_expr: &'tcx hir::Expr<'tcx>,\n         callee_expr: &'tcx hir::Expr<'tcx>,\n     ) -> bool {"}, {"sha": "cd24969bf283b9de5444cd6f29635d9294766e85", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -179,7 +179,7 @@ fn make_invalid_casting_error<'a, 'tcx>(\n     expr_ty: Ty<'tcx>,\n     cast_ty: Ty<'tcx>,\n     fcx: &FnCtxt<'a, 'tcx>,\n-) -> DiagnosticBuilder<'a> {\n+) -> DiagnosticBuilder<'a, ErrorReported> {\n     type_error_struct!(\n         sess,\n         span,"}, {"sha": "7dca95ebdd613970d5f964fc6440bc45696c4cfe", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -37,14 +37,16 @@ pub fn check_wf_new(tcx: TyCtxt<'_>) {\n pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Abi) {\n     match tcx.sess.target.is_abi_supported(abi) {\n         Some(true) => (),\n-        Some(false) => struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0570,\n-            \"`{}` is not a supported ABI for the current target\",\n-            abi\n-        )\n-        .emit(),\n+        Some(false) => {\n+            struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0570,\n+                \"`{}` is not a supported ABI for the current target\",\n+                abi\n+            )\n+            .emit();\n+        }\n         None => {\n             tcx.struct_span_lint_hir(UNSUPPORTED_CALLING_CONVENTIONS, hir_id, span, |lint| {\n                 lint.build(\"use of calling convention not supported on this target\").emit()\n@@ -60,7 +62,7 @@ pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Ab\n             E0781,\n             \"the `\\\"C-cmse-nonsecure-call\\\"` ABI is only allowed on function pointers\"\n         )\n-        .emit()\n+        .emit();\n     }\n }\n "}, {"sha": "8ca27b010b6af647c59750f0d51c2884107c5031", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -37,7 +37,7 @@\n \n use crate::astconv::AstConv;\n use crate::check::FnCtxt;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -1307,7 +1307,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         &mut self,\n         fcx: &FnCtxt<'a, 'tcx>,\n         cause: &ObligationCause<'tcx>,\n-        augment_error: &mut dyn FnMut(&mut DiagnosticBuilder<'_>),\n+        augment_error: &mut dyn FnMut(&mut Diagnostic),\n         label_unit_as_expected: bool,\n     ) {\n         self.coerce_inner(\n@@ -1330,7 +1330,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         cause: &ObligationCause<'tcx>,\n         expression: Option<&'tcx hir::Expr<'tcx>>,\n         mut expression_ty: Ty<'tcx>,\n-        augment_error: Option<&mut dyn FnMut(&mut DiagnosticBuilder<'_>)>,\n+        augment_error: Option<&mut dyn FnMut(&mut Diagnostic)>,\n         label_expression_as_expected: bool,\n     ) {\n         // Incorporate whatever type inference information we have\n@@ -1520,7 +1520,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         fcx: &FnCtxt<'a, 'tcx>,\n         id: hir::HirId,\n         expression: Option<(&'tcx hir::Expr<'tcx>, hir::HirId)>,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) -> DiagnosticBuilder<'a, ErrorReported> {\n         let mut err = fcx.report_mismatched_types(cause, expected, found, ty_err);\n \n         let mut pointing_at_return_type = false;\n@@ -1603,7 +1603,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n     fn add_impl_trait_explanation<'a>(\n         &self,\n-        err: &mut DiagnosticBuilder<'a>,\n+        err: &mut Diagnostic,\n         cause: &ObligationCause<'tcx>,\n         fcx: &FnCtxt<'a, 'tcx>,\n         expected: Ty<'tcx>,"}, {"sha": "80096b90f953097d806b1fba84e1167f127490e7", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -4,7 +4,7 @@ use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::ObligationCause;\n \n use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n@@ -23,7 +23,7 @@ use std::iter;\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn emit_coerce_suggestions(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         sp: Span,\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         self.demand_suptype_with_origin(&self.misc(sp), expected, actual)\n     }\n \n@@ -67,7 +67,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         cause: &ObligationCause<'tcx>,\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         match self.at(cause, self.param_env).sup(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         sp: Span,\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         self.demand_eqtype_with_origin(&self.misc(sp), expected, actual)\n     }\n \n@@ -97,7 +97,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         cause: &ObligationCause<'tcx>,\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         match self.at(cause, self.param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n@@ -134,7 +134,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         allow_two_phase: AllowTwoPhase,\n-    ) -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx>>) {\n+    ) -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx, ErrorReported>>) {\n         let expected = self.resolve_vars_with_obligations(expected);\n \n         let e = match self.try_coerce(expr, checked_ty, expected, allow_two_phase, None) {\n@@ -155,7 +155,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn annotate_expected_due_to_let_ty(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n         error: TypeError<'_>,\n     ) {\n@@ -251,7 +251,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if !lhs.is_syntactic_place_expr() {\n                     // We already emitted E0070 \"invalid left-hand side of assignment\", so we\n                     // silence this.\n-                    err.delay_as_bug();\n+                    err.downgrade_to_delayed_bug();\n                 }\n             }\n             _ => {}\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// sole field is of the found type, suggest such variants. (Issue #42764)\n     fn suggest_compatible_variants(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         expr_ty: Ty<'tcx>,\n@@ -899,7 +899,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn check_for_cast(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n@@ -1039,7 +1039,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let in_const_context = self.tcx.hir().is_inside_const_context(expr.hir_id);\n \n         let suggest_fallible_into_or_lhs_from =\n-            |err: &mut DiagnosticBuilder<'_>, exp_to_found_is_fallible: bool| {\n+            |err: &mut Diagnostic, exp_to_found_is_fallible: bool| {\n                 // If we know the expression the expected type is derived from, we might be able\n                 // to suggest a widening conversion rather than a narrowing one (which may\n                 // panic). For example, given x: u8 and y: u32, if we know the span of \"x\",\n@@ -1083,7 +1083,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n \n         let suggest_to_change_suffix_or_into =\n-            |err: &mut DiagnosticBuilder<'_>,\n+            |err: &mut Diagnostic,\n              found_to_exp_is_fallible: bool,\n              exp_to_found_is_fallible: bool| {\n                 let exp_is_lhs =\n@@ -1282,11 +1282,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     // Report the type inferred by the return statement.\n-    fn report_closure_inferred_return_type(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expected: Ty<'tcx>,\n-    ) {\n+    fn report_closure_inferred_return_type(&self, err: &mut Diagnostic, expected: Ty<'tcx>) {\n         if let Some(sp) = self.ret_coercion_span.get() {\n             // If the closure has an explicit return type annotation, or if\n             // the closure's return type has been inferred from outside"}, {"sha": "f84036a7a39909a21f6c058d8ce10f01bc5414c4", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -25,6 +25,7 @@ use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructEx\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n+use rustc_errors::Diagnostic;\n use rustc_errors::ErrorReported;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc_hir as hir;\n@@ -60,7 +61,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n-        extend_err: impl Fn(&mut DiagnosticBuilder<'_>),\n+        extend_err: impl Fn(&mut Diagnostic),\n     ) -> Ty<'tcx> {\n         self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected), extend_err)\n     }\n@@ -69,7 +70,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        extend_err: impl Fn(&mut DiagnosticBuilder<'_>),\n+        extend_err: impl Fn(&mut Diagnostic),\n     ) -> Ty<'tcx> {\n         let expected_ty = expected.to_option(&self).unwrap_or(self.tcx.types.bool);\n         let mut ty = self.check_expr_with_expectation(expr, expected);\n@@ -485,7 +486,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .map_or(false, |x| x.iter().any(|adj| matches!(adj.kind, Adjust::Deref(_))))\n         });\n         if !is_named {\n-            self.tcx.sess.emit_err(AddressOfTemporaryTaken { span: oprnd.span })\n+            self.tcx.sess.emit_err(AddressOfTemporaryTaken { span: oprnd.span });\n         }\n     }\n \n@@ -1469,37 +1470,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                     self.register_predicates(obligations)\n                                                 }\n                                                 // FIXME: Need better diagnostics for `FieldMisMatch` error\n-                                                Err(_) => self\n-                                                    .report_mismatched_types(\n+                                                Err(_) => {\n+                                                    self.report_mismatched_types(\n                                                         &cause,\n                                                         target_ty,\n                                                         fru_ty,\n                                                         FieldMisMatch(variant.name, ident.name),\n                                                     )\n-                                                    .emit(),\n+                                                    .emit();\n+                                                }\n                                             }\n                                         }\n                                         fru_ty\n                                     })\n                                     .collect()\n                             }\n                             _ => {\n-                                return self\n-                                    .report_mismatched_types(\n-                                        &self.misc(base_expr.span),\n-                                        adt_ty,\n-                                        base_ty,\n-                                        Sorts(ExpectedFound::new(true, adt_ty, base_ty)),\n-                                    )\n-                                    .emit();\n+                                self.report_mismatched_types(\n+                                    &self.misc(base_expr.span),\n+                                    adt_ty,\n+                                    base_ty,\n+                                    Sorts(ExpectedFound::new(true, adt_ty, base_ty)),\n+                                )\n+                                .emit();\n+                                return;\n                             }\n                         }\n                     }\n                     _ => {\n-                        return self\n-                            .tcx\n+                        self.tcx\n                             .sess\n                             .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n+                        return;\n                     }\n                 }\n             } else {\n@@ -1528,10 +1530,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         })\n                         .collect(),\n                     _ => {\n-                        return self\n-                            .tcx\n+                        self.tcx\n                             .sess\n                             .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n+                        return;\n                     }\n                 }\n             };\n@@ -1923,7 +1925,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn suggest_await_on_field_access(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         field_ident: Ident,\n         base: &'tcx hir::Expr<'tcx>,\n         ty: Ty<'tcx>,\n@@ -2123,7 +2125,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn point_at_param_definition(&self, err: &mut DiagnosticBuilder<'_>, param: ty::ParamTy) {\n+    fn point_at_param_definition(&self, err: &mut Diagnostic, param: ty::ParamTy) {\n         let generics = self.tcx.generics_of(self.body_id.owner.to_def_id());\n         let generic_param = generics.type_param(&param, self.tcx);\n         if let ty::GenericParamDefKind::Type { synthetic: true, .. } = generic_param.kind {\n@@ -2142,7 +2144,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn suggest_fields_on_recordish(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         def: &'tcx ty::AdtDef,\n         field: Ident,\n         access_span: Span,\n@@ -2171,7 +2173,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn maybe_suggest_array_indexing(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n         base: &hir::Expr<'_>,\n         field: Ident,\n@@ -2195,7 +2197,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn suggest_first_deref_field(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n         base: &hir::Expr<'_>,\n         field: Ident,\n@@ -2212,7 +2214,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: Ident,\n         expr_t: Ty<'tcx>,\n         id: HirId,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'_, ErrorReported> {\n         let span = field.span;\n         debug!(\"no_such_field_err(span: {:?}, field: {:?}, expr_t: {:?})\", span, field, expr_t);\n "}, {"sha": "0fe5e74da89bfbf2cdcb98c8f5b4076ce121d4f0", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -8,7 +8,7 @@ use crate::check::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n \n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, DiagnosticBuilder, ErrorReported};\n+use rustc_errors::{Applicability, Diagnostic, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -953,7 +953,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(in super::super) fn note_internal_mutation_in_method(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n@@ -998,7 +998,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(in super::super) fn note_need_for_fn_pointer(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {"}, {"sha": "4b6460b62b77a5c7baf827bf269ff3b4e2d8052d", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -11,7 +11,7 @@ use crate::check::{\n \n use rustc_ast as ast;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticId};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             fn variadic_error<'tcx>(sess: &Session, span: Span, ty: Ty<'tcx>, cast_ty: &str) {\n                 use crate::structured_errors::MissingCastForVariadicArg;\n \n-                MissingCastForVariadicArg { sess, span, ty, cast_ty }.diagnostic().emit()\n+                MissingCastForVariadicArg { sess, span, ty, cast_ty }.diagnostic().emit();\n             }\n \n             for arg in provided_args.iter().skip(expected_arg_count) {\n@@ -837,7 +837,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             kind: hir::ExprKind::Loop(_, _, hir::LoopSource::While, _),\n                                             ..\n                                         })) => {\n-                                            err.delay_as_bug();\n+                                            err.downgrade_to_delayed_bug();\n                                         }\n                                         _ => {}\n                                     }\n@@ -890,7 +890,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n     ) {\n         if let Some((span_semi, boxed)) = self.could_remove_semicolon(blk, expected_ty) {\n             if let StatementAsExpression::NeedsBoxing = boxed {"}, {"sha": "9e4b88e3746806ccd0847f2302bbfd812dad4be4", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -4,7 +4,7 @@ use crate::astconv::AstConv;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_span::{self, MultiSpan, Span};\n \n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n@@ -22,11 +22,7 @@ use rustc_middle::ty::subst::GenericArgKind;\n use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub(in super::super) fn suggest_semicolon_at_end(\n-        &self,\n-        span: Span,\n-        err: &mut DiagnosticBuilder<'_>,\n-    ) {\n+    pub(in super::super) fn suggest_semicolon_at_end(&self, span: Span, err: &mut Diagnostic) {\n         err.span_suggestion_short(\n             span.shrink_to_hi(),\n             \"consider using a semicolon here\",\n@@ -42,7 +38,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// - Possible missing return type if the return type is the default, and not `fn main()`.\n     pub fn suggest_mismatched_types_on_tail(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n@@ -81,7 +77,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```\n     fn suggest_fn_call(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n@@ -211,7 +207,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn suggest_deref_ref_or_into(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n@@ -312,7 +308,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// in the heap by calling `Box::new()`.\n     pub(in super::super) fn suggest_boxing_when_appropriate(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n@@ -347,7 +343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// suggest a non-capturing closure\n     pub(in super::super) fn suggest_no_capture_closure(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n@@ -382,7 +378,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     #[instrument(skip(self, err))]\n     pub(in super::super) fn suggest_calling_boxed_future_when_appropriate(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n@@ -477,7 +473,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// it suggests adding a semicolon.\n     fn suggest_missing_semicolon(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expression: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n     ) {\n@@ -518,7 +514,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// type.\n     pub(in super::super) fn suggest_missing_return_type(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         fn_decl: &hir::FnDecl<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n@@ -580,7 +576,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```\n     fn try_suggest_return_impl_trait(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         fn_id: hir::HirId,\n@@ -681,7 +677,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(in super::super) fn suggest_missing_break_or_return_expr(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &'tcx hir::Expr<'tcx>,\n         fn_decl: &hir::FnDecl<'_>,\n         expected: Ty<'tcx>,\n@@ -751,7 +747,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(in super::super) fn suggest_missing_parentheses(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n     ) {\n         let sp = self.tcx.sess.source_map().start_point(expr.span);"}, {"sha": "999aafbd5375a4de8baeb2ae158720c3dba5a42d", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -14,7 +14,7 @@ pub use self::MethodError::*;\n use crate::check::FnCtxt;\n use crate::ObligationCause;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace};\n use rustc_hir::def_id::DefId;\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self, err, call_expr))]\n     crate fn suggest_method_call(\n         &self,\n-        err: &mut DiagnosticBuilder<'a>,\n+        err: &mut Diagnostic,\n         msg: &str,\n         method_name: Ident,\n         self_ty: Ty<'tcx>,"}, {"sha": "ccaea10233dc136d7572710098071c4161f1c8ad", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -3,7 +3,9 @@\n \n use crate::check::FnCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{\n+    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorReported,\n+};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n@@ -91,14 +93,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         source: SelfSource<'tcx>,\n         error: MethodError<'tcx>,\n         args: Option<&'tcx [hir::Expr<'tcx>]>,\n-    ) -> Option<DiagnosticBuilder<'_>> {\n+    ) -> Option<DiagnosticBuilder<'_, ErrorReported>> {\n         // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n             return None;\n         }\n \n         let report_candidates = |span: Span,\n-                                 err: &mut DiagnosticBuilder<'_>,\n+                                 err: &mut Diagnostic,\n                                  mut sources: Vec<CandidateSource>,\n                                  sugg_span: Span| {\n             sources.sort();\n@@ -268,7 +270,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         (None, true) => \"variant\",\n                     }\n                 };\n-                let mut err = if !actual.references_error() {\n+                // FIXME(eddyb) this intendation is probably unnecessary.\n+                let mut err = {\n                     // Suggest clamping down the type if the method that is being attempted to\n                     // be used exists at all, and the type is an ambiguous numeric type\n                     // ({integer}/{float}).\n@@ -461,10 +464,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                         err\n                     }\n-                } else {\n-                    tcx.sess.diagnostic().struct_dummy()\n                 };\n \n+                if actual.references_error() {\n+                    err.downgrade_to_delayed_bug();\n+                }\n+\n                 if let Some(def) = actual.ty_adt_def() {\n                     if let Some(full_sp) = tcx.hir().span_if_local(def.did) {\n                         let def_sp = tcx.sess.source_map().guess_head_span(full_sp);\n@@ -625,10 +630,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n \n                 if self.is_fn_ty(rcvr_ty, span) {\n-                    fn report_function<T: std::fmt::Display>(\n-                        err: &mut DiagnosticBuilder<'_>,\n-                        name: T,\n-                    ) {\n+                    fn report_function<T: std::fmt::Display>(err: &mut Diagnostic, name: T) {\n                         err.note(\n                             &format!(\"`{}` is a function, perhaps you wish to call it\", name,),\n                         );\n@@ -1111,7 +1113,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     crate fn note_unmet_impls_on_type(\n         &self,\n-        err: &mut rustc_errors::DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         errors: Vec<FulfillmentError<'tcx>>,\n     ) {\n         let all_local_types_needing_impls =\n@@ -1187,7 +1189,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn suggest_derive(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         unsatisfied_predicates: &[(\n             ty::Predicate<'tcx>,\n             Option<ty::Predicate<'tcx>>,\n@@ -1287,7 +1289,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn suggest_await_before_method(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         item_name: Ident,\n         ty: Ty<'tcx>,\n         call: &hir::Expr<'_>,\n@@ -1311,7 +1313,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn suggest_use_candidates(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         mut msg: String,\n         candidates: Vec<DefId>,\n     ) {\n@@ -1416,7 +1418,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn suggest_valid_traits(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         valid_out_of_scope_traits: Vec<DefId>,\n     ) -> bool {\n         if !valid_out_of_scope_traits.is_empty() {\n@@ -1454,7 +1456,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn suggest_traits_to_import(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n@@ -1983,7 +1985,7 @@ fn find_use_placement<'tcx>(tcx: TyCtxt<'tcx>, target_module: LocalDefId) -> (Op\n fn print_disambiguation_help<'tcx>(\n     item_name: Ident,\n     args: Option<&'tcx [hir::Expr<'tcx>]>,\n-    err: &mut DiagnosticBuilder<'_>,\n+    err: &mut Diagnostic,\n     trait_name: String,\n     rcvr_ty: Ty<'_>,\n     kind: ty::AssocKind,"}, {"sha": "e2a91635a2d8b5f54bfee480833fde095e72824e", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -139,11 +139,13 @@ pub use self::Expectation::*;\n #[macro_export]\n macro_rules! type_error_struct {\n     ($session:expr, $span:expr, $typ:expr, $code:ident, $($message:tt)*) => ({\n+        let mut err = rustc_errors::struct_span_err!($session, $span, $code, $($message)*);\n+\n         if $typ.references_error() {\n-            $session.diagnostic().struct_dummy()\n-        } else {\n-            rustc_errors::struct_span_err!($session, $span, $code, $($message)*)\n+            err.downgrade_to_delayed_bug();\n         }\n+\n+        err\n     })\n }\n "}, {"sha": "5873b0f52a60eac6f1dbbb017cf21714841974dc", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -3,7 +3,7 @@\n use super::method::MethodCallee;\n use super::{has_expected_num_generic_args, FnCtxt};\n use rustc_ast as ast;\n-use rustc_errors::{self, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{self, struct_span_err, Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::adjustment::{\n@@ -483,7 +483,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// suggest calling the function. Returns `true` if suggestion would apply (even if not given).\n     fn add_type_neq_err_label(\n         &self,\n-        err: &mut rustc_errors::DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         span: Span,\n         ty: Ty<'tcx>,\n         other_ty: Ty<'tcx>,\n@@ -545,7 +545,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         rhs_expr: &'tcx hir::Expr<'tcx>,\n         lhs_ty: Ty<'tcx>,\n         rhs_ty: Ty<'tcx>,\n-        err: &mut rustc_errors::DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         is_assign: IsAssign,\n         op: hir::BinOp,\n     ) -> bool {\n@@ -937,7 +937,7 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool\n fn suggest_constraining_param(\n     tcx: TyCtxt<'_>,\n     body_id: hir::HirId,\n-    mut err: &mut DiagnosticBuilder<'_>,\n+    mut err: &mut Diagnostic,\n     lhs_ty: Ty<'_>,\n     rhs_ty: Ty<'_>,\n     missing_trait: &str,"}, {"sha": "7c6917734b2ae16030b359de40a69cd8997fd2b9", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -2,7 +2,9 @@ use crate::check::FnCtxt;\n use rustc_ast as ast;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{\n+    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorReported,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n@@ -98,7 +100,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         self.demand_eqtype_with_origin(&self.pattern_cause(ti, cause_span), expected, actual)\n     }\n \n@@ -512,7 +514,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    fn endpoint_has_type(&self, err: &mut DiagnosticBuilder<'_>, span: Span, ty: Ty<'_>) {\n+    fn endpoint_has_type(&self, err: &mut Diagnostic, span: Span, ty: Ty<'_>) {\n         if !ty.references_error() {\n             err.span_label(span, &format!(\"this is of type `{}`\", ty));\n         }\n@@ -645,7 +647,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn borrow_pat_suggestion(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut Diagnostic,\n         pat: &Pat<'_>,\n         inner: &Pat<'_>,\n         expected: Ty<'tcx>,\n@@ -783,7 +785,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn maybe_suggest_range_literal(\n         &self,\n-        e: &mut DiagnosticBuilder<'_>,\n+        e: &mut Diagnostic,\n         opt_def_id: Option<hir::def_id::DefId>,\n         ident: Ident,\n     ) -> bool {\n@@ -817,7 +819,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn emit_bad_pat_path<'b>(\n         &self,\n-        mut e: DiagnosticBuilder<'_>,\n+        mut e: DiagnosticBuilder<'_, ErrorReported>,\n         pat_span: Span,\n         res: Res,\n         pat_res: Res,\n@@ -1368,7 +1370,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         variant: &VariantDef,\n         pat: &'_ Pat<'_>,\n         fields: &[hir::PatField<'_>],\n-    ) -> Option<DiagnosticBuilder<'_>> {\n+    ) -> Option<DiagnosticBuilder<'_, ErrorReported>> {\n         // if this is a tuple struct, then all field names will be numbers\n         // so if any fields in a struct pattern use shorthand syntax, they will\n         // be invalid identifiers (for example, Foo { 0, 1 }).\n@@ -1441,7 +1443,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         inexistent_fields: &[Ident],\n         unmentioned_fields: &mut Vec<(&ty::FieldDef, Ident)>,\n         variant: &ty::VariantDef,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let tcx = self.tcx;\n         let (field_names, t, plural) = if inexistent_fields.len() == 1 {\n             (format!(\"a field named `{}`\", inexistent_fields[0]), \"this\", \"\")\n@@ -1537,7 +1539,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat: &Pat<'_>,\n         fields: &'tcx [hir::PatField<'tcx>],\n         variant: &ty::VariantDef,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorReported>> {\n         if let (CtorKind::Fn, PatKind::Struct(qpath, ..)) = (variant.ctor_kind, &pat.kind) {\n             let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n                 s.print_qpath(qpath, false)\n@@ -1619,7 +1621,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         pat: &Pat<'_>,\n         fields: &'tcx [hir::PatField<'tcx>],\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let mut err = self\n             .tcx\n             .sess\n@@ -1711,7 +1713,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         unmentioned_fields: &[(&ty::FieldDef, Ident)],\n         have_inaccessible_fields: bool,\n         fields: &'tcx [hir::PatField<'tcx>],\n-    ) -> DiagnosticBuilder<'tcx> {\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let inaccessible = if have_inaccessible_fields { \" and inaccessible fields\" } else { \"\" };\n         let field_names = if unmentioned_fields.len() == 1 {\n             format!(\"field `{}`{}\", unmentioned_fields[0].1, inaccessible)"}, {"sha": "4ab654560ea0d70373b60cfa7d64433717636834", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -4,7 +4,7 @@ use crate::constrained_generic_params::{identify_constrained_generic_params, Par\n \n use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit as hir_visit;\n@@ -448,7 +448,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                  for more information\",\n             );\n \n-            err.emit()\n+            err.emit();\n         }\n     }\n }\n@@ -843,7 +843,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                             \"using {} as const generic parameters is forbidden\",\n                             unsupported_type\n                         ),\n-                    )\n+                    );\n                 } else {\n                     let mut err = tcx.sess.struct_span_err(\n                         hir_ty.span,\n@@ -858,7 +858,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                             \"more complex types are supported with `#![feature(adt_const_params)]`\",\n                         );\n                     }\n-                    err.emit()\n+                    err.emit();\n                 }\n             };\n \n@@ -1729,12 +1729,14 @@ fn check_variances_for_type_defn<'tcx>(\n \n         match param.name {\n             hir::ParamName::Error => {}\n-            _ => report_bivariance(tcx, param),\n+            _ => {\n+                report_bivariance(tcx, param);\n+            }\n         }\n     }\n }\n \n-fn report_bivariance(tcx: TyCtxt<'_>, param: &rustc_hir::GenericParam<'_>) {\n+fn report_bivariance(tcx: TyCtxt<'_>, param: &rustc_hir::GenericParam<'_>) -> ErrorReported {\n     let span = param.span;\n     let param_name = param.name.ident().name;\n     let mut err = error_392(tcx, span, param_name);\n@@ -1943,7 +1945,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-fn error_392(tcx: TyCtxt<'_>, span: Span, param_name: Symbol) -> DiagnosticBuilder<'_> {\n+fn error_392(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    param_name: Symbol,\n+) -> DiagnosticBuilder<'_, ErrorReported> {\n     let mut err =\n         struct_span_err!(tcx.sess, span, E0392, \"parameter `{}` is never used\", param_name);\n     err.span_label(span, \"unused parameter\");"}, {"sha": "ac1f2db848fb34a00a22aec2217dca8450fc3d07", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -94,7 +94,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n             for span in fields.iter().map(|f| tcx.def_span(f.did)) {\n                 err.span_label(span, \"this field does not implement `Copy`\");\n             }\n-            err.emit()\n+            err.emit();\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n             let item = tcx.hir().expect_item(impl_did);"}, {"sha": "6c9059cfdd44a29c90f159aea3e937dc464927bb", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -159,7 +159,7 @@ fn emit_orphan_check_error<'tcx>(\n     generics: &hir::Generics<'tcx>,\n     err: traits::OrphanCheckErr<'tcx>,\n ) -> Result<!, ErrorReported> {\n-    match err {\n+    Err(match err {\n         traits::OrphanCheckErr::NonLocalInputType(tys) => {\n             let mut err = struct_span_err!(\n                 tcx.sess,\n@@ -269,9 +269,7 @@ fn emit_orphan_check_error<'tcx>(\n                 .emit(),\n             }\n         }\n-    }\n-\n-    Err(ErrorReported)\n+    })\n }\n \n #[derive(Default)]"}, {"sha": "cf2164763b1cfd065b34acac879c9b503914ce5c", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -26,7 +26,7 @@ use rustc_ast::{MetaItemKind, NestedMetaItem};\n use rustc_attr::{list_contains_name, InlineAttr, InstructionSetAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n@@ -321,7 +321,7 @@ fn bad_placeholder<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     mut spans: Vec<Span>,\n     kind: &'static str,\n-) -> rustc_errors::DiagnosticBuilder<'tcx> {\n+) -> DiagnosticBuilder<'tcx, ErrorReported> {\n     let kind = if kind.ends_with('s') { format!(\"{}es\", kind) } else { format!(\"{}s\", kind) };\n \n     spans.sort();\n@@ -1277,19 +1277,21 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n \n                         return None;\n                     }\n-                    Some(item) => tcx\n-                        .sess\n-                        .struct_span_err(item.span, \"Not a function\")\n-                        .span_note(attr_span, \"required by this annotation\")\n-                        .note(\n-                            \"All `#[rustc_must_implement_one_of]` arguments \\\n+                    Some(item) => {\n+                        tcx.sess\n+                            .struct_span_err(item.span, \"Not a function\")\n+                            .span_note(attr_span, \"required by this annotation\")\n+                            .note(\n+                                \"All `#[rustc_must_implement_one_of]` arguments \\\n                             must be associated function names\",\n-                        )\n-                        .emit(),\n-                    None => tcx\n-                        .sess\n-                        .struct_span_err(ident.span, \"Function not found in this trait\")\n-                        .emit(),\n+                            )\n+                            .emit();\n+                    }\n+                    None => {\n+                        tcx.sess\n+                            .struct_span_err(ident.span, \"Function not found in this trait\")\n+                            .emit();\n+                    }\n                 }\n \n                 Some(())"}, {"sha": "6cef3e9d9409eb1750595df7047d20b8240a6ed7", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -393,13 +393,14 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n                             tcx.def_path_str(trait_ref.def_id),\n                         ),\n                     )\n-                    .emit()\n+                    .emit();\n             }\n         }\n-        _ => tcx\n-            .sess\n-            .struct_span_err(span, &format!(\"cannot specialize on `{:?}`\", predicate))\n-            .emit(),\n+        _ => {\n+            tcx.sess\n+                .struct_span_err(span, &format!(\"cannot specialize on `{:?}`\", predicate))\n+                .emit();\n+        }\n     }\n }\n "}, {"sha": "8621375fc63e0b6a4a3d2ff94e97e5acea93a0e3", "filename": "compiler/rustc_typeck/src/structured_errors.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -6,15 +6,15 @@ pub use self::{\n     missing_cast_for_variadic_arg::*, sized_unsized_cast::*, wrong_number_of_generic_args::*,\n };\n \n-use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n+use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_session::Session;\n \n pub trait StructuredDiagnostic<'tcx> {\n     fn session(&self) -> &Session;\n \n     fn code(&self) -> DiagnosticId;\n \n-    fn diagnostic(&self) -> DiagnosticBuilder<'tcx> {\n+    fn diagnostic(&self) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let err = self.diagnostic_common();\n \n         if self.session().teach(&self.code()) {\n@@ -24,13 +24,19 @@ pub trait StructuredDiagnostic<'tcx> {\n         }\n     }\n \n-    fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx>;\n+    fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx, ErrorReported>;\n \n-    fn diagnostic_regular(&self, err: DiagnosticBuilder<'tcx>) -> DiagnosticBuilder<'tcx> {\n+    fn diagnostic_regular(\n+        &self,\n+        err: DiagnosticBuilder<'tcx, ErrorReported>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         err\n     }\n \n-    fn diagnostic_extended(&self, err: DiagnosticBuilder<'tcx>) -> DiagnosticBuilder<'tcx> {\n+    fn diagnostic_extended(\n+        &self,\n+        err: DiagnosticBuilder<'tcx, ErrorReported>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         err\n     }\n }"}, {"sha": "2dc9f26004cf824b7d7cead8a34c7cc502f4e0cf", "filename": "compiler/rustc_typeck/src/structured_errors/missing_cast_for_variadic_arg.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,5 +1,5 @@\n use crate::structured_errors::StructuredDiagnostic;\n-use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_middle::ty::{Ty, TypeFoldable};\n use rustc_session::Session;\n use rustc_span::Span;\n@@ -20,16 +20,16 @@ impl<'tcx> StructuredDiagnostic<'tcx> for MissingCastForVariadicArg<'tcx> {\n         rustc_errors::error_code!(E0617)\n     }\n \n-    fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx> {\n-        let mut err = if self.ty.references_error() {\n-            self.sess.diagnostic().struct_dummy()\n-        } else {\n-            self.sess.struct_span_fatal_with_code(\n-                self.span,\n-                &format!(\"can't pass `{}` to variadic function\", self.ty),\n-                self.code(),\n-            )\n-        };\n+    fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx, ErrorReported> {\n+        let mut err = self.sess.struct_span_fatal_with_code(\n+            self.span,\n+            &format!(\"can't pass `{}` to variadic function\", self.ty),\n+            self.code(),\n+        );\n+\n+        if self.ty.references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n \n         if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.span) {\n             err.span_suggestion(\n@@ -45,7 +45,10 @@ impl<'tcx> StructuredDiagnostic<'tcx> for MissingCastForVariadicArg<'tcx> {\n         err\n     }\n \n-    fn diagnostic_extended(&self, mut err: DiagnosticBuilder<'tcx>) -> DiagnosticBuilder<'tcx> {\n+    fn diagnostic_extended(\n+        &self,\n+        mut err: DiagnosticBuilder<'tcx, ErrorReported>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         err.note(&format!(\n             \"certain types, like `{}`, must be casted before passing them to a \\\n                 variadic function, because of arcane ABI rules dictated by the C \\"}, {"sha": "8d2cdbb170b985a70d769de4640c85660ff03f6b", "filename": "compiler/rustc_typeck/src/structured_errors/sized_unsized_cast.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,5 +1,5 @@\n use crate::structured_errors::StructuredDiagnostic;\n-use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n+use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_middle::ty::{Ty, TypeFoldable};\n use rustc_session::Session;\n use rustc_span::Span;\n@@ -20,22 +20,27 @@ impl<'tcx> StructuredDiagnostic<'tcx> for SizedUnsizedCast<'tcx> {\n         rustc_errors::error_code!(E0607)\n     }\n \n-    fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx> {\n+    fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx, ErrorReported> {\n+        let mut err = self.sess.struct_span_fatal_with_code(\n+            self.span,\n+            &format!(\n+                \"cannot cast thin pointer `{}` to fat pointer `{}`\",\n+                self.expr_ty, self.cast_ty\n+            ),\n+            self.code(),\n+        );\n+\n         if self.expr_ty.references_error() {\n-            self.sess.diagnostic().struct_dummy()\n-        } else {\n-            self.sess.struct_span_fatal_with_code(\n-                self.span,\n-                &format!(\n-                    \"cannot cast thin pointer `{}` to fat pointer `{}`\",\n-                    self.expr_ty, self.cast_ty\n-                ),\n-                self.code(),\n-            )\n+            err.downgrade_to_delayed_bug();\n         }\n+\n+        err\n     }\n \n-    fn diagnostic_extended(&self, mut err: DiagnosticBuilder<'tcx>) -> DiagnosticBuilder<'tcx> {\n+    fn diagnostic_extended(\n+        &self,\n+        mut err: DiagnosticBuilder<'tcx, ErrorReported>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         err.help(\n             \"Thin pointers are \\\"simple\\\" pointers: they are purely a reference to a\n memory address."}, {"sha": "b763b51dd01434050980dd1116cc8eafaaa4f094", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,5 +1,7 @@\n use crate::structured_errors::StructuredDiagnostic;\n-use rustc_errors::{pluralize, Applicability, DiagnosticBuilder, DiagnosticId};\n+use rustc_errors::{\n+    pluralize, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticId, ErrorReported,\n+};\n use rustc_hir as hir;\n use rustc_middle::hir::map::fn_sig;\n use rustc_middle::middle::resolve_lifetime::LifetimeScopeForPath;\n@@ -362,15 +364,15 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         }\n     }\n \n-    fn start_diagnostics(&self) -> DiagnosticBuilder<'tcx> {\n+    fn start_diagnostics(&self) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let span = self.path_segment.ident.span;\n         let msg = self.create_error_message();\n \n         self.tcx.sess.struct_span_err_with_code(span, &msg, self.code())\n     }\n \n     /// Builds the `expected 1 type argument / supplied 2 type arguments` message.\n-    fn notify(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn notify(&self, err: &mut Diagnostic) {\n         let (quantifier, bound) = self.get_quantifier_and_bound();\n         let provided_args = self.num_provided_args();\n \n@@ -422,7 +424,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest(&self, err: &mut Diagnostic) {\n         debug!(\n             \"suggest(self.provided {:?}, self.gen_args.span(): {:?})\",\n             self.num_provided_args(),\n@@ -449,7 +451,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n     /// ```text\n     /// type Map = HashMap<String>;\n     /// ```\n-    fn suggest_adding_args(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest_adding_args(&self, err: &mut Diagnostic) {\n         if self.gen_args.parenthesized {\n             return;\n         }\n@@ -465,7 +467,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_adding_lifetime_args(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest_adding_lifetime_args(&self, err: &mut Diagnostic) {\n         debug!(\"suggest_adding_lifetime_args(path_segment: {:?})\", self.path_segment);\n         let num_missing_args = self.num_missing_lifetime_args();\n         let num_params_to_take = num_missing_args;\n@@ -547,7 +549,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_adding_type_and_const_args(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest_adding_type_and_const_args(&self, err: &mut Diagnostic) {\n         let num_missing_args = self.num_missing_type_or_const_args();\n         let msg = format!(\"add missing {} argument{}\", self.kind(), pluralize!(num_missing_args));\n \n@@ -602,7 +604,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n     /// ```text\n     /// type Map = HashMap<String, String, String, String>;\n     /// ```\n-    fn suggest_removing_args_or_generics(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest_removing_args_or_generics(&self, err: &mut Diagnostic) {\n         let num_provided_lt_args = self.num_provided_lifetime_args();\n         let num_provided_type_const_args = self.num_provided_type_or_const_args();\n         let num_provided_args = num_provided_lt_args + num_provided_type_const_args;\n@@ -617,7 +619,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n \n         let remove_entire_generics = num_redundant_args >= self.gen_args.args.len();\n \n-        let remove_lifetime_args = |err: &mut DiagnosticBuilder<'_>| {\n+        let remove_lifetime_args = |err: &mut Diagnostic| {\n             let mut lt_arg_spans = Vec::new();\n             let mut found_redundant = false;\n             for arg in self.gen_args.args {\n@@ -659,7 +661,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n             );\n         };\n \n-        let remove_type_or_const_args = |err: &mut DiagnosticBuilder<'_>| {\n+        let remove_type_or_const_args = |err: &mut Diagnostic| {\n             let mut gen_arg_spans = Vec::new();\n             let mut found_redundant = false;\n             for arg in self.gen_args.args {\n@@ -729,7 +731,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n     }\n \n     /// Builds the `type defined here` message.\n-    fn show_definition(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn show_definition(&self, err: &mut Diagnostic) {\n         let mut spans: MultiSpan = if let Some(def_span) = self.tcx.def_ident_span(self.def_id) {\n             if self.tcx.sess.source_map().span_to_snippet(def_span).is_ok() {\n                 def_span.into()\n@@ -789,7 +791,7 @@ impl<'tcx> StructuredDiagnostic<'tcx> for WrongNumberOfGenericArgs<'_, 'tcx> {\n         rustc_errors::error_code!(E0107)\n     }\n \n-    fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx> {\n+    fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx, ErrorReported> {\n         let mut err = self.start_diagnostics();\n \n         self.notify(&mut err);"}, {"sha": "58ca8869ea9d7b745a73875103f284e3e7b196df", "filename": "src/librustdoc/clean/render_macro_matchers.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -69,17 +69,15 @@ fn snippet_equal_to_token(tcx: TyCtxt<'_>, matcher: &TokenTree) -> Option<String\n         match rustc_parse::maybe_new_parser_from_source_str(&sess, file_name, snippet.clone()) {\n             Ok(parser) => parser,\n             Err(diagnostics) => {\n-                for mut diagnostic in diagnostics {\n-                    diagnostic.cancel();\n-                }\n+                drop(diagnostics);\n                 return None;\n             }\n         };\n \n     // Reparse a single token tree.\n     let mut reparsed_trees = match parser.parse_all_token_trees() {\n         Ok(reparsed_trees) => reparsed_trees,\n-        Err(mut diagnostic) => {\n+        Err(diagnostic) => {\n             diagnostic.cancel();\n             return None;\n         }"}, {"sha": "a08732be1c560542ca6e9a4a300ed06c0c729035", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -551,10 +551,7 @@ crate fn make_test(\n             let mut parser = match maybe_new_parser_from_source_str(&sess, filename, source) {\n                 Ok(p) => p,\n                 Err(errs) => {\n-                    for mut err in errs {\n-                        err.cancel();\n-                    }\n-\n+                    drop(errs);\n                     return (found_main, found_extern_crate, found_macro);\n                 }\n             };\n@@ -594,7 +591,7 @@ crate fn make_test(\n                         }\n                     }\n                     Ok(None) => break,\n-                    Err(mut e) => {\n+                    Err(e) => {\n                         e.cancel();\n                         break;\n                     }"}, {"sha": "9d3e58a3a66fc7ca5300f697da42016982d381fb", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -720,12 +720,10 @@ fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n             let mut msg =\n                 tcx.sess.struct_err(&format!(\"couldn't generate documentation: {}\", e.error));\n             let file = e.file.display().to_string();\n-            if file.is_empty() {\n-                msg.emit()\n-            } else {\n-                msg.note(&format!(\"failed to create or modify \\\"{}\\\"\", file)).emit()\n+            if !file.is_empty() {\n+                msg.note(&format!(\"failed to create or modify \\\"{}\\\"\", file));\n             }\n-            Err(ErrorReported)\n+            Err(msg.emit())\n         }\n     }\n }"}, {"sha": "3ebd28e83b1220689ae249b89e458fca6a343185", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -3,7 +3,7 @@\n //! [RFC 1946]: https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md\n \n use rustc_data_structures::{fx::FxHashMap, stable_set::FxHashSet};\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::def::{\n     DefKind,\n     Namespace::{self, *},\n@@ -1434,7 +1434,7 @@ impl LinkCollector<'_, '_> {\n     ) {\n         // The resolved item did not match the disambiguator; give a better error than 'not found'\n         let msg = format!(\"incompatible link kind for `{}`\", path_str);\n-        let callback = |diag: &mut DiagnosticBuilder<'_>, sp: Option<rustc_span::Span>| {\n+        let callback = |diag: &mut Diagnostic, sp: Option<rustc_span::Span>| {\n             let note = format!(\n                 \"this link resolved to {} {}, which is not {} {}\",\n                 resolved.article(),\n@@ -1866,7 +1866,7 @@ fn report_diagnostic(\n     lint: &'static Lint,\n     msg: &str,\n     DiagnosticInfo { item, ori_link: _, dox, link_range }: &DiagnosticInfo<'_>,\n-    decorate: impl FnOnce(&mut DiagnosticBuilder<'_>, Option<rustc_span::Span>),\n+    decorate: impl FnOnce(&mut Diagnostic, Option<rustc_span::Span>),\n ) {\n     let hir_id = match DocContext::as_local_hir_id(tcx, item.def_id) {\n         Some(hir_id) => hir_id,\n@@ -2098,8 +2098,15 @@ fn resolution_failure(\n                         )\n                     }\n                     ResolutionFailure::NoParentItem => {\n-                        diag.level = rustc_errors::Level::Bug;\n-                        \"all intra-doc links should have a parent item\".to_owned()\n+                        // FIXME(eddyb) this doesn't belong here, whatever made\n+                        // the `ResolutionFailure::NoParentItem` should emit an\n+                        // immediate or delayed `span_bug` about the issue.\n+                        tcx.sess.delay_span_bug(\n+                            sp.unwrap_or(DUMMY_SP),\n+                            \"intra-doc link missing parent item\",\n+                        );\n+\n+                        \"BUG: all intra-doc links should have a parent item\".to_owned()\n                     }\n                     ResolutionFailure::MalformedGenerics(variant) => match variant {\n                         MalformedGenerics::UnbalancedAngleBrackets => {\n@@ -2233,7 +2240,7 @@ fn ambiguity_error(\n /// disambiguator.\n fn suggest_disambiguator(\n     res: Res,\n-    diag: &mut DiagnosticBuilder<'_>,\n+    diag: &mut Diagnostic,\n     path_str: &str,\n     ori_link: &str,\n     sp: Option<rustc_span::Span>,"}, {"sha": "a37d3a32571edf0b02cd2de922a7f12b2b01d1cf", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -42,7 +42,7 @@ fn parse_expr(ps: &ParseSess, src: &str) -> Option<P<Expr>> {\n \n     let mut p =\n         new_parser_from_source_str(ps, FileName::Custom(src_as_string.clone()), src_as_string);\n-    p.parse_expr().map_err(|mut e| e.cancel()).ok()\n+    p.parse_expr().map_err(|e| e.cancel()).ok()\n }\n \n // Helper functions for building exprs"}, {"sha": "a20aa12c9ff4771a1a3e56543d980bb42b207ec6", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -6,7 +6,7 @@ use clippy_utils::{\n };\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Block, Expr, ExprKind, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -489,7 +489,7 @@ fn emit_branches_sharing_code_lint(\n         add_expr_note = !cx.typeck_results().expr_ty(if_expr).is_unit();\n     }\n \n-    let add_optional_msgs = |diag: &mut DiagnosticBuilder<'_>| {\n+    let add_optional_msgs = |diag: &mut Diagnostic| {\n         if add_expr_note {\n             diag.note(\"The end suggestion probably needs some adjustments to use the expression result correctly\");\n         }"}, {"sha": "16173580fd4617ae67a5223b96ce94a3a67be87d", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -628,9 +628,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code) {\n                     Ok(p) => p,\n                     Err(errs) => {\n-                        for mut err in errs {\n-                            err.cancel();\n-                        }\n+                        drop(errs);\n                         return false;\n                     },\n                 };\n@@ -668,7 +666,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                             _ => {},\n                         },\n                         Ok(None) => break,\n-                        Err(mut e) => {\n+                        Err(e) => {\n                             e.cancel();\n                             return false;\n                         },"}, {"sha": "d5430a8c91750784b0033ccb226c9d352c632b60", "filename": "src/tools/clippy/clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,7 +1,7 @@\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n \n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_inf, walk_ty, Visitor};\n use rustc_hir::{Body, Expr, ExprKind, GenericArg, Item, ItemKind, QPath, TyKind};\n@@ -68,7 +68,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n \n         fn suggestion<'tcx>(\n             cx: &LateContext<'tcx>,\n-            diag: &mut DiagnosticBuilder<'_>,\n+            diag: &mut Diagnostic,\n             generics_span: Span,\n             generics_suggestion_span: Span,\n             target: &ImplicitHasherType<'_>,"}, {"sha": "dd7177e0131ca5d3ef2ff523a6d68a1b023ccf26", "filename": "src/tools/clippy/clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,7 +1,7 @@\n //! checks for `#[inline]` on trait methods without bodies\n \n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::sugg::DiagnosticBuilderExt;\n+use clippy_utils::sugg::DiagnosticExt;\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n use rustc_hir::{TraitFn, TraitItem, TraitItemKind};"}, {"sha": "ebfd908a6fb741692149fe5a491bf1612680221a", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -6,7 +6,7 @@ use clippy_utils::{get_trait_def_id, is_self, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Node, PatKind, QPath, TyKind};\n use rustc_hir::{HirIdMap, HirIdSet};\n@@ -196,7 +196,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                     }\n \n                     // Dereference suggestion\n-                    let sugg = |diag: &mut DiagnosticBuilder<'_>| {\n+                    let sugg = |diag: &mut Diagnostic| {\n                         if let ty::Adt(def, ..) = ty.kind() {\n                             if let Some(span) = cx.tcx.hir().span_if_local(def.did) {\n                                 if can_type_implement_copy(cx.tcx, cx.param_env, ty, traits::ObligationCause::dummy_with_span(span)).is_ok() {"}, {"sha": "4cb79648ae36a054e13ce8aeda7f558fccb34d7a", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_hir_and_then;\n use clippy_utils::return_ty;\n use clippy_utils::source::snippet;\n-use clippy_utils::sugg::DiagnosticBuilderExt;\n+use clippy_utils::sugg::DiagnosticExt;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;"}, {"sha": "a328ddda5ae7b9fd6b980eddf188641e70057f6b", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -534,7 +534,7 @@ impl Write {\n             match parser\n                 .parse_expr()\n                 .map(rustc_ast::ptr::P::into_inner)\n-                .map_err(|mut e| e.cancel())\n+                .map_err(|e| e.cancel())\n             {\n                 // write!(e, ...)\n                 Ok(p) if parser.eat(&token::Comma) => Some(p),\n@@ -563,7 +563,7 @@ impl Write {\n             }\n \n             let comma_span = parser.prev_token.span;\n-            let token_expr = if let Ok(expr) = parser.parse_expr().map_err(|mut err| err.cancel()) {\n+            let token_expr = if let Ok(expr) = parser.parse_expr().map_err(|err| err.cancel()) {\n                 expr\n             } else {\n                 return (Some(fmtstr), None);"}, {"sha": "a927788e6a44ad9931c8bc7521fdea5f4006fa5c", "filename": "src/tools/clippy/clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -8,13 +8,13 @@\n //! Thank you!\n //! ~The `INTERNAL_METADATA_COLLECTOR` lint\n \n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::HirId;\n use rustc_lint::{LateContext, Lint, LintContext};\n use rustc_span::source_map::{MultiSpan, Span};\n use std::env;\n \n-fn docs_link(diag: &mut DiagnosticBuilder<'_>, lint: &'static Lint) {\n+fn docs_link(diag: &mut Diagnostic, lint: &'static Lint) {\n     if env::var(\"CLIPPY_DISABLE_DOCS_LINKS\").is_err() {\n         if let Some(lint) = lint.name_lower().strip_prefix(\"clippy::\") {\n             diag.help(&format!(\n@@ -145,7 +145,7 @@ pub fn span_lint_and_then<C, S, F>(cx: &C, lint: &'static Lint, sp: S, msg: &str\n where\n     C: LintContext,\n     S: Into<MultiSpan>,\n-    F: FnOnce(&mut DiagnosticBuilder<'_>),\n+    F: FnOnce(&mut Diagnostic),\n {\n     cx.struct_span_lint(lint, sp, |diag| {\n         let mut diag = diag.build(msg);\n@@ -169,7 +169,7 @@ pub fn span_lint_hir_and_then(\n     hir_id: HirId,\n     sp: impl Into<MultiSpan>,\n     msg: &str,\n-    f: impl FnOnce(&mut DiagnosticBuilder<'_>),\n+    f: impl FnOnce(&mut Diagnostic),\n ) {\n     cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |diag| {\n         let mut diag = diag.build(msg);\n@@ -219,7 +219,7 @@ pub fn span_lint_and_sugg<'a, T: LintContext>(\n /// appear once per\n /// replacement. In human-readable format though, it only appears once before\n /// the whole suggestion.\n-pub fn multispan_sugg<I>(diag: &mut DiagnosticBuilder<'_>, help_msg: &str, sugg: I)\n+pub fn multispan_sugg<I>(diag: &mut Diagnostic, help_msg: &str, sugg: I)\n where\n     I: IntoIterator<Item = (Span, String)>,\n {\n@@ -232,7 +232,7 @@ where\n /// multiple spans. This is tracked in issue [rustfix#141](https://github.com/rust-lang/rustfix/issues/141).\n /// Suggestions with multiple spans will be silently ignored.\n pub fn multispan_sugg_with_applicability<I>(\n-    diag: &mut DiagnosticBuilder<'_>,\n+    diag: &mut Diagnostic,\n     help_msg: &str,\n     applicability: Applicability,\n     sugg: I,"}, {"sha": "63c442e70085a1015825b4731f3b079ccd985af1", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -673,8 +673,8 @@ fn indentation<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n         })\n }\n \n-/// Convenience extension trait for `DiagnosticBuilder`.\n-pub trait DiagnosticBuilderExt<T: LintContext> {\n+/// Convenience extension trait for `Diagnostic`.\n+pub trait DiagnosticExt<T: LintContext> {\n     /// Suggests to add an attribute to an item.\n     ///\n     /// Correctly handles indentation of the attribute and item.\n@@ -721,7 +721,7 @@ pub trait DiagnosticBuilderExt<T: LintContext> {\n     fn suggest_remove_item(&mut self, cx: &T, item: Span, msg: &str, applicability: Applicability);\n }\n \n-impl<T: LintContext> DiagnosticBuilderExt<T> for rustc_errors::DiagnosticBuilder<'_> {\n+impl<T: LintContext> DiagnosticExt<T> for rustc_errors::Diagnostic {\n     fn suggest_item_with_attr<D: Display + ?Sized>(\n         &mut self,\n         cx: &T,"}, {"sha": "d4bddd957858ff30eb732c8999ada0f28b9faed0", "filename": "src/tools/rustfmt/src/modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -439,7 +439,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                 }\n             }\n             Err(mod_err) if !mods_outside_ast.is_empty() => {\n-                if let ModError::ParserError(mut e) = mod_err {\n+                if let ModError::ParserError(e) = mod_err {\n                     e.cancel();\n                 }\n                 Ok(Some(SubModKind::MultiExternal(mods_outside_ast)))"}, {"sha": "306b6bb745ee6d0221571f17ccc32fdad0986336", "filename": "src/tools/rustfmt/src/parse/macros/cfg_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -57,7 +57,7 @@ fn parse_cfg_if_inner<'a>(\n             let item = match parser.parse_item(ForceCollect::No) {\n                 Ok(Some(item_ptr)) => item_ptr.into_inner(),\n                 Ok(None) => continue,\n-                Err(mut err) => {\n+                Err(err) => {\n                     err.cancel();\n                     parser.sess.span_diagnostic.reset_err_count();\n                     return Err("}, {"sha": "4c541de04be0894d4a53ef53890043105b345630", "filename": "src/tools/rustfmt/src/parse/macros/lazy_static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Flazy_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Flazy_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Flazy_static.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn parse_lazy_static(\n                         val\n                     }\n                 }\n-                Err(mut err) => {\n+                Err(err) => {\n                     err.cancel();\n                     parser.sess.span_diagnostic.reset_err_count();\n                     return None;"}, {"sha": "fd738908170f86ef5264737ae24ab466228c146e", "filename": "src/tools/rustfmt/src/parse/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -36,7 +36,7 @@ fn parse_macro_arg<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n                         return Some(MacroArg::$macro_arg($f(x)?));\n                     }\n                 }\n-                Err(mut e) => {\n+                Err(e) => {\n                     e.cancel();\n                     parser.sess.span_diagnostic.reset_err_count();\n                 }"}, {"sha": "f0944a88d2f2222be8cb519efd2c7c5f70b46aee", "filename": "src/tools/rustfmt/src/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -115,7 +115,7 @@ impl<'a> Parser<'a> {\n             match parser.parse_mod(&TokenKind::Eof) {\n                 Ok(result) => Some(result),\n                 Err(mut e) => {\n-                    sess.emit_or_cancel_diagnostic(&mut e);\n+                    e.emit();\n                     if sess.can_reset_errors() {\n                         sess.reset_errors();\n                     }"}, {"sha": "40a6d708d8cccb25911c89b0cf85295481c698ad", "filename": "src/tools/rustfmt/src/parse/session.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs?ref=d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "patch": "@@ -60,7 +60,7 @@ impl Emitter for SilentOnIgnoredFilesEmitter {\n         None\n     }\n     fn emit_diagnostic(&mut self, db: &Diagnostic) {\n-        if db.level == DiagnosticLevel::Fatal {\n+        if db.level() == DiagnosticLevel::Fatal {\n             return self.handle_non_ignoreable_error(db);\n         }\n         if let Some(primary_span) = &db.span.primary_span() {\n@@ -230,17 +230,6 @@ impl ParseSess {\n         }\n     }\n \n-    pub(crate) fn emit_or_cancel_diagnostic(&self, diagnostic: &mut Diagnostic) {\n-        self.parse_sess.span_diagnostic.emit_diagnostic(diagnostic);\n-        // The Handler will check whether the diagnostic should be emitted\n-        // based on the user's rustfmt configuration and the originating file\n-        // that caused the parser error. If the Handler determined it should skip\n-        // emission then we need to ensure the diagnostic is cancelled.\n-        if !diagnostic.cancelled() {\n-            diagnostic.cancel();\n-        }\n-    }\n-\n     pub(super) fn can_reset_errors(&self) -> bool {\n         self.can_reset_errors.load(Ordering::Acquire)\n     }\n@@ -292,7 +281,7 @@ mod tests {\n         use super::*;\n         use crate::config::IgnoreList;\n         use crate::utils::mk_sp;\n-        use rustc_span::{FileName as SourceMapFileName, MultiSpan, RealFileName, DUMMY_SP};\n+        use rustc_span::{FileName as SourceMapFileName, MultiSpan, RealFileName};\n         use std::path::PathBuf;\n         use std::sync::atomic::AtomicU32;\n \n@@ -310,16 +299,12 @@ mod tests {\n         }\n \n         fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {\n-            Diagnostic {\n-                level,\n-                code: None,\n-                message: vec![],\n-                children: vec![],\n-                suggestions: Ok(vec![]),\n-                span: span.unwrap_or_else(MultiSpan::new),\n-                sort_span: DUMMY_SP,\n-                is_lint: false,\n+            let mut diag = Diagnostic::new(level, \"\");\n+            diag.message.clear();\n+            if let Some(span) = span {\n+                diag.span = span;\n             }\n+            diag\n         }\n \n         fn build_emitter("}]}