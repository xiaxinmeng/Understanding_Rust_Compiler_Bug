{"sha": "0892a7380b1bde39b979a00de1d11cef3357a717", "node_id": "C_kwDOAAsO6NoAKDA4OTJhNzM4MGIxYmRlMzliOTc5YTAwZGUxZDExY2VmMzM1N2E3MTc", "commit": {"author": {"name": "Kyle Matsuda", "email": "kyle.yoshio.matsuda@gmail.com", "date": "2023-04-17T21:57:29Z"}, "committer": {"name": "Kyle Matsuda", "email": "kyle.yoshio.matsuda@gmail.com", "date": "2023-04-20T18:36:50Z"}, "message": "change usages of explicit_item_bounds to bound_explicit_item_bounds", "tree": {"sha": "ac39d858274627a769cde8675b05744c005fba57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac39d858274627a769cde8675b05744c005fba57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0892a7380b1bde39b979a00de1d11cef3357a717", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0892a7380b1bde39b979a00de1d11cef3357a717", "html_url": "https://github.com/rust-lang/rust/commit/0892a7380b1bde39b979a00de1d11cef3357a717", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0892a7380b1bde39b979a00de1d11cef3357a717/comments", "author": {"login": "kylematsuda", "id": 17287790, "node_id": "MDQ6VXNlcjE3Mjg3Nzkw", "avatar_url": "https://avatars.githubusercontent.com/u/17287790?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kylematsuda", "html_url": "https://github.com/kylematsuda", "followers_url": "https://api.github.com/users/kylematsuda/followers", "following_url": "https://api.github.com/users/kylematsuda/following{/other_user}", "gists_url": "https://api.github.com/users/kylematsuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/kylematsuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kylematsuda/subscriptions", "organizations_url": "https://api.github.com/users/kylematsuda/orgs", "repos_url": "https://api.github.com/users/kylematsuda/repos", "events_url": "https://api.github.com/users/kylematsuda/events{/privacy}", "received_events_url": "https://api.github.com/users/kylematsuda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kylematsuda", "id": 17287790, "node_id": "MDQ6VXNlcjE3Mjg3Nzkw", "avatar_url": "https://avatars.githubusercontent.com/u/17287790?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kylematsuda", "html_url": "https://github.com/kylematsuda", "followers_url": "https://api.github.com/users/kylematsuda/followers", "following_url": "https://api.github.com/users/kylematsuda/following{/other_user}", "gists_url": "https://api.github.com/users/kylematsuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/kylematsuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kylematsuda/subscriptions", "organizations_url": "https://api.github.com/users/kylematsuda/orgs", "repos_url": "https://api.github.com/users/kylematsuda/repos", "events_url": "https://api.github.com/users/kylematsuda/events{/privacy}", "received_events_url": "https://api.github.com/users/kylematsuda/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a57fa08f483620c2b4f33c6b5dcdbbf2b4c08ad8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a57fa08f483620c2b4f33c6b5dcdbbf2b4c08ad8", "html_url": "https://github.com/rust-lang/rust/commit/a57fa08f483620c2b4f33c6b5dcdbbf2b4c08ad8"}], "stats": {"total": 126, "additions": 76, "deletions": 50}, "files": [{"sha": "680562ccf622938c35a41d39a064caeecec388eb", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -319,9 +319,12 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n             selftys: vec![],\n         };\n         let prohibit_opaque = tcx\n-            .explicit_item_bounds(def_id)\n-            .iter()\n-            .try_for_each(|(predicate, _)| predicate.visit_with(&mut visitor));\n+            .bound_explicit_item_bounds(def_id.to_def_id())\n+            .transpose_iter()\n+            .try_for_each(|bound| {\n+                let predicate = bound.map_bound(|&(predicate, _)| predicate).subst_identity();\n+                predicate.visit_with(&mut visitor)\n+            });\n \n         if let Some(ty) = prohibit_opaque.break_value() {\n             visitor.visit_item(&item);"}, {"sha": "9b89e51bacfc98422112063ff4855cb38b8e83fd", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -360,7 +360,10 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                             tcx,\n                             param_env,\n                             item_def_id,\n-                            tcx.explicit_item_bounds(item_def_id).to_vec(),\n+                            tcx.bound_explicit_item_bounds(item_def_id.to_def_id())\n+                                .transpose_iter()\n+                                .map(|bound| bound.map_bound(|b| *b).subst_identity())\n+                                .collect::<Vec<_>>(),\n                             &FxIndexSet::default(),\n                             gat_def_id.def_id,\n                             gat_generics,\n@@ -1122,10 +1125,11 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n /// Assuming the defaults are used, check that all predicates (bounds on the\n /// assoc type and where clauses on the trait) hold.\n fn check_associated_type_bounds(wfcx: &WfCheckingCtxt<'_, '_>, item: ty::AssocItem, span: Span) {\n-    let bounds = wfcx.tcx().explicit_item_bounds(item.def_id);\n+    let bounds = wfcx.tcx().bound_explicit_item_bounds(item.def_id);\n \n     debug!(\"check_associated_type_bounds: bounds={:?}\", bounds);\n-    let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n+    let wf_obligations = bounds.transpose_iter().flat_map(|b| {\n+        let (bound, bound_span) = b.map_bound(|b| *b).subst_identity();\n         let normalized_bound = wfcx.normalize(span, None, bound);\n         traits::wf::predicate_obligations(\n             wfcx.infcx,"}, {"sha": "5b2f1419a6921d6ee1cd07f1add8574f58ad96ac", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -130,9 +130,10 @@ pub(super) fn item_bounds(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> ty::EarlyBinder<&'_ ty::List<ty::Predicate<'_>>> {\n-    let bounds = tcx.mk_predicates_from_iter(util::elaborate(\n-        tcx,\n-        tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n-    ));\n-    ty::EarlyBinder(bounds)\n+    tcx.bound_explicit_item_bounds(def_id).map_bound(|bounds| {\n+        tcx.mk_predicates_from_iter(util::elaborate(\n+            tcx,\n+            bounds.iter().map(|&(bound, _span)| bound),\n+        ))\n+    })\n }"}, {"sha": "1d17af8da8538c943b4e38e425001eca24606381", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -571,7 +571,8 @@ fn check_must_not_suspend_ty<'tcx>(\n         // FIXME: support adding the attribute to TAITs\n         ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n             let mut has_emitted = false;\n-            for &(predicate, _) in fcx.tcx.explicit_item_bounds(def) {\n+            for bound in fcx.tcx.bound_explicit_item_bounds(def).transpose_iter() {\n+                let predicate = bound.map_bound(|&(predicate, _)| predicate).subst_identity();\n                 // We only look at the `DefId`, so it is safe to skip the binder here.\n                 if let ty::PredicateKind::Clause(ty::Clause::Trait(ref poly_trait_predicate)) =\n                     predicate.kind().skip_binder()"}, {"sha": "5c408c749456b3f780e7e57a0aab12a898eaf3c7", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -74,7 +74,9 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n         // For every projection predicate in the opaque type's explicit bounds,\n         // check that the type that we're assigning actually satisfies the bounds\n         // of the associated type.\n-        for &(pred, pred_span) in cx.tcx.explicit_item_bounds(def_id) {\n+        for bound in cx.tcx.bound_explicit_item_bounds(def_id).transpose_iter() {\n+            let (pred, pred_span) = bound.map_bound(|b| *b).subst_identity();\n+\n             // Liberate bound regions in the predicate since we\n             // don't actually care about lifetimes in this check.\n             let predicate = cx.tcx.liberate_late_bound_regions(def_id, pred.kind());"}, {"sha": "7e4852e3d3bf04e143672b8fad0c07538c708822", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -254,23 +254,29 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 }\n                 ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n                 ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n-                    elaborate(cx.tcx, cx.tcx.explicit_item_bounds(def).iter().cloned())\n-                        // We only care about self bounds for the impl-trait\n-                        .filter_only_self()\n-                        .find_map(|(pred, _span)| {\n-                            // We only look at the `DefId`, so it is safe to skip the binder here.\n-                            if let ty::PredicateKind::Clause(ty::Clause::Trait(\n-                                ref poly_trait_predicate,\n-                            )) = pred.kind().skip_binder()\n-                            {\n-                                let def_id = poly_trait_predicate.trait_ref.def_id;\n-\n-                                is_def_must_use(cx, def_id, span)\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                        .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n+                    elaborate(\n+                        cx.tcx,\n+                        cx.tcx\n+                            .bound_explicit_item_bounds(def)\n+                            .transpose_iter()\n+                            .map(|bound| bound.map_bound(|b| *b).subst_identity()),\n+                    )\n+                    // We only care about self bounds for the impl-trait\n+                    .filter_only_self()\n+                    .find_map(|(pred, _span)| {\n+                        // We only look at the `DefId`, so it is safe to skip the binder here.\n+                        if let ty::PredicateKind::Clause(ty::Clause::Trait(\n+                            ref poly_trait_predicate,\n+                        )) = pred.kind().skip_binder()\n+                        {\n+                            let def_id = poly_trait_predicate.trait_ref.def_id;\n+\n+                            is_def_must_use(cx, def_id, span)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n                 }\n                 ty::Dynamic(binders, _, _) => binders.iter().find_map(|predicate| {\n                     if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder()"}, {"sha": "f65117f4934d7ab639f4ed375fa7049037f13899", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -1611,7 +1611,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = ty.kind() else { return false };\n         let future_trait = self.require_lang_item(LangItem::Future, None);\n \n-        self.explicit_item_bounds(def_id).iter().any(|(predicate, _)| {\n+        self.bound_explicit_item_bounds(*def_id).skip_binder().iter().any(|(predicate, _)| {\n             let ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) = predicate.kind().skip_binder() else {\n                 return false;\n             };"}, {"sha": "c2c3d2dda3f4c600c30773a822a12f4405b51299", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -1800,7 +1800,9 @@ fn check_must_not_suspend_ty<'tcx>(\n         // FIXME: support adding the attribute to TAITs\n         ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n             let mut has_emitted = false;\n-            for &(predicate, _) in tcx.explicit_item_bounds(def) {\n+            for bound in tcx.bound_explicit_item_bounds(def).transpose_iter() {\n+                let predicate = bound.map_bound(|&(pred, _)| pred).subst_identity();\n+\n                 // We only look at the `DefId`, so it is safe to skip the binder here.\n                 if let ty::PredicateKind::Clause(ty::Clause::Trait(ref poly_trait_predicate)) =\n                     predicate.kind().skip_binder()"}, {"sha": "cd48280526f8c26a2508ba00dc898aad6a35da27", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -269,7 +269,7 @@ where\n                     // and are visited by shallow visitors.\n                     self.visit_predicates(ty::GenericPredicates {\n                         parent: None,\n-                        predicates: tcx.explicit_item_bounds(def_id),\n+                        predicates: tcx.bound_explicit_item_bounds(def_id).skip_binder(),\n                     })?;\n                 }\n             }\n@@ -1784,7 +1784,10 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n     fn bounds(&mut self) -> &mut Self {\n         self.visit_predicates(ty::GenericPredicates {\n             parent: None,\n-            predicates: self.tcx.explicit_item_bounds(self.item_def_id),\n+            predicates: self\n+                .tcx\n+                .bound_explicit_item_bounds(self.item_def_id.to_def_id())\n+                .skip_binder(),\n         });\n         self\n     }"}, {"sha": "b7ca37c058ccbb018a903eb72d85b6fcbf3b28b8", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -297,8 +297,9 @@ fn bounds_reference_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span\n     tcx.associated_items(trait_def_id)\n         .in_definition_order()\n         .filter(|item| item.kind == ty::AssocKind::Type)\n-        .flat_map(|item| tcx.explicit_item_bounds(item.def_id))\n-        .filter_map(|pred_span| predicate_references_self(tcx, *pred_span))\n+        .flat_map(|item| tcx.bound_explicit_item_bounds(item.def_id).transpose_iter())\n+        .map(|bound| bound.map_bound(|b| *b).subst_identity())\n+        .filter_map(|pred_span| predicate_references_self(tcx, pred_span))\n         .collect()\n }\n "}, {"sha": "25031b0102243d0d1adafa55c7473be85fb71201", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -421,9 +421,9 @@ fn clean_projection<'tcx>(\n     if cx.tcx.is_impl_trait_in_trait(ty.skip_binder().def_id) {\n         let bounds = cx\n             .tcx\n-            .explicit_item_bounds(ty.skip_binder().def_id)\n-            .iter()\n-            .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, ty.skip_binder().substs))\n+            .bound_explicit_item_bounds(ty.skip_binder().def_id)\n+            .subst_iter_copied(cx.tcx, ty.skip_binder().substs)\n+            .map(|(pred, _)| pred)\n             .collect::<Vec<_>>();\n         return clean_middle_opaque_bounds(cx, bounds);\n     }\n@@ -1315,10 +1315,13 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n             }\n \n             if let ty::TraitContainer = assoc_item.container {\n-                let bounds = tcx.explicit_item_bounds(assoc_item.def_id);\n+                let bounds = tcx\n+                    .bound_explicit_item_bounds(assoc_item.def_id)\n+                    .transpose_iter()\n+                    .map(|bound| bound.map_bound(|b| *b).subst_identity());\n                 let predicates = tcx.explicit_predicates_of(assoc_item.def_id).predicates;\n                 let predicates =\n-                    tcx.arena.alloc_from_iter(bounds.into_iter().chain(predicates).copied());\n+                    tcx.arena.alloc_from_iter(bounds.chain(predicates.iter().copied()));\n                 let mut generics = clean_ty_generics(\n                     cx,\n                     tcx.generics_of(assoc_item.def_id),\n@@ -1844,9 +1847,9 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             // by looking up the bounds associated with the def_id.\n             let bounds = cx\n                 .tcx\n-                .explicit_item_bounds(def_id)\n-                .iter()\n-                .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, substs))\n+                .bound_explicit_item_bounds(def_id)\n+                .subst_iter_copied(cx.tcx, substs)\n+                .map(|(bound, _)| bound)\n                 .collect::<Vec<_>>();\n             clean_middle_opaque_bounds(cx, bounds)\n         }"}, {"sha": "73ae2406f9dbc132ab5e40b73fc97d87a5aec9ee", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, AliasTy, Clause, EarlyBinder, PredicateKind};\n+use rustc_middle::ty::{self, AliasTy, Clause, PredicateKind};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{sym, Span};\n@@ -64,10 +64,9 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n         }\n         let ret_ty = return_ty(cx, cx.tcx.hir().local_def_id_to_hir_id(fn_def_id).expect_owner());\n         if let ty::Alias(ty::Opaque, AliasTy { def_id, substs, .. }) = *ret_ty.kind() {\n-            let preds = cx.tcx.explicit_item_bounds(def_id);\n+            let preds = cx.tcx.bound_explicit_item_bounds(def_id);\n             let mut is_future = false;\n-            for &(p, _span) in preds {\n-                let p = EarlyBinder(p).subst(cx.tcx, substs);\n+            for (p, _span) in preds.subst_iter_copied(cx.tcx, substs) {\n                 if let Some(trait_pred) = p.to_opt_poly_trait_pred() {\n                     if Some(trait_pred.skip_binder().trait_ref.def_id) == cx.tcx.lang_items().future_trait() {\n                         is_future = true;"}, {"sha": "058f6b0306dcf91adf0a7e10d0463c6d63f96994", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0892a7380b1bde39b979a00de1d11cef3357a717/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0892a7380b1bde39b979a00de1d11cef3357a717/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=0892a7380b1bde39b979a00de1d11cef3357a717", "patch": "@@ -90,7 +90,8 @@ pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'\n                         return false;\n                     }\n \n-                    for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n+                    for bound in cx.tcx.bound_explicit_item_bounds(def_id).transpose_iter() {\n+                        let (predicate, _span) = bound.map_bound(|b| *b).subst_identity();\n                         match predicate.kind().skip_binder() {\n                             // For `impl Trait<U>`, it will register a predicate of `T: Trait<U>`, so we go through\n                             // and check substituions to find `U`.\n@@ -267,7 +268,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         },\n         ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) => {\n-            for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n+            for (predicate, _) in cx.tcx.bound_explicit_item_bounds(*def_id).skip_binder() {\n                 if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) = predicate.kind().skip_binder() {\n                     if cx.tcx.has_attr(trait_predicate.trait_ref.def_id, sym::must_use) {\n                         return true;"}]}