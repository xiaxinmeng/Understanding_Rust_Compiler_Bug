{"sha": "8ccc89bc312caa65ca46b55b47492abdd5b6910a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjY2M4OWJjMzEyY2FhNjVjYTQ2YjU1YjQ3NDkyYWJkZDViNjkxMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-05T09:28:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-05T09:28:07Z"}, "message": "Auto merge of #82777 - GuillaumeGomez:rollup-etcsupl, r=GuillaumeGomez\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #76716 (Don't warn for `missing_doc_examples` when item is #[doc(hidden)])\n - #82088 (Shorten html::render)\n - #82690 (Update rustdoc documentation)\n - #82752 (Add a regression test for issue-81712)\n - #82765 (Fix polymorphization ICE on associated types in trait decls using const generics in bounds)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "21aae974b62d722b3d7f25fc325231a4fe863792", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21aae974b62d722b3d7f25fc325231a4fe863792"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ccc89bc312caa65ca46b55b47492abdd5b6910a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ccc89bc312caa65ca46b55b47492abdd5b6910a", "html_url": "https://github.com/rust-lang/rust/commit/8ccc89bc312caa65ca46b55b47492abdd5b6910a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ccc89bc312caa65ca46b55b47492abdd5b6910a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0d66b54fb3acc2125972b88ff543a2c04d14af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0d66b54fb3acc2125972b88ff543a2c04d14af5", "html_url": "https://github.com/rust-lang/rust/commit/a0d66b54fb3acc2125972b88ff543a2c04d14af5"}, {"sha": "f74231fd27b6eced577d6e53e955b50754006ae9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f74231fd27b6eced577d6e53e955b50754006ae9", "html_url": "https://github.com/rust-lang/rust/commit/f74231fd27b6eced577d6e53e955b50754006ae9"}], "stats": {"total": 5802, "additions": 2939, "deletions": 2863}, "files": [{"sha": "f2f7242a8fdde7adaceb8c338678e4bdbc5572d5", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -438,18 +438,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn optimized_mir_or_const_arg_mir(\n-        self,\n-        def: ty::WithOptConstParam<DefId>,\n-    ) -> &'tcx Body<'tcx> {\n-        if let Some((did, param_did)) = def.as_const_arg() {\n-            self.mir_for_ctfe_of_const_arg((did, param_did))\n-        } else {\n-            self.optimized_mir(def.did)\n-        }\n-    }\n-\n     #[inline]\n     pub fn mir_for_ctfe_opt_const_arg(self, def: ty::WithOptConstParam<DefId>) -> &'tcx Body<'tcx> {\n         if let Some((did, param_did)) = def.as_const_arg() {"}, {"sha": "23cedfd499eaa2e9d86fd2e6d4f2b1daaf1bc72d", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -499,7 +499,7 @@ impl<'tcx> Instance<'tcx> {\n     }\n \n     /// Returns a new `Instance` where generic parameters in `instance.substs` are replaced by\n-    /// identify parameters if they are determined to be unused in `instance.def`.\n+    /// identity parameters if they are determined to be unused in `instance.def`.\n     pub fn polymorphize(self, tcx: TyCtxt<'tcx>) -> Self {\n         debug!(\"polymorphize: running polymorphization analysis\");\n         if !tcx.sess.opts.debugging_opts.polymorphize {"}, {"sha": "c27a337554e675342504189171201f35f6eb07b3", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -2963,7 +2963,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                 | DefKind::AnonConst => self.mir_for_ctfe_opt_const_arg(def),\n                 // If the caller wants `mir_for_ctfe` of a function they should not be using\n                 // `instance_mir`, so we'll assume const fn also wants the optimized version.\n-                _ => self.optimized_mir_or_const_arg_mir(def),\n+                _ => {\n+                    assert_eq!(def.const_param_did, None);\n+                    self.optimized_mir(def.did)\n+                }\n             },\n             ty::InstanceDef::VtableShim(..)\n             | ty::InstanceDef::ReifyShim(..)"}, {"sha": "05b0e3a7dab954ba1114ff6a80736ae90c26ac4d", "filename": "compiler/rustc_mir/src/monomorphize/polymorphize.rs", "status": "modified", "additions": 64, "deletions": 40, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -30,9 +30,8 @@ pub fn provide(providers: &mut Providers) {\n /// Determine which generic parameters are used by the function/method/closure represented by\n /// `def_id`. Returns a bitset where bits representing unused parameters are set (`is_empty`\n /// indicates all parameters are used).\n+#[instrument(skip(tcx))]\n fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n-    debug!(\"unused_generic_params({:?})\", def_id);\n-\n     if !tcx.sess.opts.debugging_opts.polymorphize {\n         // If polymorphization disabled, then all parameters are used.\n         return FiniteBitSet::new_empty();\n@@ -46,7 +45,7 @@ fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n     }\n \n     let generics = tcx.generics_of(def_id);\n-    debug!(\"unused_generic_params: generics={:?}\", generics);\n+    debug!(?generics);\n \n     // Exit early when there are no parameters to be unused.\n     if generics.count() == 0 {\n@@ -57,11 +56,11 @@ fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n     let context = tcx.hir().body_const_context(def_id.expect_local());\n     match context {\n         Some(ConstContext::ConstFn) | None if !tcx.is_mir_available(def_id) => {\n-            debug!(\"unused_generic_params: (no mir available) def_id={:?}\", def_id);\n+            debug!(\"no mir available\");\n             return FiniteBitSet::new_empty();\n         }\n         Some(_) if !tcx.is_ctfe_mir_available(def_id) => {\n-            debug!(\"unused_generic_params: (no ctfe mir available) def_id={:?}\", def_id);\n+            debug!(\"no ctfe mir available\");\n             return FiniteBitSet::new_empty();\n         }\n         _ => {}\n@@ -72,9 +71,9 @@ fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n         generics.count().try_into().expect(\"more generic parameters than can fit into a `u32`\");\n     let mut unused_parameters = FiniteBitSet::<u32>::new_empty();\n     unused_parameters.set_range(0..generics_count);\n-    debug!(\"unused_generic_params: (start) unused_parameters={:?}\", unused_parameters);\n+    debug!(?unused_parameters, \"(start)\");\n     mark_used_by_default_parameters(tcx, def_id, generics, &mut unused_parameters);\n-    debug!(\"unused_generic_params: (after default) unused_parameters={:?}\", unused_parameters);\n+    debug!(?unused_parameters, \"(after default)\");\n \n     // Visit MIR and accumululate used generic parameters.\n     let body = match context {\n@@ -85,10 +84,10 @@ fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n     };\n     let mut vis = MarkUsedGenericParams { tcx, def_id, unused_parameters: &mut unused_parameters };\n     vis.visit_body(body);\n-    debug!(\"unused_generic_params: (after visitor) unused_parameters={:?}\", unused_parameters);\n+    debug!(?unused_parameters, \"(after visitor)\");\n \n     mark_used_by_predicates(tcx, def_id, &mut unused_parameters);\n-    debug!(\"unused_generic_params: (end) unused_parameters={:?}\", unused_parameters);\n+    debug!(?unused_parameters, \"(end)\");\n \n     // Emit errors for debugging and testing if enabled.\n     if !unused_parameters.is_empty() {\n@@ -101,24 +100,55 @@ fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n /// Some parameters are considered used-by-default, such as non-generic parameters and the dummy\n /// generic parameters from closures, this function marks them as used. `leaf_is_closure` should\n /// be `true` if the item that `unused_generic_params` was invoked on is a closure.\n+#[instrument(skip(tcx, def_id, generics, unused_parameters))]\n fn mark_used_by_default_parameters<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     generics: &'tcx ty::Generics,\n     unused_parameters: &mut FiniteBitSet<u32>,\n ) {\n-    if !tcx.is_trait(def_id) && (tcx.is_closure(def_id) || tcx.type_of(def_id).is_generator()) {\n-        for param in &generics.params {\n-            debug!(\"mark_used_by_default_parameters: (closure/gen) param={:?}\", param);\n-            unused_parameters.clear(param.index);\n-        }\n-    } else {\n-        for param in &generics.params {\n-            debug!(\"mark_used_by_default_parameters: (other) param={:?}\", param);\n-            if let ty::GenericParamDefKind::Lifetime = param.kind {\n+    match tcx.def_kind(def_id) {\n+        DefKind::Closure | DefKind::Generator => {\n+            for param in &generics.params {\n+                debug!(?param, \"(closure/gen)\");\n                 unused_parameters.clear(param.index);\n             }\n         }\n+        DefKind::Mod\n+        | DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Trait\n+        | DefKind::TyAlias\n+        | DefKind::ForeignTy\n+        | DefKind::TraitAlias\n+        | DefKind::AssocTy\n+        | DefKind::TyParam\n+        | DefKind::Fn\n+        | DefKind::Const\n+        | DefKind::ConstParam\n+        | DefKind::Static\n+        | DefKind::Ctor(_, _)\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::Macro(_)\n+        | DefKind::ExternCrate\n+        | DefKind::Use\n+        | DefKind::ForeignMod\n+        | DefKind::AnonConst\n+        | DefKind::OpaqueTy\n+        | DefKind::Field\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::Impl => {\n+            for param in &generics.params {\n+                debug!(?param, \"(other)\");\n+                if let ty::GenericParamDefKind::Lifetime = param.kind {\n+                    unused_parameters.clear(param.index);\n+                }\n+            }\n+        }\n     }\n \n     if let Some(parent) = generics.parent {\n@@ -128,23 +158,20 @@ fn mark_used_by_default_parameters<'tcx>(\n \n /// Search the predicates on used generic parameters for any unused generic parameters, and mark\n /// those as used.\n+#[instrument(skip(tcx, def_id))]\n fn mark_used_by_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     unused_parameters: &mut FiniteBitSet<u32>,\n ) {\n     let def_id = tcx.closure_base_def_id(def_id);\n     let predicates = tcx.explicit_predicates_of(def_id);\n-    debug!(\"mark_used_by_predicates: predicates_of={:?}\", predicates);\n \n     let mut current_unused_parameters = FiniteBitSet::new_empty();\n     // Run to a fixed point to support `where T: Trait<U>, U: Trait<V>`, starting with an empty\n     // bit set so that this is skipped if all parameters are already used.\n     while current_unused_parameters != *unused_parameters {\n-        debug!(\n-            \"mark_used_by_predicates: current_unused_parameters={:?} = unused_parameters={:?}\",\n-            current_unused_parameters, unused_parameters\n-        );\n+        debug!(?current_unused_parameters, ?unused_parameters);\n         current_unused_parameters = *unused_parameters;\n \n         for (predicate, _) in predicates.predicates {\n@@ -169,13 +196,13 @@ fn mark_used_by_predicates<'tcx>(\n \n /// Emit errors for the function annotated by `#[rustc_polymorphize_error]`, labelling each generic\n /// parameter which was unused.\n+#[instrument(skip(tcx, generics))]\n fn emit_unused_generic_params_error<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     generics: &'tcx ty::Generics,\n     unused_parameters: &FiniteBitSet<u32>,\n ) {\n-    debug!(\"emit_unused_generic_params_error: def_id={:?}\", def_id);\n     let base_def_id = tcx.closure_base_def_id(def_id);\n     if !tcx\n         .get_attrs(base_def_id)\n@@ -185,7 +212,6 @@ fn emit_unused_generic_params_error<'tcx>(\n         return;\n     }\n \n-    debug!(\"emit_unused_generic_params_error: unused_parameters={:?}\", unused_parameters);\n     let fn_span = match tcx.opt_item_name(def_id) {\n         Some(ident) => ident.span,\n         _ => tcx.def_span(def_id),\n@@ -197,7 +223,7 @@ fn emit_unused_generic_params_error<'tcx>(\n     while let Some(generics) = next_generics {\n         for param in &generics.params {\n             if unused_parameters.contains(param.index).unwrap_or(false) {\n-                debug!(\"emit_unused_generic_params_error: param={:?}\", param);\n+                debug!(?param);\n                 let def_span = tcx.def_span(param.def_id);\n                 err.span_label(def_span, &format!(\"generic parameter `{}` is unused\", param.name));\n             }\n@@ -219,33 +245,31 @@ struct MarkUsedGenericParams<'a, 'tcx> {\n impl<'a, 'tcx> MarkUsedGenericParams<'a, 'tcx> {\n     /// Invoke `unused_generic_params` on a body contained within the current item (e.g.\n     /// a closure, generator or constant).\n+    #[instrument(skip(self, def_id, substs))]\n     fn visit_child_body(&mut self, def_id: DefId, substs: SubstsRef<'tcx>) {\n         let unused = self.tcx.unused_generic_params(def_id);\n-        debug!(\n-            \"visit_child_body: unused_parameters={:?} unused={:?}\",\n-            self.unused_parameters, unused\n-        );\n+        debug!(?self.unused_parameters, ?unused);\n         for (i, arg) in substs.iter().enumerate() {\n             let i = i.try_into().unwrap();\n             if !unused.contains(i).unwrap_or(false) {\n                 arg.visit_with(self);\n             }\n         }\n-        debug!(\"visit_child_body: unused_parameters={:?}\", self.unused_parameters);\n+        debug!(?self.unused_parameters);\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n+    #[instrument(skip(self, local))]\n     fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n-        debug!(\"visit_local_decl: local_decl={:?}\", local_decl);\n         if local == Local::from_usize(1) {\n             let def_kind = self.tcx.def_kind(self.def_id);\n             if matches!(def_kind, DefKind::Closure | DefKind::Generator) {\n                 // Skip visiting the closure/generator that is currently being processed. This only\n                 // happens because the first argument to the closure is a reference to itself and\n                 // that will call `visit_substs`, resulting in each generic parameter captured being\n                 // considered used by default.\n-                debug!(\"visit_local_decl: skipping closure substs\");\n+                debug!(\"skipping closure substs\");\n                 return;\n             }\n         }\n@@ -263,15 +287,15 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n+    #[instrument(skip(self))]\n     fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\"visit_const: c={:?}\", c);\n         if !c.has_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n \n         match c.val {\n             ty::ConstKind::Param(param) => {\n-                debug!(\"visit_const: param={:?}\", param);\n+                debug!(?param);\n                 self.unused_parameters.clear(param.index);\n                 ControlFlow::CONTINUE\n             }\n@@ -296,15 +320,15 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self))]\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\"visit_ty: ty={:?}\", ty);\n         if !ty.has_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n \n         match *ty.kind() {\n             ty::Closure(def_id, substs) | ty::Generator(def_id, substs, ..) => {\n-                debug!(\"visit_ty: def_id={:?}\", def_id);\n+                debug!(?def_id);\n                 // Avoid cycle errors with generators.\n                 if def_id == self.def_id {\n                     return ControlFlow::CONTINUE;\n@@ -316,7 +340,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n                 ControlFlow::CONTINUE\n             }\n             ty::Param(param) => {\n-                debug!(\"visit_ty: param={:?}\", param);\n+                debug!(?param);\n                 self.unused_parameters.clear(param.index);\n                 ControlFlow::CONTINUE\n             }\n@@ -333,8 +357,8 @@ struct HasUsedGenericParams<'a> {\n impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a> {\n     type BreakTy = ();\n \n+    #[instrument(skip(self))]\n     fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\"visit_const: c={:?}\", c);\n         if !c.has_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n@@ -351,8 +375,8 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a> {\n         }\n     }\n \n+    #[instrument(skip(self))]\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\"visit_ty: ty={:?}\", ty);\n         if !ty.has_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }"}, {"sha": "ae94527e2b4ca80ee5dfb25d6722ebe71235e161", "filename": "src/doc/rustdoc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -8,7 +8,7 @@\n - [Documentation tests](documentation-tests.md)\n - [Linking to items by name](linking-to-items-by-name.md)\n - [Lints](lints.md)\n-- [Passes](passes.md)\n - [Advanced features](advanced-features.md)\n - [Unstable features](unstable-features.md)\n+- [Passes](passes.md)\n - [References](references.md)"}, {"sha": "2e4016e24bc3fa8d81333c5f93f2f1be94ed68b1", "filename": "src/doc/rustdoc/src/command-line-arguments.md", "status": "modified", "additions": 37, "deletions": 49, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -57,23 +57,6 @@ release: 1.17.0\n LLVM version: 3.9\n ```\n \n-## `-r`/`--input-format`: input format\n-\n-This flag is currently ignored; the idea is that `rustdoc` would support various\n-input formats, and you could specify them via this flag.\n-\n-Rustdoc only supports Rust source code and Markdown input formats. If the\n-file ends in `.md` or `.markdown`, `rustdoc` treats it as a Markdown file.\n-Otherwise, it assumes that the input file is Rust.\n-\n-\n-## `-w`/`--output-format`: output format\n-\n-This flag is currently ignored; the idea is that `rustdoc` would support\n-various output formats, and you could specify them via this flag.\n-\n-Rustdoc only supports HTML output, and so this flag is redundant today.\n-\n ## `-o`/`--output`: output path\n \n Using this flag looks like this:\n@@ -100,6 +83,25 @@ By default, `rustdoc` assumes that the name of your crate is the same name\n as the `.rs` file. `--crate-name` lets you override this assumption with\n whatever name you choose.\n \n+## `--document-private-items`: Show items that are not public\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs --document-private-items\n+```\n+\n+By default, `rustdoc` only documents items that are publicly reachable.\n+\n+```rust\n+pub fn public() {} // this item is public and will documented\n+mod private { // this item is private and will not be documented\n+    pub fn unreachable() {} // this item is public, but unreachable, so it will not be documented\n+}\n+```\n+\n+`--document-private-items` documents all items, even if they're not public.\n+\n ## `-L`/`--library-path`: where to look for dependencies\n \n Using this flag looks like this:\n@@ -166,38 +168,6 @@ affect that.\n The arguments to this flag are the same as those for the `-C` flag on rustc. Run `rustc -C help` to\n get the full list.\n \n-## `--passes`: add more rustdoc passes\n-\n-Using this flag looks like this:\n-\n-```bash\n-$ rustdoc --passes list\n-$ rustdoc src/lib.rs --passes strip-priv-imports\n-```\n-\n-An argument of \"list\" will print a list of possible \"rustdoc passes\", and other\n-arguments will be the name of which passes to run in addition to the defaults.\n-\n-For more details on passes, see [the chapter on them](passes.md).\n-\n-See also `--no-defaults`.\n-\n-## `--no-defaults`: don't run default passes\n-\n-Using this flag looks like this:\n-\n-```bash\n-$ rustdoc src/lib.rs --no-defaults\n-```\n-\n-By default, `rustdoc` will run several passes over your code. This\n-removes those defaults, allowing you to use `--passes` to specify\n-exactly which passes you want.\n-\n-For more details on passes, see [the chapter on them](passes.md).\n-\n-See also `--passes`.\n-\n ## `--test`: run code examples as tests\n \n Using this flag looks like this:\n@@ -429,3 +399,21 @@ If you specify `@path` on the command-line, then it will open `path` and read\n command line options from it. These options are one per line; a blank line indicates\n an empty option. The file can use Unix or Windows style line endings, and must be\n encoded as UTF-8.\n+\n+## `--passes`: add more rustdoc passes\n+\n+This flag is **deprecated**.\n+For more details on passes, see [the chapter on them](passes.md).\n+\n+## `--no-defaults`: don't run default passes\n+\n+This flag is **deprecated**.\n+For more details on passes, see [the chapter on them](passes.md).\n+\n+## `-r`/`--input-format`: input format\n+\n+This flag is **deprecated** and **has no effect**.\n+\n+Rustdoc only supports Rust source code and Markdown input formats. If the\n+file ends in `.md` or `.markdown`, `rustdoc` treats it as a Markdown file.\n+Otherwise, it assumes that the input file is Rust."}, {"sha": "c3c3fd3068ec44757c49d1b9e39229ce968fa334", "filename": "src/doc/rustdoc/src/passes.md", "status": "modified", "additions": 5, "deletions": 82, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -3,86 +3,9 @@\n Rustdoc has a concept called \"passes\". These are transformations that\n `rustdoc` runs on your documentation before producing its final output.\n \n-In addition to the passes below, check out the docs for these flags:\n+Customizing passes is **deprecated**. The available passes are not considered stable and may\n+change in any release.\n \n-* [`--passes`](command-line-arguments.md#--passes-add-more-rustdoc-passes)\n-* [`--no-defaults`](command-line-arguments.md#--no-defaults-dont-run-default-passes)\n-\n-## Default passes\n-\n-By default, rustdoc will run some passes, namely:\n-\n-* `strip-hidden`\n-* `strip-private`\n-* `collapse-docs`\n-* `unindent-comments`\n-\n-However, `strip-private` implies `strip-priv-imports`, and so effectively,\n-all passes are run by default.\n-\n-## `strip-hidden`\n-\n-This pass implements the `#[doc(hidden)]` attribute. When this pass runs, it\n-checks each item, and if it is annotated with this attribute, it removes it\n-from `rustdoc`'s output.\n-\n-Without this pass, these items will remain in the output.\n-\n-## `unindent-comments`\n-\n-When you write a doc comment like this:\n-\n-```rust,no_run\n-/// This is a documentation comment.\n-# fn f() {}\n-```\n-\n-There's a space between the `///` and that `T`. That spacing isn't intended\n-to be a part of the output; it's there for humans, to help separate the doc\n-comment syntax from the text of the comment. This pass is what removes that\n-space.\n-\n-The exact rules are left under-specified so that we can fix issues that we find.\n-\n-Without this pass, the exact number of spaces is preserved.\n-\n-## `collapse-docs`\n-\n-With this pass, multiple `#[doc]` attributes are converted into one single\n-documentation string.\n-\n-For example:\n-\n-```rust,no_run\n-#[doc = \"This is the first line.\"]\n-#[doc = \"This is the second line.\"]\n-# fn f() {}\n-```\n-\n-Gets collapsed into a single doc string of\n-\n-```text\n-This is the first line.\n-This is the second line.\n-```\n-\n-## `strip-private`\n-\n-This removes documentation for any non-public items, so for example:\n-\n-```rust,no_run\n-/// These are private docs.\n-struct Private;\n-\n-/// These are public docs.\n-pub struct Public;\n-```\n-\n-This pass removes the docs for `Private`, since they're not public.\n-\n-This pass implies `strip-priv-imports`.\n-\n-## `strip-priv-imports`\n-\n-This is the same as `strip-private`, but for `extern crate` and `use`\n-statements instead of items.\n+In the past the most common use case for customizing passes was to omit the `strip-private` pass.\n+You can do this more easily, and without risk of the pass being changed, by passing\n+[`--document-private-items`](./unstable-features.md#--document-private-items)."}, {"sha": "7d1845dc9578e82157d81364d81e549883d8bd21", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -340,6 +340,30 @@ Some methodology notes about what rustdoc counts in this metric:\n Public items that are not documented can be seen with the built-in `missing_docs` lint. Private\n items that are not documented can be seen with Clippy's `missing_docs_in_private_items` lint.\n \n+## `-w`/`--output-format`: output format\n+\n+When using\n+[`--show-coverage`](https://doc.rust-lang.org/nightly/rustdoc/unstable-features.html#--show-coverage-get-statistics-about-code-documentation-coverage),\n+passing `--output-format json` will display the coverage information in JSON format. For example,\n+here is the JSON for a file with one documented item and one undocumented item:\n+\n+```rust\n+/// This item has documentation\n+pub fn foo() {}\n+\n+pub fn no_documentation() {}\n+```\n+\n+```json\n+{\"no_std.rs\":{\"total\":3,\"with_docs\":1,\"total_examples\":3,\"with_examples\":0}}\n+```\n+\n+Note that the third item is the crate root, which in this case is undocumented.\n+\n+When not using `--show-coverage`, `--output-format json` emits documentation in the experimental\n+[JSON format](https://github.com/rust-lang/rfcs/pull/2963). `--output-format html` has no effect,\n+and is also accepted on stable toolchains.\n+\n ### `--enable-per-target-ignores`: allow `ignore-foo` style filters for doctests\n \n Using this flag looks like this:"}, {"sha": "976168a9ac407a126802d3e72ae9376f24a12e62", "filename": "src/librustdoc/html/render/context.rs", "status": "added", "additions": 617, "deletions": 0, "changes": 617, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -0,0 +1,617 @@\n+use std::cell::RefCell;\n+use std::collections::BTreeMap;\n+use std::io;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+use std::sync::mpsc::{channel, Receiver};\n+use std::sync::Arc;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::Session;\n+use rustc_span::edition::Edition;\n+use rustc_span::source_map::FileName;\n+use rustc_span::symbol::sym;\n+\n+use super::cache::{build_index, ExternalLocation};\n+use super::print_item::{full_path, item_path, print_item};\n+use super::write_shared::write_shared;\n+use super::{\n+    print_sidebar, settings, AllTypes, NameDoc, SharedContext, StylePath, BASIC_KEYWORDS,\n+    CURRENT_DEPTH, INITIAL_IDS,\n+};\n+\n+use crate::clean::{self, AttributesExt};\n+use crate::config::RenderOptions;\n+use crate::docfs::{DocFS, PathError};\n+use crate::error::Error;\n+use crate::formats::cache::Cache;\n+use crate::formats::item_type::ItemType;\n+use crate::formats::FormatRenderer;\n+use crate::html::escape::Escape;\n+use crate::html::format::Buffer;\n+use crate::html::markdown::{self, plain_text_summary, ErrorCodes, IdMap};\n+use crate::html::{layout, sources};\n+\n+/// Major driving force in all rustdoc rendering. This contains information\n+/// about where in the tree-like hierarchy rendering is occurring and controls\n+/// how the current page is being rendered.\n+///\n+/// It is intended that this context is a lightweight object which can be fairly\n+/// easily cloned because it is cloned per work-job (about once per item in the\n+/// rustdoc tree).\n+#[derive(Clone)]\n+crate struct Context<'tcx> {\n+    /// Current hierarchy of components leading down to what's currently being\n+    /// rendered\n+    crate current: Vec<String>,\n+    /// The current destination folder of where HTML artifacts should be placed.\n+    /// This changes as the context descends into the module hierarchy.\n+    crate dst: PathBuf,\n+    /// A flag, which when `true`, will render pages which redirect to the\n+    /// real location of an item. This is used to allow external links to\n+    /// publicly reused items to redirect to the right location.\n+    crate render_redirect_pages: bool,\n+    /// `None` by default, depends on the `generate-redirect-map` option flag. If this field is set\n+    /// to `Some(...)`, it'll store redirections and then generate a JSON file at the top level of\n+    /// the crate.\n+    crate redirections: Option<Rc<RefCell<FxHashMap<String, String>>>>,\n+    /// The map used to ensure all generated 'id=' attributes are unique.\n+    pub(super) id_map: Rc<RefCell<IdMap>>,\n+    /// Tracks section IDs for `Deref` targets so they match in both the main\n+    /// body and the sidebar.\n+    pub(super) deref_id_map: Rc<RefCell<FxHashMap<DefId, String>>>,\n+    crate shared: Arc<SharedContext<'tcx>>,\n+    all: Rc<RefCell<AllTypes>>,\n+    /// Storage for the errors produced while generating documentation so they\n+    /// can be printed together at the end.\n+    crate errors: Rc<Receiver<String>>,\n+    crate cache: Rc<Cache>,\n+}\n+\n+impl<'tcx> Context<'tcx> {\n+    pub(super) fn path(&self, filename: &str) -> PathBuf {\n+        // We use splitn vs Path::extension here because we might get a filename\n+        // like `style.min.css` and we want to process that into\n+        // `style-suffix.min.css`.  Path::extension would just return `css`\n+        // which would result in `style.min-suffix.css` which isn't what we\n+        // want.\n+        let (base, ext) = filename.split_once('.').unwrap();\n+        let filename = format!(\"{}{}.{}\", base, self.shared.resource_suffix, ext);\n+        self.dst.join(&filename)\n+    }\n+\n+    pub(super) fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.shared.tcx\n+    }\n+\n+    fn sess(&self) -> &'tcx Session {\n+        &self.shared.tcx.sess\n+    }\n+\n+    pub(super) fn derive_id(&self, id: String) -> String {\n+        let mut map = self.id_map.borrow_mut();\n+        map.derive(id)\n+    }\n+\n+    /// String representation of how to get back to the root path of the 'doc/'\n+    /// folder in terms of a relative URL.\n+    pub(super) fn root_path(&self) -> String {\n+        \"../\".repeat(self.current.len())\n+    }\n+\n+    fn render_item(&self, it: &clean::Item, pushname: bool) -> String {\n+        // A little unfortunate that this is done like this, but it sure\n+        // does make formatting *a lot* nicer.\n+        CURRENT_DEPTH.with(|slot| {\n+            slot.set(self.current.len());\n+        });\n+\n+        let mut title = if it.is_primitive() || it.is_keyword() {\n+            // No need to include the namespace for primitive types and keywords\n+            String::new()\n+        } else {\n+            self.current.join(\"::\")\n+        };\n+        if pushname {\n+            if !title.is_empty() {\n+                title.push_str(\"::\");\n+            }\n+            title.push_str(&it.name.unwrap().as_str());\n+        }\n+        title.push_str(\" - Rust\");\n+        let tyname = it.type_();\n+        let desc = it.doc_value().as_ref().map(|doc| plain_text_summary(&doc));\n+        let desc = if let Some(desc) = desc {\n+            desc\n+        } else if it.is_crate() {\n+            format!(\"API documentation for the Rust `{}` crate.\", self.shared.layout.krate)\n+        } else {\n+            format!(\n+                \"API documentation for the Rust `{}` {} in crate `{}`.\",\n+                it.name.as_ref().unwrap(),\n+                tyname,\n+                self.shared.layout.krate\n+            )\n+        };\n+        let keywords = make_item_keywords(it);\n+        let page = layout::Page {\n+            css_class: tyname.as_str(),\n+            root_path: &self.root_path(),\n+            static_root_path: self.shared.static_root_path.as_deref(),\n+            title: &title,\n+            description: &desc,\n+            keywords: &keywords,\n+            resource_suffix: &self.shared.resource_suffix,\n+            extra_scripts: &[],\n+            static_extra_scripts: &[],\n+        };\n+\n+        {\n+            self.id_map.borrow_mut().reset();\n+            self.id_map.borrow_mut().populate(&INITIAL_IDS);\n+        }\n+\n+        if !self.render_redirect_pages {\n+            layout::render(\n+                &self.shared.layout,\n+                &page,\n+                |buf: &mut _| print_sidebar(self, it, buf),\n+                |buf: &mut _| print_item(self, it, buf),\n+                &self.shared.style_files,\n+            )\n+        } else {\n+            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n+                let mut path = String::new();\n+                for name in &names[..names.len() - 1] {\n+                    path.push_str(name);\n+                    path.push('/');\n+                }\n+                path.push_str(&item_path(ty, names.last().unwrap()));\n+                match self.redirections {\n+                    Some(ref redirections) => {\n+                        let mut current_path = String::new();\n+                        for name in &self.current {\n+                            current_path.push_str(name);\n+                            current_path.push('/');\n+                        }\n+                        current_path.push_str(&item_path(ty, names.last().unwrap()));\n+                        redirections.borrow_mut().insert(current_path, path);\n+                    }\n+                    None => return layout::redirect(&format!(\"{}{}\", self.root_path(), path)),\n+                }\n+            }\n+            String::new()\n+        }\n+    }\n+\n+    /// Construct a map of items shown in the sidebar to a plain-text summary of their docs.\n+    fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n+        // BTreeMap instead of HashMap to get a sorted output\n+        let mut map: BTreeMap<_, Vec<_>> = BTreeMap::new();\n+        for item in &m.items {\n+            if item.is_stripped() {\n+                continue;\n+            }\n+\n+            let short = item.type_();\n+            let myname = match item.name {\n+                None => continue,\n+                Some(ref s) => s.to_string(),\n+            };\n+            let short = short.to_string();\n+            map.entry(short).or_default().push((\n+                myname,\n+                Some(item.doc_value().map_or_else(String::new, |s| plain_text_summary(&s))),\n+            ));\n+        }\n+\n+        if self.shared.sort_modules_alphabetically {\n+            for items in map.values_mut() {\n+                items.sort();\n+            }\n+        }\n+        map\n+    }\n+\n+    /// Generates a url appropriate for an `href` attribute back to the source of\n+    /// this item.\n+    ///\n+    /// The url generated, when clicked, will redirect the browser back to the\n+    /// original source code.\n+    ///\n+    /// If `None` is returned, then a source link couldn't be generated. This\n+    /// may happen, for example, with externally inlined items where the source\n+    /// of their crate documentation isn't known.\n+    pub(super) fn src_href(&self, item: &clean::Item) -> Option<String> {\n+        if item.source.is_dummy() {\n+            return None;\n+        }\n+        let mut root = self.root_path();\n+        let mut path = String::new();\n+        let cnum = item.source.cnum(self.sess());\n+\n+        // We can safely ignore synthetic `SourceFile`s.\n+        let file = match item.source.filename(self.sess()) {\n+            FileName::Real(ref path) => path.local_path().to_path_buf(),\n+            _ => return None,\n+        };\n+        let file = &file;\n+\n+        let symbol;\n+        let (krate, path) = if cnum == LOCAL_CRATE {\n+            if let Some(path) = self.shared.local_sources.get(file) {\n+                (self.shared.layout.krate.as_str(), path)\n+            } else {\n+                return None;\n+            }\n+        } else {\n+            let (krate, src_root) = match *self.cache.extern_locations.get(&cnum)? {\n+                (name, ref src, ExternalLocation::Local) => (name, src),\n+                (name, ref src, ExternalLocation::Remote(ref s)) => {\n+                    root = s.to_string();\n+                    (name, src)\n+                }\n+                (_, _, ExternalLocation::Unknown) => return None,\n+            };\n+\n+            sources::clean_path(&src_root, file, false, |component| {\n+                path.push_str(&component.to_string_lossy());\n+                path.push('/');\n+            });\n+            let mut fname = file.file_name().expect(\"source has no filename\").to_os_string();\n+            fname.push(\".html\");\n+            path.push_str(&fname.to_string_lossy());\n+            symbol = krate.as_str();\n+            (&*symbol, &path)\n+        };\n+\n+        let loline = item.source.lo(self.sess()).line;\n+        let hiline = item.source.hi(self.sess()).line;\n+        let lines =\n+            if loline == hiline { loline.to_string() } else { format!(\"{}-{}\", loline, hiline) };\n+        Some(format!(\n+            \"{root}src/{krate}/{path}#{lines}\",\n+            root = Escape(&root),\n+            krate = krate,\n+            path = path,\n+            lines = lines\n+        ))\n+    }\n+}\n+\n+/// Generates the documentation for `crate` into the directory `dst`\n+impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n+    fn descr() -> &'static str {\n+        \"html\"\n+    }\n+\n+    fn init(\n+        mut krate: clean::Crate,\n+        options: RenderOptions,\n+        edition: Edition,\n+        mut cache: Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Result<(Self, clean::Crate), Error> {\n+        // need to save a copy of the options for rendering the index page\n+        let md_opts = options.clone();\n+        let RenderOptions {\n+            output,\n+            external_html,\n+            id_map,\n+            playground_url,\n+            sort_modules_alphabetically,\n+            themes: style_files,\n+            default_settings,\n+            extension_css,\n+            resource_suffix,\n+            static_root_path,\n+            generate_search_filter,\n+            unstable_features,\n+            generate_redirect_map,\n+            ..\n+        } = options;\n+\n+        let src_root = match krate.src {\n+            FileName::Real(ref p) => match p.local_path().parent() {\n+                Some(p) => p.to_path_buf(),\n+                None => PathBuf::new(),\n+            },\n+            _ => PathBuf::new(),\n+        };\n+        // If user passed in `--playground-url` arg, we fill in crate name here\n+        let mut playground = None;\n+        if let Some(url) = playground_url {\n+            playground =\n+                Some(markdown::Playground { crate_name: Some(krate.name.to_string()), url });\n+        }\n+        let mut layout = layout::Layout {\n+            logo: String::new(),\n+            favicon: String::new(),\n+            external_html,\n+            default_settings,\n+            krate: krate.name.to_string(),\n+            css_file_extension: extension_css,\n+            generate_search_filter,\n+        };\n+        let mut issue_tracker_base_url = None;\n+        let mut include_sources = true;\n+\n+        // Crawl the crate attributes looking for attributes which control how we're\n+        // going to emit HTML\n+        if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n+            for attr in attrs.lists(sym::doc) {\n+                match (attr.name_or_empty(), attr.value_str()) {\n+                    (sym::html_favicon_url, Some(s)) => {\n+                        layout.favicon = s.to_string();\n+                    }\n+                    (sym::html_logo_url, Some(s)) => {\n+                        layout.logo = s.to_string();\n+                    }\n+                    (sym::html_playground_url, Some(s)) => {\n+                        playground = Some(markdown::Playground {\n+                            crate_name: Some(krate.name.to_string()),\n+                            url: s.to_string(),\n+                        });\n+                    }\n+                    (sym::issue_tracker_base_url, Some(s)) => {\n+                        issue_tracker_base_url = Some(s.to_string());\n+                    }\n+                    (sym::html_no_source, None) if attr.is_word() => {\n+                        include_sources = false;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        let (sender, receiver) = channel();\n+        let mut scx = SharedContext {\n+            tcx,\n+            collapsed: krate.collapsed,\n+            src_root,\n+            include_sources,\n+            local_sources: Default::default(),\n+            issue_tracker_base_url,\n+            layout,\n+            created_dirs: Default::default(),\n+            sort_modules_alphabetically,\n+            style_files,\n+            resource_suffix,\n+            static_root_path,\n+            fs: DocFS::new(sender),\n+            edition,\n+            codes: ErrorCodes::from(unstable_features.is_nightly_build()),\n+            playground,\n+        };\n+\n+        // Add the default themes to the `Vec` of stylepaths\n+        //\n+        // Note that these must be added before `sources::render` is called\n+        // so that the resulting source pages are styled\n+        //\n+        // `light.css` is not disabled because it is the stylesheet that stays loaded\n+        // by the browser as the theme stylesheet. The theme system (hackily) works by\n+        // changing the href to this stylesheet. All other themes are disabled to\n+        // prevent rule conflicts\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\"), disabled: false });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\"), disabled: true });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\"), disabled: true });\n+\n+        let dst = output;\n+        scx.ensure_dir(&dst)?;\n+        krate = sources::render(&dst, &mut scx, krate)?;\n+\n+        // Build our search index\n+        let index = build_index(&krate, &mut cache, tcx);\n+\n+        let mut cx = Context {\n+            current: Vec::new(),\n+            dst,\n+            render_redirect_pages: false,\n+            id_map: Rc::new(RefCell::new(id_map)),\n+            deref_id_map: Rc::new(RefCell::new(FxHashMap::default())),\n+            shared: Arc::new(scx),\n+            all: Rc::new(RefCell::new(AllTypes::new())),\n+            errors: Rc::new(receiver),\n+            cache: Rc::new(cache),\n+            redirections: if generate_redirect_map { Some(Default::default()) } else { None },\n+        };\n+\n+        CURRENT_DEPTH.with(|s| s.set(0));\n+\n+        // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n+        write_shared(&cx, &krate, index, &md_opts)?;\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n+        Ok((cx, krate))\n+    }\n+\n+    fn after_krate(\n+        &mut self,\n+        krate: &clean::Crate,\n+        diag: &rustc_errors::Handler,\n+    ) -> Result<(), Error> {\n+        let final_file = self.dst.join(&*krate.name.as_str()).join(\"all.html\");\n+        let settings_file = self.dst.join(\"settings.html\");\n+        let crate_name = krate.name;\n+\n+        let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n+        if !root_path.ends_with('/') {\n+            root_path.push('/');\n+        }\n+        let mut page = layout::Page {\n+            title: \"List of all items in this crate\",\n+            css_class: \"mod\",\n+            root_path: \"../\",\n+            static_root_path: self.shared.static_root_path.as_deref(),\n+            description: \"List of all items in this crate\",\n+            keywords: BASIC_KEYWORDS,\n+            resource_suffix: &self.shared.resource_suffix,\n+            extra_scripts: &[],\n+            static_extra_scripts: &[],\n+        };\n+        let sidebar = if let Some(ref version) = self.cache.crate_version {\n+            format!(\n+                \"<p class=\\\"location\\\">Crate {}</p>\\\n+                     <div class=\\\"block version\\\">\\\n+                         <p>Version {}</p>\\\n+                     </div>\\\n+                     <a id=\\\"all-types\\\" href=\\\"index.html\\\"><p>Back to index</p></a>\",\n+                crate_name,\n+                Escape(version),\n+            )\n+        } else {\n+            String::new()\n+        };\n+        let all = self.all.replace(AllTypes::new());\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            |buf: &mut Buffer| all.print(buf),\n+            &self.shared.style_files,\n+        );\n+        self.shared.fs.write(&final_file, v.as_bytes())?;\n+\n+        // Generating settings page.\n+        page.title = \"Rustdoc settings\";\n+        page.description = \"Settings of Rustdoc\";\n+        page.root_path = \"./\";\n+\n+        let mut style_files = self.shared.style_files.clone();\n+        let sidebar = \"<p class=\\\"location\\\">Settings</p><div class=\\\"sidebar-elems\\\"></div>\";\n+        style_files.push(StylePath { path: PathBuf::from(\"settings.css\"), disabled: false });\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            settings(\n+                self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n+                &self.shared.resource_suffix,\n+                &self.shared.style_files,\n+            )?,\n+            &style_files,\n+        );\n+        self.shared.fs.write(&settings_file, v.as_bytes())?;\n+        if let Some(redirections) = self.redirections.take() {\n+            if !redirections.borrow().is_empty() {\n+                let redirect_map_path =\n+                    self.dst.join(&*krate.name.as_str()).join(\"redirect-map.json\");\n+                let paths = serde_json::to_string(&*redirections.borrow()).unwrap();\n+                self.shared.ensure_dir(&self.dst.join(&*krate.name.as_str()))?;\n+                self.shared.fs.write(&redirect_map_path, paths.as_bytes())?;\n+            }\n+        }\n+\n+        // Flush pending errors.\n+        Arc::get_mut(&mut self.shared).unwrap().fs.close();\n+        let nb_errors = self.errors.iter().map(|err| diag.struct_err(&err).emit()).count();\n+        if nb_errors > 0 {\n+            Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    fn mod_item_in(&mut self, item: &clean::Item, item_name: &str) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+        let scx = &self.shared;\n+        self.dst.push(item_name);\n+        self.current.push(item_name.to_owned());\n+\n+        info!(\"Recursing into {}\", self.dst.display());\n+\n+        let buf = self.render_item(item, false);\n+        // buf will be empty if the module is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(\"index.html\");\n+            scx.fs.write(&joint_dst, buf.as_bytes())?;\n+        }\n+\n+        // Render sidebar-items.js used throughout this module.\n+        if !self.render_redirect_pages {\n+            let module = match *item.kind {\n+                clean::StrippedItem(box clean::ModuleItem(ref m)) | clean::ModuleItem(ref m) => m,\n+                _ => unreachable!(),\n+            };\n+            let items = self.build_sidebar_items(module);\n+            let js_dst = self.dst.join(\"sidebar-items.js\");\n+            let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n+            scx.fs.write(&js_dst, &v)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn mod_item_out(&mut self, _item_name: &str) -> Result<(), Error> {\n+        info!(\"Recursed; leaving {}\", self.dst.display());\n+\n+        // Go back to where we were at\n+        self.dst.pop();\n+        self.current.pop();\n+        Ok(())\n+    }\n+\n+    fn item(&mut self, item: clean::Item) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+\n+        let buf = self.render_item(&item, true);\n+        // buf will be empty if the item is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            let name = item.name.as_ref().unwrap();\n+            let item_type = item.type_();\n+            let file_name = &item_path(item_type, &name.as_str());\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(file_name);\n+            self.shared.fs.write(&joint_dst, buf.as_bytes())?;\n+\n+            if !self.render_redirect_pages {\n+                self.all.borrow_mut().append(full_path(self, &item), &item_type);\n+            }\n+            // If the item is a macro, redirect from the old macro URL (with !)\n+            // to the new one (without).\n+            if item_type == ItemType::Macro {\n+                let redir_name = format!(\"{}.{}!.html\", item_type, name);\n+                if let Some(ref redirections) = self.redirections {\n+                    let crate_name = &self.shared.layout.krate;\n+                    redirections.borrow_mut().insert(\n+                        format!(\"{}/{}\", crate_name, redir_name),\n+                        format!(\"{}/{}\", crate_name, file_name),\n+                    );\n+                } else {\n+                    let v = layout::redirect(file_name);\n+                    let redir_dst = self.dst.join(redir_name);\n+                    self.shared.fs.write(&redir_dst, v.as_bytes())?;\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn cache(&self) -> &Cache {\n+        &self.cache\n+    }\n+}\n+\n+fn make_item_keywords(it: &clean::Item) -> String {\n+    format!(\"{}, {}\", BASIC_KEYWORDS, it.name.as_ref().unwrap())\n+}"}, {"sha": "50cae50c2c3eb964f64257e39cef6162ae96d8a8", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 128, "deletions": 2643, "changes": 2771, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a"}, {"sha": "6d61248f28ef0936bacfbfa656edb9d1fe84f942", "filename": "src/librustdoc/html/render/print_item.rs", "status": "added", "additions": 1420, "deletions": 0, "changes": 1420, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -0,0 +1,1420 @@\n+use std::cmp::Ordering;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_hir::def::CtorKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::middle::stability;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::hygiene::MacroKind;\n+use rustc_span::symbol::{kw, sym, Symbol};\n+\n+use super::{\n+    collect_paths_for_type, document, ensure_trailing_slash, item_ty_to_strs, render_assoc_item,\n+    render_assoc_items, render_attributes, render_impl, render_stability_since_raw, spotlight_decl,\n+    write_srclink, AssocItemLink, Context,\n+};\n+use crate::clean::{self, GetDefId};\n+use crate::formats::cache::Cache;\n+use crate::formats::item_type::ItemType;\n+use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n+use crate::html::escape::Escape;\n+use crate::html::format::{print_abi_with_space, Buffer, Function, PrintWithSpace, WhereClause};\n+use crate::html::highlight;\n+use crate::html::markdown::MarkdownSummaryLine;\n+\n+pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n+    debug_assert!(!item.is_stripped());\n+    // Write the breadcrumb trail header for the top\n+    buf.write_str(\"<h1 class=\\\"fqn\\\"><span class=\\\"in-band\\\">\");\n+    let name = match *item.kind {\n+        clean::ModuleItem(ref m) => {\n+            if m.is_crate {\n+                \"Crate \"\n+            } else {\n+                \"Module \"\n+            }\n+        }\n+        clean::FunctionItem(..) | clean::ForeignFunctionItem(..) => \"Function \",\n+        clean::TraitItem(..) => \"Trait \",\n+        clean::StructItem(..) => \"Struct \",\n+        clean::UnionItem(..) => \"Union \",\n+        clean::EnumItem(..) => \"Enum \",\n+        clean::TypedefItem(..) => \"Type Definition \",\n+        clean::MacroItem(..) => \"Macro \",\n+        clean::ProcMacroItem(ref mac) => match mac.kind {\n+            MacroKind::Bang => \"Macro \",\n+            MacroKind::Attr => \"Attribute Macro \",\n+            MacroKind::Derive => \"Derive Macro \",\n+        },\n+        clean::PrimitiveItem(..) => \"Primitive Type \",\n+        clean::StaticItem(..) | clean::ForeignStaticItem(..) => \"Static \",\n+        clean::ConstantItem(..) => \"Constant \",\n+        clean::ForeignTypeItem => \"Foreign Type \",\n+        clean::KeywordItem(..) => \"Keyword \",\n+        clean::OpaqueTyItem(..) => \"Opaque Type \",\n+        clean::TraitAliasItem(..) => \"Trait Alias \",\n+        _ => {\n+            // We don't generate pages for any other type.\n+            unreachable!();\n+        }\n+    };\n+    buf.write_str(name);\n+    if !item.is_primitive() && !item.is_keyword() {\n+        let cur = &cx.current;\n+        let amt = if item.is_mod() { cur.len() - 1 } else { cur.len() };\n+        for (i, component) in cur.iter().enumerate().take(amt) {\n+            write!(\n+                buf,\n+                \"<a href=\\\"{}index.html\\\">{}</a>::<wbr>\",\n+                \"../\".repeat(cur.len() - i - 1),\n+                component\n+            );\n+        }\n+    }\n+    write!(buf, \"<a class=\\\"{}\\\" href=\\\"\\\">{}</a>\", item.type_(), item.name.as_ref().unwrap());\n+\n+    buf.write_str(\"</span>\"); // in-band\n+    buf.write_str(\"<span class=\\\"out-of-band\\\">\");\n+    render_stability_since_raw(\n+        buf,\n+        item.stable_since(cx.tcx()).as_deref(),\n+        item.const_stable_since(cx.tcx()).as_deref(),\n+        None,\n+        None,\n+    );\n+    buf.write_str(\n+        \"<span id=\\\"render-detail\\\">\\\n+                <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n+                    title=\\\"collapse all docs\\\">\\\n+                    [<span class=\\\"inner\\\">&#x2212;</span>]\\\n+                </a>\\\n+            </span>\",\n+    );\n+\n+    // Write `src` tag\n+    //\n+    // When this item is part of a `crate use` in a downstream crate, the\n+    // [src] link in the downstream documentation will actually come back to\n+    // this page, and this link will be auto-clicked. The `id` attribute is\n+    // used to find the link to auto-click.\n+    if cx.shared.include_sources && !item.is_primitive() {\n+        write_srclink(cx, item, buf);\n+    }\n+\n+    buf.write_str(\"</span></h1>\"); // out-of-band\n+\n+    match *item.kind {\n+        clean::ModuleItem(ref m) => item_module(buf, cx, item, &m.items),\n+        clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n+            item_function(buf, cx, item, f)\n+        }\n+        clean::TraitItem(ref t) => item_trait(buf, cx, item, t),\n+        clean::StructItem(ref s) => item_struct(buf, cx, item, s),\n+        clean::UnionItem(ref s) => item_union(buf, cx, item, s),\n+        clean::EnumItem(ref e) => item_enum(buf, cx, item, e),\n+        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t),\n+        clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n+        clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n+        clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n+        clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) => item_static(buf, cx, item, i),\n+        clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n+        clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n+        clean::KeywordItem(_) => item_keyword(buf, cx, item),\n+        clean::OpaqueTyItem(ref e) => item_opaque_ty(buf, cx, item, e),\n+        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n+        _ => {\n+            // We don't generate pages for any other type.\n+            unreachable!();\n+        }\n+    }\n+}\n+\n+fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n+    document(w, cx, item, None);\n+\n+    let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped()).collect::<Vec<usize>>();\n+\n+    // the order of item types in the listing\n+    fn reorder(ty: ItemType) -> u8 {\n+        match ty {\n+            ItemType::ExternCrate => 0,\n+            ItemType::Import => 1,\n+            ItemType::Primitive => 2,\n+            ItemType::Module => 3,\n+            ItemType::Macro => 4,\n+            ItemType::Struct => 5,\n+            ItemType::Enum => 6,\n+            ItemType::Constant => 7,\n+            ItemType::Static => 8,\n+            ItemType::Trait => 9,\n+            ItemType::Function => 10,\n+            ItemType::Typedef => 12,\n+            ItemType::Union => 13,\n+            _ => 14 + ty as u8,\n+        }\n+    }\n+\n+    fn cmp(\n+        i1: &clean::Item,\n+        i2: &clean::Item,\n+        idx1: usize,\n+        idx2: usize,\n+        tcx: TyCtxt<'_>,\n+    ) -> Ordering {\n+        let ty1 = i1.type_();\n+        let ty2 = i2.type_();\n+        if ty1 != ty2 {\n+            return (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2));\n+        }\n+        let s1 = i1.stability(tcx).as_ref().map(|s| s.level);\n+        let s2 = i2.stability(tcx).as_ref().map(|s| s.level);\n+        if let (Some(a), Some(b)) = (s1, s2) {\n+            match (a.is_stable(), b.is_stable()) {\n+                (true, true) | (false, false) => {}\n+                (false, true) => return Ordering::Less,\n+                (true, false) => return Ordering::Greater,\n+            }\n+        }\n+        let lhs = i1.name.unwrap_or(kw::Empty).as_str();\n+        let rhs = i2.name.unwrap_or(kw::Empty).as_str();\n+        compare_names(&lhs, &rhs)\n+    }\n+\n+    if cx.shared.sort_modules_alphabetically {\n+        indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2, cx.tcx()));\n+    }\n+    // This call is to remove re-export duplicates in cases such as:\n+    //\n+    // ```\n+    // crate mod foo {\n+    //     crate mod bar {\n+    //         crate trait Double { fn foo(); }\n+    //     }\n+    // }\n+    //\n+    // crate use foo::bar::*;\n+    // crate use foo::*;\n+    // ```\n+    //\n+    // `Double` will appear twice in the generated docs.\n+    //\n+    // FIXME: This code is quite ugly and could be improved. Small issue: DefId\n+    // can be identical even if the elements are different (mostly in imports).\n+    // So in case this is an import, we keep everything by adding a \"unique id\"\n+    // (which is the position in the vector).\n+    indices.dedup_by_key(|i| {\n+        (\n+            items[*i].def_id,\n+            if items[*i].name.as_ref().is_some() { Some(full_path(cx, &items[*i])) } else { None },\n+            items[*i].type_(),\n+            if items[*i].is_import() { *i } else { 0 },\n+        )\n+    });\n+\n+    debug!(\"{:?}\", indices);\n+    let mut curty = None;\n+    for &idx in &indices {\n+        let myitem = &items[idx];\n+        if myitem.is_stripped() {\n+            continue;\n+        }\n+\n+        let myty = Some(myitem.type_());\n+        if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n+            // Put `extern crate` and `use` re-exports in the same section.\n+            curty = myty;\n+        } else if myty != curty {\n+            if curty.is_some() {\n+                w.write_str(\"</table>\");\n+            }\n+            curty = myty;\n+            let (short, name) = item_ty_to_strs(&myty.unwrap());\n+            write!(\n+                w,\n+                \"<h2 id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n+                       <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n+                id = cx.derive_id(short.to_owned()),\n+                name = name\n+            );\n+        }\n+\n+        match *myitem.kind {\n+            clean::ExternCrateItem(ref name, ref src) => {\n+                use crate::html::format::anchor;\n+\n+                match *src {\n+                    Some(ref src) => write!(\n+                        w,\n+                        \"<tr><td><code>{}extern crate {} as {};\",\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                        anchor(myitem.def_id, &*src.as_str(), cx.cache()),\n+                        name\n+                    ),\n+                    None => write!(\n+                        w,\n+                        \"<tr><td><code>{}extern crate {};\",\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                        anchor(myitem.def_id, &*name.as_str(), cx.cache())\n+                    ),\n+                }\n+                w.write_str(\"</code></td></tr>\");\n+            }\n+\n+            clean::ImportItem(ref import) => {\n+                write!(\n+                    w,\n+                    \"<tr><td><code>{}{}</code></td></tr>\",\n+                    myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                    import.print(cx.cache())\n+                );\n+            }\n+\n+            _ => {\n+                if myitem.name.is_none() {\n+                    continue;\n+                }\n+\n+                let unsafety_flag = match *myitem.kind {\n+                    clean::FunctionItem(ref func) | clean::ForeignFunctionItem(ref func)\n+                        if func.header.unsafety == hir::Unsafety::Unsafe =>\n+                    {\n+                        \"<a title=\\\"unsafe function\\\" href=\\\"#\\\"><sup>\u26a0</sup></a>\"\n+                    }\n+                    _ => \"\",\n+                };\n+\n+                let stab = myitem.stability_class(cx.tcx());\n+                let add = if stab.is_some() { \" \" } else { \"\" };\n+\n+                let doc_value = myitem.doc_value().unwrap_or_default();\n+                write!(\n+                    w,\n+                    \"<tr class=\\\"{stab}{add}module-item\\\">\\\n+                         <td><a class=\\\"{class}\\\" href=\\\"{href}\\\" \\\n+                             title=\\\"{title}\\\">{name}</a>{unsafety_flag}</td>\\\n+                         <td class=\\\"docblock-short\\\">{stab_tags}{docs}</td>\\\n+                     </tr>\",\n+                    name = *myitem.name.as_ref().unwrap(),\n+                    stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n+                    docs = MarkdownSummaryLine(&doc_value, &myitem.links(&cx.cache)).into_string(),\n+                    class = myitem.type_(),\n+                    add = add,\n+                    stab = stab.unwrap_or_else(String::new),\n+                    unsafety_flag = unsafety_flag,\n+                    href = item_path(myitem.type_(), &myitem.name.unwrap().as_str()),\n+                    title = [full_path(cx, myitem), myitem.type_().to_string()]\n+                        .iter()\n+                        .filter_map(|s| if !s.is_empty() { Some(s.as_str()) } else { None })\n+                        .collect::<Vec<_>>()\n+                        .join(\" \"),\n+                );\n+            }\n+        }\n+    }\n+\n+    if curty.is_some() {\n+        w.write_str(\"</table>\");\n+    }\n+}\n+\n+/// Render the stability, deprecation and portability tags that are displayed in the item's summary\n+/// at the module level.\n+fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) -> String {\n+    let mut tags = String::new();\n+\n+    fn tag_html(class: &str, title: &str, contents: &str) -> String {\n+        format!(r#\"<span class=\"stab {}\" title=\"{}\">{}</span>\"#, class, Escape(title), contents)\n+    }\n+\n+    // The trailing space after each tag is to space it properly against the rest of the docs.\n+    if let Some(depr) = &item.deprecation(tcx) {\n+        let mut message = \"Deprecated\";\n+        if !stability::deprecation_in_effect(\n+            depr.is_since_rustc_version,\n+            depr.since.map(|s| s.as_str()).as_deref(),\n+        ) {\n+            message = \"Deprecation planned\";\n+        }\n+        tags += &tag_html(\"deprecated\", \"\", message);\n+    }\n+\n+    // The \"rustc_private\" crates are permanently unstable so it makes no sense\n+    // to render \"unstable\" everywhere.\n+    if item\n+        .stability(tcx)\n+        .as_ref()\n+        .map(|s| s.level.is_unstable() && s.feature != sym::rustc_private)\n+        == Some(true)\n+    {\n+        tags += &tag_html(\"unstable\", \"\", \"Experimental\");\n+    }\n+\n+    let cfg = match (&item.attrs.cfg, parent.attrs.cfg.as_ref()) {\n+        (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n+        (cfg, _) => cfg.as_deref().cloned(),\n+    };\n+\n+    debug!(\"Portability {:?} - {:?} = {:?}\", item.attrs.cfg, parent.attrs.cfg, cfg);\n+    if let Some(ref cfg) = cfg {\n+        tags += &tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html());\n+    }\n+\n+    tags\n+}\n+\n+fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n+    let header_len = format!(\n+        \"{}{}{}{}{:#}fn {}{:#}\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        f.header.constness.print_with_space(),\n+        f.header.asyncness.print_with_space(),\n+        f.header.unsafety.print_with_space(),\n+        print_abi_with_space(f.header.abi),\n+        it.name.as_ref().unwrap(),\n+        f.generics.print(cx.cache())\n+    )\n+    .len();\n+    w.write_str(\"<pre class=\\\"rust fn\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n+         {name}{generics}{decl}{spotlight}{where_clause}</pre>\",\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        constness = f.header.constness.print_with_space(),\n+        asyncness = f.header.asyncness.print_with_space(),\n+        unsafety = f.header.unsafety.print_with_space(),\n+        abi = print_abi_with_space(f.header.abi),\n+        name = it.name.as_ref().unwrap(),\n+        generics = f.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &f.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        decl = Function { decl: &f.decl, header_len, indent: 0, asyncness: f.header.asyncness }\n+            .print(cx.cache()),\n+        spotlight = spotlight_decl(&f.decl, cx.cache()),\n+    );\n+    document(w, cx, it, None)\n+}\n+\n+fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait) {\n+    let bounds = bounds(&t.bounds, false, cx.cache());\n+    let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n+    let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n+    let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n+    let provided = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();\n+\n+    // Output the trait definition\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust trait\\\">\");\n+        render_attributes(w, it, true);\n+        write!(\n+            w,\n+            \"{}{}{}trait {}{}{}\",\n+            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+            t.unsafety.print_with_space(),\n+            if t.is_auto { \"auto \" } else { \"\" },\n+            it.name.as_ref().unwrap(),\n+            t.generics.print(cx.cache()),\n+            bounds\n+        );\n+\n+        if !t.generics.where_predicates.is_empty() {\n+            let where_ = WhereClause { gens: &t.generics, indent: 0, end_newline: true };\n+            write!(w, \"{}\", where_.print(cx.cache()));\n+        } else {\n+            w.write_str(\" \");\n+        }\n+\n+        if t.items.is_empty() {\n+            w.write_str(\"{ }\");\n+        } else {\n+            // FIXME: we should be using a derived_id for the Anchors here\n+            w.write_str(\"{\\n\");\n+            for t in &types {\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                w.write_str(\";\\n\");\n+            }\n+            if !types.is_empty() && !consts.is_empty() {\n+                w.write_str(\"\\n\");\n+            }\n+            for t in &consts {\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                w.write_str(\";\\n\");\n+            }\n+            if !consts.is_empty() && !required.is_empty() {\n+                w.write_str(\"\\n\");\n+            }\n+            for (pos, m) in required.iter().enumerate() {\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                w.write_str(\";\\n\");\n+\n+                if pos < required.len() - 1 {\n+                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n+                }\n+            }\n+            if !required.is_empty() && !provided.is_empty() {\n+                w.write_str(\"\\n\");\n+            }\n+            for (pos, m) in provided.iter().enumerate() {\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                match *m.kind {\n+                    clean::MethodItem(ref inner, _)\n+                        if !inner.generics.where_predicates.is_empty() =>\n+                    {\n+                        w.write_str(\",\\n    { ... }\\n\");\n+                    }\n+                    _ => {\n+                        w.write_str(\" { ... }\\n\");\n+                    }\n+                }\n+                if pos < provided.len() - 1 {\n+                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n+                }\n+            }\n+            w.write_str(\"}\");\n+        }\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    // Trait documentation\n+    document(w, cx, it, None);\n+\n+    fn write_small_section_header(w: &mut Buffer, id: &str, title: &str, extra_content: &str) {\n+        write!(\n+            w,\n+            \"<h2 id=\\\"{0}\\\" class=\\\"small-section-header\\\">\\\n+                {1}<a href=\\\"#{0}\\\" class=\\\"anchor\\\"></a>\\\n+             </h2>{2}\",\n+            id, title, extra_content\n+        )\n+    }\n+\n+    fn write_loading_content(w: &mut Buffer, extra_content: &str) {\n+        write!(w, \"{}<span class=\\\"loading-content\\\">Loading content...</span>\", extra_content)\n+    }\n+\n+    fn trait_item(w: &mut Buffer, cx: &Context<'_>, m: &clean::Item, t: &clean::Item) {\n+        let name = m.name.as_ref().unwrap();\n+        info!(\"Documenting {} on {:?}\", name, t.name);\n+        let item_type = m.type_();\n+        let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+        write!(w, \"<h3 id=\\\"{id}\\\" class=\\\"method\\\"><code>\", id = id,);\n+        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl, cx);\n+        w.write_str(\"</code>\");\n+        render_stability_since(w, m, t, cx.tcx());\n+        write_srclink(cx, m, w);\n+        w.write_str(\"</h3>\");\n+        document(w, cx, m, Some(t));\n+    }\n+\n+    if !types.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"associated-types\",\n+            \"Associated Types\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for t in types {\n+            trait_item(w, cx, t, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+\n+    if !consts.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"associated-const\",\n+            \"Associated Constants\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for t in consts {\n+            trait_item(w, cx, t, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+\n+    // Output the documentation for each function individually\n+    if !required.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"required-methods\",\n+            \"Required methods\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for m in required {\n+            trait_item(w, cx, m, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+    if !provided.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"provided-methods\",\n+            \"Provided methods\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for m in provided {\n+            trait_item(w, cx, m, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+\n+    // If there are methods directly on this trait object, render them here.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n+\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n+        // The DefId is for the first Type found with that name. The bool is\n+        // if any Types with the same name but different DefId have been found.\n+        let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n+        for implementor in implementors {\n+            match implementor.inner_impl().for_ {\n+                clean::ResolvedPath { ref path, did, is_generic: false, .. }\n+                | clean::BorrowedRef {\n+                    type_: box clean::ResolvedPath { ref path, did, is_generic: false, .. },\n+                    ..\n+                } => {\n+                    let &mut (prev_did, ref mut has_duplicates) =\n+                        implementor_dups.entry(path.last()).or_insert((did, false));\n+                    if prev_did != did {\n+                        *has_duplicates = true;\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n+            i.inner_impl()\n+                .for_\n+                .def_id_full(cx.cache())\n+                .map_or(true, |d| cx.cache.paths.contains_key(&d))\n+        });\n+\n+        let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n+            local.iter().partition(|i| i.inner_impl().synthetic);\n+\n+        synthetic.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n+        concrete.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n+\n+        if !foreign.is_empty() {\n+            write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n+\n+            for implementor in foreign {\n+                let assoc_link = AssocItemLink::GotoSource(\n+                    implementor.impl_item.def_id,\n+                    &implementor.inner_impl().provided_trait_methods,\n+                );\n+                render_impl(\n+                    w,\n+                    cx,\n+                    &implementor,\n+                    it,\n+                    assoc_link,\n+                    RenderMode::Normal,\n+                    implementor.impl_item.stable_since(cx.tcx()).as_deref(),\n+                    implementor.impl_item.const_stable_since(cx.tcx()).as_deref(),\n+                    false,\n+                    None,\n+                    true,\n+                    false,\n+                    &[],\n+                );\n+            }\n+            write_loading_content(w, \"\");\n+        }\n+\n+        write_small_section_header(\n+            w,\n+            \"implementors\",\n+            \"Implementors\",\n+            \"<div class=\\\"item-list\\\" id=\\\"implementors-list\\\">\",\n+        );\n+        for implementor in concrete {\n+            render_implementor(cx, implementor, it, w, &implementor_dups, &[]);\n+        }\n+        write_loading_content(w, \"</div>\");\n+\n+        if t.is_auto {\n+            write_small_section_header(\n+                w,\n+                \"synthetic-implementors\",\n+                \"Auto implementors\",\n+                \"<div class=\\\"item-list\\\" id=\\\"synthetic-implementors-list\\\">\",\n+            );\n+            for implementor in synthetic {\n+                render_implementor(\n+                    cx,\n+                    implementor,\n+                    it,\n+                    w,\n+                    &implementor_dups,\n+                    &collect_paths_for_type(implementor.inner_impl().for_.clone(), &cx.cache),\n+                );\n+            }\n+            write_loading_content(w, \"</div>\");\n+        }\n+    } else {\n+        // even without any implementations to write in, we still want the heading and list, so the\n+        // implementors javascript file pulled in below has somewhere to write the impls into\n+        write_small_section_header(\n+            w,\n+            \"implementors\",\n+            \"Implementors\",\n+            \"<div class=\\\"item-list\\\" id=\\\"implementors-list\\\">\",\n+        );\n+        write_loading_content(w, \"</div>\");\n+\n+        if t.is_auto {\n+            write_small_section_header(\n+                w,\n+                \"synthetic-implementors\",\n+                \"Auto implementors\",\n+                \"<div class=\\\"item-list\\\" id=\\\"synthetic-implementors-list\\\">\",\n+            );\n+            write_loading_content(w, \"</div>\");\n+        }\n+    }\n+\n+    write!(\n+        w,\n+        \"<script type=\\\"text/javascript\\\" \\\n+                 src=\\\"{root_path}/implementors/{path}/{ty}.{name}.js\\\" async>\\\n+         </script>\",\n+        root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n+        path = if it.def_id.is_local() {\n+            cx.current.join(\"/\")\n+        } else {\n+            let (ref path, _) = cx.cache.external_paths[&it.def_id];\n+            path[..path.len() - 1].join(\"/\")\n+        },\n+        ty = it.type_(),\n+        name = *it.name.as_ref().unwrap()\n+    );\n+}\n+\n+fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n+    w.write_str(\"<pre class=\\\"rust trait-alias\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"trait {}{}{} = {};</pre>\",\n+        it.name.as_ref().unwrap(),\n+        t.generics.print(cx.cache()),\n+        WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        bounds(&t.bounds, true, cx.cache())\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    // Render any items associated directly to this alias, as otherwise they\n+    // won't be visible anywhere in the docs. It would be nice to also show\n+    // associated items from the aliased type (see discussion in #32077), but\n+    // we need #14072 to make sense of the generics.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n+    w.write_str(\"<pre class=\\\"rust opaque\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"type {}{}{where_clause} = impl {bounds};</pre>\",\n+        it.name.as_ref().unwrap(),\n+        t.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        bounds = bounds(&t.bounds, false, cx.cache())\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    // Render any items associated directly to this alias, as otherwise they\n+    // won't be visible anywhere in the docs. It would be nice to also show\n+    // associated items from the aliased type (see discussion in #32077), but\n+    // we need #14072 to make sense of the generics.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n+    w.write_str(\"<pre class=\\\"rust typedef\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"type {}{}{where_clause} = {type_};</pre>\",\n+        it.name.as_ref().unwrap(),\n+        t.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        type_ = t.type_.print(cx.cache())\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    // Render any items associated directly to this alias, as otherwise they\n+    // won't be visible anywhere in the docs. It would be nice to also show\n+    // associated items from the aliased type (see discussion in #32077), but\n+    // we need #14072 to make sense of the generics.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union) {\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust union\\\">\");\n+        render_attributes(w, it, true);\n+        render_union(w, it, Some(&s.generics), &s.fields, \"\", true, cx);\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    document(w, cx, it, None);\n+    let mut fields = s\n+        .fields\n+        .iter()\n+        .filter_map(|f| match *f.kind {\n+            clean::StructFieldItem(ref ty) => Some((f, ty)),\n+            _ => None,\n+        })\n+        .peekable();\n+    if fields.peek().is_some() {\n+        write!(\n+            w,\n+            \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\n+                   Fields<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a></h2>\"\n+        );\n+        for (field, ty) in fields {\n+            let name = field.name.as_ref().expect(\"union field name\");\n+            let id = format!(\"{}.{}\", ItemType::StructField, name);\n+            write!(\n+                w,\n+                \"<span id=\\\"{id}\\\" class=\\\"{shortty} small-section-header\\\">\\\n+                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                     <code>{name}: {ty}</code>\\\n+                 </span>\",\n+                id = id,\n+                name = name,\n+                shortty = ItemType::StructField,\n+                ty = ty.print(cx.cache())\n+            );\n+            if let Some(stability_class) = field.stability_class(cx.tcx()) {\n+                write!(w, \"<span class=\\\"stab {stab}\\\"></span>\", stab = stability_class);\n+            }\n+            document(w, cx, field, Some(it));\n+        }\n+    }\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum) {\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust enum\\\">\");\n+        render_attributes(w, it, true);\n+        write!(\n+            w,\n+            \"{}enum {}{}{}\",\n+            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+            it.name.as_ref().unwrap(),\n+            e.generics.print(cx.cache()),\n+            WhereClause { gens: &e.generics, indent: 0, end_newline: true }.print(cx.cache())\n+        );\n+        if e.variants.is_empty() && !e.variants_stripped {\n+            w.write_str(\" {}\");\n+        } else {\n+            w.write_str(\" {\\n\");\n+            for v in &e.variants {\n+                w.write_str(\"    \");\n+                let name = v.name.as_ref().unwrap();\n+                match *v.kind {\n+                    clean::VariantItem(ref var) => match var {\n+                        clean::Variant::CLike => write!(w, \"{}\", name),\n+                        clean::Variant::Tuple(ref tys) => {\n+                            write!(w, \"{}(\", name);\n+                            for (i, ty) in tys.iter().enumerate() {\n+                                if i > 0 {\n+                                    w.write_str(\",&nbsp;\")\n+                                }\n+                                write!(w, \"{}\", ty.print(cx.cache()));\n+                            }\n+                            w.write_str(\")\");\n+                        }\n+                        clean::Variant::Struct(ref s) => {\n+                            render_struct(w, v, None, s.struct_type, &s.fields, \"    \", false, cx);\n+                        }\n+                    },\n+                    _ => unreachable!(),\n+                }\n+                w.write_str(\",\\n\");\n+            }\n+\n+            if e.variants_stripped {\n+                w.write_str(\"    // some variants omitted\\n\");\n+            }\n+            w.write_str(\"}\");\n+        }\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    document(w, cx, it, None);\n+    if !e.variants.is_empty() {\n+        write!(\n+            w,\n+            \"<h2 id=\\\"variants\\\" class=\\\"variants small-section-header\\\">\n+                   Variants{}<a href=\\\"#variants\\\" class=\\\"anchor\\\"></a></h2>\\n\",\n+            document_non_exhaustive_header(it)\n+        );\n+        document_non_exhaustive(w, it);\n+        for variant in &e.variants {\n+            let id =\n+                cx.derive_id(format!(\"{}.{}\", ItemType::Variant, variant.name.as_ref().unwrap()));\n+            write!(\n+                w,\n+                \"<div id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n+                    <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                    <code>{name}\",\n+                id = id,\n+                name = variant.name.as_ref().unwrap()\n+            );\n+            if let clean::VariantItem(clean::Variant::Tuple(ref tys)) = *variant.kind {\n+                w.write_str(\"(\");\n+                for (i, ty) in tys.iter().enumerate() {\n+                    if i > 0 {\n+                        w.write_str(\",&nbsp;\");\n+                    }\n+                    write!(w, \"{}\", ty.print(cx.cache()));\n+                }\n+                w.write_str(\")\");\n+            }\n+            w.write_str(\"</code></div>\");\n+            document(w, cx, variant, Some(it));\n+            document_non_exhaustive(w, variant);\n+\n+            use crate::clean::Variant;\n+            if let clean::VariantItem(Variant::Struct(ref s)) = *variant.kind {\n+                let variant_id = cx.derive_id(format!(\n+                    \"{}.{}.fields\",\n+                    ItemType::Variant,\n+                    variant.name.as_ref().unwrap()\n+                ));\n+                write!(w, \"<div class=\\\"autohide sub-variant\\\" id=\\\"{id}\\\">\", id = variant_id);\n+                write!(\n+                    w,\n+                    \"<h3>Fields of <b>{name}</b></h3><div>\",\n+                    name = variant.name.as_ref().unwrap()\n+                );\n+                for field in &s.fields {\n+                    use crate::clean::StructFieldItem;\n+                    if let StructFieldItem(ref ty) = *field.kind {\n+                        let id = cx.derive_id(format!(\n+                            \"variant.{}.field.{}\",\n+                            variant.name.as_ref().unwrap(),\n+                            field.name.as_ref().unwrap()\n+                        ));\n+                        write!(\n+                            w,\n+                            \"<span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n+                                 <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                                 <code>{f}:&nbsp;{t}</code>\\\n+                             </span>\",\n+                            id = id,\n+                            f = field.name.as_ref().unwrap(),\n+                            t = ty.print(cx.cache())\n+                        );\n+                        document(w, cx, field, Some(variant));\n+                    }\n+                }\n+                w.write_str(\"</div></div>\");\n+            }\n+            render_stability_since(w, variant, it, cx.tcx());\n+        }\n+    }\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Macro) {\n+    wrap_into_docblock(w, |w| {\n+        highlight::render_with_highlighting(\n+            &t.source,\n+            w,\n+            Some(\"macro\"),\n+            None,\n+            None,\n+            it.source.span().edition(),\n+        );\n+    });\n+    document(w, cx, it, None)\n+}\n+\n+fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n+    let name = it.name.as_ref().expect(\"proc-macros always have names\");\n+    match m.kind {\n+        MacroKind::Bang => {\n+            w.push_str(\"<pre class=\\\"rust macro\\\">\");\n+            write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n+            w.push_str(\"</pre>\");\n+        }\n+        MacroKind::Attr => {\n+            w.push_str(\"<pre class=\\\"rust attr\\\">\");\n+            write!(w, \"#[{}]\", name);\n+            w.push_str(\"</pre>\");\n+        }\n+        MacroKind::Derive => {\n+            w.push_str(\"<pre class=\\\"rust derive\\\">\");\n+            write!(w, \"#[derive({})]\", name);\n+            if !m.helpers.is_empty() {\n+                w.push_str(\"\\n{\\n\");\n+                w.push_str(\"    // Attributes available to this derive:\\n\");\n+                for attr in &m.helpers {\n+                    writeln!(w, \"    #[{}]\", attr);\n+                }\n+                w.push_str(\"}\\n\");\n+            }\n+            w.push_str(\"</pre>\");\n+        }\n+    }\n+    document(w, cx, it, None)\n+}\n+\n+fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+    document(w, cx, it, None);\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n+    w.write_str(\"<pre class=\\\"rust const\\\">\");\n+    render_attributes(w, it, false);\n+\n+    write!(\n+        w,\n+        \"{vis}const {name}: {typ}\",\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        name = it.name.as_ref().unwrap(),\n+        typ = c.type_.print(cx.cache()),\n+    );\n+\n+    if c.value.is_some() || c.is_literal {\n+        write!(w, \" = {expr};\", expr = Escape(&c.expr));\n+    } else {\n+        w.write_str(\";\");\n+    }\n+\n+    if let Some(value) = &c.value {\n+        if !c.is_literal {\n+            let value_lowercase = value.to_lowercase();\n+            let expr_lowercase = c.expr.to_lowercase();\n+\n+            if value_lowercase != expr_lowercase\n+                && value_lowercase.trim_end_matches(\"i32\") != expr_lowercase\n+            {\n+                write!(w, \" // {value}\", value = Escape(value));\n+            }\n+        }\n+    }\n+\n+    w.write_str(\"</pre>\");\n+    document(w, cx, it, None)\n+}\n+\n+fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Struct) {\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust struct\\\">\");\n+        render_attributes(w, it, true);\n+        render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    document(w, cx, it, None);\n+    let mut fields = s\n+        .fields\n+        .iter()\n+        .filter_map(|f| match *f.kind {\n+            clean::StructFieldItem(ref ty) => Some((f, ty)),\n+            _ => None,\n+        })\n+        .peekable();\n+    if let CtorKind::Fictive = s.struct_type {\n+        if fields.peek().is_some() {\n+            write!(\n+                w,\n+                \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\n+                       Fields{}<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a></h2>\",\n+                document_non_exhaustive_header(it)\n+            );\n+            document_non_exhaustive(w, it);\n+            for (field, ty) in fields {\n+                let id = cx.derive_id(format!(\n+                    \"{}.{}\",\n+                    ItemType::StructField,\n+                    field.name.as_ref().unwrap()\n+                ));\n+                write!(\n+                    w,\n+                    \"<span id=\\\"{id}\\\" class=\\\"{item_type} small-section-header\\\">\\\n+                         <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                         <code>{name}: {ty}</code>\\\n+                     </span>\",\n+                    item_type = ItemType::StructField,\n+                    id = id,\n+                    name = field.name.as_ref().unwrap(),\n+                    ty = ty.print(cx.cache())\n+                );\n+                document(w, cx, field, Some(it));\n+            }\n+        }\n+    }\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Static) {\n+    w.write_str(\"<pre class=\\\"rust static\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"{vis}static {mutability}{name}: {typ}</pre>\",\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        mutability = s.mutability.print_with_space(),\n+        name = it.name.as_ref().unwrap(),\n+        typ = s.type_.print(cx.cache())\n+    );\n+    document(w, cx, it, None)\n+}\n+\n+fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+    w.write_str(\"<pre class=\\\"rust foreigntype\\\">extern {\\n\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"    {}type {};\\n}}</pre>\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        it.name.as_ref().unwrap(),\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+    document(w, cx, it, None)\n+}\n+\n+/// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n+crate fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n+    /// Takes a non-numeric and a numeric part from the given &str.\n+    fn take_parts<'a>(s: &mut &'a str) -> (&'a str, &'a str) {\n+        let i = s.find(|c: char| c.is_ascii_digit());\n+        let (a, b) = s.split_at(i.unwrap_or(s.len()));\n+        let i = b.find(|c: char| !c.is_ascii_digit());\n+        let (b, c) = b.split_at(i.unwrap_or(b.len()));\n+        *s = c;\n+        (a, b)\n+    }\n+\n+    while !lhs.is_empty() || !rhs.is_empty() {\n+        let (la, lb) = take_parts(&mut lhs);\n+        let (ra, rb) = take_parts(&mut rhs);\n+        // First process the non-numeric part.\n+        match la.cmp(ra) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n+        // Then process the numeric part, if both sides have one (and they fit in a u64).\n+        if let (Ok(ln), Ok(rn)) = (lb.parse::<u64>(), rb.parse::<u64>()) {\n+            match ln.cmp(&rn) {\n+                Ordering::Equal => (),\n+                x => return x,\n+            }\n+        }\n+        // Then process the numeric part again, but this time as strings.\n+        match lb.cmp(rb) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n+    }\n+\n+    Ordering::Equal\n+}\n+\n+pub(super) fn full_path(cx: &Context<'_>, item: &clean::Item) -> String {\n+    let mut s = cx.current.join(\"::\");\n+    s.push_str(\"::\");\n+    s.push_str(&item.name.unwrap().as_str());\n+    s\n+}\n+\n+pub(super) fn item_path(ty: ItemType, name: &str) -> String {\n+    match ty {\n+        ItemType::Module => format!(\"{}index.html\", ensure_trailing_slash(name)),\n+        _ => format!(\"{}.{}.html\", ty, name),\n+    }\n+}\n+\n+fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool, cache: &Cache) -> String {\n+    let mut bounds = String::new();\n+    if !t_bounds.is_empty() {\n+        if !trait_alias {\n+            bounds.push_str(\": \");\n+        }\n+        for (i, p) in t_bounds.iter().enumerate() {\n+            if i > 0 {\n+                bounds.push_str(\" + \");\n+            }\n+            bounds.push_str(&p.print(cache).to_string());\n+        }\n+    }\n+    bounds\n+}\n+\n+fn wrap_into_docblock<F>(w: &mut Buffer, f: F)\n+where\n+    F: FnOnce(&mut Buffer),\n+{\n+    w.write_str(\"<div class=\\\"docblock type-decl hidden-by-usual-hider\\\">\");\n+    f(w);\n+    w.write_str(\"</div>\")\n+}\n+\n+fn render_stability_since(\n+    w: &mut Buffer,\n+    item: &clean::Item,\n+    containing_item: &clean::Item,\n+    tcx: TyCtxt<'_>,\n+) {\n+    render_stability_since_raw(\n+        w,\n+        item.stable_since(tcx).as_deref(),\n+        item.const_stable_since(tcx).as_deref(),\n+        containing_item.stable_since(tcx).as_deref(),\n+        containing_item.const_stable_since(tcx).as_deref(),\n+    )\n+}\n+\n+fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl, cache: &Cache) -> Ordering {\n+    let lhs = format!(\"{}\", lhs.inner_impl().print(cache, false));\n+    let rhs = format!(\"{}\", rhs.inner_impl().print(cache, false));\n+\n+    // lhs and rhs are formatted as HTML, which may be unnecessary\n+    compare_names(&lhs, &rhs)\n+}\n+\n+fn render_implementor(\n+    cx: &Context<'_>,\n+    implementor: &Impl,\n+    trait_: &clean::Item,\n+    w: &mut Buffer,\n+    implementor_dups: &FxHashMap<Symbol, (DefId, bool)>,\n+    aliases: &[String],\n+) {\n+    // If there's already another implementor that has the same abbridged name, use the\n+    // full path, for example in `std::iter::ExactSizeIterator`\n+    let use_absolute = match implementor.inner_impl().for_ {\n+        clean::ResolvedPath { ref path, is_generic: false, .. }\n+        | clean::BorrowedRef {\n+            type_: box clean::ResolvedPath { ref path, is_generic: false, .. },\n+            ..\n+        } => implementor_dups[&path.last()].1,\n+        _ => false,\n+    };\n+    render_impl(\n+        w,\n+        cx,\n+        implementor,\n+        trait_,\n+        AssocItemLink::Anchor(None),\n+        RenderMode::Normal,\n+        trait_.stable_since(cx.tcx()).as_deref(),\n+        trait_.const_stable_since(cx.tcx()).as_deref(),\n+        false,\n+        Some(use_absolute),\n+        false,\n+        false,\n+        aliases,\n+    );\n+}\n+\n+fn render_union(\n+    w: &mut Buffer,\n+    it: &clean::Item,\n+    g: Option<&clean::Generics>,\n+    fields: &[clean::Item],\n+    tab: &str,\n+    structhead: bool,\n+    cx: &Context<'_>,\n+) {\n+    write!(\n+        w,\n+        \"{}{}{}\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        if structhead { \"union \" } else { \"\" },\n+        it.name.as_ref().unwrap()\n+    );\n+    if let Some(g) = g {\n+        write!(w, \"{}\", g.print(cx.cache()));\n+        write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache()));\n+    }\n+\n+    write!(w, \" {{\\n{}\", tab);\n+    for field in fields {\n+        if let clean::StructFieldItem(ref ty) = *field.kind {\n+            write!(\n+                w,\n+                \"    {}{}: {},\\n{}\",\n+                field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                field.name.as_ref().unwrap(),\n+                ty.print(cx.cache()),\n+                tab\n+            );\n+        }\n+    }\n+\n+    if it.has_stripped_fields().unwrap() {\n+        write!(w, \"    // some fields omitted\\n{}\", tab);\n+    }\n+    w.write_str(\"}\");\n+}\n+\n+fn render_struct(\n+    w: &mut Buffer,\n+    it: &clean::Item,\n+    g: Option<&clean::Generics>,\n+    ty: CtorKind,\n+    fields: &[clean::Item],\n+    tab: &str,\n+    structhead: bool,\n+    cx: &Context<'_>,\n+) {\n+    write!(\n+        w,\n+        \"{}{}{}\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        if structhead { \"struct \" } else { \"\" },\n+        it.name.as_ref().unwrap()\n+    );\n+    if let Some(g) = g {\n+        write!(w, \"{}\", g.print(cx.cache()))\n+    }\n+    match ty {\n+        CtorKind::Fictive => {\n+            if let Some(g) = g {\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache())\n+                )\n+            }\n+            let mut has_visible_fields = false;\n+            w.write_str(\" {\");\n+            for field in fields {\n+                if let clean::StructFieldItem(ref ty) = *field.kind {\n+                    write!(\n+                        w,\n+                        \"\\n{}    {}{}: {},\",\n+                        tab,\n+                        field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                        field.name.as_ref().unwrap(),\n+                        ty.print(cx.cache())\n+                    );\n+                    has_visible_fields = true;\n+                }\n+            }\n+\n+            if has_visible_fields {\n+                if it.has_stripped_fields().unwrap() {\n+                    write!(w, \"\\n{}    // some fields omitted\", tab);\n+                }\n+                write!(w, \"\\n{}\", tab);\n+            } else if it.has_stripped_fields().unwrap() {\n+                // If there are no visible fields we can just display\n+                // `{ /* fields omitted */ }` to save space.\n+                write!(w, \" /* fields omitted */ \");\n+            }\n+            w.write_str(\"}\");\n+        }\n+        CtorKind::Fn => {\n+            w.write_str(\"(\");\n+            for (i, field) in fields.iter().enumerate() {\n+                if i > 0 {\n+                    w.write_str(\", \");\n+                }\n+                match *field.kind {\n+                    clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n+                    clean::StructFieldItem(ref ty) => {\n+                        write!(\n+                            w,\n+                            \"{}{}\",\n+                            field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                            ty.print(cx.cache())\n+                        )\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+            w.write_str(\")\");\n+            if let Some(g) = g {\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n+                )\n+            }\n+            w.write_str(\";\");\n+        }\n+        CtorKind::Const => {\n+            // Needed for PhantomData.\n+            if let Some(g) = g {\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n+                )\n+            }\n+            w.write_str(\";\");\n+        }\n+    }\n+}\n+\n+fn document_non_exhaustive_header(item: &clean::Item) -> &str {\n+    if item.is_non_exhaustive() { \" (Non-exhaustive)\" } else { \"\" }\n+}\n+\n+fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n+    if item.is_non_exhaustive() {\n+        write!(w, \"<div class=\\\"docblock non-exhaustive non-exhaustive-{}\\\">\", {\n+            if item.is_struct() {\n+                \"struct\"\n+            } else if item.is_enum() {\n+                \"enum\"\n+            } else if item.is_variant() {\n+                \"variant\"\n+            } else {\n+                \"type\"\n+            }\n+        });\n+\n+        if item.is_struct() {\n+            w.write_str(\n+                \"Non-exhaustive structs could have additional fields added in future. \\\n+                 Therefore, non-exhaustive structs cannot be constructed in external crates \\\n+                 using the traditional <code>Struct {{ .. }}</code> syntax; cannot be \\\n+                 matched against without a wildcard <code>..</code>; and \\\n+                 struct update syntax will not work.\",\n+            );\n+        } else if item.is_enum() {\n+            w.write_str(\n+                \"Non-exhaustive enums could have additional variants added in future. \\\n+                 Therefore, when matching against variants of non-exhaustive enums, an \\\n+                 extra wildcard arm must be added to account for any future variants.\",\n+            );\n+        } else if item.is_variant() {\n+            w.write_str(\n+                \"Non-exhaustive enum variants could have additional fields added in future. \\\n+                 Therefore, non-exhaustive enum variants cannot be constructed in external \\\n+                 crates and cannot be matched against.\",\n+            );\n+        } else {\n+            w.write_str(\n+                \"This type will require a wildcard arm in any match statements or constructors.\",\n+            );\n+        }\n+\n+        w.write_str(\"</div>\");\n+    }\n+}"}, {"sha": "3175fbe5666d893c0b616dbe99235ca20caf9689", "filename": "src/librustdoc/html/render/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -1,4 +1,7 @@\n-use super::*;\n+use std::cmp::Ordering;\n+\n+use super::print_item::compare_names;\n+use super::{AllTypes, Buffer};\n \n #[test]\n fn test_compare_names() {"}, {"sha": "cbf0f9a4927c61b279e836e3d97a5f2d5a378450", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "added", "additions": 542, "deletions": 0, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -0,0 +1,542 @@\n+use std::ffi::OsStr;\n+use std::fmt::Write;\n+use std::fs::{self, File};\n+use std::io::prelude::*;\n+use std::io::{self, BufReader};\n+use std::path::{Component, Path, PathBuf};\n+\n+use itertools::Itertools;\n+use rustc_data_structures::flock;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use serde::Serialize;\n+\n+use super::{collect_paths_for_type, ensure_trailing_slash, Context, BASIC_KEYWORDS};\n+use crate::clean::Crate;\n+use crate::config::RenderOptions;\n+use crate::docfs::{DocFS, PathError};\n+use crate::error::Error;\n+use crate::formats::FormatRenderer;\n+use crate::html::{layout, static_files};\n+\n+pub(super) fn write_shared(\n+    cx: &Context<'_>,\n+    krate: &Crate,\n+    search_index: String,\n+    options: &RenderOptions,\n+) -> Result<(), Error> {\n+    // Write out the shared files. Note that these are shared among all rustdoc\n+    // docs placed in the output directory, so this needs to be a synchronized\n+    // operation with respect to all other rustdocs running around.\n+    let lock_file = cx.dst.join(\".lock\");\n+    let _lock = try_err!(flock::Lock::new(&lock_file, true, true, true), &lock_file);\n+\n+    // Add all the static files. These may already exist, but we just\n+    // overwrite them anyway to make sure that they're fresh and up-to-date.\n+\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"rustdoc.css\"),\n+        static_files::RUSTDOC_CSS,\n+        options.enable_minification,\n+    )?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"settings.css\"),\n+        static_files::SETTINGS_CSS,\n+        options.enable_minification,\n+    )?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"noscript.css\"),\n+        static_files::NOSCRIPT_CSS,\n+        options.enable_minification,\n+    )?;\n+\n+    // To avoid \"light.css\" to be overwritten, we'll first run over the received themes and only\n+    // then we'll run over the \"official\" styles.\n+    let mut themes: FxHashSet<String> = FxHashSet::default();\n+\n+    for entry in &cx.shared.style_files {\n+        let theme = try_none!(try_none!(entry.path.file_stem(), &entry.path).to_str(), &entry.path);\n+        let extension =\n+            try_none!(try_none!(entry.path.extension(), &entry.path).to_str(), &entry.path);\n+\n+        // Handle the official themes\n+        match theme {\n+            \"light\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"light.css\"),\n+                static_files::themes::LIGHT,\n+                options.enable_minification,\n+            )?,\n+            \"dark\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"dark.css\"),\n+                static_files::themes::DARK,\n+                options.enable_minification,\n+            )?,\n+            \"ayu\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"ayu.css\"),\n+                static_files::themes::AYU,\n+                options.enable_minification,\n+            )?,\n+            _ => {\n+                // Handle added third-party themes\n+                let content = try_err!(fs::read(&entry.path), &entry.path);\n+                cx.shared\n+                    .fs\n+                    .write(cx.path(&format!(\"{}.{}\", theme, extension)), content.as_slice())?;\n+            }\n+        };\n+\n+        themes.insert(theme.to_owned());\n+    }\n+\n+    let write = |p, c| cx.shared.fs.write(p, c);\n+    if (*cx.shared).layout.logo.is_empty() {\n+        write(cx.path(\"rust-logo.png\"), static_files::RUST_LOGO)?;\n+    }\n+    if (*cx.shared).layout.favicon.is_empty() {\n+        write(cx.path(\"favicon.svg\"), static_files::RUST_FAVICON_SVG)?;\n+        write(cx.path(\"favicon-16x16.png\"), static_files::RUST_FAVICON_PNG_16)?;\n+        write(cx.path(\"favicon-32x32.png\"), static_files::RUST_FAVICON_PNG_32)?;\n+    }\n+    write(cx.path(\"brush.svg\"), static_files::BRUSH_SVG)?;\n+    write(cx.path(\"wheel.svg\"), static_files::WHEEL_SVG)?;\n+    write(cx.path(\"down-arrow.svg\"), static_files::DOWN_ARROW_SVG)?;\n+\n+    let mut themes: Vec<&String> = themes.iter().collect();\n+    themes.sort();\n+    // To avoid theme switch latencies as much as possible, we put everything theme related\n+    // at the beginning of the html files into another js file.\n+    let theme_js = format!(\n+        r#\"var themes = document.getElementById(\"theme-choices\");\n+var themePicker = document.getElementById(\"theme-picker\");\n+\n+function showThemeButtonState() {{\n+    themes.style.display = \"block\";\n+    themePicker.style.borderBottomRightRadius = \"0\";\n+    themePicker.style.borderBottomLeftRadius = \"0\";\n+}}\n+\n+function hideThemeButtonState() {{\n+    themes.style.display = \"none\";\n+    themePicker.style.borderBottomRightRadius = \"3px\";\n+    themePicker.style.borderBottomLeftRadius = \"3px\";\n+}}\n+\n+function switchThemeButtonState() {{\n+    if (themes.style.display === \"block\") {{\n+        hideThemeButtonState();\n+    }} else {{\n+        showThemeButtonState();\n+    }}\n+}};\n+\n+function handleThemeButtonsBlur(e) {{\n+    var active = document.activeElement;\n+    var related = e.relatedTarget;\n+\n+    if (active.id !== \"theme-picker\" &&\n+        (!active.parentNode || active.parentNode.id !== \"theme-choices\") &&\n+        (!related ||\n+         (related.id !== \"theme-picker\" &&\n+          (!related.parentNode || related.parentNode.id !== \"theme-choices\")))) {{\n+        hideThemeButtonState();\n+    }}\n+}}\n+\n+themePicker.onclick = switchThemeButtonState;\n+themePicker.onblur = handleThemeButtonsBlur;\n+{}.forEach(function(item) {{\n+    var but = document.createElement(\"button\");\n+    but.textContent = item;\n+    but.onclick = function(el) {{\n+        switchTheme(currentTheme, mainTheme, item, true);\n+        useSystemTheme(false);\n+    }};\n+    but.onblur = handleThemeButtonsBlur;\n+    themes.appendChild(but);\n+}});\"#,\n+        serde_json::to_string(&themes).unwrap()\n+    );\n+\n+    write_minify(&cx.shared.fs, cx.path(\"theme.js\"), &theme_js, options.enable_minification)?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"main.js\"),\n+        static_files::MAIN_JS,\n+        options.enable_minification,\n+    )?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"settings.js\"),\n+        static_files::SETTINGS_JS,\n+        options.enable_minification,\n+    )?;\n+    if cx.shared.include_sources {\n+        write_minify(\n+            &cx.shared.fs,\n+            cx.path(\"source-script.js\"),\n+            static_files::sidebar::SOURCE_SCRIPT,\n+            options.enable_minification,\n+        )?;\n+    }\n+\n+    {\n+        write_minify(\n+            &cx.shared.fs,\n+            cx.path(\"storage.js\"),\n+            &format!(\n+                \"var resourcesSuffix = \\\"{}\\\";{}\",\n+                cx.shared.resource_suffix,\n+                static_files::STORAGE_JS\n+            ),\n+            options.enable_minification,\n+        )?;\n+    }\n+\n+    if let Some(ref css) = cx.shared.layout.css_file_extension {\n+        let out = cx.path(\"theme.css\");\n+        let buffer = try_err!(fs::read_to_string(css), css);\n+        if !options.enable_minification {\n+            cx.shared.fs.write(&out, &buffer)?;\n+        } else {\n+            write_minify(&cx.shared.fs, out, &buffer, options.enable_minification)?;\n+        }\n+    }\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"normalize.css\"),\n+        static_files::NORMALIZE_CSS,\n+        options.enable_minification,\n+    )?;\n+    write(cx.dst.join(\"FiraSans-Regular.woff2\"), static_files::fira_sans::REGULAR2)?;\n+    write(cx.dst.join(\"FiraSans-Medium.woff2\"), static_files::fira_sans::MEDIUM2)?;\n+    write(cx.dst.join(\"FiraSans-Regular.woff\"), static_files::fira_sans::REGULAR)?;\n+    write(cx.dst.join(\"FiraSans-Medium.woff\"), static_files::fira_sans::MEDIUM)?;\n+    write(cx.dst.join(\"FiraSans-LICENSE.txt\"), static_files::fira_sans::LICENSE)?;\n+    write(cx.dst.join(\"SourceSerifPro-Regular.ttf.woff\"), static_files::source_serif_pro::REGULAR)?;\n+    write(cx.dst.join(\"SourceSerifPro-Bold.ttf.woff\"), static_files::source_serif_pro::BOLD)?;\n+    write(cx.dst.join(\"SourceSerifPro-It.ttf.woff\"), static_files::source_serif_pro::ITALIC)?;\n+    write(cx.dst.join(\"SourceSerifPro-LICENSE.md\"), static_files::source_serif_pro::LICENSE)?;\n+    write(cx.dst.join(\"SourceCodePro-Regular.woff\"), static_files::source_code_pro::REGULAR)?;\n+    write(cx.dst.join(\"SourceCodePro-Semibold.woff\"), static_files::source_code_pro::SEMIBOLD)?;\n+    write(cx.dst.join(\"SourceCodePro-LICENSE.txt\"), static_files::source_code_pro::LICENSE)?;\n+    write(cx.dst.join(\"LICENSE-MIT.txt\"), static_files::LICENSE_MIT)?;\n+    write(cx.dst.join(\"LICENSE-APACHE.txt\"), static_files::LICENSE_APACHE)?;\n+    write(cx.dst.join(\"COPYRIGHT.txt\"), static_files::COPYRIGHT)?;\n+\n+    fn collect(path: &Path, krate: &str, key: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n+        let mut ret = Vec::new();\n+        let mut krates = Vec::new();\n+\n+        if path.exists() {\n+            let prefix = format!(r#\"{}[\"{}\"]\"#, key, krate);\n+            for line in BufReader::new(File::open(path)?).lines() {\n+                let line = line?;\n+                if !line.starts_with(key) {\n+                    continue;\n+                }\n+                if line.starts_with(&prefix) {\n+                    continue;\n+                }\n+                ret.push(line.to_string());\n+                krates.push(\n+                    line[key.len() + 2..]\n+                        .split('\"')\n+                        .next()\n+                        .map(|s| s.to_owned())\n+                        .unwrap_or_else(String::new),\n+                );\n+            }\n+        }\n+        Ok((ret, krates))\n+    }\n+\n+    fn collect_json(path: &Path, krate: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n+        let mut ret = Vec::new();\n+        let mut krates = Vec::new();\n+\n+        if path.exists() {\n+            let prefix = format!(\"\\\"{}\\\"\", krate);\n+            for line in BufReader::new(File::open(path)?).lines() {\n+                let line = line?;\n+                if !line.starts_with('\"') {\n+                    continue;\n+                }\n+                if line.starts_with(&prefix) {\n+                    continue;\n+                }\n+                if line.ends_with(\",\\\\\") {\n+                    ret.push(line[..line.len() - 2].to_string());\n+                } else {\n+                    // Ends with \"\\\\\" (it's the case for the last added crate line)\n+                    ret.push(line[..line.len() - 1].to_string());\n+                }\n+                krates.push(\n+                    line.split('\"')\n+                        .find(|s| !s.is_empty())\n+                        .map(|s| s.to_owned())\n+                        .unwrap_or_else(String::new),\n+                );\n+            }\n+        }\n+        Ok((ret, krates))\n+    }\n+\n+    use std::ffi::OsString;\n+\n+    #[derive(Debug)]\n+    struct Hierarchy {\n+        elem: OsString,\n+        children: FxHashMap<OsString, Hierarchy>,\n+        elems: FxHashSet<OsString>,\n+    }\n+\n+    impl Hierarchy {\n+        fn new(elem: OsString) -> Hierarchy {\n+            Hierarchy { elem, children: FxHashMap::default(), elems: FxHashSet::default() }\n+        }\n+\n+        fn to_json_string(&self) -> String {\n+            let mut subs: Vec<&Hierarchy> = self.children.values().collect();\n+            subs.sort_unstable_by(|a, b| a.elem.cmp(&b.elem));\n+            let mut files = self\n+                .elems\n+                .iter()\n+                .map(|s| format!(\"\\\"{}\\\"\", s.to_str().expect(\"invalid osstring conversion\")))\n+                .collect::<Vec<_>>();\n+            files.sort_unstable();\n+            let subs = subs.iter().map(|s| s.to_json_string()).collect::<Vec<_>>().join(\",\");\n+            let dirs =\n+                if subs.is_empty() { String::new() } else { format!(\",\\\"dirs\\\":[{}]\", subs) };\n+            let files = files.join(\",\");\n+            let files =\n+                if files.is_empty() { String::new() } else { format!(\",\\\"files\\\":[{}]\", files) };\n+            format!(\n+                \"{{\\\"name\\\":\\\"{name}\\\"{dirs}{files}}}\",\n+                name = self.elem.to_str().expect(\"invalid osstring conversion\"),\n+                dirs = dirs,\n+                files = files\n+            )\n+        }\n+    }\n+\n+    if cx.shared.include_sources {\n+        let mut hierarchy = Hierarchy::new(OsString::new());\n+        for source in cx\n+            .shared\n+            .local_sources\n+            .iter()\n+            .filter_map(|p| p.0.strip_prefix(&cx.shared.src_root).ok())\n+        {\n+            let mut h = &mut hierarchy;\n+            let mut elems = source\n+                .components()\n+                .filter_map(|s| match s {\n+                    Component::Normal(s) => Some(s.to_owned()),\n+                    _ => None,\n+                })\n+                .peekable();\n+            loop {\n+                let cur_elem = elems.next().expect(\"empty file path\");\n+                if elems.peek().is_none() {\n+                    h.elems.insert(cur_elem);\n+                    break;\n+                } else {\n+                    let e = cur_elem.clone();\n+                    h = h.children.entry(cur_elem.clone()).or_insert_with(|| Hierarchy::new(e));\n+                }\n+            }\n+        }\n+\n+        let dst = cx.dst.join(&format!(\"source-files{}.js\", cx.shared.resource_suffix));\n+        let (mut all_sources, _krates) =\n+            try_err!(collect(&dst, &krate.name.as_str(), \"sourcesIndex\"), &dst);\n+        all_sources.push(format!(\n+            \"sourcesIndex[\\\"{}\\\"] = {};\",\n+            &krate.name,\n+            hierarchy.to_json_string()\n+        ));\n+        all_sources.sort();\n+        let v = format!(\n+            \"var N = null;var sourcesIndex = {{}};\\n{}\\ncreateSourceSidebar();\\n\",\n+            all_sources.join(\"\\n\")\n+        );\n+        cx.shared.fs.write(&dst, v.as_bytes())?;\n+    }\n+\n+    // Update the search index and crate list.\n+    let dst = cx.dst.join(&format!(\"search-index{}.js\", cx.shared.resource_suffix));\n+    let (mut all_indexes, mut krates) = try_err!(collect_json(&dst, &krate.name.as_str()), &dst);\n+    all_indexes.push(search_index);\n+    krates.push(krate.name.to_string());\n+    krates.sort();\n+\n+    // Sort the indexes by crate so the file will be generated identically even\n+    // with rustdoc running in parallel.\n+    all_indexes.sort();\n+    {\n+        let mut v = String::from(\"var searchIndex = JSON.parse('{\\\\\\n\");\n+        v.push_str(&all_indexes.join(\",\\\\\\n\"));\n+        v.push_str(\"\\\\\\n}');\\ninitSearch(searchIndex);\");\n+        cx.shared.fs.write(&dst, &v)?;\n+    }\n+\n+    let crate_list_dst = cx.dst.join(&format!(\"crates{}.js\", cx.shared.resource_suffix));\n+    let crate_list =\n+        format!(\"window.ALL_CRATES = [{}];\", krates.iter().map(|k| format!(\"\\\"{}\\\"\", k)).join(\",\"));\n+    cx.shared.fs.write(&crate_list_dst, &crate_list)?;\n+\n+    if options.enable_index_page {\n+        if let Some(index_page) = options.index_page.clone() {\n+            let mut md_opts = options.clone();\n+            md_opts.output = cx.dst.clone();\n+            md_opts.external_html = (*cx.shared).layout.external_html.clone();\n+\n+            crate::markdown::render(&index_page, md_opts, cx.shared.edition)\n+                .map_err(|e| Error::new(e, &index_page))?;\n+        } else {\n+            let dst = cx.dst.join(\"index.html\");\n+            let page = layout::Page {\n+                title: \"Index of crates\",\n+                css_class: \"mod\",\n+                root_path: \"./\",\n+                static_root_path: cx.shared.static_root_path.as_deref(),\n+                description: \"List of crates\",\n+                keywords: BASIC_KEYWORDS,\n+                resource_suffix: &cx.shared.resource_suffix,\n+                extra_scripts: &[],\n+                static_extra_scripts: &[],\n+            };\n+\n+            let content = format!(\n+                \"<h1 class=\\\"fqn\\\">\\\n+                     <span class=\\\"in-band\\\">List of all crates</span>\\\n+                </h1><ul class=\\\"crate mod\\\">{}</ul>\",\n+                krates\n+                    .iter()\n+                    .map(|s| {\n+                        format!(\n+                            \"<li><a class=\\\"crate mod\\\" href=\\\"{}index.html\\\">{}</a></li>\",\n+                            ensure_trailing_slash(s),\n+                            s\n+                        )\n+                    })\n+                    .collect::<String>()\n+            );\n+            let v = layout::render(&cx.shared.layout, &page, \"\", content, &cx.shared.style_files);\n+            cx.shared.fs.write(&dst, v.as_bytes())?;\n+        }\n+    }\n+\n+    // Update the list of all implementors for traits\n+    let dst = cx.dst.join(\"implementors\");\n+    for (&did, imps) in &cx.cache.implementors {\n+        // Private modules can leak through to this phase of rustdoc, which\n+        // could contain implementations for otherwise private types. In some\n+        // rare cases we could find an implementation for an item which wasn't\n+        // indexed, so we just skip this step in that case.\n+        //\n+        // FIXME: this is a vague explanation for why this can't be a `get`, in\n+        //        theory it should be...\n+        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n+            Some(p) => p,\n+            None => match cx.cache.external_paths.get(&did) {\n+                Some(p) => p,\n+                None => continue,\n+            },\n+        };\n+\n+        #[derive(Serialize)]\n+        struct Implementor {\n+            text: String,\n+            synthetic: bool,\n+            types: Vec<String>,\n+        }\n+\n+        let implementors = imps\n+            .iter()\n+            .filter_map(|imp| {\n+                // If the trait and implementation are in the same crate, then\n+                // there's no need to emit information about it (there's inlining\n+                // going on). If they're in different crates then the crate defining\n+                // the trait will be interested in our implementation.\n+                //\n+                // If the implementation is from another crate then that crate\n+                // should add it.\n+                if imp.impl_item.def_id.krate == did.krate || !imp.impl_item.def_id.is_local() {\n+                    None\n+                } else {\n+                    Some(Implementor {\n+                        text: imp.inner_impl().print(cx.cache(), false).to_string(),\n+                        synthetic: imp.inner_impl().synthetic,\n+                        types: collect_paths_for_type(imp.inner_impl().for_.clone(), cx.cache()),\n+                    })\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+\n+        // Only create a js file if we have impls to add to it. If the trait is\n+        // documented locally though we always create the file to avoid dead\n+        // links.\n+        if implementors.is_empty() && !cx.cache.paths.contains_key(&did) {\n+            continue;\n+        }\n+\n+        let implementors = format!(\n+            r#\"implementors[\"{}\"] = {};\"#,\n+            krate.name,\n+            serde_json::to_string(&implementors).unwrap()\n+        );\n+\n+        let mut mydst = dst.clone();\n+        for part in &remote_path[..remote_path.len() - 1] {\n+            mydst.push(part);\n+        }\n+        cx.shared.ensure_dir(&mydst)?;\n+        mydst.push(&format!(\"{}.{}.js\", remote_item_type, remote_path[remote_path.len() - 1]));\n+\n+        let (mut all_implementors, _) =\n+            try_err!(collect(&mydst, &krate.name.as_str(), \"implementors\"), &mydst);\n+        all_implementors.push(implementors);\n+        // Sort the implementors by crate so the file will be generated\n+        // identically even with rustdoc running in parallel.\n+        all_implementors.sort();\n+\n+        let mut v = String::from(\"(function() {var implementors = {};\\n\");\n+        for implementor in &all_implementors {\n+            writeln!(v, \"{}\", *implementor).unwrap();\n+        }\n+        v.push_str(\n+            \"if (window.register_implementors) {\\\n+                 window.register_implementors(implementors);\\\n+             } else {\\\n+                 window.pending_implementors = implementors;\\\n+             }\",\n+        );\n+        v.push_str(\"})()\");\n+        cx.shared.fs.write(&mydst, &v)?;\n+    }\n+    Ok(())\n+}\n+\n+fn write_minify(\n+    fs: &DocFS,\n+    dst: PathBuf,\n+    contents: &str,\n+    enable_minification: bool,\n+) -> Result<(), Error> {\n+    if enable_minification {\n+        if dst.extension() == Some(&OsStr::new(\"css\")) {\n+            let res = try_none!(minifier::css::minify(contents).ok(), &dst);\n+            fs.write(dst, res.as_bytes())\n+        } else {\n+            fs.write(dst, minifier::js::minify(contents).as_bytes())\n+        }\n+    } else {\n+        fs.write(dst, contents.as_bytes())\n+    }\n+}"}, {"sha": "ede9e18a511a8ed0871167a595b8707d27102548", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -9,8 +9,10 @@ use crate::clean::*;\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::{find_testable_code, ErrorCodes, Ignore, LangString};\n+use crate::visit_ast::inherits_doc_hidden;\n use rustc_middle::lint::LintLevelSource;\n use rustc_session::lint;\n+use rustc_span::symbol::sym;\n \n crate const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass = Pass {\n     name: \"check-private-items-doc-tests\",\n@@ -51,23 +53,30 @@ impl crate::doctest::Tester for Tests {\n }\n \n crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if matches!(\n-        *item.kind,\n-        clean::StructFieldItem(_)\n-            | clean::VariantItem(_)\n-            | clean::AssocConstItem(_, _)\n-            | clean::AssocTypeItem(_, _)\n-            | clean::TypedefItem(_, _)\n-            | clean::StaticItem(_)\n-            | clean::ConstantItem(_)\n-            | clean::ExternCrateItem(_, _)\n-            | clean::ImportItem(_)\n-            | clean::PrimitiveItem(_)\n-            | clean::KeywordItem(_)\n-    ) {\n+    if !cx.cache.access_levels.is_public(item.def_id)\n+        || matches!(\n+            *item.kind,\n+            clean::StructFieldItem(_)\n+                | clean::VariantItem(_)\n+                | clean::AssocConstItem(_, _)\n+                | clean::AssocTypeItem(_, _)\n+                | clean::TypedefItem(_, _)\n+                | clean::StaticItem(_)\n+                | clean::ConstantItem(_)\n+                | clean::ExternCrateItem(_, _)\n+                | clean::ImportItem(_)\n+                | clean::PrimitiveItem(_)\n+                | clean::KeywordItem(_)\n+        )\n+    {\n         return false;\n     }\n     let hir_id = cx.tcx.hir().local_def_id_to_hir_id(item.def_id.expect_local());\n+    if cx.tcx.hir().attrs(hir_id).lists(sym::doc).has_word(sym::hidden)\n+        || inherits_doc_hidden(cx.tcx, hir_id)\n+    {\n+        return false;\n+    }\n     let (level, source) = cx.tcx.lint_level_at_node(crate::lint::MISSING_DOC_CODE_EXAMPLES, hir_id);\n     level != lint::Level::Allow || matches!(source, LintLevelSource::Default)\n }"}, {"sha": "ba6bb359b9135664aa8d8fa983a26f7beeff568c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -29,6 +29,16 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<String> {\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n+crate fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool {\n+    while let Some(id) = tcx.hir().get_enclosing_scope(node) {\n+        node = id;\n+        if tcx.hir().attrs(node).lists(sym::doc).has_word(sym::hidden) {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n // Also, is there some reason that this doesn't use the 'visit'\n // framework from syntax?.\n \n@@ -158,19 +168,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om: &mut Module<'tcx>,\n         please_inline: bool,\n     ) -> bool {\n-        fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: hir::HirId) -> bool {\n-            while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n-                node = id;\n-                if cx.tcx.hir().attrs(node).lists(sym::doc).has_word(sym::hidden) {\n-                    return true;\n-                }\n-                if node == hir::CRATE_HIR_ID {\n-                    break;\n-                }\n-            }\n-            false\n-        }\n-\n         debug!(\"maybe_inline_local res: {:?}\", res);\n \n         let tcx = self.cx.tcx;\n@@ -212,7 +209,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         };\n \n         let is_private = !self.cx.cache.access_levels.is_public(res_did);\n-        let is_hidden = inherits_doc_hidden(self.cx, res_hir_id);\n+        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_hir_id);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {"}, {"sha": "41e8847792694635d97ecdfe1a6b70ff75ffb870", "filename": "src/test/rustdoc-ui/lint-missing-doc-code-example.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -12,16 +12,16 @@\n /// ```\n /// println!(\"hello\");\n /// ```\n-fn test() {\n+pub fn test() {\n }\n \n #[allow(missing_docs)]\n-mod module1 { //~ ERROR\n+pub mod module1 { //~ ERROR\n }\n \n #[allow(rustdoc::missing_doc_code_examples)]\n /// doc\n-mod module2 {\n+pub mod module2 {\n \n   /// doc\n   pub fn test() {}\n@@ -63,9 +63,22 @@ pub enum Enum {\n /// Doc\n //~^ ERROR\n #[repr(C)]\n-union Union {\n+pub union Union {\n     /// Doc, but no code example and it's fine!\n     a: i32,\n     /// Doc, but no code example and it's fine!\n     b: f32,\n }\n+\n+\n+#[doc(hidden)]\n+pub mod foo {\n+    pub fn bar() {}\n+}\n+\n+fn babar() {}\n+\n+\n+mod fofoo {\n+    pub fn tadam() {}\n+}"}, {"sha": "371579785428168088b70c5615341c8287ba992a", "filename": "src/test/rustdoc-ui/lint-missing-doc-code-example.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.stderr?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -1,7 +1,7 @@\n error: missing code example in this documentation\n   --> $DIR/lint-missing-doc-code-example.rs:19:1\n    |\n-LL | / mod module1 {\n+LL | / pub mod module1 {\n LL | | }\n    | |_^\n    |"}, {"sha": "934870afc119cb7812105eee52379007acd59eae", "filename": "src/test/ui/generic-associated-types/issue-81712-cyclic-traits.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81712-cyclic-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81712-cyclic-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81712-cyclic-traits.rs?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for #81712.\n+\n+#![feature(generic_associated_types)]\n+#![allow(incomplete_features)]\n+\n+trait A {\n+    type BType: B<AType = Self>;\n+}\n+\n+trait B {\n+    type AType: A<BType = Self>;\n+}\n+trait C {\n+    type DType<T>: D<T, CType = Self>;\n+    //~^ ERROR: missing generics for associated type `C::DType` [E0107]\n+}\n+trait D<T> {\n+    type CType: C<DType = Self>;\n+}\n+\n+fn main() {}"}, {"sha": "75f68cd3148930862f44379c4b8032274c083936", "filename": "src/test/ui/generic-associated-types/issue-81712-cyclic-traits.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81712-cyclic-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ccc89bc312caa65ca46b55b47492abdd5b6910a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81712-cyclic-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81712-cyclic-traits.stderr?ref=8ccc89bc312caa65ca46b55b47492abdd5b6910a", "patch": "@@ -0,0 +1,19 @@\n+error[E0107]: missing generics for associated type `C::DType`\n+  --> $DIR/issue-81712-cyclic-traits.rs:14:10\n+   |\n+LL |     type DType<T>: D<T, CType = Self>;\n+   |          ^^^^^ expected 1 type argument\n+   |\n+note: associated type defined here, with 1 type parameter: `T`\n+  --> $DIR/issue-81712-cyclic-traits.rs:14:10\n+   |\n+LL |     type DType<T>: D<T, CType = Self>;\n+   |          ^^^^^ -\n+help: use angle brackets to add missing type argument\n+   |\n+LL |     type DType<T><T>: D<T, CType = Self>;\n+   |               ^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0107`."}]}