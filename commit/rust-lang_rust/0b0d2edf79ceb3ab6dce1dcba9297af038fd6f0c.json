{"sha": "0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMGQyZWRmNzljZWIzYWI2ZGNlMWRjYmE5Mjk3YWYwMzhmZDZmMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-17T03:58:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-17T03:58:41Z"}, "message": "Auto merge of #54254 - RalfJung:miri-dangling, r=eddyb\n\nmiri engine: keep around some information for dead allocations\n\nWe use it to test if a dangling ptr is aligned and non-NULL. This makes some code pass that should pass (writing a ZST to a properly aligned dangling pointer), and makes some code fail that should fail (writing a ZST to a pointer obtained via pointer arithmetic from a real location, but ouf-of-bounds -- that pointer could be NULL, so we cannot allow writing to it).\n\nCTFE does not allow these operations; tests are added to miri with https://github.com/solson/miri/pull/453.", "tree": {"sha": "991e813806a741d5d4473dcae17b04bdf7adea4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/991e813806a741d5d4473dcae17b04bdf7adea4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c", "html_url": "https://github.com/rust-lang/rust/commit/0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c6478998e2a0c33e46c951bd011ce367d6438ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c6478998e2a0c33e46c951bd011ce367d6438ba", "html_url": "https://github.com/rust-lang/rust/commit/0c6478998e2a0c33e46c951bd011ce367d6438ba"}, {"sha": "f3a76a18d74ce98e6813e74ae7779c8efc67b70d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a76a18d74ce98e6813e74ae7779c8efc67b70d", "html_url": "https://github.com/rust-lang/rust/commit/f3a76a18d74ce98e6813e74ae7779c8efc67b70d"}], "stats": {"total": 59, "additions": 50, "deletions": 9}, "files": [{"sha": "fcb310f7045674abce83c78ff297bc62be398419", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c", "patch": "@@ -51,6 +51,11 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// a static creates a copy here, in the machine.\n     alloc_map: FxHashMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n \n+    /// To be able to compare pointers with NULL, and to check alignment for accesses\n+    /// to ZSTs (where pointers may dangle), we keep track of the size even for allocations\n+    /// that do not exist any more.\n+    dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n+\n     pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n@@ -74,6 +79,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Memory {\n             data,\n             alloc_map: FxHashMap::default(),\n+            dead_alloc_map: FxHashMap::default(),\n             tcx,\n         }\n     }\n@@ -150,6 +156,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n+        debug!(\"deallocating: {}\", ptr.alloc_id);\n+\n         if ptr.offset.bytes() != 0 {\n             return err!(DeallocateNonBasePtr);\n         }\n@@ -189,23 +197,41 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        debug!(\"deallocated : {}\", ptr.alloc_id);\n+        // Don't forget to remember size and align of this now-dead allocation\n+        let old = self.dead_alloc_map.insert(\n+            ptr.alloc_id,\n+            (Size::from_bytes(alloc.bytes.len() as u64), alloc.align)\n+        );\n+        if old.is_some() {\n+            bug!(\"Nothing can be deallocated twice\");\n+        }\n \n         Ok(())\n     }\n \n-    /// Check that the pointer is aligned AND non-NULL. This supports scalars\n-    /// for the benefit of other parts of miri that need to check alignment even for ZST.\n+    /// Check that the pointer is aligned AND non-NULL. This supports ZSTs in two ways:\n+    /// You can pass a scalar, and a `Pointer` does not have to actually still be allocated.\n     pub fn check_align(&self, ptr: Scalar, required_align: Align) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr {\n             Scalar::Ptr(ptr) => {\n-                let alloc = self.get(ptr.alloc_id)?;\n-                (ptr.offset.bytes(), alloc.align)\n+                let (size, align) = self.get_size_and_align(ptr.alloc_id)?;\n+                // check this is not NULL -- which we can ensure only if this is in-bounds\n+                // of some (potentially dead) allocation.\n+                if ptr.offset > size {\n+                    return err!(PointerOutOfBounds {\n+                        ptr,\n+                        access: true,\n+                        allocation_size: size,\n+                    });\n+                };\n+                // keep data for alignment check\n+                (ptr.offset.bytes(), align)\n             }\n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, self.pointer_size().bytes());\n                 assert!(bits < (1u128 << self.pointer_size().bits()));\n+                // check this is not NULL\n                 if bits == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n@@ -306,6 +332,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n+    pub fn get_size_and_align(&self, id: AllocId) -> EvalResult<'tcx, (Size, Align)> {\n+        Ok(match self.get(id) {\n+            Ok(alloc) => (Size::from_bytes(alloc.bytes.len() as u64), alloc.align),\n+            Err(err) => match err.kind {\n+                EvalErrorKind::DanglingPointerDeref =>\n+                    // This should be in the dead allocation map\n+                    *self.dead_alloc_map.get(&id).expect(\n+                        \"allocation missing in dead_alloc_map\"\n+                    ),\n+                // E.g. a function ptr allocation\n+                _ => return Err(err)\n+            }\n+        })\n+    }\n+\n     pub fn get_mut(\n         &mut self,\n         id: AllocId,"}, {"sha": "c7f84f768395351c35405e9fa0c7a39ea4e334fc", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c", "patch": "@@ -219,7 +219,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n         let (ptr, ptr_align) = mplace.to_scalar_ptr_align();\n \n-        if mplace.layout.size.bytes() == 0 {\n+        if mplace.layout.is_zst() {\n             // Not all ZSTs have a layout we would handle below, so just short-circuit them\n             // all here.\n             self.memory.check_align(ptr, ptr_align)?;\n@@ -376,14 +376,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         })\n     }\n \n-    // Take an operand, representing a pointer, and dereference it -- that\n+    // Take an operand, representing a pointer, and dereference it to a place -- that\n     // will always be a MemPlace.\n     pub(super) fn deref_operand(\n         &self,\n         src: OpTy<'tcx>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         let val = self.read_value(src)?;\n-        trace!(\"deref to {} on {:?}\", val.layout.ty, val);\n+        trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n         Ok(self.ref_to_mplace(val)?)\n     }\n "}, {"sha": "e3f7f26f53efda786f55b8045ed9015dca092228", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=0b0d2edf79ceb3ab6dce1dcba9297af038fd6f0c", "patch": "@@ -612,7 +612,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // wrong type.\n \n         // Nothing to do for ZSTs, other than checking alignment\n-        if dest.layout.size.bytes() == 0 {\n+        if dest.layout.is_zst() {\n             self.memory.check_align(ptr, ptr_align)?;\n             return Ok(());\n         }"}]}