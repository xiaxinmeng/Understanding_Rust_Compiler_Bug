{"sha": "a6d080608db1bcc2a2f8fc586d8a5d3c85e50763", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZDA4MDYwOGRiMWJjYzJhMmY4ZmM1ODZkOGE1ZDNjODVlNTA3NjM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-15T06:27:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-15T06:27:59Z"}, "message": "Merge #2249\n\n2249: Cleanup hover r=matklad a=kjeremy\n\nTake advantage of classify_name to consolidate multiple hover paths. This isn't quite as clean as I want it to be (`no_fallback` bool is wonky). There's a relationship between `HoverResult` being empty and the range that is a little warty.\r\n\r\nAlso I noticed that HoverResults are always marked as exact and have been for quite a while... maybe that should be removed in another PR.\n\nCo-authored-by: Jeremy Kolb <kjeremy@gmail.com>", "tree": {"sha": "70a40132208527395890715e6b9c6cbfe38c972c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70a40132208527395890715e6b9c6cbfe38c972c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6d080608db1bcc2a2f8fc586d8a5d3c85e50763", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdzkVvCRBK7hj4Ov3rIwAAdHIIAAZUBVMEN7trpxKMlFordc+p\nKfaJX88wYzr3K/MOxD77sITkGkjIgREu3SdRIGfWPNgvZ3mDQ5nF05j4YHPzG0/K\njocwFXN7AWKeQl7BCHkQEirC3KOEP7aTO1PV8CSpjKR9mrsUKBeXnZI02MBSKrjn\ntCWtXel6F1/1ouRqilRqcBfBwx21VyF3EaZSI4Z+vJTtb4SwIYCDQDiKrlO2L4SV\ndcMDz+8OB5Ey96RZGzIkUb6GEVrhOmUZGb37gALRZu/A5+6yRTqU/NC7S3sHIBIt\neKgh75/sBrgzvkIL6ARpevQLZ7TOIknq9yB6YJjyfz7x6AyEHf3383l2QsnLTY0=\n=pi3A\n-----END PGP SIGNATURE-----\n", "payload": "tree 70a40132208527395890715e6b9c6cbfe38c972c\nparent ae6a803c0a38a423f2987b04283ec27900c80f0c\nparent 89647f93c499f2db186e8d216e3d279c0ae9fb70\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573799279 +0000\ncommitter GitHub <noreply@github.com> 1573799279 +0000\n\nMerge #2249\n\n2249: Cleanup hover r=matklad a=kjeremy\n\nTake advantage of classify_name to consolidate multiple hover paths. This isn't quite as clean as I want it to be (`no_fallback` bool is wonky). There's a relationship between `HoverResult` being empty and the range that is a little warty.\r\n\r\nAlso I noticed that HoverResults are always marked as exact and have been for quite a while... maybe that should be removed in another PR.\n\nCo-authored-by: Jeremy Kolb <kjeremy@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6d080608db1bcc2a2f8fc586d8a5d3c85e50763", "html_url": "https://github.com/rust-lang/rust/commit/a6d080608db1bcc2a2f8fc586d8a5d3c85e50763", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6d080608db1bcc2a2f8fc586d8a5d3c85e50763/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae6a803c0a38a423f2987b04283ec27900c80f0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae6a803c0a38a423f2987b04283ec27900c80f0c", "html_url": "https://github.com/rust-lang/rust/commit/ae6a803c0a38a423f2987b04283ec27900c80f0c"}, {"sha": "89647f93c499f2db186e8d216e3d279c0ae9fb70", "url": "https://api.github.com/repos/rust-lang/rust/commits/89647f93c499f2db186e8d216e3d279c0ae9fb70", "html_url": "https://github.com/rust-lang/rust/commit/89647f93c499f2db186e8d216e3d279c0ae9fb70"}], "stats": {"total": 204, "additions": 93, "deletions": 111}, "files": [{"sha": "07d511fb316c94d889325147ed1fb7e3590db32f", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 93, "deletions": 111, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/a6d080608db1bcc2a2f8fc586d8a5d3c85e50763/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d080608db1bcc2a2f8fc586d8a5d3c85e50763/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=a6d080608db1bcc2a2f8fc586d8a5d3c85e50763", "patch": "@@ -5,7 +5,7 @@ use ra_db::SourceDatabase;\n use ra_syntax::{\n     algo::{ancestors_at_offset, find_covering_element, find_node_at_offset},\n     ast::{self, DocCommentsOwner},\n-    match_ast, AstNode,\n+    AstNode,\n };\n \n use crate::{\n@@ -14,7 +14,7 @@ use crate::{\n         description_from_symbol, docs_from_symbol, macro_label, rust_code_markup,\n         rust_code_markup_with_doc, ShortLabel,\n     },\n-    references::{classify_name_ref, NameKind::*},\n+    references::{classify_name, classify_name_ref, NameKind, NameKind::*},\n     FilePosition, FileRange, RangeInfo,\n };\n \n@@ -92,65 +92,88 @@ fn hover_text(docs: Option<String>, desc: Option<String>) -> Option<String> {\n     }\n }\n \n+fn hover_text_from_name_kind(\n+    db: &RootDatabase,\n+    name_kind: NameKind,\n+    no_fallback: &mut bool,\n+) -> Option<String> {\n+    return match name_kind {\n+        Macro(it) => {\n+            let src = it.source(db);\n+            hover_text(src.ast.doc_comment_text(), Some(macro_label(&src.ast)))\n+        }\n+        Field(it) => {\n+            let src = it.source(db);\n+            match src.ast {\n+                hir::FieldSource::Named(it) => hover_text(it.doc_comment_text(), it.short_label()),\n+                _ => None,\n+            }\n+        }\n+        AssocItem(it) => match it {\n+            hir::AssocItem::Function(it) => from_def_source(db, it),\n+            hir::AssocItem::Const(it) => from_def_source(db, it),\n+            hir::AssocItem::TypeAlias(it) => from_def_source(db, it),\n+        },\n+        Def(it) => match it {\n+            hir::ModuleDef::Module(it) => match it.definition_source(db).ast {\n+                hir::ModuleSource::Module(it) => {\n+                    hover_text(it.doc_comment_text(), it.short_label())\n+                }\n+                _ => None,\n+            },\n+            hir::ModuleDef::Function(it) => from_def_source(db, it),\n+            hir::ModuleDef::Adt(Adt::Struct(it)) => from_def_source(db, it),\n+            hir::ModuleDef::Adt(Adt::Union(it)) => from_def_source(db, it),\n+            hir::ModuleDef::Adt(Adt::Enum(it)) => from_def_source(db, it),\n+            hir::ModuleDef::EnumVariant(it) => from_def_source(db, it),\n+            hir::ModuleDef::Const(it) => from_def_source(db, it),\n+            hir::ModuleDef::Static(it) => from_def_source(db, it),\n+            hir::ModuleDef::Trait(it) => from_def_source(db, it),\n+            hir::ModuleDef::TypeAlias(it) => from_def_source(db, it),\n+            hir::ModuleDef::BuiltinType(it) => Some(it.to_string()),\n+        },\n+        SelfType(ty) => match ty.as_adt() {\n+            Some((adt_def, _)) => match adt_def {\n+                hir::Adt::Struct(it) => from_def_source(db, it),\n+                hir::Adt::Union(it) => from_def_source(db, it),\n+                hir::Adt::Enum(it) => from_def_source(db, it),\n+            },\n+            _ => None,\n+        },\n+        Local(_) => {\n+            // Hover for these shows type names\n+            *no_fallback = true;\n+            None\n+        }\n+        GenericParam(_) => {\n+            // FIXME: Hover for generic param\n+            None\n+        }\n+    };\n+\n+    fn from_def_source<A, D>(db: &RootDatabase, def: D) -> Option<String>\n+    where\n+        D: HasSource<Ast = A>,\n+        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n+    {\n+        let src = def.source(db);\n+        hover_text(src.ast.doc_comment_text(), src.ast.short_label())\n+    }\n+}\n+\n pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<HoverResult>> {\n     let parse = db.parse(position.file_id);\n     let file = parse.tree();\n+\n     let mut res = HoverResult::new();\n \n-    let mut range = None;\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n+    let mut range = if let Some(name_ref) =\n+        find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset)\n+    {\n         let mut no_fallback = false;\n-        let name_kind = classify_name_ref(db, position.file_id, &name_ref).map(|d| d.kind);\n-        match name_kind {\n-            Some(Macro(it)) => {\n-                let src = it.source(db);\n-                res.extend(hover_text(src.ast.doc_comment_text(), Some(macro_label(&src.ast))));\n-            }\n-            Some(Field(it)) => {\n-                let src = it.source(db);\n-                if let hir::FieldSource::Named(it) = src.ast {\n-                    res.extend(hover_text(it.doc_comment_text(), it.short_label()));\n-                }\n-            }\n-            Some(AssocItem(it)) => res.extend(match it {\n-                hir::AssocItem::Function(it) => from_def_source(db, it),\n-                hir::AssocItem::Const(it) => from_def_source(db, it),\n-                hir::AssocItem::TypeAlias(it) => from_def_source(db, it),\n-            }),\n-            Some(Def(it)) => match it {\n-                hir::ModuleDef::Module(it) => {\n-                    if let hir::ModuleSource::Module(it) = it.definition_source(db).ast {\n-                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                    }\n-                }\n-                hir::ModuleDef::Function(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Adt(Adt::Struct(it)) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Adt(Adt::Union(it)) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Adt(Adt::Enum(it)) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::EnumVariant(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Const(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Static(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Trait(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::TypeAlias(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::BuiltinType(it) => res.extend(Some(it.to_string())),\n-            },\n-            Some(SelfType(ty)) => {\n-                if let Some((adt_def, _)) = ty.as_adt() {\n-                    res.extend(match adt_def {\n-                        hir::Adt::Struct(it) => from_def_source(db, it),\n-                        hir::Adt::Union(it) => from_def_source(db, it),\n-                        hir::Adt::Enum(it) => from_def_source(db, it),\n-                    })\n-                }\n-            }\n-            Some(Local(_)) => {\n-                // Hover for these shows type names\n-                no_fallback = true;\n-            }\n-            Some(GenericParam(_)) => {\n-                // FIXME: Hover for generic param\n-            }\n-            None => {}\n+        if let Some(name_kind) = classify_name_ref(db, position.file_id, &name_ref).map(|d| d.kind)\n+        {\n+            res.extend(hover_text_from_name_kind(db, name_kind, &mut no_fallback))\n         }\n \n         if res.is_empty() && !no_fallback {\n@@ -164,55 +187,24 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         }\n \n         if !res.is_empty() {\n-            range = Some(name_ref.syntax().text_range())\n+            Some(name_ref.syntax().text_range())\n+        } else {\n+            None\n         }\n     } else if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), position.offset) {\n-        if let Some(parent) = name.syntax().parent() {\n-            let text = match_ast! {\n-                match parent {\n-                    ast::StructDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::EnumDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::EnumVariant(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::FnDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::TypeAliasDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::ConstDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::StaticDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::TraitDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::RecordFieldDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::Module(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::MacroCall(it) => {\n-                        hover_text(it.doc_comment_text(), None)\n-                    },\n-                    _ => None,\n-                }\n-            };\n-            res.extend(text);\n+        if let Some(name_kind) = classify_name(db, position.file_id, &name).map(|d| d.kind) {\n+            let mut _b: bool = true;\n+            res.extend(hover_text_from_name_kind(db, name_kind, &mut _b));\n         }\n \n-        if !res.is_empty() && range.is_none() {\n-            range = Some(name.syntax().text_range());\n+        if !res.is_empty() {\n+            Some(name.syntax().text_range())\n+        } else {\n+            None\n         }\n-    }\n+    } else {\n+        None\n+    };\n \n     if range.is_none() {\n         let node = ancestors_at_offset(file.syntax(), position.offset).find(|n| {\n@@ -221,23 +213,13 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         let frange = FileRange { file_id: position.file_id, range: node.text_range() };\n         res.extend(type_of(db, frange).map(rust_code_markup));\n         range = Some(node.text_range());\n-    }\n+    };\n \n     let range = range?;\n     if res.is_empty() {\n         return None;\n     }\n-    let res = RangeInfo::new(range, res);\n-    return Some(res);\n-\n-    fn from_def_source<A, D>(db: &RootDatabase, def: D) -> Option<String>\n-    where\n-        D: HasSource<Ast = A>,\n-        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n-    {\n-        let src = def.source(db);\n-        hover_text(src.ast.doc_comment_text(), src.ast.short_label())\n-    }\n+    Some(RangeInfo::new(range, res))\n }\n \n pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {"}]}