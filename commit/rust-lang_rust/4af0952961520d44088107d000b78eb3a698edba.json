{"sha": "4af0952961520d44088107d000b78eb3a698edba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZjA5NTI5NjE1MjBkNDQwODgxMDdkMDAwYjc4ZWIzYTY5OGVkYmE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-28T15:51:44Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-14T20:12:46Z"}, "message": "Call `is_freeze` less in unsafety-checking\n\nThis is to avoid cycles when calling `is_freeze` on an opaque type.", "tree": {"sha": "ac66afdfc83e41681f97c4513ea4437dd42792ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac66afdfc83e41681f97c4513ea4437dd42792ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4af0952961520d44088107d000b78eb3a698edba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4af0952961520d44088107d000b78eb3a698edba", "html_url": "https://github.com/rust-lang/rust/commit/4af0952961520d44088107d000b78eb3a698edba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4af0952961520d44088107d000b78eb3a698edba/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f41cf4cef551d887de539842d11945b6bfaa8b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f41cf4cef551d887de539842d11945b6bfaa8b6", "html_url": "https://github.com/rust-lang/rust/commit/7f41cf4cef551d887de539842d11945b6bfaa8b6"}], "stats": {"total": 77, "additions": 58, "deletions": 19}, "files": [{"sha": "fab55018d3099ba531a1e385bd879a5875590a4a", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4af0952961520d44088107d000b78eb3a698edba/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af0952961520d44088107d000b78eb3a698edba/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=4af0952961520d44088107d000b78eb3a698edba", "patch": "@@ -178,6 +178,16 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n+        // prevent\n+        // * `&mut x.field`\n+        // * `x.field = y;`\n+        // * `&x.field` if `field`'s type has interior mutability\n+        // because either of these would allow modifying the layout constrained field and\n+        // insert values that violate the layout constraints.\n+        if context.is_mutating_use() || context.is_borrow() {\n+            self.check_mut_borrowing_layout_constrained_field(place, context.is_mutating_use());\n+        }\n+\n         for (i, elem) in place.projection.iter().enumerate() {\n             let proj_base = &place.projection[..i];\n \n@@ -198,24 +208,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            let is_borrow_of_interior_mut = context.is_borrow()\n-                && !Place::ty_from(place.local, proj_base, self.body, self.tcx).ty.is_freeze(\n-                    self.tcx,\n-                    self.param_env,\n-                    self.source_info.span,\n-                );\n-            // prevent\n-            // * `&mut x.field`\n-            // * `x.field = y;`\n-            // * `&x.field` if `field`'s type has interior mutability\n-            // because either of these would allow modifying the layout constrained field and\n-            // insert values that violate the layout constraints.\n-            if context.is_mutating_use() || is_borrow_of_interior_mut {\n-                self.check_mut_borrowing_layout_constrained_field(place, context.is_mutating_use());\n-            }\n             let old_source_info = self.source_info;\n-            if let (local, []) = (&place.local, proj_base) {\n-                let decl = &self.body.local_decls[*local];\n+            if let [] = proj_base {\n+                let decl = &self.body.local_decls[place.local];\n                 if decl.internal {\n                     if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n                         if self.tcx.is_mutable_static(def_id) {\n@@ -240,7 +235,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         // Internal locals are used in the `move_val_init` desugaring.\n                         // We want to check unsafety against the source info of the\n                         // desugaring, rather than the source info of the RHS.\n-                        self.source_info = self.body.local_decls[*local].source_info;\n+                        self.source_info = self.body.local_decls[place.local].source_info;\n                     }\n                 }\n             }\n@@ -396,6 +391,9 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             cursor = proj_base;\n \n             match elem {\n+                // Modifications behind a dereference don't affect the value of\n+                // the pointer.\n+                ProjectionElem::Deref => return,\n                 ProjectionElem::Field(..) => {\n                     let ty =\n                         Place::ty_from(place.local, proj_base, &self.body.local_decls, self.tcx).ty;\n@@ -409,14 +407,23 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                                         \"mutating layout constrained fields cannot statically be \\\n                                         checked for valid values\",\n                                     )\n-                                } else {\n+\n+                                // Check `is_freeze` as late as possible to avoid cycle errors\n+                                // with opaque types.\n+                                } else if !place.ty(self.body, self.tcx).ty.is_freeze(\n+                                    self.tcx,\n+                                    self.param_env,\n+                                    self.source_info.span,\n+                                ) {\n                                     (\n                                         \"borrow of layout constrained field with interior \\\n                                         mutability\",\n                                         \"references to fields of layout constrained fields \\\n                                         lose the constraints. Coupled with interior mutability, \\\n                                         the field can be changed to invalid values\",\n                                     )\n+                                } else {\n+                                    continue;\n                                 };\n                                 self.require_unsafe(\n                                     description,"}, {"sha": "4a5831c5b73df177261171fad04ccf789d9d9570", "filename": "src/test/ui/impl-trait/unsafety-checking-cycle.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4af0952961520d44088107d000b78eb3a698edba/src%2Ftest%2Fui%2Fimpl-trait%2Funsafety-checking-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af0952961520d44088107d000b78eb3a698edba/src%2Ftest%2Fui%2Fimpl-trait%2Funsafety-checking-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funsafety-checking-cycle.rs?ref=4af0952961520d44088107d000b78eb3a698edba", "patch": "@@ -0,0 +1,32 @@\n+// Ensure that we don't get a cycle error from trying to determine whether an\n+// opaque type implements `Freeze` in safety checking, when it doesn't matter.\n+\n+// check-pass\n+\n+#![feature(rustc_attrs)]\n+\n+struct AnyValue<T>(T);\n+\n+// No need to check for `Freeze` here, there's no\n+// `rustc_layout_scalar_valid_range_start` involved.\n+fn not_restricted(c: bool) -> impl Sized {\n+    if c {\n+        let x = AnyValue(not_restricted(false));\n+        &x.0;\n+    }\n+    2u32\n+}\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+struct NonZero<T>(T);\n+\n+// No need to check for `Freeze` here, we're not borrowing the field.\n+fn not_field(c: bool) -> impl Sized {\n+    if c {\n+        let x = unsafe { NonZero(not_field(false)) };\n+        &x;\n+    }\n+    5u32\n+}\n+\n+fn main() {}"}]}