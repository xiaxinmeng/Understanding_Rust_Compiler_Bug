{"sha": "99d3798b6cef2d1e427b6c50ffef65c28e43acbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZDM3OThiNmNlZjJkMWU0MjdiNmM1MGZmZWY2NWMyOGU0M2FjYmY=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-03T20:50:45Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-04-29T19:36:55Z"}, "message": "Do not compute entry parent when not required.", "tree": {"sha": "74e26c2cc759c0efc14fb8ed6f6409e55c2d51b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74e26c2cc759c0efc14fb8ed6f6409e55c2d51b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99d3798b6cef2d1e427b6c50ffef65c28e43acbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99d3798b6cef2d1e427b6c50ffef65c28e43acbf", "html_url": "https://github.com/rust-lang/rust/commit/99d3798b6cef2d1e427b6c50ffef65c28e43acbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99d3798b6cef2d1e427b6c50ffef65c28e43acbf/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d341e1e288cfb39cf7e8644c468654a9b8e0fca", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d341e1e288cfb39cf7e8644c468654a9b8e0fca", "html_url": "https://github.com/rust-lang/rust/commit/2d341e1e288cfb39cf7e8644c468654a9b8e0fca"}], "stats": {"total": 227, "additions": 127, "deletions": 100}, "files": [{"sha": "23780b38196d52fe99d27e214bb9cd5bff262905", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99d3798b6cef2d1e427b6c50ffef65c28e43acbf/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d3798b6cef2d1e427b6c50ffef65c28e43acbf/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=99d3798b6cef2d1e427b6c50ffef65c28e43acbf", "patch": "@@ -1,5 +1,5 @@\n use crate::arena::Arena;\n-use crate::hir::map::{Entry, HirOwnerData, Map};\n+use crate::hir::map::{HirOwnerData, Map};\n use crate::hir::{Owner, OwnerNodes, ParentedNode};\n use crate::ich::StableHashingContext;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -61,6 +61,13 @@ fn hash_body(\n     stable_hasher.finish()\n }\n \n+/// Represents an entry and its parent `HirId`.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Entry<'hir> {\n+    parent: HirId,\n+    node: Node<'hir>,\n+}\n+\n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn root(\n         sess: &'a Session,"}, {"sha": "5e6e79540d6b58a8254f20ae2776e40af161ae75", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 117, "deletions": 97, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/99d3798b6cef2d1e427b6c50ffef65c28e43acbf/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d3798b6cef2d1e427b6c50ffef65c28e43acbf/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=99d3798b6cef2d1e427b6c50ffef65c28e43acbf", "patch": "@@ -14,6 +14,7 @@ use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::*;\n+use rustc_index::vec::Idx;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, Ident, Symbol};\n@@ -23,13 +24,6 @@ use rustc_target::spec::abi::Abi;\n pub mod blocks;\n mod collector;\n \n-/// Represents an entry and its parent `HirId`.\n-#[derive(Copy, Clone, Debug)]\n-pub struct Entry<'hir> {\n-    parent: HirId,\n-    node: Node<'hir>,\n-}\n-\n fn fn_decl<'hir>(node: Node<'hir>) -> Option<&'hir FnDecl<'hir>> {\n     match node {\n         Node::Item(Item { kind: ItemKind::Fn(sig, _, _), .. })\n@@ -108,10 +102,48 @@ impl<'hir> Iterator for ParentHirIterator<'_, 'hir> {\n             }\n \n             self.current_id = parent_id;\n-            if let Some(entry) = self.map.find_entry(parent_id) {\n-                return Some((parent_id, entry.node));\n+            if let Some(node) = self.map.find(parent_id) {\n+                return Some((parent_id, node));\n+            }\n+            // If this `HirId` doesn't have an entry, skip it and look for its `parent_id`.\n+        }\n+    }\n+}\n+\n+/// An iterator that walks up the ancestor tree of a given `HirId`.\n+/// Constructed using `tcx.hir().parent_owner_iter(hir_id)`.\n+pub struct ParentOwnerIterator<'map, 'hir> {\n+    current_id: HirId,\n+    map: &'map Map<'hir>,\n+}\n+\n+impl<'hir> Iterator for ParentOwnerIterator<'_, 'hir> {\n+    type Item = (HirId, Node<'hir>);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.current_id.local_id.index() != 0 {\n+            self.current_id.local_id = ItemLocalId::new(0);\n+            if let Some(node) = self.map.find(self.current_id) {\n+                return Some((self.current_id, node));\n+            }\n+        }\n+        if self.current_id == CRATE_HIR_ID {\n+            return None;\n+        }\n+        loop {\n+            // There are nodes that do not have entries, so we need to skip them.\n+            let parent_id = self.map.def_key(self.current_id.owner).parent;\n+\n+            let parent_id = parent_id.map_or(CRATE_HIR_ID.owner, |local_def_index| {\n+                let def_id = LocalDefId { local_def_index };\n+                self.map.local_def_id_to_hir_id(def_id).owner\n+            });\n+            self.current_id = HirId::make_owner(parent_id);\n+\n+            // If this `HirId` doesn't have an entry, skip it and look for its `parent_id`.\n+            if let Some(node) = self.map.find(self.current_id) {\n+                return Some((self.current_id, node));\n             }\n-            // If this `HirId` doesn't have an `Entry`, skip it and look for its `parent_id`.\n         }\n     }\n }\n@@ -144,7 +176,7 @@ impl<'hir> Map<'hir> {\n             bug!(\n                 \"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n                 hir_id,\n-                self.find_entry(hir_id)\n+                self.find(hir_id)\n             )\n         })\n     }\n@@ -251,27 +283,61 @@ impl<'hir> Map<'hir> {\n             .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", local_def_id))\n     }\n \n-    fn find_entry(&self, id: HirId) -> Option<Entry<'hir>> {\n+    pub fn find_parent_node(&self, id: HirId) -> Option<HirId> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n-            let owner = self.tcx.hir_owner(id.owner);\n-            owner.map(|owner| Entry { parent: owner.parent, node: owner.node })\n+            let owner = self.tcx.hir_owner(id.owner)?;\n+            Some(owner.parent)\n         } else {\n-            let owner = self.tcx.hir_owner_nodes(id.owner);\n-            owner.and_then(|owner| {\n-                let node = owner.nodes[id.local_id].as_ref();\n-                // FIXME(eddyb) use a single generic type instead of having both\n-                // `Entry` and `ParentedNode`, which are effectively the same.\n-                // Alternatively, rewrite code using `Entry` to use `ParentedNode`.\n-                node.map(|node| Entry {\n-                    parent: HirId { owner: id.owner, local_id: node.parent },\n-                    node: node.node,\n-                })\n-            })\n+            let owner = self.tcx.hir_owner_nodes(id.owner)?;\n+            let node = owner.nodes[id.local_id].as_ref()?;\n+            let hir_id = HirId { owner: id.owner, local_id: node.parent };\n+            Some(hir_id)\n         }\n     }\n \n-    fn get_entry(&self, id: HirId) -> Entry<'hir> {\n-        self.find_entry(id).unwrap()\n+    pub fn get_parent_node(&self, hir_id: HirId) -> HirId {\n+        self.find_parent_node(hir_id).unwrap()\n+    }\n+\n+    /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n+    pub fn find(&self, id: HirId) -> Option<Node<'hir>> {\n+        if id.local_id == ItemLocalId::from_u32(0) {\n+            let owner = self.tcx.hir_owner(id.owner)?;\n+            Some(owner.node)\n+        } else {\n+            let owner = self.tcx.hir_owner_nodes(id.owner)?;\n+            let node = owner.nodes[id.local_id].as_ref()?;\n+            Some(node.node)\n+        }\n+    }\n+\n+    /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n+    pub fn get(&self, id: HirId) -> Node<'hir> {\n+        self.find(id).unwrap_or_else(|| bug!(\"couldn't find hir id {} in the HIR map\", id))\n+    }\n+\n+    pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n+        id.as_local().and_then(|id| self.find(self.local_def_id_to_hir_id(id)))\n+    }\n+\n+    pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n+        self.get_if_local(id).and_then(|node| match &node {\n+            Node::ImplItem(impl_item) => Some(&impl_item.generics),\n+            Node::TraitItem(trait_item) => Some(&trait_item.generics),\n+            Node::Item(Item {\n+                kind:\n+                    ItemKind::Fn(_, generics, _)\n+                    | ItemKind::TyAlias(_, generics)\n+                    | ItemKind::Enum(_, generics)\n+                    | ItemKind::Struct(_, generics)\n+                    | ItemKind::Union(_, generics)\n+                    | ItemKind::Trait(_, _, generics, ..)\n+                    | ItemKind::TraitAlias(generics, _)\n+                    | ItemKind::Impl(Impl { generics, .. }),\n+                ..\n+            }) => Some(generics),\n+            _ => None,\n+        })\n     }\n \n     pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n@@ -436,7 +502,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = self.local_def_id_to_hir_id(module);\n-        match self.get_entry(hir_id).node {\n+        match self.get(hir_id) {\n             Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n             Node::Crate(item) => (&item, item.inner, hir_id),\n             node => panic!(\"not a module: {:?}\", node),\n@@ -475,60 +541,18 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n-    pub fn get(&self, id: HirId) -> Node<'hir> {\n-        self.find(id).unwrap_or_else(|| bug!(\"couldn't find hir id {} in the HIR map\", id))\n-    }\n-\n-    pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n-        id.as_local().and_then(|id| self.find(self.local_def_id_to_hir_id(id)))\n-    }\n-\n-    pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n-        self.get_if_local(id).and_then(|node| match &node {\n-            Node::ImplItem(impl_item) => Some(&impl_item.generics),\n-            Node::TraitItem(trait_item) => Some(&trait_item.generics),\n-            Node::Item(Item {\n-                kind:\n-                    ItemKind::Fn(_, generics, _)\n-                    | ItemKind::TyAlias(_, generics)\n-                    | ItemKind::Enum(_, generics)\n-                    | ItemKind::Struct(_, generics)\n-                    | ItemKind::Union(_, generics)\n-                    | ItemKind::Trait(_, _, generics, ..)\n-                    | ItemKind::TraitAlias(generics, _)\n-                    | ItemKind::Impl(Impl { generics, .. }),\n-                ..\n-            }) => Some(generics),\n-            _ => None,\n-        })\n-    }\n-\n-    /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n-    pub fn find(&self, hir_id: HirId) -> Option<Node<'hir>> {\n-        self.find_entry(hir_id).map(|entry| entry.node)\n-    }\n-\n-    /// Similar to `get_parent`; returns the parent HIR Id, or just `hir_id` if there\n-    /// is no parent. Note that the parent may be `CRATE_HIR_ID`, which is not itself\n-    /// present in the map, so passing the return value of `get_parent_node` to\n-    /// `get` may in fact panic.\n-    /// This function returns the immediate parent in the HIR, whereas `get_parent`\n-    /// returns the enclosing item. Note that this might not be the actual parent\n-    /// node in the HIR -- some kinds of nodes are not in the map and these will\n-    /// never appear as the parent node. Thus, you can always walk the parent nodes\n-    /// from a node to the root of the HIR (unless you get back the same ID here,\n-    /// which can happen if the ID is not in the map itself or is just weird).\n-    pub fn get_parent_node(&self, hir_id: HirId) -> HirId {\n-        self.get_entry(hir_id).parent\n-    }\n-\n     /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n     /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n     pub fn parent_iter(&self, current_id: HirId) -> ParentHirIterator<'_, 'hir> {\n         ParentHirIterator { current_id, map: self }\n     }\n \n+    /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n+    /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n+    pub fn parent_owner_iter(&self, current_id: HirId) -> ParentOwnerIterator<'_, 'hir> {\n+        ParentOwnerIterator { current_id, map: self }\n+    }\n+\n     /// Checks if the node is left-hand side of an assignment.\n     pub fn is_lhs(&self, id: HirId) -> bool {\n         match self.find(self.get_parent_node(id)) {\n@@ -549,7 +573,7 @@ impl<'hir> Map<'hir> {\n     /// Whether `hir_id` corresponds to a `mod` or a crate.\n     pub fn is_hir_id_module(&self, hir_id: HirId) -> bool {\n         matches!(\n-            self.get_entry(hir_id).node,\n+            self.get(hir_id),\n             Node::Item(Item { kind: ItemKind::Mod(_), .. }) | Node::Crate(..)\n         )\n     }\n@@ -579,8 +603,8 @@ impl<'hir> Map<'hir> {\n     pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n         let mut iter = self.parent_iter(id).peekable();\n         let mut ignore_tail = false;\n-        if let Some(entry) = self.find_entry(id) {\n-            if let Node::Expr(Expr { kind: ExprKind::Ret(_), .. }) = entry.node {\n+        if let Some(node) = self.find(id) {\n+            if let Node::Expr(Expr { kind: ExprKind::Ret(_), .. }) = node {\n                 // When dealing with `return` statements, we don't care about climbing only tail\n                 // expressions.\n                 ignore_tail = true;\n@@ -617,23 +641,23 @@ impl<'hir> Map<'hir> {\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n-        for (hir_id, node) in self.parent_iter(hir_id) {\n-            match node {\n-                Node::Crate(_)\n-                | Node::Item(_)\n-                | Node::ForeignItem(_)\n-                | Node::TraitItem(_)\n-                | Node::ImplItem(_) => return hir_id,\n-                _ => {}\n+        for (hir_id, node) in self.parent_owner_iter(hir_id) {\n+            if let Node::Crate(_)\n+            | Node::Item(_)\n+            | Node::ForeignItem(_)\n+            | Node::TraitItem(_)\n+            | Node::ImplItem(_) = node\n+            {\n+                return hir_id;\n             }\n         }\n-        hir_id\n+        CRATE_HIR_ID\n     }\n \n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub(super) fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n-        for (hir_id, node) in self.parent_iter(hir_id) {\n+        for (hir_id, node) in self.parent_owner_iter(hir_id) {\n             if let Node::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n                 return hir_id;\n             }\n@@ -707,12 +731,8 @@ impl<'hir> Map<'hir> {\n \n     pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n-        if let Some(entry) = self.find_entry(parent) {\n-            if let Entry {\n-                node: Node::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }),\n-                ..\n-            } = entry\n-            {\n+        if let Some(node) = self.find(parent) {\n+            if let Node::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }) = node {\n                 return *abi;\n             }\n         }\n@@ -806,7 +826,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn opt_span(&self, hir_id: HirId) -> Option<Span> {\n-        let span = match self.find_entry(hir_id)?.node {\n+        let span = match self.find(hir_id)? {\n             Node::Param(param) => param.span,\n             Node::Item(item) => match &item.kind {\n                 ItemKind::Fn(sig, _, _) => sig.span,\n@@ -855,7 +875,7 @@ impl<'hir> Map<'hir> {\n     /// Like `hir.span()`, but includes the body of function items\n     /// (instead of just the function header)\n     pub fn span_with_body(&self, hir_id: HirId) -> Span {\n-        match self.find_entry(hir_id).map(|entry| entry.node) {\n+        match self.find(hir_id) {\n             Some(Node::TraitItem(item)) => item.span,\n             Some(Node::ImplItem(impl_item)) => impl_item.span,\n             Some(Node::Item(item)) => item.span,"}, {"sha": "dd1a985353f25a1a6d3fe737aadaa9d18679af5b", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99d3798b6cef2d1e427b6c50ffef65c28e43acbf/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d3798b6cef2d1e427b6c50ffef65c28e43acbf/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=99d3798b6cef2d1e427b6c50ffef65c28e43acbf", "patch": "@@ -38,10 +38,10 @@ pub struct Owner<'tcx> {\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let Owner { parent, node } = self;\n+        let Owner { node, parent } = self;\n         hcx.while_hashing_hir_bodies(false, |hcx| {\n             parent.hash_stable(hcx, hasher);\n-            node.hash_stable(hcx, hasher);\n+            node.hash_stable(hcx, hasher)\n         });\n     }\n }"}]}