{"sha": "6a3545ef055a6c3b46593c2b17512486dc3fa0ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMzU0NWVmMDU1YTZjM2I0NjU5M2MyYjE3NTEyNDg2ZGMzZmEwZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-05T03:52:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-05T03:52:39Z"}, "message": "Auto merge of #27439 - vberger:more_perseverant_resolve, r=nrc\n\n(This is a second try at #26242. This time I think things should be ok.)\r\n\r\nThe current algorithm handling import resolutions works sequentially, handling imports in the order they appear in the source file, and blocking/bailing on the first one generating an error/being unresolved.\r\n\r\nThis can lead to situations where the order of the `use` statements can make the difference between \"this code compiles\" and \"this code fails on an unresolved import\" (see #18083 for example). This is especially true when considering glob imports.\r\n\r\nThis PR changes the behaviour of the algorithm to instead try to resolve all imports in a module. If one fails, it is recorded and the next one is tried (instead of directly giving up). Also, all errors generated are stored (and not reported directly).\r\n\r\nThe main loop of the algorithms guaranties that the algorithm will always finish: if a round of resolution does not resolve anything new, we are stuck and give up. At this point, the new version of the algorithm will display all errors generated by the last round of resolve. This way we are sure to not silence relevant errors or help messages, but also to not give up too early.\r\n\r\n**As a consequence, the import resolution becomes independent of the order in which the `use` statements are written in the source files.** I personally don't see any situations where this could be a problem, but this might need some thought.\r\n\r\nI passed `rpass` and `cfail` tests on my computer, and now am compiling a full stage2 compiler to ensure the crates reporting errors in my previous attempts still build correctly. I guess once I have checked it, this will need a crater run?\r\n\r\nFixes #18083.\r\n\r\nr? @alexcrichton , cc @nrc @brson", "tree": {"sha": "220bd5614ffff7215341328df2b5682ad9d95201", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/220bd5614ffff7215341328df2b5682ad9d95201"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a3545ef055a6c3b46593c2b17512486dc3fa0ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3545ef055a6c3b46593c2b17512486dc3fa0ee", "html_url": "https://github.com/rust-lang/rust/commit/6a3545ef055a6c3b46593c2b17512486dc3fa0ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbe415a4a7c3e10eff6d9a4b08128c341742e401", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbe415a4a7c3e10eff6d9a4b08128c341742e401", "html_url": "https://github.com/rust-lang/rust/commit/dbe415a4a7c3e10eff6d9a4b08128c341742e401"}, {"sha": "58e35d7c2ab93637c6c549b03a04f900fb3499d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/58e35d7c2ab93637c6c549b03a04f900fb3499d2", "html_url": "https://github.com/rust-lang/rust/commit/58e35d7c2ab93637c6c549b03a04f900fb3499d2"}], "stats": {"total": 243, "additions": 189, "deletions": 54}, "files": [{"sha": "8c2bb9a88025f17c90030f1de1cbc3ab0991622c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6a3545ef055a6c3b46593c2b17512486dc3fa0ee", "patch": "@@ -20,6 +20,7 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(associated_consts)]\n+#![feature(borrow_state)]\n #![feature(rc_weak)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -176,7 +177,7 @@ pub enum ResolutionError<'a> {\n     /// error E0431: `self` import can only appear in an import list with a non-empty prefix\n     SelfImportOnlyInImportListWithNonEmptyPrefix,\n     /// error E0432: unresolved import\n-    UnresolvedImport(Option<(&'a str, Option<&'a str>)>),\n+    UnresolvedImport(Option<(&'a str, &'a str)>),\n     /// error E0433: failed to resolve\n     FailedToResolve(&'a str),\n     /// error E0434: can't capture dynamic environment in a fn item\n@@ -359,8 +360,7 @@ fn resolve_error<'b, 'a:'b, 'tcx:'a>(resolver: &'b Resolver<'a, 'tcx>, span: syn\n         }\n         ResolutionError::UnresolvedImport(name) => {\n             let msg = match name {\n-                Some((n, Some(p))) => format!(\"unresolved import `{}`{}\", n, p),\n-                Some((n, None)) => format!(\"unresolved import (maybe you meant `{}::*`?)\", n),\n+                Some((n, p)) => format!(\"unresolved import `{}`{}\", n, p),\n                 None => \"unresolved import\".to_owned()\n             };\n             span_err!(resolver.session, span, E0432, \"{}\", msg);\n@@ -539,8 +539,8 @@ enum ResolveResult<T> {\n }\n \n impl<T> ResolveResult<T> {\n-    fn indeterminate(&self) -> bool {\n-        match *self { Indeterminate => true, _ => false }\n+    fn success(&self) -> bool {\n+        match *self { Success(_) => true, _ => false }\n     }\n }\n \n@@ -732,7 +732,12 @@ impl Module {\n     }\n \n     fn all_imports_resolved(&self) -> bool {\n-        self.imports.borrow().len() == self.resolved_import_count.get()\n+        if self.imports.borrow_state() == ::std::cell::BorrowState::Writing {\n+            // it is currently being resolved ! so nope\n+            false\n+        } else {\n+            self.imports.borrow().len() == self.resolved_import_count.get()\n+        }\n     }\n }\n \n@@ -1815,19 +1820,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let imports = module_.imports.borrow();\n         let import_count = imports.len();\n         if index != import_count {\n-            let sn = self.session\n-                         .codemap()\n-                         .span_to_snippet((*imports)[index].span)\n-                         .unwrap();\n-            if sn.contains(\"::\") {\n-                resolve_error(self,\n-                              (*imports)[index].span,\n-                              ResolutionError::UnresolvedImport(None));\n-            } else {\n-                resolve_error(self,\n-                              (*imports)[index].span,\n-                              ResolutionError::UnresolvedImport(Some((&*sn, None))));\n-            }\n+            resolve_error(self,\n+                          (*imports)[index].span,\n+                          ResolutionError::UnresolvedImport(None));\n         }\n \n         // Descend into children and anonymous children."}, {"sha": "412643ba9454642ae422eee7865fcffcdb9695c3", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 61, "deletions": 28, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=6a3545ef055a6c3b46593c2b17512486dc3fa0ee", "patch": "@@ -184,6 +184,11 @@ impl ImportResolution {\n     }\n }\n \n+struct ImportResolvingError {\n+    span: Span,\n+    path: String,\n+    help: String,\n+}\n \n struct ImportResolver<'a, 'b:'a, 'tcx:'b> {\n     resolver: &'a mut Resolver<'b, 'tcx>\n@@ -208,15 +213,28 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                    i, self.resolver.unresolved_imports);\n \n             let module_root = self.resolver.graph_root.get_module();\n-            self.resolve_imports_for_module_subtree(module_root.clone());\n+            let errors = self.resolve_imports_for_module_subtree(module_root.clone());\n \n             if self.resolver.unresolved_imports == 0 {\n                 debug!(\"(resolving imports) success\");\n                 break;\n             }\n \n             if self.resolver.unresolved_imports == prev_unresolved_imports {\n-                self.resolver.report_unresolved_imports(module_root);\n+                // resolving failed\n+                if errors.len() > 0 {\n+                    for e in errors {\n+                        resolve_error(self.resolver,\n+                                      e.span,\n+                                      ResolutionError::UnresolvedImport(Some((&e.path, &e.help))));\n+                    }\n+                } else {\n+                    // Report unresolved imports only if no hard error was already reported\n+                    // to avoid generating multiple errors on the same import.\n+                    // Imports that are still indeterminate at this point are actually blocked\n+                    // by errored imports, so there is no point reporting them.\n+                    self.resolver.report_unresolved_imports(module_root);\n+                }\n                 break;\n             }\n \n@@ -227,11 +245,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Attempts to resolve imports for the given module and all of its\n     /// submodules.\n-    fn resolve_imports_for_module_subtree(&mut self, module_: Rc<Module>) {\n+    fn resolve_imports_for_module_subtree(&mut self, module_: Rc<Module>)\n+                                          -> Vec<ImportResolvingError> {\n+        let mut errors = Vec::new();\n         debug!(\"(resolving imports for module subtree) resolving {}\",\n                module_to_string(&*module_));\n         let orig_module = replace(&mut self.resolver.current_module, module_.clone());\n-        self.resolve_imports_for_module(module_.clone());\n+        errors.extend(self.resolve_imports_for_module(module_.clone()));\n         self.resolver.current_module = orig_module;\n \n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n@@ -241,53 +261,67 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     // Nothing to do.\n                 }\n                 Some(child_module) => {\n-                    self.resolve_imports_for_module_subtree(child_module);\n+                    errors.extend(self.resolve_imports_for_module_subtree(child_module));\n                 }\n             }\n         }\n \n         for (_, child_module) in module_.anonymous_children.borrow().iter() {\n-            self.resolve_imports_for_module_subtree(child_module.clone());\n+            errors.extend(self.resolve_imports_for_module_subtree(child_module.clone()));\n         }\n+\n+        errors\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(&mut self, module: Rc<Module>) {\n+    fn resolve_imports_for_module(&mut self, module: Rc<Module>) -> Vec<ImportResolvingError> {\n+        let mut errors = Vec::new();\n+\n         if module.all_imports_resolved() {\n             debug!(\"(resolving imports for module) all imports resolved for \\\n                    {}\",\n                    module_to_string(&*module));\n-            return;\n+            return errors;\n         }\n \n-        let imports = module.imports.borrow();\n+        let mut imports = module.imports.borrow_mut();\n         let import_count = imports.len();\n-        while module.resolved_import_count.get() < import_count {\n+        let mut indeterminate_imports = Vec::new();\n+        while module.resolved_import_count.get() + indeterminate_imports.len() < import_count {\n             let import_index = module.resolved_import_count.get();\n-            let import_directive = &(*imports)[import_index];\n             match self.resolve_import_for_module(module.clone(),\n-                                                 import_directive) {\n+                                                 &imports[import_index]) {\n                 ResolveResult::Failed(err) => {\n+                    let import_directive = &imports[import_index];\n                     let (span, help) = match err {\n                         Some((span, msg)) => (span, format!(\". {}\", msg)),\n                         None => (import_directive.span, String::new())\n                     };\n-                    resolve_error(self.resolver,\n-                                    span,\n-                                    ResolutionError::UnresolvedImport(\n-                                                Some((&*import_path_to_string(\n-                                                        &import_directive.module_path,\n-                                                        import_directive.subclass),\n-                                                      Some(&*help))))\n-                                   );\n+                    errors.push(ImportResolvingError {\n+                                    span: span,\n+                                    path: import_path_to_string(\n+                                            &import_directive.module_path,\n+                                            import_directive.subclass\n+                                         ),\n+                                    help: help\n+                                });\n+                }\n+                ResolveResult::Indeterminate => {}\n+                ResolveResult::Success(()) => {\n+                    // count success\n+                    module.resolved_import_count\n+                          .set(module.resolved_import_count.get() + 1);\n+                    continue;\n                 }\n-                ResolveResult::Indeterminate => break, // Bail out. We'll come around next time.\n-                ResolveResult::Success(()) => () // Good. Continue.\n             }\n+            // This resolution was not successful, keep it for later\n+            indeterminate_imports.push(imports.swap_remove(import_index));\n \n-            module.resolved_import_count\n-                  .set(module.resolved_import_count.get() + 1);\n         }\n+\n+        imports.extend(indeterminate_imports);\n+\n+        errors\n     }\n \n     /// Attempts to resolve the given import. The return value indicates\n@@ -367,11 +401,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         // Decrement the count of unresolved globs if necessary. But only if\n-        // the resolution result is indeterminate -- otherwise we'll stop\n-        // processing imports here. (See the loop in\n-        // resolve_imports_for_module).\n+        // the resolution result is a success -- other cases will\n+        // be handled by the main loop.\n \n-        if !resolution_result.indeterminate() {\n+        if resolution_result.success() {\n             match import_directive.subclass {\n                 GlobImport => {\n                     assert!(module_.glob_count.get() >= 1);"}, {"sha": "0f3d54d5fe3d8778d4f15dd09a8bbd75c99ca115", "filename": "src/test/compile-fail/import-shadow-6.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Ftest%2Fcompile-fail%2Fimport-shadow-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Ftest%2Fcompile-fail%2Fimport-shadow-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-6.rs?ref=6a3545ef055a6c3b46593c2b17512486dc3fa0ee", "patch": "@@ -12,8 +12,8 @@\n \n #![no_implicit_prelude]\n \n-use qux::*;\n-use foo::*; //~ERROR a type named `Baz` has already been imported in this module\n+use qux::*; //~ERROR a type named `Baz` has already been imported in this module\n+use foo::*;\n \n mod foo {\n     pub type Baz = isize;"}, {"sha": "bf26a591b4b5d61abb447f654de542328846bff1", "filename": "src/test/compile-fail/issue-25396.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Ftest%2Fcompile-fail%2Fissue-25396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Ftest%2Fcompile-fail%2Fissue-25396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25396.rs?ref=6a3545ef055a6c3b46593c2b17512486dc3fa0ee", "patch": "@@ -11,14 +11,14 @@\n use foo::baz;\n use bar::baz; //~ ERROR a module named `baz` has already been imported\n \n-use foo::Quux;\n use bar::Quux; //~ ERROR a trait named `Quux` has already been imported\n+use foo::Quux;\n \n-use foo::blah;\n-use bar::blah; //~ ERROR a type named `blah` has already been imported\n+use foo::blah; //~ ERROR a type named `blah` has already been imported\n+use bar::blah;\n \n-use foo::WOMP;\n-use bar::WOMP; //~ ERROR a value named `WOMP` has already been imported\n+use foo::WOMP; //~ ERROR a value named `WOMP` has already been imported\n+use bar::WOMP;\n \n fn main() {}\n "}, {"sha": "a7949e7d6e3b15dfd469f2bbcc28532cb968a76c", "filename": "src/test/run-pass/import-glob-1.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs?ref=6a3545ef055a6c3b46593c2b17512486dc3fa0ee", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This should resolve fine. Prior to fix, the last import\n+// was being tried too early, and marked as unrsolved before\n+// the glob import had a chance to be resolved.\n+\n+mod bar {\n+    pub use self::middle::*;\n+\n+    mod middle {\n+        pub use self::baz::Baz;\n+\n+        mod baz {\n+            pub enum Baz {\n+                Baz1,\n+                Baz2\n+            }\n+        }\n+    }\n+}\n+\n+mod foo {\n+    use bar::Baz::{Baz1, Baz2};\n+}\n+\n+fn main() {}"}, {"sha": "ff26e186db3934fef8d96e15f556b189e34356c6", "filename": "src/test/run-pass/issue-18083.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Ftest%2Frun-pass%2Fissue-18083.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Ftest%2Frun-pass%2Fissue-18083.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18083.rs?ref=6a3545ef055a6c3b46593c2b17512486dc3fa0ee", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// These crossed imports should resolve fine, and not block on\n+// each other and be reported as unresolved.\n+\n+mod a {\n+    use b::{B};\n+    pub use self::inner::A;\n+\n+    mod inner {\n+        pub struct A;\n+    }\n+}\n+\n+mod b {\n+    use a::{A};\n+    pub use self::inner::B;\n+\n+    mod inner {\n+        pub struct B;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "3c4777951302e17657ed0a2f6547dac7b76affc2", "filename": "src/test/run-pass/issue-4865-1.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Ftest%2Frun-pass%2Fissue-4865-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3545ef055a6c3b46593c2b17512486dc3fa0ee/src%2Ftest%2Frun-pass%2Fissue-4865-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4865-1.rs?ref=6a3545ef055a6c3b46593c2b17512486dc3fa0ee", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This should resolve fine.\n+// Prior to fix, the crossed imports between a and b\n+// would block on the glob import, itself never being resolved\n+// because these previous imports were not resolved.\n+\n+pub mod a {\n+    use b::fn_b;\n+    use c::*;\n+\n+    pub fn fn_a(){\n+    }\n+}\n+\n+pub mod b {\n+    use a::fn_a;\n+    use c::*;\n+\n+    pub fn fn_b(){\n+    }\n+}\n+\n+pub mod c{\n+    pub fn fn_c(){\n+    }\n+}\n+\n+use a::fn_a;\n+use b::fn_b;\n+\n+fn main() {\n+}"}]}