{"sha": "866250c6d4ca63fb56b7d58e55f8949337663998", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NjI1MGM2ZDRjYTYzZmI1NmI3ZDU4ZTU1Zjg5NDkzMzc2NjM5OTg=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-01-27T00:22:12Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-07-22T13:33:59Z"}, "message": "prototype Placer protocol for unstable overloaded-box and placement-in.", "tree": {"sha": "c59ea396b51429ddaf14b0accf801c6ea009a36f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c59ea396b51429ddaf14b0accf801c6ea009a36f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/866250c6d4ca63fb56b7d58e55f8949337663998", "comment_count": 12, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/866250c6d4ca63fb56b7d58e55f8949337663998", "html_url": "https://github.com/rust-lang/rust/commit/866250c6d4ca63fb56b7d58e55f8949337663998", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/866250c6d4ca63fb56b7d58e55f8949337663998/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1829fa5199bae5a192c771807c532badce14be37", "url": "https://api.github.com/repos/rust-lang/rust/commits/1829fa5199bae5a192c771807c532badce14be37", "html_url": "https://github.com/rust-lang/rust/commit/1829fa5199bae5a192c771807c532badce14be37"}], "stats": {"total": 338, "additions": 333, "deletions": 5}, "files": [{"sha": "4b571a43627f489e214dc50c1e653678d982db87", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 102, "deletions": 5, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/866250c6d4ca63fb56b7d58e55f8949337663998/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/866250c6d4ca63fb56b7d58e55f8949337663998/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=866250c6d4ca63fb56b7d58e55f8949337663998", "patch": "@@ -55,13 +55,16 @@\n \n use core::prelude::*;\n \n+use heap;\n+\n use core::any::Any;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n-use core::marker::Unsize;\n+use core::marker::{self, Unsize};\n use core::mem;\n use core::ops::{CoerceUnsized, Deref, DerefMut};\n+use core::ops::{Placer, Boxed, Place, InPlace, BoxPlace};\n use core::ptr::Unique;\n use core::raw::{TraitObject};\n \n@@ -83,15 +86,110 @@ use core::raw::{TraitObject};\n #[lang = \"exchange_heap\"]\n #[unstable(feature = \"box_heap\",\n            reason = \"may be renamed; uncertain about custom allocator design\")]\n-pub const HEAP: () = ();\n+pub const HEAP: ExchangeHeapSingleton =\n+    ExchangeHeapSingleton { _force_singleton: () };\n+\n+/// This the singleton type used solely for `boxed::HEAP`.\n+#[derive(Copy, Clone)]\n+pub struct ExchangeHeapSingleton { _force_singleton: () }\n \n /// A pointer type for heap allocation.\n ///\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[fundamental]\n-pub struct Box<T>(Unique<T>);\n+pub struct Box<T: ?Sized>(Unique<T>);\n+\n+/// `IntermediateBox` represents uninitialized backing storage for `Box`.\n+///\n+/// FIXME (pnkfelix): Ideally we would just reuse `Box<T>` instead of\n+/// introducing a separate `IntermediateBox<T>`; but then you hit\n+/// issues when you e.g. attempt to destructure an instance of `Box`,\n+/// since it is a lang item and so it gets special handling by the\n+/// compiler.  Easier just to make this parallel type for now.\n+///\n+/// FIXME (pnkfelix): Currently the `box` protocol only supports\n+/// creating instances of sized types. This IntermediateBox is\n+/// designed to be forward-compatible with a future protocol that\n+/// supports creating instances of unsized types; that is why the type\n+/// parameter has the `?Sized` generalization marker, and is also why\n+/// this carries an explicit size. However, it probably does not need\n+/// to carry the explicit alignment; that is just a work-around for\n+/// the fact that the `align_of` intrinsic currently requires the\n+/// input type to be Sized (which I do not think is strictly\n+/// necessary).\n+#[unstable(feature = \"placement_in\", reason = \"placement box design is still being worked out.\")]\n+pub struct IntermediateBox<T: ?Sized>{\n+    ptr: *mut u8,\n+    size: usize,\n+    align: usize,\n+    marker: marker::PhantomData<*mut T>,\n+}\n+\n+impl<T> Place<T> for IntermediateBox<T> {\n+    fn pointer(&mut self) -> *mut T {\n+        unsafe { ::core::mem::transmute(self.ptr) }\n+    }\n+}\n+\n+unsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> {\n+    let p = b.ptr as *mut T;\n+    mem::forget(b);\n+    mem::transmute(p)\n+}\n+\n+fn make_place<T>() -> IntermediateBox<T> {\n+    let size = mem::size_of::<T>();\n+    let align = mem::align_of::<T>();\n+\n+    let p = if size == 0 {\n+        heap::EMPTY as *mut u8\n+    } else {\n+        let p = unsafe {\n+            heap::allocate(size, align)\n+        };\n+        if p.is_null() {\n+            panic!(\"Box make_place allocation failure.\");\n+        }\n+        p\n+    };\n+\n+    IntermediateBox { ptr: p, size: size, align: align, marker: marker::PhantomData }\n+}\n+\n+impl<T> BoxPlace<T> for IntermediateBox<T> {\n+    fn make_place() -> IntermediateBox<T> { make_place() }\n+}\n+\n+impl<T> InPlace<T> for IntermediateBox<T> {\n+    type Owner = Box<T>;\n+    unsafe fn finalize(self) -> Box<T> { finalize(self) }\n+}\n+\n+impl<T> Boxed for Box<T> {\n+    type Data = T;\n+    type Place = IntermediateBox<T>;\n+    unsafe fn finalize(b: IntermediateBox<T>) -> Box<T> { finalize(b) }\n+}\n+\n+impl<T> Placer<T> for ExchangeHeapSingleton {\n+    type Place = IntermediateBox<T>;\n+\n+    fn make_place(self) -> IntermediateBox<T> {\n+        make_place()\n+    }\n+}\n+\n+impl<T: ?Sized> Drop for IntermediateBox<T> {\n+    fn drop(&mut self) {\n+        if self.size > 0 {\n+            unsafe {\n+                heap::deallocate(self.ptr, self.size, self.align)\n+            }\n+        }\n+    }\n+}\n \n impl<T> Box<T> {\n     /// Allocates memory on the heap and then moves `x` into it.\n@@ -199,8 +297,7 @@ impl<T: Clone> Clone for Box<T> {\n     /// let y = x.clone();\n     /// ```\n     #[inline]\n-    fn clone(&self) -> Box<T> { box {(**self).clone()} }\n-\n+    fn clone(&self) -> Box<T> { box (HEAP) {(**self).clone()} }\n     /// Copies `source`'s contents into `self` without creating a new allocation.\n     ///\n     /// # Examples"}, {"sha": "18e4e282f2223a05b42ed883a446a8cd1e6f76d0", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/866250c6d4ca63fb56b7d58e55f8949337663998/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/866250c6d4ca63fb56b7d58e55f8949337663998/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=866250c6d4ca63fb56b7d58e55f8949337663998", "patch": "@@ -1266,3 +1266,115 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n \n // *const T -> *const U\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n+\n+/// Both `in (PLACE) EXPR` and `box EXPR` desugar into expressions\n+/// that allocate an intermediate \"place\" that holds uninitialized\n+/// state.  The desugaring evaluates EXPR, and writes the result at\n+/// the address returned by the `pointer` method of this trait.\n+///\n+/// A `Place` can be thought of as a special representation for a\n+/// hypothetical `&uninit` reference (which Rust cannot currently\n+/// express directly). That is, it represents a pointer to\n+/// uninitialized storage.\n+///\n+/// The client is responsible for two steps: First, initializing the\n+/// payload (it can access its address via `pointer`). Second,\n+/// converting the agent to an instance of the owning pointer, via the\n+/// appropriate `finalize` method (see the `InPlace`.\n+///\n+/// If evaluating EXPR fails, then the destructor for the\n+/// implementation of Place to clean up any intermediate state\n+/// (e.g. deallocate box storage, pop a stack, etc).\n+pub trait Place<Data: ?Sized> {\n+    /// Returns the address where the input value will be written.\n+    /// Note that the data at this address is generally uninitialized,\n+    /// and thus one should use `ptr::write` for initializing it.\n+    fn pointer(&mut self) -> *mut Data;\n+}\n+\n+/// Interface to implementations of  `in (PLACE) EXPR`.\n+///\n+/// `in (PLACE) EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let p = PLACE;\n+/// let mut place = Placer::make_place(p);\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     std::ptr::write(raw_place, value);\n+///     InPlace::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `in (PLACE) EXPR` is derived from the type of `PLACE`;\n+/// if the type of `PLACE` is `P`, then the final type of the whole\n+/// expression is `P::Place::Owner` (see the `InPlace` and `Boxed`\n+/// traits).\n+///\n+/// Values for types implementing this trait usually are transient\n+/// intermediate values (e.g. the return value of `Vec::emplace_back`)\n+/// or `Copy`, since the `make_place` method takes `self` by value.\n+pub trait Placer<Data: ?Sized> {\n+    /// `Place` is the intermedate agent guarding the\n+    /// uninitialized state for `Data`.\n+    type Place: InPlace<Data>;\n+\n+    /// Creates a fresh place from `self`.\n+    fn make_place(self) -> Self::Place;\n+}\n+\n+/// Specialization of `Place` trait supporting `in (PLACE) EXPR`.\n+pub trait InPlace<Data: ?Sized>: Place<Data> {\n+    /// `Owner` is the type of the end value of `in (PLACE) EXPR`\n+    ///\n+    /// Note that when `in (PLACE) EXPR` is solely used for\n+    /// side-effecting an existing data-structure,\n+    /// e.g. `Vec::emplace_back`, then `Owner` need not carry any\n+    /// information at all (e.g. it can be the unit type `()` in that\n+    /// case).\n+    type Owner;\n+\n+    /// Converts self into the final value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// the returned instance of `Owner` and forgetting self.\n+    unsafe fn finalize(self) -> Self::Owner;\n+}\n+\n+/// Core trait for the `box EXPR` form.\n+///\n+/// `box EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let mut place = BoxPlace::make_place();\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     ::std::ptr::write(raw_place, value);\n+///     Boxed::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `box EXPR` is supplied from its surrounding\n+/// context; in the above expansion, the result type `T` is used\n+/// to determine which implementation of `Boxed` to use, and that\n+/// `<T as Boxed>` in turn dictates determines which\n+/// implementation of `BoxPlace` to use, namely:\n+/// `<<T as Boxed>::Place as BoxPlace>`.\n+pub trait Boxed {\n+    /// The kind of data that is stored in this kind of box.\n+    type Data;  /* (`Data` unused b/c cannot yet express below bound.) */\n+    /// The place that will negotiate the storage of the data.\n+    type Place; /* should be bounded by BoxPlace<Self::Data> */\n+\n+    /// Converts filled place into final owning value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// returned instance of `Self` and forgetting `filled`.\n+    unsafe fn finalize(filled: Self::Place) -> Self;\n+}\n+\n+/// Specialization of `Place` trait supporting `box EXPR`.\n+pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n+    /// Creates a globally fresh place.\n+    fn make_place() -> Self;\n+}"}, {"sha": "f27a96545ddfa4835ca2a782ef8579f5e0b99f80", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/866250c6d4ca63fb56b7d58e55f8949337663998/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/866250c6d4ca63fb56b7d58e55f8949337663998/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=866250c6d4ca63fb56b7d58e55f8949337663998", "patch": "@@ -555,6 +555,11 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                     None => {}\n                 }\n                 self.consume_expr(&**base);\n+                if place.is_some() {\n+                    self.tcx().sess.span_bug(\n+                        expr.span,\n+                        \"box with explicit place remains after expansion\");\n+                }\n             }\n \n             ast::ExprMac(..) => {"}, {"sha": "3a72a50b5caec34f5988d5702dbfddbfb9a2c0ed", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/866250c6d4ca63fb56b7d58e55f8949337663998/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/866250c6d4ca63fb56b7d58e55f8949337663998/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=866250c6d4ca63fb56b7d58e55f8949337663998", "patch": "@@ -33,6 +33,16 @@ use visit;\n use visit::Visitor;\n use std_inject;\n \n+// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n+// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n+fn mk_core_path(fld: &mut MacroExpander,\n+                span: Span,\n+                suffix: &[&'static str]) -> ast::Path {\n+    let mut idents = vec![fld.cx.ident_of_std(\"core\")];\n+    for s in suffix.iter() { idents.push(fld.cx.ident_of(*s)); }\n+    fld.cx.path_global(span, idents)\n+}\n+\n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     fn push_compiler_expansion(fld: &mut MacroExpander, span: Span, expansion_desc: &str) {\n         fld.cx.bt_push(ExpnInfo {\n@@ -47,6 +57,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     }\n \n     e.and_then(|ast::Expr {id, node, span}| match node {\n+\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprMac(mac) => {\n@@ -71,6 +82,109 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             })\n         }\n \n+        // Desugar ExprBox: `in (PLACE) EXPR`\n+        ast::ExprBox(Some(placer), value_expr) => {\n+            // to:\n+            //\n+            // let p = PLACE;\n+            // let mut place = Placer::make_place(p);\n+            // let raw_place = InPlace::pointer(&mut place);\n+            // let value = EXPR;\n+            // unsafe {\n+            //     std::ptr::write(raw_place, value);\n+            //     InPlace::finalize(place)\n+            // }\n+\n+            let value_span = value_expr.span;\n+            let placer_span = placer.span;\n+\n+            let placer_expr = fld.fold_expr(placer);\n+            let value_expr = fld.fold_expr(value_expr);\n+\n+            let placer_ident = token::gensym_ident(\"placer\");\n+            let agent_ident = token::gensym_ident(\"place\");\n+            let value_ident = token::gensym_ident(\"value\");\n+            let p_ptr_ident = token::gensym_ident(\"p_ptr\");\n+\n+            let placer = fld.cx.expr_ident(span, placer_ident);\n+            let agent = fld.cx.expr_ident(span, agent_ident);\n+            let value = fld.cx.expr_ident(span, value_ident);\n+            let p_ptr = fld.cx.expr_ident(span, p_ptr_ident);\n+\n+            let make_place = [\"ops\", \"Placer\", \"make_place\"];\n+            let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n+            let ptr_write = [\"ptr\", \"write\"];\n+            let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n+\n+            let make_call = |fld: &mut MacroExpander, p, args| {\n+                let path = mk_core_path(fld, placer_span, p);\n+                let path = fld.cx.expr_path(path);\n+                fld.cx.expr_call(span, path, args)\n+            };\n+\n+            let stmt_let = |fld: &mut MacroExpander, bind, expr| {\n+                fld.cx.stmt_let(placer_span, false, bind, expr)\n+            };\n+            let stmt_let_mut = |fld: &mut MacroExpander, bind, expr| {\n+                fld.cx.stmt_let(placer_span, true, bind, expr)\n+            };\n+\n+            // let placer = <placer_expr> ;\n+            let s1 = stmt_let(fld, placer_ident, placer_expr);\n+\n+            // let mut place = Placer::make_place(placer);\n+            let s2 = {\n+                let call = make_call(fld, &make_place, vec![placer]);\n+                stmt_let_mut(fld, agent_ident, call)\n+            };\n+\n+            // let p_ptr = Place::pointer(&mut place);\n+            let s3 = {\n+                let args = vec![fld.cx.expr_mut_addr_of(placer_span, agent.clone())];\n+                let call = make_call(fld, &place_pointer, args);\n+                stmt_let(fld, p_ptr_ident, call)\n+            };\n+\n+            // let value = <value_expr>;\n+            let s4 = fld.cx.stmt_let(value_span, false, value_ident, value_expr);\n+\n+            // unsafe { ptr::write(p_ptr, value); InPlace::finalize(place) }\n+            let expr = {\n+                let call_ptr_write = StmtSemi(make_call(\n+                    fld, &ptr_write, vec![p_ptr, value]), ast::DUMMY_NODE_ID);\n+                let call_ptr_write = codemap::respan(value_span, call_ptr_write);\n+\n+                let call = make_call(fld, &inplace_finalize, vec![agent]);\n+                Some(fld.cx.expr_block(P(ast::Block {\n+                    stmts: vec![P(call_ptr_write)],\n+                    expr: Some(call),\n+                    id: ast::DUMMY_NODE_ID,\n+                    rules: ast::UnsafeBlock(ast::CompilerGenerated),\n+                    span: span,\n+                })))\n+            };\n+\n+            let block = fld.cx.block_all(span, vec![s1, s2, s3, s4], expr);\n+            fld.cx.expr_block(block)\n+        }\n+\n+        // Issue #22181:\n+        // Eventually a desugaring for `box EXPR`\n+        // (similar to the desugaring above for `in PLACE BLOCK`)\n+        // should go here, desugaring\n+        //\n+        // to:\n+        //\n+        // let mut place = BoxPlace::make_place();\n+        // let raw_place = Place::pointer(&mut place);\n+        // let value = $value;\n+        // unsafe {\n+        //     ::std::ptr::write(raw_place, value);\n+        //     Boxed::finalize(place)\n+        // }\n+        //\n+        // But for now there are type-inference issues doing that.\n+\n         ast::ExprWhile(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);"}]}