{"sha": "4ca51cfbcfe75b27c21bc269780992f55b4c6d84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYTUxY2ZiY2ZlNzViMjdjMjFiYzI2OTc4MDk5MmY1NWI0YzZkODQ=", "commit": {"author": {"name": "gfreezy", "email": "gfreezy@gmail.com", "date": "2019-03-25T17:02:06Z"}, "committer": {"name": "gfreezy", "email": "gfreezy@gmail.com", "date": "2019-04-01T14:53:47Z"}, "message": "intelligently add parens when inlining local varaibles", "tree": {"sha": "371c29b6c8537ba5e0c1062859e6da8c7dd777cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/371c29b6c8537ba5e0c1062859e6da8c7dd777cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ca51cfbcfe75b27c21bc269780992f55b4c6d84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ca51cfbcfe75b27c21bc269780992f55b4c6d84", "html_url": "https://github.com/rust-lang/rust/commit/4ca51cfbcfe75b27c21bc269780992f55b4c6d84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ca51cfbcfe75b27c21bc269780992f55b4c6d84/comments", "author": {"login": "gfreezy", "id": 510012, "node_id": "MDQ6VXNlcjUxMDAxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/510012?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gfreezy", "html_url": "https://github.com/gfreezy", "followers_url": "https://api.github.com/users/gfreezy/followers", "following_url": "https://api.github.com/users/gfreezy/following{/other_user}", "gists_url": "https://api.github.com/users/gfreezy/gists{/gist_id}", "starred_url": "https://api.github.com/users/gfreezy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gfreezy/subscriptions", "organizations_url": "https://api.github.com/users/gfreezy/orgs", "repos_url": "https://api.github.com/users/gfreezy/repos", "events_url": "https://api.github.com/users/gfreezy/events{/privacy}", "received_events_url": "https://api.github.com/users/gfreezy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gfreezy", "id": 510012, "node_id": "MDQ6VXNlcjUxMDAxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/510012?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gfreezy", "html_url": "https://github.com/gfreezy", "followers_url": "https://api.github.com/users/gfreezy/followers", "following_url": "https://api.github.com/users/gfreezy/following{/other_user}", "gists_url": "https://api.github.com/users/gfreezy/gists{/gist_id}", "starred_url": "https://api.github.com/users/gfreezy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gfreezy/subscriptions", "organizations_url": "https://api.github.com/users/gfreezy/orgs", "repos_url": "https://api.github.com/users/gfreezy/repos", "events_url": "https://api.github.com/users/gfreezy/events{/privacy}", "received_events_url": "https://api.github.com/users/gfreezy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56f3524c693eed6a849f27139b6c8f32986ca4b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/56f3524c693eed6a849f27139b6c8f32986ca4b8", "html_url": "https://github.com/rust-lang/rust/commit/56f3524c693eed6a849f27139b6c8f32986ca4b8"}], "stats": {"total": 447, "additions": 402, "deletions": 45}, "files": [{"sha": "e80e3573868ff58719c8e02a1f3670947b40c197", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ca51cfbcfe75b27c21bc269780992f55b4c6d84/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca51cfbcfe75b27c21bc269780992f55b4c6d84/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=4ca51cfbcfe75b27c21bc269780992f55b4c6d84", "patch": "@@ -114,6 +114,10 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n     pub(crate) fn covering_element(&self) -> SyntaxElement<'a> {\n         find_covering_element(self.source_file.syntax(), self.frange.range)\n     }\n+\n+    pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement<'a> {\n+        find_covering_element(self.source_file.syntax(), range)\n+    }\n }\n \n #[derive(Default)]"}, {"sha": "0d7b884b8bb6b582263911c3ae03d59f706ebf17", "filename": "crates/ra_assists/src/inline_local_variable.rs", "status": "modified", "additions": 387, "deletions": 44, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/4ca51cfbcfe75b27c21bc269780992f55b4c6d84/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca51cfbcfe75b27c21bc269780992f55b4c6d84/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs?ref=4ca51cfbcfe75b27c21bc269780992f55b4c6d84", "patch": "@@ -1,7 +1,16 @@\n-use hir::db::HirDatabase;\n-use hir::source_binder::function_from_child_node;\n-use ra_syntax::{ast::{self, AstNode}, TextRange};\n-use ra_syntax::ast::{PatKind, ExprKind};\n+use hir::{\n+    db::HirDatabase,\n+    source_binder::function_from_child_node\n+};\n+use ra_syntax::{\n+    ast::{\n+        self,\n+        AstNode,\n+        PatKind,\n+        ExprKind\n+    },\n+    TextRange,\n+};\n \n use crate::{Assist, AssistCtx, AssistId};\n use crate::assist_ctx::AssistBuilder;\n@@ -15,37 +24,7 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n     if bind_pat.is_mutable() {\n         return None;\n     }\n-    let initializer = let_stmt.initializer()?;\n-    let wrap_in_parens = match initializer.kind() {\n-        ExprKind::LambdaExpr(_)\n-        | ExprKind::IfExpr(_)\n-        | ExprKind::LoopExpr(_)\n-        | ExprKind::ForExpr(_)\n-        | ExprKind::WhileExpr(_)\n-        | ExprKind::ContinueExpr(_)\n-        | ExprKind::BreakExpr(_)\n-        | ExprKind::Label(_)\n-        | ExprKind::ReturnExpr(_)\n-        | ExprKind::MatchExpr(_)\n-        | ExprKind::StructLit(_)\n-        | ExprKind::CastExpr(_)\n-        | ExprKind::PrefixExpr(_)\n-        | ExprKind::RangeExpr(_)\n-        | ExprKind::BinExpr(_) => true,\n-        ExprKind::CallExpr(_)\n-        | ExprKind::IndexExpr(_)\n-        | ExprKind::MethodCallExpr(_)\n-        | ExprKind::FieldExpr(_)\n-        | ExprKind::TryExpr(_)\n-        | ExprKind::RefExpr(_)\n-        | ExprKind::Literal(_)\n-        | ExprKind::TupleExpr(_)\n-        | ExprKind::ArrayExpr(_)\n-        | ExprKind::ParenExpr(_)\n-        | ExprKind::PathExpr(_)\n-        | ExprKind::BlockExpr(_) => false,\n-    };\n-\n+    let initializer_expr = let_stmt.initializer();\n     let delete_range = if let Some(whitespace) = let_stmt\n         .syntax()\n         .next_sibling_or_token()\n@@ -56,22 +35,66 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n         let_stmt.syntax().range()\n     };\n \n-    let init_str = if wrap_in_parens {\n-        format!(\"({})\", initializer.syntax().text().to_string())\n-    } else {\n-        initializer.syntax().text().to_string()\n-    };\n     let function = function_from_child_node(ctx.db, ctx.frange.file_id, bind_pat.syntax())?;\n     let scope = function.scopes(ctx.db);\n     let refs = scope.find_all_refs(bind_pat);\n \n+    let mut wrap_in_parens = vec![true; refs.len()];\n+\n+    for (i, desc) in refs.iter().enumerate() {\n+        let usage_node = ctx\n+            .covering_node_for_range(desc.range)\n+            .ancestors()\n+            .find_map(|node| ast::PathExpr::cast(node))?;\n+        let usage_parent_option = usage_node.syntax().parent().and_then(ast::Expr::cast);\n+        let usage_parent = match usage_parent_option {\n+            Some(u) => u,\n+            None => {\n+                wrap_in_parens[i] = false;\n+                continue;\n+            }\n+        };\n+\n+        wrap_in_parens[i] = match (initializer_expr?.kind(), usage_parent.kind()) {\n+            (ExprKind::CallExpr(_), _)\n+            | (ExprKind::IndexExpr(_), _)\n+            | (ExprKind::MethodCallExpr(_), _)\n+            | (ExprKind::FieldExpr(_), _)\n+            | (ExprKind::TryExpr(_), _)\n+            | (ExprKind::RefExpr(_), _)\n+            | (ExprKind::Literal(_), _)\n+            | (ExprKind::TupleExpr(_), _)\n+            | (ExprKind::ArrayExpr(_), _)\n+            | (ExprKind::ParenExpr(_), _)\n+            | (ExprKind::PathExpr(_), _)\n+            | (ExprKind::BlockExpr(_), _)\n+            | (_, ExprKind::CallExpr(_))\n+            | (_, ExprKind::TupleExpr(_))\n+            | (_, ExprKind::ArrayExpr(_))\n+            | (_, ExprKind::ParenExpr(_))\n+            | (_, ExprKind::ForExpr(_))\n+            | (_, ExprKind::WhileExpr(_))\n+            | (_, ExprKind::BreakExpr(_))\n+            | (_, ExprKind::ReturnExpr(_))\n+            | (_, ExprKind::MatchExpr(_)) => false,\n+            _ => true,\n+        };\n+    }\n+\n+    let init_str = initializer_expr?.syntax().text().to_string();\n+    let init_in_paren = format!(\"({})\", &init_str);\n+\n     ctx.add_action(\n         AssistId(\"inline_local_variable\"),\n         \"inline local variable\",\n         move |edit: &mut AssistBuilder| {\n             edit.delete(delete_range);\n-            for desc in refs {\n-                edit.replace(desc.range, init_str.clone())\n+            for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n+                if should_wrap {\n+                    edit.replace(desc.range, init_in_paren.clone())\n+                } else {\n+                    edit.replace(desc.range, init_str.clone())\n+                }\n             }\n             edit.set_cursor(delete_range.start())\n         },\n@@ -149,7 +172,7 @@ fn foo() {\n \n     }\n     let b = (1 + 1) * 10;\n-    bar((1 + 1));\n+    bar(1 + 1);\n }\",\n         );\n     }\n@@ -217,7 +240,7 @@ fn foo() {\n \n     }\n     let b = (bar(1) as u64) * 10;\n-    bar((bar(1) as u64));\n+    bar(bar(1) as u64);\n }\",\n         );\n     }\n@@ -294,6 +317,326 @@ fn foo() {\n fn foo() {\n     let mut a<|> = 1 + 1;\n     a + 1;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_call_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = bar(10 + 1);\n+    let b = a * 10;\n+    let c = a as usize;\n+}\",\n+            \"\n+fn foo() {\n+    <|>let b = bar(10 + 1) * 10;\n+    let c = bar(10 + 1) as usize;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_index_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let x = vec![1, 2, 3];\n+    let a<|> = x[0];\n+    let b = a * 10;\n+    let c = a as usize;\n+}\",\n+            \"\n+fn foo() {\n+    let x = vec![1, 2, 3];\n+    <|>let b = x[0] * 10;\n+    let c = x[0] as usize;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_method_call_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let bar = vec![1];\n+    let a<|> = bar.len();\n+    let b = a * 10;\n+    let c = a as usize;\n+}\",\n+            \"\n+fn foo() {\n+    let bar = vec![1];\n+    <|>let b = bar.len() * 10;\n+    let c = bar.len() as usize;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_field_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+struct Bar {\n+    foo: usize\n+}\n+\n+fn foo() {\n+    let bar = Bar { foo: 1 };\n+    let a<|> = bar.foo;\n+    let b = a * 10;\n+    let c = a as usize;\n+}\",\n+            \"\n+struct Bar {\n+    foo: usize\n+}\n+\n+fn foo() {\n+    let bar = Bar { foo: 1 };\n+    <|>let b = bar.foo * 10;\n+    let c = bar.foo as usize;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_try_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() -> Option<usize> {\n+    let bar = Some(1);\n+    let a<|> = bar?;\n+    let b = a * 10;\n+    let c = a as usize;\n+    None\n+}\",\n+            \"\n+fn foo() -> Option<usize> {\n+    let bar = Some(1);\n+    <|>let b = bar? * 10;\n+    let c = bar? as usize;\n+    None\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_ref_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let bar = 10;\n+    let a<|> = &bar;\n+    let b = a * 10;\n+}\",\n+            \"\n+fn foo() {\n+    let bar = 10;\n+    <|>let b = &bar * 10;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_tuple_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = (10, 20);\n+    let b = a[0];\n+}\",\n+            \"\n+fn foo() {\n+    <|>let b = (10, 20)[0];\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_array_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = [1, 2, 3];\n+    let b = a.len();\n+}\",\n+            \"\n+fn foo() {\n+    <|>let b = [1, 2, 3].len();\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_paren() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = (10 + 20);\n+    let b = a * 10;\n+    let c = a as usize;\n+}\",\n+            \"\n+fn foo() {\n+    <|>let b = (10 + 20) * 10;\n+    let c = (10 + 20) as usize;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_path_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let d = 10;\n+    let a<|> = d;\n+    let b = a * 10;\n+    let c = a as usize;\n+}\",\n+            \"\n+fn foo() {\n+    let d = 10;\n+    <|>let b = d * 10;\n+    let c = d as usize;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_block_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = { 10 };\n+    let b = a * 10;\n+    let c = a as usize;\n+}\",\n+            \"\n+fn foo() {\n+    <|>let b = { 10 } * 10;\n+    let c = { 10 } as usize;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_used_in_different_expr1() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = 10 + 20;\n+    let b = a * 10;\n+    let c = (a, 20);\n+    let d = [a, 10];\n+    let e = (a);\n+}\",\n+            \"\n+fn foo() {\n+    <|>let b = (10 + 20) * 10;\n+    let c = (10 + 20, 20);\n+    let d = [10 + 20, 10];\n+    let e = (10 + 20);\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_used_in_for_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = vec![10, 20];\n+    for i in a {}\n+}\",\n+            \"\n+fn foo() {\n+    <|>for i in vec![10, 20] {}\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_used_in_while_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = 1 > 0;\n+    while a {}\n+}\",\n+            \"\n+fn foo() {\n+    <|>while 1 > 0 {}\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_used_in_break_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = 1 + 1;\n+    loop {\n+        break a;\n+    }\n+}\",\n+            \"\n+fn foo() {\n+    <|>loop {\n+        break 1 + 1;\n+    }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_used_in_return_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = 1 > 0;\n+    return a;\n+}\",\n+            \"\n+fn foo() {\n+    <|>return 1 > 0;\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_used_in_match_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = 1 > 0;\n+    match a {}\n+}\",\n+            \"\n+fn foo() {\n+    <|>match 1 > 0 {}\n }\",\n         );\n     }"}, {"sha": "946c9faf2aa018f0258caaf5de23ee9edeb9a0a1", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ca51cfbcfe75b27c21bc269780992f55b4c6d84/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca51cfbcfe75b27c21bc269780992f55b4c6d84/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=4ca51cfbcfe75b27c21bc269780992f55b4c6d84", "patch": "@@ -760,6 +760,7 @@ impl ExprCollector {\n             ast::ExprKind::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::MacroCall(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n         }\n     }\n "}, {"sha": "435d90116efdf885f82f4ec0451294271a286e55", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ca51cfbcfe75b27c21bc269780992f55b4c6d84/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca51cfbcfe75b27c21bc269780992f55b4c6d84/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=4ca51cfbcfe75b27c21bc269780992f55b4c6d84", "patch": "@@ -715,6 +715,7 @@ pub enum ExprKind<'a> {\n     RangeExpr(&'a RangeExpr),\n     BinExpr(&'a BinExpr),\n     Literal(&'a Literal),\n+    MacroCall(&'a MacroCall),\n }\n impl<'a> From<&'a TupleExpr> for &'a Expr {\n     fn from(n: &'a TupleExpr) -> &'a Expr {\n@@ -851,6 +852,11 @@ impl<'a> From<&'a Literal> for &'a Expr {\n         Expr::cast(&n.syntax).unwrap()\n     }\n }\n+impl<'a> From<&'a MacroCall> for &'a Expr {\n+    fn from(n: &'a MacroCall) -> &'a Expr {\n+        Expr::cast(&n.syntax).unwrap()\n+    }\n+}\n \n \n impl AstNode for Expr {\n@@ -882,7 +888,8 @@ impl AstNode for Expr {\n             | PREFIX_EXPR\n             | RANGE_EXPR\n             | BIN_EXPR\n-            | LITERAL => Some(Expr::from_repr(syntax.into_repr())),\n+            | LITERAL\n+            | MACRO_CALL => Some(Expr::from_repr(syntax.into_repr())),\n             _ => None,\n         }\n     }\n@@ -924,6 +931,7 @@ impl Expr {\n             RANGE_EXPR => ExprKind::RangeExpr(RangeExpr::cast(&self.syntax).unwrap()),\n             BIN_EXPR => ExprKind::BinExpr(BinExpr::cast(&self.syntax).unwrap()),\n             LITERAL => ExprKind::Literal(Literal::cast(&self.syntax).unwrap()),\n+            MACRO_CALL => ExprKind::MacroCall(MacroCall::cast(&self.syntax).unwrap()),\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "3d97bea7f56bb7ca974efaae266f566c40871f4b", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ca51cfbcfe75b27c21bc269780992f55b4c6d84/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/4ca51cfbcfe75b27c21bc269780992f55b4c6d84/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=4ca51cfbcfe75b27c21bc269780992f55b4c6d84", "patch": "@@ -494,6 +494,7 @@ Grammar(\n                 \"RangeExpr\",\n                 \"BinExpr\",\n                 \"Literal\",\n+                \"MacroCall\",\n             ],\n         ),\n "}]}