{"sha": "c20356e96b706f8bc480d905abf218163dc9ff30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMDM1NmU5NmI3MDZmOGJjNDgwZDkwNWFiZjIxODE2M2RjOWZmMzA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-12T08:43:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-12T08:43:17Z"}, "message": "Rollup merge of #76484 - fusion-engineering-forks:maybe-uninit-drop, r=RalfJung\n\nAdd MaybeUninit::assume_init_drop.\n\n`ManuallyDrop`'s documentation tells the user to use `MaybeUninit` instead when handling uninitialized data. However, the main functionality of `ManuallyDrop` (`drop`) is not available directly on `MaybeUninit`. Adding it makes it easier to switch from one to the other.\n\nI re-used the `maybe_uninit_extra` feature and tracking issue number (#63567), since it seems very related. (And to avoid creating too many features tracking issues for `MaybeUninit`.)", "tree": {"sha": "a094ed1eb70fe1b1db19cc72b8fe3c010a91add0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a094ed1eb70fe1b1db19cc72b8fe3c010a91add0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c20356e96b706f8bc480d905abf218163dc9ff30", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfXIolCRBK7hj4Ov3rIwAAdHIIAGx9hg+fjdEEMgBI1Xwo4dBC\n4WwbqPWgx9X+QBOJ0qZ/gLn4kiFkCg2eTGaaCL3fGZV/C6hIZEe9lDDIQbCx0iOC\nTrju7uYC1xRtUAehrtqT9SvOLKvJhzGtWCLq7M4s78sKYTbuUcKTPSmuBWIwovHp\neueEoTS9F9ktxhueEDDlWRmZeVlhA/19SkYhhLUH1cHM0s1i13XXtdcQH2kePCvv\nT+m6BA46S81la9Ts0gQApmgtpFwDNZ4UZOp3t0iPcdH3JSc8+AFzzY2PeqxiR3w3\n73FU8KexuKWuGdqlxcaXhqXSTvlQZQ4It375znFoiJJDV+LYuxM/KBlSb6fWhok=\n=cVV7\n-----END PGP SIGNATURE-----\n", "payload": "tree a094ed1eb70fe1b1db19cc72b8fe3c010a91add0\nparent 5d90d6ee903d547cbb708b059c3b18b81fb7827c\nparent 43c7a9b72b284bee6ce8517550cb6ee7903c639e\nauthor Ralf Jung <post@ralfj.de> 1599900197 +0200\ncommitter GitHub <noreply@github.com> 1599900197 +0200\n\nRollup merge of #76484 - fusion-engineering-forks:maybe-uninit-drop, r=RalfJung\n\nAdd MaybeUninit::assume_init_drop.\n\n`ManuallyDrop`'s documentation tells the user to use `MaybeUninit` instead when handling uninitialized data. However, the main functionality of `ManuallyDrop` (`drop`) is not available directly on `MaybeUninit`. Adding it makes it easier to switch from one to the other.\n\nI re-used the `maybe_uninit_extra` feature and tracking issue number (#63567), since it seems very related. (And to avoid creating too many features tracking issues for `MaybeUninit`.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c20356e96b706f8bc480d905abf218163dc9ff30", "html_url": "https://github.com/rust-lang/rust/commit/c20356e96b706f8bc480d905abf218163dc9ff30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c20356e96b706f8bc480d905abf218163dc9ff30/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d90d6ee903d547cbb708b059c3b18b81fb7827c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d90d6ee903d547cbb708b059c3b18b81fb7827c", "html_url": "https://github.com/rust-lang/rust/commit/5d90d6ee903d547cbb708b059c3b18b81fb7827c"}, {"sha": "43c7a9b72b284bee6ce8517550cb6ee7903c639e", "url": "https://api.github.com/repos/rust-lang/rust/commits/43c7a9b72b284bee6ce8517550cb6ee7903c639e", "html_url": "https://github.com/rust-lang/rust/commit/43c7a9b72b284bee6ce8517550cb6ee7903c639e"}], "stats": {"total": 53, "additions": 42, "deletions": 11}, "files": [{"sha": "cafb002c01a1106433f5e5647adafb3936f524fd", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c20356e96b706f8bc480d905abf218163dc9ff30/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20356e96b706f8bc480d905abf218163dc9ff30/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=c20356e96b706f8bc480d905abf218163dc9ff30", "patch": "@@ -103,7 +103,7 @@ impl<T, const N: usize> Iterator for IntoIter<T, N> {\n             // dead now (i.e. do not touch). As `idx` was the start of the\n             // alive-zone, the alive zone is now `data[alive]` again, restoring\n             // all invariants.\n-            unsafe { self.data.get_unchecked(idx).read() }\n+            unsafe { self.data.get_unchecked(idx).assume_init_read() }\n         })\n     }\n \n@@ -136,7 +136,7 @@ impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N> {\n             // dead now (i.e. do not touch). As `idx` was the end of the\n             // alive-zone, the alive zone is now `data[alive]` again, restoring\n             // all invariants.\n-            unsafe { self.data.get_unchecked(idx).read() }\n+            unsafe { self.data.get_unchecked(idx).assume_init_read() }\n         })\n     }\n }"}, {"sha": "b0ebaa6a12b51186c8dbf433813b8e44225e1329", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c20356e96b706f8bc480d905abf218163dc9ff30/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20356e96b706f8bc480d905abf218163dc9ff30/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=c20356e96b706f8bc480d905abf218163dc9ff30", "patch": "@@ -2,6 +2,7 @@ use crate::any::type_name;\n use crate::fmt;\n use crate::intrinsics;\n use crate::mem::ManuallyDrop;\n+use crate::ptr;\n \n /// A wrapper type to construct uninitialized instances of `T`.\n ///\n@@ -471,6 +472,8 @@ impl<T> MaybeUninit<T> {\n     /// *immediate* undefined behavior, but will cause undefined behavior with most\n     /// safe operations (including dropping it).\n     ///\n+    /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+    ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:\n@@ -519,8 +522,8 @@ impl<T> MaybeUninit<T> {\n     /// this initialization invariant.\n     ///\n     /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n-    /// multiple copies of the data (by calling `read` multiple times, or first\n-    /// calling `read` and then [`assume_init`]), it is your responsibility\n+    /// multiple copies of the data (by calling `assume_init_read` multiple times, or first\n+    /// calling `assume_init_read` and then [`assume_init`]), it is your responsibility\n     /// to ensure that that data may indeed be duplicated.\n     ///\n     /// [inv]: #initialization-invariant\n@@ -536,16 +539,16 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let mut x = MaybeUninit::<u32>::uninit();\n     /// x.write(13);\n-    /// let x1 = unsafe { x.read() };\n+    /// let x1 = unsafe { x.assume_init_read() };\n     /// // `u32` is `Copy`, so we may read multiple times.\n-    /// let x2 = unsafe { x.read() };\n+    /// let x2 = unsafe { x.assume_init_read() };\n     /// assert_eq!(x1, x2);\n     ///\n     /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n     /// x.write(None);\n-    /// let x1 = unsafe { x.read() };\n+    /// let x1 = unsafe { x.assume_init_read() };\n     /// // Duplicating a `None` value is okay, so we may read multiple times.\n-    /// let x2 = unsafe { x.read() };\n+    /// let x2 = unsafe { x.assume_init_read() };\n     /// assert_eq!(x1, x2);\n     /// ```\n     ///\n@@ -557,14 +560,14 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n     /// x.write(Some(vec![0,1,2]));\n-    /// let x1 = unsafe { x.read() };\n-    /// let x2 = unsafe { x.read() };\n+    /// let x1 = unsafe { x.assume_init_read() };\n+    /// let x2 = unsafe { x.assume_init_read() };\n     /// // We now created two copies of the same vector, leading to a double-free \u26a0\ufe0f when\n     /// // they both get dropped!\n     /// ```\n     #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n-    pub unsafe fn read(&self) -> T {\n+    pub unsafe fn assume_init_read(&self) -> T {\n         // SAFETY: the caller must guarantee that `self` is initialized.\n         // Reading from `self.as_ptr()` is safe since `self` should be initialized.\n         unsafe {\n@@ -573,6 +576,34 @@ impl<T> MaybeUninit<T> {\n         }\n     }\n \n+    /// Drops the contained value in place.\n+    ///\n+    /// If you have ownership of the `MaybeUninit`, you can use [`assume_init`] instead.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is\n+    /// in an initialized state. Calling this when the content is not yet fully\n+    /// initialized causes undefined behavior.\n+    ///\n+    /// On top of that, all additional invariants of the type `T` must be\n+    /// satisfied, as the `Drop` implementation of `T` (or its members) may\n+    /// rely on this. For example, a `1`-initialized [`Vec<T>`] is considered\n+    /// initialized (under the current implementation; this does not constitute\n+    /// a stable guarantee) because the only requirement the compiler knows\n+    /// about it is that the data pointer must be non-null. Dropping such a\n+    /// `Vec<T>` however will cause undefined behaviour.\n+    ///\n+    /// [`assume_init`]: MaybeUninit::assume_init\n+    /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n+    pub unsafe fn assume_init_drop(&mut self) {\n+        // SAFETY: the caller must guarantee that `self` is initialized and\n+        // satisfies all invariants of `T`.\n+        // Dropping the value in place is safe if that is the case.\n+        unsafe { ptr::drop_in_place(self.as_mut_ptr()) }\n+    }\n+\n     /// Gets a shared reference to the contained value.\n     ///\n     /// This can be useful when we want to access a `MaybeUninit` that has been"}]}