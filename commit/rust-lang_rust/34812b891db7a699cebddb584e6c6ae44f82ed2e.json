{"sha": "34812b891db7a699cebddb584e6c6ae44f82ed2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ODEyYjg5MWRiN2E2OTljZWJkZGI1ODRlNmM2YWU0NGY4MmVkMmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-02T19:04:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-08T20:51:38Z"}, "message": "Stop masking overflow and propagate it out more aggressively; also improve error reporting to suggest to user how to fix.", "tree": {"sha": "50b63db5056827d614e0bc5ca485f812bd886fe3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50b63db5056827d614e0bc5ca485f812bd886fe3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34812b891db7a699cebddb584e6c6ae44f82ed2e", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34812b891db7a699cebddb584e6c6ae44f82ed2e", "html_url": "https://github.com/rust-lang/rust/commit/34812b891db7a699cebddb584e6c6ae44f82ed2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34812b891db7a699cebddb584e6c6ae44f82ed2e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ee85d828ebb2502d186ff63f0215340bf79d5ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee85d828ebb2502d186ff63f0215340bf79d5ad", "html_url": "https://github.com/rust-lang/rust/commit/3ee85d828ebb2502d186ff63f0215340bf79d5ad"}], "stats": {"total": 54, "additions": 37, "deletions": 17}, "files": [{"sha": "0e106227f9eb2335e479e79e17fc09e48a2a5465", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/34812b891db7a699cebddb584e6c6ae44f82ed2e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34812b891db7a699cebddb584e6c6ae44f82ed2e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=34812b891db7a699cebddb584e6c6ae44f82ed2e", "patch": "@@ -155,10 +155,10 @@ enum BuiltinBoundConditions<'tcx> {\n }\n \n #[deriving(Show)]\n-enum EvaluationResult {\n+enum EvaluationResult<'tcx> {\n     EvaluatedToOk,\n-    EvaluatedToErr,\n     EvaluatedToAmbig,\n+    EvaluatedToErr(SelectionError<'tcx>),\n }\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n@@ -272,7 +272,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               bound: ty::BuiltinBound,\n                                               previous_stack: &ObligationStack<'o, 'tcx>,\n                                               ty: Ty<'tcx>)\n-                                              -> EvaluationResult\n+                                              -> EvaluationResult<'tcx>\n     {\n         let obligation =\n             util::obligation_for_builtin_bound(\n@@ -295,7 +295,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn evaluate_obligation_recursively<'o>(&mut self,\n                                            previous_stack: Option<&ObligationStack<'o, 'tcx>>,\n                                            obligation: &Obligation<'tcx>)\n-                                           -> EvaluationResult\n+                                           -> EvaluationResult<'tcx>\n     {\n         debug!(\"evaluate_obligation_recursively({})\",\n                obligation.repr(self.tcx()));\n@@ -310,7 +310,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn evaluate_stack<'o>(&mut self,\n                           stack: &ObligationStack<'o, 'tcx>)\n-                          -> EvaluationResult\n+                          -> EvaluationResult<'tcx>\n     {\n         // In intercrate mode, whenever any of the types are unbound,\n         // there can always be an impl. Even if there are no impls in\n@@ -381,7 +381,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.candidate_from_obligation(stack) {\n             Ok(Some(c)) => self.winnow_candidate(stack, &c),\n             Ok(None) => EvaluatedToAmbig,\n-            Err(_) => EvaluatedToErr,\n+            Err(e) => EvaluatedToErr(e),\n         }\n     }\n \n@@ -812,27 +812,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn winnow_candidate<'o>(&mut self,\n                             stack: &ObligationStack<'o, 'tcx>,\n                             candidate: &Candidate<'tcx>)\n-                            -> EvaluationResult\n+                            -> EvaluationResult<'tcx>\n     {\n         debug!(\"winnow_candidate: candidate={}\", candidate.repr(self.tcx()));\n         self.infcx.probe(|| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => self.winnow_selection(Some(stack), selection),\n-                Err(_) => EvaluatedToErr,\n+                Err(error) => EvaluatedToErr(error),\n             }\n         })\n     }\n \n     fn winnow_selection<'o>(&mut self,\n                             stack: Option<&ObligationStack<'o, 'tcx>>,\n                             selection: Selection<'tcx>)\n-                            -> EvaluationResult\n+                            -> EvaluationResult<'tcx>\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in selection.iter_nested() {\n             match self.evaluate_obligation_recursively(stack, obligation) {\n-                EvaluatedToErr => { return EvaluatedToErr; }\n+                EvaluatedToErr(e) => { return EvaluatedToErr(e); }\n                 EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n                 EvaluatedToOk => { }\n             }\n@@ -1847,11 +1847,18 @@ impl<'o, 'tcx> Repr<'tcx> for ObligationStack<'o, 'tcx> {\n     }\n }\n \n-impl EvaluationResult {\n+impl<'tcx> EvaluationResult<'tcx> {\n     fn may_apply(&self) -> bool {\n         match *self {\n-            EvaluatedToOk | EvaluatedToAmbig => true,\n-            EvaluatedToErr => false,\n+            EvaluatedToOk |\n+            EvaluatedToAmbig |\n+            EvaluatedToErr(Overflow) |\n+            EvaluatedToErr(OutputTypeParameterMismatch(..)) => {\n+                true\n+            }\n+            EvaluatedToErr(Unimplemented) => {\n+                false\n+            }\n         }\n     }\n }"}, {"sha": "80363055a4bf0ea6206dc7bde15a49063dbc9bdb", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34812b891db7a699cebddb584e6c6ae44f82ed2e/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34812b891db7a699cebddb584e6c6ae44f82ed2e/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=34812b891db7a699cebddb584e6c6ae44f82ed2e", "patch": "@@ -366,6 +366,15 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     \"overflow evaluating the trait `{}` for the type `{}`\",\n                     trait_ref.user_string(fcx.tcx()),\n                     self_ty.user_string(fcx.tcx())).as_slice());\n+\n+            let current_limit = fcx.tcx().sess.recursion_limit.get();\n+            let suggested_limit = current_limit * 2;\n+            fcx.tcx().sess.span_note(\n+                obligation.cause.span,\n+                format!(\n+                    \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                    suggested_limit)[]);\n+\n             note_obligation_cause(fcx, obligation);\n         }\n         Unimplemented => {"}, {"sha": "17afb168a9839a284ba75e4c3e908f5733bcf9e7", "filename": "src/test/compile-fail/recursion_limit.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34812b891db7a699cebddb584e6c6ae44f82ed2e/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34812b891db7a699cebddb584e6c6ae44f82ed2e/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs?ref=34812b891db7a699cebddb584e6c6ae44f82ed2e", "patch": "@@ -42,6 +42,10 @@ fn is_send<T:Send>() { }\n \n fn main() {\n     is_send::<A>();\n-    //~^ ERROR not implemented\n-    //~^^ ERROR not implemented\n+    //~^ ERROR overflow evaluating\n+    //~^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n+    //~^^^ NOTE must be implemented\n+    //~^^^^ ERROR overflow evaluating\n+    //~^^^^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n+    //~^^^^^^ NOTE must be implemented\n }"}, {"sha": "b3528f7abe71927f0c8284dae48340f0d1347bb6", "filename": "src/test/compile-fail/unboxed-closures-type-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34812b891db7a699cebddb584e6c6ae44f82ed2e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34812b891db7a699cebddb584e6c6ae44f82ed2e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs?ref=34812b891db7a699cebddb584e6c6ae44f82ed2e", "patch": "@@ -14,6 +14,6 @@ use std::ops::FnMut;\n \n pub fn main() {\n     let mut f = |&mut: x: int, y: int| -> int { x + y };\n-    let z = f.call_mut((1u, 2));    //~ ERROR not implemented\n+    let z = f.call_mut((1u, 2));    //~ ERROR type mismatch\n     println!(\"{}\", z);\n }"}, {"sha": "a96bde7cca4cdcb06ce12c1140709b7b9aa22e32", "filename": "src/test/compile-fail/unboxed-closures-vtable-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34812b891db7a699cebddb584e6c6ae44f82ed2e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34812b891db7a699cebddb584e6c6ae44f82ed2e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs?ref=34812b891db7a699cebddb584e6c6ae44f82ed2e", "patch": "@@ -18,7 +18,7 @@ fn call_it<F:FnMut<(int,int),int>>(y: int, mut f: F) -> int {\n \n pub fn main() {\n     let f = |&mut: x: uint, y: int| -> int { (x as int) + y };\n-    let z = call_it(3, f);  //~ ERROR not implemented\n+    let z = call_it(3, f);  //~ ERROR type mismatch\n     println!(\"{}\", z);\n }\n "}]}