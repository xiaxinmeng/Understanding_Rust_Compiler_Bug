{"sha": "09412d85fc3137d6ada3b27170e14c287f1a1191", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NDEyZDg1ZmMzMTM3ZDZhZGEzYjI3MTcwZTE0YzI4N2YxYTExOTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-21T09:37:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-21T09:37:08Z"}, "message": "Merge #8123\n\n8123: Do not display unqualified assoc item completions r=SomeoneToIgnore a=SomeoneToIgnore\n\nPart of https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/autoimport.20weirdness\r\n\r\nRemoves all flyimport completions for any unqualified associated type, effectively reverting https://github.com/rust-analyzer/rust-analyzer/pull/8095 \r\nI've explained the reasoning in the corresponding FIXME and open to discussions.\r\nAs an alternative way, we could add yet another parameter in the method that's used by the `qualify_path` and enable it for the qualify assists only.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "ac01ec54df0cebba975c82008482319820ce8757", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac01ec54df0cebba975c82008482319820ce8757"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09412d85fc3137d6ada3b27170e14c287f1a1191", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgVxPECRBK7hj4Ov3rIwAAdHIIAJRtz9z0SMxzD9WcLxKSKvWh\nPbLHWjoOkXMTLRvWmsjNKRIuZsTDFxkY873E5SXSkVUGhJp2LY/jnRQ2wIceQy/8\nVYHrW0mZ5xGh/AUAri/PUyYQ27dwqpNV5xJN/6PgQpDgXeEwKEEoYI86xddRZgF3\n9yNO8VCVXwN/kZ0vox3kDGwYvYh5papMLb66F3KQ/giz2tLmZ6V5DanGlWS2h8nJ\n3dx+bhg4npLg8+JK3om3qxz40WnfF2TyWwMqYHCf4SaQDaaoOiE8BcdJHRlfUIJV\ngBfL3ZDJGzANHMbHqIwlZCsxAqGRnc/wPUrmXGVkUR1ykrofGYkq3gD06tbbe8s=\n=cFz5\n-----END PGP SIGNATURE-----\n", "payload": "tree ac01ec54df0cebba975c82008482319820ce8757\nparent 2280f62a40f31d83fd79b62c46dd3d610354d78c\nparent 56a7d246d59d9429304b82bce2f1e71b632c5737\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1616319428 +0000\ncommitter GitHub <noreply@github.com> 1616319428 +0000\n\nMerge #8123\n\n8123: Do not display unqualified assoc item completions r=SomeoneToIgnore a=SomeoneToIgnore\n\nPart of https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/autoimport.20weirdness\r\n\r\nRemoves all flyimport completions for any unqualified associated type, effectively reverting https://github.com/rust-analyzer/rust-analyzer/pull/8095 \r\nI've explained the reasoning in the corresponding FIXME and open to discussions.\r\nAs an alternative way, we could add yet another parameter in the method that's used by the `qualify_path` and enable it for the qualify assists only.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09412d85fc3137d6ada3b27170e14c287f1a1191", "html_url": "https://github.com/rust-lang/rust/commit/09412d85fc3137d6ada3b27170e14c287f1a1191", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09412d85fc3137d6ada3b27170e14c287f1a1191/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2280f62a40f31d83fd79b62c46dd3d610354d78c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2280f62a40f31d83fd79b62c46dd3d610354d78c", "html_url": "https://github.com/rust-lang/rust/commit/2280f62a40f31d83fd79b62c46dd3d610354d78c"}, {"sha": "56a7d246d59d9429304b82bce2f1e71b632c5737", "url": "https://api.github.com/repos/rust-lang/rust/commits/56a7d246d59d9429304b82bce2f1e71b632c5737", "html_url": "https://github.com/rust-lang/rust/commit/56a7d246d59d9429304b82bce2f1e71b632c5737"}], "stats": {"total": 474, "additions": 250, "deletions": 224}, "files": [{"sha": "f91770a763750cf2559859d66d7139350be91c9f", "filename": "crates/ide_assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=09412d85fc3137d6ada3b27170e14c287f1a1191", "patch": "@@ -536,6 +536,7 @@ fn main() {\n     }\n \n     #[test]\n+    #[ignore = \"FIXME: non-trait assoc items completion is unsupported yet, see FIXME in the import_assets.rs for more details\"]\n     fn associated_struct_const_unqualified() {\n         check_assist(\n             qualify_path,"}, {"sha": "2608b56da6ff1f1b746b91e22fe59bb31ba532d5", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=09412d85fc3137d6ada3b27170e14c287f1a1191", "patch": "@@ -1,5 +1,5 @@\n use hir::ModuleDef;\n-use ide_db::helpers::mod_path_to_ast;\n+use ide_db::helpers::{import_assets::NameToImport, mod_path_to_ast};\n use ide_db::items_locator;\n use itertools::Itertools;\n use syntax::{\n@@ -65,20 +65,25 @@ pub(crate) fn replace_derive_with_manual_impl(\n     let current_module = ctx.sema.scope(annotated_name.syntax()).module()?;\n     let current_crate = current_module.krate();\n \n-    let found_traits =\n-        items_locator::with_exact_name(&ctx.sema, current_crate, trait_token.text().to_string())\n-            .into_iter()\n-            .filter_map(|item| match ModuleDef::from(item.as_module_def_id()?) {\n-                ModuleDef::Trait(trait_) => Some(trait_),\n-                _ => None,\n-            })\n-            .flat_map(|trait_| {\n-                current_module\n-                    .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_))\n-                    .as_ref()\n-                    .map(mod_path_to_ast)\n-                    .zip(Some(trait_))\n-            });\n+    let found_traits = items_locator::items_with_name(\n+        &ctx.sema,\n+        current_crate,\n+        NameToImport::Exact(trait_token.text().to_string()),\n+        items_locator::AssocItemSearch::Exclude,\n+        Some(items_locator::DEFAULT_QUERY_SEARCH_LIMIT),\n+    )\n+    .into_iter()\n+    .filter_map(|item| match ModuleDef::from(item.as_module_def_id()?) {\n+        ModuleDef::Trait(trait_) => Some(trait_),\n+        _ => None,\n+    })\n+    .flat_map(|trait_| {\n+        current_module\n+            .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_))\n+            .as_ref()\n+            .map(mod_path_to_ast)\n+            .zip(Some(trait_))\n+    });\n \n     let mut no_traits_found = true;\n     for (trait_path, trait_) in found_traits.inspect(|_| no_traits_found = false) {"}, {"sha": "eb2cba6319c6cc7d923879d0583e9e83bbc730bd", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=09412d85fc3137d6ada3b27170e14c287f1a1191", "patch": "@@ -943,6 +943,38 @@ mod foo {\n \n fn main() {\n     bar::Ass$0\n+}\"#,\n+            expect![[]],\n+        )\n+    }\n+\n+    #[test]\n+    fn unqualified_assoc_items_are_omitted() {\n+        check(\n+            r#\"\n+mod something {\n+    pub trait BaseTrait {\n+        fn test_function() -> i32;\n+    }\n+\n+    pub struct Item1;\n+    pub struct Item2;\n+\n+    impl BaseTrait for Item1 {\n+        fn test_function() -> i32 {\n+            1\n+        }\n+    }\n+\n+    impl BaseTrait for Item2 {\n+        fn test_function() -> i32 {\n+            2\n+        }\n+    }\n+}\n+\n+fn main() {\n+    test_f$0\n }\"#,\n             expect![[]],\n         )"}, {"sha": "87cddb98eeca314a3098c8607b3e5b5e108eb672", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=09412d85fc3137d6ada3b27170e14c287f1a1191", "patch": "@@ -14,7 +14,10 @@ mod completions;\n use completions::flyimport::position_for_import;\n use ide_db::{\n     base_db::FilePosition,\n-    helpers::{import_assets::LocatedImport, insert_use::ImportScope},\n+    helpers::{\n+        import_assets::{LocatedImport, NameToImport},\n+        insert_use::ImportScope,\n+    },\n     items_locator, RootDatabase,\n };\n use text_edit::TextEdit;\n@@ -151,15 +154,20 @@ pub fn resolve_completion_edits(\n     let current_module = ctx.sema.scope(position_for_import).module()?;\n     let current_crate = current_module.krate();\n \n-    let (import_path, item_to_import) =\n-        items_locator::with_exact_name(&ctx.sema, current_crate, imported_name)\n-            .into_iter()\n-            .filter_map(|candidate| {\n-                current_module\n-                    .find_use_path_prefixed(db, candidate, config.insert_use.prefix_kind)\n-                    .zip(Some(candidate))\n-            })\n-            .find(|(mod_path, _)| mod_path.to_string() == full_import_path)?;\n+    let (import_path, item_to_import) = items_locator::items_with_name(\n+        &ctx.sema,\n+        current_crate,\n+        NameToImport::Exact(imported_name),\n+        items_locator::AssocItemSearch::Include,\n+        Some(items_locator::DEFAULT_QUERY_SEARCH_LIMIT),\n+    )\n+    .into_iter()\n+    .filter_map(|candidate| {\n+        current_module\n+            .find_use_path_prefixed(db, candidate, config.insert_use.prefix_kind)\n+            .zip(Some(candidate))\n+    })\n+    .find(|(mod_path, _)| mod_path.to_string() == full_import_path)?;\n     let import =\n         LocatedImport::new(import_path.clone(), item_to_import, item_to_import, Some(import_path));\n "}, {"sha": "0da7a1a9d5ae488cf27d28775cf89c2efac06020", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 96, "deletions": 119, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=09412d85fc3137d6ada3b27170e14c287f1a1191", "patch": "@@ -61,7 +61,7 @@ pub struct FirstSegmentUnresolved {\n }\n \n /// A name that will be used during item lookups.\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum NameToImport {\n     /// Requires items with names that exactly match the given string, case-sensitive.\n     Exact(String),\n@@ -201,129 +201,103 @@ impl ImportAssets {\n         sema: &Semantics<RootDatabase>,\n         prefixed: Option<PrefixKind>,\n     ) -> Vec<LocatedImport> {\n-        let items_with_candidate_name = match self.name_to_import() {\n-            NameToImport::Exact(exact_name) => items_locator::with_exact_name(\n-                sema,\n-                self.module_with_candidate.krate(),\n-                exact_name.clone(),\n-            ),\n-            // FIXME: ideally, we should avoid using `fst` for seacrhing trait imports for assoc items:\n-            // instead, we need to look up all trait impls for a certain struct and search through them only\n-            // see https://github.com/rust-analyzer/rust-analyzer/pull/7293#issuecomment-761585032\n-            // and https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Blanket.20trait.20impls.20lookup\n-            // for the details\n-            NameToImport::Fuzzy(fuzzy_name) => {\n-                let (assoc_item_search, limit) = if self.import_candidate.is_trait_candidate() {\n-                    (AssocItemSearch::AssocItemsOnly, None)\n-                } else {\n-                    (AssocItemSearch::Include, Some(DEFAULT_QUERY_SEARCH_LIMIT))\n-                };\n-\n-                items_locator::with_similar_name(\n-                    sema,\n-                    self.module_with_candidate.krate(),\n-                    fuzzy_name.clone(),\n-                    assoc_item_search,\n-                    limit,\n-                )\n-            }\n-        };\n+        let _p = profile::span(\"import_assets::search_for\");\n \n         let scope_definitions = self.scope_definitions(sema);\n-        self.applicable_defs(sema.db, prefixed, items_with_candidate_name)\n-            .into_iter()\n-            .filter(|import| import.import_path.len() > 1)\n-            .filter(|import| !scope_definitions.contains(&ScopeDef::from(import.item_to_import)))\n-            .sorted_by_key(|import| import.import_path.clone())\n-            .collect()\n-    }\n-\n-    fn scope_definitions(&self, sema: &Semantics<RootDatabase>) -> FxHashSet<ScopeDef> {\n-        let mut scope_definitions = FxHashSet::default();\n-        sema.scope(&self.candidate_node).process_all_names(&mut |_, scope_def| {\n-            scope_definitions.insert(scope_def);\n-        });\n-        scope_definitions\n-    }\n-\n-    fn name_to_import(&self) -> &NameToImport {\n-        match &self.import_candidate {\n-            ImportCandidate::Path(candidate) => &candidate.name,\n-            ImportCandidate::TraitAssocItem(candidate)\n-            | ImportCandidate::TraitMethod(candidate) => &candidate.assoc_item_name,\n-        }\n-    }\n-\n-    fn applicable_defs(\n-        &self,\n-        db: &RootDatabase,\n-        prefixed: Option<PrefixKind>,\n-        items_with_candidate_name: FxHashSet<ItemInNs>,\n-    ) -> FxHashSet<LocatedImport> {\n-        let _p = profile::span(\"import_assets::applicable_defs\");\n         let current_crate = self.module_with_candidate.krate();\n-\n         let mod_path = |item| {\n-            get_mod_path(db, item_for_path_search(db, item)?, &self.module_with_candidate, prefixed)\n+            get_mod_path(\n+                sema.db,\n+                item_for_path_search(sema.db, item)?,\n+                &self.module_with_candidate,\n+                prefixed,\n+            )\n         };\n \n         match &self.import_candidate {\n             ImportCandidate::Path(path_candidate) => {\n-                path_applicable_imports(db, path_candidate, mod_path, items_with_candidate_name)\n+                path_applicable_imports(sema, current_crate, path_candidate, mod_path)\n+            }\n+            ImportCandidate::TraitAssocItem(trait_candidate) => {\n+                trait_applicable_items(sema, current_crate, trait_candidate, true, mod_path)\n+            }\n+            ImportCandidate::TraitMethod(trait_candidate) => {\n+                trait_applicable_items(sema, current_crate, trait_candidate, false, mod_path)\n             }\n-            ImportCandidate::TraitAssocItem(trait_candidate) => trait_applicable_items(\n-                db,\n-                current_crate,\n-                trait_candidate,\n-                true,\n-                mod_path,\n-                items_with_candidate_name,\n-            ),\n-            ImportCandidate::TraitMethod(trait_candidate) => trait_applicable_items(\n-                db,\n-                current_crate,\n-                trait_candidate,\n-                false,\n-                mod_path,\n-                items_with_candidate_name,\n-            ),\n         }\n+        .into_iter()\n+        .filter(|import| import.import_path.len() > 1)\n+        .filter(|import| !scope_definitions.contains(&ScopeDef::from(import.item_to_import)))\n+        .sorted_by_key(|import| import.import_path.clone())\n+        .collect()\n+    }\n+\n+    fn scope_definitions(&self, sema: &Semantics<RootDatabase>) -> FxHashSet<ScopeDef> {\n+        let _p = profile::span(\"import_assets::scope_definitions\");\n+        let mut scope_definitions = FxHashSet::default();\n+        sema.scope(&self.candidate_node).process_all_names(&mut |_, scope_def| {\n+            scope_definitions.insert(scope_def);\n+        });\n+        scope_definitions\n     }\n }\n \n fn path_applicable_imports(\n-    db: &RootDatabase,\n+    sema: &Semantics<RootDatabase>,\n+    current_crate: Crate,\n     path_candidate: &PathImportCandidate,\n     mod_path: impl Fn(ItemInNs) -> Option<ModPath> + Copy,\n-    items_with_candidate_name: FxHashSet<ItemInNs>,\n ) -> FxHashSet<LocatedImport> {\n     let _p = profile::span(\"import_assets::path_applicable_imports\");\n \n-    let (unresolved_first_segment, unresolved_qualifier) = match &path_candidate.qualifier {\n+    match &path_candidate.qualifier {\n         None => {\n-            return items_with_candidate_name\n-                .into_iter()\n-                .filter_map(|item| {\n-                    let mut mod_path = mod_path(item)?;\n-                    if let Some(assoc_item) = item_as_assoc(db, item) {\n-                        mod_path.push_segment(assoc_item.name(db)?);\n-                    }\n-                    Some(LocatedImport::new(mod_path.clone(), item, item, Some(mod_path)))\n-                })\n-                .collect();\n+            items_locator::items_with_name(\n+                sema,\n+                current_crate,\n+                path_candidate.name.clone(),\n+                // FIXME: we could look up assoc items by the input and propose those in completion,\n+                // but that requries more preparation first:\n+                // * store non-trait assoc items in import_map to fully enable this lookup\n+                // * ensure that does not degrade the performance (bencmark it)\n+                // * write more logic to check for corresponding trait presence requirement (we're unable to flyimport multiple item right now)\n+                // * improve the associated completion item matching and/or scoring to ensure no noisy completions appear\n+                //\n+                // see also an ignored test under FIXME comment in the qualify_path.rs module\n+                AssocItemSearch::Exclude,\n+                Some(DEFAULT_QUERY_SEARCH_LIMIT),\n+            )\n+            .into_iter()\n+            .filter_map(|item| {\n+                let mod_path = mod_path(item)?;\n+                Some(LocatedImport::new(mod_path.clone(), item, item, Some(mod_path)))\n+            })\n+            .collect()\n         }\n-        Some(first_segment_unresolved) => (\n-            first_segment_unresolved.fist_segment.to_string(),\n-            path_to_string_stripping_turbo_fish(&first_segment_unresolved.full_qualifier),\n-        ),\n-    };\n-\n-    items_with_candidate_name\n-        .into_iter()\n-        .filter_map(|item| {\n-            import_for_item(db, mod_path, &unresolved_first_segment, &unresolved_qualifier, item)\n-        })\n-        .collect()\n+        Some(first_segment_unresolved) => {\n+            let unresolved_qualifier =\n+                path_to_string_stripping_turbo_fish(&first_segment_unresolved.full_qualifier);\n+            let unresolved_first_segment = first_segment_unresolved.fist_segment.text();\n+            items_locator::items_with_name(\n+                sema,\n+                current_crate,\n+                path_candidate.name.clone(),\n+                AssocItemSearch::Include,\n+                Some(DEFAULT_QUERY_SEARCH_LIMIT),\n+            )\n+            .into_iter()\n+            .filter_map(|item| {\n+                import_for_item(\n+                    sema.db,\n+                    mod_path,\n+                    unresolved_first_segment,\n+                    &unresolved_qualifier,\n+                    item,\n+                )\n+            })\n+            .collect()\n+        }\n+    }\n }\n \n fn import_for_item(\n@@ -438,25 +412,32 @@ fn module_with_segment_name(\n }\n \n fn trait_applicable_items(\n-    db: &RootDatabase,\n+    sema: &Semantics<RootDatabase>,\n     current_crate: Crate,\n     trait_candidate: &TraitImportCandidate,\n     trait_assoc_item: bool,\n     mod_path: impl Fn(ItemInNs) -> Option<ModPath>,\n-    items_with_candidate_name: FxHashSet<ItemInNs>,\n ) -> FxHashSet<LocatedImport> {\n     let _p = profile::span(\"import_assets::trait_applicable_items\");\n-    let mut required_assoc_items = FxHashSet::default();\n \n-    let trait_candidates = items_with_candidate_name\n-        .into_iter()\n-        .filter_map(|input| item_as_assoc(db, input))\n-        .filter_map(|assoc| {\n-            let assoc_item_trait = assoc.containing_trait(db)?;\n-            required_assoc_items.insert(assoc);\n-            Some(assoc_item_trait.into())\n-        })\n-        .collect();\n+    let db = sema.db;\n+\n+    let mut required_assoc_items = FxHashSet::default();\n+    let trait_candidates = items_locator::items_with_name(\n+        sema,\n+        current_crate,\n+        trait_candidate.assoc_item_name.clone(),\n+        AssocItemSearch::AssocItemsOnly,\n+        Some(DEFAULT_QUERY_SEARCH_LIMIT),\n+    )\n+    .into_iter()\n+    .filter_map(|input| item_as_assoc(db, input))\n+    .filter_map(|assoc| {\n+        let assoc_item_trait = assoc.containing_trait(db)?;\n+        required_assoc_items.insert(assoc);\n+        Some(assoc_item_trait.into())\n+    })\n+    .collect();\n \n     let mut located_imports = FxHashSet::default();\n \n@@ -565,10 +546,6 @@ impl ImportCandidate {\n     ) -> Option<Self> {\n         path_import_candidate(sema, qualifier, NameToImport::Fuzzy(fuzzy_name))\n     }\n-\n-    fn is_trait_candidate(&self) -> bool {\n-        matches!(self, ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_))\n-    }\n }\n \n fn path_import_candidate("}, {"sha": "518cddd74073cbb0ac416f68c80e56a653326eb4", "filename": "crates/ide_db/src/items_locator.rs", "status": "modified", "additions": 83, "deletions": 80, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09412d85fc3137d6ada3b27170e14c287f1a1191/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fitems_locator.rs?ref=09412d85fc3137d6ada3b27170e14c287f1a1191", "patch": "@@ -1,6 +1,7 @@\n-//! This module contains an import search functionality that is provided to the assists module.\n-//! Later, this should be moved away to a separate crate that is accessible from the assists module.\n-\n+//! This module has the functionality to search the project and its dependencies for a certain item,\n+//! by its name and a few criteria.\n+//! The main reason for this module to exist is the fact that project's items and dependencies' items\n+//! are located in different caches, with different APIs.\n use either::Either;\n use hir::{\n     import_map::{self, ImportKind},\n@@ -10,122 +11,118 @@ use syntax::{ast, AstNode, SyntaxKind::NAME};\n \n use crate::{\n     defs::{Definition, NameClass},\n+    helpers::import_assets::NameToImport,\n     symbol_index::{self, FileSymbol},\n     RootDatabase,\n };\n use rustc_hash::FxHashSet;\n \n-pub(crate) const DEFAULT_QUERY_SEARCH_LIMIT: usize = 40;\n+/// A value to use, when uncertain which limit to pick.\n+pub const DEFAULT_QUERY_SEARCH_LIMIT: usize = 40;\n \n-pub fn with_exact_name(\n-    sema: &Semantics<'_, RootDatabase>,\n-    krate: Crate,\n-    exact_name: String,\n-) -> FxHashSet<ItemInNs> {\n-    let _p = profile::span(\"find_exact_imports\");\n-    find_items(\n-        sema,\n-        krate,\n-        {\n-            let mut local_query = symbol_index::Query::new(exact_name.clone());\n-            local_query.exact();\n-            local_query.limit(DEFAULT_QUERY_SEARCH_LIMIT);\n-            local_query\n-        },\n-        import_map::Query::new(exact_name)\n-            .limit(DEFAULT_QUERY_SEARCH_LIMIT)\n-            .name_only()\n-            .search_mode(import_map::SearchMode::Equals)\n-            .case_sensitive(),\n-    )\n-}\n-\n-#[derive(Debug)]\n+/// Three possible ways to search for the name in associated and/or other items.\n+#[derive(Debug, Clone, Copy)]\n pub enum AssocItemSearch {\n+    /// Search for the name in both associated and other items.\n     Include,\n+    /// Search for the name in other items only.\n     Exclude,\n+    /// Search for the name in the associated items only.\n     AssocItemsOnly,\n }\n \n-pub fn with_similar_name(\n+/// Searches for importable items with the given name in the crate and its dependencies.\n+pub fn items_with_name(\n     sema: &Semantics<'_, RootDatabase>,\n     krate: Crate,\n-    fuzzy_search_string: String,\n+    name: NameToImport,\n     assoc_item_search: AssocItemSearch,\n     limit: Option<usize>,\n ) -> FxHashSet<ItemInNs> {\n-    let _p = profile::span(\"find_similar_imports\");\n+    let _p = profile::span(\"items_with_name\").detail(|| {\n+        format!(\n+            \"Name: {} ({:?}), crate: {:?}, limit: {:?}\",\n+            name.text(),\n+            assoc_item_search,\n+            krate.display_name(sema.db).map(|name| name.to_string()),\n+            limit,\n+        )\n+    });\n+\n+    let (mut local_query, mut external_query) = match name {\n+        NameToImport::Exact(exact_name) => {\n+            let mut local_query = symbol_index::Query::new(exact_name.clone());\n+            local_query.exact();\n \n-    let mut external_query = import_map::Query::new(fuzzy_search_string.clone())\n-        .search_mode(import_map::SearchMode::Fuzzy)\n-        .name_only();\n+            let external_query = import_map::Query::new(exact_name)\n+                .name_only()\n+                .search_mode(import_map::SearchMode::Equals)\n+                .case_sensitive();\n \n-    match assoc_item_search {\n-        AssocItemSearch::Include => {}\n-        AssocItemSearch::Exclude => {\n-            external_query = external_query.exclude_import_kind(ImportKind::AssociatedItem);\n+            (local_query, external_query)\n         }\n-        AssocItemSearch::AssocItemsOnly => {\n-            external_query = external_query.assoc_items_only();\n+        NameToImport::Fuzzy(fuzzy_search_string) => {\n+            let mut external_query = import_map::Query::new(fuzzy_search_string.clone())\n+                .search_mode(import_map::SearchMode::Fuzzy)\n+                .name_only();\n+            match assoc_item_search {\n+                AssocItemSearch::Include => {}\n+                AssocItemSearch::Exclude => {\n+                    external_query = external_query.exclude_import_kind(ImportKind::AssociatedItem);\n+                }\n+                AssocItemSearch::AssocItemsOnly => {\n+                    external_query = external_query.assoc_items_only();\n+                }\n+            }\n+\n+            (symbol_index::Query::new(fuzzy_search_string), external_query)\n         }\n-    }\n-\n-    let mut local_query = symbol_index::Query::new(fuzzy_search_string);\n+    };\n \n     if let Some(limit) = limit {\n         external_query = external_query.limit(limit);\n         local_query.limit(limit);\n     }\n \n-    find_items(sema, krate, local_query, external_query)\n-        .into_iter()\n-        .filter(move |&item| match assoc_item_search {\n-            AssocItemSearch::Include => true,\n-            AssocItemSearch::Exclude => !is_assoc_item(item, sema.db),\n-            AssocItemSearch::AssocItemsOnly => is_assoc_item(item, sema.db),\n-        })\n-        .collect()\n-}\n-\n-fn is_assoc_item(item: ItemInNs, db: &RootDatabase) -> bool {\n-    item.as_module_def_id()\n-        .and_then(|module_def_id| ModuleDef::from(module_def_id).as_assoc_item(db))\n-        .is_some()\n+    find_items(sema, krate, assoc_item_search, local_query, external_query)\n }\n \n fn find_items(\n     sema: &Semantics<'_, RootDatabase>,\n     krate: Crate,\n+    assoc_item_search: AssocItemSearch,\n     local_query: symbol_index::Query,\n     external_query: import_map::Query,\n ) -> FxHashSet<ItemInNs> {\n-    let _p = profile::span(\"find_similar_imports\");\n+    let _p = profile::span(\"find_items\");\n     let db = sema.db;\n \n-    // Query dependencies first.\n-    let mut candidates = krate\n-        .query_external_importables(db, external_query)\n-        .map(|external_importable| match external_importable {\n-            Either::Left(module_def) => ItemInNs::from(module_def),\n-            Either::Right(macro_def) => ItemInNs::from(macro_def),\n-        })\n-        .collect::<FxHashSet<_>>();\n+    let external_importables =\n+        krate.query_external_importables(db, external_query).map(|external_importable| {\n+            match external_importable {\n+                Either::Left(module_def) => ItemInNs::from(module_def),\n+                Either::Right(macro_def) => ItemInNs::from(macro_def),\n+            }\n+        });\n \n     // Query the local crate using the symbol index.\n-    let local_results = symbol_index::crate_symbols(db, krate.into(), local_query);\n-\n-    candidates.extend(\n-        local_results\n-            .into_iter()\n-            .filter_map(|local_candidate| get_name_definition(sema, &local_candidate))\n-            .filter_map(|name_definition_to_import| match name_definition_to_import {\n-                Definition::ModuleDef(module_def) => Some(ItemInNs::from(module_def)),\n-                Definition::Macro(macro_def) => Some(ItemInNs::from(macro_def)),\n-                _ => None,\n-            }),\n-    );\n-\n-    candidates\n+    let local_results = symbol_index::crate_symbols(db, krate.into(), local_query)\n+        .into_iter()\n+        .filter_map(|local_candidate| get_name_definition(sema, &local_candidate))\n+        .filter_map(|name_definition_to_import| match name_definition_to_import {\n+            Definition::ModuleDef(module_def) => Some(ItemInNs::from(module_def)),\n+            Definition::Macro(macro_def) => Some(ItemInNs::from(macro_def)),\n+            _ => None,\n+        });\n+\n+    external_importables\n+        .chain(local_results)\n+        .filter(move |&item| match assoc_item_search {\n+            AssocItemSearch::Include => true,\n+            AssocItemSearch::Exclude => !is_assoc_item(item, sema.db),\n+            AssocItemSearch::AssocItemsOnly => is_assoc_item(item, sema.db),\n+        })\n+        .collect()\n }\n \n fn get_name_definition(\n@@ -144,3 +141,9 @@ fn get_name_definition(\n     let name = ast::Name::cast(candidate_name_node)?;\n     NameClass::classify(sema, &name)?.defined(sema.db)\n }\n+\n+fn is_assoc_item(item: ItemInNs, db: &RootDatabase) -> bool {\n+    item.as_module_def_id()\n+        .and_then(|module_def_id| ModuleDef::from(module_def_id).as_assoc_item(db))\n+        .is_some()\n+}"}]}