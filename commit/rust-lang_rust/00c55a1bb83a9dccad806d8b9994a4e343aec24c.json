{"sha": "00c55a1bb83a9dccad806d8b9994a4e343aec24c", "node_id": "C_kwDOAAsO6NoAKDAwYzU1YTFiYjgzYTlkY2NhZDgwNmQ4Yjk5OTRhNGUzNDNhZWMyNGM", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-11-05T18:50:29Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-12-31T03:33:44Z"}, "message": "Introduce IntervalSet\n\nThis is a compact, fast storage for variable-sized sets, typically consisting of\nlarger ranges. It is less efficient than a bitset if ranges are both small and\nthe domain size is small, but will still perform acceptably. With enormous\ndomain sizes and large ranges, the interval set performs much better, as it can\nbe much more densely packed in memory than the uncompressed bit set alternative.", "tree": {"sha": "3bd803c1aae047863082b8a1b52540a174ee289d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bd803c1aae047863082b8a1b52540a174ee289d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00c55a1bb83a9dccad806d8b9994a4e343aec24c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00c55a1bb83a9dccad806d8b9994a4e343aec24c", "html_url": "https://github.com/rust-lang/rust/commit/00c55a1bb83a9dccad806d8b9994a4e343aec24c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00c55a1bb83a9dccad806d8b9994a4e343aec24c/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a09f775e5a71ba809f465b3af377943627552001", "url": "https://api.github.com/repos/rust-lang/rust/commits/a09f775e5a71ba809f465b3af377943627552001", "html_url": "https://github.com/rust-lang/rust/commit/a09f775e5a71ba809f465b3af377943627552001"}], "stats": {"total": 471, "additions": 471, "deletions": 0}, "files": [{"sha": "6f7bedf7d123d04eaeebc4922984470ed58bdd0c", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00c55a1bb83a9dccad806d8b9994a4e343aec24c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/00c55a1bb83a9dccad806d8b9994a4e343aec24c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=00c55a1bb83a9dccad806d8b9994a4e343aec24c", "patch": "@@ -3965,6 +3965,7 @@ dependencies = [\n  \"arrayvec\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n+ \"smallvec\",\n ]\n \n [[package]]"}, {"sha": "89419bfce6f5bf86846713017ce68afab612aca1", "filename": "compiler/rustc_index/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00c55a1bb83a9dccad806d8b9994a4e343aec24c/compiler%2Frustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00c55a1bb83a9dccad806d8b9994a4e343aec24c/compiler%2Frustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2FCargo.toml?ref=00c55a1bb83a9dccad806d8b9994a4e343aec24c", "patch": "@@ -10,3 +10,4 @@ doctest = false\n arrayvec = { version = \"0.7\", default-features = false }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_macros = { path = \"../rustc_macros\" }\n+smallvec = \"1\""}, {"sha": "6da95053b116d2092e4bdaeef7f08fe2904c46be", "filename": "compiler/rustc_index/src/interval.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/00c55a1bb83a9dccad806d8b9994a4e343aec24c/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c55a1bb83a9dccad806d8b9994a4e343aec24c/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval.rs?ref=00c55a1bb83a9dccad806d8b9994a4e343aec24c", "patch": "@@ -0,0 +1,269 @@\n+use std::iter::Step;\n+use std::marker::PhantomData;\n+use std::ops::Bound;\n+use std::ops::RangeBounds;\n+\n+use crate::vec::Idx;\n+use crate::vec::IndexVec;\n+use smallvec::SmallVec;\n+\n+#[cfg(test)]\n+mod tests;\n+\n+/// Stores a set of intervals on the indices.\n+#[derive(Debug, Clone)]\n+pub struct IntervalSet<I> {\n+    // Start, end\n+    map: SmallVec<[(u32, u32); 4]>,\n+    domain: usize,\n+    _data: PhantomData<I>,\n+}\n+\n+#[inline]\n+fn inclusive_start<T: Idx>(range: impl RangeBounds<T>) -> u32 {\n+    match range.start_bound() {\n+        Bound::Included(start) => start.index() as u32,\n+        Bound::Excluded(start) => start.index() as u32 + 1,\n+        Bound::Unbounded => 0,\n+    }\n+}\n+\n+#[inline]\n+fn inclusive_end<T: Idx>(domain: usize, range: impl RangeBounds<T>) -> Option<u32> {\n+    let end = match range.end_bound() {\n+        Bound::Included(end) => end.index() as u32,\n+        Bound::Excluded(end) => end.index().checked_sub(1)? as u32,\n+        Bound::Unbounded => domain.checked_sub(1)? as u32,\n+    };\n+    Some(end)\n+}\n+\n+impl<I: Idx> IntervalSet<I> {\n+    pub fn new(domain: usize) -> IntervalSet<I> {\n+        IntervalSet { map: SmallVec::new(), domain, _data: PhantomData }\n+    }\n+\n+    pub fn clear(&mut self) {\n+        self.map.clear();\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = I> + '_\n+    where\n+        I: Step,\n+    {\n+        self.iter_intervals().flatten()\n+    }\n+\n+    /// Iterates through intervals stored in the set, in order.\n+    pub fn iter_intervals(&self) -> impl Iterator<Item = std::ops::Range<I>> + '_\n+    where\n+        I: Step,\n+    {\n+        self.map.iter().map(|&(start, end)| I::new(start as usize)..I::new(end as usize + 1))\n+    }\n+\n+    /// Returns true if we increased the number of elements present.\n+    pub fn insert(&mut self, point: I) -> bool {\n+        self.insert_range(point..=point)\n+    }\n+\n+    /// Returns true if we increased the number of elements present.\n+    pub fn insert_range(&mut self, range: impl RangeBounds<I> + Clone) -> bool {\n+        let start = inclusive_start(range.clone());\n+        let Some(mut end) = inclusive_end(self.domain, range) else {\n+            // empty range\n+            return false;\n+        };\n+        if start > end {\n+            return false;\n+        }\n+\n+        loop {\n+            // This condition looks a bit weird, but actually makes sense.\n+            //\n+            // if r.0 == end + 1, then we're actually adjacent, so we want to\n+            // continue to the next range. We're looking here for the first\n+            // range which starts *non-adjacently* to our end.\n+            let next = self.map.partition_point(|r| r.0 <= end + 1);\n+            if let Some(last) = next.checked_sub(1) {\n+                let (prev_start, prev_end) = &mut self.map[last];\n+                if *prev_end + 1 >= start {\n+                    // If the start for the inserted range is adjacent to the\n+                    // end of the previous, we can extend the previous range.\n+                    if start < *prev_start {\n+                        // Our range starts before the one we found. We'll need\n+                        // to *remove* it, and then try again.\n+                        //\n+                        // FIXME: This is not so efficient; we may need to\n+                        // recurse a bunch of times here. Instead, it's probably\n+                        // better to do something like drain_filter(...) on the\n+                        // map to be able to delete or modify all the ranges in\n+                        // start..=end and then potentially re-insert a new\n+                        // range.\n+                        end = std::cmp::max(end, *prev_end);\n+                        self.map.remove(last);\n+                    } else {\n+                        // We overlap with the previous range, increase it to\n+                        // include us.\n+                        //\n+                        // Make sure we're actually going to *increase* it though --\n+                        // it may be that end is just inside the previously existing\n+                        // set.\n+                        return if end > *prev_end {\n+                            *prev_end = end;\n+                            true\n+                        } else {\n+                            false\n+                        };\n+                    }\n+                } else {\n+                    // Otherwise, we don't overlap, so just insert\n+                    self.map.insert(last + 1, (start, end));\n+                    return true;\n+                }\n+            } else {\n+                if self.map.is_empty() {\n+                    // Quite common in practice, and expensive to call memcpy\n+                    // with length zero.\n+                    self.map.push((start, end));\n+                } else {\n+                    self.map.insert(next, (start, end));\n+                }\n+                return true;\n+            }\n+        }\n+    }\n+\n+    pub fn contains(&self, needle: I) -> bool {\n+        let needle = needle.index() as u32;\n+        let last = match self.map.partition_point(|r| r.0 <= needle).checked_sub(1) {\n+            Some(idx) => idx,\n+            None => {\n+                // All ranges in the map start after the new range's end\n+                return false;\n+            }\n+        };\n+        let (_, prev_end) = &self.map[last];\n+        needle <= *prev_end\n+    }\n+\n+    pub fn superset(&self, other: &IntervalSet<I>) -> bool\n+    where\n+        I: Step,\n+    {\n+        // FIXME: Performance here is probably not great. We will be doing a lot\n+        // of pointless tree traversals.\n+        other.iter().all(|elem| self.contains(elem))\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.map.is_empty()\n+    }\n+\n+    /// Returns the maximum (last) element present in the set from `range`.\n+    pub fn last_set_in(&self, range: impl RangeBounds<I> + Clone) -> Option<I> {\n+        let start = inclusive_start(range.clone());\n+        let Some(end) = inclusive_end(self.domain, range) else {\n+            // empty range\n+            return None;\n+        };\n+        if start > end {\n+            return None;\n+        }\n+        let last = match self.map.partition_point(|r| r.0 <= end).checked_sub(1) {\n+            Some(idx) => idx,\n+            None => {\n+                // All ranges in the map start after the new range's end\n+                return None;\n+            }\n+        };\n+        let (_, prev_end) = &self.map[last];\n+        if start <= *prev_end { Some(I::new(std::cmp::min(*prev_end, end) as usize)) } else { None }\n+    }\n+\n+    pub fn insert_all(&mut self) {\n+        self.clear();\n+        self.map.push((0, self.domain.try_into().unwrap()));\n+    }\n+\n+    pub fn union(&mut self, other: &IntervalSet<I>) -> bool\n+    where\n+        I: Step,\n+    {\n+        assert_eq!(self.domain, other.domain);\n+        let mut did_insert = false;\n+        for range in other.iter_intervals() {\n+            did_insert |= self.insert_range(range);\n+        }\n+        did_insert\n+    }\n+}\n+\n+/// This data structure optimizes for cases where the stored bits in each row\n+/// are expected to be highly contiguous (long ranges of 1s or 0s), in contrast\n+/// to BitMatrix and SparseBitMatrix which are optimized for\n+/// \"random\"/non-contiguous bits and cheap(er) point queries at the expense of\n+/// memory usage.\n+#[derive(Clone)]\n+pub struct SparseIntervalMatrix<R, C>\n+where\n+    R: Idx,\n+    C: Idx,\n+{\n+    rows: IndexVec<R, IntervalSet<C>>,\n+    column_size: usize,\n+}\n+\n+impl<R: Idx, C: Step + Idx> SparseIntervalMatrix<R, C> {\n+    pub fn new(column_size: usize) -> SparseIntervalMatrix<R, C> {\n+        SparseIntervalMatrix { rows: IndexVec::new(), column_size }\n+    }\n+\n+    pub fn rows(&self) -> impl Iterator<Item = R> {\n+        self.rows.indices()\n+    }\n+\n+    pub fn row(&self, row: R) -> Option<&IntervalSet<C>> {\n+        self.rows.get(row)\n+    }\n+\n+    fn ensure_row(&mut self, row: R) -> &mut IntervalSet<C> {\n+        self.rows.ensure_contains_elem(row, || IntervalSet::new(self.column_size));\n+        &mut self.rows[row]\n+    }\n+\n+    pub fn union_row(&mut self, row: R, from: &IntervalSet<C>) -> bool\n+    where\n+        C: Step,\n+    {\n+        self.ensure_row(row).union(from)\n+    }\n+\n+    pub fn union_rows(&mut self, read: R, write: R) -> bool\n+    where\n+        C: Step,\n+    {\n+        if read == write || self.rows.get(read).is_none() {\n+            return false;\n+        }\n+        self.ensure_row(write);\n+        let (read_row, write_row) = self.rows.pick2_mut(read, write);\n+        write_row.union(read_row)\n+    }\n+\n+    pub fn insert_all_into_row(&mut self, row: R) {\n+        self.ensure_row(row).insert_all();\n+    }\n+\n+    pub fn insert_range(&mut self, row: R, range: impl RangeBounds<C> + Clone) {\n+        self.ensure_row(row).insert_range(range);\n+    }\n+\n+    pub fn insert(&mut self, row: R, point: C) -> bool {\n+        self.ensure_row(row).insert(point)\n+    }\n+\n+    pub fn contains(&self, row: R, point: C) -> bool {\n+        self.row(row).map_or(false, |r| r.contains(point))\n+    }\n+}"}, {"sha": "d90b449f3260919915f83dfcff69526bbc58d722", "filename": "compiler/rustc_index/src/interval/tests.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/00c55a1bb83a9dccad806d8b9994a4e343aec24c/compiler%2Frustc_index%2Fsrc%2Finterval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c55a1bb83a9dccad806d8b9994a4e343aec24c/compiler%2Frustc_index%2Fsrc%2Finterval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval%2Ftests.rs?ref=00c55a1bb83a9dccad806d8b9994a4e343aec24c", "patch": "@@ -0,0 +1,199 @@\n+use super::*;\n+\n+#[test]\n+fn insert_collapses() {\n+    let mut set = IntervalSet::<u32>::new(3000);\n+    set.insert_range(9831..=9837);\n+    set.insert_range(43..=9830);\n+    assert_eq!(set.iter_intervals().collect::<Vec<_>>(), [43..9838]);\n+}\n+\n+#[test]\n+fn contains() {\n+    let mut set = IntervalSet::new(300);\n+    set.insert(0u32);\n+    assert!(set.contains(0));\n+    set.insert_range(0..10);\n+    assert!(set.contains(9));\n+    assert!(!set.contains(10));\n+    set.insert_range(10..11);\n+    assert!(set.contains(10));\n+}\n+\n+#[test]\n+fn insert() {\n+    for i in 0..30usize {\n+        let mut set = IntervalSet::new(300);\n+        for j in i..30usize {\n+            set.insert(j);\n+            for k in i..j {\n+                assert!(set.contains(k));\n+            }\n+        }\n+    }\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..1u32);\n+    assert!(set.contains(0), \"{:?}\", set.map);\n+    assert!(!set.contains(1));\n+    set.insert_range(1..1);\n+    assert!(set.contains(0));\n+    assert!(!set.contains(1));\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(4..5u32);\n+    set.insert_range(5..10);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [4, 5, 6, 7, 8, 9]);\n+    set.insert_range(3..7);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..10u32);\n+    set.insert_range(3..5);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..10u32);\n+    set.insert_range(0..3);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..10u32);\n+    set.insert_range(0..10);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..10u32);\n+    set.insert_range(5..10);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..10u32);\n+    set.insert_range(5..13);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);\n+}\n+\n+#[test]\n+fn insert_range() {\n+    #[track_caller]\n+    fn check<R>(range: R)\n+    where\n+        R: RangeBounds<usize> + Clone + IntoIterator<Item = usize> + std::fmt::Debug,\n+    {\n+        let mut set = IntervalSet::new(300);\n+        set.insert_range(range.clone());\n+        for i in set.iter() {\n+            assert!(range.contains(&i));\n+        }\n+        for i in range.clone() {\n+            assert!(set.contains(i), \"A: {} in {:?}, inserted {:?}\", i, set, range);\n+        }\n+        set.insert_range(range.clone());\n+        for i in set.iter() {\n+            assert!(range.contains(&i), \"{} in {:?}\", i, set);\n+        }\n+        for i in range.clone() {\n+            assert!(set.contains(i), \"B: {} in {:?}, inserted {:?}\", i, set, range);\n+        }\n+    }\n+    check(10..10);\n+    check(10..100);\n+    check(10..30);\n+    check(0..5);\n+    check(0..250);\n+    check(200..250);\n+\n+    check(10..=10);\n+    check(10..=100);\n+    check(10..=30);\n+    check(0..=5);\n+    check(0..=250);\n+    check(200..=250);\n+\n+    for i in 0..30 {\n+        for j in i..30 {\n+            check(i..j);\n+            check(i..=j);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn insert_range_dual() {\n+    let mut set = IntervalSet::<u32>::new(300);\n+    set.insert_range(0..3);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2]);\n+    set.insert_range(5..7);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 5, 6]);\n+    set.insert_range(3..4);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 5, 6]);\n+    set.insert_range(3..5);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6]);\n+}\n+\n+#[test]\n+fn last_set_before_adjacent() {\n+    let mut set = IntervalSet::<u32>::new(300);\n+    set.insert_range(0..3);\n+    set.insert_range(3..5);\n+    assert_eq!(set.last_set_in(0..3), Some(2));\n+    assert_eq!(set.last_set_in(0..5), Some(4));\n+    assert_eq!(set.last_set_in(3..5), Some(4));\n+    set.insert_range(2..5);\n+    assert_eq!(set.last_set_in(0..3), Some(2));\n+    assert_eq!(set.last_set_in(0..5), Some(4));\n+    assert_eq!(set.last_set_in(3..5), Some(4));\n+}\n+\n+#[test]\n+fn last_set_in() {\n+    fn easy(set: &IntervalSet<usize>, needle: impl RangeBounds<usize>) -> Option<usize> {\n+        let mut last_leq = None;\n+        for e in set.iter() {\n+            if needle.contains(&e) {\n+                last_leq = Some(e);\n+            }\n+        }\n+        last_leq\n+    }\n+\n+    #[track_caller]\n+    fn cmp(set: &IntervalSet<usize>, needle: impl RangeBounds<usize> + Clone + std::fmt::Debug) {\n+        assert_eq!(\n+            set.last_set_in(needle.clone()),\n+            easy(set, needle.clone()),\n+            \"{:?} in {:?}\",\n+            needle,\n+            set\n+        );\n+    }\n+    let mut set = IntervalSet::new(300);\n+    cmp(&set, 50..=50);\n+    set.insert(64);\n+    cmp(&set, 64..=64);\n+    set.insert(64 - 1);\n+    cmp(&set, 0..=64 - 1);\n+    cmp(&set, 0..=5);\n+    cmp(&set, 10..100);\n+    set.insert(100);\n+    cmp(&set, 100..110);\n+    cmp(&set, 99..100);\n+    cmp(&set, 99..=100);\n+\n+    for i in 0..=30 {\n+        for j in i..=30 {\n+            for k in 0..30 {\n+                let mut set = IntervalSet::new(100);\n+                cmp(&set, ..j);\n+                cmp(&set, i..);\n+                cmp(&set, i..j);\n+                cmp(&set, i..=j);\n+                set.insert(k);\n+                cmp(&set, ..j);\n+                cmp(&set, i..);\n+                cmp(&set, i..j);\n+                cmp(&set, i..=j);\n+            }\n+        }\n+    }\n+}"}, {"sha": "359b1859c6889052f02776ee85509347d32beade", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00c55a1bb83a9dccad806d8b9994a4e343aec24c/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c55a1bb83a9dccad806d8b9994a4e343aec24c/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=00c55a1bb83a9dccad806d8b9994a4e343aec24c", "patch": "@@ -7,6 +7,7 @@\n #![feature(let_else)]\n \n pub mod bit_set;\n+pub mod interval;\n pub mod vec;\n \n // FIXME(#56935): Work around ICEs during cross-compilation."}]}