{"sha": "f67e7d6b4ab61acc7de258fd555f79c55b433cbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2N2U3ZDZiNGFiNjFhY2M3ZGUyNThmZDU1NWY3OWM1NWI0MzNjYmU=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-01T08:29:23Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-04T18:34:00Z"}, "message": "Add method, new_block, to MirContext for block construction.\n\nThis makes a slow transition to block construction happening only from\nMirContext easier.", "tree": {"sha": "28dde72938b675d4ebafea5f0183ff033dff0b2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28dde72938b675d4ebafea5f0183ff033dff0b2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f67e7d6b4ab61acc7de258fd555f79c55b433cbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f67e7d6b4ab61acc7de258fd555f79c55b433cbe", "html_url": "https://github.com/rust-lang/rust/commit/f67e7d6b4ab61acc7de258fd555f79c55b433cbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f67e7d6b4ab61acc7de258fd555f79c55b433cbe/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "html_url": "https://github.com/rust-lang/rust/commit/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb"}], "stats": {"total": 44, "additions": 24, "deletions": 20}, "files": [{"sha": "db54bd717afcb7b2766d2e3e89c1fda561cde1f2", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f67e7d6b4ab61acc7de258fd555f79c55b433cbe/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67e7d6b4ab61acc7de258fd555f79c55b433cbe/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f67e7d6b4ab61acc7de258fd555f79c55b433cbe", "patch": "@@ -44,7 +44,7 @@ use super::operand::OperandValue::{Pair, Ref, Immediate};\n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock,\n         funclets: &IndexVec<mir::BasicBlock, Option<Funclet>>) {\n-        let mut bcx = self.build_block(bb);\n+        let mut bcx = self.get_builder(bb);\n         let data = &self.mir[bb];\n \n         debug!(\"trans_block({:?}={:?})\", bb, data);\n@@ -75,7 +75,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n         };\n \n-        let llblock = |this: &mut Self, bcx: &Builder, target: mir::BasicBlock| {\n+        let llblock = |this: &mut Self, target: mir::BasicBlock| {\n             let lltarget = this.blocks[target];\n \n             if let Some(cp) = cleanup_pad {\n@@ -85,7 +85,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                         debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n                         let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n-                        let trampoline = bcx.build_new_block(name);\n+                        let trampoline = this.new_block(name);\n                         trampoline.cleanup_ret(cp, Some(lltarget));\n                         trampoline.llbb()\n                     }\n@@ -139,8 +139,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::TerminatorKind::If { ref cond, targets: (true_bb, false_bb) } => {\n                 let cond = self.trans_operand(&bcx, cond);\n \n-                let lltrue = llblock(self, &bcx, true_bb);\n-                let llfalse = llblock(self, &bcx, false_bb);\n+                let lltrue = llblock(self, true_bb);\n+                let llfalse = llblock(self, false_bb);\n                 bcx.cond_br(cond.immediate(), lltrue, llfalse);\n             }\n \n@@ -159,7 +159,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // code. This is especially helpful in cases like an if-let on a huge enum.\n                     // Note: This optimization is only valid for exhaustive matches.\n                     Some((&&bb, &c)) if c > targets.len() / 2 => {\n-                        (Some(bb), llblock(self, &bcx, bb))\n+                        (Some(bb), llblock(self, bb))\n                     }\n                     // We're generating an exhaustive switch, so the else branch\n                     // can't be hit.  Branching to an unreachable instruction\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 assert_eq!(adt_def.variants.len(), targets.len());\n                 for (adt_variant, &target) in adt_def.variants.iter().zip(targets) {\n                     if default_bb != Some(target) {\n-                        let llbb = llblock(self, &bcx, target);\n+                        let llbb = llblock(self, target);\n                         let llval = adt::trans_case(&bcx, ty, Disr::from(adt_variant.disr_val));\n                         bcx.add_case(switch, llval, llbb)\n                     }\n@@ -181,10 +181,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let (otherwise, targets) = targets.split_last().unwrap();\n                 let discr = bcx.load(self.trans_lvalue(&bcx, discr).llval);\n                 let discr = base::to_immediate(&bcx, discr, switch_ty);\n-                let switch = bcx.switch(discr, llblock(self, &bcx, *otherwise), values.len());\n+                let switch = bcx.switch(discr, llblock(self, *otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n                     let val = Const::from_constval(bcx.ccx, value.clone(), switch_ty);\n-                    let llbb = llblock(self, &bcx, *target);\n+                    let llbb = llblock(self, *target);\n                     bcx.add_case(switch, val.llval, llbb)\n                 }\n             }\n@@ -261,7 +261,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         drop_fn,\n                         args,\n                         self.blocks[target],\n-                        llblock(self, &bcx, unwind),\n+                        llblock(self, unwind),\n                         cleanup_bundle\n                     );\n                 } else {\n@@ -301,8 +301,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let cond = bcx.call(expect, &[cond, C_bool(bcx.ccx, expected)], None);\n \n                 // Create the failure block and the conditional branch to it.\n-                let lltarget = llblock(self, &bcx, target);\n-                let panic_block = bcx.build_new_block(\"panic\");\n+                let lltarget = llblock(self, target);\n+                let panic_block = self.new_block(\"panic\");\n                 if expected {\n                     bcx.cond_br(cond, lltarget, panic_block.llbb());\n                 } else {\n@@ -382,7 +382,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     bcx.invoke(llfn,\n                                &args,\n                                self.unreachable_block(),\n-                               llblock(self, &bcx, unwind),\n+                               llblock(self, unwind),\n                                cleanup_bundle);\n                 } else {\n                     bcx.call(llfn, &args, cleanup_bundle);\n@@ -580,12 +580,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let invokeret = bcx.invoke(fn_ptr,\n                                                &llargs,\n                                                ret_bcx,\n-                                               llblock(self, &bcx, cleanup),\n+                                               llblock(self, cleanup),\n                                                cleanup_bundle);\n                     fn_ty.apply_attrs_callsite(invokeret);\n \n                     if let Some((_, target)) = *destination {\n-                        let ret_bcx = self.build_block(target);\n+                        let ret_bcx = self.get_builder(target);\n                         ret_bcx.position_at_start(ret_bcx.llbb());\n                         self.set_debug_loc(&ret_bcx, terminator.source_info);\n                         let op = OperandRef {\n@@ -791,9 +791,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             return self.blocks[target_bb];\n         }\n \n-        let target = self.build_block(target_bb);\n+        let target = self.get_builder(target_bb);\n \n-        let bcx = target.build_new_block(\"cleanup\");\n+        let bcx = self.new_block(\"cleanup\");\n         self.landing_pads[target_bb] = Some(bcx.llbb());\n \n         let ccx = bcx.ccx;\n@@ -809,14 +809,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     fn unreachable_block(&mut self) -> BasicBlockRef {\n         self.unreachable_block.unwrap_or_else(|| {\n-            let bl = self.build_block(mir::START_BLOCK).build_new_block(\"unreachable\");\n+            let bl = self.new_block(\"unreachable\");\n             bl.unreachable();\n             self.unreachable_block = Some(bl.llbb());\n             bl.llbb()\n         })\n     }\n \n-    pub fn build_block(&self, bb: mir::BasicBlock) -> Builder<'a, 'tcx> {\n+    pub fn new_block(&self, name: &str) -> Builder<'a, 'tcx> {\n+        Builder::new_block(self.ccx, self.llfn, name)\n+    }\n+\n+    pub fn get_builder(&self, bb: mir::BasicBlock) -> Builder<'a, 'tcx> {\n         let builder = Builder::with_ccx(self.ccx);\n         builder.position_at_end(self.blocks[bb]);\n         builder"}, {"sha": "2090c8eaab929bbf847b81718901e624e69d370b", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f67e7d6b4ab61acc7de258fd555f79c55b433cbe/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67e7d6b4ab61acc7de258fd555f79c55b433cbe/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=f67e7d6b4ab61acc7de258fd555f79c55b433cbe", "patch": "@@ -326,7 +326,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     let funclets: IndexVec<mir::BasicBlock, Option<Funclet>> =\n     mircx.cleanup_kinds.iter_enumerated().map(|(bb, cleanup_kind)| {\n         if let CleanupKind::Funclet = *cleanup_kind {\n-            let bcx = mircx.build_block(bb);\n+            let bcx = mircx.get_builder(bb);\n             bcx.set_personality_fn(mircx.ccx.eh_personality());\n             if base::wants_msvc_seh(ccx.sess()) {\n                 return Some(Funclet::new(bcx.cleanup_pad(None, &[])));"}]}