{"sha": "af306567858b9456870d33963673d4711dff9ec2", "node_id": "C_kwDOAAsO6NoAKGFmMzA2NTY3ODU4Yjk0NTY4NzBkMzM5NjM2NzNkNDcxMWRmZjllYzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-05T10:47:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-05T10:47:47Z"}, "message": "Auto merge of #14436 - lowr:patch/normalize-assoc-type-in-path-expr, r=HKalbasi\n\nNormalize associated types in paths in expressions\n\nPart of #14393\n\nWhen we resolve paths in expressions (either path expressions or paths in struct expressions), there's a need of projection normalization, which `TyLoweringContext` cannot do on its own. We've been properly applying normalization for paths in struct expressions without type anchor, but not for others:\n\n```rust\nenum E {\n    S { v: i32 }\n    Empty,\n}\n\nimpl Foo for Bar {\n    type Assoc = E;\n    fn foo() {\n        let _ = Self::Assoc::S { v: 42 };   // path in struct expr without type anchor; we already support this\n        let _ = <Self>::Assoc::S { v: 42 }; // path in struct expr with type anchor; resolves with this PR\n        let _ = Self::Assoc::Empty;         // path expr; resolves with this PR\n    }\n}\n```\n\nWith this PR we correctly resolve the whole path, but we need some more tweaks in HIR and/or IDE layers to properly resolve a qualifier (prefix) of such paths and provide IDE features that are pointed out in #14393 to be currently broken.", "tree": {"sha": "5118ca4de4baea86701f7763aa4cdd73814da1e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5118ca4de4baea86701f7763aa4cdd73814da1e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af306567858b9456870d33963673d4711dff9ec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af306567858b9456870d33963673d4711dff9ec2", "html_url": "https://github.com/rust-lang/rust/commit/af306567858b9456870d33963673d4711dff9ec2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af306567858b9456870d33963673d4711dff9ec2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6464392c15fa8788215d669c4c0b1e46bcadeea", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6464392c15fa8788215d669c4c0b1e46bcadeea", "html_url": "https://github.com/rust-lang/rust/commit/a6464392c15fa8788215d669c4c0b1e46bcadeea"}, {"sha": "6447d485e3765c20295368ac3503ed18b041298f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6447d485e3765c20295368ac3503ed18b041298f", "html_url": "https://github.com/rust-lang/rust/commit/6447d485e3765c20295368ac3503ed18b041298f"}], "stats": {"total": 285, "additions": 232, "deletions": 53}, "files": [{"sha": "9afe07932ecc6b2cb3c25ea7fa823e3ff564cdd8", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=af306567858b9456870d33963673d4711dff9ec2", "patch": "@@ -79,7 +79,7 @@ enum Scope {\n     ExprScope(ExprScope),\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum TypeNs {\n     SelfType(ImplId),\n     GenericParam(TypeParamId),"}, {"sha": "23206e93bcb493ea70ff4ecf35cf1e32bd6afff6", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 69, "deletions": 41, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=af306567858b9456870d33963673d4711dff9ec2", "patch": "@@ -16,7 +16,7 @@\n use std::sync::Arc;\n use std::{convert::identity, ops::Index};\n \n-use chalk_ir::{cast::Cast, ConstValue, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n+use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use either::Either;\n use hir_def::{\n     body::Body,\n@@ -37,10 +37,10 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::{always, never};\n \n use crate::{\n-    db::HirDatabase, fold_tys, fold_tys_and_consts, infer::coerce::CoerceMany,\n-    lower::ImplTraitLoweringMode, static_lifetime, to_assoc_type_id, AliasEq, AliasTy, Const,\n-    DomainGoal, GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId,\n-    Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    db::HirDatabase, fold_tys, infer::coerce::CoerceMany, lower::ImplTraitLoweringMode,\n+    static_lifetime, to_assoc_type_id, AliasEq, AliasTy, DomainGoal, GenericArg, Goal, ImplTraitId,\n+    InEnvironment, Interner, ProjectionTy, RpitId, Substitution, TraitRef, Ty, TyBuilder, TyExt,\n+    TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -744,43 +744,13 @@ impl<'a> InferenceContext<'a> {\n         self.result.standard_types.unknown.clone()\n     }\n \n-    /// Replaces ConstScalar::Unknown by a new type var, so we can maybe still infer it.\n-    fn insert_const_vars_shallow(&mut self, c: Const) -> Const {\n-        let data = c.data(Interner);\n-        match &data.value {\n-            ConstValue::Concrete(cc) => match cc.interned {\n-                crate::ConstScalar::Unknown => self.table.new_const_var(data.ty.clone()),\n-                _ => c,\n-            },\n-            _ => c,\n-        }\n-    }\n-\n     /// Replaces `Ty::Error` by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n-        match ty.kind(Interner) {\n-            TyKind::Error => self.table.new_type_var(),\n-            TyKind::InferenceVar(..) => {\n-                let ty_resolved = self.resolve_ty_shallow(&ty);\n-                if ty_resolved.is_unknown() {\n-                    self.table.new_type_var()\n-                } else {\n-                    ty\n-                }\n-            }\n-            _ => ty,\n-        }\n+        self.table.insert_type_vars_shallow(ty)\n     }\n \n     fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n-        fold_tys_and_consts(\n-            ty,\n-            |x, _| match x {\n-                Either::Left(ty) => Either::Left(self.insert_type_vars_shallow(ty)),\n-                Either::Right(c) => Either::Right(self.insert_const_vars_shallow(c)),\n-            },\n-            DebruijnIndex::INNERMOST,\n-        )\n+        self.table.insert_type_vars(ty)\n     }\n \n     fn push_obligation(&mut self, o: DomainGoal) {\n@@ -909,8 +879,6 @@ impl<'a> InferenceContext<'a> {\n             None => return (self.err_ty(), None),\n         };\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n-        // FIXME: this should resolve assoc items as well, see this example:\n-        // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n         let (resolution, unresolved) = if value_ns {\n             match self.resolver.resolve_path_in_value_ns(self.db.upcast(), path) {\n                 Some(ResolveValueResult::ValueNs(value)) => match value {\n@@ -964,8 +932,68 @@ impl<'a> InferenceContext<'a> {\n             TypeNs::SelfType(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = generics.placeholder_subst(self.db);\n-                let ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n-                self.resolve_variant_on_alias(ty, unresolved, mod_path)\n+                let mut ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n+\n+                let Some(mut remaining_idx) = unresolved else {\n+                    return self.resolve_variant_on_alias(ty, None, mod_path);\n+                };\n+\n+                let mut remaining_segments = path.segments().skip(remaining_idx);\n+\n+                // We need to try resolving unresolved segments one by one because each may resolve\n+                // to a projection, which `TyLoweringContext` cannot handle on its own.\n+                while !remaining_segments.is_empty() {\n+                    let resolved_segment = path.segments().get(remaining_idx - 1).unwrap();\n+                    let current_segment = remaining_segments.take(1);\n+\n+                    // If we can resolve to an enum variant, it takes priority over associated type\n+                    // of the same name.\n+                    if let Some((AdtId::EnumId(id), _)) = ty.as_adt() {\n+                        let enum_data = self.db.enum_data(id);\n+                        let name = current_segment.first().unwrap().name;\n+                        if let Some(local_id) = enum_data.variant(name) {\n+                            let variant = EnumVariantId { parent: id, local_id };\n+                            return if remaining_segments.len() == 1 {\n+                                (ty, Some(variant.into()))\n+                            } else {\n+                                // We still have unresolved paths, but enum variants never have\n+                                // associated types!\n+                                (self.err_ty(), None)\n+                            };\n+                        }\n+                    }\n+\n+                    // `lower_partly_resolved_path()` returns `None` as type namespace unless\n+                    // `remaining_segments` is empty, which is never the case here. We don't know\n+                    // which namespace the new `ty` is in until normalized anyway.\n+                    (ty, _) = ctx.lower_partly_resolved_path(\n+                        resolution,\n+                        resolved_segment,\n+                        current_segment,\n+                        false,\n+                    );\n+\n+                    ty = self.table.insert_type_vars(ty);\n+                    ty = self.table.normalize_associated_types_in(ty);\n+                    ty = self.table.resolve_ty_shallow(&ty);\n+                    if ty.is_unknown() {\n+                        return (self.err_ty(), None);\n+                    }\n+\n+                    // FIXME(inherent_associated_types): update `resolution` based on `ty` here.\n+                    remaining_idx += 1;\n+                    remaining_segments = remaining_segments.skip(1);\n+                }\n+\n+                let variant = ty.as_adt().and_then(|(id, _)| match id {\n+                    AdtId::StructId(s) => Some(VariantId::StructId(s)),\n+                    AdtId::UnionId(u) => Some(VariantId::UnionId(u)),\n+                    AdtId::EnumId(_) => {\n+                        // FIXME Error E0071, expected struct, variant or union type, found enum `Foo`\n+                        None\n+                    }\n+                });\n+                (ty, variant)\n             }\n             TypeNs::TypeAliasId(it) => {\n                 let container = it.lookup(self.db.upcast()).container;"}, {"sha": "368c3f65243d996397674834d41d8f2ad023553f", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=af306567858b9456870d33963673d4711dff9ec2", "patch": "@@ -30,11 +30,18 @@ impl<'a> InferenceContext<'a> {\n \n     fn resolve_value_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n         let (value, self_subst) = if let Some(type_ref) = path.type_anchor() {\n-            let Some(last) = path.segments().last() else { return None };\n-            let ty = self.make_ty(type_ref);\n-            let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n+            let last = path.segments().last()?;\n+\n+            // Don't use `self.make_ty()` here as we need `orig_ns`.\n             let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n-            let (ty, _) = ctx.lower_ty_relative_path(ty, None, remaining_segments_for_ty);\n+            let (ty, orig_ns) = ctx.lower_ty_ext(type_ref);\n+            let ty = self.table.insert_type_vars(ty);\n+            let ty = self.table.normalize_associated_types_in(ty);\n+\n+            let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n+            let (ty, _) = ctx.lower_ty_relative_path(ty, orig_ns, remaining_segments_for_ty);\n+            let ty = self.table.insert_type_vars(ty);\n+            let ty = self.table.normalize_associated_types_in(ty);\n             self.resolve_ty_assoc_item(ty, last.name, id).map(|(it, substs)| (it, Some(substs)))?\n         } else {\n             // FIXME: report error, unresolved first path segment\n@@ -169,7 +176,7 @@ impl<'a> InferenceContext<'a> {\n     ) -> Option<(ValueNs, Substitution)> {\n         let trait_ = trait_ref.hir_trait_id();\n         let item =\n-            self.db.trait_data(trait_).items.iter().map(|(_name, id)| (*id)).find_map(|item| {\n+            self.db.trait_data(trait_).items.iter().map(|(_name, id)| *id).find_map(|item| {\n                 match item {\n                     AssocItemId::FunctionId(func) => {\n                         if segment.name == &self.db.function_data(func).name {\n@@ -288,7 +295,7 @@ impl<'a> InferenceContext<'a> {\n         name: &Name,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Substitution)> {\n-        let ty = self.resolve_ty_shallow(ty);\n+        let ty = self.resolve_ty_shallow(&ty);\n         let (enum_id, subst) = match ty.as_adt() {\n             Some((AdtId::EnumId(e), subst)) => (e, subst),\n             _ => return None,"}, {"sha": "c73acb4b12ed8a03f926a3f819a4f8873d819ef6", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=af306567858b9456870d33963673d4711dff9ec2", "patch": "@@ -7,16 +7,18 @@ use chalk_ir::{\n     IntTy, TyVariableKind, UniverseIndex,\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n+use either::Either;\n use ena::unify::UnifyKey;\n use hir_expand::name;\n use stdx::never;\n \n use super::{InferOk, InferResult, InferenceContext, TypeError};\n use crate::{\n-    db::HirDatabase, fold_tys, static_lifetime, to_chalk_trait_id, traits::FnTrait, AliasEq,\n-    AliasTy, BoundVar, Canonical, Const, DebruijnIndex, GenericArg, GenericArgData, Goal, Guidance,\n-    InEnvironment, InferenceVar, Interner, Lifetime, ParamKind, ProjectionTy, ProjectionTyExt,\n-    Scalar, Solution, Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind, VariableKind,\n+    db::HirDatabase, fold_tys, fold_tys_and_consts, static_lifetime, to_chalk_trait_id,\n+    traits::FnTrait, AliasEq, AliasTy, BoundVar, Canonical, Const, ConstValue, DebruijnIndex,\n+    GenericArg, GenericArgData, Goal, Guidance, InEnvironment, InferenceVar, Interner, Lifetime,\n+    ParamKind, ProjectionTy, ProjectionTyExt, Scalar, Solution, Substitution, TraitEnvironment, Ty,\n+    TyBuilder, TyExt, TyKind, VariableKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -717,6 +719,45 @@ impl<'a> InferenceTable<'a> {\n             None\n         }\n     }\n+\n+    pub(super) fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n+        fold_tys_and_consts(\n+            ty,\n+            |x, _| match x {\n+                Either::Left(ty) => Either::Left(self.insert_type_vars_shallow(ty)),\n+                Either::Right(c) => Either::Right(self.insert_const_vars_shallow(c)),\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n+    }\n+\n+    /// Replaces `Ty::Error` by a new type var, so we can maybe still infer it.\n+    pub(super) fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n+        match ty.kind(Interner) {\n+            TyKind::Error => self.new_type_var(),\n+            TyKind::InferenceVar(..) => {\n+                let ty_resolved = self.resolve_ty_shallow(&ty);\n+                if ty_resolved.is_unknown() {\n+                    self.new_type_var()\n+                } else {\n+                    ty\n+                }\n+            }\n+            _ => ty,\n+        }\n+    }\n+\n+    /// Replaces ConstScalar::Unknown by a new type var, so we can maybe still infer it.\n+    pub(super) fn insert_const_vars_shallow(&mut self, c: Const) -> Const {\n+        let data = c.data(Interner);\n+        match &data.value {\n+            ConstValue::Concrete(cc) => match cc.interned {\n+                crate::ConstScalar::Unknown => self.new_const_var(data.ty.clone()),\n+                _ => c,\n+            },\n+            _ => c,\n+        }\n+    }\n }\n \n impl<'a> fmt::Debug for InferenceTable<'a> {"}, {"sha": "adadbb888ba988f96077a2b3a3723b70ff416823", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=af306567858b9456870d33963673d4711dff9ec2", "patch": "@@ -103,7 +103,7 @@ impl ImplTraitLoweringState {\n #[derive(Debug)]\n pub struct TyLoweringContext<'a> {\n     pub db: &'a dyn HirDatabase,\n-    pub resolver: &'a Resolver,\n+    resolver: &'a Resolver,\n     in_binders: DebruijnIndex,\n     /// Note: Conceptually, it's thinkable that we could be in a location where\n     /// some type params should be represented as placeholders, and others"}, {"sha": "17a0c12c3ef7d1340c16e27662ad6b3e8ce601d4", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af306567858b9456870d33963673d4711dff9ec2/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=af306567858b9456870d33963673d4711dff9ec2", "patch": "@@ -4183,3 +4183,106 @@ fn test() {\n \"#,\n     );\n }\n+\n+#[test]\n+fn associated_type_in_struct_expr_path() {\n+    // FIXME: All annotation should be resolvable.\n+    // For lines marked as unstable, see rust-lang/rust#86935.\n+    // FIXME: Remove the comments once stablized.\n+    check_types(\n+        r#\"\n+trait Trait {\n+    type Assoc;\n+    fn f();\n+}\n+\n+struct S { x: u32 }\n+\n+impl Trait for () {\n+    type Assoc = S;\n+\n+    fn f() {\n+        let x = 42;\n+        let a = Self::Assoc { x };\n+      //    ^ S\n+        let a = <Self>::Assoc { x }; // unstable\n+      //    ^ {unknown}\n+\n+        // should be `Copy` but we don't track ownership anyway.\n+        let value = S { x };\n+        if let Self::Assoc { x } = value {}\n+      //                     ^ u32\n+        if let <Self>::Assoc { x } = value {} // unstable\n+      //                       ^ {unknown}\n+    }\n+}\n+    \"#,\n+    );\n+}\n+\n+#[test]\n+fn associted_type_in_struct_expr_path_enum() {\n+    // FIXME: All annotation should be resolvable.\n+    // For lines marked as unstable, see rust-lang/rust#86935.\n+    // FIXME: Remove the comments once stablized.\n+    check_types(\n+        r#\"\n+trait Trait {\n+    type Assoc;\n+    fn f();\n+}\n+\n+enum E {\n+    Unit,\n+    Struct { x: u32 },\n+}\n+\n+impl Trait for () {\n+    type Assoc = E;\n+\n+    fn f() {\n+        let a = Self::Assoc::Unit;\n+      //    ^ E\n+        let a = <Self>::Assoc::Unit;\n+      //    ^ E\n+        let a = <Self::Assoc>::Unit;\n+      //    ^ E\n+        let a = <<Self>::Assoc>::Unit;\n+      //    ^ E\n+\n+        // should be `Copy` but we don't track ownership anyway.\n+        let value = E::Unit;\n+        if let Self::Assoc::Unit = value {}\n+      //       ^^^^^^^^^^^^^^^^^ E\n+        if let <Self>::Assoc::Unit = value {}\n+      //       ^^^^^^^^^^^^^^^^^^^ E\n+        if let <Self::Assoc>::Unit = value {}\n+      //       ^^^^^^^^^^^^^^^^^^^ E\n+        if let <<Self>::Assoc>::Unit = value {}\n+      //       ^^^^^^^^^^^^^^^^^^^^^ E\n+\n+        let x = 42;\n+        let a = Self::Assoc::Struct { x };\n+      //    ^ E\n+        let a = <Self>::Assoc::Struct { x }; // unstable\n+      //    ^ {unknown}\n+        let a = <Self::Assoc>::Struct { x }; // unstable\n+      //    ^ {unknown}\n+        let a = <<Self>::Assoc>::Struct { x }; // unstable\n+      //    ^ {unknown}\n+\n+        // should be `Copy` but we don't track ownership anyway.\n+        let value = E::Struct { x: 42 };\n+        if let Self::Assoc::Struct { x } = value {}\n+      //                             ^ u32\n+        if let <Self>::Assoc::Struct { x } = value {} // unstable\n+      //                               ^ {unknown}\n+        if let <Self::Assoc>::Struct { x } = value {} // unstable\n+      //                               ^ {unknown}\n+        if let <<Self>::Assoc>::Struct { x } = value {} // unstable\n+      //                                 ^ {unknown}\n+    }\n+}\n+    \"#,\n+    );\n+}"}]}