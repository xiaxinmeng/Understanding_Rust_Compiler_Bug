{"sha": "e44784b8750016a695361c990024750e037d8f9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NDc4NGI4NzUwMDE2YTY5NTM2MWM5OTAwMjQ3NTBlMDM3ZDhmOWY=", "commit": {"author": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2020-09-20T15:22:17Z"}, "committer": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2020-10-04T18:43:36Z"}, "message": "Assume slice len is bounded by allocation size\n\nUses assume to check the length against a constant upper bound. The\ninlined result then informs the optimizer of the sound value range.\n\nThis was tried with unreachable_unchecked before which introduces a\nbranch. This has the advantage of not being executed in sound code but\ncomplicates basic blocks. It resulted in ~2% increased compile time in\nsome worst cases.\n\nAdd a codegen test for the assumption, testing the issue from #67186", "tree": {"sha": "60652ccb46cce808024badc56173593400be44a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60652ccb46cce808024badc56173593400be44a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e44784b8750016a695361c990024750e037d8f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e44784b8750016a695361c990024750e037d8f9f", "html_url": "https://github.com/rust-lang/rust/commit/e44784b8750016a695361c990024750e037d8f9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e44784b8750016a695361c990024750e037d8f9f/comments", "author": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d92d28e523bf056ab4eb752510ec52fe4f1c6311", "url": "https://api.github.com/repos/rust-lang/rust/commits/d92d28e523bf056ab4eb752510ec52fe4f1c6311", "html_url": "https://github.com/rust-lang/rust/commit/d92d28e523bf056ab4eb752510ec52fe4f1c6311"}], "stats": {"total": 54, "additions": 51, "deletions": 3}, "files": [{"sha": "49cec16276260ad81b5e74fd13a090828df162cc", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e44784b8750016a695361c990024750e037d8f9f/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44784b8750016a695361c990024750e037d8f9f/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=e44784b8750016a695361c990024750e037d8f9f", "patch": "@@ -80,8 +80,9 @@\n #![feature(constctlz)]\n #![feature(const_panic)]\n #![feature(const_pin)]\n-#![feature(const_fn_union)]\n #![feature(const_fn)]\n+#![feature(const_fn_union)]\n+#![feature(const_assume)]\n #![cfg_attr(not(bootstrap), feature(const_fn_floating_point_arithmetic))]\n #![cfg_attr(not(bootstrap), feature(const_fn_fn_ptr_basics))]\n #![feature(const_generics)]"}, {"sha": "d2b64f3ac6ad0524680f7e9538f96f497c5e8ba0", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e44784b8750016a695361c990024750e037d8f9f/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44784b8750016a695361c990024750e037d8f9f/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=e44784b8750016a695361c990024750e037d8f9f", "patch": "@@ -78,6 +78,17 @@ pub use index::check_range;\n #[lang = \"slice\"]\n #[cfg(not(test))]\n impl<T> [T] {\n+    #[cfg(not(bootstrap))] // Unused in bootstrap\n+    /// The maximum, inclusive, length such that the slice is no larger than `isize::MAX` bytes.\n+    /// This constant is used in `len` below.\n+    const MAX_LEN_BOUND: usize = {\n+        if mem::size_of::<T>() == 0 {\n+            usize::MAX\n+        } else {\n+            isize::MAX as usize / mem::size_of::<T>()\n+        }\n+    };\n+\n     /// Returns the number of elements in the slice.\n     ///\n     /// # Examples\n@@ -90,11 +101,23 @@ impl<T> [T] {\n     #[rustc_const_stable(feature = \"const_slice_len\", since = \"1.32.0\")]\n     #[inline]\n     // SAFETY: const sound because we transmute out the length field as a usize (which it must be)\n-    #[allow_internal_unstable(const_fn_union)]\n+    #[allow_internal_unstable(const_fn_union, const_assume)]\n     pub const fn len(&self) -> usize {\n         // SAFETY: this is safe because `&[T]` and `FatPtr<T>` have the same layout.\n         // Only `std` can make this guarantee.\n-        unsafe { crate::ptr::Repr { rust: self }.raw.len }\n+        let raw_len = unsafe { crate::ptr::Repr { rust: self }.raw.len };\n+\n+        #[cfg(not(bootstrap))] // FIXME: executing assume in const eval not supported in bootstrap\n+        // SAFETY: this assume asserts that `raw_len * size_of::<T>() <= isize::MAX`. All\n+        // references must point to one allocation with size at most isize::MAX. Note that we the\n+        // multiplication could appear to overflow until we have assumed the bound. This overflow\n+        // would make additional values appear 'valid' and then `n > 1` the range of permissible\n+        // length would no longer be the full or even a single range.\n+        unsafe {\n+            crate::intrinsics::assume(raw_len <= Self::MAX_LEN_BOUND)\n+        };\n+\n+        raw_len\n     }\n \n     /// Returns `true` if the slice has a length of 0."}, {"sha": "bb74fc3b2752cf85257a6abbbf0d9443b114d38f", "filename": "src/test/codegen/len-is-bounded.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e44784b8750016a695361c990024750e037d8f9f/src%2Ftest%2Fcodegen%2Flen-is-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44784b8750016a695361c990024750e037d8f9f/src%2Ftest%2Fcodegen%2Flen-is-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flen-is-bounded.rs?ref=e44784b8750016a695361c990024750e037d8f9f", "patch": "@@ -0,0 +1,24 @@\n+// min-llvm-version: 11.0\n+// compile-flags: -O -C panic=abort\n+#![crate_type = \"lib\"]\n+\n+#[no_mangle]\n+pub fn len_range(a: &[u8], b: &[u8]) -> usize {\n+    // CHECK-NOT: panic\n+    a.len().checked_add(b.len()).unwrap()\n+}\n+\n+#[no_mangle]\n+pub fn len_range_on_non_byte(a: &[u16], b: &[u16]) -> usize {\n+    // CHECK-NOT: panic\n+    a.len().checked_add(b.len()).unwrap()\n+}\n+\n+pub struct Zst;\n+\n+#[no_mangle]\n+pub fn zst_range(a: &[Zst], b: &[Zst]) -> usize {\n+    // Zsts may be arbitrarily large.\n+    // CHECK: panic\n+    a.len().checked_add(b.len()).unwrap()\n+}"}]}