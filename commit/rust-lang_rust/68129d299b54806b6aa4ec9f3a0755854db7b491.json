{"sha": "68129d299b54806b6aa4ec9f3a0755854db7b491", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MTI5ZDI5OWI1NDgwNmI2YWE0ZWM5ZjNhMDc1NTg1NGRiN2I0OTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T03:16:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T03:16:59Z"}, "message": "auto merge of #12061 : pongad/rust/delorderable, r=cmr\n\n#12057", "tree": {"sha": "e68b861deca38e786ea5a22a32999de0630c27c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e68b861deca38e786ea5a22a32999de0630c27c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68129d299b54806b6aa4ec9f3a0755854db7b491", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68129d299b54806b6aa4ec9f3a0755854db7b491", "html_url": "https://github.com/rust-lang/rust/commit/68129d299b54806b6aa4ec9f3a0755854db7b491", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68129d299b54806b6aa4ec9f3a0755854db7b491/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "url": "https://api.github.com/repos/rust-lang/rust/commits/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29", "html_url": "https://github.com/rust-lang/rust/commit/89b1686bd7db25b5dd948b1a4d9dfd0c68084c29"}, {"sha": "bf1464c413bb2564c7be0eaceef9515bc0f94f1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf1464c413bb2564c7be0eaceef9515bc0f94f1f", "html_url": "https://github.com/rust-lang/rust/commit/bf1464c413bb2564c7be0eaceef9515bc0f94f1f"}], "stats": {"total": 368, "additions": 55, "deletions": 313}, "files": [{"sha": "6639e7b3ab7d2fdd759237b75d0747ca7d668350", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -33,6 +33,7 @@ use std::cast::{transmute, transmute_mut, transmute_mut_region};\n use std::cast;\n use std::cell::{Cell, RefCell};\n use std::mem;\n+use std::cmp;\n use std::num;\n use std::kinds::marker;\n use std::rc::Rc;\n@@ -183,7 +184,7 @@ impl Arena {\n     // Functions for the POD part of the arena\n     fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n-        let new_min_chunk_size = num::max(n_bytes, self.chunk_size());\n+        let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.set(@Cons(self.pod_head.clone(), self.chunks.get()));\n         self.pod_head =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), true);\n@@ -223,7 +224,7 @@ impl Arena {\n     fn alloc_nonpod_grow(&mut self, n_bytes: uint, align: uint)\n                          -> (*u8, *u8) {\n         // Allocate a new chunk.\n-        let new_min_chunk_size = num::max(n_bytes, self.chunk_size());\n+        let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.set(@Cons(self.head.clone(), self.chunks.get()));\n         self.head =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), false);"}, {"sha": "1ff868dced20e5addf987aa6c155eccf4d37d1f7", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -14,7 +14,6 @@\n use std::cmp;\n use std::iter::RandomAccessIterator;\n use std::iter::{Rev, Enumerate, Repeat, Map, Zip};\n-use std::num;\n use std::ops;\n use std::uint;\n use std::vec;\n@@ -846,7 +845,7 @@ impl MutableSet<uint> for BitvSet {\n         }\n         let nbits = self.capacity();\n         if value >= nbits {\n-            let newsize = num::max(value, nbits * 2) / uint::BITS + 1;\n+            let newsize = cmp::max(value, nbits * 2) / uint::BITS + 1;\n             assert!(newsize > self.bitv.storage.len());\n             self.bitv.storage.grow(newsize, &0);\n         }\n@@ -881,7 +880,7 @@ impl BitvSet {\n     fn commons<'a>(&'a self, other: &'a BitvSet)\n         -> Map<'static, ((uint, &'a uint), &'a ~[uint]), (uint, uint, uint),\n                Zip<Enumerate<vec::Items<'a, uint>>, Repeat<&'a ~[uint]>>> {\n-        let min = num::min(self.bitv.storage.len(), other.bitv.storage.len());\n+        let min = cmp::min(self.bitv.storage.len(), other.bitv.storage.len());\n         self.bitv.storage.slice(0, min).iter().enumerate()\n             .zip(Repeat::new(&other.bitv.storage))\n             .map(|((i, &w), o_store)| (i * uint::BITS, w, o_store[i]))"}, {"sha": "325f55b463451dc81dc4e6f0a3860e4bdb0b0e4a", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -13,7 +13,7 @@\n //! RingBuf implements the trait Deque. It should be imported with `use\n //! extra::container::Deque`.\n \n-use std::num;\n+use std::cmp;\n use std::vec;\n use std::iter::{Rev, RandomAccessIterator};\n \n@@ -120,7 +120,7 @@ impl<T> RingBuf<T> {\n     /// Create an empty RingBuf with space for at least `n` elements.\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         RingBuf{nelts: 0, lo: 0,\n-              elts: vec::from_fn(num::max(MINIMUM_CAPACITY, n), |_| None)}\n+              elts: vec::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n     }\n \n     /// Retrieve an element in the RingBuf by index"}, {"sha": "85da41911c93dab7a233c740b75fc578c964b2df", "filename": "src/libextra/test.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -27,6 +27,7 @@ use time::precise_time_ns;\n use collections::TreeMap;\n \n use std::clone::Clone;\n+use std::cmp;\n use std::io;\n use std::io::File;\n use std::io::Writer;\n@@ -1003,7 +1004,7 @@ impl MetricMap {\n                     if delta.abs() <= noise {\n                         LikelyNoise\n                     } else {\n-                        let pct = delta.abs() / (vold.value).max(&f64::EPSILON) * 100.0;\n+                        let pct = delta.abs() / cmp::max(vold.value, f64::EPSILON) * 100.0;\n                         if vold.noise < 0.0 {\n                             // When 'noise' is negative, it means we want\n                             // to see deltas that go up over time, and can\n@@ -1126,7 +1127,7 @@ impl BenchHarness {\n         if self.iterations == 0 {\n             0\n         } else {\n-            self.ns_elapsed() / self.iterations.max(&1)\n+            self.ns_elapsed() / cmp::max(self.iterations, 1)\n         }\n     }\n \n@@ -1149,7 +1150,7 @@ impl BenchHarness {\n         if self.ns_per_iter() == 0 {\n             n = 1_000_000;\n         } else {\n-            n = 1_000_000 / self.ns_per_iter().max(&1);\n+            n = 1_000_000 / cmp::max(self.ns_per_iter(), 1);\n         }\n         // if the first run took more than 1ms we don't want to just\n         // be left doing 0 iterations on every loop. The unfortunate\n@@ -1215,6 +1216,7 @@ impl BenchHarness {\n }\n \n pub mod bench {\n+    use std::cmp;\n     use test::{BenchHarness, BenchSamples};\n \n     pub fn benchmark(f: |&mut BenchHarness|) -> BenchSamples {\n@@ -1227,7 +1229,7 @@ pub mod bench {\n \n         let ns_iter_summ = bs.auto_bench(f);\n \n-        let ns_iter = (ns_iter_summ.median as u64).max(&1);\n+        let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n         let iter_s = 1_000_000_000 / ns_iter;\n         let mb_s = (bs.bytes * iter_s) / 1_000_000;\n "}, {"sha": "cb6f5b24a0943eb562601091e139fff20dcf67be", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -29,7 +29,7 @@\n #[license = \"MIT/ASL2\"];\n \n use std::cell::Cell;\n-use std::{os, path};\n+use std::{cmp, os, path};\n use std::io::fs;\n use std::path::is_sep;\n \n@@ -106,7 +106,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n     }\n \n     let root_len = pat_root.map_or(0u, |p| p.as_vec().len());\n-    let dir_patterns = pattern.slice_from(root_len.min(&pattern.len()))\n+    let dir_patterns = pattern.slice_from(cmp::min(root_len, pattern.len()))\n                        .split_terminator(is_sep).map(|s| Pattern::new(s)).to_owned_vec();\n \n     let todo = list_dir_sorted(&root).move_iter().map(|x|(x,0u)).to_owned_vec();"}, {"sha": "345dce12feda785743c0c3efac09d9168f80a3b6", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 10, "deletions": 46, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -16,9 +16,9 @@ A `BigUint` is represented as an array of `BigDigit`s.\n A `BigInt` is a combination of `BigUint` and `Sign`.\n */\n \n+use std::cmp;\n use std::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n-use std::num;\n-use std::num::{Zero, One, ToStrRadix, FromStrRadix, Orderable};\n+use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n use std::num::{Bitwise, ToPrimitive, FromPrimitive};\n use std::rand::Rng;\n use std::str;\n@@ -133,27 +133,9 @@ impl FromStr for BigUint {\n \n impl Num for BigUint {}\n \n-impl Orderable for BigUint {\n-    #[inline]\n-    fn min(&self, other: &BigUint) -> BigUint {\n-        if self < other { self.clone() } else { other.clone() }\n-    }\n-\n-    #[inline]\n-    fn max(&self, other: &BigUint) -> BigUint {\n-        if self > other { self.clone() } else { other.clone() }\n-    }\n-\n-    #[inline]\n-    fn clamp(&self, mn: &BigUint, mx: &BigUint) -> BigUint {\n-        if self > mx { mx.clone() } else\n-        if self < mn { mn.clone() } else { self.clone() }\n-    }\n-}\n-\n impl BitAnd<BigUint, BigUint> for BigUint {\n     fn bitand(&self, other: &BigUint) -> BigUint {\n-        let new_len = num::min(self.data.len(), other.data.len());\n+        let new_len = cmp::min(self.data.len(), other.data.len());\n         let anded = vec::from_fn(new_len, |i| {\n             // i will never be less than the size of either data vector\n             let ai = self.data[i];\n@@ -166,7 +148,7 @@ impl BitAnd<BigUint, BigUint> for BigUint {\n \n impl BitOr<BigUint, BigUint> for BigUint {\n     fn bitor(&self, other: &BigUint) -> BigUint {\n-        let new_len = num::max(self.data.len(), other.data.len());\n+        let new_len = cmp::max(self.data.len(), other.data.len());\n         let ored = vec::from_fn(new_len, |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n@@ -178,7 +160,7 @@ impl BitOr<BigUint, BigUint> for BigUint {\n \n impl BitXor<BigUint, BigUint> for BigUint {\n     fn bitxor(&self, other: &BigUint) -> BigUint {\n-        let new_len = num::max(self.data.len(), other.data.len());\n+        let new_len = cmp::max(self.data.len(), other.data.len());\n         let xored = vec::from_fn(new_len, |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n@@ -223,7 +205,7 @@ impl Unsigned for BigUint {}\n \n impl Add<BigUint, BigUint> for BigUint {\n     fn add(&self, other: &BigUint) -> BigUint {\n-        let new_len = num::max(self.data.len(), other.data.len());\n+        let new_len = cmp::max(self.data.len(), other.data.len());\n \n         let mut carry = 0;\n         let mut sum = vec::from_fn(new_len, |i| {\n@@ -242,7 +224,7 @@ impl Add<BigUint, BigUint> for BigUint {\n \n impl Sub<BigUint, BigUint> for BigUint {\n     fn sub(&self, other: &BigUint) -> BigUint {\n-        let new_len = num::max(self.data.len(), other.data.len());\n+        let new_len = cmp::max(self.data.len(), other.data.len());\n \n         let mut borrow = 0;\n         let diff = vec::from_fn(new_len, |i| {\n@@ -278,7 +260,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n         // = a1*b1 * base^2 +\n         //   (a1*b1 + a0*b0 - (a1-b0)*(b1-a0)) * base +\n         //   a0*b0\n-        let half_len = num::max(s_len, o_len) / 2;\n+        let half_len = cmp::max(s_len, o_len) / 2;\n         let (sHi, sLo) = cut_at(self,  half_len);\n         let (oHi, oLo) = cut_at(other, half_len);\n \n@@ -315,7 +297,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n         #[inline]\n         fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n-            let mid = num::min(a.data.len(), n);\n+            let mid = cmp::min(a.data.len(), n);\n             return (BigUint::from_slice(a.data.slice(mid, a.data.len())),\n                     BigUint::from_slice(a.data.slice(0, mid)));\n         }\n@@ -720,7 +702,7 @@ impl BigUint {\n         let mut n: BigUint      = Zero::zero();\n         let mut power: BigUint  = One::one();\n         loop {\n-            let start = num::max(end, unit_len) - unit_len;\n+            let start = cmp::max(end, unit_len) - unit_len;\n             match uint::parse_bytes(buf.slice(start, end), radix) {\n                 Some(d) => {\n                     let d: Option<BigUint> = FromPrimitive::from_uint(d);\n@@ -941,24 +923,6 @@ impl FromStr for BigInt {\n \n impl Num for BigInt {}\n \n-impl Orderable for BigInt {\n-    #[inline]\n-    fn min(&self, other: &BigInt) -> BigInt {\n-        if self < other { self.clone() } else { other.clone() }\n-    }\n-\n-    #[inline]\n-    fn max(&self, other: &BigInt) -> BigInt {\n-        if self > other { self.clone() } else { other.clone() }\n-    }\n-\n-    #[inline]\n-    fn clamp(&self, mn: &BigInt, mx: &BigInt) -> BigInt {\n-        if self > mx { mx.clone() } else\n-        if self < mn { mn.clone() } else { self.clone() }\n-    }\n-}\n-\n impl Shl<uint, BigInt> for BigInt {\n     #[inline]\n     fn shl(&self, rhs: &uint) -> BigInt {"}, {"sha": "a41996d044f82db877f9fa611658c29ca92e6d5e", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -160,25 +160,6 @@ cmp_impl!(impl TotalEq, equals)\n cmp_impl!(impl Ord, lt, gt, le, ge)\n cmp_impl!(impl TotalOrd, cmp -> cmp::Ordering)\n \n-impl<T: Clone + Integer + Ord> Orderable for Ratio<T> {\n-    #[inline]\n-    fn min(&self, other: &Ratio<T>) -> Ratio<T> {\n-        if *self < *other { self.clone() } else { other.clone() }\n-    }\n-\n-    #[inline]\n-    fn max(&self, other: &Ratio<T>) -> Ratio<T> {\n-        if *self > *other { self.clone() } else { other.clone() }\n-    }\n-\n-    #[inline]\n-    fn clamp(&self, mn: &Ratio<T>, mx: &Ratio<T>) -> Ratio<T> {\n-        if *self > *mx { mx.clone()} else\n-        if *self < *mn { mn.clone() } else { self.clone() }\n-    }\n-}\n-\n-\n /* Arithmetic */\n // a/b * c/d = (a*c)/(b*d)\n impl<T: Clone + Integer + Ord>"}, {"sha": "05087581fd73ae3cdd24164ab2673a095a844b0d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -46,8 +46,8 @@ use middle::lint;\n \n use d = driver::driver;\n \n+use std::cmp;\n use std::io;\n-use std::num;\n use std::os;\n use std::str;\n use std::task;\n@@ -164,7 +164,7 @@ Available lint options:\n \n     let mut max_key = 0;\n     for &(_, name) in lint_dict.iter() {\n-        max_key = num::max(name.len(), max_key);\n+        max_key = cmp::max(name.len(), max_key);\n     }\n     fn padded(max: uint, s: &str) -> ~str {\n         \" \".repeat(max - s.len()) + s"}, {"sha": "8e704aa14da4f802b09e8ca7bafe28acf2d93317", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -26,8 +26,8 @@ use syntax::attr::AttrMetaMethods;\n \n use std::c_str::ToCStr;\n use std::cast;\n+use std::cmp;\n use std::io;\n-use std::num;\n use std::option;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::str;\n@@ -331,7 +331,7 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Option<MetadataBlob> {\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n-                let minsz = num::min(vlen, csz);\n+                let minsz = cmp::min(vlen, csz);\n                 let mut version_ok = false;\n                 vec::raw::buf_as_slice(cvbuf, minsz, |buf0| {\n                     version_ok = (buf0 =="}, {"sha": "e0f13db030562651c27e64cf45752235d08f64b1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -18,8 +18,8 @@ use middle::typeck::method_map;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n+use std::cmp;\n use std::iter;\n-use std::num;\n use std::vec;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n@@ -286,7 +286,7 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                 let max_len = m.rev_iter().fold(0, |max_len, r| {\n                   match r[0].node {\n                     PatVec(ref before, _, ref after) => {\n-                      num::max(before.len() + after.len(), max_len)\n+                      cmp::max(before.len() + after.len(), max_len)\n                     }\n                     _ => max_len\n                   }"}, {"sha": "ca80ce26ae3962b0ff33dccb4a7f01f0b999da62", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -17,7 +17,7 @@ use middle::trans::context::CrateContext;\n \n use middle::trans::type_::Type;\n \n-use std::num;\n+use std::cmp;\n use std::option::{None, Some};\n \n fn align_up_to(off: uint, a: uint) -> uint {\n@@ -44,7 +44,7 @@ fn ty_align(ty: Type) -> uint {\n                 1\n             } else {\n                 let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| num::max(a, ty_align(*t)))\n+                str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n             }\n         }\n         Array => {"}, {"sha": "c3bd84dd583ad5c02e9738fe90c3187be449318d", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -11,7 +11,7 @@\n #[allow(non_uppercase_pattern_statics)];\n \n use std::libc::c_uint;\n-use std::num;\n+use std::cmp;\n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::StructRetAttribute;\n use middle::trans::context::CrateContext;\n@@ -44,7 +44,7 @@ fn ty_align(ty: Type) -> uint {\n             1\n           } else {\n             let str_tys = ty.field_types();\n-            str_tys.iter().fold(1, |a, t| num::max(a, ty_align(*t)))\n+            str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n           }\n         }\n         Array => {\n@@ -98,7 +98,7 @@ fn classify_arg_ty(ty: Type, offset: &mut uint) -> ArgType {\n     let size = ty_size(ty) * 8;\n     let mut align = ty_align(ty);\n \n-    align = num::min(num::max(align, 4), 8);\n+    align = cmp::min(cmp::max(align, 4), 8);\n     *offset = align_up_to(*offset, align);\n     *offset += align_up_to(size, align * 8) / 8;\n "}, {"sha": "4d2e0eeb4762eee0cf2b0871f3af10bfdf6d7da9", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -21,7 +21,7 @@ use middle::trans::context::CrateContext;\n \n use middle::trans::type_::Type;\n \n-use std::num;\n+use std::cmp;\n use std::vec;\n \n #[deriving(Clone, Eq)]\n@@ -105,7 +105,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 1\n               } else {\n                 let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| num::max(a, ty_align(*t)))\n+                str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n               }\n             }\n             Array => {"}, {"sha": "30643737078e827b23d727d0814eb42627634501", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::cmp;\n use std::hashmap::HashSet;\n use std::local_data;\n-use std::num;\n use std::uint;\n use syntax::ast;\n \n@@ -267,7 +267,7 @@ pub fn unindent(s: &str) -> ~str {\n                     false\n                 }\n             });\n-            num::min(min_indent, spaces)\n+            cmp::min(min_indent, spaces)\n         }\n     });\n "}, {"sha": "de9f836ca5eb60a40543828d5fab0f54b5d36527", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -169,6 +169,8 @@ pub trait Ord {\n     fn gt(&self, other: &Self) -> bool {  other.lt(self) }\n     #[inline]\n     fn ge(&self, other: &Self) -> bool { !self.lt(other) }\n+\n+    // FIXME (#12068): Add min/max/clamp default methods\n }\n \n /// The equivalence relation. Two values may be equivalent even if they are"}, {"sha": "f8e02c82fcd992e51854ccd7e48deae2d05758c8", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -54,7 +54,7 @@\n \n use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use clone::Clone;\n-use cmp::{Eq, Equiv};\n+use cmp::{Eq, Equiv, max};\n use default::Default;\n #[cfg(not(stage0))] use fmt;\n use hash::Hash;\n@@ -376,7 +376,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     /// cause many collisions and very poor performance. Setting them\n     /// manually using this function can expose a DoS attack vector.\n     pub fn with_capacity_and_keys(k0: u64, k1: u64, capacity: uint) -> HashMap<K, V> {\n-        let cap = num::max(INITIAL_CAPACITY, capacity);\n+        let cap = max(INITIAL_CAPACITY, capacity);\n         HashMap {\n             k0: k0, k1: k1,\n             resize_at: resize_at(cap),"}, {"sha": "231cf6592eb2ca907dd20f4ba4a2863586c8d4b3", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -10,10 +10,10 @@\n \n //! Buffering wrappers for I/O traits\n \n+use cmp;\n use container::Container;\n use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::ExactSize;\n-use num;\n use option::{Some, None};\n use result::{Ok, Err};\n use vec::{OwnedVector, ImmutableVector, MutableVector};\n@@ -104,7 +104,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let nread = {\n             let available = if_ok!(self.fill());\n-            let nread = num::min(available.len(), buf.len());\n+            let nread = cmp::min(available.len(), buf.len());\n             vec::bytes::copy_memory(buf, available.slice_to(nread));\n             nread\n         };"}, {"sha": "9951405fa0c2fad406cbd397a9a55742485c1453", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -189,42 +189,6 @@ impl Ord for f32 {\n     fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n }\n \n-impl Orderable for f32 {\n-    /// Returns `NAN` if either of the numbers are `NAN`.\n-    #[inline]\n-    fn min(&self, other: &f32) -> f32 {\n-        match () {\n-            _ if self.is_nan()  => *self,\n-            _ if other.is_nan() => *other,\n-            _ if *self < *other => *self,\n-            _                   => *other,\n-        }\n-    }\n-\n-    /// Returns `NAN` if either of the numbers are `NAN`.\n-    #[inline]\n-    fn max(&self, other: &f32) -> f32 {\n-        match () {\n-            _ if self.is_nan()  => *self,\n-            _ if other.is_nan() => *other,\n-            _ if *self > *other => *self,\n-            _                   => *other,\n-        }\n-    }\n-\n-    /// Returns the number constrained within the range `mn <= self <= mx`.\n-    /// If any of the numbers are `NAN` then `NAN` is returned.\n-    #[inline]\n-    fn clamp(&self, mn: &f32, mx: &f32) -> f32 {\n-        match () {\n-            _ if self.is_nan()   => *self,\n-            _ if !(*self <= *mx) => *mx,\n-            _ if !(*self >= *mn) => *mn,\n-            _                    => *self,\n-        }\n-    }\n-}\n-\n impl Default for f32 {\n     #[inline]\n     fn default() -> f32 { 0.0 }\n@@ -913,30 +877,6 @@ mod tests {\n         num::test_num(10f32, 2f32);\n     }\n \n-    #[test]\n-    fn test_min() {\n-        assert_eq!(1f32.min(&2f32), 1f32);\n-        assert_eq!(2f32.min(&1f32), 1f32);\n-    }\n-\n-    #[test]\n-    fn test_max() {\n-        assert_eq!(1f32.max(&2f32), 2f32);\n-        assert_eq!(2f32.max(&1f32), 2f32);\n-    }\n-\n-    #[test]\n-    fn test_clamp() {\n-        assert_eq!(1f32.clamp(&2f32, &4f32), 2f32);\n-        assert_eq!(8f32.clamp(&2f32, &4f32), 4f32);\n-        assert_eq!(3f32.clamp(&2f32, &4f32), 3f32);\n-\n-        let nan: f32 = Float::nan();\n-        assert!(3f32.clamp(&nan, &4f32).is_nan());\n-        assert!(3f32.clamp(&2f32, &nan).is_nan());\n-        assert!(nan.clamp(&2f32, &4f32).is_nan());\n-    }\n-\n     #[test]\n     fn test_floor() {\n         assert_approx_eq!(1.0f32.floor(), 1.0f32);"}, {"sha": "643dcc5bd4b8e701b2a0a425901c51382577e71e", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -196,42 +196,6 @@ impl Ord for f64 {\n     fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n }\n \n-impl Orderable for f64 {\n-    /// Returns `NAN` if either of the numbers are `NAN`.\n-    #[inline]\n-    fn min(&self, other: &f64) -> f64 {\n-        match () {\n-            _ if self.is_nan()  => *self,\n-            _ if other.is_nan() => *other,\n-            _ if *self < *other => *self,\n-            _                   => *other,\n-        }\n-    }\n-\n-    /// Returns `NAN` if either of the numbers are `NAN`.\n-    #[inline]\n-    fn max(&self, other: &f64) -> f64 {\n-        match () {\n-            _ if self.is_nan()  => *self,\n-            _ if other.is_nan() => *other,\n-            _ if *self > *other => *self,\n-            _                   => *other,\n-        }\n-    }\n-\n-    /// Returns the number constrained within the range `mn <= self <= mx`.\n-    /// If any of the numbers are `NAN` then `NAN` is returned.\n-    #[inline]\n-    fn clamp(&self, mn: &f64, mx: &f64) -> f64 {\n-        match () {\n-            _ if self.is_nan()   => *self,\n-            _ if !(*self <= *mx) => *mx,\n-            _ if !(*self >= *mn) => *mn,\n-            _                    => *self,\n-        }\n-    }\n-}\n-\n impl Default for f64 {\n     #[inline]\n     fn default() -> f64 { 0.0 }\n@@ -915,38 +879,6 @@ mod tests {\n         num::test_num(10f64, 2f64);\n     }\n \n-    #[test]\n-    fn test_min() {\n-        assert_eq!(1f64.min(&2f64), 1f64);\n-        assert_eq!(2f64.min(&1f64), 1f64);\n-\n-        let nan: f64 = Float::nan();\n-        assert!(1f64.min(&nan).is_nan());\n-        assert!(nan.min(&1f64).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_max() {\n-        assert_eq!(1f64.max(&2f64), 2f64);\n-        assert_eq!(2f64.max(&1f64), 2f64);\n-\n-        let nan: f64 = Float::nan();\n-        assert!(1f64.max(&nan).is_nan());\n-        assert!(nan.max(&1f64).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_clamp() {\n-        assert_eq!(1f64.clamp(&2f64, &4f64), 2f64);\n-        assert_eq!(8f64.clamp(&2f64, &4f64), 4f64);\n-        assert_eq!(3f64.clamp(&2f64, &4f64), 3f64);\n-\n-        let nan: f64 = Float::nan();\n-        assert!(3f64.clamp(&nan, &4f64).is_nan());\n-        assert!(3f64.clamp(&2f64, &nan).is_nan());\n-        assert!(nan.clamp(&2f64, &4f64).is_nan());\n-    }\n-\n     #[test]\n     fn test_floor() {\n         assert_approx_eq!(1.0f64.floor(), 1.0f64);"}, {"sha": "4965d0606115d43012a6ee42811b688a0374ac2d", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -53,24 +53,6 @@ impl Eq for $T {\n     fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n }\n \n-impl Orderable for $T {\n-    #[inline]\n-    fn min(&self, other: &$T) -> $T {\n-        if *self < *other { *self } else { *other }\n-    }\n-\n-    #[inline]\n-    fn max(&self, other: &$T) -> $T {\n-        if *self > *other { *self } else { *other }\n-    }\n-\n-    #[inline]\n-    fn clamp(&self, mn: &$T, mx: &$T) -> $T {\n-        if *self > *mx { *mx } else\n-        if *self < *mn { *mn } else { *self }\n-    }\n-}\n-\n impl Default for $T {\n     #[inline]\n     fn default() -> $T { 0 }\n@@ -457,17 +439,6 @@ mod tests {\n         num::test_num(10 as $T, 2 as $T);\n     }\n \n-    #[test]\n-    fn test_orderable() {\n-        assert_eq!((1 as $T).min(&(2 as $T)), 1 as $T);\n-        assert_eq!((2 as $T).min(&(1 as $T)), 1 as $T);\n-        assert_eq!((1 as $T).max(&(2 as $T)), 2 as $T);\n-        assert_eq!((2 as $T).max(&(1 as $T)), 2 as $T);\n-        assert_eq!((1 as $T).clamp(&(2 as $T), &(4 as $T)), 2 as $T);\n-        assert_eq!((8 as $T).clamp(&(2 as $T), &(4 as $T)), 4 as $T);\n-        assert_eq!((3 as $T).clamp(&(2 as $T), &(4 as $T)), 3 as $T);\n-    }\n-\n     #[test]\n     pub fn test_abs() {\n         assert_eq!((1 as $T).abs(), 1 as $T);"}, {"sha": "c5510078e39513c9b9e9b673c820fa4149db457f", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -33,23 +33,6 @@ pub trait Num: Eq + Zero + One\n              + Div<Self,Self>\n              + Rem<Self,Self> {}\n \n-pub trait Orderable: Ord {\n-    // These should be methods on `Ord`, with overridable default implementations. We don't want\n-    // to encumber all implementors of Ord by requiring them to implement these functions, but at\n-    // the same time we want to be able to take advantage of the speed of the specific numeric\n-    // functions (like the `fmin` and `fmax` intrinsics).\n-    fn min(&self, other: &Self) -> Self;\n-    fn max(&self, other: &Self) -> Self;\n-    fn clamp(&self, mn: &Self, mx: &Self) -> Self;\n-}\n-\n-/// Return the smaller number.\n-#[inline(always)] pub fn min<T: Orderable>(x: T, y: T) -> T { x.min(&y) }\n-/// Return the larger number.\n-#[inline(always)] pub fn max<T: Orderable>(x: T, y: T) -> T { x.max(&y) }\n-/// Returns the number constrained within the range `mn <= self <= mx`.\n-#[inline(always)] pub fn clamp<T: Orderable>(value: T, mn: T, mx: T) -> T { value.clamp(&mn, &mx) }\n-\n /// Defines an additive identity element for `Self`.\n ///\n /// # Deriving\n@@ -140,7 +123,7 @@ pub trait Signed: Num\n pub trait Unsigned: Num {}\n \n pub trait Integer: Num\n-                 + Orderable\n+                 + Ord\n                  + Div<Self,Self>\n                  + Rem<Self,Self> {\n     fn div_rem(&self, other: &Self) -> (Self,Self);\n@@ -185,7 +168,7 @@ pub trait Round {\n \n /// Defines constants and methods common to real numbers\n pub trait Real: Signed\n-              + Orderable\n+              + Ord\n               + Round\n               + Div<Self,Self> {\n     // Common Constants\n@@ -434,7 +417,7 @@ pub trait Primitive: Clone\n                    + DeepClone\n                    + Num\n                    + NumCast\n-                   + Orderable\n+                   + Ord\n                    + Bounded {}\n \n /// A collection of traits relevant to primitive signed and unsigned integers"}, {"sha": "bbf1c497c2be556535fbccce9457cea0ab606d96", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -44,28 +44,6 @@ impl Eq for $T {\n     fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n }\n \n-impl Orderable for $T {\n-    #[inline]\n-    fn min(&self, other: &$T) -> $T {\n-        if *self < *other { *self } else { *other }\n-    }\n-\n-    #[inline]\n-    fn max(&self, other: &$T) -> $T {\n-        if *self > *other { *self } else { *other }\n-    }\n-\n-    /// Returns the number constrained within the range `mn <= self <= mx`.\n-    #[inline]\n-    fn clamp(&self, mn: &$T, mx: &$T) -> $T {\n-        match () {\n-            _ if (*self > *mx) => *mx,\n-            _ if (*self < *mn) => *mn,\n-            _                  => *self,\n-        }\n-    }\n-}\n-\n impl Default for $T {\n     #[inline]\n     fn default() -> $T { 0 }\n@@ -329,17 +307,6 @@ mod tests {\n         num::test_num(10 as $T, 2 as $T);\n     }\n \n-    #[test]\n-    fn test_orderable() {\n-        assert_eq!((1 as $T).min(&(2 as $T)), 1 as $T);\n-        assert_eq!((2 as $T).min(&(1 as $T)), 1 as $T);\n-        assert_eq!((1 as $T).max(&(2 as $T)), 2 as $T);\n-        assert_eq!((2 as $T).max(&(1 as $T)), 2 as $T);\n-        assert_eq!((1 as $T).clamp(&(2 as $T), &(4 as $T)), 2 as $T);\n-        assert_eq!((8 as $T).clamp(&(2 as $T), &(4 as $T)), 4 as $T);\n-        assert_eq!((3 as $T).clamp(&(2 as $T), &(4 as $T)), 3 as $T);\n-    }\n-\n     #[test]\n     fn test_div_mod_floor() {\n         assert_eq!((10 as $T).div_floor(&(3 as $T)), 3 as $T);"}, {"sha": "3eaa1db87bafdc7464f06231190df99b4372fc30", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -59,7 +59,7 @@ pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n pub use num::{Integer, Real, Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n-pub use num::{Orderable, Signed, Unsigned, Round};\n+pub use num::{Signed, Unsigned, Round};\n pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;"}, {"sha": "56f690f0e2b83a7c3eed697af79c74a535f6f974", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -18,10 +18,10 @@ use visit::Visitor;\n use visit;\n \n use std::cell::{Cell, RefCell};\n+use std::cmp;\n use std::hashmap::HashMap;\n use std::u32;\n use std::local_data;\n-use std::num;\n \n pub fn path_name_i(idents: &[Ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n@@ -343,8 +343,8 @@ impl IdRange {\n     }\n \n     pub fn add(&mut self, id: NodeId) {\n-        self.min = num::min(self.min, id);\n-        self.max = num::max(self.max, id + 1);\n+        self.min = cmp::min(self.min, id);\n+        self.max = cmp::max(self.max, id + 1);\n     }\n }\n "}, {"sha": "12e78629386259b6de999fefe65c8ab684aae366", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -16,7 +16,7 @@\n \n use std::io;\n use std::io::{BufferedWriter, File};\n-use std::num::min;\n+use std::cmp::min;\n use std::os;\n \n static LINE_LENGTH: uint = 60;"}, {"sha": "a6e6713e137b11d47fba1b67b4aad51a72e87eaa", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68129d299b54806b6aa4ec9f3a0755854db7b491/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=68129d299b54806b6aa4ec9f3a0755854db7b491", "patch": "@@ -14,7 +14,7 @@ extern mod sync;\n \n use std::from_str::FromStr;\n use std::iter::count;\n-use std::num::min;\n+use std::cmp::min;\n use std::os;\n use std::vec::from_elem;\n use sync::Arc;"}]}