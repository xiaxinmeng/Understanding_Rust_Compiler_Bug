{"sha": "3eddda6f4c581383a8ead83d4731e888acb1c957", "node_id": "C_kwDOAAsO6NoAKDNlZGRkYTZmNGM1ODEzODNhOGVhZDgzZDQ3MzFlODg4YWNiMWM5NTc", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-01-05T16:26:34Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-01-05T16:26:34Z"}, "message": "simplify", "tree": {"sha": "e408a1578a734057b0bb47eefbd105debe725c95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e408a1578a734057b0bb47eefbd105debe725c95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3eddda6f4c581383a8ead83d4731e888acb1c957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3eddda6f4c581383a8ead83d4731e888acb1c957", "html_url": "https://github.com/rust-lang/rust/commit/3eddda6f4c581383a8ead83d4731e888acb1c957", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3eddda6f4c581383a8ead83d4731e888acb1c957/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5049bdcdaefd7650a58fa9f393ad7351e5c5462", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5049bdcdaefd7650a58fa9f393ad7351e5c5462", "html_url": "https://github.com/rust-lang/rust/commit/c5049bdcdaefd7650a58fa9f393ad7351e5c5462"}], "stats": {"total": 91, "additions": 43, "deletions": 48}, "files": [{"sha": "730523252cf670fd28661b16f5097e44e527cd30", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3eddda6f4c581383a8ead83d4731e888acb1c957/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eddda6f4c581383a8ead83d4731e888acb1c957/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=3eddda6f4c581383a8ead83d4731e888acb1c957", "patch": "@@ -781,12 +781,10 @@ fn attr_macro_as_call_id(\n     macro_attr: &Attr,\n     db: &dyn db::DefDatabase,\n     krate: CrateId,\n-    def: Option<MacroDefId>,\n-) -> Result<MacroCallId, UnresolvedMacro> {\n+    def: MacroDefId,\n+) -> MacroCallId {\n     let attr_path = &item_attr.path;\n-    let def = def.ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n-    let last_segment =\n-        attr_path.segments().last().ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n+    let last_segment = attr_path.segments().last().expect(\"empty attribute path\");\n     let mut arg = match macro_attr.input.as_deref() {\n         Some(attr::AttrInput::TokenTree(tt, map)) => (tt.clone(), map.clone()),\n         _ => Default::default(),\n@@ -805,5 +803,5 @@ fn attr_macro_as_call_id(\n             invoc_attr_index: macro_attr.id.ast_index,\n         },\n     );\n-    Ok(res)\n+    res\n }"}, {"sha": "da774bd0466b173ca20eb6d3152301057917f4ff", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3eddda6f4c581383a8ead83d4731e888acb1c957/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eddda6f4c581383a8ead83d4731e888acb1c957/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=3eddda6f4c581383a8ead83d4731e888acb1c957", "patch": "@@ -1124,10 +1124,13 @@ impl DefCollector<'_> {\n                         }\n                     }\n \n-                    let def = resolver(path.clone()).filter(MacroDefId::is_attribute);\n+                    let def = match resolver(path.clone()) {\n+                        Some(def) if def.is_attribute() => def,\n+                        _ => return true,\n+                    };\n                     if matches!(\n                         def,\n-                        Some(MacroDefId {  kind:MacroDefKind::BuiltInAttr(expander, _),.. })\n+                        MacroDefId {  kind:MacroDefKind::BuiltInAttr(expander, _),.. }\n                         if expander.is_derive()\n                     ) {\n                         // Resolved to `#[derive]`\n@@ -1184,52 +1187,46 @@ impl DefCollector<'_> {\n                         return true;\n                     }\n \n-                    // Not resolved to a derive helper or the derive attribute, so try to resolve as a normal attribute.\n-                    match attr_macro_as_call_id(file_ast_id, attr, self.db, self.def_map.krate, def)\n-                    {\n-                        Ok(call_id) => {\n-                            let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n-\n-                            // Skip #[test]/#[bench] expansion, which would merely result in more memory usage\n-                            // due to duplicating functions into macro expansions\n-                            if matches!(\n-                                loc.def.kind,\n-                                MacroDefKind::BuiltInAttr(expander, _)\n-                                if expander.is_test() || expander.is_bench()\n-                            ) {\n-                                return recollect_without(self);\n-                            }\n-\n-                            if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n-                                if exp.is_dummy() {\n-                                    // Proc macros that cannot be expanded are treated as not\n-                                    // resolved, in order to fall back later.\n-                                    self.def_map.diagnostics.push(\n-                                        DefDiagnostic::unresolved_proc_macro(\n-                                            directive.module_id,\n-                                            loc.kind,\n-                                        ),\n-                                    );\n-\n-                                    return recollect_without(self);\n-                                }\n-                            }\n+                    // Not resolved to a derive helper or the derive attribute, so try to treat as a normal attribute.\n+                    let call_id =\n+                        attr_macro_as_call_id(file_ast_id, attr, self.db, self.def_map.krate, def);\n+                    let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n \n-                            self.def_map.modules[directive.module_id]\n-                                .scope\n-                                .add_attr_macro_invoc(ast_id, call_id);\n+                    // Skip #[test]/#[bench] expansion, which would merely result in more memory usage\n+                    // due to duplicating functions into macro expansions\n+                    if matches!(\n+                        loc.def.kind,\n+                        MacroDefKind::BuiltInAttr(expander, _)\n+                        if expander.is_test() || expander.is_bench()\n+                    ) {\n+                        return recollect_without(self);\n+                    }\n \n-                            resolved.push((\n+                    if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n+                        if exp.is_dummy() {\n+                            // Proc macros that cannot be expanded are treated as not\n+                            // resolved, in order to fall back later.\n+                            self.def_map.diagnostics.push(DefDiagnostic::unresolved_proc_macro(\n                                 directive.module_id,\n-                                call_id,\n-                                directive.depth,\n-                                directive.container,\n+                                loc.kind,\n                             ));\n-                            res = ReachedFixedPoint::No;\n-                            return false;\n+\n+                            return recollect_without(self);\n                         }\n-                        Err(UnresolvedMacro { .. }) => (),\n                     }\n+\n+                    self.def_map.modules[directive.module_id]\n+                        .scope\n+                        .add_attr_macro_invoc(ast_id, call_id);\n+\n+                    resolved.push((\n+                        directive.module_id,\n+                        call_id,\n+                        directive.depth,\n+                        directive.container,\n+                    ));\n+                    res = ReachedFixedPoint::No;\n+                    return false;\n                 }\n             }\n "}]}