{"sha": "ade310cbb6e949b27285ca592e34371c1cc6677f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZTMxMGNiYjZlOTQ5YjI3Mjg1Y2E1OTJlMzQzNzFjMWNjNjY3N2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-14T21:01:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-14T21:01:35Z"}, "message": "auto merge of #10018 : fhahn/rust/check-inferred-ints, r=alexcrichton\n\nI've started working on this issue and pushed a small commit, which adds a range check for integer literals in `middle::const_eval` (no `uint` at the moment) \r\nAt the moment, this patch is just a proof of concept, I'm not sure if there is a better function for the checks in `middle::const_eval`. This patch does not check for overflows after constant folding, eg:\r\n\r\n    let x: i8 = 99 + 99;", "tree": {"sha": "179f19735600c04427f28df62bd9d786abd4c6ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/179f19735600c04427f28df62bd9d786abd4c6ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ade310cbb6e949b27285ca592e34371c1cc6677f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ade310cbb6e949b27285ca592e34371c1cc6677f", "html_url": "https://github.com/rust-lang/rust/commit/ade310cbb6e949b27285ca592e34371c1cc6677f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ade310cbb6e949b27285ca592e34371c1cc6677f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d11935bf6ae3e784aefb1c359a70fea5dfd3d00", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d11935bf6ae3e784aefb1c359a70fea5dfd3d00", "html_url": "https://github.com/rust-lang/rust/commit/0d11935bf6ae3e784aefb1c359a70fea5dfd3d00"}, {"sha": "20627c7430afd700cf0b462c372d9086c7c51f0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/20627c7430afd700cf0b462c372d9086c7c51f0a", "html_url": "https://github.com/rust-lang/rust/commit/20627c7430afd700cf0b462c372d9086c7c51f0a"}], "stats": {"total": 147, "additions": 126, "deletions": 21}, "files": [{"sha": "9cea63f0d0b5d36ac5fd344ddfa0f85bfac5a62a", "filename": "doc/po/ja/tutorial-tasks.md.po", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ade310cbb6e949b27285ca592e34371c1cc6677f/doc%2Fpo%2Fja%2Ftutorial-tasks.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/ade310cbb6e949b27285ca592e34371c1cc6677f/doc%2Fpo%2Fja%2Ftutorial-tasks.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial-tasks.md.po?ref=ade310cbb6e949b27285ca592e34371c1cc6677f", "patch": "@@ -529,7 +529,7 @@ msgid \"\"\n \"The basic example below illustrates this.\\n\"\n \"~~~\\n\"\n \"# fn make_a_sandwich() {};\\n\"\n-\"fn fib(n: uint) -> uint {\\n\"\n+\"fn fib(n: u64) -> u64 {\\n\"\n \"    // lengthy computation returning an uint\\n\"\n \"    12586269025\\n\"\n \"}\\n\""}, {"sha": "483cde9d7d016cd0824f86679027ab8dd22704f0", "filename": "doc/po/tutorial-tasks.md.pot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ade310cbb6e949b27285ca592e34371c1cc6677f/doc%2Fpo%2Ftutorial-tasks.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/ade310cbb6e949b27285ca592e34371c1cc6677f/doc%2Fpo%2Ftutorial-tasks.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-tasks.md.pot?ref=ade310cbb6e949b27285ca592e34371c1cc6677f", "patch": "@@ -529,7 +529,7 @@ msgid \"\"\n \"The basic example below illustrates this.\\n\"\n \"~~~\\n\"\n \"# fn make_a_sandwich() {};\\n\"\n-\"fn fib(n: uint) -> uint {\\n\"\n+\"fn fib(n: u64) -> u64 {\\n\"\n \"    // lengthy computation returning an uint\\n\"\n \"    12586269025\\n\"\n \"}\\n\""}, {"sha": "adde4ab17e62699e62f01af5b19e91e466d6f104", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ade310cbb6e949b27285ca592e34371c1cc6677f/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/ade310cbb6e949b27285ca592e34371c1cc6677f/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=ade310cbb6e949b27285ca592e34371c1cc6677f", "patch": "@@ -273,7 +273,7 @@ later.\n The basic example below illustrates this.\n ~~~\n # fn make_a_sandwich() {};\n-fn fib(n: uint) -> uint {\n+fn fib(n: u64) -> u64 {\n     // lengthy computation returning an uint\n     12586269025\n }"}, {"sha": "5f84f505b5ceec3fe87da6db85eb7cc3ccb8fc8d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ade310cbb6e949b27285ca592e34371c1cc6677f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade310cbb6e949b27285ca592e34371c1cc6677f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=ade310cbb6e949b27285ca592e34371c1cc6677f", "patch": "@@ -199,21 +199,6 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n           }\n         }\n     }\n-    match e.node {\n-        ExprLit(@codemap::Spanned {node: lit_int(v, t), _}) => {\n-            if (v as u64) > ast_util::int_ty_max(\n-                if t == ty_i { sess.targ_cfg.int_type } else { t }) {\n-                sess.span_err(e.span, \"literal out of range for its type\");\n-            }\n-        }\n-        ExprLit(@codemap::Spanned {node: lit_uint(v, t), _}) => {\n-            if v > ast_util::uint_ty_max(\n-                if t == ty_u { sess.targ_cfg.uint_type } else { t }) {\n-                sess.span_err(e.span, \"literal out of range for its type\");\n-            }\n-        }\n-        _ => ()\n-    }\n     visit::walk_expr(v, e, is_const);\n }\n "}, {"sha": "bc6cc00b786fd854c65554166f3bca76c84c604e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ade310cbb6e949b27285ca592e34371c1cc6677f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade310cbb6e949b27285ca592e34371c1cc6677f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=ade310cbb6e949b27285ca592e34371c1cc6677f", "patch": "@@ -73,6 +73,7 @@ pub enum lint {\n     non_uppercase_statics,\n     non_uppercase_pattern_statics,\n     type_limits,\n+    type_overflow,\n     unused_unsafe,\n \n     managed_heap_memory,\n@@ -220,6 +221,14 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n      }),\n \n+    (\"type_overflow\",\n+     LintSpec {\n+        lint: type_overflow,\n+        desc: \"literal out of range for its type\",\n+        default: warn\n+     }),\n+\n+\n     (\"unused_unsafe\",\n      LintSpec {\n         lint: unused_unsafe,\n@@ -329,6 +338,9 @@ struct Context<'self> {\n     // levels, this stack keeps track of the previous lint levels of whatever\n     // was modified.\n     lint_stack: ~[(lint, level, LintSource)],\n+\n+    // id of the last visited negated expression\n+    negated_expr_id: ast::NodeId\n }\n \n impl<'self> Context<'self> {\n@@ -522,7 +534,48 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n                 cx.span_lint(type_limits, e.span,\n                              \"comparison is useless due to type limits\");\n             }\n-        }\n+        },\n+        ast::ExprLit(lit) => {\n+            match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n+                ty::ty_int(t) => {\n+                    let int_type = if t == ast::ty_i {\n+                        cx.tcx.sess.targ_cfg.int_type\n+                    } else { t };\n+                    let (min, max) = int_ty_range(int_type);\n+                    let mut lit_val: i64 = match lit.node {\n+                        ast::lit_int(v, _) => v,\n+                        ast::lit_uint(v, _) => v as i64,\n+                        ast::lit_int_unsuffixed(v) => v,\n+                        _ => fail!()\n+                    };\n+                    if cx.negated_expr_id == e.id {\n+                        lit_val *= -1;\n+                    }\n+                    if  lit_val < min || lit_val > max {\n+                        cx.span_lint(type_overflow, e.span,\n+                                     \"literal out of range for its type\");\n+                    }\n+                },\n+                ty::ty_uint(t) => {\n+                    let uint_type = if t == ast::ty_u {\n+                        cx.tcx.sess.targ_cfg.uint_type\n+                    } else { t };\n+                    let (min, max) = uint_ty_range(uint_type);\n+                    let lit_val: u64 = match lit.node {\n+                        ast::lit_int(v, _) => v as u64,\n+                        ast::lit_uint(v, _) => v,\n+                        ast::lit_int_unsuffixed(v) => v as u64,\n+                        _ => fail!()\n+                    };\n+                    if  lit_val < min || lit_val > max {\n+                        cx.span_lint(type_overflow, e.span,\n+                                     \"literal out of range for its type\");\n+                    }\n+                },\n+\n+                _ => ()\n+            };\n+        },\n         _ => ()\n     };\n \n@@ -1052,11 +1105,25 @@ impl<'self> Visitor<()> for Context<'self> {\n     }\n \n     fn visit_expr(&mut self, e: @ast::Expr, _: ()) {\n+        match e.node {\n+            ast::ExprUnary(_, ast::UnNeg, expr) => {\n+                // propagate negation, if the negation itself isn't negated\n+                if self.negated_expr_id != e.id {\n+                    self.negated_expr_id = expr.id;\n+                }\n+            },\n+            ast::ExprParen(expr) => if self.negated_expr_id == e.id {\n+                self.negated_expr_id = expr.id\n+            },\n+            _ => ()\n+        };\n+\n         check_while_true_expr(self, e);\n         check_stability(self, e);\n         check_unused_unsafe(self, e);\n         check_unnecessary_allocation(self, e);\n         check_heap_expr(self, e);\n+\n         check_type_limits(self, e);\n \n         visit::walk_expr(self, e, ());\n@@ -1150,6 +1217,7 @@ pub fn check_crate(tcx: ty::ctxt,\n         cur_struct_def_id: -1,\n         is_doc_hidden: false,\n         lint_stack: ~[],\n+        negated_expr_id: -1\n     };\n \n     // Install default lint levels, followed by the command line levels, and"}, {"sha": "08714e3a044b45733ae31184809b03e133b910c0", "filename": "src/test/compile-fail/lint-type-limits.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ade310cbb6e949b27285ca592e34371c1cc6677f/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade310cbb6e949b27285ca592e34371c1cc6677f/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs?ref=ade310cbb6e949b27285ca592e34371c1cc6677f", "patch": "@@ -24,11 +24,13 @@ fn bar() -> i8 {\n \n fn baz() -> bool {\n     128 > bar() //~ ERROR comparison is useless due to type limits\n+                //~^ WARNING literal out of range for its type\n }\n \n fn qux() {\n     let mut i = 1i8;\n     while 200 != i { //~ ERROR comparison is useless due to type limits\n+                     //~^ WARNING literal out of range for its type\n         i += 1;\n     }\n }"}, {"sha": "27cd2bae125c8187ec0e967b41de310e734b4f4d", "filename": "src/test/compile-fail/lint-type-overflow.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ade310cbb6e949b27285ca592e34371c1cc6677f/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade310cbb6e949b27285ca592e34371c1cc6677f/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs?ref=ade310cbb6e949b27285ca592e34371c1cc6677f", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+\n+#[deny(type_overflow)];\n+\n+fn test(x: i8) {\n+    println!(\"x {}\", x);\n+}\n+\n+#[allow(unused_variable)]\n+fn main() {\n+    let x1: u8 = 255; // should be OK\n+    let x1: u8 = 256; //~ error: literal out of range for its type\n+\n+    let x1 = 255_u8; // should be OK\n+    let x1 = 256_u8; //~ error: literal out of range for its type\n+\n+    let x2: i8 = -128; // should be OK\n+    let x1: i8 = 128; //~ error: literal out of range for its type\n+    let x2: i8 = --128; //~ error: literal out of range for its type\n+\n+    let x3: i8 = -129; //~ error: literal out of range for its type\n+    let x3: i8 = -(129); //~ error: literal out of range for its type\n+    let x3: i8 = -{129}; //~ error: literal out of range for its type\n+\n+    test(1000); //~ error: literal out of range for its type\n+\n+    let x = 128_i8; //~ error: literal out of range for its type\n+    let x = 127_i8; \n+    let x = -128_i8; \n+    let x = -(128_i8); \n+    let x = -129_i8; //~ error: literal out of range for its type\n+\n+    let x: i32 = 2147483647; // should be OK\n+    let x = 2147483647_i32; // should be OK\n+    let x: i32 = 2147483648; //~ error: literal out of range for its type\n+    let x = 2147483648_i32; //~ error: literal out of range for its type\n+    let x: i32 = -2147483648; // should be OK\n+    let x = -2147483648_i32; // should be OK\n+    let x: i32 = -2147483649; //~ error: literal out of range for its type\n+    let x = -2147483649_i32; //~ error: literal out of range for its type\n+}"}, {"sha": "1c4316672f3fb1ed4f4b573ef7725cc4369e7090", "filename": "src/test/compile-fail/oversized-literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ade310cbb6e949b27285ca592e34371c1cc6677f/src%2Ftest%2Fcompile-fail%2Foversized-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade310cbb6e949b27285ca592e34371c1cc6677f/src%2Ftest%2Fcompile-fail%2Foversized-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foversized-literal.rs?ref=ade310cbb6e949b27285ca592e34371c1cc6677f", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:literal out of range\n+// compile-flags: -D type-overflow\n \n-fn main() { info!(\"{}\", 300u8); }\n+fn main() { info!(\"{}\", 300u8); } //~ error: literal out of range for its type"}]}