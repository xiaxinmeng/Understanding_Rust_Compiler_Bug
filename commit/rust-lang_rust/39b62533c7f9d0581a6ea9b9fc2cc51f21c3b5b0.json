{"sha": "39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YjYyNTMzYzdmOWQwNTgxYTZlYTliOWZjMmNjNTFmMjFjM2I1YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-07T07:12:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-07T07:12:51Z"}, "message": "Auto merge of #70837 - nnethercote:speed-up-find_library_crate, r=petrochenkov\n\nSpeed up path searching with `find_library_crate`.\n\nBy doing prefix and suffix checking on a `String` copy of each relevant\n`PathBuf`, rather than the `PathBuf` itself.", "tree": {"sha": "5a86e732ade9cf5a8e428821cf7679dabf3219e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a86e732ade9cf5a8e428821cf7679dabf3219e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "html_url": "https://github.com/rust-lang/rust/commit/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "209b2be09fcaff937480d1fbbe8b31646e361c7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/209b2be09fcaff937480d1fbbe8b31646e361c7a", "html_url": "https://github.com/rust-lang/rust/commit/209b2be09fcaff937480d1fbbe8b31646e361c7a"}, {"sha": "a932616cf1426484f4a530ef6d2d654b7d1accaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a932616cf1426484f4a530ef6d2d654b7d1accaf", "html_url": "https://github.com/rust-lang/rust/commit/a932616cf1426484f4a530ef6d2d654b7d1accaf"}], "stats": {"total": 66, "additions": 45, "deletions": 21}, "files": [{"sha": "fc63cfd143eb38ebb70f4be280c2eca0cad846d2", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "patch": "@@ -543,8 +543,8 @@ impl<'a> CrateLocator<'a> {\n         // of the crate id (path/name/id).\n         //\n         // The goal of this step is to look at as little metadata as possible.\n-        self.filesearch.search(|path, kind| {\n-            let file = match path.file_name().and_then(|s| s.to_str()) {\n+        self.filesearch.search(|spf, kind| {\n+            let file = match &spf.file_name_str {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n@@ -556,20 +556,18 @@ impl<'a> CrateLocator<'a> {\n                 (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], CrateFlavor::Dylib)\n             } else {\n                 if file.starts_with(&staticlib_prefix) && file.ends_with(&staticpair.1) {\n-                    staticlibs.push(CrateMismatch {\n-                        path: path.to_path_buf(),\n-                        got: \"static\".to_string(),\n-                    });\n+                    staticlibs\n+                        .push(CrateMismatch { path: spf.path.clone(), got: \"static\".to_string() });\n                 }\n                 return FileDoesntMatch;\n             };\n \n-            info!(\"lib candidate: {}\", path.display());\n+            info!(\"lib candidate: {}\", spf.path.display());\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str).or_default();\n             let (ref mut rlibs, ref mut rmetas, ref mut dylibs) = *slot;\n-            fs::canonicalize(path)\n+            fs::canonicalize(&spf.path)\n                 .map(|p| {\n                     if seen_paths.contains(&p) {\n                         return FileDoesntMatch;"}, {"sha": "e98746231fb307e0510d2bb601dc243074df66b6", "filename": "src/librustc_session/filesearch.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0/src%2Flibrustc_session%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0/src%2Flibrustc_session%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Ffilesearch.rs?ref=39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "patch": "@@ -7,7 +7,7 @@ use std::env;\n use std::fs;\n use std::path::{Path, PathBuf};\n \n-use crate::search_paths::{PathKind, SearchPath};\n+use crate::search_paths::{PathKind, SearchPath, SearchPathFile};\n use log::debug;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n \n@@ -43,28 +43,28 @@ impl<'a> FileSearch<'a> {\n \n     pub fn search<F>(&self, mut pick: F)\n     where\n-        F: FnMut(&Path, PathKind) -> FileMatch,\n+        F: FnMut(&SearchPathFile, PathKind) -> FileMatch,\n     {\n         for search_path in self.search_paths() {\n             debug!(\"searching {}\", search_path.dir.display());\n-            fn is_rlib(p: &Path) -> bool {\n-                p.extension() == Some(\"rlib\".as_ref())\n+            fn is_rlib(spf: &SearchPathFile) -> bool {\n+                if let Some(f) = &spf.file_name_str { f.ends_with(\".rlib\") } else { false }\n             }\n             // Reading metadata out of rlibs is faster, and if we find both\n             // an rlib and a dylib we only read one of the files of\n             // metadata, so in the name of speed, bring all rlib files to\n             // the front of the search list.\n-            let files1 = search_path.files.iter().filter(|p| is_rlib(p));\n-            let files2 = search_path.files.iter().filter(|p| !is_rlib(p));\n-            for path in files1.chain(files2) {\n-                debug!(\"testing {}\", path.display());\n-                let maybe_picked = pick(path, search_path.kind);\n+            let files1 = search_path.files.iter().filter(|spf| is_rlib(&spf));\n+            let files2 = search_path.files.iter().filter(|spf| !is_rlib(&spf));\n+            for spf in files1.chain(files2) {\n+                debug!(\"testing {}\", spf.path.display());\n+                let maybe_picked = pick(spf, search_path.kind);\n                 match maybe_picked {\n                     FileMatches => {\n-                        debug!(\"picked {}\", path.display());\n+                        debug!(\"picked {}\", spf.path.display());\n                     }\n                     FileDoesntMatch => {\n-                        debug!(\"rejected {}\", path.display());\n+                        debug!(\"rejected {}\", spf.path.display());\n                     }\n                 }\n             }"}, {"sha": "4ff06acaa1fd4eedcb7fc5799599a465673c04f6", "filename": "src/librustc_session/search_paths.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0/src%2Flibrustc_session%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0/src%2Flibrustc_session%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsearch_paths.rs?ref=39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "patch": "@@ -6,7 +6,31 @@ use std::path::{Path, PathBuf};\n pub struct SearchPath {\n     pub kind: PathKind,\n     pub dir: PathBuf,\n-    pub files: Vec<PathBuf>,\n+    pub files: Vec<SearchPathFile>,\n+}\n+\n+// The obvious implementation of `SearchPath::files` is a `Vec<PathBuf>`. But\n+// it is searched repeatedly by `find_library_crate`, and the searches involve\n+// checking the prefix and suffix of the filename of each `PathBuf`. This is\n+// doable, but very slow, because it involves calls to `file_name` and\n+// `extension` that are themselves slow.\n+//\n+// This type augments the `PathBuf` with an `Option<String>` containing the\n+// `PathBuf`'s filename. The prefix and suffix checking is much faster on the\n+// `Option<String>` than the `PathBuf`. (It's an `Option` because\n+// `Path::file_name` can fail; if that happens then all subsequent checking\n+// will also fail, which is fine.)\n+#[derive(Clone, Debug)]\n+pub struct SearchPathFile {\n+    pub path: PathBuf,\n+    pub file_name_str: Option<String>,\n+}\n+\n+impl SearchPathFile {\n+    fn new(path: PathBuf) -> SearchPathFile {\n+        let file_name_str = path.file_name().and_then(|f| f.to_str()).map(|s| s.to_string());\n+        SearchPathFile { path, file_name_str }\n+    }\n }\n \n #[derive(PartialEq, Clone, Copy, Debug, Hash, Eq, RustcEncodable, RustcDecodable)]\n@@ -60,7 +84,9 @@ impl SearchPath {\n     fn new(kind: PathKind, dir: PathBuf) -> Self {\n         // Get the files within the directory.\n         let files = match std::fs::read_dir(&dir) {\n-            Ok(files) => files.filter_map(|p| p.ok().map(|s| s.path())).collect::<Vec<_>>(),\n+            Ok(files) => files\n+                .filter_map(|e| e.ok().map(|e| SearchPathFile::new(e.path())))\n+                .collect::<Vec<_>>(),\n             Err(..) => vec![],\n         };\n "}]}