{"sha": "94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "node_id": "C_kwDOAAsO6NoAKDk0ZGM3YTNlYjA5MmI1ZWE2NDFhNGQzNDRmYWU1ZjNhZDQxNTg4NTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-04T19:01:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-04T19:01:47Z"}, "message": "Auto merge of #14251 - Veykril:ty-expr-stmt, r=Veykril\n\ninternal: Set expectation for no-semi expression statements to unit", "tree": {"sha": "8ccb40f4bce95305216083e84c05edf1c49f3c4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ccb40f4bce95305216083e84c05edf1c49f3c4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "html_url": "https://github.com/rust-lang/rust/commit/94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5efcfe5ca983afea02b81c3e413d9064b013c514", "url": "https://api.github.com/repos/rust-lang/rust/commits/5efcfe5ca983afea02b81c3e413d9064b013c514", "html_url": "https://github.com/rust-lang/rust/commit/5efcfe5ca983afea02b81c3e413d9064b013c514"}, {"sha": "b85e2af898546f9c7a7b58b02b43ba0ae0c948c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b85e2af898546f9c7a7b58b02b43ba0ae0c948c9", "html_url": "https://github.com/rust-lang/rust/commit/b85e2af898546f9c7a7b58b02b43ba0ae0c948c9"}], "stats": {"total": 682, "additions": 394, "deletions": 288}, "files": [{"sha": "3164a5f4c290680d9467f949613d0a202f75b3aa", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -37,7 +37,7 @@ use crate::{\n     item_scope::BuiltinShadowMode,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n-    AdtId, BlockLoc, ModuleDefId, UnresolvedMacro,\n+    AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n };\n \n pub struct LowerCtx<'a> {\n@@ -238,33 +238,32 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::BlockExpr(e) => match e.modifier() {\n                 Some(ast::BlockModifier::Try(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n+                    self.collect_block_(e, |id, statements, tail| Expr::TryBlock {\n+                        id,\n+                        statements,\n+                        tail,\n+                    })\n                 }\n                 Some(ast::BlockModifier::Unsafe(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::Unsafe { body }, syntax_ptr)\n+                    self.collect_block_(e, |id, statements, tail| Expr::Unsafe {\n+                        id,\n+                        statements,\n+                        tail,\n+                    })\n                 }\n-                // FIXME: we need to record these effects somewhere...\n                 Some(ast::BlockModifier::Label(label)) => {\n                     let label = self.collect_label(label);\n-                    let res = self.collect_block(e);\n-                    match &mut self.body.exprs[res] {\n-                        Expr::Block { label: block_label, .. } => {\n-                            *block_label = Some(label);\n-                        }\n-                        _ => unreachable!(),\n-                    }\n-                    res\n-                }\n-                Some(ast::BlockModifier::Async(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::Async { body }, syntax_ptr)\n-                }\n-                Some(ast::BlockModifier::Const(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::Const { body }, syntax_ptr)\n+                    self.collect_block_(e, |id, statements, tail| Expr::Block {\n+                        id,\n+                        statements,\n+                        tail,\n+                        label: Some(label),\n+                    })\n                 }\n+                Some(ast::BlockModifier::Async(_)) => self\n+                    .collect_block_(e, |id, statements, tail| Expr::Async { id, statements, tail }),\n+                Some(ast::BlockModifier::Const(_)) => self\n+                    .collect_block_(e, |id, statements, tail| Expr::Const { id, statements, tail }),\n                 None => self.collect_block(e),\n             },\n             ast::Expr::LoopExpr(e) => {\n@@ -737,6 +736,19 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n+        self.collect_block_(block, |id, statements, tail| Expr::Block {\n+            id,\n+            statements,\n+            tail,\n+            label: None,\n+        })\n+    }\n+\n+    fn collect_block_(\n+        &mut self,\n+        block: ast::BlockExpr,\n+        mk_block: impl FnOnce(BlockId, Box<[Statement]>, Option<ExprId>) -> Expr,\n+    ) -> ExprId {\n         let file_local_id = self.ast_id_map.ast_id(&block);\n         let ast_id = AstId::new(self.expander.current_file_id, file_local_id);\n         let block_loc =\n@@ -769,15 +781,8 @@ impl ExprCollector<'_> {\n         });\n \n         let syntax_node_ptr = AstPtr::new(&block.into());\n-        let expr_id = self.alloc_expr(\n-            Expr::Block {\n-                id: block_id,\n-                statements: statements.into_boxed_slice(),\n-                tail,\n-                label: None,\n-            },\n-            syntax_node_ptr,\n-        );\n+        let expr_id = self\n+            .alloc_expr(mk_block(block_id, statements.into_boxed_slice(), tail), syntax_node_ptr);\n \n         self.expander.def_map = prev_def_map;\n         self.expander.module = prev_local_module;"}, {"sha": "622756ee8a97969906ba3bb1b2cf00621e1590ab", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -292,18 +292,6 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*expr);\n                 w!(self, \"?\");\n             }\n-            Expr::TryBlock { body } => {\n-                w!(self, \"try \");\n-                self.print_expr(*body);\n-            }\n-            Expr::Async { body } => {\n-                w!(self, \"async \");\n-                self.print_expr(*body);\n-            }\n-            Expr::Const { body } => {\n-                w!(self, \"const \");\n-                self.print_expr(*body);\n-            }\n             Expr::Cast { expr, type_ref } => {\n                 self.print_expr(*expr);\n                 w!(self, \" as \");\n@@ -402,10 +390,6 @@ impl<'a> Printer<'a> {\n                 }\n                 w!(self, \")\");\n             }\n-            Expr::Unsafe { body } => {\n-                w!(self, \"unsafe \");\n-                self.print_expr(*body);\n-            }\n             Expr::Array(arr) => {\n                 w!(self, \"[\");\n                 if !matches!(arr, Array::ElementList { elements, .. } if elements.is_empty()) {\n@@ -428,25 +412,47 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Literal(lit) => self.print_literal(lit),\n             Expr::Block { id: _, statements, tail, label } => {\n-                self.whitespace();\n-                if let Some(lbl) = label {\n-                    w!(self, \"{}: \", self.body[*lbl].name);\n+                let label = label.map(|lbl| format!(\"{}: \", self.body[lbl].name));\n+                self.print_block(label.as_deref(), statements, tail);\n+            }\n+            Expr::Unsafe { id: _, statements, tail } => {\n+                self.print_block(Some(\"unsafe \"), statements, tail);\n+            }\n+            Expr::TryBlock { id: _, statements, tail } => {\n+                self.print_block(Some(\"try \"), statements, tail);\n+            }\n+            Expr::Async { id: _, statements, tail } => {\n+                self.print_block(Some(\"async \"), statements, tail);\n+            }\n+            Expr::Const { id: _, statements, tail } => {\n+                self.print_block(Some(\"const \"), statements, tail);\n+            }\n+        }\n+    }\n+\n+    fn print_block(\n+        &mut self,\n+        label: Option<&str>,\n+        statements: &Box<[Statement]>,\n+        tail: &Option<la_arena::Idx<Expr>>,\n+    ) {\n+        self.whitespace();\n+        if let Some(lbl) = label {\n+            w!(self, \"{}\", lbl);\n+        }\n+        w!(self, \"{{\");\n+        if !statements.is_empty() || tail.is_some() {\n+            self.indented(|p| {\n+                for stmt in &**statements {\n+                    p.print_stmt(stmt);\n                 }\n-                w!(self, \"{{\");\n-                if !statements.is_empty() || tail.is_some() {\n-                    self.indented(|p| {\n-                        for stmt in &**statements {\n-                            p.print_stmt(stmt);\n-                        }\n-                        if let Some(tail) = tail {\n-                            p.print_expr(*tail);\n-                        }\n-                        p.newline();\n-                    });\n+                if let Some(tail) = tail {\n+                    p.print_expr(*tail);\n                 }\n-                w!(self, \"}}\");\n-            }\n+                p.newline();\n+            });\n         }\n+        w!(self, \"}}\");\n     }\n \n     fn print_pat(&mut self, pat: PatId) {"}, {"sha": "e7078b7953b8f311f2a39cc9ec7571ddf36ebdbc", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -194,6 +194,16 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n             scopes.set_scope(expr, scope);\n             compute_block_scopes(statements, *tail, body, scopes, &mut scope);\n         }\n+        Expr::Unsafe { id, statements, tail }\n+        | Expr::Async { id, statements, tail }\n+        | Expr::Const { id, statements, tail }\n+        | Expr::TryBlock { id, statements, tail } => {\n+            let mut scope = scopes.new_block_scope(*scope, *id, None);\n+            // Overwrite the old scope for the block expr, so that every block scope can be found\n+            // via the block itself (important for blocks that only contain items, no expressions).\n+            scopes.set_scope(expr, scope);\n+            compute_block_scopes(statements, *tail, body, scopes, &mut scope);\n+        }\n         Expr::For { iterable, pat, body: body_expr, label } => {\n             compute_expr_scopes(*iterable, body, scopes, scope);\n             let mut scope = scopes.new_labeled_scope(*scope, make_label(label));"}, {"sha": "78a2f861233d6a5a2b7693842d2945e0e672e0c1", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -109,6 +109,26 @@ pub enum Expr {\n         tail: Option<ExprId>,\n         label: Option<LabelId>,\n     },\n+    TryBlock {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n+    Async {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n+    Const {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n+    Unsafe {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n     Loop {\n         body: ExprId,\n         label: Option<LabelId>,\n@@ -172,15 +192,6 @@ pub enum Expr {\n     Try {\n         expr: ExprId,\n     },\n-    TryBlock {\n-        body: ExprId,\n-    },\n-    Async {\n-        body: ExprId,\n-    },\n-    Const {\n-        body: ExprId,\n-    },\n     Cast {\n         expr: ExprId,\n         type_ref: Interned<TypeRef>,\n@@ -222,9 +233,6 @@ pub enum Expr {\n         exprs: Box<[ExprId]>,\n         is_assignee_expr: bool,\n     },\n-    Unsafe {\n-        body: ExprId,\n-    },\n     Array(Array),\n     Literal(Literal),\n     Underscore,\n@@ -290,13 +298,20 @@ impl Expr {\n             Expr::Let { expr, .. } => {\n                 f(*expr);\n             }\n-            Expr::Block { statements, tail, .. } => {\n+            Expr::Block { statements, tail, .. }\n+            | Expr::TryBlock { statements, tail, .. }\n+            | Expr::Unsafe { statements, tail, .. }\n+            | Expr::Async { statements, tail, .. }\n+            | Expr::Const { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {\n-                        Statement::Let { initializer, .. } => {\n+                        Statement::Let { initializer, else_branch, .. } => {\n                             if let &Some(expr) = initializer {\n                                 f(expr);\n                             }\n+                            if let &Some(expr) = else_branch {\n+                                f(expr);\n+                            }\n                         }\n                         Statement::Expr { expr: expression, .. } => f(*expression),\n                     }\n@@ -305,10 +320,6 @@ impl Expr {\n                     f(expr);\n                 }\n             }\n-            Expr::TryBlock { body }\n-            | Expr::Unsafe { body }\n-            | Expr::Async { body }\n-            | Expr::Const { body } => f(*body),\n             Expr::Loop { body, .. } => f(*body),\n             Expr::While { condition, body, .. } => {\n                 f(*condition);"}, {"sha": "664db292a7f78d603235f4eb732d58bb0fa4a384", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -294,8 +294,8 @@ impl Resolver {\n             }\n         }\n \n-        if let res @ Some(_) = self.module_scope.resolve_path_in_value_ns(db, path) {\n-            return res;\n+        if let Some(res) = self.module_scope.resolve_path_in_value_ns(db, path) {\n+            return Some(res);\n         }\n \n         // If a path of the shape `u16::from_le_bytes` failed to resolve at all, then we fall back"}, {"sha": "d25c0ccf00dcd6ed947fa573fb25f1b0062b5d17", "filename": "crates/hir-ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -94,8 +94,10 @@ fn walk_unsafe(\n                 unsafe_expr_cb(UnsafeExpr { expr: current, inside_unsafe_block });\n             }\n         }\n-        Expr::Unsafe { body: child } => {\n-            return walk_unsafe(db, infer, def, body, *child, true, unsafe_expr_cb);\n+        Expr::Unsafe { .. } => {\n+            return expr.walk_child_exprs(|child| {\n+                walk_unsafe(db, infer, def, body, child, true, unsafe_expr_cb);\n+            });\n         }\n         _ => {}\n     }"}, {"sha": "8895dc095f92acbfccbe4a976bb82206b7c027ab", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 172, "deletions": 123, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -84,14 +84,38 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n+    pub(super) fn infer_expr_coerce_never(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n+        let ty = self.infer_expr_inner(expr, expected);\n+        // While we don't allow *arbitrary* coercions here, we *do* allow\n+        // coercions from ! to `expected`.\n+        if ty.is_never() {\n+            if let Some(adjustments) = self.result.expr_adjustments.get(&expr) {\n+                return if let [Adjustment { kind: Adjust::NeverToAny, target }] = &**adjustments {\n+                    target.clone()\n+                } else {\n+                    self.err_ty()\n+                };\n+            }\n+\n+            let adj_ty = self.table.new_type_var();\n+            self.write_expr_adj(\n+                expr,\n+                vec![Adjustment { kind: Adjust::NeverToAny, target: adj_ty.clone() }],\n+            );\n+            adj_ty\n+        } else {\n+            ty\n+        }\n+    }\n+\n     fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         self.db.unwind_if_cancelled();\n \n         let ty = match &self.body[tgt_expr] {\n             Expr::Missing => self.err_ty(),\n             &Expr::If { condition, then_branch, else_branch } => {\n                 let expected = &expected.adjust_for_branches(&mut self.table);\n-                self.infer_expr(\n+                self.infer_expr_coerce_never(\n                     condition,\n                     &Expectation::HasType(self.result.standard_types.bool_.clone()),\n                 );\n@@ -124,41 +148,18 @@ impl<'a> InferenceContext<'a> {\n                 self.result.standard_types.bool_.clone()\n             }\n             Expr::Block { statements, tail, label, id: _ } => {\n-                let old_resolver = mem::replace(\n-                    &mut self.resolver,\n-                    resolver_for_expr(self.db.upcast(), self.owner, tgt_expr),\n-                );\n-                let ty = match label {\n-                    Some(_) => {\n-                        let break_ty = self.table.new_type_var();\n-                        let (breaks, ty) = self.with_breakable_ctx(\n-                            BreakableKind::Block,\n-                            Some(break_ty.clone()),\n-                            *label,\n-                            |this| {\n-                                this.infer_block(\n-                                    tgt_expr,\n-                                    statements,\n-                                    *tail,\n-                                    &Expectation::has_type(break_ty),\n-                                )\n-                            },\n-                        );\n-                        breaks.unwrap_or(ty)\n-                    }\n-                    None => self.infer_block(tgt_expr, statements, *tail, expected),\n-                };\n-                self.resolver = old_resolver;\n-                ty\n+                self.infer_block(tgt_expr, statements, *tail, *label, expected)\n+            }\n+            Expr::Unsafe { id: _, statements, tail } => {\n+                self.infer_block(tgt_expr, statements, *tail, None, expected)\n             }\n-            Expr::Unsafe { body } => self.infer_expr(*body, expected),\n-            Expr::Const { body } => {\n+            Expr::Const { id: _, statements, tail } => {\n                 self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n-                    this.infer_expr(*body, expected)\n+                    this.infer_block(tgt_expr, statements, *tail, None, expected)\n                 })\n                 .1\n             }\n-            Expr::TryBlock { body } => {\n+            Expr::TryBlock { id: _, statements, tail } => {\n                 // The type that is returned from the try block\n                 let try_ty = self.table.new_type_var();\n                 if let Some(ty) = expected.only_has_type(&mut self.table) {\n@@ -169,13 +170,16 @@ impl<'a> InferenceContext<'a> {\n                 let ok_ty =\n                     self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_output());\n \n-                self.with_breakable_ctx(BreakableKind::Block, Some(ok_ty.clone()), None, |this| {\n-                    this.infer_expr(*body, &Expectation::has_type(ok_ty));\n-                });\n-\n+                self.infer_block(\n+                    tgt_expr,\n+                    statements,\n+                    *tail,\n+                    None,\n+                    &Expectation::has_type(ok_ty.clone()),\n+                );\n                 try_ty\n             }\n-            Expr::Async { body } => {\n+            Expr::Async { id: _, statements, tail } => {\n                 let ret_ty = self.table.new_type_var();\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n@@ -184,7 +188,13 @@ impl<'a> InferenceContext<'a> {\n \n                 let (_, inner_ty) =\n                     self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n-                        this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty))\n+                        this.infer_block(\n+                            tgt_expr,\n+                            statements,\n+                            *tail,\n+                            None,\n+                            &Expectation::has_type(ret_ty),\n+                        )\n                     });\n \n                 self.diverges = prev_diverges;\n@@ -193,7 +203,8 @@ impl<'a> InferenceContext<'a> {\n \n                 // Use the first type parameter as the output type of future.\n                 // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n-                let impl_trait_id = crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n+                let impl_trait_id =\n+                    crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, tgt_expr);\n                 let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                 TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, inner_ty))\n                     .intern(Interner)\n@@ -403,37 +414,47 @@ impl<'a> InferenceContext<'a> {\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n \n-                let expected = expected.adjust_for_branches(&mut self.table);\n-\n-                let result_ty = if arms.is_empty() {\n+                if arms.is_empty() {\n+                    self.diverges = Diverges::Always;\n                     self.result.standard_types.never.clone()\n                 } else {\n-                    expected.coercion_target_type(&mut self.table)\n-                };\n-                let mut coerce = CoerceMany::new(result_ty);\n-\n-                let matchee_diverges = self.diverges;\n-                let mut all_arms_diverge = Diverges::Always;\n-\n-                for arm in arms.iter() {\n-                    self.diverges = Diverges::Maybe;\n-                    let input_ty = self.resolve_ty_shallow(&input_ty);\n-                    self.infer_top_pat(arm.pat, &input_ty);\n-                    if let Some(guard_expr) = arm.guard {\n-                        self.infer_expr(\n-                            guard_expr,\n-                            &Expectation::HasType(self.result.standard_types.bool_.clone()),\n-                        );\n+                    let matchee_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                    let mut all_arms_diverge = Diverges::Always;\n+                    for arm in arms.iter() {\n+                        let input_ty = self.resolve_ty_shallow(&input_ty);\n+                        self.infer_top_pat(arm.pat, &input_ty);\n                     }\n \n-                    let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n-                    all_arms_diverge &= self.diverges;\n-                    coerce.coerce(self, Some(arm.expr), &arm_ty);\n-                }\n+                    let expected = expected.adjust_for_branches(&mut self.table);\n+                    let result_ty = match &expected {\n+                        // We don't coerce to `()` so that if the match expression is a\n+                        // statement it's branches can have any consistent type.\n+                        Expectation::HasType(ty) if *ty != self.result.standard_types.unit => {\n+                            ty.clone()\n+                        }\n+                        _ => self.table.new_type_var(),\n+                    };\n+                    let mut coerce = CoerceMany::new(result_ty);\n+\n+                    for arm in arms.iter() {\n+                        if let Some(guard_expr) = arm.guard {\n+                            self.diverges = Diverges::Maybe;\n+                            self.infer_expr_coerce_never(\n+                                guard_expr,\n+                                &Expectation::HasType(self.result.standard_types.bool_.clone()),\n+                            );\n+                        }\n+                        self.diverges = Diverges::Maybe;\n \n-                self.diverges = matchee_diverges | all_arms_diverge;\n+                        let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n+                        all_arms_diverge &= self.diverges;\n+                        coerce.coerce(self, Some(arm.expr), &arm_ty);\n+                    }\n \n-                coerce.complete(self)\n+                    self.diverges = matchee_diverges | all_arms_diverge;\n+\n+                    coerce.complete(self)\n+                }\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -1143,73 +1164,101 @@ impl<'a> InferenceContext<'a> {\n         expr: ExprId,\n         statements: &[Statement],\n         tail: Option<ExprId>,\n+        label: Option<LabelId>,\n         expected: &Expectation,\n     ) -> Ty {\n-        for stmt in statements {\n-            match stmt {\n-                Statement::Let { pat, type_ref, initializer, else_branch } => {\n-                    let decl_ty = type_ref\n-                        .as_ref()\n-                        .map(|tr| self.make_ty(tr))\n-                        .unwrap_or_else(|| self.table.new_type_var());\n-\n-                    let ty = if let Some(expr) = initializer {\n-                        let ty = if contains_explicit_ref_binding(&self.body, *pat) {\n-                            self.infer_expr(*expr, &Expectation::has_type(decl_ty.clone()))\n-                        } else {\n-                            self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()))\n-                        };\n-                        if type_ref.is_some() {\n-                            decl_ty\n-                        } else {\n-                            ty\n+        let coerce_ty = expected.coercion_target_type(&mut self.table);\n+        let old_resolver =\n+            mem::replace(&mut self.resolver, resolver_for_expr(self.db.upcast(), self.owner, expr));\n+        let (break_ty, ty) =\n+            self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty.clone()), label, |this| {\n+                for stmt in statements {\n+                    match stmt {\n+                        Statement::Let { pat, type_ref, initializer, else_branch } => {\n+                            let decl_ty = type_ref\n+                                .as_ref()\n+                                .map(|tr| this.make_ty(tr))\n+                                .unwrap_or_else(|| this.table.new_type_var());\n+\n+                            let ty = if let Some(expr) = initializer {\n+                                let ty = if contains_explicit_ref_binding(&this.body, *pat) {\n+                                    this.infer_expr(*expr, &Expectation::has_type(decl_ty.clone()))\n+                                } else {\n+                                    this.infer_expr_coerce(\n+                                        *expr,\n+                                        &Expectation::has_type(decl_ty.clone()),\n+                                    )\n+                                };\n+                                if type_ref.is_some() {\n+                                    decl_ty\n+                                } else {\n+                                    ty\n+                                }\n+                            } else {\n+                                decl_ty\n+                            };\n+\n+                            this.infer_top_pat(*pat, &ty);\n+\n+                            if let Some(expr) = else_branch {\n+                                let previous_diverges =\n+                                    mem::replace(&mut this.diverges, Diverges::Maybe);\n+                                this.infer_expr_coerce(\n+                                    *expr,\n+                                    &Expectation::HasType(this.result.standard_types.never.clone()),\n+                                );\n+                                this.diverges = previous_diverges;\n+                            }\n+                        }\n+                        &Statement::Expr { expr, has_semi } => {\n+                            if has_semi {\n+                                this.infer_expr(expr, &Expectation::none());\n+                            } else {\n+                                this.infer_expr_coerce(\n+                                    expr,\n+                                    &Expectation::HasType(this.result.standard_types.unit.clone()),\n+                                );\n+                            }\n                         }\n-                    } else {\n-                        decl_ty\n-                    };\n-\n-                    self.infer_top_pat(*pat, &ty);\n-\n-                    if let Some(expr) = else_branch {\n-                        let previous_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n-                        self.infer_expr_coerce(\n-                            *expr,\n-                            &Expectation::HasType(self.result.standard_types.never.clone()),\n-                        );\n-                        self.diverges = previous_diverges;\n                     }\n                 }\n-                Statement::Expr { expr, .. } => {\n-                    self.infer_expr(*expr, &Expectation::none());\n-                }\n-            }\n-        }\n \n-        if let Some(expr) = tail {\n-            self.infer_expr_coerce(expr, expected)\n-        } else {\n-            // Citing rustc: if there is no explicit tail expression,\n-            // that is typically equivalent to a tail expression\n-            // of `()` -- except if the block diverges. In that\n-            // case, there is no value supplied from the tail\n-            // expression (assuming there are no other breaks,\n-            // this implies that the type of the block will be\n-            // `!`).\n-            if self.diverges.is_always() {\n-                // we don't even make an attempt at coercion\n-                self.table.new_maybe_never_var()\n-            } else if let Some(t) = expected.only_has_type(&mut self.table) {\n-                if self.coerce(Some(expr), &TyBuilder::unit(), &t).is_err() {\n-                    self.result.type_mismatches.insert(\n-                        expr.into(),\n-                        TypeMismatch { expected: t.clone(), actual: TyBuilder::unit() },\n-                    );\n+                // FIXME: This should make use of the breakable CoerceMany\n+                if let Some(expr) = tail {\n+                    this.infer_expr_coerce(expr, expected)\n+                } else {\n+                    // Citing rustc: if there is no explicit tail expression,\n+                    // that is typically equivalent to a tail expression\n+                    // of `()` -- except if the block diverges. In that\n+                    // case, there is no value supplied from the tail\n+                    // expression (assuming there are no other breaks,\n+                    // this implies that the type of the block will be\n+                    // `!`).\n+                    if this.diverges.is_always() {\n+                        // we don't even make an attempt at coercion\n+                        this.table.new_maybe_never_var()\n+                    } else if let Some(t) = expected.only_has_type(&mut this.table) {\n+                        if this\n+                            .coerce(Some(expr), &this.result.standard_types.unit.clone(), &t)\n+                            .is_err()\n+                        {\n+                            this.result.type_mismatches.insert(\n+                                expr.into(),\n+                                TypeMismatch {\n+                                    expected: t.clone(),\n+                                    actual: this.result.standard_types.unit.clone(),\n+                                },\n+                            );\n+                        }\n+                        t\n+                    } else {\n+                        this.result.standard_types.unit.clone()\n+                    }\n                 }\n-                t\n-            } else {\n-                TyBuilder::unit()\n-            }\n-        }\n+            });\n+        self.resolver = old_resolver;\n+\n+        break_ty.unwrap_or(ty)\n     }\n \n     fn lookup_field("}, {"sha": "b3867623f37e3cf1130492b70e6b623fa47b6089", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -40,20 +40,14 @@ impl<'a> InferenceContext<'a> {\n         id: ExprOrPatId,\n     ) -> Option<Ty> {\n         let (value, self_subst) = if let Some(type_ref) = path.type_anchor() {\n-            if path.segments().is_empty() {\n-                // This can't actually happen syntax-wise\n-                return None;\n-            }\n+            let Some(last) = path.segments().last() else { return None };\n             let ty = self.make_ty(type_ref);\n             let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n             let ctx = crate::lower::TyLoweringContext::new(self.db, resolver);\n             let (ty, _) = ctx.lower_ty_relative_path(ty, None, remaining_segments_for_ty);\n-            self.resolve_ty_assoc_item(\n-                ty,\n-                path.segments().last().expect(\"path had at least one segment\").name,\n-                id,\n-            )?\n+            self.resolve_ty_assoc_item(ty, last.name, id)?\n         } else {\n+            // FIXME: report error, unresolved first path segment\n             let value_or_partial =\n                 resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path())?;\n \n@@ -66,10 +60,13 @@ impl<'a> InferenceContext<'a> {\n         };\n \n         let typable: ValueTyDefId = match value {\n-            ValueNs::LocalBinding(pat) => {\n-                let ty = self.result.type_of_pat.get(pat)?.clone();\n-                return Some(ty);\n-            }\n+            ValueNs::LocalBinding(pat) => match self.result.type_of_pat.get(pat) {\n+                Some(ty) => return Some(ty.clone()),\n+                None => {\n+                    never!(\"uninferred pattern?\");\n+                    return None;\n+                }\n+            },\n             ValueNs::FunctionId(it) => it.into(),\n             ValueNs::ConstId(it) => it.into(),\n             ValueNs::StaticId(it) => it.into(),\n@@ -91,7 +88,7 @@ impl<'a> InferenceContext<'a> {\n                     let ty = self.db.value_ty(struct_id.into()).substitute(Interner, &substs);\n                     return Some(ty);\n                 } else {\n-                    // FIXME: diagnostic, invalid Self reference\n+                    // FIXME: report error, invalid Self reference\n                     return None;\n                 }\n             }"}, {"sha": "936b56a02170ee092c7972f35b7847bf1bc3fd4f", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -331,56 +331,11 @@ impl MirLowerCtx<'_> {\n                 }\n                 Ok(result)\n             }\n+            Expr::Unsafe { id: _, statements, tail } => {\n+                self.lower_block_to_place(None, statements, current, *tail, place)\n+            }\n             Expr::Block { id: _, statements, tail, label } => {\n-                if label.is_some() {\n-                    not_supported!(\"block with label\");\n-                }\n-                for statement in statements.iter() {\n-                    match statement {\n-                        hir_def::expr::Statement::Let {\n-                            pat,\n-                            initializer,\n-                            else_branch,\n-                            type_ref: _,\n-                        } => match initializer {\n-                            Some(expr_id) => {\n-                                let else_block;\n-                                let init_place;\n-                                (init_place, current) =\n-                                    self.lower_expr_to_some_place(*expr_id, current)?;\n-                                (current, else_block) = self.pattern_match(\n-                                    current,\n-                                    None,\n-                                    init_place,\n-                                    self.expr_ty(*expr_id),\n-                                    *pat,\n-                                    BindingAnnotation::Unannotated,\n-                                )?;\n-                                match (else_block, else_branch) {\n-                                    (None, _) => (),\n-                                    (Some(else_block), None) => {\n-                                        self.set_terminator(else_block, Terminator::Unreachable);\n-                                    }\n-                                    (Some(else_block), Some(else_branch)) => {\n-                                        let (_, b) = self\n-                                            .lower_expr_to_some_place(*else_branch, else_block)?;\n-                                        self.set_terminator(b, Terminator::Unreachable);\n-                                    }\n-                                }\n-                            }\n-                            None => continue,\n-                        },\n-                        hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n-                            let ty = self.expr_ty(*expr);\n-                            let temp = self.temp(ty)?;\n-                            current = self.lower_expr_to_place(*expr, temp.into(), current)?;\n-                        }\n-                    }\n-                }\n-                match tail {\n-                    Some(tail) => self.lower_expr_to_place(*tail, place, current),\n-                    None => Ok(current),\n-                }\n+                self.lower_block_to_place(*label, statements, current, *tail, place)\n             }\n             Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin, _| {\n                 let (_, block) = this.lower_expr_to_some_place(*body, begin)?;\n@@ -686,7 +641,6 @@ impl MirLowerCtx<'_> {\n                 self.push_assignment(current, place, r);\n                 Ok(current)\n             }\n-            Expr::Unsafe { body } => self.lower_expr_to_place(*body, place, current),\n             Expr::Array(l) => match l {\n                 Array::ElementList { elements, .. } => {\n                     let elem_ty = match &self.expr_ty(expr_id).data(Interner).kind {\n@@ -723,6 +677,62 @@ impl MirLowerCtx<'_> {\n         }\n     }\n \n+    fn lower_block_to_place(\n+        &mut self,\n+        label: Option<LabelId>,\n+        statements: &[hir_def::expr::Statement],\n+        mut current: BasicBlockId,\n+        tail: Option<ExprId>,\n+        place: Place,\n+    ) -> Result<BasicBlockId> {\n+        if label.is_some() {\n+            not_supported!(\"block with label\");\n+        }\n+        for statement in statements.iter() {\n+            match statement {\n+                hir_def::expr::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n+                    match initializer {\n+                        Some(expr_id) => {\n+                            let else_block;\n+                            let init_place;\n+                            (init_place, current) =\n+                                self.lower_expr_to_some_place(*expr_id, current)?;\n+                            (current, else_block) = self.pattern_match(\n+                                current,\n+                                None,\n+                                init_place,\n+                                self.expr_ty(*expr_id),\n+                                *pat,\n+                                BindingAnnotation::Unannotated,\n+                            )?;\n+                            match (else_block, else_branch) {\n+                                (None, _) => (),\n+                                (Some(else_block), None) => {\n+                                    self.set_terminator(else_block, Terminator::Unreachable);\n+                                }\n+                                (Some(else_block), Some(else_branch)) => {\n+                                    let (_, b) =\n+                                        self.lower_expr_to_some_place(*else_branch, else_block)?;\n+                                    self.set_terminator(b, Terminator::Unreachable);\n+                                }\n+                            }\n+                        }\n+                        None => continue,\n+                    }\n+                }\n+                hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n+                    let ty = self.expr_ty(*expr);\n+                    let temp = self.temp(ty)?;\n+                    current = self.lower_expr_to_place(*expr, temp.into(), current)?;\n+                }\n+            }\n+        }\n+        match tail {\n+            Some(tail) => self.lower_expr_to_place(tail, place, current),\n+            None => Ok(current),\n+        }\n+    }\n+\n     fn lower_literal_to_operand(&mut self, ty: Ty, l: &Literal) -> Result<Operand> {\n         let size = layout_of_ty(self.db, &ty, self.owner.module(self.db.upcast()).krate())?\n             .size"}, {"sha": "759878b10bbf2d90b272a448c3673d52cb1471c8", "filename": "crates/hir-ty/src/tests.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -61,22 +61,27 @@ fn setup_tracing() -> Option<tracing::subscriber::DefaultGuard> {\n     Some(tracing::subscriber::set_default(subscriber))\n }\n \n+#[track_caller]\n fn check_types(ra_fixture: &str) {\n     check_impl(ra_fixture, false, true, false)\n }\n \n+#[track_caller]\n fn check_types_source_code(ra_fixture: &str) {\n     check_impl(ra_fixture, false, true, true)\n }\n \n+#[track_caller]\n fn check_no_mismatches(ra_fixture: &str) {\n     check_impl(ra_fixture, true, false, false)\n }\n \n+#[track_caller]\n fn check(ra_fixture: &str) {\n     check_impl(ra_fixture, false, false, false)\n }\n \n+#[track_caller]\n fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_source: bool) {\n     let _tracing = setup_tracing();\n     let (db, files) = TestDB::with_many_files(ra_fixture);"}, {"sha": "1876be303ad44862802ac0aae149a5502749bfe1", "filename": "crates/hir-ty/src/tests/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdiagnostics.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -73,3 +73,24 @@ fn test(x: bool) -> &'static str {\n \"#,\n     );\n }\n+\n+#[test]\n+fn non_unit_block_expr_stmt_no_semi() {\n+    check(\n+        r#\"\n+fn test(x: bool) {\n+    if x {\n+        \"notok\"\n+      //^^^^^^^ expected (), got &str\n+    } else {\n+        \"ok\"\n+      //^^^^ expected (), got &str\n+    }\n+    match x { true => true, false => 0 }\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), got bool\n+                                   //^ expected bool, got i32\n+    ()\n+}\n+\"#,\n+    );\n+}"}, {"sha": "4b671449e154dba9695bf096ffeb94eac61e5214", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -1167,7 +1167,6 @@ fn test() {\n             123..167 '{     ...o(); }': ()\n             133..134 's': &S\n             137..151 'unsafe { f() }': &S\n-            137..151 'unsafe { f() }': &S\n             146..147 'f': fn f() -> &S\n             146..149 'f()': &S\n             157..158 's': &S"}, {"sha": "74bcab6caa94a3ed1c14cc138e0a47f6c7e1c77b", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -476,7 +476,7 @@ fn infer_adt_pattern() {\n             183..184 'x': usize\n             190..191 'x': usize\n             201..205 'E::B': E\n-            209..212 'foo': bool\n+            209..212 'foo': {unknown}\n             216..217 '1': usize\n             227..231 'E::B': E\n             235..237 '10': usize"}, {"sha": "2fa6234da1e8639bd22bbd95f7378c603b011ad7", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -270,7 +270,7 @@ fn infer_std_crash_5() {\n             61..320 '{     ...     }': ()\n             75..79 'name': &{unknown}\n             82..166 'if doe...     }': &{unknown}\n-            85..98 'doesnt_matter': bool\n+            85..98 'doesnt_matter': {unknown}\n             99..128 '{     ...     }': &{unknown}\n             113..118 'first': &{unknown}\n             134..166 '{     ...     }': &{unknown}\n@@ -279,7 +279,7 @@ fn infer_std_crash_5() {\n             181..188 'content': &{unknown}\n             191..313 'if ICE...     }': &{unknown}\n             194..231 'ICE_RE..._VALUE': {unknown}\n-            194..247 'ICE_RE...&name)': bool\n+            194..247 'ICE_RE...&name)': {unknown}\n             241..246 '&name': &&{unknown}\n             242..246 'name': &{unknown}\n             248..276 '{     ...     }': &{unknown}\n@@ -1015,9 +1015,9 @@ fn cfg_tail() {\n             20..31 '{ \"first\" }': ()\n             22..29 '\"first\"': &str\n             72..190 '{     ...] 13 }': ()\n-            78..88 '{ \"fake\" }': &str\n+            78..88 '{ \"fake\" }': ()\n             80..86 '\"fake\"': &str\n-            93..103 '{ \"fake\" }': &str\n+            93..103 '{ \"fake\" }': ()\n             95..101 '\"fake\"': &str\n             108..120 '{ \"second\" }': ()\n             110..118 '\"second\"': &str"}, {"sha": "1a07a2c51d812666fbe7be14a88e06b2870aa182", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -352,15 +352,13 @@ unsafe fn baz(u: MyUnion) {\n             71..89 'MyUnio...o: 0 }': MyUnion\n             86..87 '0': u32\n             95..113 'unsafe...(u); }': ()\n-            95..113 'unsafe...(u); }': ()\n             104..107 'baz': fn baz(MyUnion)\n             104..110 'baz(u)': ()\n             108..109 'u': MyUnion\n             122..123 'u': MyUnion\n             126..146 'MyUnio... 0.0 }': MyUnion\n             141..144 '0.0': f32\n             152..170 'unsafe...(u); }': ()\n-            152..170 'unsafe...(u); }': ()\n             161..164 'baz': fn baz(MyUnion)\n             161..167 'baz(u)': ()\n             165..166 'u': MyUnion\n@@ -2077,22 +2075,17 @@ async fn main() {\n             16..193 '{     ...2 }; }': ()\n             26..27 'x': i32\n             30..43 'unsafe { 92 }': i32\n-            30..43 'unsafe { 92 }': i32\n             39..41 '92': i32\n             53..54 'y': impl Future<Output = ()>\n-            57..85 'async ...wait }': ()\n             57..85 'async ...wait }': impl Future<Output = ()>\n-            65..77 'async { () }': ()\n             65..77 'async { () }': impl Future<Output = ()>\n             65..83 'async ....await': ()\n             73..75 '()': ()\n             95..96 'z': ControlFlow<(), ()>\n-            130..140 'try { () }': ()\n             130..140 'try { () }': ControlFlow<(), ()>\n             136..138 '()': ()\n             150..151 'w': i32\n             154..166 'const { 92 }': i32\n-            154..166 'const { 92 }': i32\n             162..164 '92': i32\n             176..177 't': i32\n             180..190 ''a: { 92 }': i32\n@@ -2122,7 +2115,6 @@ fn main() {\n             83..84 'f': F\n             89..91 '{}': ()\n             103..231 '{     ... }); }': ()\n-            109..161 'async ...     }': Result<(), ()>\n             109..161 'async ...     }': impl Future<Output = Result<(), ()>>\n             125..139 'return Err(())': !\n             132..135 'Err': Err<(), ()>(()) -> Result<(), ()>\n@@ -2134,7 +2126,6 @@ fn main() {\n             167..171 'test': fn test<(), (), || -> impl Future<Output = Result<(), ()>>, impl Future<Output = Result<(), ()>>>(|| -> impl Future<Output = Result<(), ()>>)\n             167..228 'test(|...    })': ()\n             172..227 '|| asy...     }': || -> impl Future<Output = Result<(), ()>>\n-            175..227 'async ...     }': Result<(), ()>\n             175..227 'async ...     }': impl Future<Output = Result<(), ()>>\n             191..205 'return Err(())': !\n             198..201 'Err': Err<(), ()>(()) -> Result<(), ()>"}, {"sha": "16356141288d57cac87c155d8de07e72c3bbc2ad", "filename": "crates/ide-assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94dc7a3eb092b5ea641a4d344fae5f3ad4158853/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=94dc7a3eb092b5ea641a4d344fae5f3ad4158853", "patch": "@@ -287,7 +287,7 @@ fn foo() {\n             extract_variable,\n             r\"\n fn foo() {\n-    $0{ let x = 0; x }$0\n+    $0{ let x = 0; x }$0;\n     something_else();\n }\",\n             r\""}]}