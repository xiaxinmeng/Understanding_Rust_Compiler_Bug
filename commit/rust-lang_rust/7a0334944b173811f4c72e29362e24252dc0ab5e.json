{"sha": "7a0334944b173811f4c72e29362e24252dc0ab5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMDMzNDk0NGIxNzM4MTFmNGM3MmUyOTM2MmUyNDI1MmRjMGFiNWU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-12-15T01:11:27Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-12-16T20:35:51Z"}, "message": "Add the files I fogot about earlier\n\nd'oh", "tree": {"sha": "bda796fbc8373da876b16dc40fb5cc0d9567e1c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bda796fbc8373da876b16dc40fb5cc0d9567e1c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a0334944b173811f4c72e29362e24252dc0ab5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0334944b173811f4c72e29362e24252dc0ab5e", "html_url": "https://github.com/rust-lang/rust/commit/7a0334944b173811f4c72e29362e24252dc0ab5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a0334944b173811f4c72e29362e24252dc0ab5e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a47881182237201f207a4b89166a6be6903a8228", "url": "https://api.github.com/repos/rust-lang/rust/commits/a47881182237201f207a4b89166a6be6903a8228", "html_url": "https://github.com/rust-lang/rust/commit/a47881182237201f207a4b89166a6be6903a8228"}], "stats": {"total": 1027, "additions": 1027, "deletions": 0}, "files": [{"sha": "cbb5970bd550d0d1db5126c60c17acdfcef23b21", "filename": "src/libsyntax/errors/emitter.rs", "status": "added", "additions": 631, "deletions": 0, "changes": 631, "blob_url": "https://github.com/rust-lang/rust/blob/7a0334944b173811f4c72e29362e24252dc0ab5e/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0334944b173811f4c72e29362e24252dc0ab5e/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=7a0334944b173811f4c72e29362e24252dc0ab5e", "patch": "@@ -0,0 +1,631 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::Destination::*;\n+\n+use codemap::{self, COMMAND_LINE_SP, COMMAND_LINE_EXPN, Pos, Span};\n+use diagnostics;\n+\n+use errors::{Level, RenderSpan};\n+use errors::RenderSpan::*;\n+use errors::Level::*;\n+\n+use std::{cmp, fmt};\n+use std::io::prelude::*;\n+use std::io;\n+use std::rc::Rc;\n+use term;\n+\n+\n+pub trait Emitter {\n+    fn emit(&mut self, span: Option<Span>, msg: &str, code: Option<&str>, lvl: Level);\n+    fn custom_emit(&mut self, sp: RenderSpan, msg: &str, lvl: Level);\n+}\n+\n+/// maximum number of lines we will print for each error; arbitrary.\n+const MAX_LINES: usize = 6;\n+\n+#[derive(Clone, Copy)]\n+pub enum ColorConfig {\n+    Auto,\n+    Always,\n+    Never,\n+}\n+\n+// A basic emitter for when we don't have access to a codemap or registry. Used\n+// for reporting very early errors, etc.\n+pub struct BasicEmitter {\n+    dst: Destination,\n+}\n+\n+impl Emitter for BasicEmitter {\n+    fn emit(&mut self,\n+            sp: Option<Span>,\n+            msg: &str,\n+            code: Option<&str>,\n+            lvl: Level) {\n+        assert!(sp.is_none(), \"BasicEmitter can't handle spans\");\n+        if let Err(e) = print_diagnostic(&mut self.dst, \"\", lvl, msg, code) {\n+            panic!(\"failed to print diagnostics: {:?}\", e);\n+        }\n+\n+    }\n+\n+    fn custom_emit(&mut self, _: RenderSpan, _: &str, _: Level) {\n+        panic!(\"BasicEmitter can't handle custom_emit\");\n+    }\n+}\n+\n+impl BasicEmitter {\n+    // TODO refactor\n+    pub fn stderr(color_config: ColorConfig) -> BasicEmitter {\n+        let stderr = io::stderr();\n+\n+        let use_color = match color_config {\n+            ColorConfig::Always => true,\n+            ColorConfig::Never  => false,\n+            ColorConfig::Auto   => stderr_isatty(),\n+        };\n+\n+        if use_color {\n+            let dst = match term::stderr() {\n+                Some(t) => Terminal(t),\n+                None    => Raw(Box::new(stderr)),\n+            };\n+            BasicEmitter { dst: dst }\n+        } else {\n+            BasicEmitter { dst: Raw(Box::new(stderr)) }\n+        }\n+    }\n+}\n+\n+pub struct EmitterWriter {\n+    dst: Destination,\n+    registry: Option<diagnostics::registry::Registry>,\n+    cm: Rc<codemap::CodeMap>,\n+}\n+\n+impl Emitter for EmitterWriter {\n+    fn emit(&mut self,\n+            sp: Option<Span>,\n+            msg: &str,\n+            code: Option<&str>,\n+            lvl: Level) {\n+        let error = match sp {\n+            Some(COMMAND_LINE_SP) => self.emit_(FileLine(COMMAND_LINE_SP), msg, code, lvl),\n+            Some(sp) => self.emit_(FullSpan(sp), msg, code, lvl),\n+            None => print_diagnostic(&mut self.dst, \"\", lvl, msg, code),\n+        };\n+\n+        if let Err(e) = error {\n+            panic!(\"failed to print diagnostics: {:?}\", e);\n+        }\n+    }\n+\n+    fn custom_emit(&mut self,\n+                   sp: RenderSpan,\n+                   msg: &str,\n+                   lvl: Level) {\n+        match self.emit_(sp, msg, None, lvl) {\n+            Ok(()) => {}\n+            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n+        }\n+    }\n+}\n+\n+/// Do not use this for messages that end in `\\n` \u2013 use `println_maybe_styled` instead. See\n+/// `EmitterWriter::print_maybe_styled` for details.\n+macro_rules! print_maybe_styled {\n+    ($dst: expr, $style: expr, $($arg: tt)*) => {\n+        $dst.print_maybe_styled(format_args!($($arg)*), $style, false)\n+    }\n+}\n+\n+macro_rules! println_maybe_styled {\n+    ($dst: expr, $style: expr, $($arg: tt)*) => {\n+        $dst.print_maybe_styled(format_args!($($arg)*), $style, true)\n+    }\n+}\n+\n+impl EmitterWriter {\n+    pub fn stderr(color_config: ColorConfig,\n+                  registry: Option<diagnostics::registry::Registry>,\n+                  code_map: Rc<codemap::CodeMap>)\n+                  -> EmitterWriter {\n+        let stderr = io::stderr();\n+\n+        let use_color = match color_config {\n+            ColorConfig::Always => true,\n+            ColorConfig::Never  => false,\n+            ColorConfig::Auto   => stderr_isatty(),\n+        };\n+\n+        if use_color {\n+            let dst = match term::stderr() {\n+                Some(t) => Terminal(t),\n+                None    => Raw(Box::new(stderr)),\n+            };\n+            EmitterWriter { dst: dst, registry: registry, cm: code_map }\n+        } else {\n+            EmitterWriter { dst: Raw(Box::new(stderr)), registry: registry, cm: code_map }\n+        }\n+    }\n+\n+    pub fn new(dst: Box<Write + Send>,\n+               registry: Option<diagnostics::registry::Registry>,\n+               code_map: Rc<codemap::CodeMap>)\n+               -> EmitterWriter {\n+        EmitterWriter { dst: Raw(dst), registry: registry, cm: code_map }\n+    }\n+\n+    fn emit_(&mut self,\n+             rsp: RenderSpan,\n+             msg: &str,\n+             code: Option<&str>,\n+             lvl: Level)\n+             -> io::Result<()> {\n+        let sp = rsp.span();\n+\n+        // We cannot check equality directly with COMMAND_LINE_SP\n+        // since PartialEq is manually implemented to ignore the ExpnId\n+        let ss = if sp.expn_id == COMMAND_LINE_EXPN {\n+            \"<command line option>\".to_string()\n+        } else if let EndSpan(_) = rsp {\n+            let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n+            self.cm.span_to_string(span_end)\n+        } else {\n+            self.cm.span_to_string(sp)\n+        };\n+\n+        try!(print_diagnostic(&mut self.dst, &ss[..], lvl, msg, code));\n+\n+        match rsp {\n+            FullSpan(_) => {\n+                let lines = self.cm.span_to_lines(sp);\n+                try!(self.highlight_lines(sp, lvl, lines));\n+                try!(self.print_macro_backtrace(sp));\n+            }\n+            EndSpan(_) => {\n+                let lines = self.cm.span_to_lines(sp);\n+                try!(self.end_highlight_lines(sp, lvl, lines));\n+                try!(self.print_macro_backtrace(sp));\n+            }\n+            Suggestion(_, ref suggestion) => {\n+                try!(self.highlight_suggestion(sp, suggestion));\n+                try!(self.print_macro_backtrace(sp));\n+            }\n+            FileLine(..) => {\n+                // no source text in this case!\n+            }\n+        }\n+\n+        match code {\n+            Some(code) =>\n+                match self.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n+                    Some(_) => {\n+                        try!(print_diagnostic(&mut self.dst, &ss[..], Help,\n+                                              &format!(\"run `rustc --explain {}` to see a \\\n+                                                       detailed explanation\", code), None));\n+                    }\n+                    None => ()\n+                },\n+            None => (),\n+        }\n+        Ok(())\n+    }\n+\n+    fn highlight_suggestion(&mut self,\n+                            sp: Span,\n+                            suggestion: &str)\n+                            -> io::Result<()>\n+    {\n+        let lines = self.cm.span_to_lines(sp).unwrap();\n+        assert!(!lines.lines.is_empty());\n+\n+        // To build up the result, we want to take the snippet from the first\n+        // line that precedes the span, prepend that with the suggestion, and\n+        // then append the snippet from the last line that trails the span.\n+        let fm = &lines.file;\n+\n+        let first_line = &lines.lines[0];\n+        let prefix = fm.get_line(first_line.line_index)\n+                       .map(|l| &l[..first_line.start_col.0])\n+                       .unwrap_or(\"\");\n+\n+        let last_line = lines.lines.last().unwrap();\n+        let suffix = fm.get_line(last_line.line_index)\n+                       .map(|l| &l[last_line.end_col.0..])\n+                       .unwrap_or(\"\");\n+\n+        let complete = format!(\"{}{}{}\", prefix, suggestion, suffix);\n+\n+        // print the suggestion without any line numbers, but leave\n+        // space for them. This helps with lining up with previous\n+        // snippets from the actual error being reported.\n+        let fm = &*lines.file;\n+        let mut lines = complete.lines();\n+        for (line, line_index) in lines.by_ref().take(MAX_LINES).zip(first_line.line_index..) {\n+            let elided_line_num = format!(\"{}\", line_index+1);\n+            try!(write!(&mut self.dst, \"{0}:{1:2$} {3}\\n\",\n+                        fm.name, \"\", elided_line_num.len(), line));\n+        }\n+\n+        // if we elided some lines, add an ellipsis\n+        if lines.next().is_some() {\n+            let elided_line_num = format!(\"{}\", first_line.line_index + MAX_LINES + 1);\n+            try!(write!(&mut self.dst, \"{0:1$} {0:2$} ...\\n\",\n+                        \"\", fm.name.len(), elided_line_num.len()));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn highlight_lines(&mut self,\n+                       sp: Span,\n+                       lvl: Level,\n+                       lines: codemap::FileLinesResult)\n+                       -> io::Result<()>\n+    {\n+        let lines = match lines {\n+            Ok(lines) => lines,\n+            Err(_) => {\n+                try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n+                return Ok(());\n+            }\n+        };\n+\n+        let fm = &*lines.file;\n+\n+        let line_strings: Option<Vec<&str>> =\n+            lines.lines.iter()\n+                       .map(|info| fm.get_line(info.line_index))\n+                       .collect();\n+\n+        let line_strings = match line_strings {\n+            None => { return Ok(()); }\n+            Some(line_strings) => line_strings\n+        };\n+\n+        // Display only the first MAX_LINES lines.\n+        let all_lines = lines.lines.len();\n+        let display_lines = cmp::min(all_lines, MAX_LINES);\n+        let display_line_infos = &lines.lines[..display_lines];\n+        let display_line_strings = &line_strings[..display_lines];\n+\n+        // Calculate the widest number to format evenly and fix #11715\n+        assert!(display_line_infos.len() > 0);\n+        let mut max_line_num = display_line_infos[display_line_infos.len() - 1].line_index + 1;\n+        let mut digits = 0;\n+        while max_line_num > 0 {\n+            max_line_num /= 10;\n+            digits += 1;\n+        }\n+\n+        // Print the offending lines\n+        for (line_info, line) in display_line_infos.iter().zip(display_line_strings) {\n+            try!(write!(&mut self.dst, \"{}:{:>width$} {}\\n\",\n+                        fm.name,\n+                        line_info.line_index + 1,\n+                        line,\n+                        width=digits));\n+        }\n+\n+        // If we elided something, put an ellipsis.\n+        if display_lines < all_lines {\n+            let last_line_index = display_line_infos.last().unwrap().line_index;\n+            let s = format!(\"{}:{} \", fm.name, last_line_index + 1);\n+            try!(write!(&mut self.dst, \"{0:1$}...\\n\", \"\", s.len()));\n+        }\n+\n+        // FIXME (#3260)\n+        // If there's one line at fault we can easily point to the problem\n+        if lines.lines.len() == 1 {\n+            let lo = self.cm.lookup_char_pos(sp.lo);\n+            let mut digits = 0;\n+            let mut num = (lines.lines[0].line_index + 1) / 10;\n+\n+            // how many digits must be indent past?\n+            while num > 0 { num /= 10; digits += 1; }\n+\n+            let mut s = String::new();\n+            // Skip is the number of characters we need to skip because they are\n+            // part of the 'filename:line ' part of the previous line.\n+            let skip = fm.name.chars().count() + digits + 3;\n+            for _ in 0..skip {\n+                s.push(' ');\n+            }\n+            if let Some(orig) = fm.get_line(lines.lines[0].line_index) {\n+                let mut col = skip;\n+                let mut lastc = ' ';\n+                let mut iter = orig.chars().enumerate();\n+                for (pos, ch) in iter.by_ref() {\n+                    lastc = ch;\n+                    if pos >= lo.col.to_usize() { break; }\n+                    // Whenever a tab occurs on the previous line, we insert one on\n+                    // the error-point-squiggly-line as well (instead of a space).\n+                    // That way the squiggly line will usually appear in the correct\n+                    // position.\n+                    match ch {\n+                        '\\t' => {\n+                            col += 8 - col%8;\n+                            s.push('\\t');\n+                        },\n+                        _ => {\n+                            col += 1;\n+                            s.push(' ');\n+                        },\n+                    }\n+                }\n+\n+                try!(write!(&mut self.dst, \"{}\", s));\n+                let mut s = String::from(\"^\");\n+                let count = match lastc {\n+                    // Most terminals have a tab stop every eight columns by default\n+                    '\\t' => 8 - col%8,\n+                    _ => 1,\n+                };\n+                col += count;\n+                s.extend(::std::iter::repeat('~').take(count));\n+\n+                let hi = self.cm.lookup_char_pos(sp.hi);\n+                if hi.col != lo.col {\n+                    for (pos, ch) in iter {\n+                        if pos >= hi.col.to_usize() { break; }\n+                        let count = match ch {\n+                            '\\t' => 8 - col%8,\n+                            _ => 1,\n+                        };\n+                        col += count;\n+                        s.extend(::std::iter::repeat('~').take(count));\n+                    }\n+                }\n+\n+                if s.len() > 1 {\n+                    // One extra squiggly is replaced by a \"^\"\n+                    s.pop();\n+                }\n+\n+                try!(println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n+                                           \"{}\", s));\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Here are the differences between this and the normal `highlight_lines`:\n+    /// `end_highlight_lines` will always put arrow on the last byte of the\n+    /// span (instead of the first byte). Also, when the span is too long (more\n+    /// than 6 lines), `end_highlight_lines` will print the first line, then\n+    /// dot dot dot, then last line, whereas `highlight_lines` prints the first\n+    /// six lines.\n+    #[allow(deprecated)]\n+    fn end_highlight_lines(&mut self,\n+                           sp: Span,\n+                           lvl: Level,\n+                           lines: codemap::FileLinesResult)\n+                          -> io::Result<()> {\n+        let lines = match lines {\n+            Ok(lines) => lines,\n+            Err(_) => {\n+                try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n+                return Ok(());\n+            }\n+        };\n+\n+        let fm = &*lines.file;\n+\n+        let lines = &lines.lines[..];\n+        if lines.len() > MAX_LINES {\n+            if let Some(line) = fm.get_line(lines[0].line_index) {\n+                try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n+                            lines[0].line_index + 1, line));\n+            }\n+            try!(write!(&mut self.dst, \"...\\n\"));\n+            let last_line_index = lines[lines.len() - 1].line_index;\n+            if let Some(last_line) = fm.get_line(last_line_index) {\n+                try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n+                            last_line_index + 1, last_line));\n+            }\n+        } else {\n+            for line_info in lines {\n+                if let Some(line) = fm.get_line(line_info.line_index) {\n+                    try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n+                                line_info.line_index + 1, line));\n+                }\n+            }\n+        }\n+        let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n+        let hi = self.cm.lookup_char_pos(sp.hi);\n+        let skip = last_line_start.chars().count();\n+        let mut s = String::new();\n+        for _ in 0..skip {\n+            s.push(' ');\n+        }\n+        if let Some(orig) = fm.get_line(lines[0].line_index) {\n+            let iter = orig.chars().enumerate();\n+            for (pos, ch) in iter {\n+                // Span seems to use half-opened interval, so subtract 1\n+                if pos >= hi.col.to_usize() - 1 { break; }\n+                // Whenever a tab occurs on the previous line, we insert one on\n+                // the error-point-squiggly-line as well (instead of a space).\n+                // That way the squiggly line will usually appear in the correct\n+                // position.\n+                match ch {\n+                    '\\t' => s.push('\\t'),\n+                    _ => s.push(' '),\n+                }\n+            }\n+        }\n+        s.push('^');\n+        println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n+                              \"{}\", s)\n+    }\n+\n+    fn print_macro_backtrace(&mut self,\n+                             sp: Span)\n+                             -> io::Result<()> {\n+        let mut last_span = codemap::DUMMY_SP;\n+        let mut span = sp;\n+\n+        loop {\n+            let span_name_span = self.cm.with_expn_info(span.expn_id, |expn_info| {\n+                match expn_info {\n+                    Some(ei) => {\n+                        let (pre, post) = match ei.callee.format {\n+                            codemap::MacroAttribute(..) => (\"#[\", \"]\"),\n+                            codemap::MacroBang(..) => (\"\", \"!\"),\n+                        };\n+                        let macro_decl_name = format!(\"in this expansion of {}{}{}\",\n+                                                      pre,\n+                                                      ei.callee.name(),\n+                                                      post);\n+                        let def_site_span = ei.callee.span;\n+                        Some((ei.call_site, macro_decl_name, def_site_span))\n+                    }\n+                    // TODO map\n+                    None => None,\n+                }\n+            });\n+            let (macro_decl_name, def_site_span) = match span_name_span {\n+                None => break,\n+                Some((sp, macro_decl_name, def_site_span)) => {\n+                    span = sp;\n+                    (macro_decl_name, def_site_span)\n+                }\n+            };\n+\n+            // Don't print recursive invocations\n+            if span != last_span {\n+                let mut diag_string = macro_decl_name;\n+                if let Some(def_site_span) = def_site_span {\n+                    diag_string.push_str(&format!(\" (defined in {})\",\n+                                                  self.cm.span_to_filename(def_site_span)));\n+                }\n+\n+                let snippet = self.cm.span_to_string(span);\n+                try!(print_diagnostic(&mut self.dst, &snippet, Note, &diag_string, None));\n+            }\n+            last_span = span;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+fn print_diagnostic(dst: &mut Destination,\n+                    topic: &str,\n+                    lvl: Level,\n+                    msg: &str,\n+                    code: Option<&str>)\n+                    -> io::Result<()> {\n+    if !topic.is_empty() {\n+        try!(write!(dst, \"{} \", topic));\n+    }\n+\n+    try!(print_maybe_styled!(dst, term::Attr::ForegroundColor(lvl.color()),\n+                             \"{}: \", lvl.to_string()));\n+    try!(print_maybe_styled!(dst, term::Attr::Bold, \"{}\", msg));\n+\n+    match code {\n+        Some(code) => {\n+            let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n+            try!(print_maybe_styled!(dst, style, \" [{}]\", code.clone()));\n+        }\n+        None => ()\n+    }\n+    try!(write!(dst, \"\\n\"));\n+    Ok(())\n+}\n+\n+#[cfg(unix)]\n+fn stderr_isatty() -> bool {\n+    use libc;\n+    unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n+}\n+#[cfg(windows)]\n+fn stderr_isatty() -> bool {\n+    type DWORD = u32;\n+    type BOOL = i32;\n+    type HANDLE = *mut u8;\n+    const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n+    extern \"system\" {\n+        fn GetStdHandle(which: DWORD) -> HANDLE;\n+        fn GetConsoleMode(hConsoleHandle: HANDLE,\n+                          lpMode: *mut DWORD) -> BOOL;\n+    }\n+    unsafe {\n+        let handle = GetStdHandle(STD_ERROR_HANDLE);\n+        let mut out = 0;\n+        GetConsoleMode(handle, &mut out) != 0\n+    }\n+}\n+\n+enum Destination {\n+    Terminal(Box<term::StderrTerminal>),\n+    Raw(Box<Write + Send>),\n+}\n+\n+impl Destination {\n+    fn print_maybe_styled(&mut self,\n+                          args: fmt::Arguments,\n+                          color: term::Attr,\n+                          print_newline_at_end: bool)\n+                          -> io::Result<()> {\n+        match *self {\n+            Terminal(ref mut t) => {\n+                try!(t.attr(color));\n+                // If `msg` ends in a newline, we need to reset the color before\n+                // the newline. We're making the assumption that we end up writing\n+                // to a `LineBufferedWriter`, which means that emitting the reset\n+                // after the newline ends up buffering the reset until we print\n+                // another line or exit. Buffering the reset is a problem if we're\n+                // sharing the terminal with any other programs (e.g. other rustc\n+                // instances via `make -jN`).\n+                //\n+                // Note that if `msg` contains any internal newlines, this will\n+                // result in the `LineBufferedWriter` flushing twice instead of\n+                // once, which still leaves the opportunity for interleaved output\n+                // to be miscolored. We assume this is rare enough that we don't\n+                // have to worry about it.\n+                try!(t.write_fmt(args));\n+                try!(t.reset());\n+                if print_newline_at_end {\n+                    t.write_all(b\"\\n\")\n+                } else {\n+                    Ok(())\n+                }\n+            }\n+            Raw(ref mut w) => {\n+                try!(w.write_fmt(args));\n+                if print_newline_at_end {\n+                    w.write_all(b\"\\n\")\n+                } else {\n+                    Ok(())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl Write for Destination {\n+    fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n+        match *self {\n+            Terminal(ref mut t) => t.write(bytes),\n+            Raw(ref mut w) => w.write(bytes),\n+        }\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        match *self {\n+            Terminal(ref mut t) => t.flush(),\n+            Raw(ref mut w) => w.flush(),\n+        }\n+    }\n+}\n+"}, {"sha": "920fd2fdb00497b86645f3fae083628c30fd921b", "filename": "src/libsyntax/errors/mod.rs", "status": "added", "additions": 396, "deletions": 0, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/7a0334944b173811f4c72e29362e24252dc0ab5e/src%2Flibsyntax%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0334944b173811f4c72e29362e24252dc0ab5e/src%2Flibsyntax%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fmod.rs?ref=7a0334944b173811f4c72e29362e24252dc0ab5e", "patch": "@@ -0,0 +1,396 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use errors::emitter::ColorConfig;\n+\n+use self::Level::*;\n+use self::RenderSpan::*;\n+\n+use codemap::{self, Span};\n+use diagnostics;\n+use errors::emitter::{Emitter, EmitterWriter};\n+\n+use std::cell::{RefCell, Cell};\n+use std::{error, fmt};\n+use std::io::prelude::*;\n+use std::rc::Rc;\n+use term;\n+\n+pub mod emitter;\n+\n+#[derive(Clone)]\n+pub enum RenderSpan {\n+    /// A FullSpan renders with both with an initial line for the\n+    /// message, prefixed by file:linenum, followed by a summary of\n+    /// the source code covered by the span.\n+    FullSpan(Span),\n+\n+    /// Similar to a FullSpan, but the cited position is the end of\n+    /// the span, instead of the start. Used, at least, for telling\n+    /// compiletest/runtest to look at the last line of the span\n+    /// (since `end_highlight_lines` displays an arrow to the end\n+    /// of the span).\n+    EndSpan(Span),\n+\n+    /// A suggestion renders with both with an initial line for the\n+    /// message, prefixed by file:linenum, followed by a summary\n+    /// of hypothetical source code, where the `String` is spliced\n+    /// into the lines in place of the code covered by the span.\n+    Suggestion(Span, String),\n+\n+    /// A FileLine renders with just a line for the message prefixed\n+    /// by file:linenum.\n+    FileLine(Span),\n+}\n+\n+impl RenderSpan {\n+    fn span(&self) -> Span {\n+        match *self {\n+            FullSpan(s) |\n+            Suggestion(s, _) |\n+            EndSpan(s) |\n+            FileLine(s) =>\n+                s\n+        }\n+    }\n+}\n+\n+/// Used as a return value to signify a fatal error occurred. (It is also\n+/// used as the argument to panic at the moment, but that will eventually\n+/// not be true.)\n+#[derive(Copy, Clone, Debug)]\n+#[must_use]\n+pub struct FatalError;\n+\n+impl fmt::Display for FatalError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(f, \"parser fatal error\")\n+    }\n+}\n+\n+impl error::Error for FatalError {\n+    fn description(&self) -> &str {\n+        \"The parser has encountered a fatal error\"\n+    }\n+}\n+\n+/// Signifies that the compiler died with an explicit call to `.bug`\n+/// or `.span_bug` rather than a failed assertion, etc.\n+#[derive(Copy, Clone, Debug)]\n+pub struct ExplicitBug;\n+\n+impl fmt::Display for ExplicitBug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(f, \"parser internal bug\")\n+    }\n+}\n+\n+impl error::Error for ExplicitBug {\n+    fn description(&self) -> &str {\n+        \"The parser has encountered an internal bug\"\n+    }\n+}\n+\n+/// A handler deals with errors; certain errors\n+/// (fatal, bug, unimpl) may cause immediate exit,\n+/// others log errors for later reporting.\n+pub struct Handler {\n+    err_count: Cell<usize>,\n+    emit: RefCell<Box<Emitter>>,\n+    pub can_emit_warnings: bool,\n+    treat_err_as_bug: bool,\n+    delayed_span_bug: RefCell<Option<(codemap::Span, String)>>,\n+}\n+\n+impl Handler {\n+    pub fn new(color_config: ColorConfig,\n+               registry: Option<diagnostics::registry::Registry>,\n+               can_emit_warnings: bool,\n+               treat_err_as_bug: bool,\n+               cm: Rc<codemap::CodeMap>)\n+               -> Handler {\n+        let emitter = Box::new(EmitterWriter::stderr(color_config, registry, cm));\n+        Handler::with_emitter(can_emit_warnings, treat_err_as_bug, emitter)\n+    }\n+\n+    pub fn with_emitter(can_emit_warnings: bool,\n+                        treat_err_as_bug: bool,\n+                        e: Box<Emitter>) -> Handler {\n+        Handler {\n+            err_count: Cell::new(0),\n+            emit: RefCell::new(e),\n+            can_emit_warnings: can_emit_warnings,\n+            treat_err_as_bug: treat_err_as_bug,\n+            delayed_span_bug: RefCell::new(None),\n+        }\n+    }\n+\n+    pub fn span_fatal(&self, sp: Span, msg: &str) -> FatalError {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit(Some(sp), msg, Fatal);\n+        return FatalError;\n+    }\n+    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> FatalError {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit_with_code(Some(sp), msg, code, Fatal);\n+        return FatalError;\n+    }\n+    pub fn span_err(&self, sp: Span, msg: &str) {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit(Some(sp), msg, Error);\n+        self.bump_err_count();\n+    }\n+    pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit_with_code(Some(sp), msg, code, Error);\n+        self.bump_err_count();\n+    }\n+    pub fn span_warn(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Warning);\n+    }\n+    pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n+        self.emit_with_code(Some(sp), msg, code, Warning);\n+    }\n+    pub fn span_note(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Note);\n+    }\n+    pub fn span_end_note(&self, sp: Span, msg: &str) {\n+        self.custom_emit(EndSpan(sp), msg, Note);\n+    }\n+    pub fn span_help(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Help);\n+    }\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n+        self.custom_emit(Suggestion(sp, suggestion), msg, Help);\n+    }\n+    pub fn fileline_note(&self, sp: Span, msg: &str) {\n+        self.custom_emit(FileLine(sp), msg, Note);\n+    }\n+    pub fn fileline_help(&self, sp: Span, msg: &str) {\n+        self.custom_emit(FileLine(sp), msg, Help);\n+    }\n+    pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n+        self.emit(Some(sp), msg, Bug);\n+        panic!(ExplicitBug);\n+    }\n+    pub fn delay_span_bug(&self, sp: Span, msg: &str) {\n+        let mut delayed = self.delayed_span_bug.borrow_mut();\n+        *delayed = Some((sp, msg.to_string()));\n+    }\n+    pub fn span_bug_no_panic(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Bug);\n+        self.bump_err_count();\n+    }\n+    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n+        self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n+    }\n+    pub fn fatal(&self, msg: &str) -> FatalError {\n+        if self.treat_err_as_bug {\n+            self.bug(msg);\n+        }\n+        self.emit.borrow_mut().emit(None, msg, None, Fatal);\n+        FatalError\n+    }\n+    pub fn err(&self, msg: &str) {\n+        if self.treat_err_as_bug {\n+            self.bug(msg);\n+        }\n+        self.emit.borrow_mut().emit(None, msg, None, Error);\n+        self.bump_err_count();\n+    }\n+    pub fn warn(&self, msg: &str) {\n+        self.emit.borrow_mut().emit(None, msg, None, Warning);\n+    }\n+    pub fn note(&self, msg: &str) {\n+        self.emit.borrow_mut().emit(None, msg, None, Note);\n+    }\n+    pub fn help(&self, msg: &str) {\n+        self.emit.borrow_mut().emit(None, msg, None, Help);\n+    }\n+    pub fn bug(&self, msg: &str) -> ! {\n+        self.emit.borrow_mut().emit(None, msg, None, Bug);\n+        panic!(ExplicitBug);\n+    }\n+    pub fn unimpl(&self, msg: &str) -> ! {\n+        self.bug(&format!(\"unimplemented {}\", msg));\n+    }\n+\n+    pub fn bump_err_count(&self) {\n+        self.err_count.set(self.err_count.get() + 1);\n+    }\n+\n+    pub fn err_count(&self) -> usize {\n+        self.err_count.get()\n+    }\n+\n+    pub fn has_errors(&self) -> bool {\n+        self.err_count.get() > 0\n+    }\n+\n+    pub fn abort_if_errors(&self) {\n+        let s;\n+        match self.err_count.get() {\n+            0 => {\n+                let delayed_bug = self.delayed_span_bug.borrow();\n+                match *delayed_bug {\n+                    Some((span, ref errmsg)) => {\n+                        self.span_bug(span, errmsg);\n+                    },\n+                    _ => {}\n+                }\n+\n+                return;\n+            }\n+            1 => s = \"aborting due to previous error\".to_string(),\n+            _  => {\n+                s = format!(\"aborting due to {} previous errors\",\n+                            self.err_count.get());\n+            }\n+        }\n+\n+        panic!(self.fatal(&s[..]));\n+    }\n+\n+    pub fn emit(&self,\n+                sp: Option<Span>,\n+                msg: &str,\n+                lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings { return }\n+        self.emit.borrow_mut().emit(sp, msg, None, lvl);\n+    }\n+\n+    pub fn emit_with_code(&self,\n+                          sp: Option<Span>,\n+                          msg: &str,\n+                          code: &str,\n+                          lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings { return }\n+        self.emit.borrow_mut().emit(sp, msg, Some(code), lvl);\n+    }\n+\n+    pub fn custom_emit(&self, sp: RenderSpan, msg: &str, lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings { return }\n+        self.emit.borrow_mut().custom_emit(sp, msg, lvl);\n+    }\n+}\n+\n+\n+#[derive(Copy, PartialEq, Clone, Debug)]\n+pub enum Level {\n+    Bug,\n+    Fatal,\n+    Error,\n+    Warning,\n+    Note,\n+    Help,\n+}\n+\n+impl fmt::Display for Level {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use std::fmt::Display;\n+\n+        match *self {\n+            Bug => \"error: internal compiler error\".fmt(f),\n+            Fatal | Error => \"error\".fmt(f),\n+            Warning => \"warning\".fmt(f),\n+            Note => \"note\".fmt(f),\n+            Help => \"help\".fmt(f),\n+        }\n+    }\n+}\n+\n+impl Level {\n+    fn color(self) -> term::color::Color {\n+        match self {\n+            Bug | Fatal | Error => term::color::BRIGHT_RED,\n+            Warning => term::color::BRIGHT_YELLOW,\n+            Note => term::color::BRIGHT_GREEN,\n+            Help => term::color::BRIGHT_CYAN,\n+        }\n+    }\n+}\n+\n+pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n+    M: FnOnce() -> String,\n+{\n+    match opt {\n+        Some(t) => t,\n+        None => diag.bug(&msg()),\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::Level;\n+    use emitter::EmitterWriter;\n+    use codemap::{mk_sp, CodeMap};\n+    use std::sync::{Arc, Mutex};\n+    use std::io::{self, Write};\n+    use std::str::from_utf8;\n+\n+    // Diagnostic doesn't align properly in span where line number increases by one digit\n+    #[test]\n+    fn test_hilight_suggestion_issue_11715() {\n+        struct Sink(Arc<Mutex<Vec<u8>>>);\n+        impl Write for Sink {\n+            fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+                Write::write(&mut *self.0.lock().unwrap(), data)\n+            }\n+            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+        }\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None);\n+        let cm = CodeMap::new();\n+        let content = \"abcdefg\n+        koksi\n+        line3\n+        line4\n+        cinq\n+        line6\n+        line7\n+        line8\n+        line9\n+        line10\n+        e-l\u00e4-v\u00e4n\n+        tolv\n+        dreizehn\n+        \";\n+        let file = cm.new_filemap_and_lines(\"dummy.txt\", content);\n+        let start = file.lines.borrow()[7];\n+        let end = file.lines.borrow()[11];\n+        let sp = mk_sp(start, end);\n+        let lvl = Level::Error;\n+        println!(\"span_to_lines\");\n+        let lines = cm.span_to_lines(sp);\n+        println!(\"highlight_lines\");\n+        ew.highlight_lines(&cm, sp, lvl, lines).unwrap();\n+        println!(\"done\");\n+        let vec = data.lock().unwrap().clone();\n+        let vec: &[u8] = &vec;\n+        let str = from_utf8(vec).unwrap();\n+        println!(\"{}\", str);\n+        assert_eq!(str, \"dummy.txt: 8         line8\\n\\\n+                         dummy.txt: 9         line9\\n\\\n+                         dummy.txt:10         line10\\n\\\n+                         dummy.txt:11         e-l\u00e4-v\u00e4n\\n\\\n+                         dummy.txt:12         tolv\\n\");\n+    }\n+}"}]}