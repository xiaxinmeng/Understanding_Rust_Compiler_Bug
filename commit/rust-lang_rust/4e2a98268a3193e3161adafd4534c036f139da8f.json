{"sha": "4e2a98268a3193e3161adafd4534c036f139da8f", "node_id": "C_kwDOAAsO6NoAKDRlMmE5ODI2OGEzMTkzZTMxNjFhZGFmZDQ1MzRjMDM2ZjEzOWRhOGY", "commit": {"author": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-03-06T11:10:55Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-04-03T07:24:00Z"}, "message": "include pretty reason why ignore-FOO matched", "tree": {"sha": "16bead6b5f11477f3a5cdc7964e41ace62940a01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16bead6b5f11477f3a5cdc7964e41ace62940a01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e2a98268a3193e3161adafd4534c036f139da8f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmQqfxAACgkQzXazX3c0\ndp5iehAAkRQxTkrDMR8NGztATUBZXLw2KsTc916ao4knbUQcCmQQBY3E5B1M1rA3\n0iK4wcedHYEmZqzs2YGITCMKxoz7vMdj7NyHC0Qqp5icvA1eoCswF/VrS916TprZ\nkCa7bS73+Pwz5imeF9P29r/DEaMz00J7EOlZlPGo09pWVex/I0oO/VZXUjTXKHde\n24K6AytKRxKp2XSSU5trZDELPGmwCyyZjJ+2jpk0wxDomUl9ECtZcQUTtxHbweKb\nnRe/gEP2yldAyHaTR7G+jQ+JPk877IfyGO7iPvjeSG6l/jj79mX9//gtPxe3g8qA\nJh6KcYB8xZrrGRMaKzy7082eJnSGjP8yIauv6F6r8CWktop/jrGUUG9ma1CLIGy6\nIx3Y16M577Run+SYvaqGIrMk3XBR/Ze7/Tdr/bQcAoIJ7toVh2+vMLZ1LMxK6RUs\nxMEVgnO9na84wCA0/gC+lECnggs5/eNSfsr2oLgh8H8yhU+apSVfiexwZulhTfNW\n57FtTpIsn0TBd60SeaXGtdaFpsZfrukik3/jb1IC24Dz/lvzHPCYJt8Bhkebjwxe\n48rfyfVVgGzf89twik9xW6FZCddQ8obhFPMYxkgXd3ageezUX7K9yxS2axeqjNMe\nr3S3UxKk8YwihR83ZgcFAeedmQMRJO2ZQoWXsaFZ7I282HRq9yw=\n=kX5T\n-----END PGP SIGNATURE-----", "payload": "tree 16bead6b5f11477f3a5cdc7964e41ace62940a01\nparent 123cc413bd253492f112b0d21722c8387e0d6b53\nauthor Pietro Albini <pietro.albini@ferrous-systems.com> 1678101055 +0100\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1680506640 +0200\n\ninclude pretty reason why ignore-FOO matched\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e2a98268a3193e3161adafd4534c036f139da8f", "html_url": "https://github.com/rust-lang/rust/commit/4e2a98268a3193e3161adafd4534c036f139da8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e2a98268a3193e3161adafd4534c036f139da8f/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "123cc413bd253492f112b0d21722c8387e0d6b53", "url": "https://api.github.com/repos/rust-lang/rust/commits/123cc413bd253492f112b0d21722c8387e0d6b53", "html_url": "https://github.com/rust-lang/rust/commit/123cc413bd253492f112b0d21722c8387e0d6b53"}], "stats": {"total": 214, "additions": 141, "deletions": 73}, "files": [{"sha": "496b83a956b9cf297f4e24ac5e786e0f0f0be7a9", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4e2a98268a3193e3161adafd4534c036f139da8f/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2a98268a3193e3161adafd4534c036f139da8f/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=4e2a98268a3193e3161adafd4534c036f139da8f", "patch": "@@ -159,7 +159,7 @@ pub enum Debugger {\n }\n \n impl Debugger {\n-    fn to_str(&self) -> &'static str {\n+    pub(crate) fn to_str(&self) -> &'static str {\n         match self {\n             Debugger::Cdb => \"cdb\",\n             Debugger::Gdb => \"gdb\",\n@@ -396,7 +396,7 @@ impl Config {\n         })\n     }\n \n-    fn target_cfg(&self) -> &TargetCfg {\n+    pub fn target_cfg(&self) -> &TargetCfg {\n         self.target_cfg.borrow_with(|| TargetCfg::new(self))\n     }\n \n@@ -451,12 +451,12 @@ impl Config {\n \n #[derive(Clone, Debug)]\n pub struct TargetCfg {\n-    arch: String,\n-    os: String,\n-    env: String,\n-    abi: String,\n-    families: Vec<String>,\n-    pointer_width: u32,\n+    pub(crate) arch: String,\n+    pub(crate) os: String,\n+    pub(crate) env: String,\n+    pub(crate) abi: String,\n+    pub(crate) families: Vec<String>,\n+    pub(crate) pointer_width: u32,\n     endian: Endian,\n     panic: PanicStrategy,\n }"}, {"sha": "ea900ff068fc5630e3031dbe1f436023438a1564", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 133, "deletions": 65, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/4e2a98268a3193e3161adafd4534c036f139da8f/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2a98268a3193e3161adafd4534c036f139da8f/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=4e2a98268a3193e3161adafd4534c036f139da8f", "patch": "@@ -8,7 +8,7 @@ use std::process::Command;\n \n use tracing::*;\n \n-use crate::common::{CompareMode, Config, Debugger, FailMode, Mode, PassMode};\n+use crate::common::{Config, Debugger, FailMode, Mode, PassMode};\n use crate::util;\n use crate::{extract_cdb_version, extract_gdb_version};\n \n@@ -17,14 +17,16 @@ mod tests;\n \n /// The result of parse_cfg_name_directive.\n #[derive(Clone, PartialEq, Debug)]\n-struct ParsedNameDirective {\n-    comment: Option<String>,\n+struct ParsedNameDirective<'a> {\n+    name: Option<&'a str>,\n+    pretty_reason: Option<String>,\n+    comment: Option<&'a str>,\n     outcome: MatchOutcome,\n }\n \n-impl ParsedNameDirective {\n+impl ParsedNameDirective<'_> {\n     fn invalid() -> Self {\n-        Self { comment: None, outcome: MatchOutcome::NoMatch }\n+        Self { name: None, pretty_reason: None, comment: None, outcome: MatchOutcome::NoMatch }\n     }\n }\n \n@@ -678,7 +680,7 @@ impl Config {\n \n     /// Parses a name-value directive which contains config-specific information, e.g., `ignore-x86`\n     /// or `normalize-stderr-32bit`.\n-    fn parse_cfg_name_directive(&self, line: &str, prefix: &str) -> ParsedNameDirective {\n+    fn parse_cfg_name_directive<'a>(&self, line: &'a str, prefix: &str) -> ParsedNameDirective<'a> {\n         if !line.as_bytes().starts_with(prefix.as_bytes()) {\n             return ParsedNameDirective::invalid();\n         }\n@@ -690,56 +692,124 @@ impl Config {\n         let (name, comment) =\n             line.split_once(&[':', ' ']).map(|(l, c)| (l, Some(c))).unwrap_or((line, None));\n \n-        let matches_pointer_width = || {\n-            name.strip_suffix(\"bit\")\n-                .and_then(|width| width.parse::<u32>().ok())\n-                .map(|width| self.get_pointer_width() == width)\n-                .unwrap_or(false)\n-        };\n+        let mut is_match = None;\n+\n+        macro_rules! maybe_condition {\n+            (name: $name:expr, $(condition: $condition:expr,)? message: $($message:tt)*) => {\n+                if let Some(expected) = $name {\n+                    if name == expected $(&& $condition)? {\n+                        is_match = Some(format!($($message)*));\n+                    }\n+                }\n+            };\n+        }\n+        macro_rules! condition {\n+            (name: $name:expr, $(condition: $condition:expr,)? message: $($message:tt)*) => {\n+                maybe_condition! {\n+                    name: Some($name),\n+                    $(condition: $condition,)*\n+                    message: $($message)*\n+                }\n+            };\n+        }\n+\n+        condition! {\n+            name: \"test\",\n+            message: \"always\"\n+        }\n+        condition! {\n+            name: &self.target,\n+            message: \"when the target is {name}\"\n+        }\n+\n+        let target_cfg = self.target_cfg();\n+        condition! {\n+            name: &target_cfg.os,\n+            message: \"when the operative system is {name}\"\n+        }\n+        condition! {\n+            name: &target_cfg.env,\n+            message: \"when the target environment is {name}\"\n+        }\n+        condition! {\n+            name: &target_cfg.abi,\n+            message: \"when the ABI is {name}\"\n+        }\n+        condition! {\n+            name: &target_cfg.arch,\n+            message: \"when the architecture is {name}\"\n+        }\n+        condition! {\n+            name: format!(\"{}bit\", target_cfg.pointer_width),\n+            message: \"when the pointer width is {name}\"\n+        }\n+        for family in &target_cfg.families {\n+            condition! {\n+                name: family,\n+                message: \"when the target family is {name}\"\n+            }\n+        }\n \n         // If something is ignored for emscripten, it likely also needs to be\n         // ignored for wasm32-unknown-unknown.\n         // `wasm32-bare` is an alias to refer to just wasm32-unknown-unknown\n         // (in contrast to `wasm32` which also matches non-bare targets like\n         // asmjs-unknown-emscripten).\n-        let matches_wasm32_alias = || {\n-            self.target == \"wasm32-unknown-unknown\" && matches!(name, \"emscripten\" | \"wasm32-bare\")\n-        };\n+        condition! {\n+            name: \"emscripten\",\n+            condition: self.target == \"wasm32-unknown-unknown\",\n+            message: \"when the target is WASM\",\n+        }\n+        condition! {\n+            name: \"wasm32-bare\",\n+            condition: self.target == \"wasm32-unknown-unknown\",\n+            message: \"when the target is WASM\"\n+        }\n \n-        let is_match = name == \"test\" ||\n-            self.target == name ||                              // triple\n-            self.matches_os(name) ||\n-            self.matches_env(name) ||\n-            self.matches_abi(name) ||\n-            self.matches_family(name) ||\n-            self.target.ends_with(name) ||                      // target and env\n-            self.matches_arch(name) ||\n-            matches_wasm32_alias() ||\n-            matches_pointer_width() ||\n-            name == self.stage_id.split('-').next().unwrap() || // stage\n-            name == self.channel ||                             // channel\n-            (self.target != self.host && name == \"cross-compile\") ||\n-            (name == \"endian-big\" && self.is_big_endian()) ||\n-            (self.remote_test_client.is_some() && name == \"remote\") ||\n-            match self.compare_mode {\n-                Some(CompareMode::Polonius) => name == \"compare-mode-polonius\",\n-                Some(CompareMode::Chalk) => name == \"compare-mode-chalk\",\n-                Some(CompareMode::NextSolver) => name == \"compare-mode-next-solver\",\n-                Some(CompareMode::SplitDwarf) => name == \"compare-mode-split-dwarf\",\n-                Some(CompareMode::SplitDwarfSingle) => name == \"compare-mode-split-dwarf-single\",\n-                None => false,\n-            } ||\n-            (cfg!(debug_assertions) && name == \"debug\") ||\n-            match self.debugger {\n-                Some(Debugger::Cdb) => name == \"cdb\",\n-                Some(Debugger::Gdb) => name == \"gdb\",\n-                Some(Debugger::Lldb) => name == \"lldb\",\n-                None => false,\n-            };\n+        condition! {\n+            name: &self.channel,\n+            message: \"when the release channel is {name}\",\n+        }\n+        condition! {\n+            name: \"cross-compile\",\n+            condition: self.target != self.host,\n+            message: \"when cross-compiling\"\n+        }\n+        condition! {\n+            name: \"endian-big\",\n+            condition: self.is_big_endian(),\n+            message: \"on big-endian targets\",\n+        }\n+        condition! {\n+            name: self.stage_id.split('-').next().unwrap(),\n+            message: \"when the bootstrapping stage is {name}\",\n+        }\n+        condition! {\n+            name: \"remote\",\n+            condition: self.remote_test_client.is_some(),\n+            message: \"when running tests remotely\",\n+        }\n+        condition! {\n+            name: \"debug\",\n+            condition: cfg!(debug_assertions),\n+            message: \"when building with debug assertions\",\n+        }\n+        maybe_condition! {\n+            name: self.debugger.as_ref().map(|d| d.to_str()),\n+            message: \"when the debugger is {name}\",\n+        }\n+        maybe_condition! {\n+            name: self.compare_mode\n+                .as_ref()\n+                .map(|d| format!(\"compare-mode-{}\", d.to_str())),\n+            message: \"when comparing with {name}\",\n+        }\n \n         ParsedNameDirective {\n-            comment: comment.map(|c| c.trim().trim_start_matches('-').trim().to_string()),\n-            outcome: if is_match { MatchOutcome::Match } else { MatchOutcome::NoMatch },\n+            name: Some(name),\n+            comment: comment.map(|c| c.trim().trim_start_matches('-').trim()),\n+            outcome: if is_match.is_some() { MatchOutcome::Match } else { MatchOutcome::NoMatch },\n+            pretty_reason: is_match,\n         }\n     }\n \n@@ -1014,15 +1084,14 @@ pub fn make_test_description<R: Read>(\n             let parsed = config.parse_cfg_name_directive(ln, \"ignore\");\n             ignore = match parsed.outcome {\n                 MatchOutcome::Match => {\n-                    ignore_message = Some(match parsed.comment {\n-                        // The ignore reason must be a &'static str, so we have to leak memory to\n-                        // create it. This is fine, as the header is parsed only at the start of\n-                        // compiletest so it won't grow indefinitely.\n-                        Some(comment) => Box::leak(Box::<str>::from(format!(\n-                            \"cfg -> ignore => Match ({comment})\"\n-                        ))),\n-                        None => \"cfg -> ignore => Match\",\n-                    });\n+                    let reason = parsed.pretty_reason.unwrap();\n+                    // The ignore reason must be a &'static str, so we have to leak memory to\n+                    // create it. This is fine, as the header is parsed only at the start of\n+                    // compiletest so it won't grow indefinitely.\n+                    ignore_message = Some(Box::leak(Box::<str>::from(match parsed.comment {\n+                        Some(comment) => format!(\"ignored {reason} ({comment})\"),\n+                        None => format!(\"ignored {reason}\"),\n+                    })) as &str);\n                     true\n                 }\n                 MatchOutcome::NoMatch => ignore,\n@@ -1034,15 +1103,14 @@ pub fn make_test_description<R: Read>(\n             ignore = match parsed.outcome {\n                 MatchOutcome::Match => ignore,\n                 MatchOutcome::NoMatch => {\n-                    ignore_message = Some(match parsed.comment {\n-                        // The ignore reason must be a &'static str, so we have to leak memory to\n-                        // create it. This is fine, as the header is parsed only at the start of\n-                        // compiletest so it won't grow indefinitely.\n-                        Some(comment) => Box::leak(Box::<str>::from(format!(\n-                            \"cfg -> only => NoMatch ({comment})\"\n-                        ))),\n-                        None => \"cfg -> only => NoMatch\",\n-                    });\n+                    let name = parsed.name.unwrap();\n+                    // The ignore reason must be a &'static str, so we have to leak memory to\n+                    // create it. This is fine, as the header is parsed only at the start of\n+                    // compiletest so it won't grow indefinitely.\n+                    ignore_message = Some(Box::leak(Box::<str>::from(match parsed.comment {\n+                        Some(comment) => format!(\"did not match only-{name} ({comment})\"),\n+                        None => format!(\"did not match only-{name}\"),\n+                    })) as &str);\n                     true\n                 }\n             };"}]}