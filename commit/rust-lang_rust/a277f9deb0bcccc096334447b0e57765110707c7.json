{"sha": "a277f9deb0bcccc096334447b0e57765110707c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNzdmOWRlYjBiY2NjYzA5NjMzNDQ0N2IwZTU3NzY1MTEwNzA3Yzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-12T23:29:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-12T23:29:13Z"}, "message": "Auto merge of #37675 - arielb1:trans-closure, r=eddyb\n\nTranslate closures through the collector\n\nNow that old trans is gone, there is no need for the hack of translating closures when they are instantiated. We can translate them like regular items.\n\nr? @eddyb", "tree": {"sha": "991c38f46f15ad14c8228f874b6cd8a89e06b378", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/991c38f46f15ad14c8228f874b6cd8a89e06b378"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a277f9deb0bcccc096334447b0e57765110707c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a277f9deb0bcccc096334447b0e57765110707c7", "html_url": "https://github.com/rust-lang/rust/commit/a277f9deb0bcccc096334447b0e57765110707c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a277f9deb0bcccc096334447b0e57765110707c7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd983d02e15909567303f92532671fb2b8374285", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd983d02e15909567303f92532671fb2b8374285", "html_url": "https://github.com/rust-lang/rust/commit/fd983d02e15909567303f92532671fb2b8374285"}, {"sha": "d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7", "html_url": "https://github.com/rust-lang/rust/commit/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7"}], "stats": {"total": 960, "additions": 455, "deletions": 505}, "files": [{"sha": "2d4b36ec187603fc7aa442d678477afd0903c498", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -1150,10 +1150,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_var(self.next_ty_var_id(true))\n     }\n \n-    pub fn next_ty_vars(&self, n: usize) -> Vec<Ty<'tcx>> {\n-        (0..n).map(|_i| self.next_ty_var()).collect()\n-    }\n-\n     pub fn next_int_var_id(&self) -> IntVid {\n         self.int_unification_table\n             .borrow_mut()\n@@ -1657,7 +1653,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         if let InferTables::Local(tables) = self.tables {\n             if let Some(ty) = tables.borrow().closure_tys.get(&def_id) {\n-                return ty.subst(self.tcx, substs.func_substs);\n+                return ty.subst(self.tcx, substs.substs);\n             }\n         }\n "}, {"sha": "8c0d70c6d602b731b054452e74799357bb3a8887", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -40,6 +40,7 @@\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n+#![feature(unboxed_closures)]\n #![cfg_attr(stage0, feature(question_mark))]\n #![cfg_attr(test, feature(test))]\n "}, {"sha": "6f6534cb2064a56be8e02ce5ada885c1bc8b732e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -1912,16 +1912,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 tys.to_vec()\n             }\n \n-            ty::TyClosure(_, ref substs) => {\n+            ty::TyClosure(def_id, ref substs) => {\n                 // FIXME(#27086). We are invariant w/r/t our\n-                // substs.func_substs, but we don't see them as\n+                // func_substs, but we don't see them as\n                 // constituent types; this seems RIGHT but also like\n                 // something that a normal type couldn't simulate. Is\n                 // this just a gap with the way that PhantomData and\n                 // OIBIT interact? That is, there is no way to say\n                 // \"make me invariant with respect to this TYPE, but\n                 // do not act as though I can reach it\"\n-                substs.upvar_tys.to_vec()\n+                substs.upvar_tys(def_id, self.tcx()).collect()\n             }\n \n             // for `PhantomData<T>`, we pass `T`"}, {"sha": "9f80c2487fb2cca52651b36a9d0acad719e0f3ff", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -98,10 +98,11 @@ impl TypeContents {\n         TC::OwnsOwned | (*self & TC::OwnsAll)\n     }\n \n-    pub fn union<T, F>(v: &[T], mut f: F) -> TypeContents where\n-        F: FnMut(&T) -> TypeContents,\n+    pub fn union<I, T, F>(v: I, mut f: F) -> TypeContents where\n+        I: IntoIterator<Item=T>,\n+        F: FnMut(T) -> TypeContents,\n     {\n-        v.iter().fold(TC::None, |tc, ty| tc | f(ty))\n+        v.into_iter().fold(TC::None, |tc, ty| tc | f(ty))\n     }\n \n     pub fn has_dtor(&self) -> bool {\n@@ -215,8 +216,10 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 }\n                 ty::TyStr => TC::None,\n \n-                ty::TyClosure(_, ref substs) => {\n-                    TypeContents::union(&substs.upvar_tys, |ty| tc_ty(tcx, &ty, cache))\n+                ty::TyClosure(def_id, ref substs) => {\n+                    TypeContents::union(\n+                        substs.upvar_tys(def_id, tcx),\n+                        |ty| tc_ty(tcx, &ty, cache))\n                 }\n \n                 ty::TyTuple(ref tys) => {"}, {"sha": "45450456e8a6583e1b9e93861df9b1c627ce6103", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -1446,12 +1446,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_closure(self,\n                       closure_id: DefId,\n-                      substs: &'tcx Substs<'tcx>,\n-                      tys: &[Ty<'tcx>])\n+                      substs: &'tcx Substs<'tcx>)\n                       -> Ty<'tcx> {\n         self.mk_closure_from_closure_substs(closure_id, ClosureSubsts {\n-            func_substs: substs,\n-            upvar_tys: self.intern_type_list(tys)\n+            substs: substs\n         })\n     }\n \n@@ -1574,4 +1572,3 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n         Ok(f(&iter.collect::<Result<AccumulateVec<[_; 8]>, _>>()?))\n     }\n }\n-"}, {"sha": "2c09b89beb2322a8f972235f0b9835fca6addff7", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -88,8 +88,7 @@ impl FlagComputation {\n             &ty::TyClosure(_, ref substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n-                self.add_substs(&substs.func_substs);\n-                self.add_tys(&substs.upvar_tys);\n+                self.add_substs(&substs.substs);\n             }\n \n             &ty::TyInfer(infer) => {"}, {"sha": "5ee1c3678d675df1aba5a4567112dd7a986b40ee", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -631,7 +631,9 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n             // Perhaps one of the upvars of this closure is non-zero\n             // Let's recurse and find out!\n-            (_, &ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. })) |\n+            (_, &ty::TyClosure(def_id, ref substs)) => {\n+                Struct::non_zero_field_path(infcx, substs.upvar_tys(def_id, tcx))\n+            }\n             // Can we use one of the fields in this tuple?\n             (_, &ty::TyTuple(tys)) => {\n                 Struct::non_zero_field_path(infcx, tys.iter().cloned())\n@@ -961,7 +963,13 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             // Tuples and closures.\n-            ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) |\n+            ty::TyClosure(def_id, ref substs) => {\n+                let mut st = Struct::new(dl, false);\n+                let tys = substs.upvar_tys(def_id, tcx);\n+                st.extend(dl, tys.map(|ty| ty.layout(infcx)), ty)?;\n+                Univariant { variant: st, non_zero: false }\n+            }\n+\n             ty::TyTuple(tys) => {\n                 let mut st = Struct::new(dl, false);\n                 st.extend(dl, tys.iter().map(|ty| ty.layout(infcx)), ty)?;"}, {"sha": "1de54f49a55227d4a8361c2bf97c558d45c2221e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -2544,12 +2544,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // tables by typeck; else, it will be retreived from\n         // the external crate metadata.\n         if let Some(ty) = self.tables.borrow().closure_tys.get(&def_id) {\n-            return ty.subst(self, substs.func_substs);\n+            return ty.subst(self, substs.substs);\n         }\n \n         let ty = self.sess.cstore.closure_ty(self.global_tcx(), def_id);\n         self.tables.borrow_mut().closure_tys.insert(def_id, ty.clone());\n-        ty.subst(self, substs.func_substs)\n+        ty.subst(self, substs.substs)\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements."}, {"sha": "e3d13f593954f6ee8ba39356cecdda23e22d5e1c", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // in the `subtys` iterator (e.g., when encountering a\n         // projection).\n         match ty.sty {\n-            ty::TyClosure(_, ref substs) => {\n+            ty::TyClosure(def_id, ref substs) => {\n                 // FIXME(#27086). We do not accumulate from substs, since they\n                 // don't represent reachable data. This means that, in\n                 // practice, some of the lifetime parameters might not\n@@ -110,7 +110,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // what func/type parameters are used and unused,\n                 // taking into consideration UFCS and so forth.\n \n-                for &upvar_ty in substs.upvar_tys {\n+                for upvar_ty in substs.upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);\n                 }\n             }"}, {"sha": "2a01bad33c52e398a7a49b349cfaeb99e5c810a4", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -534,13 +534,8 @@ impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n                            -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        let substs = relate_substs(relation, None, a.func_substs, b.func_substs)?;\n-        assert_eq!(a.upvar_tys.len(), b.upvar_tys.len());\n-        Ok(ty::ClosureSubsts {\n-            func_substs: substs,\n-            upvar_tys: relation.tcx().mk_type_list(\n-                a.upvar_tys.iter().zip(b.upvar_tys).map(|(a, b)| relation.relate(a, b)))?\n-        })\n+        let substs = relate_substs(relation, None, a.substs, b.substs)?;\n+        Ok(ty::ClosureSubsts { substs: substs })\n     }\n }\n "}, {"sha": "e73be23a42c76d068416337e3ef2cd89e8d0f8b3", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -198,11 +198,8 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     type Lifted = ty::ClosureSubsts<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&(self.func_substs, self.upvar_tys)).map(|(substs, upvar_tys)| {\n-            ty::ClosureSubsts {\n-                func_substs: substs,\n-                upvar_tys: upvar_tys\n-            }\n+        tcx.lift(&self.substs).map(|substs| {\n+            ty::ClosureSubsts { substs: substs }\n         })\n     }\n }\n@@ -654,13 +651,12 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ClosureSubsts {\n-            func_substs: self.func_substs.fold_with(folder),\n-            upvar_tys: self.upvar_tys.fold_with(folder),\n+            substs: self.substs.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.func_substs.visit_with(visitor) || self.upvar_tys.visit_with(visitor)\n+        self.substs.visit_with(visitor)\n     }\n }\n "}, {"sha": "56466d596829804ecb89bc77c2355979b0a2d13e", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -11,6 +11,7 @@\n //! This module contains TypeVariants and its major components\n \n use hir::def_id::DefId;\n+\n use middle::region;\n use ty::subst::Substs;\n use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TypeFoldable};\n@@ -254,15 +255,23 @@ pub enum TypeVariants<'tcx> {\n /// handle). Plus it fixes an ICE. :P\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ClosureSubsts<'tcx> {\n-    /// Lifetime and type parameters from the enclosing function.\n+    /// Lifetime and type parameters from the enclosing function,\n+    /// concatenated with the types of the upvars.\n+    ///\n     /// These are separated out because trans wants to pass them around\n     /// when monomorphizing.\n-    pub func_substs: &'tcx Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n+}\n \n-    /// The types of the upvars. The list parallels the freevars and\n-    /// `upvar_borrows` lists. These are kept distinct so that we can\n-    /// easily index into them.\n-    pub upvar_tys: &'tcx Slice<Ty<'tcx>>\n+impl<'a, 'gcx, 'acx, 'tcx> ClosureSubsts<'tcx> {\n+    #[inline]\n+    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'acx>) ->\n+        impl Iterator<Item=Ty<'tcx>> + 'tcx\n+    {\n+        let generics = tcx.item_generics(def_id);\n+        self.substs[self.substs.len()-generics.own_count()..].iter().map(\n+            |t| t.as_type().expect(\"unexpected region in upvars\"))\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -1234,7 +1243,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 substs.regions().collect()\n             }\n             TyClosure(_, ref substs) => {\n-                substs.func_substs.regions().collect()\n+                substs.substs.regions().collect()\n             }\n             TyProjection(ref data) => {\n                 data.trait_ref.substs.regions().collect()"}, {"sha": "41fcb09fb2dc7ef2c3eb324e7679900b1122d0fd", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -183,6 +183,22 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         tcx.intern_substs(&substs)\n     }\n \n+    pub fn extend_to<FR, FT>(&self,\n+                             tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                             def_id: DefId,\n+                             mut mk_region: FR,\n+                             mut mk_type: FT)\n+                             -> &'tcx Substs<'tcx>\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx>\n+    {\n+        let defs = tcx.item_generics(def_id);\n+        let mut result = Vec::with_capacity(defs.count());\n+        result.extend(self[..].iter().cloned());\n+        Substs::fill_single(&mut result, defs, &mut mk_region, &mut mk_type);\n+        tcx.intern_substs(&result)\n+    }\n+\n     fn fill_item<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          defs: &ty::Generics<'tcx>,\n@@ -195,7 +211,15 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n             let parent_defs = tcx.item_generics(def_id);\n             Substs::fill_item(substs, tcx, parent_defs, mk_region, mk_type);\n         }\n+        Substs::fill_single(substs, defs, mk_region, mk_type)\n+    }\n \n+    fn fill_single<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n+                           defs: &ty::Generics<'tcx>,\n+                           mk_region: &mut FR,\n+                           mk_type: &mut FT)\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n         // Handle Self first, before all regions.\n         let mut types = defs.types.iter();\n         if defs.parent.is_none() && defs.has_self {\n@@ -274,6 +298,11 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         let defs = tcx.item_generics(source_ancestor);\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.own_count()..]).cloned())\n     }\n+\n+    pub fn truncate_to(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, generics: &ty::Generics<'tcx>)\n+                       -> &'tcx Substs<'tcx> {\n+        tcx.mk_substs(self.iter().take(generics.count()).cloned())\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {"}, {"sha": "7d3e380a3b59076ef5a10bb7a841336171f62a35", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -11,6 +11,7 @@\n //! misc. type-system utilities too small to deserve their own file\n \n use hir::def_id::DefId;\n+use hir::map::DefPathData;\n use infer::InferCtxt;\n use hir::map as ast_map;\n use hir::pat_util;\n@@ -390,6 +391,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // (e.g. calling `foo.0.clone()` of `Foo<T:Clone>`).\n         return !self.has_attr(dtor_method, \"unsafe_destructor_blind_to_params\");\n     }\n+\n+    pub fn closure_base_def_id(&self, def_id: DefId) -> DefId {\n+        let mut def_id = def_id;\n+        while self.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr {\n+            def_id = self.parent_def_id(def_id).unwrap_or_else(|| {\n+                bug!(\"closure {:?} has no parent\", def_id);\n+            });\n+        }\n+        def_id\n+    }\n }\n \n /// When hashing a type this ends up affecting properties like symbol names. We"}, {"sha": "a6ecfd2fb70668405327f35d7ba2eb6064bc7d35", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -97,8 +97,7 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n             stack.extend(substs.types().rev());\n         }\n         ty::TyClosure(_, ref substs) => {\n-            stack.extend(substs.func_substs.types().rev());\n-            stack.extend(substs.upvar_tys.iter().cloned().rev());\n+            stack.extend(substs.substs.types().rev());\n         }\n         ty::TyTuple(ts) => {\n             stack.extend(ts.iter().cloned().rev());"}, {"sha": "a63c7ba6a25ce9fd093ac59754e692372e2c66c9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -907,13 +907,14 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             }\n             TyStr => write!(f, \"str\"),\n             TyClosure(did, substs) => ty::tls::with(|tcx| {\n+                let upvar_tys = substs.upvar_tys(did, tcx);\n                 write!(f, \"[closure\")?;\n \n                 if let Some(node_id) = tcx.map.as_local_node_id(did) {\n                     write!(f, \"@{:?}\", tcx.map.span(node_id))?;\n                     let mut sep = \" \";\n                     tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(substs.upvar_tys) {\n+                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                             let def_id = freevar.def.def_id();\n                             let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n                             write!(f,\n@@ -930,7 +931,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     // visible in trans bug reports, I imagine.\n                     write!(f, \"@{:?}\", did)?;\n                     let mut sep = \" \";\n-                    for (index, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n                         write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n                         sep = \", \";\n                     }"}, {"sha": "cdb19d164bf290d94432f7ec9e278121a39a3944", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -709,9 +709,11 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             ty::TyAdt(def, substs) => {\n                 self.open_drop_for_adt(c, def, substs)\n             }\n-            ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n-                upvar_tys: tys, ..\n-            }) => {\n+            ty::TyClosure(def_id, substs) => {\n+                let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx).collect();\n+                self.open_drop_for_tuple(c, &tys)\n+            }\n+            ty::TyTuple(tys) => {\n                 self.open_drop_for_tuple(c, tys)\n             }\n             ty::TyBox(ty) => {"}, {"sha": "778a9d185e145ef797e857617f4ac71da4e0a5f3", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -1056,10 +1056,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             stability: None,\n             deprecation: None,\n \n-            ty: None,\n+            ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n             variances: LazySeq::empty(),\n-            generics: None,\n+            generics: Some(self.encode_generics(def_id)),\n             predicates: None,\n \n             ast: None,"}, {"sha": "24c1ca574a01baf6731adc2fefcb8cdf700a52a7", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -521,8 +521,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n             let upvars = cx.tcx.with_freevars(expr.id, |freevars| {\n                 freevars.iter()\n-                    .enumerate()\n-                    .map(|(i, fv)| capture_freevar(cx, expr, fv, substs.upvar_tys[i]))\n+                    .zip(substs.upvar_tys(def_id, cx.tcx))\n+                    .map(|(fv, ty)| capture_freevar(cx, expr, fv, ty))\n                     .collect()\n             });\n             ExprKind::Closure {"}, {"sha": "79bb14b7336c1a0bb28d63f4374b9e1a334a7b78", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -274,9 +274,15 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 ty::TyAdt(adt_def, substs) if adt_def.is_univariant() => {\n                         (&adt_def.variants[0], substs)\n                     }\n-                ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n-                    upvar_tys: tys, ..\n-                }) => {\n+                ty::TyClosure(def_id, substs) => {\n+                    return match substs.upvar_tys(def_id, tcx).nth(field.index()) {\n+                        Some(ty) => Ok(ty),\n+                        None => Err(FieldAccessError::OutOfRange {\n+                            field_count: substs.upvar_tys(def_id, tcx).count()\n+                        })\n+                    }\n+                }\n+                ty::TyTuple(tys) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {"}, {"sha": "c3340281d073254a08a9420dc5e34df0191e23cd", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -108,9 +108,9 @@ fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n             }).collect::<Vec<_>>()\n         },\n         ty::TyTuple(fields) => fields.to_vec(),\n-        ty::TyClosure(_, substs) => {\n+        ty::TyClosure(def_id, substs) => {\n             if variant_index > 0 { bug!(\"{} is a closure, which only has one variant\", t);}\n-            substs.upvar_tys.to_vec()\n+            substs.upvar_tys(def_id, cx.tcx()).collect()\n         },\n         _ => bug!(\"{} is not a type that can have fields.\", t)\n     }"}, {"sha": "c7cad6455bc30e17a472a32abea52587e2546074", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -1003,34 +1003,41 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     }\n }\n \n-/// Builds an LLVM function out of a source function.\n-///\n-/// If the function closes over its environment a closure will be returned.\n-pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               llfndecl: ValueRef,\n-                               instance: Instance<'tcx>,\n-                               sig: &ty::FnSig<'tcx>,\n-                               abi: Abi) {\n+pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n+    let _s = StatRecorder::new(ccx, ccx.tcx().item_path_str(instance.def));\n+    // this is an info! to allow collecting monomorphization statistics\n+    // and to allow finding the last function before LLVM aborts from\n+    // release builds.\n+    info!(\"trans_instance({})\", instance);\n+\n+    let _icx = push_ctxt(\"trans_instance\");\n+\n+    let fn_ty = ccx.tcx().item_type(instance.def);\n+    let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n+    let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n+\n+    let ty::BareFnTy { abi, ref sig, .. } = *common::ty_fn_ty(ccx, fn_ty);\n+    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(sig);\n+\n+    let lldecl = match ccx.instances().borrow().get(&instance) {\n+        Some(&val) => val,\n+        None => bug!(\"Instance `{:?}` not already declared\", instance)\n+    };\n+\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n-    let _icx = push_ctxt(\"trans_closure\");\n     if !ccx.sess().no_landing_pads() {\n-        attributes::emit_uwtable(llfndecl, true);\n+        attributes::emit_uwtable(lldecl, true);\n     }\n \n-    // this is an info! to allow collecting monomorphization statistics\n-    // and to allow finding the last function before LLVM aborts from\n-    // release builds.\n-    info!(\"trans_closure(..., {})\", instance);\n-\n-    let fn_ty = FnType::new(ccx, abi, sig, &[]);\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx,\n-                               llfndecl,\n+                               lldecl,\n                                fn_ty,\n-                               Some((instance, sig, abi)),\n+                               Some((instance, &sig, abi)),\n                                &arena);\n \n     if fcx.mir.is_none() {\n@@ -1040,26 +1047,6 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     mir::trans_mir(&fcx);\n }\n \n-pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx().item_path_str(instance.def));\n-    debug!(\"trans_instance(instance={:?})\", instance);\n-    let _icx = push_ctxt(\"trans_instance\");\n-\n-    let fn_ty = ccx.tcx().item_type(instance.def);\n-    let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n-    let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n-\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(fn_ty.fn_sig());\n-    let abi = fn_ty.fn_abi();\n-\n-    let lldecl = match ccx.instances().borrow().get(&instance) {\n-        Some(&val) => val,\n-        None => bug!(\"Instance `{:?}` not already declared\", instance)\n-    };\n-\n-    trans_closure(ccx, lldecl, instance, &sig, abi);\n-}\n-\n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                  def_id: DefId,\n                                  substs: &'tcx Substs<'tcx>,"}, {"sha": "faf65f3f98b0928d12d9b928faa7daeecda238d7", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 171, "deletions": 6, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -26,11 +26,11 @@ use attributes;\n use base;\n use base::*;\n use build::*;\n-use closure;\n use common::{self, Block, Result, CrateContext, FunctionContext, SharedCrateContext};\n use consts;\n use debuginfo::DebugLoc;\n use declare;\n+use value::Value;\n use meth;\n use monomorphize::{self, Instance};\n use trans_item::TransItem;\n@@ -147,11 +147,12 @@ impl<'tcx> Callee<'tcx> {\n                 // after passing through fulfill_obligation\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n                 let instance = Instance::new(def_id, substs);\n-                let llfn = closure::trans_closure_method(ccx,\n-                                                         vtable_closure.closure_def_id,\n-                                                         vtable_closure.substs,\n-                                                         instance,\n-                                                         trait_closure_kind);\n+                let llfn = trans_closure_method(\n+                    ccx,\n+                    vtable_closure.closure_def_id,\n+                    vtable_closure.substs,\n+                    instance,\n+                    trait_closure_kind);\n \n                 let method_ty = def_ty(ccx.shared(), def_id, substs);\n                 Callee::ptr(llfn, method_ty)\n@@ -250,6 +251,170 @@ fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n     monomorphize::apply_param_substs(shared, substs, &ty)\n }\n \n+\n+fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n+                                  def_id: DefId,\n+                                  substs: ty::ClosureSubsts<'tcx>,\n+                                  method_instance: Instance<'tcx>,\n+                                  trait_closure_kind: ty::ClosureKind)\n+                                  -> ValueRef\n+{\n+    // If this is a closure, redirect to it.\n+    let (llfn, _) = get_fn(ccx, def_id, substs.substs);\n+\n+    // If the closure is a Fn closure, but a FnOnce is needed (etc),\n+    // then adapt the self type\n+    let llfn_closure_kind = ccx.tcx().closure_kind(def_id);\n+\n+    let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n+\n+    debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n+           trait_closure_kind={:?}, llfn={:?})\",\n+           llfn_closure_kind, trait_closure_kind, Value(llfn));\n+\n+    match (llfn_closure_kind, trait_closure_kind) {\n+        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n+            // No adapter needed.\n+            llfn\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            llfn\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // this by doing something like:\n+            //\n+            //     fn call_once(self, ...) { call_mut(&self, ...) }\n+            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+            //\n+            // These are both the same at trans time.\n+            trans_fn_once_adapter_shim(ccx, def_id, substs, method_instance, llfn)\n+        }\n+        _ => {\n+            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n+                 llfn_closure_kind,\n+                 trait_closure_kind);\n+        }\n+    }\n+}\n+\n+fn trans_fn_once_adapter_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    def_id: DefId,\n+    substs: ty::ClosureSubsts<'tcx>,\n+    method_instance: Instance<'tcx>,\n+    llreffn: ValueRef)\n+    -> ValueRef\n+{\n+    if let Some(&llfn) = ccx.instances().borrow().get(&method_instance) {\n+        return llfn;\n+    }\n+\n+    debug!(\"trans_fn_once_adapter_shim(def_id={:?}, substs={:?}, llreffn={:?})\",\n+           def_id, substs, Value(llreffn));\n+\n+    let tcx = ccx.tcx();\n+\n+    // Find a version of the closure type. Substitute static for the\n+    // region since it doesn't really matter.\n+    let closure_ty = tcx.mk_closure_from_closure_substs(def_id, substs);\n+    let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), closure_ty);\n+\n+    // Make a version with the type of by-ref closure.\n+    let ty::ClosureTy { unsafety, abi, mut sig } = tcx.closure_type(def_id, substs);\n+    sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n+    let llref_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: unsafety,\n+        abi: abi,\n+        sig: sig.clone()\n+    }));\n+    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n+           llref_fn_ty);\n+\n+\n+    // Make a version of the closure type with the same arguments, but\n+    // with argument #0 being by value.\n+    assert_eq!(abi, Abi::RustCall);\n+    sig.0.inputs[0] = closure_ty;\n+\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n+\n+    let llonce_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: unsafety,\n+        abi: abi,\n+        sig: ty::Binder(sig)\n+    }));\n+\n+    // Create the by-value helper.\n+    let function_name = method_instance.symbol_name(ccx.shared());\n+    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n+    attributes::set_frame_pointer_elimination(ccx, lloncefn);\n+\n+    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n+    block_arena = TypedArena::new();\n+    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, &block_arena);\n+    let mut bcx = fcx.init(false);\n+\n+\n+    // the first argument (`self`) will be the (by value) closure env.\n+\n+    let mut llargs = get_params(fcx.llfn);\n+    let mut self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+    let env_arg = &fcx.fn_ty.args[0];\n+    let llenv = if env_arg.is_indirect() {\n+        llargs[self_idx]\n+    } else {\n+        let scratch = alloc_ty(bcx, closure_ty, \"self\");\n+        let mut llarg_idx = self_idx;\n+        env_arg.store_fn_arg(&bcx.build(), &mut llarg_idx, scratch);\n+        scratch\n+    };\n+\n+    debug!(\"trans_fn_once_adapter_shim: env={:?}\", Value(llenv));\n+    // Adjust llargs such that llargs[self_idx..] has the call arguments.\n+    // For zero-sized closures that means sneaking in a new argument.\n+    if env_arg.is_ignore() {\n+        if self_idx > 0 {\n+            self_idx -= 1;\n+            llargs[self_idx] = llenv;\n+        } else {\n+            llargs.insert(0, llenv);\n+        }\n+    } else {\n+        llargs[self_idx] = llenv;\n+    }\n+\n+    let dest = fcx.llretslotptr.get();\n+\n+    let callee = Callee {\n+        data: Fn(llreffn),\n+        ty: llref_fn_ty\n+    };\n+\n+    // Call the by-ref closure body with `self` in a cleanup scope,\n+    // to drop `self` when the body returns, or in case it unwinds.\n+    let self_scope = fcx.push_custom_cleanup_scope();\n+    fcx.schedule_drop_mem(self_scope, llenv, closure_ty);\n+\n+    bcx = callee.call(bcx, DebugLoc::None, &llargs[self_idx..], dest).bcx;\n+\n+    fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n+\n+    fcx.finish(bcx, DebugLoc::None);\n+\n+    ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n+\n+    lloncefn\n+}\n+\n /// Translates an adapter that implements the `Fn` trait for a fn\n /// pointer. This is basically the equivalent of something like:\n ///"}, {"sha": "a1d645fb993b01987d86ff513ab30608610808b1", "filename": "src/librustc_trans/closure.rs", "status": "removed", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/fd983d02e15909567303f92532671fb2b8374285/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd983d02e15909567303f92532671fb2b8374285/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=fd983d02e15909567303f92532671fb2b8374285", "patch": "@@ -1,319 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use arena::TypedArena;\n-use llvm::{self, ValueRef, get_params};\n-use rustc::hir::def_id::DefId;\n-use abi::{Abi, FnType};\n-use attributes;\n-use base::*;\n-use callee::{self, Callee};\n-use common::*;\n-use debuginfo::{DebugLoc};\n-use declare;\n-use monomorphize::{Instance};\n-use value::Value;\n-use rustc::ty::{self, Ty, TyCtxt};\n-\n-use rustc::hir;\n-\n-fn get_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           closure_id: DefId,\n-                           fn_ty: Ty<'tcx>)\n-                           -> Ty<'tcx> {\n-    match tcx.closure_kind(closure_id) {\n-        ty::ClosureKind::Fn => {\n-            tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), fn_ty)\n-        }\n-        ty::ClosureKind::FnMut => {\n-            tcx.mk_mut_ref(tcx.mk_region(ty::ReErased), fn_ty)\n-        }\n-        ty::ClosureKind::FnOnce => fn_ty,\n-    }\n-}\n-\n-/// Returns the LLVM function declaration for a closure, creating it if\n-/// necessary. If the ID does not correspond to a closure ID, returns None.\n-fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                               closure_id: DefId,\n-                                               substs: ty::ClosureSubsts<'tcx>)\n-                                               -> ValueRef {\n-    // Normalize type so differences in regions and typedefs don't cause\n-    // duplicate declarations\n-    let tcx = ccx.tcx();\n-    let substs = tcx.erase_regions(&substs);\n-    let instance = Instance::new(closure_id, substs.func_substs);\n-\n-    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n-        debug!(\"get_or_create_closure_declaration(): found closure {:?}: {:?}\",\n-               instance, Value(llfn));\n-        return llfn;\n-    }\n-\n-    let symbol = instance.symbol_name(ccx.shared());\n-\n-    // Compute the rust-call form of the closure call method.\n-    let sig = &tcx.closure_type(closure_id, substs).sig;\n-    let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n-    let closure_type = tcx.mk_closure_from_closure_substs(closure_id, substs);\n-    let function_type = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: hir::Unsafety::Normal,\n-        abi: Abi::RustCall,\n-        sig: ty::Binder(ty::FnSig {\n-            inputs: Some(get_self_type(tcx, closure_id, closure_type))\n-                        .into_iter().chain(sig.inputs).collect(),\n-            output: sig.output,\n-            variadic: false\n-        })\n-    }));\n-    let llfn = declare::declare_fn(ccx, &symbol, function_type);\n-\n-    attributes::set_frame_pointer_elimination(ccx, llfn);\n-\n-    debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n-            closure {:?}: {:?}\",\n-           instance, Value(llfn));\n-\n-    // NOTE: We do *not* store llfn in the ccx.instances() map here,\n-    //       that is only done, when the closures body is translated.\n-\n-    llfn\n-}\n-\n-pub fn trans_closure_body_via_mir<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                            closure_def_id: DefId,\n-                                            closure_substs: ty::ClosureSubsts<'tcx>) {\n-    // (*) Note that in the case of inlined functions, the `closure_def_id` will be the\n-    // defid of the closure in its original crate, whereas `id` will be the id of the local\n-    // inlined copy.\n-    debug!(\"trans_closure_body_via_mir(closure_def_id={:?}, closure_substs={:?})\",\n-           closure_def_id, closure_substs);\n-\n-    let tcx = ccx.tcx();\n-    let _icx = push_ctxt(\"closure::trans_closure_expr\");\n-\n-    let param_substs = closure_substs.func_substs;\n-    let instance = Instance::new(closure_def_id, param_substs);\n-\n-    // If we have not done so yet, translate this closure's body\n-    if  !ccx.instances().borrow().contains_key(&instance) {\n-        let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n-\n-        unsafe {\n-            if ccx.sess().target.target.options.allows_weak_linkage {\n-                llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::WeakODRLinkage);\n-                llvm::SetUniqueComdat(ccx.llmod(), llfn);\n-            } else {\n-                llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage);\n-            }\n-        }\n-\n-        // set an inline hint for all closures\n-        attributes::inline(llfn, attributes::InlineAttr::Hint);\n-\n-        // Get the type of this closure. Use the current `param_substs` as\n-        // the closure substitutions. This makes sense because the closure\n-        // takes the same set of type arguments as the enclosing fn, and\n-        // this function (`trans_closure`) is invoked at the point\n-        // of the closure expression.\n-\n-        let sig = &tcx.closure_type(closure_def_id, closure_substs).sig;\n-        let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n-\n-        let closure_type = tcx.mk_closure_from_closure_substs(closure_def_id,\n-                                                              closure_substs);\n-        let sig = ty::FnSig {\n-            inputs: Some(get_self_type(tcx, closure_def_id, closure_type))\n-                        .into_iter().chain(sig.inputs).collect(),\n-            output: sig.output,\n-            variadic: false\n-        };\n-\n-        trans_closure(ccx,\n-                      llfn,\n-                      Instance::new(closure_def_id, param_substs),\n-                      &sig,\n-                      Abi::RustCall);\n-\n-        ccx.instances().borrow_mut().insert(instance, llfn);\n-    }\n-}\n-\n-pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                                      closure_def_id: DefId,\n-                                      substs: ty::ClosureSubsts<'tcx>,\n-                                      method_instance: Instance<'tcx>,\n-                                      trait_closure_kind: ty::ClosureKind)\n-                                      -> ValueRef\n-{\n-    // If this is a closure, redirect to it.\n-    let llfn = get_or_create_closure_declaration(ccx, closure_def_id, substs);\n-\n-    // If weak linkage is not allowed, we have to make sure that a local,\n-    // private copy of the closure is available in this codegen unit\n-    if !ccx.sess().target.target.options.allows_weak_linkage &&\n-       !ccx.sess().opts.single_codegen_unit() {\n-\n-        trans_closure_body_via_mir(ccx, closure_def_id, substs);\n-    }\n-\n-    // If the closure is a Fn closure, but a FnOnce is needed (etc),\n-    // then adapt the self type\n-    let llfn_closure_kind = ccx.tcx().closure_kind(closure_def_id);\n-\n-    let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n-\n-    debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n-           trait_closure_kind={:?}, llfn={:?})\",\n-           llfn_closure_kind, trait_closure_kind, Value(llfn));\n-\n-    match (llfn_closure_kind, trait_closure_kind) {\n-        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n-            // No adapter needed.\n-            llfn\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n-            // `fn(&mut self, ...)`. In fact, at trans time, these are\n-            // basically the same thing, so we can just return llfn.\n-            llfn\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n-            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n-            // this by doing something like:\n-            //\n-            //     fn call_once(self, ...) { call_mut(&self, ...) }\n-            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n-            //\n-            // These are both the same at trans time.\n-            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, method_instance, llfn)\n-        }\n-        _ => {\n-            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n-                 llfn_closure_kind,\n-                 trait_closure_kind);\n-        }\n-    }\n-}\n-\n-fn trans_fn_once_adapter_shim<'a, 'tcx>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n-    closure_def_id: DefId,\n-    substs: ty::ClosureSubsts<'tcx>,\n-    method_instance: Instance<'tcx>,\n-    llreffn: ValueRef)\n-    -> ValueRef\n-{\n-    if let Some(&llfn) = ccx.instances().borrow().get(&method_instance) {\n-        return llfn;\n-    }\n-\n-    debug!(\"trans_fn_once_adapter_shim(closure_def_id={:?}, substs={:?}, llreffn={:?})\",\n-           closure_def_id, substs, Value(llreffn));\n-\n-    let tcx = ccx.tcx();\n-\n-    // Find a version of the closure type. Substitute static for the\n-    // region since it doesn't really matter.\n-    let closure_ty = tcx.mk_closure_from_closure_substs(closure_def_id, substs);\n-    let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), closure_ty);\n-\n-    // Make a version with the type of by-ref closure.\n-    let ty::ClosureTy { unsafety, abi, mut sig } =\n-        tcx.closure_type(closure_def_id, substs);\n-    sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n-    let llref_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: unsafety,\n-        abi: abi,\n-        sig: sig.clone()\n-    }));\n-    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n-           llref_fn_ty);\n-\n-\n-    // Make a version of the closure type with the same arguments, but\n-    // with argument #0 being by value.\n-    assert_eq!(abi, Abi::RustCall);\n-    sig.0.inputs[0] = closure_ty;\n-\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n-    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n-\n-    let llonce_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: unsafety,\n-        abi: abi,\n-        sig: ty::Binder(sig)\n-    }));\n-\n-    // Create the by-value helper.\n-    let function_name = method_instance.symbol_name(ccx.shared());\n-    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n-    attributes::set_frame_pointer_elimination(ccx, lloncefn);\n-\n-    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n-    block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, &block_arena);\n-    let mut bcx = fcx.init(false);\n-\n-\n-    // the first argument (`self`) will be the (by value) closure env.\n-\n-    let mut llargs = get_params(fcx.llfn);\n-    let mut self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n-    let env_arg = &fcx.fn_ty.args[0];\n-    let llenv = if env_arg.is_indirect() {\n-        llargs[self_idx]\n-    } else {\n-        let scratch = alloc_ty(bcx, closure_ty, \"self\");\n-        let mut llarg_idx = self_idx;\n-        env_arg.store_fn_arg(&bcx.build(), &mut llarg_idx, scratch);\n-        scratch\n-    };\n-\n-    debug!(\"trans_fn_once_adapter_shim: env={:?}\", Value(llenv));\n-    // Adjust llargs such that llargs[self_idx..] has the call arguments.\n-    // For zero-sized closures that means sneaking in a new argument.\n-    if env_arg.is_ignore() {\n-        if self_idx > 0 {\n-            self_idx -= 1;\n-            llargs[self_idx] = llenv;\n-        } else {\n-            llargs.insert(0, llenv);\n-        }\n-    } else {\n-        llargs[self_idx] = llenv;\n-    }\n-\n-    let dest = fcx.llretslotptr.get();\n-\n-    let callee = Callee {\n-        data: callee::Fn(llreffn),\n-        ty: llref_fn_ty\n-    };\n-\n-    // Call the by-ref closure body with `self` in a cleanup scope,\n-    // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = fcx.push_custom_cleanup_scope();\n-    fcx.schedule_drop_mem(self_scope, llenv, closure_ty);\n-\n-    bcx = callee.call(bcx, DebugLoc::None, &llargs[self_idx..], dest).bcx;\n-\n-    fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n-\n-    fcx.finish(bcx, DebugLoc::None);\n-\n-    ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n-\n-    lloncefn\n-}"}, {"sha": "2728a666556e43c90da4b4a7e665defe56647e02", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -446,24 +446,6 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         debug!(\"visiting rvalue {:?}\", *rvalue);\n \n         match *rvalue {\n-            mir::Rvalue::Aggregate(mir::AggregateKind::Closure(def_id,\n-                                                               ref substs), _) => {\n-                let mir = self.scx.tcx().item_mir(def_id);\n-\n-                let concrete_substs = monomorphize::apply_param_substs(self.scx,\n-                                                                       self.param_substs,\n-                                                                       &substs.func_substs);\n-                let concrete_substs = self.scx.tcx().erase_regions(&concrete_substs);\n-\n-                let visitor = MirNeighborCollector {\n-                    scx: self.scx,\n-                    mir: &mir,\n-                    output: self.output,\n-                    param_substs: concrete_substs\n-                };\n-\n-                visit_mir_and_promoted(visitor, &mir);\n-            }\n             // When doing an cast from a regular pointer to a fat pointer, we\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n@@ -797,8 +779,8 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        ty::TyClosure(_, substs) => {\n-            for upvar_ty in substs.upvar_tys {\n+        ty::TyClosure(def_id, substs) => {\n+            for upvar_ty in substs.upvar_tys(def_id, scx.tcx()) {\n                 let upvar_ty = glue::get_drop_glue_type(scx.tcx(), upvar_ty);\n                 if glue::type_needs_drop(scx.tcx(), upvar_ty) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(upvar_ty)));\n@@ -888,10 +870,12 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         traits::VtableImpl(impl_data) => {\n             Some(traits::find_method(tcx, trait_method.name, rcvr_substs, &impl_data))\n         }\n-        // If we have a closure or a function pointer, we will also encounter\n-        // the concrete closure/function somewhere else (during closure or fn\n-        // pointer construction). That's where we track those things.\n-        traits::VtableClosure(..) |\n+        traits::VtableClosure(closure_data) => {\n+            Some((closure_data.closure_def_id, closure_data.substs.substs))\n+        }\n+        // Trait object and function pointer shims are always\n+        // instantiated in-place, and as they are just an ABI-adjusting\n+        // indirect call they do not have any dependencies.\n         traits::VtableFnPointer(..) |\n         traits::VtableObject(..) => {\n             None"}, {"sha": "a0fac9cc6599eeaa9e98761e0e1360c3066c519d", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -44,6 +44,8 @@ use rustc::hir;\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n+use std::borrow::Cow;\n+use std::iter;\n use std::ops::Deref;\n use std::ffi::CString;\n use std::cell::{Cell, RefCell, Ref};\n@@ -109,7 +111,16 @@ pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n             Some([monomorphize::field_ty(ccx.tcx(), substs, &fields[0]),\n                   monomorphize::field_ty(ccx.tcx(), substs, &fields[1])])\n         }\n-        ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) |\n+        ty::TyClosure(def_id, substs) => {\n+            let mut tys = substs.upvar_tys(def_id, ccx.tcx());\n+            tys.next().and_then(|first_ty| tys.next().and_then(|second_ty| {\n+                if tys.next().is_some() {\n+                    None\n+                } else {\n+                    Some([first_ty, second_ty])\n+                }\n+            }))\n+        }\n         ty::TyTuple(tys) => {\n             if tys.len() != 2 {\n                 return None;\n@@ -1060,3 +1071,32 @@ pub fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }\n }\n+\n+pub fn ty_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                          ty: Ty<'tcx>)\n+                          -> Cow<'tcx, ty::BareFnTy<'tcx>>\n+{\n+    match ty.sty {\n+        ty::TyFnDef(_, _, fty) => Cow::Borrowed(fty),\n+        // Shims currently have type TyFnPtr. Not sure this should remain.\n+        ty::TyFnPtr(fty) => Cow::Borrowed(fty),\n+        ty::TyClosure(def_id, substs) => {\n+            let tcx = ccx.tcx();\n+            let ty::ClosureTy { unsafety, abi, sig } = tcx.closure_type(def_id, substs);\n+\n+            let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n+            let env_ty = match tcx.closure_kind(def_id) {\n+                ty::ClosureKind::Fn => tcx.mk_imm_ref(tcx.mk_region(env_region), ty),\n+                ty::ClosureKind::FnMut => tcx.mk_mut_ref(tcx.mk_region(env_region), ty),\n+                ty::ClosureKind::FnOnce => ty,\n+            };\n+\n+            let sig = sig.map_bound(|sig| ty::FnSig {\n+                inputs: iter::once(env_ty).chain(sig.inputs).collect(),\n+                ..sig\n+            });\n+            Cow::Owned(ty::BareFnTy { unsafety: unsafety, abi: abi, sig: sig })\n+        }\n+        _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)\n+    }\n+}"}, {"sha": "5b9ef78ddc22e86f0dd4abc5e112b74fa820415b", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -574,10 +574,11 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n \n         }\n-        ty::TyClosure(_, ref substs) => {\n+        ty::TyClosure(def_id, substs) => {\n+            let upvar_tys : Vec<_> = substs.upvar_tys(def_id, cx.tcx()).collect();\n             prepare_tuple_metadata(cx,\n                                    t,\n-                                   &substs.upvar_tys,\n+                                   &upvar_tys,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }"}, {"sha": "482275d298bc0e14c309f097669851dbec423b81", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -25,7 +25,6 @@ use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,\n                       FlagPrototyped};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::DefPathData;\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n@@ -248,21 +247,19 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n \n     // Find the enclosing function, in case this is a closure.\n-    let mut fn_def_id = instance.def;\n-    let mut def_key = cx.tcx().def_key(fn_def_id);\n+    let def_key = cx.tcx().def_key(instance.def);\n     let mut name = def_key.disambiguated_data.data.to_string();\n     let name_len = name.len();\n-    while def_key.disambiguated_data.data == DefPathData::ClosureExpr {\n-        fn_def_id.index = def_key.parent.expect(\"closure without a parent?\");\n-        def_key = cx.tcx().def_key(fn_def_id);\n-    }\n+\n+    let fn_def_id = cx.tcx().closure_base_def_id(instance.def);\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n     let generics = cx.tcx().item_generics(fn_def_id);\n+    let substs = instance.substs.truncate_to(cx.tcx(), generics);\n     let template_parameters = get_template_parameters(cx,\n                                                       &generics,\n-                                                      instance.substs,\n+                                                      substs,\n                                                       file_metadata,\n                                                       &mut name);\n "}, {"sha": "662e3bec66db874cad34a8920558e7bb0962f928", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -25,6 +25,7 @@ use rustc::ty;\n use abi::{Abi, FnType};\n use attributes;\n use context::CrateContext;\n+use common;\n use type_::Type;\n use value::Value;\n \n@@ -103,8 +104,8 @@ pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type) -> ValueRef {\n pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                             fn_type: ty::Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n-    let abi = fn_type.fn_abi();\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(fn_type.fn_sig());\n+    let ty::BareFnTy { abi, ref sig, .. } = *common::ty_fn_ty(ccx, fn_type);\n+    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n     let fty = FnType::new(ccx, abi, &sig, &[]);"}, {"sha": "d6d4d33923f1a91fb4529461eb54996c693bd2af", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -531,8 +531,8 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n     let mut cx = cx;\n     match t.sty {\n-        ty::TyClosure(_, ref substs) => {\n-            for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n+        ty::TyClosure(def_id, substs) => {\n+            for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n                 let llupvar = adt::trans_field_ptr(cx, t, value, Disr(0), i);\n                 cx = drop_ty(cx, llupvar, upvar_ty, DebugLoc::None);\n             }"}, {"sha": "0757343a8af574f6c390e17696be7170976fcaba", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -109,7 +109,6 @@ mod cabi_x86_64;\n mod cabi_x86_win64;\n mod callee;\n mod cleanup;\n-mod closure;\n mod collector;\n mod common;\n mod consts;"}, {"sha": "bca81fa36458f4726c2041d696148e1ed811e6fe", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -553,14 +553,6 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n                 failure?;\n \n-                // FIXME Shouldn't need to manually trigger closure instantiations.\n-                if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n-                    use closure;\n-                    closure::trans_closure_body_via_mir(self.ccx,\n-                                                        def_id,\n-                                                        self.monomorphize(&substs));\n-                }\n-\n                 match *kind {\n                     mir::AggregateKind::Array => {\n                         self.const_array(dest_ty, &fields)"}, {"sha": "12b17c26cbc41dbec9d3eb7a4b27bb67531b9fc6", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -470,8 +470,8 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n             } else {\n                 (arg_ty, false)\n             };\n-            let upvar_tys = if let ty::TyClosure(_, ref substs) = closure_ty.sty {\n-                &substs.upvar_tys[..]\n+            let upvar_tys = if let ty::TyClosure(def_id, substs) = closure_ty.sty {\n+                substs.upvar_tys(def_id, tcx)\n             } else {\n                 bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_ty);\n             };"}, {"sha": "bf01db0ffd3255eb7fa926b7bde38bb57333efcf", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -133,15 +133,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n                     },\n                     _ => {\n-                        // FIXME Shouldn't need to manually trigger closure instantiations.\n-                        if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n-                            use closure;\n-\n-                            closure::trans_closure_body_via_mir(bcx.ccx(),\n-                                                                def_id,\n-                                                                bcx.monomorphize(&substs));\n-                        }\n-\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields."}, {"sha": "c5a7dbbcf54800642c8ee202fd3bee7106a58621", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -166,6 +166,11 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n         }\n \n+        if let ty::TyClosure(..) = mono_ty.sty {\n+            // set an inline hint for all closures\n+            attributes::inline(lldecl, attributes::InlineAttr::Hint);\n+        }\n+\n         attributes::from_fn_attrs(ccx, &attrs, lldecl);\n \n         ccx.instances().borrow_mut().insert(instance, lldecl);\n@@ -477,12 +482,14 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 push_unique_type_name(tcx, sig.output, output);\n             }\n         },\n-        ty::TyClosure(def_id, ref closure_substs) => {\n+        ty::TyClosure(def_id, closure_substs) => {\n             push_item_name(tcx, def_id, output);\n             output.push_str(\"{\");\n             output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n             output.push_str(\"}\");\n-            push_type_params(tcx, closure_substs.func_substs, &[], output);\n+            let generics = tcx.item_generics(tcx.closure_base_def_id(def_id));\n+            let substs = closure_substs.substs.truncate_to(tcx, generics);\n+            push_type_params(tcx, substs, &[], output);\n         }\n         ty::TyError |\n         ty::TyInfer(_) |"}, {"sha": "75287d4064ae1df607a970ce8a9d1c12292e8df7", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -47,12 +47,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                      body: &'gcx hir::Expr,\n                      expected_sig: Option<ty::FnSig<'tcx>>)\n                      -> Ty<'tcx> {\n-        let expr_def_id = self.tcx.map.local_def_id(expr.id);\n-\n         debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n                opt_kind,\n                expected_sig);\n \n+        let expr_def_id = self.tcx.map.local_def_id(expr.id);\n         let mut fn_ty = AstConv::ty_of_closure(self,\n                                                hir::Unsafety::Normal,\n                                                decl,\n@@ -62,16 +61,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Create type variables (for now) to represent the transformed\n         // types of upvars. These will be unified during the upvar\n         // inference phase (`upvar.rs`).\n-        let num_upvars = self.tcx.with_freevars(expr.id, |fv| fv.len());\n-        let upvar_tys = self.next_ty_vars(num_upvars);\n-\n-        debug!(\"check_closure: expr.id={:?} upvar_tys={:?}\",\n-               expr.id,\n-               upvar_tys);\n-\n         let closure_type = self.tcx.mk_closure(expr_def_id,\n-                                               self.parameter_environment.free_substs,\n-                                               &upvar_tys);\n+            self.parameter_environment.free_substs.extend_to(self.tcx, expr_def_id,\n+                |_, _| span_bug!(expr.span, \"closure has region param\"),\n+                |_, _| self.infcx.next_ty_var()\n+            )\n+        );\n+\n+        debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n         let fn_sig = self.tcx\n             .liberate_late_bound_regions(self.tcx.region_maps.call_site_extent(expr.id, body.id),"}, {"sha": "09e1f6592c170d08c6831092198b2a5b7ed53d0e", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -482,8 +482,14 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n             Ok(())\n         }\n \n-        ty::TyTuple(tys) |\n-        ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) => {\n+        ty::TyClosure(def_id, substs) => {\n+            for ty in substs.upvar_tys(def_id, tcx) {\n+                iterate_over_potentially_unsafe_regions_in_type(cx, context, ty, depth+1)?\n+            }\n+            Ok(())\n+        }\n+\n+        ty::TyTuple(tys) => {\n             for ty in tys {\n                 iterate_over_potentially_unsafe_regions_in_type(cx, context, ty, depth+1)?\n             }"}, {"sha": "1ea47107c3b18cc9f88e974d5c62f29512d173a3", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -183,8 +183,8 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         // inference algorithm will reject it).\n \n         // Extract the type variables UV0...UVn.\n-        let closure_substs = match self.fcx.node_ty(id).sty {\n-            ty::TyClosure(_, ref substs) => substs,\n+        let (def_id, closure_substs) = match self.fcx.node_ty(id).sty {\n+            ty::TyClosure(def_id, substs) => (def_id, substs),\n             ref t => {\n                 span_bug!(\n                     span,\n@@ -197,7 +197,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         let final_upvar_tys = self.final_upvar_tys(id);\n         debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n                id, closure_substs, final_upvar_tys);\n-        for (&upvar_ty, final_upvar_ty) in closure_substs.upvar_tys.iter().zip(final_upvar_tys) {\n+        for (upvar_ty, final_upvar_ty) in\n+            closure_substs.upvar_tys(def_id, self.fcx.tcx).zip(final_upvar_tys)\n+        {\n             self.fcx.demand_eqtype(span, final_upvar_ty, upvar_ty);\n         }\n "}, {"sha": "816243b3eab47082312578736ac19e650bd6e908", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a277f9deb0bcccc096334447b0e57765110707c7/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a277f9deb0bcccc096334447b0e57765110707c7", "patch": "@@ -80,7 +80,7 @@ use std::cell::RefCell;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n use syntax::{abi, ast, attr};\n-use syntax::parse::token::keywords;\n+use syntax::parse::token::{self, keywords};\n use syntax_pos::Span;\n \n use rustc::hir::{self, intravisit, map as hir_map, print as pprust};\n@@ -134,6 +134,13 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx>\n         intravisit::walk_item(self, item);\n     }\n \n+    fn visit_expr(&mut self, expr: &hir::Expr) {\n+        if let hir::ExprClosure(..) = expr.node {\n+            convert_closure(self.ccx, expr.id);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyImplTrait(..) = ty.node {\n             let def_id = self.ccx.tcx.map.local_def_id(ty.id);\n@@ -559,6 +566,40 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ccx.tcx.predicates.borrow_mut().insert(def_id, struct_predicates.clone());\n }\n \n+fn convert_closure<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                             node_id: ast::NodeId)\n+{\n+    let tcx = ccx.tcx;\n+    let def_id = tcx.map.local_def_id(node_id);\n+    let base_def_id = tcx.closure_base_def_id(def_id);\n+    let base_generics = generics_of_def_id(ccx, base_def_id);\n+\n+    // provide junk type parameter defs - the only place that\n+    // cares about anything but the length is instantiation,\n+    // and we don't do that for closures.\n+    let upvar_decls : Vec<_> = tcx.with_freevars(node_id, |fv| {\n+        fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n+            index: (base_generics.count() as u32) + (i as u32),\n+            name: token::intern(\"<upvar>\"),\n+            def_id: def_id,\n+            default_def_id: base_def_id,\n+            default: None,\n+            object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n+            pure_wrt_drop: false,\n+        }).collect()\n+    });\n+    tcx.generics.borrow_mut().insert(def_id, tcx.alloc_generics(ty::Generics {\n+        parent: Some(base_def_id),\n+        parent_regions: base_generics.parent_regions + (base_generics.regions.len() as u32),\n+        parent_types: base_generics.parent_types + (base_generics.types.len() as u32),\n+        regions: vec![],\n+        types: upvar_decls,\n+        has_self: base_generics.has_self,\n+    }));\n+\n+    type_of_def_id(ccx, def_id);\n+}\n+\n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: AssociatedItemContainer,\n                             id: ast::NodeId,\n@@ -1504,6 +1545,13 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     }\n                 }\n             }\n+            NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+                ccx.tcx.mk_closure(def_id, Substs::for_item(\n+                    ccx.tcx, def_id,\n+                    |def, _| ccx.tcx.mk_region(def.to_early_bound_region()),\n+                    |def, _| ccx.tcx.mk_param_from_def(def)\n+                ))\n+            }\n             x => {\n                 bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n             }"}]}