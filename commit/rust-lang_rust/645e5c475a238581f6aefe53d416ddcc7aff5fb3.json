{"sha": "645e5c475a238581f6aefe53d416ddcc7aff5fb3", "node_id": "C_kwDOAAsO6NoAKDY0NWU1YzQ3NWEyMzg1ODFmNmFlZmU1M2Q0MTZkZGNjN2FmZjVmYjM", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-06-26T04:14:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-26T04:14:56Z"}, "message": "Rollup merge of #98371 - compiler-errors:better-opaque-printing, r=oli-obk\n\nFix printing `impl trait` under binders\n\nBefore, we would render `impl for<'a> Trait<'a>` like `impl Trait<for<'a> 'a>`, lol.", "tree": {"sha": "6b2e0f2b5ad3ae38d7c623473a63b24c945b64fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b2e0f2b5ad3ae38d7c623473a63b24c945b64fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/645e5c475a238581f6aefe53d416ddcc7aff5fb3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJit91ACRBK7hj4Ov3rIwAAp8YIAJchDpzY4BPwVFxsG17ZM2f3\nvw4Z8H/weK2GGf99DzachjtzIaLYm9lwnZ1tUk0ZfG3XXzVMmBPi4kPhKXIVB20z\nVaTBpABXI0FgEgLZ3kmaDMM+nF6C+vxB77bwNiHKZTtArNCIofoEOmRvDA5hkZVR\nK/OQ1UnRRc3b6QRMpRD/YFwHF9B9VbdtGgSvK2w+lZ9oXAn5qijWSMlChzDZAmQt\nslA6Cbx5Dohe2jjpdiNDm+VF6AfXNwjSvJz5kOZSKm1ELZ9Z1t3OfrqNnhx1ErcZ\nSvTB/1nPy7S4DDiFRlekI7W+LCRjbpifa6zOh9tfdvufTAb0M29J36XUPBGl6yM=\n=/Qc7\n-----END PGP SIGNATURE-----\n", "payload": "tree 6b2e0f2b5ad3ae38d7c623473a63b24c945b64fe\nparent 639a655e11306116e8507d401a1262e87e1b23b7\nparent e80ccedbaeeb5b97880d83ea95c79fc1d0dcf418\nauthor Yuki Okushi <jtitor@2k36.org> 1656216896 +0900\ncommitter GitHub <noreply@github.com> 1656216896 +0900\n\nRollup merge of #98371 - compiler-errors:better-opaque-printing, r=oli-obk\n\nFix printing `impl trait` under binders\n\nBefore, we would render `impl for<'a> Trait<'a>` like `impl Trait<for<'a> 'a>`, lol.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/645e5c475a238581f6aefe53d416ddcc7aff5fb3", "html_url": "https://github.com/rust-lang/rust/commit/645e5c475a238581f6aefe53d416ddcc7aff5fb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/645e5c475a238581f6aefe53d416ddcc7aff5fb3/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "639a655e11306116e8507d401a1262e87e1b23b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/639a655e11306116e8507d401a1262e87e1b23b7", "html_url": "https://github.com/rust-lang/rust/commit/639a655e11306116e8507d401a1262e87e1b23b7"}, {"sha": "e80ccedbaeeb5b97880d83ea95c79fc1d0dcf418", "url": "https://api.github.com/repos/rust-lang/rust/commits/e80ccedbaeeb5b97880d83ea95c79fc1d0dcf418", "html_url": "https://github.com/rust-lang/rust/commit/e80ccedbaeeb5b97880d83ea95c79fc1d0dcf418"}], "stats": {"total": 280, "additions": 166, "deletions": 114}, "files": [{"sha": "c56909ba18b143559e34418c949147fda55d516f", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 120, "deletions": 113, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/645e5c475a238581f6aefe53d416ddcc7aff5fb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645e5c475a238581f6aefe53d416ddcc7aff5fb3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=645e5c475a238581f6aefe53d416ddcc7aff5fb3", "patch": "@@ -226,7 +226,7 @@ pub trait PrettyPrinter<'tcx>:\n         value.as_ref().skip_binder().print(self)\n     }\n \n-    fn wrap_binder<T, F: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n+    fn wrap_binder<T, F: FnOnce(&T, Self) -> Result<Self, fmt::Error>>(\n         self,\n         value: &ty::Binder<'tcx, T>,\n         f: F,\n@@ -773,26 +773,26 @@ pub trait PrettyPrinter<'tcx>:\n         def_id: DefId,\n         substs: &'tcx ty::List<ty::GenericArg<'tcx>>,\n     ) -> Result<Self::Type, Self::Error> {\n-        define_scoped_cx!(self);\n+        let tcx = self.tcx();\n \n         // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n         // by looking up the projections associated with the def_id.\n-        let bounds = self.tcx().bound_explicit_item_bounds(def_id);\n+        let bounds = tcx.bound_explicit_item_bounds(def_id);\n \n         let mut traits = FxIndexMap::default();\n         let mut fn_traits = FxIndexMap::default();\n         let mut is_sized = false;\n \n         for predicate in bounds.transpose_iter().map(|e| e.map_bound(|(p, _)| *p)) {\n-            let predicate = predicate.subst(self.tcx(), substs);\n+            let predicate = predicate.subst(tcx, substs);\n             let bound_predicate = predicate.kind();\n \n             match bound_predicate.skip_binder() {\n                 ty::PredicateKind::Trait(pred) => {\n                     let trait_ref = bound_predicate.rebind(pred.trait_ref);\n \n                     // Don't print + Sized, but rather + ?Sized if absent.\n-                    if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n+                    if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n                         is_sized = true;\n                         continue;\n                     }\n@@ -801,7 +801,7 @@ pub trait PrettyPrinter<'tcx>:\n                 }\n                 ty::PredicateKind::Projection(pred) => {\n                     let proj_ref = bound_predicate.rebind(pred);\n-                    let trait_ref = proj_ref.required_poly_trait_ref(self.tcx());\n+                    let trait_ref = proj_ref.required_poly_trait_ref(tcx);\n \n                     // Projection type entry -- the def-id for naming, and the ty.\n                     let proj_ty = (proj_ref.projection_def_id(), proj_ref.term());\n@@ -817,148 +817,155 @@ pub trait PrettyPrinter<'tcx>:\n             }\n         }\n \n+        write!(self, \"impl \")?;\n+\n         let mut first = true;\n         // Insert parenthesis around (Fn(A, B) -> C) if the opaque ty has more than one other trait\n         let paren_needed = fn_traits.len() > 1 || traits.len() > 0 || !is_sized;\n \n-        p!(\"impl\");\n-\n         for (fn_once_trait_ref, entry) in fn_traits {\n-            // Get the (single) generic ty (the args) of this FnOnce trait ref.\n-            let generics = self.tcx().generics_of(fn_once_trait_ref.def_id());\n-            let args =\n-                generics.own_substs_no_defaults(self.tcx(), fn_once_trait_ref.skip_binder().substs);\n-\n-            match (entry.return_ty, args[0].expect_ty()) {\n-                // We can only print `impl Fn() -> ()` if we have a tuple of args and we recorded\n-                // a return type.\n-                (Some(return_ty), arg_tys) if matches!(arg_tys.kind(), ty::Tuple(_)) => {\n-                    let name = if entry.fn_trait_ref.is_some() {\n-                        \"Fn\"\n-                    } else if entry.fn_mut_trait_ref.is_some() {\n-                        \"FnMut\"\n-                    } else {\n-                        \"FnOnce\"\n-                    };\n+            write!(self, \"{}\", if first { \"\" } else { \" + \" })?;\n+            write!(self, \"{}\", if paren_needed { \"(\" } else { \"\" })?;\n \n-                    p!(\n-                        write(\"{}\", if first { \" \" } else { \" + \" }),\n-                        write(\"{}{}(\", if paren_needed { \"(\" } else { \"\" }, name)\n-                    );\n+            self = self.wrap_binder(&fn_once_trait_ref, |trait_ref, mut cx| {\n+                define_scoped_cx!(cx);\n+                // Get the (single) generic ty (the args) of this FnOnce trait ref.\n+                let generics = tcx.generics_of(trait_ref.def_id);\n+                let args = generics.own_substs_no_defaults(tcx, trait_ref.substs);\n+\n+                match (entry.return_ty, args[0].expect_ty()) {\n+                    // We can only print `impl Fn() -> ()` if we have a tuple of args and we recorded\n+                    // a return type.\n+                    (Some(return_ty), arg_tys) if matches!(arg_tys.kind(), ty::Tuple(_)) => {\n+                        let name = if entry.fn_trait_ref.is_some() {\n+                            \"Fn\"\n+                        } else if entry.fn_mut_trait_ref.is_some() {\n+                            \"FnMut\"\n+                        } else {\n+                            \"FnOnce\"\n+                        };\n \n-                    for (idx, ty) in arg_tys.tuple_fields().iter().enumerate() {\n-                        if idx > 0 {\n-                            p!(\", \");\n+                        p!(write(\"{}(\", name));\n+\n+                        for (idx, ty) in arg_tys.tuple_fields().iter().enumerate() {\n+                            if idx > 0 {\n+                                p!(\", \");\n+                            }\n+                            p!(print(ty));\n                         }\n-                        p!(print(ty));\n-                    }\n \n-                    p!(\")\");\n-                    if let Term::Ty(ty) = return_ty.skip_binder() {\n-                        if !ty.is_unit() {\n-                            p!(\" -> \", print(return_ty));\n+                        p!(\")\");\n+                        if let Term::Ty(ty) = return_ty.skip_binder() {\n+                            if !ty.is_unit() {\n+                                p!(\" -> \", print(return_ty));\n+                            }\n                         }\n-                    }\n-                    p!(write(\"{}\", if paren_needed { \")\" } else { \"\" }));\n+                        p!(write(\"{}\", if paren_needed { \")\" } else { \"\" }));\n \n-                    first = false;\n-                }\n-                // If we got here, we can't print as a `impl Fn(A, B) -> C`. Just record the\n-                // trait_refs we collected in the OpaqueFnEntry as normal trait refs.\n-                _ => {\n-                    if entry.has_fn_once {\n-                        traits.entry(fn_once_trait_ref).or_default().extend(\n-                            // Group the return ty with its def id, if we had one.\n-                            entry\n-                                .return_ty\n-                                .map(|ty| (self.tcx().lang_items().fn_once_output().unwrap(), ty)),\n-                        );\n-                    }\n-                    if let Some(trait_ref) = entry.fn_mut_trait_ref {\n-                        traits.entry(trait_ref).or_default();\n+                        first = false;\n                     }\n-                    if let Some(trait_ref) = entry.fn_trait_ref {\n-                        traits.entry(trait_ref).or_default();\n+                    // If we got here, we can't print as a `impl Fn(A, B) -> C`. Just record the\n+                    // trait_refs we collected in the OpaqueFnEntry as normal trait refs.\n+                    _ => {\n+                        if entry.has_fn_once {\n+                            traits.entry(fn_once_trait_ref).or_default().extend(\n+                                // Group the return ty with its def id, if we had one.\n+                                entry\n+                                    .return_ty\n+                                    .map(|ty| (tcx.lang_items().fn_once_output().unwrap(), ty)),\n+                            );\n+                        }\n+                        if let Some(trait_ref) = entry.fn_mut_trait_ref {\n+                            traits.entry(trait_ref).or_default();\n+                        }\n+                        if let Some(trait_ref) = entry.fn_trait_ref {\n+                            traits.entry(trait_ref).or_default();\n+                        }\n                     }\n                 }\n-            }\n+\n+                Ok(cx)\n+            })?;\n         }\n \n         // Print the rest of the trait types (that aren't Fn* family of traits)\n         for (trait_ref, assoc_items) in traits {\n-            p!(\n-                write(\"{}\", if first { \" \" } else { \" + \" }),\n-                print(trait_ref.skip_binder().print_only_trait_name())\n-            );\n+            write!(self, \"{}\", if first { \"\" } else { \" + \" })?;\n+\n+            self = self.wrap_binder(&trait_ref, |trait_ref, mut cx| {\n+                define_scoped_cx!(cx);\n+                p!(print(trait_ref.print_only_trait_name()));\n \n-            let generics = self.tcx().generics_of(trait_ref.def_id());\n-            let args = generics.own_substs_no_defaults(self.tcx(), trait_ref.skip_binder().substs);\n+                let generics = tcx.generics_of(trait_ref.def_id);\n+                let args = generics.own_substs_no_defaults(tcx, trait_ref.substs);\n \n-            if !args.is_empty() || !assoc_items.is_empty() {\n-                let mut first = true;\n+                if !args.is_empty() || !assoc_items.is_empty() {\n+                    let mut first = true;\n \n-                for ty in args {\n-                    if first {\n-                        p!(\"<\");\n-                        first = false;\n-                    } else {\n-                        p!(\", \");\n+                    for ty in args {\n+                        if first {\n+                            p!(\"<\");\n+                            first = false;\n+                        } else {\n+                            p!(\", \");\n+                        }\n+                        p!(print(ty));\n                     }\n-                    p!(print(trait_ref.rebind(*ty)));\n-                }\n \n-                for (assoc_item_def_id, term) in assoc_items {\n-                    // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks,\n-                    // unless we can find out what generator return type it comes from.\n-                    let term = if let Some(ty) = term.skip_binder().ty()\n-                        && let ty::Projection(ty::ProjectionTy { item_def_id, substs }) = ty.kind()\n-                        && Some(*item_def_id) == self.tcx().lang_items().generator_return()\n-                    {\n-                        if let ty::Generator(_, substs, _) = substs.type_at(0).kind() {\n-                            let return_ty = substs.as_generator().return_ty();\n-                            if !return_ty.is_ty_infer() {\n-                                return_ty.into()\n+                    for (assoc_item_def_id, term) in assoc_items {\n+                        // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks,\n+                        // unless we can find out what generator return type it comes from.\n+                        let term = if let Some(ty) = term.skip_binder().ty()\n+                            && let ty::Projection(ty::ProjectionTy { item_def_id, substs }) = ty.kind()\n+                            && Some(*item_def_id) == tcx.lang_items().generator_return()\n+                        {\n+                            if let ty::Generator(_, substs, _) = substs.type_at(0).kind() {\n+                                let return_ty = substs.as_generator().return_ty();\n+                                if !return_ty.is_ty_infer() {\n+                                    return_ty.into()\n+                                } else {\n+                                    continue;\n+                                }\n                             } else {\n                                 continue;\n                             }\n                         } else {\n-                            continue;\n-                        }\n-                    } else {\n-                        term.skip_binder()\n-                    };\n+                            term.skip_binder()\n+                        };\n \n-                    if first {\n-                        p!(\"<\");\n-                        first = false;\n-                    } else {\n-                        p!(\", \");\n-                    }\n+                        if first {\n+                            p!(\"<\");\n+                            first = false;\n+                        } else {\n+                            p!(\", \");\n+                        }\n \n-                    p!(write(\"{} = \", self.tcx().associated_item(assoc_item_def_id).name));\n+                        p!(write(\"{} = \", tcx.associated_item(assoc_item_def_id).name));\n \n-                    match term {\n-                        Term::Ty(ty) => {\n-                            p!(print(ty))\n-                        }\n-                        Term::Const(c) => {\n-                            p!(print(c));\n-                        }\n-                    };\n-                }\n+                        match term {\n+                            Term::Ty(ty) => {\n+                                p!(print(ty))\n+                            }\n+                            Term::Const(c) => {\n+                                p!(print(c));\n+                            }\n+                        };\n+                    }\n \n-                if !first {\n-                    p!(\">\");\n+                    if !first {\n+                        p!(\">\");\n+                    }\n                 }\n-            }\n \n-            first = false;\n+                first = false;\n+                Ok(cx)\n+            })?;\n         }\n \n         if !is_sized {\n-            p!(write(\"{}?Sized\", if first { \" \" } else { \" + \" }));\n+            write!(self, \"{}?Sized\", if first { \"\" } else { \" + \" })?;\n         } else if first {\n-            p!(\" Sized\");\n+            write!(self, \"Sized\")?;\n         }\n \n         Ok(self)\n@@ -1869,7 +1876,7 @@ impl<'tcx> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx> {\n         self.pretty_in_binder(value)\n     }\n \n-    fn wrap_binder<T, C: Fn(&T, Self) -> Result<Self, Self::Error>>(\n+    fn wrap_binder<T, C: FnOnce(&T, Self) -> Result<Self, Self::Error>>(\n         self,\n         value: &ty::Binder<'tcx, T>,\n         f: C,\n@@ -2256,7 +2263,7 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         Ok(inner)\n     }\n \n-    pub fn pretty_wrap_binder<T, C: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n+    pub fn pretty_wrap_binder<T, C: FnOnce(&T, Self) -> Result<Self, fmt::Error>>(\n         self,\n         value: &ty::Binder<'tcx, T>,\n         f: C,"}, {"sha": "e9b76b19dc4075d32d8100dd70b29dcef7b0b6ad", "filename": "src/test/ui/async-await/issue-70935-complex-spans.drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/645e5c475a238581f6aefe53d416ddcc7aff5fb3/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/645e5c475a238581f6aefe53d416ddcc7aff5fb3/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr?ref=645e5c475a238581f6aefe53d416ddcc7aff5fb3", "patch": "@@ -22,7 +22,7 @@ LL |   async fn baz<T>(_c: impl FnMut() -> T) where T: Future<Output=()> {\n LL | |\n LL | | }\n    | |_^\n-   = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = ()>`, `()`\n+   = note: required because it captures the following types: `ResumeTy`, `impl for<'r, 's, 't0> Future<Output = ()>`, `()`\n note: required because it's used within this `async` block\n   --> $DIR/issue-70935-complex-spans.rs:23:16\n    |"}, {"sha": "273b5dcdb098545f91f83bf01d7db6a47598fe66", "filename": "src/test/ui/impl-trait/printing-binder.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/645e5c475a238581f6aefe53d416ddcc7aff5fb3/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645e5c475a238581f6aefe53d416ddcc7aff5fb3/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.rs?ref=645e5c475a238581f6aefe53d416ddcc7aff5fb3", "patch": "@@ -0,0 +1,14 @@\n+trait Trait<'a> {}\n+impl<T> Trait<'_> for T {}\n+fn whatever() -> impl for<'a> Trait<'a> + for<'b> Trait<'b> {}\n+\n+fn whatever2() -> impl for<'c> Fn(&'c ()) {\n+    |_: &()| {}\n+}\n+\n+fn main() {\n+    let x: u32 = whatever();\n+    //~^ ERROR mismatched types\n+    let x2: u32 = whatever2();\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "5ffec8af1028915defdee18a6ab16434e8ea1bc9", "filename": "src/test/ui/impl-trait/printing-binder.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/645e5c475a238581f6aefe53d416ddcc7aff5fb3/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/645e5c475a238581f6aefe53d416ddcc7aff5fb3/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.stderr?ref=645e5c475a238581f6aefe53d416ddcc7aff5fb3", "patch": "@@ -0,0 +1,31 @@\n+error[E0308]: mismatched types\n+  --> $DIR/printing-binder.rs:10:18\n+   |\n+LL | fn whatever() -> impl for<'a> Trait<'a> + for<'b> Trait<'b> {}\n+   |                  ------------------------------------------ the found opaque type\n+...\n+LL |     let x: u32 = whatever();\n+   |            ---   ^^^^^^^^^^ expected `u32`, found opaque type\n+   |            |\n+   |            expected due to this\n+   |\n+   = note:     expected type `u32`\n+           found opaque type `impl for<'a> Trait<'a> + for<'b> Trait<'b>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/printing-binder.rs:12:19\n+   |\n+LL | fn whatever2() -> impl for<'c> Fn(&'c ()) {\n+   |                   ----------------------- the found opaque type\n+...\n+LL |     let x2: u32 = whatever2();\n+   |             ---   ^^^^^^^^^^^ expected `u32`, found opaque type\n+   |             |\n+   |             expected due to this\n+   |\n+   = note:     expected type `u32`\n+           found opaque type `impl for<'c> Fn(&'c ())`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}