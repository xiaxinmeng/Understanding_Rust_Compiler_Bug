{"sha": "c5189a22ccf4c28e309e4189defbb88b83bb2aea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MTg5YTIyY2NmNGMyOGUzMDllNDE4OWRlZmJiODhiODNiYjJhZWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-08T19:16:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-08T19:16:05Z"}, "message": "Merge #7923\n\n7923: Remove useless code_model indirection r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "a9eccedac7905ac3b6d6608b4607241ddefe6a63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9eccedac7905ac3b6d6608b4607241ddefe6a63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5189a22ccf4c28e309e4189defbb88b83bb2aea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgRnf1CRBK7hj4Ov3rIwAAdHIIAKY2RC2tb/vrFB7kgXYb6q//\nSTzawxWqwKZoK4fn33gh6LTpSqyN2LH9EIN7uKWHzr3TM3zY8TQNw6fsrZ2Ep5TT\nAhXoHkRSB9V7kVBxQh3Vvrz4v5gn60kQN/cxbqbUGRokShvjiBheE1cshvmu9Z7b\nOzOpJHVtrXnSiwoyUw0P4lLSZKMglwP5/0fip4qD2SVdC/TO07OznDp2MuDD2wwf\nnm2LZZqzwbk+kDchYqveeLw9tAeHYPx6GbWOJ5qTRxf8F/8CAqr5mT2/HmXt1lCr\nn2VBkm9k0TVbZaYxz0rheuQXZMYUJiErzZWbmjbMGQhky6DaPqsfuV3e/ujjUno=\n=Am4M\n-----END PGP SIGNATURE-----\n", "payload": "tree a9eccedac7905ac3b6d6608b4607241ddefe6a63\nparent 8b7e82b012c417ec40a896203ad79f20cf5530ef\nparent 9faf8dd69a819e50b9c973857fe324d7605e2d24\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615230965 +0000\ncommitter GitHub <noreply@github.com> 1615230965 +0000\n\nMerge #7923\n\n7923: Remove useless code_model indirection r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5189a22ccf4c28e309e4189defbb88b83bb2aea", "html_url": "https://github.com/rust-lang/rust/commit/c5189a22ccf4c28e309e4189defbb88b83bb2aea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5189a22ccf4c28e309e4189defbb88b83bb2aea/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b7e82b012c417ec40a896203ad79f20cf5530ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b7e82b012c417ec40a896203ad79f20cf5530ef", "html_url": "https://github.com/rust-lang/rust/commit/8b7e82b012c417ec40a896203ad79f20cf5530ef"}, {"sha": "9faf8dd69a819e50b9c973857fe324d7605e2d24", "url": "https://api.github.com/repos/rust-lang/rust/commits/9faf8dd69a819e50b9c973857fe324d7605e2d24", "html_url": "https://github.com/rust-lang/rust/commit/9faf8dd69a819e50b9c973857fe324d7605e2d24"}], "stats": {"total": 4269, "additions": 2131, "deletions": 2138}, "files": [{"sha": "9ee4b3059b90485d885ffba97a49adcb67e5f926", "filename": "crates/hir/src/code_model.rs", "status": "removed", "additions": 0, "deletions": 2095, "changes": 2095, "blob_url": "https://github.com/rust-lang/rust/blob/8b7e82b012c417ec40a896203ad79f20cf5530ef/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b7e82b012c417ec40a896203ad79f20cf5530ef/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=8b7e82b012c417ec40a896203ad79f20cf5530ef", "patch": "@@ -1,2095 +0,0 @@\n-//! FIXME: write short doc here\n-use std::{iter, sync::Arc};\n-\n-use arrayvec::ArrayVec;\n-use base_db::{CrateDisplayName, CrateId, Edition, FileId};\n-use either::Either;\n-use hir_def::{\n-    adt::{ReprKind, StructKind, VariantData},\n-    expr::{BindingAnnotation, LabelId, Pat, PatId},\n-    import_map,\n-    item_tree::ItemTreeNode,\n-    lang_item::LangItemTarget,\n-    path::ModPath,\n-    per_ns::PerNs,\n-    resolver::{HasResolver, Resolver},\n-    src::HasSource as _,\n-    type_ref::TypeRef,\n-    AdtId, AssocContainerId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId,\n-    DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule, ImplId, LifetimeParamId,\n-    LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeParamId, UnionId,\n-};\n-use hir_def::{find_path::PrefixKind, item_scope::ItemInNs, visibility::Visibility};\n-use hir_expand::{\n-    diagnostics::DiagnosticSink,\n-    name::{name, AsName},\n-    MacroDefId, MacroDefKind,\n-};\n-use hir_ty::{\n-    autoderef,\n-    display::{write_bounds_like_dyn_trait_with_prefix, HirDisplayError, HirFormatter},\n-    method_resolution,\n-    traits::{FnTrait, Solution, SolutionVariables},\n-    AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, DebruijnIndex, GenericPredicate,\n-    InEnvironment, Mutability, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs,\n-    TraitEnvironment, Ty, TyDefId, TyVariableKind,\n-};\n-use rustc_hash::FxHashSet;\n-use stdx::{format_to, impl_from};\n-use syntax::{\n-    ast::{self, AttrsOwner, NameOwner},\n-    AstNode, SmolStr,\n-};\n-use tt::{Ident, Leaf, Literal, TokenTree};\n-\n-use crate::{\n-    db::{DefDatabase, HirDatabase},\n-    has_source::HasSource,\n-    HirDisplay, InFile, Name,\n-};\n-\n-/// hir::Crate describes a single crate. It's the main interface with which\n-/// a crate's dependencies interact. Mostly, it should be just a proxy for the\n-/// root module.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Crate {\n-    pub(crate) id: CrateId,\n-}\n-\n-#[derive(Debug)]\n-pub struct CrateDependency {\n-    pub krate: Crate,\n-    pub name: Name,\n-}\n-\n-impl Crate {\n-    pub fn dependencies(self, db: &dyn HirDatabase) -> Vec<CrateDependency> {\n-        db.crate_graph()[self.id]\n-            .dependencies\n-            .iter()\n-            .map(|dep| {\n-                let krate = Crate { id: dep.crate_id };\n-                let name = dep.as_name();\n-                CrateDependency { krate, name }\n-            })\n-            .collect()\n-    }\n-\n-    // FIXME: add `transitive_reverse_dependencies`.\n-    pub fn reverse_dependencies(self, db: &dyn HirDatabase) -> Vec<Crate> {\n-        let crate_graph = db.crate_graph();\n-        crate_graph\n-            .iter()\n-            .filter(|&krate| {\n-                crate_graph[krate].dependencies.iter().any(|it| it.crate_id == self.id)\n-            })\n-            .map(|id| Crate { id })\n-            .collect()\n-    }\n-\n-    pub fn root_module(self, db: &dyn HirDatabase) -> Module {\n-        let def_map = db.crate_def_map(self.id);\n-        Module { id: def_map.module_id(def_map.root()) }\n-    }\n-\n-    pub fn root_file(self, db: &dyn HirDatabase) -> FileId {\n-        db.crate_graph()[self.id].root_file_id\n-    }\n-\n-    pub fn edition(self, db: &dyn HirDatabase) -> Edition {\n-        db.crate_graph()[self.id].edition\n-    }\n-\n-    pub fn display_name(self, db: &dyn HirDatabase) -> Option<CrateDisplayName> {\n-        db.crate_graph()[self.id].display_name.clone()\n-    }\n-\n-    pub fn query_external_importables(\n-        self,\n-        db: &dyn DefDatabase,\n-        query: import_map::Query,\n-    ) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n-        import_map::search_dependencies(db, self.into(), query).into_iter().map(|item| match item {\n-            ItemInNs::Types(mod_id) | ItemInNs::Values(mod_id) => Either::Left(mod_id.into()),\n-            ItemInNs::Macros(mac_id) => Either::Right(mac_id.into()),\n-        })\n-    }\n-\n-    pub fn all(db: &dyn HirDatabase) -> Vec<Crate> {\n-        db.crate_graph().iter().map(|id| Crate { id }).collect()\n-    }\n-\n-    /// Try to get the root URL of the documentation of a crate.\n-    pub fn get_html_root_url(self: &Crate, db: &dyn HirDatabase) -> Option<String> {\n-        // Look for #![doc(html_root_url = \"...\")]\n-        let attrs = db.attrs(AttrDefId::ModuleId(self.root_module(db).into()));\n-        let doc_attr_q = attrs.by_key(\"doc\");\n-\n-        if !doc_attr_q.exists() {\n-            return None;\n-        }\n-\n-        let doc_url = doc_attr_q.tt_values().map(|tt| {\n-            let name = tt.token_trees.iter()\n-                .skip_while(|tt| !matches!(tt, TokenTree::Leaf(Leaf::Ident(Ident{text: ref ident, ..})) if ident == \"html_root_url\"))\n-                .skip(2)\n-                .next();\n-\n-            match name {\n-                Some(TokenTree::Leaf(Leaf::Literal(Literal{ref text, ..}))) => Some(text),\n-                _ => None\n-            }\n-        }).flat_map(|t| t).next();\n-\n-        doc_url.map(|s| s.trim_matches('\"').trim_end_matches('/').to_owned() + \"/\")\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Module {\n-    pub(crate) id: ModuleId,\n-}\n-\n-/// The defs which can be visible in the module.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum ModuleDef {\n-    Module(Module),\n-    Function(Function),\n-    Adt(Adt),\n-    // Can't be directly declared, but can be imported.\n-    Variant(Variant),\n-    Const(Const),\n-    Static(Static),\n-    Trait(Trait),\n-    TypeAlias(TypeAlias),\n-    BuiltinType(BuiltinType),\n-}\n-impl_from!(\n-    Module,\n-    Function,\n-    Adt(Struct, Enum, Union),\n-    Variant,\n-    Const,\n-    Static,\n-    Trait,\n-    TypeAlias,\n-    BuiltinType\n-    for ModuleDef\n-);\n-\n-impl From<VariantDef> for ModuleDef {\n-    fn from(var: VariantDef) -> Self {\n-        match var {\n-            VariantDef::Struct(t) => Adt::from(t).into(),\n-            VariantDef::Union(t) => Adt::from(t).into(),\n-            VariantDef::Variant(t) => t.into(),\n-        }\n-    }\n-}\n-\n-impl ModuleDef {\n-    pub fn module(self, db: &dyn HirDatabase) -> Option<Module> {\n-        match self {\n-            ModuleDef::Module(it) => it.parent(db),\n-            ModuleDef::Function(it) => Some(it.module(db)),\n-            ModuleDef::Adt(it) => Some(it.module(db)),\n-            ModuleDef::Variant(it) => Some(it.module(db)),\n-            ModuleDef::Const(it) => Some(it.module(db)),\n-            ModuleDef::Static(it) => Some(it.module(db)),\n-            ModuleDef::Trait(it) => Some(it.module(db)),\n-            ModuleDef::TypeAlias(it) => Some(it.module(db)),\n-            ModuleDef::BuiltinType(_) => None,\n-        }\n-    }\n-\n-    pub fn canonical_path(&self, db: &dyn HirDatabase) -> Option<String> {\n-        let mut segments = Vec::new();\n-        segments.push(self.name(db)?.to_string());\n-        for m in self.module(db)?.path_to_root(db) {\n-            segments.extend(m.name(db).map(|it| it.to_string()))\n-        }\n-        segments.reverse();\n-        Some(segments.join(\"::\"))\n-    }\n-\n-    pub fn definition_visibility(&self, db: &dyn HirDatabase) -> Option<Visibility> {\n-        let module = match self {\n-            ModuleDef::Module(it) => it.parent(db)?,\n-            ModuleDef::Function(it) => return Some(it.visibility(db)),\n-            ModuleDef::Adt(it) => it.module(db),\n-            ModuleDef::Variant(it) => {\n-                let parent = it.parent_enum(db);\n-                let module = it.module(db);\n-                return module.visibility_of(db, &ModuleDef::Adt(Adt::Enum(parent)));\n-            }\n-            ModuleDef::Const(it) => return Some(it.visibility(db)),\n-            ModuleDef::Static(it) => it.module(db),\n-            ModuleDef::Trait(it) => it.module(db),\n-            ModuleDef::TypeAlias(it) => return Some(it.visibility(db)),\n-            ModuleDef::BuiltinType(_) => return None,\n-        };\n-\n-        module.visibility_of(db, self)\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        match self {\n-            ModuleDef::Adt(it) => Some(it.name(db)),\n-            ModuleDef::Trait(it) => Some(it.name(db)),\n-            ModuleDef::Function(it) => Some(it.name(db)),\n-            ModuleDef::Variant(it) => Some(it.name(db)),\n-            ModuleDef::TypeAlias(it) => Some(it.name(db)),\n-            ModuleDef::Module(it) => it.name(db),\n-            ModuleDef::Const(it) => it.name(db),\n-            ModuleDef::Static(it) => it.name(db),\n-\n-            ModuleDef::BuiltinType(it) => Some(it.name()),\n-        }\n-    }\n-\n-    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n-        let id = match self {\n-            ModuleDef::Adt(it) => match it {\n-                Adt::Struct(it) => it.id.into(),\n-                Adt::Enum(it) => it.id.into(),\n-                Adt::Union(it) => it.id.into(),\n-            },\n-            ModuleDef::Trait(it) => it.id.into(),\n-            ModuleDef::Function(it) => it.id.into(),\n-            ModuleDef::TypeAlias(it) => it.id.into(),\n-            ModuleDef::Module(it) => it.id.into(),\n-            ModuleDef::Const(it) => it.id.into(),\n-            ModuleDef::Static(it) => it.id.into(),\n-            _ => return,\n-        };\n-\n-        let module = match self.module(db) {\n-            Some(it) => it,\n-            None => return,\n-        };\n-\n-        hir_ty::diagnostics::validate_module_item(db, module.id.krate(), id, sink)\n-    }\n-}\n-\n-impl Module {\n-    /// Name of this module.\n-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        let def_map = self.id.def_map(db.upcast());\n-        let parent = def_map[self.id.local_id].parent?;\n-        def_map[parent].children.iter().find_map(|(name, module_id)| {\n-            if *module_id == self.id.local_id {\n-                Some(name.clone())\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    /// Returns the crate this module is part of.\n-    pub fn krate(self) -> Crate {\n-        Crate { id: self.id.krate() }\n-    }\n-\n-    /// Topmost parent of this module. Every module has a `crate_root`, but some\n-    /// might be missing `krate`. This can happen if a module's file is not included\n-    /// in the module tree of any target in `Cargo.toml`.\n-    pub fn crate_root(self, db: &dyn HirDatabase) -> Module {\n-        let def_map = db.crate_def_map(self.id.krate());\n-        Module { id: def_map.module_id(def_map.root()) }\n-    }\n-\n-    /// Iterates over all child modules.\n-    pub fn children(self, db: &dyn HirDatabase) -> impl Iterator<Item = Module> {\n-        let def_map = self.id.def_map(db.upcast());\n-        let children = def_map[self.id.local_id]\n-            .children\n-            .iter()\n-            .map(|(_, module_id)| Module { id: def_map.module_id(*module_id) })\n-            .collect::<Vec<_>>();\n-        children.into_iter()\n-    }\n-\n-    /// Finds a parent module.\n-    pub fn parent(self, db: &dyn HirDatabase) -> Option<Module> {\n-        // FIXME: handle block expressions as modules (their parent is in a different DefMap)\n-        let def_map = self.id.def_map(db.upcast());\n-        let parent_id = def_map[self.id.local_id].parent?;\n-        Some(Module { id: def_map.module_id(parent_id) })\n-    }\n-\n-    pub fn path_to_root(self, db: &dyn HirDatabase) -> Vec<Module> {\n-        let mut res = vec![self];\n-        let mut curr = self;\n-        while let Some(next) = curr.parent(db) {\n-            res.push(next);\n-            curr = next\n-        }\n-        res\n-    }\n-\n-    /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(\n-        self,\n-        db: &dyn HirDatabase,\n-        visible_from: Option<Module>,\n-    ) -> Vec<(Name, ScopeDef)> {\n-        self.id.def_map(db.upcast())[self.id.local_id]\n-            .scope\n-            .entries()\n-            .filter_map(|(name, def)| {\n-                if let Some(m) = visible_from {\n-                    let filtered =\n-                        def.filter_visibility(|vis| vis.is_visible_from(db.upcast(), m.id));\n-                    if filtered.is_none() && !def.is_none() {\n-                        None\n-                    } else {\n-                        Some((name, filtered))\n-                    }\n-                } else {\n-                    Some((name, def))\n-                }\n-            })\n-            .flat_map(|(name, def)| {\n-                ScopeDef::all_items(def).into_iter().map(move |item| (name.clone(), item))\n-            })\n-            .collect()\n-    }\n-\n-    pub fn visibility_of(self, db: &dyn HirDatabase, def: &ModuleDef) -> Option<Visibility> {\n-        self.id.def_map(db.upcast())[self.id.local_id].scope.visibility_of(def.clone().into())\n-    }\n-\n-    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n-        let _p = profile::span(\"Module::diagnostics\").detail(|| {\n-            format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n-        });\n-        let def_map = self.id.def_map(db.upcast());\n-        def_map.add_diagnostics(db.upcast(), self.id.local_id, sink);\n-        for decl in self.declarations(db) {\n-            match decl {\n-                crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n-                crate::ModuleDef::Module(m) => {\n-                    // Only add diagnostics from inline modules\n-                    if def_map[m.id.local_id].origin.is_inline() {\n-                        m.diagnostics(db, sink)\n-                    }\n-                }\n-                _ => {\n-                    decl.diagnostics(db, sink);\n-                }\n-            }\n-        }\n-\n-        for impl_def in self.impl_defs(db) {\n-            for item in impl_def.items(db) {\n-                if let AssocItem::Function(f) = item {\n-                    f.diagnostics(db, sink);\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn declarations(self, db: &dyn HirDatabase) -> Vec<ModuleDef> {\n-        let def_map = self.id.def_map(db.upcast());\n-        def_map[self.id.local_id].scope.declarations().map(ModuleDef::from).collect()\n-    }\n-\n-    pub fn impl_defs(self, db: &dyn HirDatabase) -> Vec<Impl> {\n-        let def_map = self.id.def_map(db.upcast());\n-        def_map[self.id.local_id].scope.impls().map(Impl::from).collect()\n-    }\n-\n-    /// Finds a path that can be used to refer to the given item from within\n-    /// this module, if possible.\n-    pub fn find_use_path(self, db: &dyn DefDatabase, item: impl Into<ItemInNs>) -> Option<ModPath> {\n-        hir_def::find_path::find_path(db, item.into(), self.into())\n-    }\n-\n-    /// Finds a path that can be used to refer to the given item from within\n-    /// this module, if possible. This is used for returning import paths for use-statements.\n-    pub fn find_use_path_prefixed(\n-        self,\n-        db: &dyn DefDatabase,\n-        item: impl Into<ItemInNs>,\n-        prefix_kind: PrefixKind,\n-    ) -> Option<ModPath> {\n-        hir_def::find_path::find_path_prefixed(db, item.into(), self.into(), prefix_kind)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Field {\n-    pub(crate) parent: VariantDef,\n-    pub(crate) id: LocalFieldId,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub enum FieldSource {\n-    Named(ast::RecordField),\n-    Pos(ast::TupleField),\n-}\n-\n-impl Field {\n-    pub fn name(&self, db: &dyn HirDatabase) -> Name {\n-        self.parent.variant_data(db).fields()[self.id].name.clone()\n-    }\n-\n-    /// Returns the type as in the signature of the struct (i.e., with\n-    /// placeholder types for type parameters). This is good for showing\n-    /// signature help, but not so good to actually get the type of the field\n-    /// when you actually have a variable of the struct.\n-    pub fn signature_ty(&self, db: &dyn HirDatabase) -> Type {\n-        let var_id = self.parent.into();\n-        let generic_def_id: GenericDefId = match self.parent {\n-            VariantDef::Struct(it) => it.id.into(),\n-            VariantDef::Union(it) => it.id.into(),\n-            VariantDef::Variant(it) => it.parent.id.into(),\n-        };\n-        let substs = Substs::type_params(db, generic_def_id);\n-        let ty = db.field_types(var_id)[self.id].clone().subst(&substs);\n-        Type::new(db, self.parent.module(db).id.krate(), var_id, ty)\n-    }\n-\n-    pub fn parent_def(&self, _db: &dyn HirDatabase) -> VariantDef {\n-        self.parent\n-    }\n-}\n-\n-impl HasVisibility for Field {\n-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n-        let variant_data = self.parent.variant_data(db);\n-        let visibility = &variant_data.fields()[self.id].visibility;\n-        let parent_id: hir_def::VariantId = self.parent.into();\n-        visibility.resolve(db.upcast(), &parent_id.resolver(db.upcast()))\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Struct {\n-    pub(crate) id: StructId,\n-}\n-\n-impl Struct {\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n-    }\n-\n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n-        Some(self.module(db).krate())\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        db.struct_data(self.id).name.clone()\n-    }\n-\n-    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {\n-        db.struct_data(self.id)\n-            .variant_data\n-            .fields()\n-            .iter()\n-            .map(|(id, _)| Field { parent: self.into(), id })\n-            .collect()\n-    }\n-\n-    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        Type::from_def(\n-            db,\n-            self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n-            self.id,\n-        )\n-    }\n-\n-    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprKind> {\n-        db.struct_data(self.id).repr.clone()\n-    }\n-\n-    pub fn kind(self, db: &dyn HirDatabase) -> StructKind {\n-        self.variant_data(db).kind()\n-    }\n-\n-    fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n-        db.struct_data(self.id).variant_data.clone()\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Union {\n-    pub(crate) id: UnionId,\n-}\n-\n-impl Union {\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        db.union_data(self.id).name.clone()\n-    }\n-\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n-    }\n-\n-    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        Type::from_def(\n-            db,\n-            self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n-            self.id,\n-        )\n-    }\n-\n-    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {\n-        db.union_data(self.id)\n-            .variant_data\n-            .fields()\n-            .iter()\n-            .map(|(id, _)| Field { parent: self.into(), id })\n-            .collect()\n-    }\n-\n-    fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n-        db.union_data(self.id).variant_data.clone()\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Enum {\n-    pub(crate) id: EnumId,\n-}\n-\n-impl Enum {\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n-    }\n-\n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n-        Some(self.module(db).krate())\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        db.enum_data(self.id).name.clone()\n-    }\n-\n-    pub fn variants(self, db: &dyn HirDatabase) -> Vec<Variant> {\n-        db.enum_data(self.id).variants.iter().map(|(id, _)| Variant { parent: self, id }).collect()\n-    }\n-\n-    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        Type::from_def(\n-            db,\n-            self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n-            self.id,\n-        )\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Variant {\n-    pub(crate) parent: Enum,\n-    pub(crate) id: LocalEnumVariantId,\n-}\n-\n-impl Variant {\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        self.parent.module(db)\n-    }\n-    pub fn parent_enum(self, _db: &dyn HirDatabase) -> Enum {\n-        self.parent\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        db.enum_data(self.parent.id).variants[self.id].name.clone()\n-    }\n-\n-    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {\n-        self.variant_data(db)\n-            .fields()\n-            .iter()\n-            .map(|(id, _)| Field { parent: self.into(), id })\n-            .collect()\n-    }\n-\n-    pub fn kind(self, db: &dyn HirDatabase) -> StructKind {\n-        self.variant_data(db).kind()\n-    }\n-\n-    pub(crate) fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n-        db.enum_data(self.parent.id).variants[self.id].variant_data.clone()\n-    }\n-}\n-\n-/// A Data Type\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum Adt {\n-    Struct(Struct),\n-    Union(Union),\n-    Enum(Enum),\n-}\n-impl_from!(Struct, Union, Enum for Adt);\n-\n-impl Adt {\n-    pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n-        let subst = db.generic_defaults(self.into());\n-        subst.iter().any(|ty| &ty.value == &Ty::Unknown)\n-    }\n-\n-    /// Turns this ADT into a type. Any type parameters of the ADT will be\n-    /// turned into unknown types, which is good for e.g. finding the most\n-    /// general set of completions, but will not look very nice when printed.\n-    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        let id = AdtId::from(self);\n-        Type::from_def(db, id.module(db.upcast()).krate(), id)\n-    }\n-\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        match self {\n-            Adt::Struct(s) => s.module(db),\n-            Adt::Union(s) => s.module(db),\n-            Adt::Enum(e) => e.module(db),\n-        }\n-    }\n-\n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n-        Some(self.module(db).krate())\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        match self {\n-            Adt::Struct(s) => s.name(db),\n-            Adt::Union(u) => u.name(db),\n-            Adt::Enum(e) => e.name(db),\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum VariantDef {\n-    Struct(Struct),\n-    Union(Union),\n-    Variant(Variant),\n-}\n-impl_from!(Struct, Union, Variant for VariantDef);\n-\n-impl VariantDef {\n-    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {\n-        match self {\n-            VariantDef::Struct(it) => it.fields(db),\n-            VariantDef::Union(it) => it.fields(db),\n-            VariantDef::Variant(it) => it.fields(db),\n-        }\n-    }\n-\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        match self {\n-            VariantDef::Struct(it) => it.module(db),\n-            VariantDef::Union(it) => it.module(db),\n-            VariantDef::Variant(it) => it.module(db),\n-        }\n-    }\n-\n-    pub fn name(&self, db: &dyn HirDatabase) -> Name {\n-        match self {\n-            VariantDef::Struct(s) => s.name(db),\n-            VariantDef::Union(u) => u.name(db),\n-            VariantDef::Variant(e) => e.name(db),\n-        }\n-    }\n-\n-    pub(crate) fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n-        match self {\n-            VariantDef::Struct(it) => it.variant_data(db),\n-            VariantDef::Union(it) => it.variant_data(db),\n-            VariantDef::Variant(it) => it.variant_data(db),\n-        }\n-    }\n-}\n-\n-/// The defs which have a body.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum DefWithBody {\n-    Function(Function),\n-    Static(Static),\n-    Const(Const),\n-}\n-impl_from!(Function, Const, Static for DefWithBody);\n-\n-impl DefWithBody {\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        match self {\n-            DefWithBody::Const(c) => c.module(db),\n-            DefWithBody::Function(f) => f.module(db),\n-            DefWithBody::Static(s) => s.module(db),\n-        }\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        match self {\n-            DefWithBody::Function(f) => Some(f.name(db)),\n-            DefWithBody::Static(s) => s.name(db),\n-            DefWithBody::Const(c) => c.name(db),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Function {\n-    pub(crate) id: FunctionId,\n-}\n-\n-impl Function {\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        self.id.lookup(db.upcast()).module(db.upcast()).into()\n-    }\n-\n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n-        Some(self.module(db).krate())\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        db.function_data(self.id).name.clone()\n-    }\n-\n-    /// Get this function's return type\n-    pub fn ret_type(self, db: &dyn HirDatabase) -> Type {\n-        let resolver = self.id.resolver(db.upcast());\n-        let ret_type = &db.function_data(self.id).ret_type;\n-        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n-        let environment = TraitEnvironment::lower(db, &resolver);\n-        Type {\n-            krate: self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n-            ty: InEnvironment { value: Ty::from_hir_ext(&ctx, ret_type).0, environment },\n-        }\n-    }\n-\n-    pub fn self_param(self, db: &dyn HirDatabase) -> Option<SelfParam> {\n-        if !db.function_data(self.id).has_self_param {\n-            return None;\n-        }\n-        Some(SelfParam { func: self.id })\n-    }\n-\n-    pub fn assoc_fn_params(self, db: &dyn HirDatabase) -> Vec<Param> {\n-        let resolver = self.id.resolver(db.upcast());\n-        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n-        let environment = TraitEnvironment::lower(db, &resolver);\n-        db.function_data(self.id)\n-            .params\n-            .iter()\n-            .map(|type_ref| {\n-                let ty = Type {\n-                    krate: self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n-                    ty: InEnvironment {\n-                        value: Ty::from_hir_ext(&ctx, type_ref).0,\n-                        environment: environment.clone(),\n-                    },\n-                };\n-                Param { ty }\n-            })\n-            .collect()\n-    }\n-    pub fn method_params(self, db: &dyn HirDatabase) -> Option<Vec<Param>> {\n-        if self.self_param(db).is_none() {\n-            return None;\n-        }\n-        let mut res = self.assoc_fn_params(db);\n-        res.remove(0);\n-        Some(res)\n-    }\n-\n-    pub fn is_unsafe(self, db: &dyn HirDatabase) -> bool {\n-        db.function_data(self.id).is_unsafe\n-    }\n-\n-    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n-        let krate = self.module(db).id.krate();\n-        hir_def::diagnostics::validate_body(db.upcast(), self.id.into(), sink);\n-        hir_ty::diagnostics::validate_module_item(db, krate, self.id.into(), sink);\n-        hir_ty::diagnostics::validate_body(db, self.id.into(), sink);\n-    }\n-\n-    /// Whether this function declaration has a definition.\n-    ///\n-    /// This is false in the case of required (not provided) trait methods.\n-    pub fn has_body(self, db: &dyn HirDatabase) -> bool {\n-        db.function_data(self.id).has_body\n-    }\n-\n-    /// A textual representation of the HIR of this function for debugging purposes.\n-    pub fn debug_hir(self, db: &dyn HirDatabase) -> String {\n-        let body = db.body(self.id.into());\n-\n-        let mut result = String::new();\n-        format_to!(result, \"HIR expressions in the body of `{}`:\\n\", self.name(db));\n-        for (id, expr) in body.exprs.iter() {\n-            format_to!(result, \"{:?}: {:?}\\n\", id, expr);\n-        }\n-\n-        result\n-    }\n-}\n-\n-// Note: logically, this belongs to `hir_ty`, but we are not using it there yet.\n-pub enum Access {\n-    Shared,\n-    Exclusive,\n-    Owned,\n-}\n-\n-impl From<Mutability> for Access {\n-    fn from(mutability: Mutability) -> Access {\n-        match mutability {\n-            Mutability::Not => Access::Shared,\n-            Mutability::Mut => Access::Exclusive,\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct Param {\n-    ty: Type,\n-}\n-\n-impl Param {\n-    pub fn ty(&self) -> &Type {\n-        &self.ty\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct SelfParam {\n-    func: FunctionId,\n-}\n-\n-impl SelfParam {\n-    pub fn access(self, db: &dyn HirDatabase) -> Access {\n-        let func_data = db.function_data(self.func);\n-        func_data\n-            .params\n-            .first()\n-            .map(|param| match *param {\n-                TypeRef::Reference(.., mutability) => match mutability {\n-                    hir_def::type_ref::Mutability::Shared => Access::Shared,\n-                    hir_def::type_ref::Mutability::Mut => Access::Exclusive,\n-                },\n-                _ => Access::Owned,\n-            })\n-            .unwrap_or(Access::Owned)\n-    }\n-}\n-\n-impl HasVisibility for Function {\n-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n-        let function_data = db.function_data(self.id);\n-        let visibility = &function_data.visibility;\n-        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Const {\n-    pub(crate) id: ConstId,\n-}\n-\n-impl Const {\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n-    }\n-\n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n-        Some(self.module(db).krate())\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        db.const_data(self.id).name.clone()\n-    }\n-}\n-\n-impl HasVisibility for Const {\n-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n-        let function_data = db.const_data(self.id);\n-        let visibility = &function_data.visibility;\n-        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Static {\n-    pub(crate) id: StaticId,\n-}\n-\n-impl Static {\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n-    }\n-\n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n-        Some(self.module(db).krate())\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        db.static_data(self.id).name.clone()\n-    }\n-\n-    pub fn is_mut(self, db: &dyn HirDatabase) -> bool {\n-        db.static_data(self.id).mutable\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Trait {\n-    pub(crate) id: TraitId,\n-}\n-\n-impl Trait {\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        db.trait_data(self.id).name.clone()\n-    }\n-\n-    pub fn items(self, db: &dyn HirDatabase) -> Vec<AssocItem> {\n-        db.trait_data(self.id).items.iter().map(|(_name, it)| (*it).into()).collect()\n-    }\n-\n-    pub fn is_auto(self, db: &dyn HirDatabase) -> bool {\n-        db.trait_data(self.id).auto\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TypeAlias {\n-    pub(crate) id: TypeAliasId,\n-}\n-\n-impl TypeAlias {\n-    pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n-        let subst = db.generic_defaults(self.id.into());\n-        subst.iter().any(|ty| &ty.value == &Ty::Unknown)\n-    }\n-\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n-    }\n-\n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n-        Some(self.module(db).krate())\n-    }\n-\n-    pub fn type_ref(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n-        db.type_alias_data(self.id).type_ref.clone()\n-    }\n-\n-    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        Type::from_def(db, self.id.lookup(db.upcast()).module(db.upcast()).krate(), self.id)\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        db.type_alias_data(self.id).name.clone()\n-    }\n-}\n-\n-impl HasVisibility for TypeAlias {\n-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n-        let function_data = db.type_alias_data(self.id);\n-        let visibility = &function_data.visibility;\n-        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct BuiltinType {\n-    pub(crate) inner: hir_def::builtin_type::BuiltinType,\n-}\n-\n-impl BuiltinType {\n-    pub fn ty(self, db: &dyn HirDatabase, module: Module) -> Type {\n-        let resolver = module.id.resolver(db.upcast());\n-        Type::new_with_resolver(db, &resolver, Ty::builtin(self.inner))\n-            .expect(\"crate not present in resolver\")\n-    }\n-\n-    pub fn name(self) -> Name {\n-        self.inner.as_name()\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroDef {\n-    pub(crate) id: MacroDefId,\n-}\n-\n-impl MacroDef {\n-    /// FIXME: right now, this just returns the root module of the crate that\n-    /// defines this macro. The reasons for this is that macros are expanded\n-    /// early, in `hir_expand`, where modules simply do not exist yet.\n-    pub fn module(self, db: &dyn HirDatabase) -> Option<Module> {\n-        let krate = self.id.krate;\n-        let def_map = db.crate_def_map(krate);\n-        let module_id = def_map.root();\n-        Some(Module { id: def_map.module_id(module_id) })\n-    }\n-\n-    /// XXX: this parses the file\n-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        self.source(db)?.value.name().map(|it| it.as_name())\n-    }\n-\n-    /// Indicate it is a proc-macro\n-    pub fn is_proc_macro(&self) -> bool {\n-        matches!(self.id.kind, MacroDefKind::ProcMacro(_))\n-    }\n-\n-    /// Indicate it is a derive macro\n-    pub fn is_derive_macro(&self) -> bool {\n-        matches!(self.id.kind, MacroDefKind::ProcMacro(_) | MacroDefKind::BuiltInDerive(_))\n-    }\n-}\n-\n-/// Invariant: `inner.as_assoc_item(db).is_some()`\n-/// We do not actively enforce this invariant.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub enum AssocItem {\n-    Function(Function),\n-    Const(Const),\n-    TypeAlias(TypeAlias),\n-}\n-pub enum AssocItemContainer {\n-    Trait(Trait),\n-    Impl(Impl),\n-}\n-pub trait AsAssocItem {\n-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem>;\n-}\n-\n-impl AsAssocItem for Function {\n-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n-        as_assoc_item(db, AssocItem::Function, self.id)\n-    }\n-}\n-impl AsAssocItem for Const {\n-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n-        as_assoc_item(db, AssocItem::Const, self.id)\n-    }\n-}\n-impl AsAssocItem for TypeAlias {\n-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n-        as_assoc_item(db, AssocItem::TypeAlias, self.id)\n-    }\n-}\n-impl AsAssocItem for ModuleDef {\n-    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n-        match self {\n-            ModuleDef::Function(it) => it.as_assoc_item(db),\n-            ModuleDef::Const(it) => it.as_assoc_item(db),\n-            ModuleDef::TypeAlias(it) => it.as_assoc_item(db),\n-            _ => None,\n-        }\n-    }\n-}\n-fn as_assoc_item<ID, DEF, CTOR, AST>(db: &dyn HirDatabase, ctor: CTOR, id: ID) -> Option<AssocItem>\n-where\n-    ID: Lookup<Data = AssocItemLoc<AST>>,\n-    DEF: From<ID>,\n-    CTOR: FnOnce(DEF) -> AssocItem,\n-    AST: ItemTreeNode,\n-{\n-    match id.lookup(db.upcast()).container {\n-        AssocContainerId::TraitId(_) | AssocContainerId::ImplId(_) => Some(ctor(DEF::from(id))),\n-        AssocContainerId::ContainerId(_) => None,\n-    }\n-}\n-\n-impl AssocItem {\n-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        match self {\n-            AssocItem::Function(it) => Some(it.name(db)),\n-            AssocItem::Const(it) => it.name(db),\n-            AssocItem::TypeAlias(it) => Some(it.name(db)),\n-        }\n-    }\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        match self {\n-            AssocItem::Function(f) => f.module(db),\n-            AssocItem::Const(c) => c.module(db),\n-            AssocItem::TypeAlias(t) => t.module(db),\n-        }\n-    }\n-    pub fn container(self, db: &dyn HirDatabase) -> AssocItemContainer {\n-        let container = match self {\n-            AssocItem::Function(it) => it.id.lookup(db.upcast()).container,\n-            AssocItem::Const(it) => it.id.lookup(db.upcast()).container,\n-            AssocItem::TypeAlias(it) => it.id.lookup(db.upcast()).container,\n-        };\n-        match container {\n-            AssocContainerId::TraitId(id) => AssocItemContainer::Trait(id.into()),\n-            AssocContainerId::ImplId(id) => AssocItemContainer::Impl(id.into()),\n-            AssocContainerId::ContainerId(_) => panic!(\"invalid AssocItem\"),\n-        }\n-    }\n-\n-    pub fn containing_trait(self, db: &dyn HirDatabase) -> Option<Trait> {\n-        match self.container(db) {\n-            AssocItemContainer::Trait(t) => Some(t),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-impl HasVisibility for AssocItem {\n-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n-        match self {\n-            AssocItem::Function(f) => f.visibility(db),\n-            AssocItem::Const(c) => c.visibility(db),\n-            AssocItem::TypeAlias(t) => t.visibility(db),\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericDef {\n-    Function(Function),\n-    Adt(Adt),\n-    Trait(Trait),\n-    TypeAlias(TypeAlias),\n-    Impl(Impl),\n-    // enum variants cannot have generics themselves, but their parent enums\n-    // can, and this makes some code easier to write\n-    Variant(Variant),\n-    // consts can have type parameters from their parents (i.e. associated consts of traits)\n-    Const(Const),\n-}\n-impl_from!(\n-    Function,\n-    Adt(Struct, Enum, Union),\n-    Trait,\n-    TypeAlias,\n-    Impl,\n-    Variant,\n-    Const\n-    for GenericDef\n-);\n-\n-impl GenericDef {\n-    pub fn params(self, db: &dyn HirDatabase) -> Vec<GenericParam> {\n-        let generics = db.generic_params(self.into());\n-        let ty_params = generics\n-            .types\n-            .iter()\n-            .map(|(local_id, _)| TypeParam { id: TypeParamId { parent: self.into(), local_id } })\n-            .map(GenericParam::TypeParam);\n-        let lt_params = generics\n-            .lifetimes\n-            .iter()\n-            .map(|(local_id, _)| LifetimeParam {\n-                id: LifetimeParamId { parent: self.into(), local_id },\n-            })\n-            .map(GenericParam::LifetimeParam);\n-        let const_params = generics\n-            .consts\n-            .iter()\n-            .map(|(local_id, _)| ConstParam { id: ConstParamId { parent: self.into(), local_id } })\n-            .map(GenericParam::ConstParam);\n-        ty_params.chain(lt_params).chain(const_params).collect()\n-    }\n-\n-    pub fn type_params(self, db: &dyn HirDatabase) -> Vec<TypeParam> {\n-        let generics = db.generic_params(self.into());\n-        generics\n-            .types\n-            .iter()\n-            .map(|(local_id, _)| TypeParam { id: TypeParamId { parent: self.into(), local_id } })\n-            .collect()\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct Local {\n-    pub(crate) parent: DefWithBodyId,\n-    pub(crate) pat_id: PatId,\n-}\n-\n-impl Local {\n-    pub fn is_param(self, db: &dyn HirDatabase) -> bool {\n-        let src = self.source(db);\n-        match src.value {\n-            Either::Left(bind_pat) => {\n-                bind_pat.syntax().ancestors().any(|it| ast::Param::can_cast(it.kind()))\n-            }\n-            Either::Right(_self_param) => true,\n-        }\n-    }\n-\n-    // FIXME: why is this an option? It shouldn't be?\n-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        let body = db.body(self.parent.into());\n-        match &body[self.pat_id] {\n-            Pat::Bind { name, .. } => Some(name.clone()),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn is_self(self, db: &dyn HirDatabase) -> bool {\n-        self.name(db) == Some(name![self])\n-    }\n-\n-    pub fn is_mut(self, db: &dyn HirDatabase) -> bool {\n-        let body = db.body(self.parent.into());\n-        match &body[self.pat_id] {\n-            Pat::Bind { mode, .. } => match mode {\n-                BindingAnnotation::Mutable | BindingAnnotation::RefMut => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn parent(self, _db: &dyn HirDatabase) -> DefWithBody {\n-        self.parent.into()\n-    }\n-\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        self.parent(db).module(db)\n-    }\n-\n-    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        let def = DefWithBodyId::from(self.parent);\n-        let infer = db.infer(def);\n-        let ty = infer[self.pat_id].clone();\n-        let krate = def.module(db.upcast()).krate();\n-        Type::new(db, krate, def, ty)\n-    }\n-\n-    pub fn source(self, db: &dyn HirDatabase) -> InFile<Either<ast::IdentPat, ast::SelfParam>> {\n-        let (_body, source_map) = db.body_with_source_map(self.parent.into());\n-        let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n-        let root = src.file_syntax(db.upcast());\n-        src.map(|ast| {\n-            ast.map_left(|it| it.cast().unwrap().to_node(&root)).map_right(|it| it.to_node(&root))\n-        })\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct Label {\n-    pub(crate) parent: DefWithBodyId,\n-    pub(crate) label_id: LabelId,\n-}\n-\n-impl Label {\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        self.parent(db).module(db)\n-    }\n-\n-    pub fn parent(self, _db: &dyn HirDatabase) -> DefWithBody {\n-        self.parent.into()\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        let body = db.body(self.parent.into());\n-        body[self.label_id].name.clone()\n-    }\n-\n-    pub fn source(self, db: &dyn HirDatabase) -> InFile<ast::Label> {\n-        let (_body, source_map) = db.body_with_source_map(self.parent.into());\n-        let src = source_map.label_syntax(self.label_id);\n-        let root = src.file_syntax(db.upcast());\n-        src.map(|ast| ast.to_node(&root))\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum GenericParam {\n-    TypeParam(TypeParam),\n-    LifetimeParam(LifetimeParam),\n-    ConstParam(ConstParam),\n-}\n-impl_from!(TypeParam, LifetimeParam, ConstParam for GenericParam);\n-\n-impl GenericParam {\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        match self {\n-            GenericParam::TypeParam(it) => it.module(db),\n-            GenericParam::LifetimeParam(it) => it.module(db),\n-            GenericParam::ConstParam(it) => it.module(db),\n-        }\n-    }\n-\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        match self {\n-            GenericParam::TypeParam(it) => it.name(db),\n-            GenericParam::LifetimeParam(it) => it.name(db),\n-            GenericParam::ConstParam(it) => it.name(db),\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct TypeParam {\n-    pub(crate) id: TypeParamId,\n-}\n-\n-impl TypeParam {\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        let params = db.generic_params(self.id.parent);\n-        params.types[self.id.local_id].name.clone().unwrap_or_else(Name::missing)\n-    }\n-\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        self.id.parent.module(db.upcast()).into()\n-    }\n-\n-    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        let resolver = self.id.parent.resolver(db.upcast());\n-        let environment = TraitEnvironment::lower(db, &resolver);\n-        let ty = Ty::Placeholder(self.id);\n-        Type {\n-            krate: self.id.parent.module(db.upcast()).krate(),\n-            ty: InEnvironment { value: ty, environment },\n-        }\n-    }\n-\n-    pub fn trait_bounds(self, db: &dyn HirDatabase) -> Vec<Trait> {\n-        db.generic_predicates_for_param(self.id)\n-            .into_iter()\n-            .filter_map(|pred| match &pred.value {\n-                hir_ty::GenericPredicate::Implemented(trait_ref) => {\n-                    Some(Trait::from(trait_ref.trait_))\n-                }\n-                _ => None,\n-            })\n-            .collect()\n-    }\n-\n-    pub fn default(self, db: &dyn HirDatabase) -> Option<Type> {\n-        let params = db.generic_defaults(self.id.parent);\n-        let local_idx = hir_ty::param_idx(db, self.id)?;\n-        let resolver = self.id.parent.resolver(db.upcast());\n-        let environment = TraitEnvironment::lower(db, &resolver);\n-        let ty = params.get(local_idx)?.clone();\n-        let subst = Substs::type_params(db, self.id.parent);\n-        let ty = ty.subst(&subst.prefix(local_idx));\n-        Some(Type {\n-            krate: self.id.parent.module(db.upcast()).krate(),\n-            ty: InEnvironment { value: ty, environment },\n-        })\n-    }\n-}\n-\n-impl HirDisplay for TypeParam {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n-        write!(f, \"{}\", self.name(f.db))?;\n-        let bounds = f.db.generic_predicates_for_param(self.id);\n-        let substs = Substs::type_params(f.db, self.id.parent);\n-        let predicates = bounds.iter().cloned().map(|b| b.subst(&substs)).collect::<Vec<_>>();\n-        if !(predicates.is_empty() || f.omit_verbose_types()) {\n-            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, f)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct LifetimeParam {\n-    pub(crate) id: LifetimeParamId,\n-}\n-\n-impl LifetimeParam {\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        let params = db.generic_params(self.id.parent);\n-        params.lifetimes[self.id.local_id].name.clone()\n-    }\n-\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        self.id.parent.module(db.upcast()).into()\n-    }\n-\n-    pub fn parent(self, _db: &dyn HirDatabase) -> GenericDef {\n-        self.id.parent.into()\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct ConstParam {\n-    pub(crate) id: ConstParamId,\n-}\n-\n-impl ConstParam {\n-    pub fn name(self, db: &dyn HirDatabase) -> Name {\n-        let params = db.generic_params(self.id.parent);\n-        params.consts[self.id.local_id].name.clone()\n-    }\n-\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        self.id.parent.module(db.upcast()).into()\n-    }\n-\n-    pub fn parent(self, _db: &dyn HirDatabase) -> GenericDef {\n-        self.id.parent.into()\n-    }\n-\n-    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        let def = self.id.parent;\n-        let krate = def.module(db.upcast()).krate();\n-        Type::new(db, krate, def, db.const_param_ty(self.id))\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Impl {\n-    pub(crate) id: ImplId,\n-}\n-\n-impl Impl {\n-    pub fn all_in_crate(db: &dyn HirDatabase, krate: Crate) -> Vec<Impl> {\n-        let inherent = db.inherent_impls_in_crate(krate.id);\n-        let trait_ = db.trait_impls_in_crate(krate.id);\n-\n-        inherent.all_impls().chain(trait_.all_impls()).map(Self::from).collect()\n-    }\n-    pub fn for_trait(db: &dyn HirDatabase, krate: Crate, trait_: Trait) -> Vec<Impl> {\n-        let impls = db.trait_impls_in_crate(krate.id);\n-        impls.for_trait(trait_.id).map(Self::from).collect()\n-    }\n-\n-    // FIXME: the return type is wrong. This should be a hir version of\n-    // `TraitRef` (ie, resolved `TypeRef`).\n-    pub fn target_trait(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n-        db.impl_data(self.id).target_trait.clone()\n-    }\n-\n-    pub fn target_ty(self, db: &dyn HirDatabase) -> Type {\n-        let impl_data = db.impl_data(self.id);\n-        let resolver = self.id.resolver(db.upcast());\n-        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n-        let environment = TraitEnvironment::lower(db, &resolver);\n-        let ty = Ty::from_hir(&ctx, &impl_data.target_type);\n-        Type {\n-            krate: self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n-            ty: InEnvironment { value: ty, environment },\n-        }\n-    }\n-\n-    pub fn items(self, db: &dyn HirDatabase) -> Vec<AssocItem> {\n-        db.impl_data(self.id).items.iter().map(|it| (*it).into()).collect()\n-    }\n-\n-    pub fn is_negative(self, db: &dyn HirDatabase) -> bool {\n-        db.impl_data(self.id).is_negative\n-    }\n-\n-    pub fn module(self, db: &dyn HirDatabase) -> Module {\n-        self.id.lookup(db.upcast()).container.module(db.upcast()).into()\n-    }\n-\n-    pub fn krate(self, db: &dyn HirDatabase) -> Crate {\n-        Crate { id: self.module(db).id.krate() }\n-    }\n-\n-    pub fn is_builtin_derive(self, db: &dyn HirDatabase) -> Option<InFile<ast::Attr>> {\n-        let src = self.source(db)?;\n-        let item = src.file_id.is_builtin_derive(db.upcast())?;\n-        let hygenic = hir_expand::hygiene::Hygiene::new(db.upcast(), item.file_id);\n-\n-        // FIXME: handle `cfg_attr`\n-        let attr = item\n-            .value\n-            .attrs()\n-            .filter_map(|it| {\n-                let path = ModPath::from_src(it.path()?, &hygenic)?;\n-                if path.as_ident()?.to_string() == \"derive\" {\n-                    Some(it)\n-                } else {\n-                    None\n-                }\n-            })\n-            .last()?;\n-\n-        Some(item.with_value(attr))\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct Type {\n-    krate: CrateId,\n-    ty: InEnvironment<Ty>,\n-}\n-\n-impl Type {\n-    pub(crate) fn new_with_resolver(\n-        db: &dyn HirDatabase,\n-        resolver: &Resolver,\n-        ty: Ty,\n-    ) -> Option<Type> {\n-        let krate = resolver.krate()?;\n-        Some(Type::new_with_resolver_inner(db, krate, resolver, ty))\n-    }\n-    pub(crate) fn new_with_resolver_inner(\n-        db: &dyn HirDatabase,\n-        krate: CrateId,\n-        resolver: &Resolver,\n-        ty: Ty,\n-    ) -> Type {\n-        let environment = TraitEnvironment::lower(db, &resolver);\n-        Type { krate, ty: InEnvironment { value: ty, environment } }\n-    }\n-\n-    fn new(db: &dyn HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n-        let resolver = lexical_env.resolver(db.upcast());\n-        let environment = TraitEnvironment::lower(db, &resolver);\n-        Type { krate, ty: InEnvironment { value: ty, environment } }\n-    }\n-\n-    fn from_def(\n-        db: &dyn HirDatabase,\n-        krate: CrateId,\n-        def: impl HasResolver + Into<TyDefId> + Into<GenericDefId>,\n-    ) -> Type {\n-        let substs = Substs::build_for_def(db, def).fill_with_unknown().build();\n-        let ty = db.ty(def.into()).subst(&substs);\n-        Type::new(db, krate, def, ty)\n-    }\n-\n-    pub fn is_unit(&self) -> bool {\n-        matches!(self.ty.value, Ty::Tuple(0, ..))\n-    }\n-    pub fn is_bool(&self) -> bool {\n-        matches!(self.ty.value, Ty::Scalar(Scalar::Bool))\n-    }\n-\n-    pub fn is_mutable_reference(&self) -> bool {\n-        matches!(self.ty.value, Ty::Ref(Mutability::Mut, ..))\n-    }\n-\n-    pub fn remove_ref(&self) -> Option<Type> {\n-        if let Ty::Ref(.., substs) = &self.ty.value {\n-            Some(self.derived(substs[0].clone()))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn is_unknown(&self) -> bool {\n-        matches!(self.ty.value, Ty::Unknown)\n-    }\n-\n-    /// Checks that particular type `ty` implements `std::future::Future`.\n-    /// This function is used in `.await` syntax completion.\n-    pub fn impls_future(&self, db: &dyn HirDatabase) -> bool {\n-        // No special case for the type of async block, since Chalk can figure it out.\n-\n-        let krate = self.krate;\n-\n-        let std_future_trait =\n-            db.lang_item(krate, \"future_trait\".into()).and_then(|it| it.as_trait());\n-        let std_future_trait = match std_future_trait {\n-            Some(it) => it,\n-            None => return false,\n-        };\n-\n-        let canonical_ty = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n-        method_resolution::implements_trait(\n-            &canonical_ty,\n-            db,\n-            self.ty.environment.clone(),\n-            krate,\n-            std_future_trait,\n-        )\n-    }\n-\n-    /// Checks that particular type `ty` implements `std::ops::FnOnce`.\n-    ///\n-    /// This function can be used to check if a particular type is callable, since FnOnce is a\n-    /// supertrait of Fn and FnMut, so all callable types implements at least FnOnce.\n-    pub fn impls_fnonce(&self, db: &dyn HirDatabase) -> bool {\n-        let krate = self.krate;\n-\n-        let fnonce_trait = match FnTrait::FnOnce.get_id(db, krate) {\n-            Some(it) => it,\n-            None => return false,\n-        };\n-\n-        let canonical_ty = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n-        method_resolution::implements_trait_unique(\n-            &canonical_ty,\n-            db,\n-            self.ty.environment.clone(),\n-            krate,\n-            fnonce_trait,\n-        )\n-    }\n-\n-    pub fn impls_trait(&self, db: &dyn HirDatabase, trait_: Trait, args: &[Type]) -> bool {\n-        let trait_ref = hir_ty::TraitRef {\n-            trait_: trait_.id,\n-            substs: Substs::build_for_def(db, trait_.id)\n-                .push(self.ty.value.clone())\n-                .fill(args.iter().map(|t| t.ty.value.clone()))\n-                .build(),\n-        };\n-\n-        let goal = Canonical {\n-            value: hir_ty::InEnvironment::new(\n-                self.ty.environment.clone(),\n-                hir_ty::Obligation::Trait(trait_ref),\n-            ),\n-            kinds: Arc::new([]),\n-        };\n-\n-        db.trait_solve(self.krate, goal).is_some()\n-    }\n-\n-    pub fn normalize_trait_assoc_type(\n-        &self,\n-        db: &dyn HirDatabase,\n-        trait_: Trait,\n-        args: &[Type],\n-        alias: TypeAlias,\n-    ) -> Option<Type> {\n-        let subst = Substs::build_for_def(db, trait_.id)\n-            .push(self.ty.value.clone())\n-            .fill(args.iter().map(|t| t.ty.value.clone()))\n-            .build();\n-        let predicate = ProjectionPredicate {\n-            projection_ty: ProjectionTy { associated_ty: alias.id, parameters: subst },\n-            ty: Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)),\n-        };\n-        let goal = Canonical {\n-            value: InEnvironment::new(\n-                self.ty.environment.clone(),\n-                Obligation::Projection(predicate),\n-            ),\n-            kinds: Arc::new([TyVariableKind::General]),\n-        };\n-\n-        match db.trait_solve(self.krate, goal)? {\n-            Solution::Unique(SolutionVariables(subst)) => subst.value.first().cloned(),\n-            Solution::Ambig(_) => None,\n-        }\n-        .map(|ty| Type {\n-            krate: self.krate,\n-            ty: InEnvironment { value: ty, environment: Arc::clone(&self.ty.environment) },\n-        })\n-    }\n-\n-    pub fn is_copy(&self, db: &dyn HirDatabase) -> bool {\n-        let lang_item = db.lang_item(self.krate, SmolStr::new(\"copy\"));\n-        let copy_trait = match lang_item {\n-            Some(LangItemTarget::TraitId(it)) => it,\n-            _ => return false,\n-        };\n-        self.impls_trait(db, copy_trait.into(), &[])\n-    }\n-\n-    pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n-        let def = match self.ty.value {\n-            Ty::FnDef(def, _) => Some(def),\n-            _ => None,\n-        };\n-\n-        let sig = self.ty.value.callable_sig(db)?;\n-        Some(Callable { ty: self.clone(), sig, def, is_bound_method: false })\n-    }\n-\n-    pub fn is_closure(&self) -> bool {\n-        matches!(&self.ty.value, Ty::Closure { .. })\n-    }\n-\n-    pub fn is_fn(&self) -> bool {\n-        matches!(&self.ty.value, Ty::FnDef(..) | Ty::Function { .. })\n-    }\n-\n-    pub fn is_packed(&self, db: &dyn HirDatabase) -> bool {\n-        let adt_id = match self.ty.value {\n-            Ty::Adt(hir_ty::AdtId(adt_id), ..) => adt_id,\n-            _ => return false,\n-        };\n-\n-        let adt = adt_id.into();\n-        match adt {\n-            Adt::Struct(s) => matches!(s.repr(db), Some(ReprKind::Packed)),\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_raw_ptr(&self) -> bool {\n-        matches!(&self.ty.value, Ty::Raw(..))\n-    }\n-\n-    pub fn contains_unknown(&self) -> bool {\n-        return go(&self.ty.value);\n-\n-        fn go(ty: &Ty) -> bool {\n-            match ty {\n-                Ty::Unknown => true,\n-                _ => ty.substs().map_or(false, |substs| substs.iter().any(go)),\n-            }\n-        }\n-    }\n-\n-    pub fn fields(&self, db: &dyn HirDatabase) -> Vec<(Field, Type)> {\n-        let (variant_id, substs) = match self.ty.value {\n-            Ty::Adt(hir_ty::AdtId(AdtId::StructId(s)), ref substs) => (s.into(), substs),\n-            Ty::Adt(hir_ty::AdtId(AdtId::UnionId(u)), ref substs) => (u.into(), substs),\n-            _ => return Vec::new(),\n-        };\n-\n-        db.field_types(variant_id)\n-            .iter()\n-            .map(|(local_id, ty)| {\n-                let def = Field { parent: variant_id.into(), id: local_id };\n-                let ty = ty.clone().subst(substs);\n-                (def, self.derived(ty))\n-            })\n-            .collect()\n-    }\n-\n-    pub fn tuple_fields(&self, _db: &dyn HirDatabase) -> Vec<Type> {\n-        if let Ty::Tuple(_, substs) = &self.ty.value {\n-            substs.iter().map(|ty| self.derived(ty.clone())).collect()\n-        } else {\n-            Vec::new()\n-        }\n-    }\n-\n-    pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n-        // There should be no inference vars in types passed here\n-        // FIXME check that?\n-        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n-        let environment = self.ty.environment.clone();\n-        let ty = InEnvironment { value: canonical, environment };\n-        autoderef(db, Some(self.krate), ty)\n-            .map(|canonical| canonical.value)\n-            .map(move |ty| self.derived(ty))\n-    }\n-\n-    // This would be nicer if it just returned an iterator, but that runs into\n-    // lifetime problems, because we need to borrow temp `CrateImplDefs`.\n-    pub fn iterate_assoc_items<T>(\n-        self,\n-        db: &dyn HirDatabase,\n-        krate: Crate,\n-        mut callback: impl FnMut(AssocItem) -> Option<T>,\n-    ) -> Option<T> {\n-        for krate in self.ty.value.def_crates(db, krate.id)? {\n-            let impls = db.inherent_impls_in_crate(krate);\n-\n-            for impl_def in impls.for_self_ty(&self.ty.value) {\n-                for &item in db.impl_data(*impl_def).items.iter() {\n-                    if let Some(result) = callback(item.into()) {\n-                        return Some(result);\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n-    pub fn type_parameters(&self) -> impl Iterator<Item = Type> + '_ {\n-        self.ty\n-            .value\n-            .strip_references()\n-            .substs()\n-            .into_iter()\n-            .flat_map(|substs| substs.iter())\n-            .map(move |ty| self.derived(ty.clone()))\n-    }\n-\n-    pub fn iterate_method_candidates<T>(\n-        &self,\n-        db: &dyn HirDatabase,\n-        krate: Crate,\n-        traits_in_scope: &FxHashSet<TraitId>,\n-        name: Option<&Name>,\n-        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n-    ) -> Option<T> {\n-        // There should be no inference vars in types passed here\n-        // FIXME check that?\n-        // FIXME replace Unknown by bound vars here\n-        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n-\n-        let env = self.ty.environment.clone();\n-        let krate = krate.id;\n-\n-        method_resolution::iterate_method_candidates(\n-            &canonical,\n-            db,\n-            env,\n-            krate,\n-            traits_in_scope,\n-            name,\n-            method_resolution::LookupMode::MethodCall,\n-            |ty, it| match it {\n-                AssocItemId::FunctionId(f) => callback(ty, f.into()),\n-                _ => None,\n-            },\n-        )\n-    }\n-\n-    pub fn iterate_path_candidates<T>(\n-        &self,\n-        db: &dyn HirDatabase,\n-        krate: Crate,\n-        traits_in_scope: &FxHashSet<TraitId>,\n-        name: Option<&Name>,\n-        mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n-    ) -> Option<T> {\n-        // There should be no inference vars in types passed here\n-        // FIXME check that?\n-        // FIXME replace Unknown by bound vars here\n-        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n-\n-        let env = self.ty.environment.clone();\n-        let krate = krate.id;\n-\n-        method_resolution::iterate_method_candidates(\n-            &canonical,\n-            db,\n-            env,\n-            krate,\n-            traits_in_scope,\n-            name,\n-            method_resolution::LookupMode::Path,\n-            |ty, it| callback(ty, it.into()),\n-        )\n-    }\n-\n-    pub fn as_adt(&self) -> Option<Adt> {\n-        let (adt, _subst) = self.ty.value.as_adt()?;\n-        Some(adt.into())\n-    }\n-\n-    pub fn as_dyn_trait(&self) -> Option<Trait> {\n-        self.ty.value.dyn_trait().map(Into::into)\n-    }\n-\n-    pub fn as_impl_traits(&self, db: &dyn HirDatabase) -> Option<Vec<Trait>> {\n-        self.ty.value.impl_trait_bounds(db).map(|it| {\n-            it.into_iter()\n-                .filter_map(|pred| match pred {\n-                    hir_ty::GenericPredicate::Implemented(trait_ref) => {\n-                        Some(Trait::from(trait_ref.trait_))\n-                    }\n-                    _ => None,\n-                })\n-                .collect()\n-        })\n-    }\n-\n-    pub fn as_associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<Trait> {\n-        self.ty.value.associated_type_parent_trait(db).map(Into::into)\n-    }\n-\n-    // FIXME: provide required accessors such that it becomes implementable from outside.\n-    pub fn is_equal_for_find_impls(&self, other: &Type) -> bool {\n-        let rref = other.remove_ref();\n-        self.ty.value.equals_ctor(rref.as_ref().map_or(&other.ty.value, |it| &it.ty.value))\n-    }\n-\n-    fn derived(&self, ty: Ty) -> Type {\n-        Type {\n-            krate: self.krate,\n-            ty: InEnvironment { value: ty, environment: self.ty.environment.clone() },\n-        }\n-    }\n-\n-    pub fn walk(&self, db: &dyn HirDatabase, mut cb: impl FnMut(Type)) {\n-        // TypeWalk::walk for a Ty at first visits parameters and only after that the Ty itself.\n-        // We need a different order here.\n-\n-        fn walk_substs(\n-            db: &dyn HirDatabase,\n-            type_: &Type,\n-            substs: &Substs,\n-            cb: &mut impl FnMut(Type),\n-        ) {\n-            for ty in substs.iter() {\n-                walk_type(db, &type_.derived(ty.clone()), cb);\n-            }\n-        }\n-\n-        fn walk_bounds(\n-            db: &dyn HirDatabase,\n-            type_: &Type,\n-            bounds: &[GenericPredicate],\n-            cb: &mut impl FnMut(Type),\n-        ) {\n-            for pred in bounds {\n-                match pred {\n-                    GenericPredicate::Implemented(trait_ref) => {\n-                        cb(type_.clone());\n-                        walk_substs(db, type_, &trait_ref.substs, cb);\n-                    }\n-                    _ => (),\n-                }\n-            }\n-        }\n-\n-        fn walk_type(db: &dyn HirDatabase, type_: &Type, cb: &mut impl FnMut(Type)) {\n-            let ty = type_.ty.value.strip_references();\n-            match ty {\n-                Ty::Adt(..) => {\n-                    cb(type_.derived(ty.clone()));\n-                }\n-                Ty::AssociatedType(..) => {\n-                    if let Some(_) = ty.associated_type_parent_trait(db) {\n-                        cb(type_.derived(ty.clone()));\n-                    }\n-                }\n-                Ty::OpaqueType(..) => {\n-                    if let Some(bounds) = ty.impl_trait_bounds(db) {\n-                        walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n-                    }\n-                }\n-                Ty::Alias(AliasTy::Opaque(opaque_ty)) => {\n-                    if let Some(bounds) = ty.impl_trait_bounds(db) {\n-                        walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n-                    }\n-\n-                    walk_substs(db, type_, &opaque_ty.parameters, cb);\n-                }\n-                Ty::Placeholder(_) => {\n-                    if let Some(bounds) = ty.impl_trait_bounds(db) {\n-                        walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n-                    }\n-                }\n-                Ty::Dyn(bounds) => {\n-                    walk_bounds(db, &type_.derived(ty.clone()), bounds.as_ref(), cb);\n-                }\n-\n-                _ => {}\n-            }\n-            if let Some(substs) = ty.substs() {\n-                walk_substs(db, type_, &substs, cb);\n-            }\n-        }\n-\n-        walk_type(db, self, &mut cb);\n-    }\n-}\n-\n-impl HirDisplay for Type {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n-        self.ty.value.hir_fmt(f)\n-    }\n-}\n-\n-// FIXME: closures\n-#[derive(Debug)]\n-pub struct Callable {\n-    ty: Type,\n-    sig: CallableSig,\n-    def: Option<CallableDefId>,\n-    pub(crate) is_bound_method: bool,\n-}\n-\n-pub enum CallableKind {\n-    Function(Function),\n-    TupleStruct(Struct),\n-    TupleEnumVariant(Variant),\n-    Closure,\n-}\n-\n-impl Callable {\n-    pub fn kind(&self) -> CallableKind {\n-        match self.def {\n-            Some(CallableDefId::FunctionId(it)) => CallableKind::Function(it.into()),\n-            Some(CallableDefId::StructId(it)) => CallableKind::TupleStruct(it.into()),\n-            Some(CallableDefId::EnumVariantId(it)) => CallableKind::TupleEnumVariant(it.into()),\n-            None => CallableKind::Closure,\n-        }\n-    }\n-    pub fn receiver_param(&self, db: &dyn HirDatabase) -> Option<ast::SelfParam> {\n-        let func = match self.def {\n-            Some(CallableDefId::FunctionId(it)) if self.is_bound_method => it,\n-            _ => return None,\n-        };\n-        let src = func.lookup(db.upcast()).source(db.upcast());\n-        let param_list = src.value.param_list()?;\n-        param_list.self_param()\n-    }\n-    pub fn n_params(&self) -> usize {\n-        self.sig.params().len() - if self.is_bound_method { 1 } else { 0 }\n-    }\n-    pub fn params(\n-        &self,\n-        db: &dyn HirDatabase,\n-    ) -> Vec<(Option<Either<ast::SelfParam, ast::Pat>>, Type)> {\n-        let types = self\n-            .sig\n-            .params()\n-            .iter()\n-            .skip(if self.is_bound_method { 1 } else { 0 })\n-            .map(|ty| self.ty.derived(ty.clone()));\n-        let patterns = match self.def {\n-            Some(CallableDefId::FunctionId(func)) => {\n-                let src = func.lookup(db.upcast()).source(db.upcast());\n-                src.value.param_list().map(|param_list| {\n-                    param_list\n-                        .self_param()\n-                        .map(|it| Some(Either::Left(it)))\n-                        .filter(|_| !self.is_bound_method)\n-                        .into_iter()\n-                        .chain(param_list.params().map(|it| it.pat().map(Either::Right)))\n-                })\n-            }\n-            _ => None,\n-        };\n-        patterns.into_iter().flatten().chain(iter::repeat(None)).zip(types).collect()\n-    }\n-    pub fn return_type(&self) -> Type {\n-        self.ty.derived(self.sig.ret().clone())\n-    }\n-}\n-\n-/// For IDE only\n-#[derive(Debug, PartialEq, Eq, Hash)]\n-pub enum ScopeDef {\n-    ModuleDef(ModuleDef),\n-    MacroDef(MacroDef),\n-    GenericParam(GenericParam),\n-    ImplSelfType(Impl),\n-    AdtSelfType(Adt),\n-    Local(Local),\n-    Unknown,\n-}\n-\n-impl ScopeDef {\n-    pub fn all_items(def: PerNs) -> ArrayVec<[Self; 3]> {\n-        let mut items = ArrayVec::new();\n-\n-        match (def.take_types(), def.take_values()) {\n-            (Some(m1), None) => items.push(ScopeDef::ModuleDef(m1.into())),\n-            (None, Some(m2)) => items.push(ScopeDef::ModuleDef(m2.into())),\n-            (Some(m1), Some(m2)) => {\n-                // Some items, like unit structs and enum variants, are\n-                // returned as both a type and a value. Here we want\n-                // to de-duplicate them.\n-                if m1 != m2 {\n-                    items.push(ScopeDef::ModuleDef(m1.into()));\n-                    items.push(ScopeDef::ModuleDef(m2.into()));\n-                } else {\n-                    items.push(ScopeDef::ModuleDef(m1.into()));\n-                }\n-            }\n-            (None, None) => {}\n-        };\n-\n-        if let Some(macro_def_id) = def.take_macros() {\n-            items.push(ScopeDef::MacroDef(macro_def_id.into()));\n-        }\n-\n-        if items.is_empty() {\n-            items.push(ScopeDef::Unknown);\n-        }\n-\n-        items\n-    }\n-}\n-\n-pub trait HasVisibility {\n-    fn visibility(&self, db: &dyn HirDatabase) -> Visibility;\n-    fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {\n-        let vis = self.visibility(db);\n-        vis.is_visible_from(db.upcast(), module.id)\n-    }\n-}"}, {"sha": "179b9d51ef06f722981e3c8b8092519d8f30a2ca", "filename": "crates/hir/src/from_id.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=c5189a22ccf4c28e309e4189defbb88b83bb2aea", "patch": "@@ -11,9 +11,8 @@ use hir_def::{\n };\n \n use crate::{\n-    code_model::{BuiltinType, GenericParam},\n-    Adt, AssocItem, DefWithBody, Field, GenericDef, Label, Local, MacroDef, ModuleDef, Variant,\n-    VariantDef,\n+    Adt, AssocItem, BuiltinType, DefWithBody, Field, GenericDef, GenericParam, Label, Local,\n+    MacroDef, ModuleDef, Variant, VariantDef,\n };\n \n macro_rules! from_id {"}, {"sha": "62692c2c18dc4614a5b60a553131e93ac1629d6a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2118, "deletions": 29, "changes": 2147, "blob_url": "https://github.com/rust-lang/rust/blob/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=c5189a22ccf4c28e309e4189defbb88b83bb2aea", "patch": "@@ -20,49 +20,2138 @@\n #![recursion_limit = \"512\"]\n \n mod semantics;\n-pub mod db;\n mod source_analyzer;\n \n-pub mod diagnostics;\n-\n mod from_id;\n-mod code_model;\n mod attrs;\n mod has_source;\n \n+pub mod diagnostics;\n+pub mod db;\n+\n+use std::{iter, sync::Arc};\n+\n+use arrayvec::ArrayVec;\n+use base_db::{CrateDisplayName, CrateId, Edition, FileId};\n+use either::Either;\n+use hir_def::{\n+    adt::{ReprKind, VariantData},\n+    expr::{BindingAnnotation, LabelId, Pat, PatId},\n+    item_tree::ItemTreeNode,\n+    lang_item::LangItemTarget,\n+    per_ns::PerNs,\n+    resolver::{HasResolver, Resolver},\n+    src::HasSource as _,\n+    AdtId, AssocContainerId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId,\n+    DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule, ImplId, LifetimeParamId,\n+    LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n+    TypeParamId, UnionId,\n+};\n+use hir_expand::{diagnostics::DiagnosticSink, name::name, MacroDefKind};\n+use hir_ty::{\n+    autoderef,\n+    display::{write_bounds_like_dyn_trait_with_prefix, HirDisplayError, HirFormatter},\n+    method_resolution,\n+    traits::{FnTrait, Solution, SolutionVariables},\n+    AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, DebruijnIndex, GenericPredicate,\n+    InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment,\n+    Ty, TyDefId, TyVariableKind,\n+};\n+use rustc_hash::FxHashSet;\n+use stdx::{format_to, impl_from};\n+use syntax::{\n+    ast::{self, AttrsOwner, NameOwner},\n+    AstNode, SmolStr,\n+};\n+use tt::{Ident, Leaf, Literal, TokenTree};\n+\n+use crate::db::{DefDatabase, HirDatabase};\n+\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n-    code_model::{\n-        Access, Adt, AsAssocItem, AssocItem, AssocItemContainer, BuiltinType, Callable,\n-        CallableKind, Const, ConstParam, Crate, CrateDependency, DefWithBody, Enum, Field,\n-        FieldSource, Function, GenericDef, GenericParam, HasVisibility, Impl, Label, LifetimeParam,\n-        Local, MacroDef, Module, ModuleDef, ScopeDef, Static, Struct, Trait, Type, TypeAlias,\n-        TypeParam, Union, Variant, VariantDef,\n-    },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope},\n };\n \n-pub use hir_def::{\n-    adt::StructKind,\n-    attr::{Attrs, Documentation},\n-    body::scope::ExprScopes,\n-    find_path::PrefixKind,\n-    import_map,\n-    item_scope::ItemInNs,\n-    nameres::ModuleSource,\n-    path::{ModPath, PathKind},\n-    type_ref::{Mutability, TypeRef},\n-    visibility::Visibility,\n-};\n-pub use hir_expand::{\n-    name::{known, AsName, Name},\n-    ExpandResult, HirFileId, InFile, MacroCallId, MacroCallLoc, /* FIXME */ MacroDefId,\n-    MacroFile, Origin,\n+// Be careful with these re-exports.\n+//\n+// `hir` is the boundary between the compiler and the IDE. It should try hard to\n+// isolate the compiler from the ide, to allow the two to be refactored\n+// independently. Re-exporting something from the compiler is the sure way to\n+// breach the boundary.\n+//\n+// Generally, a refactoring which *removes* a name from this list is a good\n+// idea!\n+pub use {\n+    hir_def::{\n+        adt::StructKind,\n+        attr::{Attrs, Documentation},\n+        body::scope::ExprScopes,\n+        find_path::PrefixKind,\n+        import_map,\n+        item_scope::ItemInNs,\n+        nameres::ModuleSource,\n+        path::{ModPath, PathKind},\n+        type_ref::{Mutability, TypeRef},\n+        visibility::Visibility,\n+    },\n+    hir_expand::{\n+        name::{known, Name},\n+        ExpandResult, HirFileId, InFile, MacroCallId, MacroCallLoc, /* FIXME */ MacroDefId,\n+        MacroFile, Origin,\n+    },\n+    hir_ty::display::HirDisplay,\n };\n-pub use hir_ty::display::HirDisplay;\n \n // These are negative re-exports: pub using these names is forbidden, they\n // should remain private to hir internals.\n #[allow(unused)]\n-use {hir_def::path::Path, hir_expand::hygiene::Hygiene};\n+use {\n+    hir_def::path::Path,\n+    hir_expand::{hygiene::Hygiene, name::AsName},\n+};\n+\n+/// hir::Crate describes a single crate. It's the main interface with which\n+/// a crate's dependencies interact. Mostly, it should be just a proxy for the\n+/// root module.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Crate {\n+    pub(crate) id: CrateId,\n+}\n+\n+#[derive(Debug)]\n+pub struct CrateDependency {\n+    pub krate: Crate,\n+    pub name: Name,\n+}\n+\n+impl Crate {\n+    pub fn dependencies(self, db: &dyn HirDatabase) -> Vec<CrateDependency> {\n+        db.crate_graph()[self.id]\n+            .dependencies\n+            .iter()\n+            .map(|dep| {\n+                let krate = Crate { id: dep.crate_id };\n+                let name = dep.as_name();\n+                CrateDependency { krate, name }\n+            })\n+            .collect()\n+    }\n+\n+    // FIXME: add `transitive_reverse_dependencies`.\n+    pub fn reverse_dependencies(self, db: &dyn HirDatabase) -> Vec<Crate> {\n+        let crate_graph = db.crate_graph();\n+        crate_graph\n+            .iter()\n+            .filter(|&krate| {\n+                crate_graph[krate].dependencies.iter().any(|it| it.crate_id == self.id)\n+            })\n+            .map(|id| Crate { id })\n+            .collect()\n+    }\n+\n+    pub fn root_module(self, db: &dyn HirDatabase) -> Module {\n+        let def_map = db.crate_def_map(self.id);\n+        Module { id: def_map.module_id(def_map.root()) }\n+    }\n+\n+    pub fn root_file(self, db: &dyn HirDatabase) -> FileId {\n+        db.crate_graph()[self.id].root_file_id\n+    }\n+\n+    pub fn edition(self, db: &dyn HirDatabase) -> Edition {\n+        db.crate_graph()[self.id].edition\n+    }\n+\n+    pub fn display_name(self, db: &dyn HirDatabase) -> Option<CrateDisplayName> {\n+        db.crate_graph()[self.id].display_name.clone()\n+    }\n+\n+    pub fn query_external_importables(\n+        self,\n+        db: &dyn DefDatabase,\n+        query: import_map::Query,\n+    ) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n+        import_map::search_dependencies(db, self.into(), query).into_iter().map(|item| match item {\n+            ItemInNs::Types(mod_id) | ItemInNs::Values(mod_id) => Either::Left(mod_id.into()),\n+            ItemInNs::Macros(mac_id) => Either::Right(mac_id.into()),\n+        })\n+    }\n+\n+    pub fn all(db: &dyn HirDatabase) -> Vec<Crate> {\n+        db.crate_graph().iter().map(|id| Crate { id }).collect()\n+    }\n+\n+    /// Try to get the root URL of the documentation of a crate.\n+    pub fn get_html_root_url(self: &Crate, db: &dyn HirDatabase) -> Option<String> {\n+        // Look for #![doc(html_root_url = \"...\")]\n+        let attrs = db.attrs(AttrDefId::ModuleId(self.root_module(db).into()));\n+        let doc_attr_q = attrs.by_key(\"doc\");\n+\n+        if !doc_attr_q.exists() {\n+            return None;\n+        }\n+\n+        let doc_url = doc_attr_q.tt_values().map(|tt| {\n+            let name = tt.token_trees.iter()\n+                .skip_while(|tt| !matches!(tt, TokenTree::Leaf(Leaf::Ident(Ident{text: ref ident, ..})) if ident == \"html_root_url\"))\n+                .skip(2)\n+                .next();\n+\n+            match name {\n+                Some(TokenTree::Leaf(Leaf::Literal(Literal{ref text, ..}))) => Some(text),\n+                _ => None\n+            }\n+        }).flat_map(|t| t).next();\n+\n+        doc_url.map(|s| s.trim_matches('\"').trim_end_matches('/').to_owned() + \"/\")\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Module {\n+    pub(crate) id: ModuleId,\n+}\n+\n+/// The defs which can be visible in the module.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum ModuleDef {\n+    Module(Module),\n+    Function(Function),\n+    Adt(Adt),\n+    // Can't be directly declared, but can be imported.\n+    Variant(Variant),\n+    Const(Const),\n+    Static(Static),\n+    Trait(Trait),\n+    TypeAlias(TypeAlias),\n+    BuiltinType(BuiltinType),\n+}\n+impl_from!(\n+    Module,\n+    Function,\n+    Adt(Struct, Enum, Union),\n+    Variant,\n+    Const,\n+    Static,\n+    Trait,\n+    TypeAlias,\n+    BuiltinType\n+    for ModuleDef\n+);\n+\n+impl From<VariantDef> for ModuleDef {\n+    fn from(var: VariantDef) -> Self {\n+        match var {\n+            VariantDef::Struct(t) => Adt::from(t).into(),\n+            VariantDef::Union(t) => Adt::from(t).into(),\n+            VariantDef::Variant(t) => t.into(),\n+        }\n+    }\n+}\n+\n+impl ModuleDef {\n+    pub fn module(self, db: &dyn HirDatabase) -> Option<Module> {\n+        match self {\n+            ModuleDef::Module(it) => it.parent(db),\n+            ModuleDef::Function(it) => Some(it.module(db)),\n+            ModuleDef::Adt(it) => Some(it.module(db)),\n+            ModuleDef::Variant(it) => Some(it.module(db)),\n+            ModuleDef::Const(it) => Some(it.module(db)),\n+            ModuleDef::Static(it) => Some(it.module(db)),\n+            ModuleDef::Trait(it) => Some(it.module(db)),\n+            ModuleDef::TypeAlias(it) => Some(it.module(db)),\n+            ModuleDef::BuiltinType(_) => None,\n+        }\n+    }\n+\n+    pub fn canonical_path(&self, db: &dyn HirDatabase) -> Option<String> {\n+        let mut segments = Vec::new();\n+        segments.push(self.name(db)?.to_string());\n+        for m in self.module(db)?.path_to_root(db) {\n+            segments.extend(m.name(db).map(|it| it.to_string()))\n+        }\n+        segments.reverse();\n+        Some(segments.join(\"::\"))\n+    }\n+\n+    pub fn definition_visibility(&self, db: &dyn HirDatabase) -> Option<Visibility> {\n+        let module = match self {\n+            ModuleDef::Module(it) => it.parent(db)?,\n+            ModuleDef::Function(it) => return Some(it.visibility(db)),\n+            ModuleDef::Adt(it) => it.module(db),\n+            ModuleDef::Variant(it) => {\n+                let parent = it.parent_enum(db);\n+                let module = it.module(db);\n+                return module.visibility_of(db, &ModuleDef::Adt(Adt::Enum(parent)));\n+            }\n+            ModuleDef::Const(it) => return Some(it.visibility(db)),\n+            ModuleDef::Static(it) => it.module(db),\n+            ModuleDef::Trait(it) => it.module(db),\n+            ModuleDef::TypeAlias(it) => return Some(it.visibility(db)),\n+            ModuleDef::BuiltinType(_) => return None,\n+        };\n+\n+        module.visibility_of(db, self)\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+        match self {\n+            ModuleDef::Adt(it) => Some(it.name(db)),\n+            ModuleDef::Trait(it) => Some(it.name(db)),\n+            ModuleDef::Function(it) => Some(it.name(db)),\n+            ModuleDef::Variant(it) => Some(it.name(db)),\n+            ModuleDef::TypeAlias(it) => Some(it.name(db)),\n+            ModuleDef::Module(it) => it.name(db),\n+            ModuleDef::Const(it) => it.name(db),\n+            ModuleDef::Static(it) => it.name(db),\n+\n+            ModuleDef::BuiltinType(it) => Some(it.name()),\n+        }\n+    }\n+\n+    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n+        let id = match self {\n+            ModuleDef::Adt(it) => match it {\n+                Adt::Struct(it) => it.id.into(),\n+                Adt::Enum(it) => it.id.into(),\n+                Adt::Union(it) => it.id.into(),\n+            },\n+            ModuleDef::Trait(it) => it.id.into(),\n+            ModuleDef::Function(it) => it.id.into(),\n+            ModuleDef::TypeAlias(it) => it.id.into(),\n+            ModuleDef::Module(it) => it.id.into(),\n+            ModuleDef::Const(it) => it.id.into(),\n+            ModuleDef::Static(it) => it.id.into(),\n+            _ => return,\n+        };\n+\n+        let module = match self.module(db) {\n+            Some(it) => it,\n+            None => return,\n+        };\n+\n+        hir_ty::diagnostics::validate_module_item(db, module.id.krate(), id, sink)\n+    }\n+}\n+\n+impl Module {\n+    /// Name of this module.\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+        let def_map = self.id.def_map(db.upcast());\n+        let parent = def_map[self.id.local_id].parent?;\n+        def_map[parent].children.iter().find_map(|(name, module_id)| {\n+            if *module_id == self.id.local_id {\n+                Some(name.clone())\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// Returns the crate this module is part of.\n+    pub fn krate(self) -> Crate {\n+        Crate { id: self.id.krate() }\n+    }\n+\n+    /// Topmost parent of this module. Every module has a `crate_root`, but some\n+    /// might be missing `krate`. This can happen if a module's file is not included\n+    /// in the module tree of any target in `Cargo.toml`.\n+    pub fn crate_root(self, db: &dyn HirDatabase) -> Module {\n+        let def_map = db.crate_def_map(self.id.krate());\n+        Module { id: def_map.module_id(def_map.root()) }\n+    }\n+\n+    /// Iterates over all child modules.\n+    pub fn children(self, db: &dyn HirDatabase) -> impl Iterator<Item = Module> {\n+        let def_map = self.id.def_map(db.upcast());\n+        let children = def_map[self.id.local_id]\n+            .children\n+            .iter()\n+            .map(|(_, module_id)| Module { id: def_map.module_id(*module_id) })\n+            .collect::<Vec<_>>();\n+        children.into_iter()\n+    }\n+\n+    /// Finds a parent module.\n+    pub fn parent(self, db: &dyn HirDatabase) -> Option<Module> {\n+        // FIXME: handle block expressions as modules (their parent is in a different DefMap)\n+        let def_map = self.id.def_map(db.upcast());\n+        let parent_id = def_map[self.id.local_id].parent?;\n+        Some(Module { id: def_map.module_id(parent_id) })\n+    }\n+\n+    pub fn path_to_root(self, db: &dyn HirDatabase) -> Vec<Module> {\n+        let mut res = vec![self];\n+        let mut curr = self;\n+        while let Some(next) = curr.parent(db) {\n+            res.push(next);\n+            curr = next\n+        }\n+        res\n+    }\n+\n+    /// Returns a `ModuleScope`: a set of items, visible in this module.\n+    pub fn scope(\n+        self,\n+        db: &dyn HirDatabase,\n+        visible_from: Option<Module>,\n+    ) -> Vec<(Name, ScopeDef)> {\n+        self.id.def_map(db.upcast())[self.id.local_id]\n+            .scope\n+            .entries()\n+            .filter_map(|(name, def)| {\n+                if let Some(m) = visible_from {\n+                    let filtered =\n+                        def.filter_visibility(|vis| vis.is_visible_from(db.upcast(), m.id));\n+                    if filtered.is_none() && !def.is_none() {\n+                        None\n+                    } else {\n+                        Some((name, filtered))\n+                    }\n+                } else {\n+                    Some((name, def))\n+                }\n+            })\n+            .flat_map(|(name, def)| {\n+                ScopeDef::all_items(def).into_iter().map(move |item| (name.clone(), item))\n+            })\n+            .collect()\n+    }\n+\n+    pub fn visibility_of(self, db: &dyn HirDatabase, def: &ModuleDef) -> Option<Visibility> {\n+        self.id.def_map(db.upcast())[self.id.local_id].scope.visibility_of(def.clone().into())\n+    }\n+\n+    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n+        let _p = profile::span(\"Module::diagnostics\").detail(|| {\n+            format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n+        });\n+        let def_map = self.id.def_map(db.upcast());\n+        def_map.add_diagnostics(db.upcast(), self.id.local_id, sink);\n+        for decl in self.declarations(db) {\n+            match decl {\n+                crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n+                crate::ModuleDef::Module(m) => {\n+                    // Only add diagnostics from inline modules\n+                    if def_map[m.id.local_id].origin.is_inline() {\n+                        m.diagnostics(db, sink)\n+                    }\n+                }\n+                _ => {\n+                    decl.diagnostics(db, sink);\n+                }\n+            }\n+        }\n+\n+        for impl_def in self.impl_defs(db) {\n+            for item in impl_def.items(db) {\n+                if let AssocItem::Function(f) = item {\n+                    f.diagnostics(db, sink);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn declarations(self, db: &dyn HirDatabase) -> Vec<ModuleDef> {\n+        let def_map = self.id.def_map(db.upcast());\n+        def_map[self.id.local_id].scope.declarations().map(ModuleDef::from).collect()\n+    }\n+\n+    pub fn impl_defs(self, db: &dyn HirDatabase) -> Vec<Impl> {\n+        let def_map = self.id.def_map(db.upcast());\n+        def_map[self.id.local_id].scope.impls().map(Impl::from).collect()\n+    }\n+\n+    /// Finds a path that can be used to refer to the given item from within\n+    /// this module, if possible.\n+    pub fn find_use_path(self, db: &dyn DefDatabase, item: impl Into<ItemInNs>) -> Option<ModPath> {\n+        hir_def::find_path::find_path(db, item.into(), self.into())\n+    }\n+\n+    /// Finds a path that can be used to refer to the given item from within\n+    /// this module, if possible. This is used for returning import paths for use-statements.\n+    pub fn find_use_path_prefixed(\n+        self,\n+        db: &dyn DefDatabase,\n+        item: impl Into<ItemInNs>,\n+        prefix_kind: PrefixKind,\n+    ) -> Option<ModPath> {\n+        hir_def::find_path::find_path_prefixed(db, item.into(), self.into(), prefix_kind)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Field {\n+    pub(crate) parent: VariantDef,\n+    pub(crate) id: LocalFieldId,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum FieldSource {\n+    Named(ast::RecordField),\n+    Pos(ast::TupleField),\n+}\n+\n+impl Field {\n+    pub fn name(&self, db: &dyn HirDatabase) -> Name {\n+        self.parent.variant_data(db).fields()[self.id].name.clone()\n+    }\n+\n+    /// Returns the type as in the signature of the struct (i.e., with\n+    /// placeholder types for type parameters). This is good for showing\n+    /// signature help, but not so good to actually get the type of the field\n+    /// when you actually have a variable of the struct.\n+    pub fn signature_ty(&self, db: &dyn HirDatabase) -> Type {\n+        let var_id = self.parent.into();\n+        let generic_def_id: GenericDefId = match self.parent {\n+            VariantDef::Struct(it) => it.id.into(),\n+            VariantDef::Union(it) => it.id.into(),\n+            VariantDef::Variant(it) => it.parent.id.into(),\n+        };\n+        let substs = Substs::type_params(db, generic_def_id);\n+        let ty = db.field_types(var_id)[self.id].clone().subst(&substs);\n+        Type::new(db, self.parent.module(db).id.krate(), var_id, ty)\n+    }\n+\n+    pub fn parent_def(&self, _db: &dyn HirDatabase) -> VariantDef {\n+        self.parent\n+    }\n+}\n+\n+impl HasVisibility for Field {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        let variant_data = self.parent.variant_data(db);\n+        let visibility = &variant_data.fields()[self.id].visibility;\n+        let parent_id: hir_def::VariantId = self.parent.into();\n+        visibility.resolve(db.upcast(), &parent_id.resolver(db.upcast()))\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Struct {\n+    pub(crate) id: StructId,\n+}\n+\n+impl Struct {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n+    }\n+\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n+        Some(self.module(db).krate())\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        db.struct_data(self.id).name.clone()\n+    }\n+\n+    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {\n+        db.struct_data(self.id)\n+            .variant_data\n+            .fields()\n+            .iter()\n+            .map(|(id, _)| Field { parent: self.into(), id })\n+            .collect()\n+    }\n+\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_def(\n+            db,\n+            self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n+            self.id,\n+        )\n+    }\n+\n+    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprKind> {\n+        db.struct_data(self.id).repr.clone()\n+    }\n+\n+    pub fn kind(self, db: &dyn HirDatabase) -> StructKind {\n+        self.variant_data(db).kind()\n+    }\n+\n+    fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n+        db.struct_data(self.id).variant_data.clone()\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Union {\n+    pub(crate) id: UnionId,\n+}\n+\n+impl Union {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        db.union_data(self.id).name.clone()\n+    }\n+\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n+    }\n+\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_def(\n+            db,\n+            self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n+            self.id,\n+        )\n+    }\n+\n+    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {\n+        db.union_data(self.id)\n+            .variant_data\n+            .fields()\n+            .iter()\n+            .map(|(id, _)| Field { parent: self.into(), id })\n+            .collect()\n+    }\n+\n+    fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n+        db.union_data(self.id).variant_data.clone()\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Enum {\n+    pub(crate) id: EnumId,\n+}\n+\n+impl Enum {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n+    }\n+\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n+        Some(self.module(db).krate())\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        db.enum_data(self.id).name.clone()\n+    }\n+\n+    pub fn variants(self, db: &dyn HirDatabase) -> Vec<Variant> {\n+        db.enum_data(self.id).variants.iter().map(|(id, _)| Variant { parent: self, id }).collect()\n+    }\n+\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_def(\n+            db,\n+            self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n+            self.id,\n+        )\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Variant {\n+    pub(crate) parent: Enum,\n+    pub(crate) id: LocalEnumVariantId,\n+}\n+\n+impl Variant {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        self.parent.module(db)\n+    }\n+    pub fn parent_enum(self, _db: &dyn HirDatabase) -> Enum {\n+        self.parent\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        db.enum_data(self.parent.id).variants[self.id].name.clone()\n+    }\n+\n+    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {\n+        self.variant_data(db)\n+            .fields()\n+            .iter()\n+            .map(|(id, _)| Field { parent: self.into(), id })\n+            .collect()\n+    }\n+\n+    pub fn kind(self, db: &dyn HirDatabase) -> StructKind {\n+        self.variant_data(db).kind()\n+    }\n+\n+    pub(crate) fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n+        db.enum_data(self.parent.id).variants[self.id].variant_data.clone()\n+    }\n+}\n+\n+/// A Data Type\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum Adt {\n+    Struct(Struct),\n+    Union(Union),\n+    Enum(Enum),\n+}\n+impl_from!(Struct, Union, Enum for Adt);\n+\n+impl Adt {\n+    pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n+        let subst = db.generic_defaults(self.into());\n+        subst.iter().any(|ty| &ty.value == &Ty::Unknown)\n+    }\n+\n+    /// Turns this ADT into a type. Any type parameters of the ADT will be\n+    /// turned into unknown types, which is good for e.g. finding the most\n+    /// general set of completions, but will not look very nice when printed.\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        let id = AdtId::from(self);\n+        Type::from_def(db, id.module(db.upcast()).krate(), id)\n+    }\n+\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        match self {\n+            Adt::Struct(s) => s.module(db),\n+            Adt::Union(s) => s.module(db),\n+            Adt::Enum(e) => e.module(db),\n+        }\n+    }\n+\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n+        Some(self.module(db).krate())\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        match self {\n+            Adt::Struct(s) => s.name(db),\n+            Adt::Union(u) => u.name(db),\n+            Adt::Enum(e) => e.name(db),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum VariantDef {\n+    Struct(Struct),\n+    Union(Union),\n+    Variant(Variant),\n+}\n+impl_from!(Struct, Union, Variant for VariantDef);\n+\n+impl VariantDef {\n+    pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {\n+        match self {\n+            VariantDef::Struct(it) => it.fields(db),\n+            VariantDef::Union(it) => it.fields(db),\n+            VariantDef::Variant(it) => it.fields(db),\n+        }\n+    }\n+\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        match self {\n+            VariantDef::Struct(it) => it.module(db),\n+            VariantDef::Union(it) => it.module(db),\n+            VariantDef::Variant(it) => it.module(db),\n+        }\n+    }\n+\n+    pub fn name(&self, db: &dyn HirDatabase) -> Name {\n+        match self {\n+            VariantDef::Struct(s) => s.name(db),\n+            VariantDef::Union(u) => u.name(db),\n+            VariantDef::Variant(e) => e.name(db),\n+        }\n+    }\n+\n+    pub(crate) fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n+        match self {\n+            VariantDef::Struct(it) => it.variant_data(db),\n+            VariantDef::Union(it) => it.variant_data(db),\n+            VariantDef::Variant(it) => it.variant_data(db),\n+        }\n+    }\n+}\n+\n+/// The defs which have a body.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum DefWithBody {\n+    Function(Function),\n+    Static(Static),\n+    Const(Const),\n+}\n+impl_from!(Function, Const, Static for DefWithBody);\n+\n+impl DefWithBody {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        match self {\n+            DefWithBody::Const(c) => c.module(db),\n+            DefWithBody::Function(f) => f.module(db),\n+            DefWithBody::Static(s) => s.module(db),\n+        }\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+        match self {\n+            DefWithBody::Function(f) => Some(f.name(db)),\n+            DefWithBody::Static(s) => s.name(db),\n+            DefWithBody::Const(c) => c.name(db),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Function {\n+    pub(crate) id: FunctionId,\n+}\n+\n+impl Function {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        self.id.lookup(db.upcast()).module(db.upcast()).into()\n+    }\n+\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n+        Some(self.module(db).krate())\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        db.function_data(self.id).name.clone()\n+    }\n+\n+    /// Get this function's return type\n+    pub fn ret_type(self, db: &dyn HirDatabase) -> Type {\n+        let resolver = self.id.resolver(db.upcast());\n+        let ret_type = &db.function_data(self.id).ret_type;\n+        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        Type {\n+            krate: self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n+            ty: InEnvironment { value: Ty::from_hir_ext(&ctx, ret_type).0, environment },\n+        }\n+    }\n+\n+    pub fn self_param(self, db: &dyn HirDatabase) -> Option<SelfParam> {\n+        if !db.function_data(self.id).has_self_param {\n+            return None;\n+        }\n+        Some(SelfParam { func: self.id })\n+    }\n+\n+    pub fn assoc_fn_params(self, db: &dyn HirDatabase) -> Vec<Param> {\n+        let resolver = self.id.resolver(db.upcast());\n+        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        db.function_data(self.id)\n+            .params\n+            .iter()\n+            .map(|type_ref| {\n+                let ty = Type {\n+                    krate: self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n+                    ty: InEnvironment {\n+                        value: Ty::from_hir_ext(&ctx, type_ref).0,\n+                        environment: environment.clone(),\n+                    },\n+                };\n+                Param { ty }\n+            })\n+            .collect()\n+    }\n+    pub fn method_params(self, db: &dyn HirDatabase) -> Option<Vec<Param>> {\n+        if self.self_param(db).is_none() {\n+            return None;\n+        }\n+        let mut res = self.assoc_fn_params(db);\n+        res.remove(0);\n+        Some(res)\n+    }\n+\n+    pub fn is_unsafe(self, db: &dyn HirDatabase) -> bool {\n+        db.function_data(self.id).is_unsafe\n+    }\n+\n+    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n+        let krate = self.module(db).id.krate();\n+        hir_def::diagnostics::validate_body(db.upcast(), self.id.into(), sink);\n+        hir_ty::diagnostics::validate_module_item(db, krate, self.id.into(), sink);\n+        hir_ty::diagnostics::validate_body(db, self.id.into(), sink);\n+    }\n+\n+    /// Whether this function declaration has a definition.\n+    ///\n+    /// This is false in the case of required (not provided) trait methods.\n+    pub fn has_body(self, db: &dyn HirDatabase) -> bool {\n+        db.function_data(self.id).has_body\n+    }\n+\n+    /// A textual representation of the HIR of this function for debugging purposes.\n+    pub fn debug_hir(self, db: &dyn HirDatabase) -> String {\n+        let body = db.body(self.id.into());\n+\n+        let mut result = String::new();\n+        format_to!(result, \"HIR expressions in the body of `{}`:\\n\", self.name(db));\n+        for (id, expr) in body.exprs.iter() {\n+            format_to!(result, \"{:?}: {:?}\\n\", id, expr);\n+        }\n+\n+        result\n+    }\n+}\n+\n+// Note: logically, this belongs to `hir_ty`, but we are not using it there yet.\n+pub enum Access {\n+    Shared,\n+    Exclusive,\n+    Owned,\n+}\n+\n+impl From<hir_ty::Mutability> for Access {\n+    fn from(mutability: hir_ty::Mutability) -> Access {\n+        match mutability {\n+            hir_ty::Mutability::Not => Access::Shared,\n+            hir_ty::Mutability::Mut => Access::Exclusive,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Param {\n+    ty: Type,\n+}\n+\n+impl Param {\n+    pub fn ty(&self) -> &Type {\n+        &self.ty\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SelfParam {\n+    func: FunctionId,\n+}\n+\n+impl SelfParam {\n+    pub fn access(self, db: &dyn HirDatabase) -> Access {\n+        let func_data = db.function_data(self.func);\n+        func_data\n+            .params\n+            .first()\n+            .map(|param| match *param {\n+                TypeRef::Reference(.., mutability) => match mutability {\n+                    hir_def::type_ref::Mutability::Shared => Access::Shared,\n+                    hir_def::type_ref::Mutability::Mut => Access::Exclusive,\n+                },\n+                _ => Access::Owned,\n+            })\n+            .unwrap_or(Access::Owned)\n+    }\n+}\n+\n+impl HasVisibility for Function {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        let function_data = db.function_data(self.id);\n+        let visibility = &function_data.visibility;\n+        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Const {\n+    pub(crate) id: ConstId,\n+}\n+\n+impl Const {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n+    }\n+\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n+        Some(self.module(db).krate())\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+        db.const_data(self.id).name.clone()\n+    }\n+}\n+\n+impl HasVisibility for Const {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        let function_data = db.const_data(self.id);\n+        let visibility = &function_data.visibility;\n+        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Static {\n+    pub(crate) id: StaticId,\n+}\n+\n+impl Static {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n+    }\n+\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n+        Some(self.module(db).krate())\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+        db.static_data(self.id).name.clone()\n+    }\n+\n+    pub fn is_mut(self, db: &dyn HirDatabase) -> bool {\n+        db.static_data(self.id).mutable\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Trait {\n+    pub(crate) id: TraitId,\n+}\n+\n+impl Trait {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).container.module(db.upcast()) }\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        db.trait_data(self.id).name.clone()\n+    }\n+\n+    pub fn items(self, db: &dyn HirDatabase) -> Vec<AssocItem> {\n+        db.trait_data(self.id).items.iter().map(|(_name, it)| (*it).into()).collect()\n+    }\n+\n+    pub fn is_auto(self, db: &dyn HirDatabase) -> bool {\n+        db.trait_data(self.id).auto\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TypeAlias {\n+    pub(crate) id: TypeAliasId,\n+}\n+\n+impl TypeAlias {\n+    pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n+        let subst = db.generic_defaults(self.id.into());\n+        subst.iter().any(|ty| &ty.value == &Ty::Unknown)\n+    }\n+\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n+    }\n+\n+    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n+        Some(self.module(db).krate())\n+    }\n+\n+    pub fn type_ref(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n+        db.type_alias_data(self.id).type_ref.clone()\n+    }\n+\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_def(db, self.id.lookup(db.upcast()).module(db.upcast()).krate(), self.id)\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        db.type_alias_data(self.id).name.clone()\n+    }\n+}\n+\n+impl HasVisibility for TypeAlias {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        let function_data = db.type_alias_data(self.id);\n+        let visibility = &function_data.visibility;\n+        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct BuiltinType {\n+    pub(crate) inner: hir_def::builtin_type::BuiltinType,\n+}\n+\n+impl BuiltinType {\n+    pub fn ty(self, db: &dyn HirDatabase, module: Module) -> Type {\n+        let resolver = module.id.resolver(db.upcast());\n+        Type::new_with_resolver(db, &resolver, Ty::builtin(self.inner))\n+            .expect(\"crate not present in resolver\")\n+    }\n+\n+    pub fn name(self) -> Name {\n+        self.inner.as_name()\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroDef {\n+    pub(crate) id: MacroDefId,\n+}\n+\n+impl MacroDef {\n+    /// FIXME: right now, this just returns the root module of the crate that\n+    /// defines this macro. The reasons for this is that macros are expanded\n+    /// early, in `hir_expand`, where modules simply do not exist yet.\n+    pub fn module(self, db: &dyn HirDatabase) -> Option<Module> {\n+        let krate = self.id.krate;\n+        let def_map = db.crate_def_map(krate);\n+        let module_id = def_map.root();\n+        Some(Module { id: def_map.module_id(module_id) })\n+    }\n+\n+    /// XXX: this parses the file\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+        self.source(db)?.value.name().map(|it| it.as_name())\n+    }\n+\n+    /// Indicate it is a proc-macro\n+    pub fn is_proc_macro(&self) -> bool {\n+        matches!(self.id.kind, MacroDefKind::ProcMacro(_))\n+    }\n+\n+    /// Indicate it is a derive macro\n+    pub fn is_derive_macro(&self) -> bool {\n+        matches!(self.id.kind, MacroDefKind::ProcMacro(_) | MacroDefKind::BuiltInDerive(_))\n+    }\n+}\n+\n+/// Invariant: `inner.as_assoc_item(db).is_some()`\n+/// We do not actively enforce this invariant.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum AssocItem {\n+    Function(Function),\n+    Const(Const),\n+    TypeAlias(TypeAlias),\n+}\n+pub enum AssocItemContainer {\n+    Trait(Trait),\n+    Impl(Impl),\n+}\n+pub trait AsAssocItem {\n+    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem>;\n+}\n+\n+impl AsAssocItem for Function {\n+    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n+        as_assoc_item(db, AssocItem::Function, self.id)\n+    }\n+}\n+impl AsAssocItem for Const {\n+    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n+        as_assoc_item(db, AssocItem::Const, self.id)\n+    }\n+}\n+impl AsAssocItem for TypeAlias {\n+    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n+        as_assoc_item(db, AssocItem::TypeAlias, self.id)\n+    }\n+}\n+impl AsAssocItem for ModuleDef {\n+    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n+        match self {\n+            ModuleDef::Function(it) => it.as_assoc_item(db),\n+            ModuleDef::Const(it) => it.as_assoc_item(db),\n+            ModuleDef::TypeAlias(it) => it.as_assoc_item(db),\n+            _ => None,\n+        }\n+    }\n+}\n+fn as_assoc_item<ID, DEF, CTOR, AST>(db: &dyn HirDatabase, ctor: CTOR, id: ID) -> Option<AssocItem>\n+where\n+    ID: Lookup<Data = AssocItemLoc<AST>>,\n+    DEF: From<ID>,\n+    CTOR: FnOnce(DEF) -> AssocItem,\n+    AST: ItemTreeNode,\n+{\n+    match id.lookup(db.upcast()).container {\n+        AssocContainerId::TraitId(_) | AssocContainerId::ImplId(_) => Some(ctor(DEF::from(id))),\n+        AssocContainerId::ContainerId(_) => None,\n+    }\n+}\n+\n+impl AssocItem {\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+        match self {\n+            AssocItem::Function(it) => Some(it.name(db)),\n+            AssocItem::Const(it) => it.name(db),\n+            AssocItem::TypeAlias(it) => Some(it.name(db)),\n+        }\n+    }\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        match self {\n+            AssocItem::Function(f) => f.module(db),\n+            AssocItem::Const(c) => c.module(db),\n+            AssocItem::TypeAlias(t) => t.module(db),\n+        }\n+    }\n+    pub fn container(self, db: &dyn HirDatabase) -> AssocItemContainer {\n+        let container = match self {\n+            AssocItem::Function(it) => it.id.lookup(db.upcast()).container,\n+            AssocItem::Const(it) => it.id.lookup(db.upcast()).container,\n+            AssocItem::TypeAlias(it) => it.id.lookup(db.upcast()).container,\n+        };\n+        match container {\n+            AssocContainerId::TraitId(id) => AssocItemContainer::Trait(id.into()),\n+            AssocContainerId::ImplId(id) => AssocItemContainer::Impl(id.into()),\n+            AssocContainerId::ContainerId(_) => panic!(\"invalid AssocItem\"),\n+        }\n+    }\n+\n+    pub fn containing_trait(self, db: &dyn HirDatabase) -> Option<Trait> {\n+        match self.container(db) {\n+            AssocItemContainer::Trait(t) => Some(t),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl HasVisibility for AssocItem {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        match self {\n+            AssocItem::Function(f) => f.visibility(db),\n+            AssocItem::Const(c) => c.visibility(db),\n+            AssocItem::TypeAlias(t) => t.visibility(db),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericDef {\n+    Function(Function),\n+    Adt(Adt),\n+    Trait(Trait),\n+    TypeAlias(TypeAlias),\n+    Impl(Impl),\n+    // enum variants cannot have generics themselves, but their parent enums\n+    // can, and this makes some code easier to write\n+    Variant(Variant),\n+    // consts can have type parameters from their parents (i.e. associated consts of traits)\n+    Const(Const),\n+}\n+impl_from!(\n+    Function,\n+    Adt(Struct, Enum, Union),\n+    Trait,\n+    TypeAlias,\n+    Impl,\n+    Variant,\n+    Const\n+    for GenericDef\n+);\n+\n+impl GenericDef {\n+    pub fn params(self, db: &dyn HirDatabase) -> Vec<GenericParam> {\n+        let generics = db.generic_params(self.into());\n+        let ty_params = generics\n+            .types\n+            .iter()\n+            .map(|(local_id, _)| TypeParam { id: TypeParamId { parent: self.into(), local_id } })\n+            .map(GenericParam::TypeParam);\n+        let lt_params = generics\n+            .lifetimes\n+            .iter()\n+            .map(|(local_id, _)| LifetimeParam {\n+                id: LifetimeParamId { parent: self.into(), local_id },\n+            })\n+            .map(GenericParam::LifetimeParam);\n+        let const_params = generics\n+            .consts\n+            .iter()\n+            .map(|(local_id, _)| ConstParam { id: ConstParamId { parent: self.into(), local_id } })\n+            .map(GenericParam::ConstParam);\n+        ty_params.chain(lt_params).chain(const_params).collect()\n+    }\n+\n+    pub fn type_params(self, db: &dyn HirDatabase) -> Vec<TypeParam> {\n+        let generics = db.generic_params(self.into());\n+        generics\n+            .types\n+            .iter()\n+            .map(|(local_id, _)| TypeParam { id: TypeParamId { parent: self.into(), local_id } })\n+            .collect()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct Local {\n+    pub(crate) parent: DefWithBodyId,\n+    pub(crate) pat_id: PatId,\n+}\n+\n+impl Local {\n+    pub fn is_param(self, db: &dyn HirDatabase) -> bool {\n+        let src = self.source(db);\n+        match src.value {\n+            Either::Left(bind_pat) => {\n+                bind_pat.syntax().ancestors().any(|it| ast::Param::can_cast(it.kind()))\n+            }\n+            Either::Right(_self_param) => true,\n+        }\n+    }\n+\n+    // FIXME: why is this an option? It shouldn't be?\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+        let body = db.body(self.parent.into());\n+        match &body[self.pat_id] {\n+            Pat::Bind { name, .. } => Some(name.clone()),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn is_self(self, db: &dyn HirDatabase) -> bool {\n+        self.name(db) == Some(name![self])\n+    }\n+\n+    pub fn is_mut(self, db: &dyn HirDatabase) -> bool {\n+        let body = db.body(self.parent.into());\n+        match &body[self.pat_id] {\n+            Pat::Bind { mode, .. } => match mode {\n+                BindingAnnotation::Mutable | BindingAnnotation::RefMut => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn parent(self, _db: &dyn HirDatabase) -> DefWithBody {\n+        self.parent.into()\n+    }\n+\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        self.parent(db).module(db)\n+    }\n+\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        let def = DefWithBodyId::from(self.parent);\n+        let infer = db.infer(def);\n+        let ty = infer[self.pat_id].clone();\n+        let krate = def.module(db.upcast()).krate();\n+        Type::new(db, krate, def, ty)\n+    }\n+\n+    pub fn source(self, db: &dyn HirDatabase) -> InFile<Either<ast::IdentPat, ast::SelfParam>> {\n+        let (_body, source_map) = db.body_with_source_map(self.parent.into());\n+        let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n+        let root = src.file_syntax(db.upcast());\n+        src.map(|ast| {\n+            ast.map_left(|it| it.cast().unwrap().to_node(&root)).map_right(|it| it.to_node(&root))\n+        })\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct Label {\n+    pub(crate) parent: DefWithBodyId,\n+    pub(crate) label_id: LabelId,\n+}\n+\n+impl Label {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        self.parent(db).module(db)\n+    }\n+\n+    pub fn parent(self, _db: &dyn HirDatabase) -> DefWithBody {\n+        self.parent.into()\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        let body = db.body(self.parent.into());\n+        body[self.label_id].name.clone()\n+    }\n+\n+    pub fn source(self, db: &dyn HirDatabase) -> InFile<ast::Label> {\n+        let (_body, source_map) = db.body_with_source_map(self.parent.into());\n+        let src = source_map.label_syntax(self.label_id);\n+        let root = src.file_syntax(db.upcast());\n+        src.map(|ast| ast.to_node(&root))\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum GenericParam {\n+    TypeParam(TypeParam),\n+    LifetimeParam(LifetimeParam),\n+    ConstParam(ConstParam),\n+}\n+impl_from!(TypeParam, LifetimeParam, ConstParam for GenericParam);\n+\n+impl GenericParam {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        match self {\n+            GenericParam::TypeParam(it) => it.module(db),\n+            GenericParam::LifetimeParam(it) => it.module(db),\n+            GenericParam::ConstParam(it) => it.module(db),\n+        }\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        match self {\n+            GenericParam::TypeParam(it) => it.name(db),\n+            GenericParam::LifetimeParam(it) => it.name(db),\n+            GenericParam::ConstParam(it) => it.name(db),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct TypeParam {\n+    pub(crate) id: TypeParamId,\n+}\n+\n+impl TypeParam {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        let params = db.generic_params(self.id.parent);\n+        params.types[self.id.local_id].name.clone().unwrap_or_else(Name::missing)\n+    }\n+\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        self.id.parent.module(db.upcast()).into()\n+    }\n+\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        let resolver = self.id.parent.resolver(db.upcast());\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ty = Ty::Placeholder(self.id);\n+        Type {\n+            krate: self.id.parent.module(db.upcast()).krate(),\n+            ty: InEnvironment { value: ty, environment },\n+        }\n+    }\n+\n+    pub fn trait_bounds(self, db: &dyn HirDatabase) -> Vec<Trait> {\n+        db.generic_predicates_for_param(self.id)\n+            .into_iter()\n+            .filter_map(|pred| match &pred.value {\n+                hir_ty::GenericPredicate::Implemented(trait_ref) => {\n+                    Some(Trait::from(trait_ref.trait_))\n+                }\n+                _ => None,\n+            })\n+            .collect()\n+    }\n+\n+    pub fn default(self, db: &dyn HirDatabase) -> Option<Type> {\n+        let params = db.generic_defaults(self.id.parent);\n+        let local_idx = hir_ty::param_idx(db, self.id)?;\n+        let resolver = self.id.parent.resolver(db.upcast());\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ty = params.get(local_idx)?.clone();\n+        let subst = Substs::type_params(db, self.id.parent);\n+        let ty = ty.subst(&subst.prefix(local_idx));\n+        Some(Type {\n+            krate: self.id.parent.module(db.upcast()).krate(),\n+            ty: InEnvironment { value: ty, environment },\n+        })\n+    }\n+}\n+\n+impl HirDisplay for TypeParam {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write!(f, \"{}\", self.name(f.db))?;\n+        let bounds = f.db.generic_predicates_for_param(self.id);\n+        let substs = Substs::type_params(f.db, self.id.parent);\n+        let predicates = bounds.iter().cloned().map(|b| b.subst(&substs)).collect::<Vec<_>>();\n+        if !(predicates.is_empty() || f.omit_verbose_types()) {\n+            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, f)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct LifetimeParam {\n+    pub(crate) id: LifetimeParamId,\n+}\n+\n+impl LifetimeParam {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        let params = db.generic_params(self.id.parent);\n+        params.lifetimes[self.id.local_id].name.clone()\n+    }\n+\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        self.id.parent.module(db.upcast()).into()\n+    }\n+\n+    pub fn parent(self, _db: &dyn HirDatabase) -> GenericDef {\n+        self.id.parent.into()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct ConstParam {\n+    pub(crate) id: ConstParamId,\n+}\n+\n+impl ConstParam {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        let params = db.generic_params(self.id.parent);\n+        params.consts[self.id.local_id].name.clone()\n+    }\n+\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        self.id.parent.module(db.upcast()).into()\n+    }\n+\n+    pub fn parent(self, _db: &dyn HirDatabase) -> GenericDef {\n+        self.id.parent.into()\n+    }\n+\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        let def = self.id.parent;\n+        let krate = def.module(db.upcast()).krate();\n+        Type::new(db, krate, def, db.const_param_ty(self.id))\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Impl {\n+    pub(crate) id: ImplId,\n+}\n+\n+impl Impl {\n+    pub fn all_in_crate(db: &dyn HirDatabase, krate: Crate) -> Vec<Impl> {\n+        let inherent = db.inherent_impls_in_crate(krate.id);\n+        let trait_ = db.trait_impls_in_crate(krate.id);\n+\n+        inherent.all_impls().chain(trait_.all_impls()).map(Self::from).collect()\n+    }\n+    pub fn for_trait(db: &dyn HirDatabase, krate: Crate, trait_: Trait) -> Vec<Impl> {\n+        let impls = db.trait_impls_in_crate(krate.id);\n+        impls.for_trait(trait_.id).map(Self::from).collect()\n+    }\n+\n+    // FIXME: the return type is wrong. This should be a hir version of\n+    // `TraitRef` (ie, resolved `TypeRef`).\n+    pub fn target_trait(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n+        db.impl_data(self.id).target_trait.clone()\n+    }\n+\n+    pub fn target_ty(self, db: &dyn HirDatabase) -> Type {\n+        let impl_data = db.impl_data(self.id);\n+        let resolver = self.id.resolver(db.upcast());\n+        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ty = Ty::from_hir(&ctx, &impl_data.target_type);\n+        Type {\n+            krate: self.id.lookup(db.upcast()).container.module(db.upcast()).krate(),\n+            ty: InEnvironment { value: ty, environment },\n+        }\n+    }\n+\n+    pub fn items(self, db: &dyn HirDatabase) -> Vec<AssocItem> {\n+        db.impl_data(self.id).items.iter().map(|it| (*it).into()).collect()\n+    }\n+\n+    pub fn is_negative(self, db: &dyn HirDatabase) -> bool {\n+        db.impl_data(self.id).is_negative\n+    }\n+\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        self.id.lookup(db.upcast()).container.module(db.upcast()).into()\n+    }\n+\n+    pub fn krate(self, db: &dyn HirDatabase) -> Crate {\n+        Crate { id: self.module(db).id.krate() }\n+    }\n+\n+    pub fn is_builtin_derive(self, db: &dyn HirDatabase) -> Option<InFile<ast::Attr>> {\n+        let src = self.source(db)?;\n+        let item = src.file_id.is_builtin_derive(db.upcast())?;\n+        let hygenic = hir_expand::hygiene::Hygiene::new(db.upcast(), item.file_id);\n+\n+        // FIXME: handle `cfg_attr`\n+        let attr = item\n+            .value\n+            .attrs()\n+            .filter_map(|it| {\n+                let path = ModPath::from_src(it.path()?, &hygenic)?;\n+                if path.as_ident()?.to_string() == \"derive\" {\n+                    Some(it)\n+                } else {\n+                    None\n+                }\n+            })\n+            .last()?;\n+\n+        Some(item.with_value(attr))\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct Type {\n+    krate: CrateId,\n+    ty: InEnvironment<Ty>,\n+}\n+\n+impl Type {\n+    pub(crate) fn new_with_resolver(\n+        db: &dyn HirDatabase,\n+        resolver: &Resolver,\n+        ty: Ty,\n+    ) -> Option<Type> {\n+        let krate = resolver.krate()?;\n+        Some(Type::new_with_resolver_inner(db, krate, resolver, ty))\n+    }\n+    pub(crate) fn new_with_resolver_inner(\n+        db: &dyn HirDatabase,\n+        krate: CrateId,\n+        resolver: &Resolver,\n+        ty: Ty,\n+    ) -> Type {\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        Type { krate, ty: InEnvironment { value: ty, environment } }\n+    }\n+\n+    fn new(db: &dyn HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n+        let resolver = lexical_env.resolver(db.upcast());\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        Type { krate, ty: InEnvironment { value: ty, environment } }\n+    }\n+\n+    fn from_def(\n+        db: &dyn HirDatabase,\n+        krate: CrateId,\n+        def: impl HasResolver + Into<TyDefId> + Into<GenericDefId>,\n+    ) -> Type {\n+        let substs = Substs::build_for_def(db, def).fill_with_unknown().build();\n+        let ty = db.ty(def.into()).subst(&substs);\n+        Type::new(db, krate, def, ty)\n+    }\n+\n+    pub fn is_unit(&self) -> bool {\n+        matches!(self.ty.value, Ty::Tuple(0, ..))\n+    }\n+    pub fn is_bool(&self) -> bool {\n+        matches!(self.ty.value, Ty::Scalar(Scalar::Bool))\n+    }\n+\n+    pub fn is_mutable_reference(&self) -> bool {\n+        matches!(self.ty.value, Ty::Ref(hir_ty::Mutability::Mut, ..))\n+    }\n+\n+    pub fn remove_ref(&self) -> Option<Type> {\n+        if let Ty::Ref(.., substs) = &self.ty.value {\n+            Some(self.derived(substs[0].clone()))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn is_unknown(&self) -> bool {\n+        matches!(self.ty.value, Ty::Unknown)\n+    }\n+\n+    /// Checks that particular type `ty` implements `std::future::Future`.\n+    /// This function is used in `.await` syntax completion.\n+    pub fn impls_future(&self, db: &dyn HirDatabase) -> bool {\n+        // No special case for the type of async block, since Chalk can figure it out.\n+\n+        let krate = self.krate;\n+\n+        let std_future_trait =\n+            db.lang_item(krate, \"future_trait\".into()).and_then(|it| it.as_trait());\n+        let std_future_trait = match std_future_trait {\n+            Some(it) => it,\n+            None => return false,\n+        };\n+\n+        let canonical_ty = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        method_resolution::implements_trait(\n+            &canonical_ty,\n+            db,\n+            self.ty.environment.clone(),\n+            krate,\n+            std_future_trait,\n+        )\n+    }\n+\n+    /// Checks that particular type `ty` implements `std::ops::FnOnce`.\n+    ///\n+    /// This function can be used to check if a particular type is callable, since FnOnce is a\n+    /// supertrait of Fn and FnMut, so all callable types implements at least FnOnce.\n+    pub fn impls_fnonce(&self, db: &dyn HirDatabase) -> bool {\n+        let krate = self.krate;\n+\n+        let fnonce_trait = match FnTrait::FnOnce.get_id(db, krate) {\n+            Some(it) => it,\n+            None => return false,\n+        };\n+\n+        let canonical_ty = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        method_resolution::implements_trait_unique(\n+            &canonical_ty,\n+            db,\n+            self.ty.environment.clone(),\n+            krate,\n+            fnonce_trait,\n+        )\n+    }\n+\n+    pub fn impls_trait(&self, db: &dyn HirDatabase, trait_: Trait, args: &[Type]) -> bool {\n+        let trait_ref = hir_ty::TraitRef {\n+            trait_: trait_.id,\n+            substs: Substs::build_for_def(db, trait_.id)\n+                .push(self.ty.value.clone())\n+                .fill(args.iter().map(|t| t.ty.value.clone()))\n+                .build(),\n+        };\n+\n+        let goal = Canonical {\n+            value: hir_ty::InEnvironment::new(\n+                self.ty.environment.clone(),\n+                hir_ty::Obligation::Trait(trait_ref),\n+            ),\n+            kinds: Arc::new([]),\n+        };\n+\n+        db.trait_solve(self.krate, goal).is_some()\n+    }\n+\n+    pub fn normalize_trait_assoc_type(\n+        &self,\n+        db: &dyn HirDatabase,\n+        trait_: Trait,\n+        args: &[Type],\n+        alias: TypeAlias,\n+    ) -> Option<Type> {\n+        let subst = Substs::build_for_def(db, trait_.id)\n+            .push(self.ty.value.clone())\n+            .fill(args.iter().map(|t| t.ty.value.clone()))\n+            .build();\n+        let predicate = ProjectionPredicate {\n+            projection_ty: ProjectionTy { associated_ty: alias.id, parameters: subst },\n+            ty: Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)),\n+        };\n+        let goal = Canonical {\n+            value: InEnvironment::new(\n+                self.ty.environment.clone(),\n+                Obligation::Projection(predicate),\n+            ),\n+            kinds: Arc::new([TyVariableKind::General]),\n+        };\n+\n+        match db.trait_solve(self.krate, goal)? {\n+            Solution::Unique(SolutionVariables(subst)) => subst.value.first().cloned(),\n+            Solution::Ambig(_) => None,\n+        }\n+        .map(|ty| Type {\n+            krate: self.krate,\n+            ty: InEnvironment { value: ty, environment: Arc::clone(&self.ty.environment) },\n+        })\n+    }\n+\n+    pub fn is_copy(&self, db: &dyn HirDatabase) -> bool {\n+        let lang_item = db.lang_item(self.krate, SmolStr::new(\"copy\"));\n+        let copy_trait = match lang_item {\n+            Some(LangItemTarget::TraitId(it)) => it,\n+            _ => return false,\n+        };\n+        self.impls_trait(db, copy_trait.into(), &[])\n+    }\n+\n+    pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n+        let def = match self.ty.value {\n+            Ty::FnDef(def, _) => Some(def),\n+            _ => None,\n+        };\n+\n+        let sig = self.ty.value.callable_sig(db)?;\n+        Some(Callable { ty: self.clone(), sig, def, is_bound_method: false })\n+    }\n+\n+    pub fn is_closure(&self) -> bool {\n+        matches!(&self.ty.value, Ty::Closure { .. })\n+    }\n+\n+    pub fn is_fn(&self) -> bool {\n+        matches!(&self.ty.value, Ty::FnDef(..) | Ty::Function { .. })\n+    }\n+\n+    pub fn is_packed(&self, db: &dyn HirDatabase) -> bool {\n+        let adt_id = match self.ty.value {\n+            Ty::Adt(hir_ty::AdtId(adt_id), ..) => adt_id,\n+            _ => return false,\n+        };\n+\n+        let adt = adt_id.into();\n+        match adt {\n+            Adt::Struct(s) => matches!(s.repr(db), Some(ReprKind::Packed)),\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_raw_ptr(&self) -> bool {\n+        matches!(&self.ty.value, Ty::Raw(..))\n+    }\n+\n+    pub fn contains_unknown(&self) -> bool {\n+        return go(&self.ty.value);\n+\n+        fn go(ty: &Ty) -> bool {\n+            match ty {\n+                Ty::Unknown => true,\n+                _ => ty.substs().map_or(false, |substs| substs.iter().any(go)),\n+            }\n+        }\n+    }\n+\n+    pub fn fields(&self, db: &dyn HirDatabase) -> Vec<(Field, Type)> {\n+        let (variant_id, substs) = match self.ty.value {\n+            Ty::Adt(hir_ty::AdtId(AdtId::StructId(s)), ref substs) => (s.into(), substs),\n+            Ty::Adt(hir_ty::AdtId(AdtId::UnionId(u)), ref substs) => (u.into(), substs),\n+            _ => return Vec::new(),\n+        };\n+\n+        db.field_types(variant_id)\n+            .iter()\n+            .map(|(local_id, ty)| {\n+                let def = Field { parent: variant_id.into(), id: local_id };\n+                let ty = ty.clone().subst(substs);\n+                (def, self.derived(ty))\n+            })\n+            .collect()\n+    }\n+\n+    pub fn tuple_fields(&self, _db: &dyn HirDatabase) -> Vec<Type> {\n+        if let Ty::Tuple(_, substs) = &self.ty.value {\n+            substs.iter().map(|ty| self.derived(ty.clone())).collect()\n+        } else {\n+            Vec::new()\n+        }\n+    }\n+\n+    pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n+        // There should be no inference vars in types passed here\n+        // FIXME check that?\n+        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        let environment = self.ty.environment.clone();\n+        let ty = InEnvironment { value: canonical, environment };\n+        autoderef(db, Some(self.krate), ty)\n+            .map(|canonical| canonical.value)\n+            .map(move |ty| self.derived(ty))\n+    }\n+\n+    // This would be nicer if it just returned an iterator, but that runs into\n+    // lifetime problems, because we need to borrow temp `CrateImplDefs`.\n+    pub fn iterate_assoc_items<T>(\n+        self,\n+        db: &dyn HirDatabase,\n+        krate: Crate,\n+        mut callback: impl FnMut(AssocItem) -> Option<T>,\n+    ) -> Option<T> {\n+        for krate in self.ty.value.def_crates(db, krate.id)? {\n+            let impls = db.inherent_impls_in_crate(krate);\n+\n+            for impl_def in impls.for_self_ty(&self.ty.value) {\n+                for &item in db.impl_data(*impl_def).items.iter() {\n+                    if let Some(result) = callback(item.into()) {\n+                        return Some(result);\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    pub fn type_parameters(&self) -> impl Iterator<Item = Type> + '_ {\n+        self.ty\n+            .value\n+            .strip_references()\n+            .substs()\n+            .into_iter()\n+            .flat_map(|substs| substs.iter())\n+            .map(move |ty| self.derived(ty.clone()))\n+    }\n+\n+    pub fn iterate_method_candidates<T>(\n+        &self,\n+        db: &dyn HirDatabase,\n+        krate: Crate,\n+        traits_in_scope: &FxHashSet<TraitId>,\n+        name: Option<&Name>,\n+        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+    ) -> Option<T> {\n+        // There should be no inference vars in types passed here\n+        // FIXME check that?\n+        // FIXME replace Unknown by bound vars here\n+        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+\n+        let env = self.ty.environment.clone();\n+        let krate = krate.id;\n+\n+        method_resolution::iterate_method_candidates(\n+            &canonical,\n+            db,\n+            env,\n+            krate,\n+            traits_in_scope,\n+            name,\n+            method_resolution::LookupMode::MethodCall,\n+            |ty, it| match it {\n+                AssocItemId::FunctionId(f) => callback(ty, f.into()),\n+                _ => None,\n+            },\n+        )\n+    }\n+\n+    pub fn iterate_path_candidates<T>(\n+        &self,\n+        db: &dyn HirDatabase,\n+        krate: Crate,\n+        traits_in_scope: &FxHashSet<TraitId>,\n+        name: Option<&Name>,\n+        mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n+    ) -> Option<T> {\n+        // There should be no inference vars in types passed here\n+        // FIXME check that?\n+        // FIXME replace Unknown by bound vars here\n+        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+\n+        let env = self.ty.environment.clone();\n+        let krate = krate.id;\n+\n+        method_resolution::iterate_method_candidates(\n+            &canonical,\n+            db,\n+            env,\n+            krate,\n+            traits_in_scope,\n+            name,\n+            method_resolution::LookupMode::Path,\n+            |ty, it| callback(ty, it.into()),\n+        )\n+    }\n+\n+    pub fn as_adt(&self) -> Option<Adt> {\n+        let (adt, _subst) = self.ty.value.as_adt()?;\n+        Some(adt.into())\n+    }\n+\n+    pub fn as_dyn_trait(&self) -> Option<Trait> {\n+        self.ty.value.dyn_trait().map(Into::into)\n+    }\n+\n+    pub fn as_impl_traits(&self, db: &dyn HirDatabase) -> Option<Vec<Trait>> {\n+        self.ty.value.impl_trait_bounds(db).map(|it| {\n+            it.into_iter()\n+                .filter_map(|pred| match pred {\n+                    hir_ty::GenericPredicate::Implemented(trait_ref) => {\n+                        Some(Trait::from(trait_ref.trait_))\n+                    }\n+                    _ => None,\n+                })\n+                .collect()\n+        })\n+    }\n+\n+    pub fn as_associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<Trait> {\n+        self.ty.value.associated_type_parent_trait(db).map(Into::into)\n+    }\n+\n+    // FIXME: provide required accessors such that it becomes implementable from outside.\n+    pub fn is_equal_for_find_impls(&self, other: &Type) -> bool {\n+        let rref = other.remove_ref();\n+        self.ty.value.equals_ctor(rref.as_ref().map_or(&other.ty.value, |it| &it.ty.value))\n+    }\n+\n+    fn derived(&self, ty: Ty) -> Type {\n+        Type {\n+            krate: self.krate,\n+            ty: InEnvironment { value: ty, environment: self.ty.environment.clone() },\n+        }\n+    }\n+\n+    pub fn walk(&self, db: &dyn HirDatabase, mut cb: impl FnMut(Type)) {\n+        // TypeWalk::walk for a Ty at first visits parameters and only after that the Ty itself.\n+        // We need a different order here.\n+\n+        fn walk_substs(\n+            db: &dyn HirDatabase,\n+            type_: &Type,\n+            substs: &Substs,\n+            cb: &mut impl FnMut(Type),\n+        ) {\n+            for ty in substs.iter() {\n+                walk_type(db, &type_.derived(ty.clone()), cb);\n+            }\n+        }\n+\n+        fn walk_bounds(\n+            db: &dyn HirDatabase,\n+            type_: &Type,\n+            bounds: &[GenericPredicate],\n+            cb: &mut impl FnMut(Type),\n+        ) {\n+            for pred in bounds {\n+                match pred {\n+                    GenericPredicate::Implemented(trait_ref) => {\n+                        cb(type_.clone());\n+                        walk_substs(db, type_, &trait_ref.substs, cb);\n+                    }\n+                    _ => (),\n+                }\n+            }\n+        }\n+\n+        fn walk_type(db: &dyn HirDatabase, type_: &Type, cb: &mut impl FnMut(Type)) {\n+            let ty = type_.ty.value.strip_references();\n+            match ty {\n+                Ty::Adt(..) => {\n+                    cb(type_.derived(ty.clone()));\n+                }\n+                Ty::AssociatedType(..) => {\n+                    if let Some(_) = ty.associated_type_parent_trait(db) {\n+                        cb(type_.derived(ty.clone()));\n+                    }\n+                }\n+                Ty::OpaqueType(..) => {\n+                    if let Some(bounds) = ty.impl_trait_bounds(db) {\n+                        walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n+                    }\n+                }\n+                Ty::Alias(AliasTy::Opaque(opaque_ty)) => {\n+                    if let Some(bounds) = ty.impl_trait_bounds(db) {\n+                        walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n+                    }\n+\n+                    walk_substs(db, type_, &opaque_ty.parameters, cb);\n+                }\n+                Ty::Placeholder(_) => {\n+                    if let Some(bounds) = ty.impl_trait_bounds(db) {\n+                        walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n+                    }\n+                }\n+                Ty::Dyn(bounds) => {\n+                    walk_bounds(db, &type_.derived(ty.clone()), bounds.as_ref(), cb);\n+                }\n+\n+                _ => {}\n+            }\n+            if let Some(substs) = ty.substs() {\n+                walk_substs(db, type_, &substs, cb);\n+            }\n+        }\n+\n+        walk_type(db, self, &mut cb);\n+    }\n+}\n+\n+impl HirDisplay for Type {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        self.ty.value.hir_fmt(f)\n+    }\n+}\n+\n+// FIXME: closures\n+#[derive(Debug)]\n+pub struct Callable {\n+    ty: Type,\n+    sig: CallableSig,\n+    def: Option<CallableDefId>,\n+    pub(crate) is_bound_method: bool,\n+}\n+\n+pub enum CallableKind {\n+    Function(Function),\n+    TupleStruct(Struct),\n+    TupleEnumVariant(Variant),\n+    Closure,\n+}\n+\n+impl Callable {\n+    pub fn kind(&self) -> CallableKind {\n+        match self.def {\n+            Some(CallableDefId::FunctionId(it)) => CallableKind::Function(it.into()),\n+            Some(CallableDefId::StructId(it)) => CallableKind::TupleStruct(it.into()),\n+            Some(CallableDefId::EnumVariantId(it)) => CallableKind::TupleEnumVariant(it.into()),\n+            None => CallableKind::Closure,\n+        }\n+    }\n+    pub fn receiver_param(&self, db: &dyn HirDatabase) -> Option<ast::SelfParam> {\n+        let func = match self.def {\n+            Some(CallableDefId::FunctionId(it)) if self.is_bound_method => it,\n+            _ => return None,\n+        };\n+        let src = func.lookup(db.upcast()).source(db.upcast());\n+        let param_list = src.value.param_list()?;\n+        param_list.self_param()\n+    }\n+    pub fn n_params(&self) -> usize {\n+        self.sig.params().len() - if self.is_bound_method { 1 } else { 0 }\n+    }\n+    pub fn params(\n+        &self,\n+        db: &dyn HirDatabase,\n+    ) -> Vec<(Option<Either<ast::SelfParam, ast::Pat>>, Type)> {\n+        let types = self\n+            .sig\n+            .params()\n+            .iter()\n+            .skip(if self.is_bound_method { 1 } else { 0 })\n+            .map(|ty| self.ty.derived(ty.clone()));\n+        let patterns = match self.def {\n+            Some(CallableDefId::FunctionId(func)) => {\n+                let src = func.lookup(db.upcast()).source(db.upcast());\n+                src.value.param_list().map(|param_list| {\n+                    param_list\n+                        .self_param()\n+                        .map(|it| Some(Either::Left(it)))\n+                        .filter(|_| !self.is_bound_method)\n+                        .into_iter()\n+                        .chain(param_list.params().map(|it| it.pat().map(Either::Right)))\n+                })\n+            }\n+            _ => None,\n+        };\n+        patterns.into_iter().flatten().chain(iter::repeat(None)).zip(types).collect()\n+    }\n+    pub fn return_type(&self) -> Type {\n+        self.ty.derived(self.sig.ret().clone())\n+    }\n+}\n+\n+/// For IDE only\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+pub enum ScopeDef {\n+    ModuleDef(ModuleDef),\n+    MacroDef(MacroDef),\n+    GenericParam(GenericParam),\n+    ImplSelfType(Impl),\n+    AdtSelfType(Adt),\n+    Local(Local),\n+    Unknown,\n+}\n+\n+impl ScopeDef {\n+    pub fn all_items(def: PerNs) -> ArrayVec<[Self; 3]> {\n+        let mut items = ArrayVec::new();\n+\n+        match (def.take_types(), def.take_values()) {\n+            (Some(m1), None) => items.push(ScopeDef::ModuleDef(m1.into())),\n+            (None, Some(m2)) => items.push(ScopeDef::ModuleDef(m2.into())),\n+            (Some(m1), Some(m2)) => {\n+                // Some items, like unit structs and enum variants, are\n+                // returned as both a type and a value. Here we want\n+                // to de-duplicate them.\n+                if m1 != m2 {\n+                    items.push(ScopeDef::ModuleDef(m1.into()));\n+                    items.push(ScopeDef::ModuleDef(m2.into()));\n+                } else {\n+                    items.push(ScopeDef::ModuleDef(m1.into()));\n+                }\n+            }\n+            (None, None) => {}\n+        };\n+\n+        if let Some(macro_def_id) = def.take_macros() {\n+            items.push(ScopeDef::MacroDef(macro_def_id.into()));\n+        }\n+\n+        if items.is_empty() {\n+            items.push(ScopeDef::Unknown);\n+        }\n+\n+        items\n+    }\n+}\n+\n+pub trait HasVisibility {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility;\n+    fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {\n+        let vis = self.visibility(db);\n+        vis.is_visible_from(db.upcast(), module.id)\n+    }\n+}"}, {"sha": "945638cc565ad315ffc09df1283bb1ad0ebf7107", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=c5189a22ccf4c28e309e4189defbb88b83bb2aea", "patch": "@@ -20,12 +20,11 @@ use syntax::{\n };\n \n use crate::{\n-    code_model::Access,\n     db::HirDatabase,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n-    AssocItem, Callable, ConstParam, Crate, Field, Function, HirFileId, Impl, InFile, Label,\n-    LifetimeParam, Local, MacroDef, Module, ModuleDef, Name, Path, ScopeDef, Trait, Type,\n+    Access, AssocItem, Callable, ConstParam, Crate, Field, Function, HirFileId, Impl, InFile,\n+    Label, LifetimeParam, Local, MacroDef, Module, ModuleDef, Name, Path, ScopeDef, Trait, Type,\n     TypeAlias, TypeParam, VariantDef,\n };\n "}, {"sha": "d546512cbdb341069bd33ad9b9650fe669f7274d", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=c5189a22ccf4c28e309e4189defbb88b83bb2aea", "patch": "@@ -28,9 +28,8 @@ use syntax::{\n };\n \n use crate::{\n-    code_model::BuiltinType, db::HirDatabase, semantics::PathResolution, Adt, Const, Field,\n-    Function, Local, MacroDef, ModuleDef, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n-    Variant,\n+    db::HirDatabase, semantics::PathResolution, Adt, BuiltinType, Const, Field, Function, Local,\n+    MacroDef, ModuleDef, Static, Struct, Trait, Type, TypeAlias, TypeParam, Variant,\n };\n use base_db::CrateId;\n "}, {"sha": "335e0ed954ad1d82fd725615dff5bc6ddf09b9b5", "filename": "crates/ide_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=c5189a22ccf4c28e309e4189defbb88b83bb2aea", "patch": "@@ -1,7 +1,7 @@\n use std::iter;\n \n use either::Either;\n-use hir::{AsName, Module, ModuleDef, Name, Variant};\n+use hir::{Module, ModuleDef, Name, Variant};\n use ide_db::{\n     defs::Definition,\n     helpers::{\n@@ -133,7 +133,7 @@ fn existing_definition(db: &RootDatabase, variant_name: &ast::Name, variant: &Va\n             ),\n             _ => false,\n         })\n-        .any(|(name, _)| name == variant_name.as_name())\n+        .any(|(name, _)| name.to_string() == variant_name.to_string())\n }\n \n fn insert_import("}, {"sha": "d84ca0e5553cf5bf2e9f5ccdfb8e148e9b19120f", "filename": "crates/ide_assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5189a22ccf4c28e309e4189defbb88b83bb2aea/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=c5189a22ccf4c28e309e4189defbb88b83bb2aea", "patch": "@@ -1,6 +1,6 @@\n use std::iter;\n \n-use hir::{AsAssocItem, AsName};\n+use hir::AsAssocItem;\n use ide_db::helpers::{import_assets::ImportCandidate, mod_path_to_ast};\n use ide_db::RootDatabase;\n use syntax::{\n@@ -160,7 +160,9 @@ fn find_trait_method(\n ) -> Option<hir::Function> {\n     if let Some(hir::AssocItem::Function(method)) =\n         trait_.items(db).into_iter().find(|item: &hir::AssocItem| {\n-            item.name(db).map(|name| name == trait_method_name.as_name()).unwrap_or(false)\n+            item.name(db)\n+                .map(|name| name.to_string() == trait_method_name.to_string())\n+                .unwrap_or(false)\n         })\n     {\n         Some(method)"}, {"sha": "e2237ca9568f5b8a78bc34f116f6698db2d84b48", "filename": "docs/dev/architecture.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5189a22ccf4c28e309e4189defbb88b83bb2aea/docs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5189a22ccf4c28e309e4189defbb88b83bb2aea/docs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Farchitecture.md?ref=c5189a22ccf4c28e309e4189defbb88b83bb2aea", "patch": "@@ -46,7 +46,7 @@ This is *the* entry point, but it front-loads a lot of complexity, so its fine t\n \n `crates/rust-analyzer/src/handlers.rs` implements all LSP requests and is a great place to start if you are already familiar with LSP.\n \n-`Analysis` and `AnalysisHost` types define the main API.\n+`Analysis` and `AnalysisHost` types define the main API for consumers of IDE services.\n \n ## Code Map\n "}]}