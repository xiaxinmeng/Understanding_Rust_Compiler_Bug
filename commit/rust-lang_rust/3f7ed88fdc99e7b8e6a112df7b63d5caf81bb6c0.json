{"sha": "3f7ed88fdc99e7b8e6a112df7b63d5caf81bb6c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmN2VkODhmZGM5OWU3YjhlNmExMTJkZjdiNjNkNWNhZjgxYmI2YzA=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-02-14T22:17:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-14T22:17:43Z"}, "message": "Rollup merge of #68129 - varkor:infer-binary-operand-behind-reference, r=nikomatsakis\n\nCorrect inference of primitive operand type behind binary operation\n\nFixes https://github.com/rust-lang/rust/issues/57447.\n\nr? @nikomatsakis", "tree": {"sha": "cbc15289ae39a111326e511927801f1ca983160f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbc15289ae39a111326e511927801f1ca983160f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f7ed88fdc99e7b8e6a112df7b63d5caf81bb6c0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeRxyICRBK7hj4Ov3rIwAAdHIIAIvyYcwbTw5C4BFNlM6ogBIx\nD/N6TN+meVZaXeq4IzOY/ebzGrnOnbvirrB5zPTFw7Go8cFWfYt9S/RfrQzVhTyT\nI4HivI7cztBOGVuBTxz5Cp5Gp8mBKaqSc+6n10oNvotB9obnxe46P/pz9hPy0udx\nbPVCHzzPFtgyLtVDHyANEx7Wd5vAieZBUx9/PcNCHvoZNOptf0xNffP0vdk0DuiK\noWYzui2wlSTtZy8i300L30fjkBa1FSe7ZESk1Utqw2zjk6Gf8STH3mF9Xdqh1bgA\nwyNFzbtmND40wvROx12/k5tdvW09ZGAkDWdRG3mj46QKjg+zDhP2UN+dVfgnHo0=\n=+mvy\n-----END PGP SIGNATURE-----\n", "payload": "tree cbc15289ae39a111326e511927801f1ca983160f\nparent 35071e3e2e74f6f780bc851500b9316e3e82062a\nparent 0276d7a32e1c83abc3106f7b36b711faf1f74dff\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1581718663 +0900\ncommitter GitHub <noreply@github.com> 1581718663 +0900\n\nRollup merge of #68129 - varkor:infer-binary-operand-behind-reference, r=nikomatsakis\n\nCorrect inference of primitive operand type behind binary operation\n\nFixes https://github.com/rust-lang/rust/issues/57447.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f7ed88fdc99e7b8e6a112df7b63d5caf81bb6c0", "html_url": "https://github.com/rust-lang/rust/commit/3f7ed88fdc99e7b8e6a112df7b63d5caf81bb6c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f7ed88fdc99e7b8e6a112df7b63d5caf81bb6c0/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35071e3e2e74f6f780bc851500b9316e3e82062a", "url": "https://api.github.com/repos/rust-lang/rust/commits/35071e3e2e74f6f780bc851500b9316e3e82062a", "html_url": "https://github.com/rust-lang/rust/commit/35071e3e2e74f6f780bc851500b9316e3e82062a"}, {"sha": "0276d7a32e1c83abc3106f7b36b711faf1f74dff", "url": "https://api.github.com/repos/rust-lang/rust/commits/0276d7a32e1c83abc3106f7b36b711faf1f74dff", "html_url": "https://github.com/rust-lang/rust/commit/0276d7a32e1c83abc3106f7b36b711faf1f74dff"}], "stats": {"total": 71, "additions": 61, "deletions": 10}, "files": [{"sha": "0c1557a59c2bc11553d7e015f05c70c9c753e189", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3f7ed88fdc99e7b8e6a112df7b63d5caf81bb6c0/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7ed88fdc99e7b8e6a112df7b63d5caf81bb6c0/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=3f7ed88fdc99e7b8e6a112df7b63d5caf81bb6c0", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let ty =\n             if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n-                self.enforce_builtin_binop_types(lhs, lhs_ty, rhs, rhs_ty, op);\n+                self.enforce_builtin_binop_types(&lhs.span, lhs_ty, &rhs.span, rhs_ty, op);\n                 self.tcx.mk_unit()\n             } else {\n                 return_ty\n@@ -86,8 +86,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && !rhs_ty.is_ty_var()\n                     && is_builtin_binop(lhs_ty, rhs_ty, op)\n                 {\n-                    let builtin_return_ty =\n-                        self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n+                    let builtin_return_ty = self.enforce_builtin_binop_types(\n+                        &lhs_expr.span,\n+                        lhs_ty,\n+                        &rhs_expr.span,\n+                        rhs_ty,\n+                        op,\n+                    );\n                     self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n                 }\n \n@@ -98,19 +103,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn enforce_builtin_binop_types(\n         &self,\n-        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        lhs_span: &Span,\n         lhs_ty: Ty<'tcx>,\n-        rhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_span: &Span,\n         rhs_ty: Ty<'tcx>,\n         op: hir::BinOp,\n     ) -> Ty<'tcx> {\n         debug_assert!(is_builtin_binop(lhs_ty, rhs_ty, op));\n \n+        // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work.\n+        // (See https://github.com/rust-lang/rust/issues/57447.)\n+        let (lhs_ty, rhs_ty) = (deref_ty_if_possible(lhs_ty), deref_ty_if_possible(rhs_ty));\n+\n         let tcx = self.tcx;\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n-                self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n-                self.demand_suptype(rhs_expr.span, tcx.mk_bool(), rhs_ty);\n+                self.demand_suptype(*lhs_span, tcx.mk_bool(), lhs_ty);\n+                self.demand_suptype(*rhs_span, tcx.mk_bool(), rhs_ty);\n                 tcx.mk_bool()\n             }\n \n@@ -121,13 +130,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             BinOpCategory::Math | BinOpCategory::Bitwise => {\n                 // both LHS and RHS and result will have the same type\n-                self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n+                self.demand_suptype(*rhs_span, lhs_ty, rhs_ty);\n                 lhs_ty\n             }\n \n             BinOpCategory::Comparison => {\n                 // both LHS and RHS and result will have the same type\n-                self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n+                self.demand_suptype(*rhs_span, lhs_ty, rhs_ty);\n                 tcx.mk_bool()\n             }\n         }\n@@ -862,6 +871,14 @@ enum Op {\n     Unary(hir::UnOp, Span),\n }\n \n+/// Dereferences a single level of immutable referencing.\n+fn deref_ty_if_possible<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n+    match ty.kind {\n+        ty::Ref(_, ty, hir::Mutability::Not) => ty,\n+        _ => ty,\n+    }\n+}\n+\n /// Returns `true` if this is a built-in arithmetic operation (e.g., u32\n /// + u32, i16x4 == i16x4) and false if these types would have to be\n /// overloaded to be legal. There are two reasons that we distinguish\n@@ -878,7 +895,11 @@ enum Op {\n /// Reason #2 is the killer. I tried for a while to always use\n /// overloaded logic and just check the types in constants/codegen after\n /// the fact, and it worked fine, except for SIMD types. -nmatsakis\n-fn is_builtin_binop(lhs: Ty<'_>, rhs: Ty<'_>, op: hir::BinOp) -> bool {\n+fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool {\n+    // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work.\n+    // (See https://github.com/rust-lang/rust/issues/57447.)\n+    let (lhs, rhs) = (deref_ty_if_possible(lhs), deref_ty_if_possible(rhs));\n+\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => true,\n "}, {"sha": "0c0a3171ee9a18ae1c4d436f21c1442157a42aa3", "filename": "src/test/ui/inference/infer-binary-operand-behind-reference.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3f7ed88fdc99e7b8e6a112df7b63d5caf81bb6c0/src%2Ftest%2Fui%2Finference%2Finfer-binary-operand-behind-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f7ed88fdc99e7b8e6a112df7b63d5caf81bb6c0/src%2Ftest%2Fui%2Finference%2Finfer-binary-operand-behind-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Finfer-binary-operand-behind-reference.rs?ref=3f7ed88fdc99e7b8e6a112df7b63d5caf81bb6c0", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+\n+fn main() {\n+    // Test that we can infer the type of binary operands when\n+    // references are involved, on various types and operators.\n+    let _: u8 = 0 + 0;\n+    let _: u8 = 0 + &0;\n+    let _: u8 = &0 + 0;\n+    let _: u8 = &0 + &0;\n+\n+    let _: f32 = 0.0 + 0.0;\n+    let _: f32 = 0.0 + &0.0;\n+    let _: f32 = &0.0 + 0.0;\n+    let _: f32 = &0.0 + &0.0;\n+\n+    let _: u8 = 0 << 0;\n+    let _: u8 = 0 << &0;\n+    let _: u8 = &0 << 0;\n+    let _: u8 = &0 << &0;\n+\n+    // Test type inference when variable types are indirectly inferred.\n+    let a = 22;\n+    let _: usize = a + &44;\n+\n+    // When we have no expected type, the types of the operands is the default type.\n+    let _ = 0 + 0;\n+    let _ = 0 + &0;\n+    let _ = &0 + 0;\n+    let _ = &0 + &0;\n+}"}]}