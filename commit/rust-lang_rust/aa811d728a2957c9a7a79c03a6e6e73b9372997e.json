{"sha": "aa811d728a2957c9a7a79c03a6e6e73b9372997e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhODExZDcyOGEyOTU3YzlhN2E3OWMwM2E2ZTZlNzNiOTM3Mjk5N2U=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-11T19:31:16Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:29Z"}, "message": "rustc: remove source field path from Layout::StructWrappedNullablePointer.", "tree": {"sha": "2b6d4f7e967b9a8e0f8b5f99858f0d41b7308406", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b6d4f7e967b9a8e0f8b5f99858f0d41b7308406"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa811d728a2957c9a7a79c03a6e6e73b9372997e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa811d728a2957c9a7a79c03a6e6e73b9372997e", "html_url": "https://github.com/rust-lang/rust/commit/aa811d728a2957c9a7a79c03a6e6e73b9372997e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa811d728a2957c9a7a79c03a6e6e73b9372997e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c", "html_url": "https://github.com/rust-lang/rust/commit/bc8e1f7efa9196f31d234ebc1c90a85e4e37874c"}], "stats": {"total": 122, "additions": 55, "deletions": 67}, "files": [{"sha": "319d4789efa92bd75ef0d474e631b49dc2cf8f3e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 21, "deletions": 55, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/aa811d728a2957c9a7a79c03a6e6e73b9372997e/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa811d728a2957c9a7a79c03a6e6e73b9372997e/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=aa811d728a2957c9a7a79c03a6e6e73b9372997e", "patch": "@@ -619,10 +619,6 @@ impl Primitive {\n     }\n }\n \n-/// Path through fields of nested structures.\n-// FIXME(eddyb) use small vector optimization for the common case.\n-pub type FieldPath = Vec<u32>;\n-\n /// A structure, a product type in ADT terms.\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct Struct {\n@@ -848,20 +844,19 @@ impl<'a, 'tcx> Struct {\n     fn non_zero_field_in_type(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               param_env: ty::ParamEnv<'tcx>,\n                               ty: Ty<'tcx>)\n-                              -> Result<Option<(Size, Primitive, FieldPath)>, LayoutError<'tcx>> {\n+                              -> Result<Option<(Size, Primitive)>, LayoutError<'tcx>> {\n         let layout = ty.layout(tcx, param_env)?;\n         match (layout, &ty.sty) {\n             (&Scalar { non_zero: true, value, .. }, _) => {\n-                Ok(Some((Size::from_bytes(0), value, vec![])))\n+                Ok(Some((Size::from_bytes(0), value)))\n             }\n             (&CEnum { non_zero: true, discr, .. }, _) => {\n-                Ok(Some((Size::from_bytes(0), Int(discr), vec![])))\n+                Ok(Some((Size::from_bytes(0), Int(discr))))\n             }\n \n             (&FatPointer { non_zero: true, .. }, _) => {\n                 Ok(Some((layout.field_offset(tcx, FAT_PTR_ADDR, None),\n-                         Pointer,\n-                         vec![FAT_PTR_ADDR as u32])))\n+                         Pointer)))\n             }\n \n             // Is this the NonZero lang item wrapping a pointer or integer type?\n@@ -873,15 +868,12 @@ impl<'a, 'tcx> Struct {\n                     // FIXME(eddyb) also allow floating-point types here.\n                     Scalar { value: value @ Int(_), non_zero: false } |\n                     Scalar { value: value @ Pointer, non_zero: false } => {\n-                        Ok(Some((layout.field_offset(tcx, 0, None),\n-                                 value,\n-                                 vec![0])))\n+                        Ok(Some((layout.field_offset(tcx, 0, None), value)))\n                     }\n                     FatPointer { non_zero: false, .. } => {\n                         Ok(Some((layout.field_offset(tcx, 0, None) +\n                                  field.field_offset(tcx, FAT_PTR_ADDR, None),\n-                                 Pointer,\n-                                 vec![FAT_PTR_ADDR as u32, 0])))\n+                                 Pointer)))\n                     }\n                     _ => Ok(None)\n                 }\n@@ -890,31 +882,22 @@ impl<'a, 'tcx> Struct {\n             // Perhaps one of the fields of this struct is non-zero\n             // let's recurse and find out\n             (&Univariant { ref variant, .. }, &ty::TyAdt(def, substs)) if def.is_struct() => {\n-                Struct::non_zero_field(\n+                variant.non_zero_field(\n                     tcx,\n                     param_env,\n                     def.struct_variant().fields.iter().map(|field| {\n                         field.ty(tcx, substs)\n-                    }),\n-                    &variant.offsets)\n+                    }))\n             }\n \n             // Perhaps one of the upvars of this closure is non-zero\n             (&Univariant { ref variant, .. }, &ty::TyClosure(def, substs)) => {\n                 let upvar_tys = substs.upvar_tys(def, tcx);\n-                Struct::non_zero_field(\n-                    tcx,\n-                    param_env,\n-                    upvar_tys,\n-                    &variant.offsets)\n+                variant.non_zero_field(tcx, param_env, upvar_tys)\n             }\n             // Can we use one of the fields in this tuple?\n             (&Univariant { ref variant, .. }, &ty::TyTuple(tys, _)) => {\n-                Struct::non_zero_field(\n-                    tcx,\n-                    param_env,\n-                    tys.iter().cloned(),\n-                    &variant.offsets)\n+                variant.non_zero_field(tcx, param_env, tys.iter().cloned())\n             }\n \n             // Is this a fixed-size array of something non-zero\n@@ -927,11 +910,7 @@ impl<'a, 'tcx> Struct {\n                     }\n                 }\n                 if count.val.to_const_int().unwrap().to_u64().unwrap() != 0 {\n-                    Struct::non_zero_field(\n-                        tcx,\n-                        param_env,\n-                        Some(ety).into_iter(),\n-                        &[Size::from_bytes(0)])\n+                    Struct::non_zero_field_in_type(tcx, param_env, ety)\n                 } else {\n                     Ok(None)\n                 }\n@@ -953,17 +932,15 @@ impl<'a, 'tcx> Struct {\n     /// Find the offset of a non-zero leaf field, starting from\n     /// the given set of fields and recursing through aggregates.\n     /// Returns Some((offset, primitive, source_path)) on success.\n-    fn non_zero_field<I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn non_zero_field<I>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          param_env: ty::ParamEnv<'tcx>,\n-                         fields: I,\n-                         offsets: &[Size])\n-                         -> Result<Option<(Size, Primitive, FieldPath)>, LayoutError<'tcx>>\n+                         fields: I)\n+                         -> Result<Option<(Size, Primitive)>, LayoutError<'tcx>>\n     where I: Iterator<Item=Ty<'tcx>> {\n-        for (i, ty) in fields.enumerate() {\n+        for (ty, &field_offset) in fields.zip(&self.offsets) {\n             let r = Struct::non_zero_field_in_type(tcx, param_env, ty)?;\n-            if let Some((offset, primitive, mut source_path)) = r {\n-                source_path.push(i as u32);\n-                return Ok(Some((offsets[i] + offset, primitive, source_path)));\n+            if let Some((offset, primitive)) = r {\n+                return Ok(Some((field_offset + offset, primitive)));\n             }\n         }\n         Ok(None)\n@@ -1152,8 +1129,6 @@ pub enum Layout {\n         nonnull: Struct,\n         discr: Primitive,\n         discr_offset: Size,\n-        /// Like discr_offset, but the source field path. For debuginfo.\n-        discrfield_source: FieldPath\n     }\n }\n \n@@ -1452,11 +1427,9 @@ impl<'a, 'tcx> Layout {\n                               .collect::<Result<Vec<_>, _>>()?,\n                             &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n \n-                        let field = Struct::non_zero_field(tcx,\n-                                                           param_env,\n-                                                           variants[discr].iter().cloned(),\n-                                                           &st.offsets)?;\n-                        let (offset, primitive, mut path_source) = if let Some(f) = field { f }\n+                        let field = st.non_zero_field(tcx, param_env,\n+                                                      variants[discr].iter().cloned())?;\n+                        let (offset, primitive) = if let Some(f) = field { f }\n                           else { continue };\n \n                         // FIXME(eddyb) should take advantage of a newtype.\n@@ -1468,15 +1441,11 @@ impl<'a, 'tcx> Layout {\n                             });\n                         }\n \n-                        // We have to fix the source path here.\n-                        path_source.reverse();\n-\n                         return success(StructWrappedNullablePointer {\n                             nndiscr: discr as u64,\n                             nonnull: st,\n                             discr: primitive,\n                             discr_offset: offset,\n-                            discrfield_source: path_source\n                         });\n                     }\n                 }\n@@ -1875,8 +1844,7 @@ impl<'a, 'tcx> Layout {\n             Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n                                                    nndiscr,\n                                                    discr: _,\n-                                                   discr_offset: _,\n-                                                   discrfield_source: _ } => {\n+                                                   discr_offset: _ } => {\n                 debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n                        ty, nndiscr, variant_layout);\n                 let variant_def = &adt_def.variants[nndiscr as usize];\n@@ -2418,13 +2386,11 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout\n                 ref nonnull,\n                 ref discr,\n                 discr_offset,\n-                ref discrfield_source\n             } => {\n                 nndiscr.hash_stable(hcx, hasher);\n                 nonnull.hash_stable(hcx, hasher);\n                 discr.hash_stable(hcx, hasher);\n                 discr_offset.hash_stable(hcx, hasher);\n-                discrfield_source.hash_stable(hcx, hasher);\n             }\n         }\n     }"}, {"sha": "98402b5e8c5f77f3660cad5ff358be4c3f9851b1", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/aa811d728a2957c9a7a79c03a6e6e73b9372997e/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa811d728a2957c9a7a79c03a6e6e73b9372997e/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=aa811d728a2957c9a7a79c03a6e6e73b9372997e", "patch": "@@ -39,6 +39,7 @@ use rustc::util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n+use std::fmt::Write;\n use std::ptr;\n use std::path::Path;\n use syntax::ast;\n@@ -1286,9 +1287,12 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 ]\n             },\n-            layout::StructWrappedNullablePointer { nonnull: ref struct_def,\n-                                                nndiscr,\n-                                                ref discrfield_source, ..} => {\n+            layout::StructWrappedNullablePointer {\n+                nonnull: ref struct_def,\n+                nndiscr,\n+                discr,\n+                discr_offset\n+            } => {\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, member_description_factory) =\n                     describe_enum_variant(cx,\n@@ -1309,19 +1313,37 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n-                let null_variant_index = (1 - nndiscr) as usize;\n-                let null_variant_name = adt.variants[null_variant_index].name;\n-                let discrfield_source = discrfield_source.iter()\n-                                           .map(|x| x.to_string())\n-                                           .collect::<Vec<_>>().join(\"$\");\n-                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                discrfield_source,\n-                                                null_variant_name);\n+                let mut name = String::from(\"RUST$ENCODED$ENUM$\");\n+                // HACK(eddyb) the debuggers should just handle offset+size\n+                // of discriminant instead of us having to recover its path.\n+                fn compute_field_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                name: &mut String,\n+                                                layout: TyLayout<'tcx>,\n+                                                offset: Size,\n+                                                size: Size) {\n+                    for i in 0..layout.field_count() {\n+                        let field_offset = layout.field_offset(ccx, i);\n+                        if field_offset > offset {\n+                            continue;\n+                        }\n+                        let inner_offset = offset - field_offset;\n+                        let field = layout.field(ccx, i);\n+                        if inner_offset + size <= field.size(ccx) {\n+                            write!(name, \"{}$\", i).unwrap();\n+                            compute_field_path(ccx, name, field, inner_offset, size);\n+                        }\n+                    }\n+                }\n+                compute_field_path(cx, &mut name,\n+                                   self.type_rep,\n+                                   discr_offset,\n+                                   discr.size(cx));\n+                name.push_str(&adt.variants[(1 - nndiscr) as usize].name.as_str());\n \n                 // Create the (singleton) list of descriptions of union members.\n                 vec![\n                     MemberDescription {\n-                        name: union_member_name,\n+                        name,\n                         type_metadata: variant_type_metadata,\n                         offset: Size::from_bytes(0),\n                         size: struct_def.stride(),"}]}