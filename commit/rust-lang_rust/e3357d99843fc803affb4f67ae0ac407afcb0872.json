{"sha": "e3357d99843fc803affb4f67ae0ac407afcb0872", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMzU3ZDk5ODQzZmM4MDNhZmZiNGY2N2FlMGFjNDA3YWZjYjA4NzI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-19T14:26:07Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-16T19:09:04Z"}, "message": "Implement interval checking", "tree": {"sha": "0d13ea4e930daad32d60450b1fa54c91093568e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d13ea4e930daad32d60450b1fa54c91093568e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3357d99843fc803affb4f67ae0ac407afcb0872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3357d99843fc803affb4f67ae0ac407afcb0872", "html_url": "https://github.com/rust-lang/rust/commit/e3357d99843fc803affb4f67ae0ac407afcb0872", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3357d99843fc803affb4f67ae0ac407afcb0872/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5590423e6ceb048dd7d792382e960d66b7615d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5590423e6ceb048dd7d792382e960d66b7615d2", "html_url": "https://github.com/rust-lang/rust/commit/b5590423e6ceb048dd7d792382e960d66b7615d2"}], "stats": {"total": 174, "additions": 164, "deletions": 10}, "files": [{"sha": "ea2597c4f854a4e13773925766ebe11ddf96c9cd", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 164, "deletions": 10, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/e3357d99843fc803affb4f67ae0ac407afcb0872/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3357d99843fc803affb4f67ae0ac407afcb0872/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=e3357d99843fc803affb4f67ae0ac407afcb0872", "patch": "@@ -273,7 +273,7 @@ impl<'tcx> Constructor<'tcx> {\n     }\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub enum Usefulness<'tcx> {\n     Useful,\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n@@ -425,10 +425,10 @@ impl<'tcx> Witness<'tcx> {\n /// Option<!> we do not include Some(_) in the returned list of constructors.\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                   pcx: PatternContext<'tcx>)\n-                                  -> Vec<Constructor<'tcx>>\n+                                  -> (Vec<Constructor<'tcx>>, bool)\n {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n-    match pcx.ty.sty {\n+    (match pcx.ty.sty {\n         ty::TyBool => {\n             [true, false].iter().map(|&b| {\n                 ConstantValue(ty::Const::from_bool(cx.tcx, b))\n@@ -457,14 +457,21 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 .map(|v| Variant(v.did))\n                 .collect()\n         }\n+        ty::TyUint(ast::UintTy::Usize) => {\n+            return (vec![\n+                ConstantRange(ty::Const::from_usize(cx.tcx, 0),\n+                              ty::Const::from_usize(cx.tcx, 100),\n+                              RangeEnd::Excluded),\n+            ], true)\n+        }\n         _ => {\n             if cx.is_uninhabited(pcx.ty) {\n                 vec![]\n             } else {\n                 vec![Single]\n             }\n         }\n-    }\n+    }, false)\n }\n \n fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n@@ -656,11 +663,148 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             pat_constructors(cx, row[0], pcx).unwrap_or(vec![])\n         }).collect();\n         debug!(\"used_ctors = {:#?}\", used_ctors);\n-        let all_ctors = all_constructors(cx, pcx);\n+        let (all_ctors, _ranged) = all_constructors(cx, pcx);\n         debug!(\"all_ctors = {:#?}\", all_ctors);\n-        let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n-            !used_ctors.contains(*c)\n-        }).cloned().collect();\n+\n+        fn to_inc_range_pair<'tcx>(tcx: TyCtxt<'_, '_, '_>, ctor: &Constructor<'tcx>) -> Option<(u64, u64)> {\n+            match ctor {\n+                Single | Variant(_) | Slice(_) => {\n+                    None\n+                }\n+                ConstantValue(const_) => {\n+                    if let Some(val) = const_.assert_usize(tcx) {\n+                        return Some((val, val));\n+                    }\n+                    None\n+                }\n+                ConstantRange(lo, hi, end) => {\n+                    if let Some(lo) = lo.assert_usize(tcx) {\n+                        if let Some(hi) = hi.assert_usize(tcx) {\n+                            if lo > hi || lo == hi && end == &RangeEnd::Excluded {\n+                                return None;\n+                            } else if end == &RangeEnd::Included {\n+                                return Some((lo, hi));\n+                            } else {\n+                                return Some((lo, hi - 1));\n+                            }\n+                        }\n+                    }\n+                    None\n+                }\n+            }\n+        }\n+\n+        fn intersect<'a, 'tcx>(\n+                    _deb: bool,\n+                    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                    ranges: Vec<Constructor<'tcx>>,\n+                     ctor: &Constructor<'tcx>)\n+                     -> (Vec<Constructor<'tcx>>, bool) {\n+            if let Some((lo1, hi1)) = to_inc_range_pair(cx.tcx, ctor) {\n+                let mut ctor_was_useful = false;\n+                // values only consists of ranges\n+                let mut new_ranges = vec![];\n+                let mut ranges: Vec<_> =\n+                    ranges.into_iter().filter_map(|r| to_inc_range_pair(cx.tcx, &r)).collect();\n+                while let Some((lo2, hi2)) = ranges.pop() {\n+                    eprintln!(\"{:?} {:?}\", (lo2, hi2), (lo1, hi1));\n+                    if lo1 <= lo2 && hi1 >= hi2 {\n+                        if _deb { eprintln!(\"case 1\"); }\n+                        ctor_was_useful = true;\n+                        continue;\n+                    }\n+                    if lo1 > hi2 || hi1 < lo2 {\n+                        if _deb { eprintln!(\"case 2\"); }\n+                        new_ranges.push((lo2, hi2));\n+                        continue;\n+                    }\n+                    if lo1 <= lo2 {\n+                        if _deb { eprintln!(\"case 3\"); }\n+                        ctor_was_useful = true;\n+                        if (hi1 + 1, hi2) == (lo2, hi2) {\n+                            new_ranges.push((hi1 + 1, hi2));\n+                        } else {\n+                            ranges.push((hi1 + 1, hi2));\n+                        }\n+                        continue;\n+                    }\n+                    if hi1 >= hi2 {\n+                        if _deb { eprintln!(\"case 4\"); }\n+                        ctor_was_useful = true;\n+                        if (lo2, lo1 - 1) == (lo2, hi2) {\n+                            new_ranges.push((lo2, lo1 - 1));\n+                        } else {\n+                            ranges.push((lo2, lo1 - 1));\n+                        }\n+                        continue;\n+                    }\n+                    ctor_was_useful = true;\n+                    ranges.push((lo2, lo1));\n+                    ranges.push((hi1, hi2));\n+                    if _deb { eprintln!(\"case 5\"); }\n+                }\n+                // transform ranges to proper format\n+                (new_ranges.into_iter().map(|(lo, hi)| {\n+                    ConstantRange(ty::Const::from_usize(cx.tcx, lo),\n+                                ty::Const::from_usize(cx.tcx, hi),\n+                                RangeEnd::Included)\n+                }).collect(), ctor_was_useful)\n+            } else {\n+                (ranges, false)\n+            }\n+        }\n+\n+        // `used_ctors` are all the constructors that appear in patterns (must check if guards)\n+        // `all_ctors` are all the necessary constructors\n+        let mut missing_ctors = vec![];\n+        let mut all_actual_ctors = vec![];\n+        'req: for req_ctor in all_ctors.clone() {\n+            if _deb {\n+                eprintln!(\"req_ctor before {:?}\", req_ctor);\n+            }\n+            let mut cur = vec![req_ctor.clone()];\n+            for used_ctor in &used_ctors {\n+                if _deb {\n+                    eprintln!(\"cut {:?}\", used_ctor);\n+                }\n+                if cur.iter().all(|ctor| {\n+                    match ctor {\n+                        ConstantRange(..) => true,\n+                        _ => false,\n+                    }\n+                }) {\n+                    let (cur2, ctor_was_useful) = intersect(_deb, cx, cur, used_ctor);\n+                    cur = cur2;\n+                    if ctor_was_useful {\n+                        all_actual_ctors.push(used_ctor.clone());\n+                    }\n+                    if cur.is_empty() {\n+                        continue 'req;\n+                    }\n+                } else {\n+                    if used_ctor == &req_ctor {\n+                        continue 'req;\n+                    }\n+                }\n+            }\n+            if _deb {\n+                eprintln!(\"req_ctor after {:?}\", cur);\n+            }\n+            missing_ctors.extend(cur);\n+        }\n+\n+        // let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n+        //     !used_ctors.contains(*c)\n+        // }).cloned().collect();\n+\n+        if _deb {\n+            eprintln!(\"used_ctors {:?}\", used_ctors);\n+            eprintln!(\"missing_ctors {:?}\", missing_ctors);\n+        }\n+\n+        // if !all_actual_ctors.is_empty() {\n+        //     all_ctors = all_actual_ctors;\n+        // }\n \n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n@@ -693,10 +837,16 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive;\n \n         if missing_ctors.is_empty() && !is_non_exhaustive {\n-            all_ctors.into_iter().map(|c| {\n+            if _ranged && _deb {\n+                return NotUseful;\n+            }\n+            let z = all_ctors.into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n-            }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n+            }).find(|result| result.is_useful()).unwrap_or(NotUseful);\n+            if _deb { eprintln!(\"ABC 1 {:?}\", z); }\n+            z\n         } else {\n+            if _deb { eprintln!(\"ABC 2\"); }\n             let matrix = rows.iter().filter_map(|r| {\n                 if r[0].is_wildcard() {\n                     Some(r[1..].to_vec())\n@@ -706,6 +856,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             }).collect();\n             match is_useful(cx, &matrix, &v[1..], witness) {\n                 UsefulWithWitness(pats) => {\n+                    if _deb { eprintln!(\"ABC 3\"); }\n                     let cx = &*cx;\n                     // In this case, there's at least one \"free\"\n                     // constructor that is only matched against by\n@@ -752,6 +903,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     // satisfied with `(_, _, true)`. In this case,\n                     // `used_ctors` is empty.\n                     let new_witnesses = if is_non_exhaustive || used_ctors.is_empty() {\n+                        if _deb { eprintln!(\"ABC 4\"); }\n                         // All constructors are unused. Add wild patterns\n                         // rather than each individual constructor\n                         pats.into_iter().map(|mut witness| {\n@@ -763,6 +915,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                             witness\n                         }).collect()\n                     } else {\n+                        if _deb { eprintln!(\"ABC 5\"); }\n                         pats.into_iter().flat_map(|witness| {\n                             missing_ctors.iter().map(move |ctor| {\n                                 witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n@@ -1062,6 +1215,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n         PatternKind::Leaf { ref subpatterns } => {\n             Some(patterns_for_variant(subpatterns, wild_patterns))\n         }\n+\n         PatternKind::Deref { ref subpattern } => {\n             Some(vec![subpattern])\n         }"}]}