{"sha": "60b4082d5feed36622340d40eb81d68010ccd1df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYjQwODJkNWZlZWQzNjYyMjM0MGQ0MGViODFkNjgwMTBjY2QxZGY=", "commit": {"author": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2020-12-15T04:03:19Z"}, "committer": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2020-12-16T22:59:11Z"}, "message": "Add more documentation to `Diagnostic` and `DiagnosticBuilder`", "tree": {"sha": "f43c732445b92b450ac0dee981d90da30abce2ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f43c732445b92b450ac0dee981d90da30abce2ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60b4082d5feed36622340d40eb81d68010ccd1df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60b4082d5feed36622340d40eb81d68010ccd1df", "html_url": "https://github.com/rust-lang/rust/commit/60b4082d5feed36622340d40eb81d68010ccd1df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60b4082d5feed36622340d40eb81d68010ccd1df/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b32e6e6ac8921035177256ab6806e6ab0d4b9b94", "url": "https://api.github.com/repos/rust-lang/rust/commits/b32e6e6ac8921035177256ab6806e6ab0d4b9b94", "html_url": "https://github.com/rust-lang/rust/commit/b32e6e6ac8921035177256ab6806e6ab0d4b9b94"}], "stats": {"total": 61, "additions": 50, "deletions": 11}, "files": [{"sha": "c3422c78ef6e295d189e17d4c814316f8b377fe6", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/60b4082d5feed36622340d40eb81d68010ccd1df/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b4082d5feed36622340d40eb81d68010ccd1df/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=60b4082d5feed36622340d40eb81d68010ccd1df", "patch": "@@ -30,7 +30,8 @@ pub enum DiagnosticId {\n     Lint { name: String, has_future_breakage: bool },\n }\n \n-/// For example a note attached to an error.\n+/// A \"sub\"-diagnostic attached to a parent diagnostic.\n+/// For example, a note attached to an error.\n #[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub struct SubDiagnostic {\n     pub level: Level,\n@@ -124,6 +125,7 @@ impl Diagnostic {\n         self.level = Level::Cancelled;\n     }\n \n+    /// Check if this diagnostic [was cancelled][Self::cancel()].\n     pub fn cancelled(&self) -> bool {\n         self.level == Level::Cancelled\n     }\n@@ -241,6 +243,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Add a note attached to this diagnostic.\n     pub fn note(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Note, msg, MultiSpan::new(), None);\n         self\n@@ -252,33 +255,40 @@ impl Diagnostic {\n     }\n \n     /// Prints the span with a note above it.\n+    /// This is like [`Diagnostic::note()`], but it gets its own span.\n     pub fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Note, msg, sp.into(), None);\n         self\n     }\n \n+    /// Add a warning attached to this diagnostic.\n     pub fn warn(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, MultiSpan::new(), None);\n         self\n     }\n \n-    /// Prints the span with a warn above it.\n+    /// Prints the span with a warning above it.\n+    /// This is like [`Diagnostic::warn()`], but it gets its own span.\n     pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n \n+    /// Add a help message attached to this diagnostic.\n     pub fn help(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with some help above it.\n+    /// This is like [`Diagnostic::help()`], but it gets its own span.\n     pub fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, sp.into(), None);\n         self\n     }\n \n+    /// Show a suggestion that has multiple parts to it.\n+    /// In other words, multiple changes need to be applied as part of this suggestion.\n     pub fn multipart_suggestion(\n         &mut self,\n         msg: &str,\n@@ -299,6 +309,8 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Show multiple suggestions that have multiple parts.\n+    /// See also [`Diagnostic::multipart_suggestion()`].\n     pub fn multipart_suggestions(\n         &mut self,\n         msg: &str,\n@@ -382,6 +394,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// [`Diagnostic::span_suggestion()`] but you can set the [`SuggestionStyle`].\n     pub fn span_suggestion_with_style(\n         &mut self,\n         sp: Span,\n@@ -401,6 +414,7 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Always show the suggested change.\n     pub fn span_suggestion_verbose(\n         &mut self,\n         sp: Span,\n@@ -419,6 +433,7 @@ impl Diagnostic {\n     }\n \n     /// Prints out a message with multiple suggested edits of the code.\n+    /// See also [`Diagnostic::span_suggestion()`].\n     pub fn span_suggestions(\n         &mut self,\n         sp: Span,\n@@ -458,7 +473,7 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Prints out a message with for a suggestion without showing the suggested code.\n+    /// Prints out a message for a suggestion without showing the suggested code.\n     ///\n     /// This is intended to be used for suggestions that are obvious in what the changes need to\n     /// be from the message, showing the span label inline would be visually unpleasant\n@@ -481,7 +496,7 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Adds a suggestion to the json output, but otherwise remains silent/undisplayed in the cli.\n+    /// Adds a suggestion to the JSON output that will not be shown in the CLI.\n     ///\n     /// This is intended to be used for suggestions that are *very* obvious in what the changes\n     /// need to be from the message, but we still want other tools to be able to apply them."}, {"sha": "de6d7c3f5d87538332ec59c8613b2ccdc7ebc81e", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/60b4082d5feed36622340d40eb81d68010ccd1df/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b4082d5feed36622340d40eb81d68010ccd1df/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=60b4082d5feed36622340d40eb81d68010ccd1df", "patch": "@@ -30,6 +30,15 @@ struct DiagnosticBuilderInner<'a> {\n     allow_suggestions: bool,\n }\n \n+/// This is a helper macro for [`forward!`] that allows automatically adding documentation\n+/// that uses tokens from [`forward!`]'s input.\n+macro_rules! forward_inner_docs {\n+    ($e:expr => $i:item) => {\n+        #[doc = $e]\n+        $i\n+    }\n+}\n+\n /// In general, the `DiagnosticBuilder` uses deref to allow access to\n /// the fields and methods of the embedded `diagnostic` in a\n /// transparent way. *However,* many of the methods are intended to\n@@ -45,10 +54,11 @@ macro_rules! forward {\n         pub fn $n:ident(&self, $($name:ident: $ty:ty),* $(,)?) -> &Self\n     ) => {\n         $(#[$attrs])*\n+        forward_inner_docs!(concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\") =>\n         pub fn $n(&self, $($name: $ty),*) -> &Self {\n             self.diagnostic.$n($($name),*);\n             self\n-        }\n+        });\n     };\n \n     // Forward pattern for &mut self -> &mut Self\n@@ -57,10 +67,11 @@ macro_rules! forward {\n         pub fn $n:ident(&mut self, $($name:ident: $ty:ty),* $(,)?) -> &mut Self\n     ) => {\n         $(#[$attrs])*\n+        forward_inner_docs!(concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\") =>\n         pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n             self.0.diagnostic.$n($($name),*);\n             self\n-        }\n+        });\n     };\n \n     // Forward pattern for &mut self -> &mut Self, with S: Into<MultiSpan>\n@@ -74,10 +85,11 @@ macro_rules! forward {\n         ) -> &mut Self\n     ) => {\n         $(#[$attrs])*\n+        forward_inner_docs!(concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\") =>\n         pub fn $n<S: Into<MultiSpan>>(&mut self, $($name: $ty),*) -> &mut Self {\n             self.0.diagnostic.$n($($name),*);\n             self\n-        }\n+        });\n     };\n }\n \n@@ -116,7 +128,7 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     /// Stashes diagnostic for possible later improvement in a different,\n     /// later stage of the compiler. The diagnostic can be accessed with\n-    /// the provided `span` and `key` through `.steal_diagnostic` on `Handler`.\n+    /// the provided `span` and `key` through [`Handler::steal_diagnostic()`].\n     ///\n     /// As with `buffer`, this is unless the handler has disabled such buffering.\n     pub fn stash(self, span: Span, key: StashKey) {\n@@ -202,7 +214,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     }\n \n     /// Labels all the given spans with the provided label.\n-    /// See `span_label` for more information.\n+    /// See [`Diagnostic::span_label()`] for more information.\n     pub fn span_labels(\n         &mut self,\n         spans: impl IntoIterator<Item = Span>,\n@@ -254,6 +266,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         msg: &str,\n     ) -> &mut Self);\n \n+    /// See [`Diagnostic::multipart_suggestion()`].\n     pub fn multipart_suggestion(\n         &mut self,\n         msg: &str,\n@@ -267,6 +280,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::multipart_suggestions()`].\n     pub fn multipart_suggestions(\n         &mut self,\n         msg: &str,\n@@ -280,6 +294,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::tool_only_multipart_suggestion()`].\n     pub fn tool_only_multipart_suggestion(\n         &mut self,\n         msg: &str,\n@@ -293,6 +308,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::span_suggestion()`].\n     pub fn span_suggestion(\n         &mut self,\n         sp: Span,\n@@ -307,6 +323,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::span_suggestions()`].\n     pub fn span_suggestions(\n         &mut self,\n         sp: Span,\n@@ -321,6 +338,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::span_suggestion_short()`].\n     pub fn span_suggestion_short(\n         &mut self,\n         sp: Span,\n@@ -335,6 +353,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::span_suggestion_verbose()`].\n     pub fn span_suggestion_verbose(\n         &mut self,\n         sp: Span,\n@@ -349,6 +368,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::span_suggestion_hidden()`].\n     pub fn span_suggestion_hidden(\n         &mut self,\n         sp: Span,\n@@ -363,6 +383,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    /// See [`Diagnostic::tool_only_span_suggestion()`] for more information.\n     pub fn tool_only_span_suggestion(\n         &mut self,\n         sp: Span,\n@@ -380,19 +401,22 @@ impl<'a> DiagnosticBuilder<'a> {\n     forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n     forward!(pub fn code(&mut self, s: DiagnosticId) -> &mut Self);\n \n+    /// Allow attaching suggestions this diagnostic.\n+    /// If this is set to `false`, then any suggestions attached with the `span_suggestion_*`\n+    /// methods after this is set to `false` will be ignored.\n     pub fn allow_suggestions(&mut self, allow: bool) -> &mut Self {\n         self.0.allow_suggestions = allow;\n         self\n     }\n \n     /// Convenience function for internal use, clients should use one of the\n-    /// struct_* methods on Handler.\n+    /// `struct_*` methods on [`Handler`].\n     crate fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder::new_with_code(handler, level, None, message)\n     }\n \n     /// Convenience function for internal use, clients should use one of the\n-    /// struct_* methods on Handler.\n+    /// `struct_*` methods on [`Handler`].\n     crate fn new_with_code(\n         handler: &'a Handler,\n         level: Level,"}]}