{"sha": "83595f9242ad9e8a7da091f65d450e44e4434f89", "node_id": "C_kwDOAAsO6NoAKDgzNTk1ZjkyNDJhZDllOGE3ZGEwOTFmNjVkNDUwZTQ0ZTQ0MzRmODk", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-04-02T21:29:41Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-04-02T21:29:41Z"}, "message": "Fix `array::IntoIter::fold` to use the optimized `Range::fold`\n\nIt was using `Iterator::by_ref` in the implementation, which ended up pessimizing it enough that, for example, it didn't vectorize when we tried it in the <https://rust-lang.zulipchat.com/#narrow/stream/257879-project-portable-simd/topic/Reducing.20sum.20into.20wider.20types> conversation.\n\nDemonstration that the codegen test doesn't pass on the current nightly: <https://rust.godbolt.org/z/Taxev5eMn>", "tree": {"sha": "98404a3bad2a0be64721abdd38e705e45b6ab209", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98404a3bad2a0be64721abdd38e705e45b6ab209"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83595f9242ad9e8a7da091f65d450e44e4434f89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83595f9242ad9e8a7da091f65d450e44e4434f89", "html_url": "https://github.com/rust-lang/rust/commit/83595f9242ad9e8a7da091f65d450e44e4434f89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83595f9242ad9e8a7da091f65d450e44e4434f89/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb82facb1626166188d49599a3313fc95201f556", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb82facb1626166188d49599a3313fc95201f556", "html_url": "https://github.com/rust-lang/rust/commit/eb82facb1626166188d49599a3313fc95201f556"}], "stats": {"total": 131, "additions": 130, "deletions": 1}, "files": [{"sha": "baf2f2d6c971431a2179f8bf151595da38b6a0cf", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83595f9242ad9e8a7da091f65d450e44e4434f89/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83595f9242ad9e8a7da091f65d450e44e4434f89/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=83595f9242ad9e8a7da091f65d450e44e4434f89", "patch": "@@ -266,7 +266,7 @@ impl<T, const N: usize> Iterator for IntoIter<T, N> {\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let data = &mut self.data;\n-        self.alive.by_ref().fold(init, |acc, idx| {\n+        iter::ByRefSized(&mut self.alive).fold(init, |acc, idx| {\n             // SAFETY: idx is obtained by folding over the `alive` range, which implies the\n             // value is currently considered alive but as the range is being consumed each value\n             // we read here will only be read once and then considered dead.\n@@ -323,6 +323,20 @@ impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N> {\n         })\n     }\n \n+    #[inline]\n+    fn rfold<Acc, Fold>(mut self, init: Acc, mut rfold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let data = &mut self.data;\n+        iter::ByRefSized(&mut self.alive).rfold(init, |acc, idx| {\n+            // SAFETY: idx is obtained by folding over the `alive` range, which implies the\n+            // value is currently considered alive but as the range is being consumed each value\n+            // we read here will only be read once and then considered dead.\n+            rfold(acc, unsafe { data.get_unchecked(idx).assume_init_read() })\n+        })\n+    }\n+\n     fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n         let len = self.len();\n "}, {"sha": "890faa5975f3e5ceccef732e9b1dc58a5d49b18b", "filename": "library/core/src/iter/adapters/by_ref_sized.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/83595f9242ad9e8a7da091f65d450e44e4434f89/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83595f9242ad9e8a7da091f65d450e44e4434f89/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs?ref=83595f9242ad9e8a7da091f65d450e44e4434f89", "patch": "@@ -40,3 +40,32 @@ impl<I: Iterator> Iterator for ByRefSized<'_, I> {\n         self.0.try_fold(init, f)\n     }\n }\n+\n+impl<I: DoubleEndedIterator> DoubleEndedIterator for ByRefSized<'_, I> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.0.next_back()\n+    }\n+\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.0.advance_back_by(n)\n+    }\n+\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.0.nth_back(n)\n+    }\n+\n+    fn rfold<B, F>(self, init: B, f: F) -> B\n+    where\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        self.0.rfold(init, f)\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        self.0.try_rfold(init, f)\n+    }\n+}"}, {"sha": "ee7ff012ec1c12e4ab64aeb3f76f3a34f72dc470", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/83595f9242ad9e8a7da091f65d450e44e4434f89/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83595f9242ad9e8a7da091f65d450e44e4434f89/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=83595f9242ad9e8a7da091f65d450e44e4434f89", "patch": "@@ -668,3 +668,35 @@ fn array_mixed_equality_nans() {\n     assert!(!(mut3 == array3));\n     assert!(mut3 != array3);\n }\n+\n+#[test]\n+fn array_into_iter_fold() {\n+    // Strings to help MIRI catch if we double-free or something\n+    let a = [\"Aa\".to_string(), \"Bb\".to_string(), \"Cc\".to_string()];\n+    let mut s = \"s\".to_string();\n+    a.into_iter().for_each(|b| s += &b);\n+    assert_eq!(s, \"sAaBbCc\");\n+\n+    let a = [1, 2, 3, 4, 5, 6];\n+    let mut it = a.into_iter();\n+    it.advance_by(1).unwrap();\n+    it.advance_back_by(2).unwrap();\n+    let s = it.fold(10, |a, b| 10 * a + b);\n+    assert_eq!(s, 10234);\n+}\n+\n+#[test]\n+fn array_into_iter_rfold() {\n+    // Strings to help MIRI catch if we double-free or something\n+    let a = [\"Aa\".to_string(), \"Bb\".to_string(), \"Cc\".to_string()];\n+    let mut s = \"s\".to_string();\n+    a.into_iter().rev().for_each(|b| s += &b);\n+    assert_eq!(s, \"sCcBbAa\");\n+\n+    let a = [1, 2, 3, 4, 5, 6];\n+    let mut it = a.into_iter();\n+    it.advance_by(1).unwrap();\n+    it.advance_back_by(2).unwrap();\n+    let s = it.rfold(10, |a, b| 10 * a + b);\n+    assert_eq!(s, 10432);\n+}"}, {"sha": "fde9b0fcd8ac16d355568a8e48741e5979caa14c", "filename": "src/test/codegen/simd-wide-sum.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/83595f9242ad9e8a7da091f65d450e44e4434f89/src%2Ftest%2Fcodegen%2Fsimd-wide-sum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83595f9242ad9e8a7da091f65d450e44e4434f89/src%2Ftest%2Fcodegen%2Fsimd-wide-sum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-wide-sum.rs?ref=83595f9242ad9e8a7da091f65d450e44e4434f89", "patch": "@@ -0,0 +1,54 @@\n+// compile-flags: -C opt-level=3 --edition=2021\n+// only-x86_64\n+// ignore-debug: the debug assertions get in the way\n+\n+#![crate_type = \"lib\"]\n+#![feature(portable_simd)]\n+\n+use std::simd::Simd;\n+const N: usize = 8;\n+\n+#[no_mangle]\n+// CHECK-LABEL: @wider_reduce_simd\n+pub fn wider_reduce_simd(x: Simd<u8, N>) -> u16 {\n+    // CHECK: zext <8 x i8>\n+    // CHECK-SAME: to <8 x i16>\n+    // CHECK: call i16 @llvm.vector.reduce.add.v8i16(<8 x i16>\n+    let x: Simd<u16, N> = x.cast();\n+    x.reduce_sum()\n+}\n+\n+#[no_mangle]\n+// CHECK-LABEL: @wider_reduce_loop\n+pub fn wider_reduce_loop(x: Simd<u8, N>) -> u16 {\n+    // CHECK: zext <8 x i8>\n+    // CHECK-SAME: to <8 x i16>\n+    // CHECK: call i16 @llvm.vector.reduce.add.v8i16(<8 x i16>\n+    let mut sum = 0_u16;\n+    for i in 0..N {\n+        sum += u16::from(x[i]);\n+    }\n+    sum\n+}\n+\n+#[no_mangle]\n+// CHECK-LABEL: @wider_reduce_iter\n+pub fn wider_reduce_iter(x: Simd<u8, N>) -> u16 {\n+    // CHECK: zext <8 x i8>\n+    // CHECK-SAME: to <8 x i16>\n+    // CHECK: call i16 @llvm.vector.reduce.add.v8i16(<8 x i16>\n+    x.as_array().iter().copied().map(u16::from).sum()\n+}\n+\n+// This iterator one is the most interesting, as it's the one\n+// which used to not auto-vectorize due to a suboptimality in the\n+// `<array::IntoIter as Iterator>::fold` implementation.\n+\n+#[no_mangle]\n+// CHECK-LABEL: @wider_reduce_into_iter\n+pub fn wider_reduce_into_iter(x: Simd<u8, N>) -> u16 {\n+    // CHECK: zext <8 x i8>\n+    // CHECK-SAME: to <8 x i16>\n+    // CHECK: call i16 @llvm.vector.reduce.add.v8i16(<8 x i16>\n+    x.to_array().into_iter().map(u16::from).sum()\n+}"}]}