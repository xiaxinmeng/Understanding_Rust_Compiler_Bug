{"sha": "9c54d862b858399c2990f9eaba963fb19bfa9c6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNTRkODYyYjg1ODM5OWMyOTkwZjllYWJhOTYzZmIxOWJmYTljNmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-02T08:54:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-03T12:00:51Z"}, "message": "Stop calling `bug()` in various weird cases and instead generate `Err()`.", "tree": {"sha": "bdd6272cbe2336766987a0735505c6a2c00e2a63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdd6272cbe2336766987a0735505c6a2c00e2a63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c54d862b858399c2990f9eaba963fb19bfa9c6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c54d862b858399c2990f9eaba963fb19bfa9c6a", "html_url": "https://github.com/rust-lang/rust/commit/9c54d862b858399c2990f9eaba963fb19bfa9c6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c54d862b858399c2990f9eaba963fb19bfa9c6a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7abf47058e73ea4a95031fb80d92f636e5a18f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7abf47058e73ea4a95031fb80d92f636e5a18f9", "html_url": "https://github.com/rust-lang/rust/commit/f7abf47058e73ea4a95031fb80d92f636e5a18f9"}], "stats": {"total": 56, "additions": 21, "deletions": 35}, "files": [{"sha": "59a9b73e978e694024f73fe8d67e031174cdec51", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9c54d862b858399c2990f9eaba963fb19bfa9c6a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c54d862b858399c2990f9eaba963fb19bfa9c6a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9c54d862b858399c2990f9eaba963fb19bfa9c6a", "patch": "@@ -195,51 +195,39 @@ pub enum deref_kind {\n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n-pub fn opt_deref_kind(t: Ty) -> Option<deref_kind> {\n+pub fn deref_kind(t: Ty) -> McResult<deref_kind> {\n     match t.sty {\n         ty::ty_uniq(_) |\n         ty::ty_closure(box ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n-            Some(deref_ptr(Unique))\n+            Ok(deref_ptr(Unique))\n         }\n \n         ty::ty_rptr(r, mt) => {\n             let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n-            Some(deref_ptr(BorrowedPtr(kind, *r)))\n+            Ok(deref_ptr(BorrowedPtr(kind, *r)))\n         }\n \n         ty::ty_closure(box ty::ClosureTy {\n                 store: ty::RegionTraitStore(r, _),\n                 ..\n             }) => {\n-            Some(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n+            Ok(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n         }\n \n         ty::ty_ptr(ref mt) => {\n-            Some(deref_ptr(UnsafePtr(mt.mutbl)))\n+            Ok(deref_ptr(UnsafePtr(mt.mutbl)))\n         }\n \n         ty::ty_enum(..) |\n         ty::ty_struct(..) => { // newtype\n-            Some(deref_interior(InteriorField(PositionalField(0))))\n+            Ok(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n         ty::ty_vec(_, _) | ty::ty_str => {\n-            Some(deref_interior(InteriorElement(element_kind(t))))\n+            Ok(deref_interior(InteriorElement(element_kind(t))))\n         }\n \n-        _ => None\n-    }\n-}\n-\n-pub fn deref_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> deref_kind {\n-    debug!(\"deref_kind {}\", ty_to_string(tcx, t));\n-    match opt_deref_kind(t) {\n-      Some(k) => k,\n-      None => {\n-        tcx.sess.bug(\n-            format!(\"deref_kind() invoked on non-derefable type {}\",\n-                    ty_to_string(tcx, t))[]);\n-      }\n+        _ => Err(()),\n     }\n }\n \n@@ -403,7 +391,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty<'tcx>> {\n         let tcx = self.typer.tcx();\n-        let base_ty = self.typer.node_ty(pat.id);\n+        let base_ty = try!(self.typer.node_ty(pat.id));\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n         // *being borrowed* is.  But ideally we would put in a more\n@@ -413,15 +401,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n-                ty::deref(base_ty, false).unwrap_or_else(|| {\n-                    panic!(\"encountered BindByRef with non &-type\");\n-                }).ty\n+                match ty::deref(base_ty, false) {\n+                    Some(t) => t.ty,\n+                    None => { return Err(()); }\n+                }\n             }\n             _ => base_ty,\n         };\n         debug!(\"pat_ty(pat={}) base_ty={} ret_ty={}\",\n                pat.repr(tcx), base_ty.repr(tcx), ret_ty.repr(tcx));\n-        ret_ty\n+        Ok(ret_ty)\n     }\n \n     pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n@@ -909,13 +898,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n             None => base_cmt\n         };\n-        match ty::deref(base_cmt.ty, true) {\n+        let base_cmt_ty = base_cmt.ty;\n+        match ty::deref(base_cmt_ty, true) {\n             Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty, implicit),\n             None => {\n-                self.tcx().sess.span_bug(\n-                    node.span(),\n-                    format!(\"Explicit deref of non-derefable type: {}\",\n-                            base_cmt.ty.repr(self.tcx()))[]);\n+                debug!(\"Explicit deref of non-derefable type: {}\",\n+                       base_cmt_ty.repr(self.tcx()));\n+                return Err(());\n             }\n         }\n     }\n@@ -992,17 +981,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 match ty::array_element_ty(self.tcx(), base_cmt.ty) {\n                     Some(ty) => ty,\n                     None => {\n-                        self.tcx().sess.span_bug(\n-                            elt.span(),\n-                            format!(\"Explicit index of non-index type `{}`\",\n-                                    base_cmt.ty.repr(self.tcx()))[]);\n+                        return Err(());\n                     }\n                 }\n             }\n         };\n \n         let m = base_cmt.mutbl.inherit();\n-        return interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty);\n+        return Ok(interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty));\n \n         fn interior<'tcx, N: ast_node>(elt: &N,\n                                        of_cmt: cmt<'tcx>,"}]}