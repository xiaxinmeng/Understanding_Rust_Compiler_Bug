{"sha": "4899ac8c053ef782c25c87b12b54dbcbfdb5e0fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4OTlhYzhjMDUzZWY3ODJjMjVjODdiMTJiNTRkYmNiZmRiNWUwZmI=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-22T07:36:48Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:49:44Z"}, "message": "Correct binding pattern's type; handle invalid records.", "tree": {"sha": "3cc5d66b09f594dc0f0afec4df85895193f11543", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cc5d66b09f594dc0f0afec4df85895193f11543"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4899ac8c053ef782c25c87b12b54dbcbfdb5e0fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4899ac8c053ef782c25c87b12b54dbcbfdb5e0fb", "html_url": "https://github.com/rust-lang/rust/commit/4899ac8c053ef782c25c87b12b54dbcbfdb5e0fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4899ac8c053ef782c25c87b12b54dbcbfdb5e0fb/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3088ca0a53540e0d7ae14f0d18efcad16cad0735", "url": "https://api.github.com/repos/rust-lang/rust/commits/3088ca0a53540e0d7ae14f0d18efcad16cad0735", "html_url": "https://github.com/rust-lang/rust/commit/3088ca0a53540e0d7ae14f0d18efcad16cad0735"}], "stats": {"total": 60, "additions": 55, "deletions": 5}, "files": [{"sha": "1d250413d2218f97cff92c00080fab75818652c3", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4899ac8c053ef782c25c87b12b54dbcbfdb5e0fb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4899ac8c053ef782c25c87b12b54dbcbfdb5e0fb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=4899ac8c053ef782c25c87b12b54dbcbfdb5e0fb", "patch": "@@ -24,6 +24,7 @@ pub(crate) type PatId = Idx<Pat>;\n pub(crate) enum PatternError {\n     Unimplemented,\n     UnresolvedVariant,\n+    MissingField,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -105,7 +106,7 @@ impl<'a> PatCtxt<'a> {\n     }\n \n     fn lower_pattern_unadjusted(&mut self, pat: hir_def::expr::PatId) -> Pat {\n-        let ty = &self.infer[pat];\n+        let mut ty = &self.infer[pat];\n         let variant = self.infer.variant_resolution_for_pat(pat);\n \n         let kind = match self.body[pat] {\n@@ -127,6 +128,9 @@ impl<'a> PatCtxt<'a> {\n             }\n \n             hir_def::expr::Pat::Bind { subpat, .. } => {\n+                if let TyKind::Ref(.., rty) = ty.kind(&Interner) {\n+                    ty = rty;\n+                }\n                 PatKind::Binding { subpattern: self.lower_opt_pattern(subpat) }\n             }\n \n@@ -140,13 +144,21 @@ impl<'a> PatCtxt<'a> {\n                 let variant_data = variant.unwrap().variant_data(self.db.upcast());\n                 let subpatterns = args\n                     .iter()\n-                    .map(|field| FieldPat {\n+                    .map(|field| {\n                         // XXX(iDawer): field lookup is inefficient\n-                        field: variant_data.field(&field.name).unwrap(),\n-                        pattern: self.lower_pattern(field.pat),\n+                        variant_data.field(&field.name).map(|lfield_id| FieldPat {\n+                            field: lfield_id,\n+                            pattern: self.lower_pattern(field.pat),\n+                        })\n                     })\n                     .collect();\n-                self.lower_variant_or_leaf(pat, ty, subpatterns)\n+                match subpatterns {\n+                    Some(subpatterns) => self.lower_variant_or_leaf(pat, ty, subpatterns),\n+                    None => {\n+                        self.errors.push(PatternError::MissingField);\n+                        PatKind::Wild\n+                    }\n+                }\n             }\n             hir_def::expr::Pat::TupleStruct { .. } | hir_def::expr::Pat::Record { .. } => {\n                 self.errors.push(PatternError::UnresolvedVariant);\n@@ -1090,6 +1102,31 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn binding_ref_has_correct_type() {\n+        // Asserts `PatKind::Binding(ref _x): bool`, not &bool.\n+        // If that's not true match checking will panic with \"incompatible constructors\"\n+        // FIXME: make facilities to test this directly like `tests::check_infer(..)`\n+        check_diagnostics(\n+            r#\"\n+enum Foo { A }\n+fn main() {\n+    // FIXME: this should not bail out but current behavior is such as the old algorithm.\n+    // ExprValidator::validate_match(..) checks types of top level patterns incorrecly.\n+    match Foo::A {\n+        ref _x => {}\n+    //  ^^^^^^ Internal: match check bailed out\n+        Foo::A => {}\n+    }\n+    match (true,) {\n+        (ref _x,) => {}\n+        (true,) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn enum_non_exhaustive() {\n         check_diagnostics(\n@@ -1161,6 +1198,19 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn record_struct_no_such_field() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo { }\n+fn main(f: Foo) {\n+    match f { Foo { bar } => () }\n+    //        ^^^^^^^^^^^ Internal: match check bailed out\n+}\n+\"#,\n+        );\n+    }\n+\n     mod false_negatives {\n         //! The implementation of match checking here is a work in progress. As we roll this out, we\n         //! prefer false negatives to false positives (ideally there would be no false positives). This"}]}