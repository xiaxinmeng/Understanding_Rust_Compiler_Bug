{"sha": "166d5f8b2fa853e3fa14a719c13d59b7b7160237", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NmQ1ZjhiMmZhODUzZTNmYTE0YTcxOWMxM2Q1OWI3YjcxNjAyMzc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-03T14:13:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-07T18:06:47Z"}, "message": "rustc_metadata: Privatize everything in decoder", "tree": {"sha": "177515114a2b8d6dc66ba0c7999890e3f8b02071", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/177515114a2b8d6dc66ba0c7999890e3f8b02071"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/166d5f8b2fa853e3fa14a719c13d59b7b7160237", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/166d5f8b2fa853e3fa14a719c13d59b7b7160237", "html_url": "https://github.com/rust-lang/rust/commit/166d5f8b2fa853e3fa14a719c13d59b7b7160237", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/166d5f8b2fa853e3fa14a719c13d59b7b7160237/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c9d4246b0826430d287936f9041a13ab5581710", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c9d4246b0826430d287936f9041a13ab5581710", "html_url": "https://github.com/rust-lang/rust/commit/0c9d4246b0826430d287936f9041a13ab5581710"}], "stats": {"total": 108, "additions": 54, "deletions": 54}, "files": [{"sha": "0d113cecff561182078fd2ff0f1c210719541831", "filename": "src/librustc_metadata/schema/decoder.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/166d5f8b2fa853e3fa14a719c13d59b7b7160237/src%2Flibrustc_metadata%2Fschema%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166d5f8b2fa853e3fa14a719c13d59b7b7160237/src%2Flibrustc_metadata%2Fschema%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema%2Fdecoder.rs?ref=166d5f8b2fa853e3fa14a719c13d59b7b7160237", "patch": "@@ -468,7 +468,7 @@ impl<'tcx> EntryKind<'tcx> {\n }\n \n impl<'a, 'tcx> CrateMetadata {\n-    crate fn is_proc_macro_crate(&self) -> bool {\n+    fn is_proc_macro_crate(&self) -> bool {\n         self.root.proc_macro_decls_static.is_some()\n     }\n \n@@ -511,7 +511,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    crate fn item_name(&self, item_index: DefIndex) -> Symbol {\n+    fn item_name(&self, item_index: DefIndex) -> Symbol {\n         if !self.is_proc_macro(item_index) {\n             self.def_key(item_index)\n                 .disambiguated_data\n@@ -523,7 +523,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n+    fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n             self.kind(index).def_kind()\n         } else {\n@@ -533,11 +533,11 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n+    fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n         self.root.per_def.span.get(self, index).unwrap().decode((self, sess))\n     }\n \n-    crate fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n+    fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n         let (name, kind, helper_attrs) = match *self.raw_proc_macro(id) {\n             ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                 let helper_attrs =\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    crate fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n+    fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n         match self.kind(item_id) {\n             EntryKind::Trait(data) => {\n                 let data = data.decode((self, sess));\n@@ -637,7 +637,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    crate fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n+    fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n         let kind = self.kind(item_id);\n         let did = self.local_def_id(item_id);\n \n@@ -662,15 +662,15 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_adt_def(did, adt_kind, variants, repr)\n     }\n \n-    crate fn get_explicit_predicates(\n+    fn get_explicit_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.root.per_def.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n-    crate fn get_inferred_outlives(\n+    fn get_inferred_outlives(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n@@ -680,36 +680,36 @@ impl<'a, 'tcx> CrateMetadata {\n         }).unwrap_or_default()\n     }\n \n-    crate fn get_super_predicates(\n+    fn get_super_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.root.per_def.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n-    crate fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n+    fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n         self.root.per_def.generics.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n-    crate fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         self.root.per_def.ty.get(self, id).unwrap().decode((self, tcx))\n     }\n \n-    crate fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n+    fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n             true => self.root.proc_macro_stability.clone(),\n             false => self.root.per_def.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }\n \n-    crate fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n+    fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n         self.root.per_def.deprecation.get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .map(|depr| depr.decode(self))\n     }\n \n-    crate fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n+    fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n         match self.is_proc_macro(id) {\n             true => ty::Visibility::Public,\n             false => self.root.per_def.visibility.get(self, id).unwrap().decode(self),\n@@ -723,31 +723,31 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n         self.get_impl_data(id).parent_impl\n     }\n \n-    crate fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n+    fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n         self.get_impl_data(id).polarity\n     }\n \n-    crate fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n+    fn get_impl_defaultness(&self, id: DefIndex) -> hir::Defaultness {\n         self.get_impl_data(id).defaultness\n     }\n \n-    crate fn get_coerce_unsized_info(\n+    fn get_coerce_unsized_info(\n         &self,\n         id: DefIndex,\n     ) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    crate fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n+    fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n         self.root.per_def.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n-    crate fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n+    fn get_lib_features(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    crate fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n+    fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n@@ -769,7 +769,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n-    crate fn get_diagnostic_items(\n+    fn get_diagnostic_items(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx FxHashMap<Symbol, DefId> {\n@@ -786,7 +786,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over each child of the given item.\n-    crate fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n+    fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n     {\n         if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n@@ -925,12 +925,12 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+    fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n             self.root.per_def.mir.get(self, id).is_some()\n     }\n \n-    crate fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+    fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n         self.root.per_def.mir.get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n@@ -939,7 +939,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .decode((self, tcx))\n     }\n \n-    crate fn get_promoted_mir(\n+    fn get_promoted_mir(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n@@ -952,7 +952,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .decode((self, tcx))\n     }\n \n-    crate fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n+    fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n         match self.kind(id) {\n             EntryKind::Const(qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplDefault, qualif, _) |\n@@ -963,7 +963,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n+    fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n         let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n@@ -996,12 +996,12 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n+    fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n         self.root.per_def.variances.get(self, id).unwrap_or(Lazy::empty())\n             .decode(self).collect()\n     }\n \n-    crate fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n+    fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n         match self.kind(node_id) {\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) |\n@@ -1010,7 +1010,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n+    fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n         match self.kind(node_id) {\n             EntryKind::Struct(data, _) => {\n                 data.decode(self).ctor.map(|index| self.local_def_id(index))\n@@ -1022,7 +1022,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n+    fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n         // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -1038,7 +1038,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect::<Vec<_>>())\n     }\n \n-    crate fn get_struct_field_names(\n+    fn get_struct_field_names(\n         &self,\n         id: DefIndex,\n         sess: &Session,\n@@ -1064,7 +1064,7 @@ impl<'a, 'tcx> CrateMetadata {\n         None\n     }\n \n-    crate fn get_inherent_implementations_for_type(\n+    fn get_inherent_implementations_for_type(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n@@ -1076,7 +1076,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    crate fn get_implementations_for_trait(\n+    fn get_implementations_for_trait(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n@@ -1107,7 +1107,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n+    fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n         let def_key = self.def_key(id);\n         match def_key.disambiguated_data.data {\n             DefPathData::TypeNs(..) | DefPathData::ValueNs(..) => (),\n@@ -1124,7 +1124,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    crate fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n+    fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n@@ -1133,7 +1133,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n+    fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n@@ -1142,7 +1142,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_dylib_dependency_formats(\n+    fn get_dylib_dependency_formats(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(CrateNum, LinkagePreference)] {\n@@ -1156,7 +1156,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }))\n     }\n \n-    crate fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n+    fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n         if self.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n@@ -1167,7 +1167,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+    fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n         let param_names = match self.kind(id) {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).param_names,\n@@ -1177,7 +1177,7 @@ impl<'a, 'tcx> CrateMetadata {\n         param_names.decode(self).collect()\n     }\n \n-    crate fn exported_symbols(\n+    fn exported_symbols(\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n@@ -1190,22 +1190,22 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn get_rendered_const(&self, id: DefIndex) -> String {\n+    fn get_rendered_const(&self, id: DefIndex) -> String {\n         match self.kind(id) {\n             EntryKind::Const(_, data) |\n             EntryKind::AssocConst(_, _, data) => data.decode(self).0,\n             _ => bug!(),\n         }\n     }\n \n-    crate fn get_macro(&self, id: DefIndex) -> MacroDef {\n+    fn get_macro(&self, id: DefIndex) -> MacroDef {\n         match self.kind(id) {\n             EntryKind::MacroDef(macro_def) => macro_def.decode(self),\n             _ => bug!(),\n         }\n     }\n \n-    crate fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n+    fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n         let constness = match self.kind(id) {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n@@ -1215,7 +1215,7 @@ impl<'a, 'tcx> CrateMetadata {\n         constness == hir::Constness::Const\n     }\n \n-    crate fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n+    fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n          match self.kind(id) {\n             EntryKind::Fn(data) => data.decode(self).asyncness,\n             EntryKind::Method(data) => data.decode(self).fn_data.asyncness,\n@@ -1224,7 +1224,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn is_foreign_item(&self, id: DefIndex) -> bool {\n+    fn is_foreign_item(&self, id: DefIndex) -> bool {\n         match self.kind(id) {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic |\n@@ -1233,7 +1233,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n+    fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n         match self.kind(id) {\n             EntryKind::ImmStatic |\n             EntryKind::ForeignImmStatic => Some(hir::MutImmutable),\n@@ -1243,12 +1243,12 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n+    fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         self.root.per_def.fn_sig.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     #[inline]\n-    crate fn def_key(&self, index: DefIndex) -> DefKey {\n+    fn def_key(&self, index: DefIndex) -> DefKey {\n         let mut key = self.def_path_table.def_key(index);\n         if self.is_proc_macro(index) {\n             let name = self.raw_proc_macro(index).name();\n@@ -1258,13 +1258,13 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     // Returns the path leading to the thing with this `id`.\n-    crate fn def_path(&self, id: DefIndex) -> DefPath {\n+    fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     #[inline]\n-    crate fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n         self.def_path_table.def_path_hash(index)\n     }\n \n@@ -1362,7 +1362,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     /// Get the `DepNodeIndex` corresponding this crate. The result of this\n     /// method is cached in the `dep_node_index` field.\n-    crate fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n+    fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n         let mut dep_node_index = self.dep_node_index.load();\n \n         if unlikely!(dep_node_index == DepNodeIndex::INVALID) {"}]}