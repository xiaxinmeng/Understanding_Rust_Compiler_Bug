{"sha": "7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlM2E4ZWM2ODg4YTA0YTRlYmMyNDhmNjE3OGFlMDJiNDhkZWEzYjY=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-01-31T15:36:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-31T15:36:41Z"}, "message": "Rollup merge of #80092 - sexxi-goose:restrict_precision, r=nikomatsakis\n\n2229: Fix issues with move closures and mutability\n\nThis PR fixes two issues when feature `capture_disjoint_fields` is used.\n\n1. Can't mutate using a mutable reference\n2. Move closures try to move value out through a reference.\n\nTo do so, we\n1. Compute the mutability of the capture and store it as part of the `CapturedPlace`  that is written in TypeckResults\n2. Restrict capture precision. Note this is temporary for now, to allow the feature to be used with move closures and ByValue captures and might change depending on discussions with the lang team.\n    - No Derefs are captured for ByValue captures, since that will result in value behind a reference getting moved.\n    - No projections are applied to raw pointers since these require unsafe blocks. We capture\n    them completely.\n\nr? `````@nikomatsakis`````", "tree": {"sha": "44bee011f9a43bf0149bf81458666a4cfea912f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44bee011f9a43bf0149bf81458666a4cfea912f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgFs6JCRBK7hj4Ov3rIwAAdHIIAJw++xfkaZHezZdY3YEhU8fP\nWm4ycKfYymri8Mu5TLXAq0Nfuva9Q06+dF/WKfZjHK+rKgGPPbeUVx4zQUu+2Oj/\nnLn/ZwHLRB2NcnaDsuE9966OPK4rbAbvwPo09eycOynkT6iYYhgTTTw2JBu1PzEn\nN8Z3J0p/Gxx4FkfqyAKLwi2hLfUvppO/R6l7S7ffidceXKRfLlGlbLGGMNxpJmsN\njkW5rdvat8R1wUGuUCMiVFvycih6MakCJ3QS9GLfvXdRKEYixfnhpu/iaN3aKQjD\nRQjZkLM8/dIxmvPG1qgLn2YmGJU84oPXng6/ww4WXeZFB6FX0ujJ0Q6Q7Cd/aDI=\n=vO2E\n-----END PGP SIGNATURE-----\n", "payload": "tree 44bee011f9a43bf0149bf81458666a4cfea912f0\nparent 0e63af5da3400ace48a0345117980473fd21ad73\nparent 0f4bab246b341b5d67ba1c01d81c4822f96dd878\nauthor Jonas Schievink <jonasschievink@gmail.com> 1612107401 +0100\ncommitter GitHub <noreply@github.com> 1612107401 +0100\n\nRollup merge of #80092 - sexxi-goose:restrict_precision, r=nikomatsakis\n\n2229: Fix issues with move closures and mutability\n\nThis PR fixes two issues when feature `capture_disjoint_fields` is used.\n\n1. Can't mutate using a mutable reference\n2. Move closures try to move value out through a reference.\n\nTo do so, we\n1. Compute the mutability of the capture and store it as part of the `CapturedPlace`  that is written in TypeckResults\n2. Restrict capture precision. Note this is temporary for now, to allow the feature to be used with move closures and ByValue captures and might change depending on discussions with the lang team.\n    - No Derefs are captured for ByValue captures, since that will result in value behind a reference getting moved.\n    - No projections are applied to raw pointers since these require unsafe blocks. We capture\n    them completely.\n\nr? `````@nikomatsakis`````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "html_url": "https://github.com/rust-lang/rust/commit/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e63af5da3400ace48a0345117980473fd21ad73", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e63af5da3400ace48a0345117980473fd21ad73", "html_url": "https://github.com/rust-lang/rust/commit/0e63af5da3400ace48a0345117980473fd21ad73"}, {"sha": "0f4bab246b341b5d67ba1c01d81c4822f96dd878", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f4bab246b341b5d67ba1c01d81c4822f96dd878", "html_url": "https://github.com/rust-lang/rust/commit/0f4bab246b341b5d67ba1c01d81c4822f96dd878"}], "stats": {"total": 1256, "additions": 1181, "deletions": 75}, "files": [{"sha": "babab005edb2b3a85c7dd53644b012b00635069a", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -661,11 +661,28 @@ pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureLis\n /// Part of `MinCaptureInformationMap`; List of `CapturePlace`s.\n pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n \n-/// A `Place` and the corresponding `CaptureInfo`.\n+/// A composite describing a `Place` that is captured by a closure.\n #[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct CapturedPlace<'tcx> {\n+    /// The `Place` that is captured.\n     pub place: HirPlace<'tcx>,\n+\n+    /// `CaptureKind` and expression(s) that resulted in such capture of `place`.\n     pub info: CaptureInfo<'tcx>,\n+\n+    /// Represents if `place` can be mutated or not.\n+    pub mutability: hir::Mutability,\n+}\n+\n+impl CapturedPlace<'tcx> {\n+    /// Returns the hir-id of the root variable for the captured place.\n+    /// e.g., if `a.b.c` was captured, would return the hir-id for `a`.\n+    pub fn get_root_variable(&self) -> hir::HirId {\n+        match self.place.base {\n+            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+            base => bug!(\"Expected upvar, found={:?}\", base),\n+        }\n+    }\n }\n \n pub fn place_to_string_for_capture(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) -> String {"}, {"sha": "04ea3cbd8b66d2fe5f823ef7e027aff15831f39d", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -215,6 +215,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             PlaceRef { local, projection: [proj_base @ .., elem] } => {\n                 match elem {\n                     ProjectionElem::Deref => {\n+                        // FIXME(project-rfc_2229#36): print capture precisely here.\n                         let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n@@ -259,6 +260,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n \n+                        // FIXME(project-rfc_2229#36): print capture precisely here.\n                         let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();"}, {"sha": "fb7694b7d88e969ce71641a8ae982d71cd1e9dc5", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -345,7 +345,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 };\n \n                 let upvar = &self.upvars[upvar_field.unwrap().index()];\n-                let upvar_hir_id = upvar.var_hir_id;\n+                // FIXME(project-rfc-2229#8): Improve borrow-check diagnostics in case of precise\n+                //                            capture.\n+                let upvar_hir_id = upvar.place.get_root_variable();\n                 let upvar_name = upvar.name;\n                 let upvar_span = self.infcx.tcx.hir().span(upvar_hir_id);\n "}, {"sha": "74abe2d35ee748814c01f83ead67999cc05d9ab6", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -64,12 +64,29 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n-                item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if self.is_upvar_field_projection(access_place.as_ref()).is_some() {\n-                    reason = \", as it is not declared as mutable\".to_string();\n+                let imm_borrow_derefed = self.upvars[upvar_index.index()]\n+                    .place\n+                    .place\n+                    .deref_tys()\n+                    .any(|ty| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Not)));\n+\n+                // If the place is immutable then:\n+                //\n+                // - Either we deref a immutable ref to get to our final place.\n+                //    - We don't capture derefs of raw ptrs\n+                // - Or the final place is immut because the root variable of the capture\n+                //   isn't marked mut and we should suggest that to the user.\n+                if imm_borrow_derefed {\n+                    // If we deref an immutable ref then the suggestion here doesn't help.\n+                    return;\n                 } else {\n-                    let name = self.upvars[upvar_index.index()].name;\n-                    reason = format!(\", as `{}` is not declared as mutable\", name);\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    if self.is_upvar_field_projection(access_place.as_ref()).is_some() {\n+                        reason = \", as it is not declared as mutable\".to_string();\n+                    } else {\n+                        let name = self.upvars[upvar_index.index()].name;\n+                        reason = format!(\", as `{}` is not declared as mutable\", name);\n+                    }\n                 }\n             }\n \n@@ -259,9 +276,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n+                let captured_place = &self.upvars[upvar_index.index()].place;\n+\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n-                let upvar_hir_id = self.upvars[upvar_index.index()].var_hir_id;\n+                let upvar_hir_id = captured_place.get_root_variable();\n+\n                 if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_hir_id) {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,"}, {"sha": "4abc623fc5f371f15a768b3958681a0861d379eb", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/var_name.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -12,7 +12,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         local_names: &IndexVec<Local, Option<Symbol>>,\n-        upvars: &[Upvar],\n+        upvars: &[Upvar<'tcx>],\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n         debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n@@ -21,6 +21,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n         self.get_upvar_index_for_region(tcx, fr)\n             .map(|index| {\n+                // FIXME(project-rfc-2229#8): Use place span for diagnostics\n                 let (name, span) = self.get_upvar_name_and_span_for_region(tcx, upvars, index);\n                 (Some(name), span)\n             })\n@@ -59,10 +60,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn get_upvar_name_and_span_for_region(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        upvars: &[Upvar],\n+        upvars: &[Upvar<'tcx>],\n         upvar_index: usize,\n     ) -> (Symbol, Span) {\n-        let upvar_hir_id = upvars[upvar_index].var_hir_id;\n+        let upvar_hir_id = upvars[upvar_index].place.get_root_variable();\n         debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={:?}\", upvar_hir_id);\n \n         let upvar_name = tcx.hir().name(upvar_hir_id);"}, {"sha": "5db52db70ac685c33cf43c8d249a66510b5ddaf0", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -5,11 +5,10 @@ use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::{HirId, Node};\n+use rustc_hir::Node;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n-use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, Operand, Place, PlaceElem,\n     PlaceRef, VarDebugInfoContents,\n@@ -18,7 +17,7 @@ use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind\n use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, ParamEnv, RegionVid, TyCtxt};\n+use rustc_middle::ty::{self, CapturedPlace, ParamEnv, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT, UNUSED_MUT};\n use rustc_span::{Span, Symbol, DUMMY_SP};\n \n@@ -73,16 +72,14 @@ crate use region_infer::RegionInferenceContext;\n \n // FIXME(eddyb) perhaps move this somewhere more centrally.\n #[derive(Debug)]\n-crate struct Upvar {\n+crate struct Upvar<'tcx> {\n+    // FIXME(project-rfc_2229#36): print capture precisely here.\n     name: Symbol,\n \n-    // FIXME(project-rfc-2229#8): This should use Place or something similar\n-    var_hir_id: HirId,\n+    place: CapturedPlace<'tcx>,\n \n     /// If true, the capture is behind a reference.\n     by_ref: bool,\n-\n-    mutability: Mutability,\n }\n \n const DEREF_PROJECTION: &[PlaceElem<'_>; 1] = &[ProjectionElem::Deref];\n@@ -161,26 +158,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let upvars: Vec<_> = tables\n         .closure_min_captures_flattened(def.did.to_def_id())\n         .map(|captured_place| {\n-            let var_hir_id = match captured_place.place.base {\n-                HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-                _ => bug!(\"Expected upvar\"),\n-            };\n+            let var_hir_id = captured_place.get_root_variable();\n             let capture = captured_place.info.capture_kind;\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue(_) => false,\n                 ty::UpvarCapture::ByRef(..) => true,\n             };\n-            let mut upvar = Upvar {\n-                name: tcx.hir().name(var_hir_id),\n-                var_hir_id,\n-                by_ref,\n-                mutability: Mutability::Not,\n-            };\n-            let bm = *tables.pat_binding_modes().get(var_hir_id).expect(\"missing binding mode\");\n-            if bm == ty::BindByValue(hir::Mutability::Mut) {\n-                upvar.mutability = Mutability::Mut;\n-            }\n-            upvar\n+            Upvar { name: tcx.hir().name(var_hir_id), place: captured_place.clone(), by_ref }\n         })\n         .collect();\n \n@@ -549,7 +533,7 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     dominators: Dominators<BasicBlock>,\n \n     /// Information about upvars not necessarily preserved in types or MIR\n-    upvars: Vec<Upvar>,\n+    upvars: Vec<Upvar<'tcx>>,\n \n     /// Names of local (user) variables (extracted from `var_debug_info`).\n     local_names: IndexVec<Local, Option<Symbol>>,\n@@ -1374,13 +1358,38 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn propagate_closure_used_mut_upvar(&mut self, operand: &Operand<'tcx>) {\n         let propagate_closure_used_mut_place = |this: &mut Self, place: Place<'tcx>| {\n-            if !place.projection.is_empty() {\n-                if let Some(field) = this.is_upvar_field_projection(place.as_ref()) {\n+            // We have three possibilities here:\n+            // a. We are modifying something through a mut-ref\n+            // b. We are modifying something that is local to our parent\n+            // c. Current body is a nested closure, and we are modifying path starting from\n+            //    a Place captured by our parent closure.\n+\n+            // Handle (c), the path being modified is exactly the path captured by our parent\n+            if let Some(field) = this.is_upvar_field_projection(place.as_ref()) {\n+                this.used_mut_upvars.push(field);\n+                return;\n+            }\n+\n+            for (place_ref, proj) in place.iter_projections().rev() {\n+                // Handle (a)\n+                if proj == ProjectionElem::Deref {\n+                    match place_ref.ty(this.body(), this.infcx.tcx).ty.kind() {\n+                        // We aren't modifying a variable directly\n+                        ty::Ref(_, _, hir::Mutability::Mut) => return,\n+\n+                        _ => {}\n+                    }\n+                }\n+\n+                // Handle (c)\n+                if let Some(field) = this.is_upvar_field_projection(place_ref) {\n                     this.used_mut_upvars.push(field);\n+                    return;\n                 }\n-            } else {\n-                this.used_mut.insert(place.local);\n             }\n+\n+            // Handle(b)\n+            this.used_mut.insert(place.local);\n         };\n \n         // This relies on the current way that by-value\n@@ -2146,6 +2155,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         place: PlaceRef<'tcx>,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) -> Result<RootPlace<'tcx>, PlaceRef<'tcx>> {\n+        debug!(\"is_mutable: place={:?}, is_local...={:?}\", place, is_local_mutation_allowed);\n         match place.last_projection() {\n             None => {\n                 let local = &self.body.local_decls[place.local];\n@@ -2227,11 +2237,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         if let Some(field) = upvar_field_projection {\n                             let upvar = &self.upvars[field.index()];\n                             debug!(\n-                                \"upvar.mutability={:?} local_mutation_is_allowed={:?} \\\n-                                 place={:?}\",\n-                                upvar, is_local_mutation_allowed, place\n+                                \"is_mutable: upvar.mutability={:?} local_mutation_is_allowed={:?} \\\n+                                 place={:?}, place_base={:?}\",\n+                                upvar, is_local_mutation_allowed, place, place_base\n                             );\n-                            match (upvar.mutability, is_local_mutation_allowed) {\n+                            match (upvar.place.mutability, is_local_mutation_allowed) {\n                                 (\n                                     Mutability::Not,\n                                     LocalMutationIsAllowed::No"}, {"sha": "a0265b20d127bd268d90baa60e0edcaabb917054", "filename": "compiler/rustc_mir/src/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -165,7 +165,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     flow_inits: &mut ResultsCursor<'cx, 'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n-    upvars: &[Upvar],\n+    upvars: &[Upvar<'tcx>],\n ) -> NllOutput<'tcx> {\n     let mut all_facts = AllFacts::enabled(infcx.tcx).then_some(AllFacts::default());\n "}, {"sha": "80de3b4e363bfb369a40b701ff9cf944e43df84a", "filename": "compiler/rustc_mir/src/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fpath_utils.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -143,7 +143,7 @@ pub(super) fn borrow_of_local_data(place: Place<'_>) -> bool {\n /// of a closure type.\n pub(crate) fn is_upvar_field_projection(\n     tcx: TyCtxt<'tcx>,\n-    upvars: &[Upvar],\n+    upvars: &[Upvar<'tcx>],\n     place_ref: PlaceRef<'tcx>,\n     body: &Body<'tcx>,\n ) -> Option<Field> {"}, {"sha": "24bbd2b8c49c17723d1f9aed5f6c474125e706d3", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -132,7 +132,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n-    upvars: &[Upvar],\n+    upvars: &[Upvar<'tcx>],\n ) -> MirTypeckResults<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n@@ -821,7 +821,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n     all_facts: &'a mut Option<AllFacts>,\n     borrow_set: &'a BorrowSet<'tcx>,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n-    upvars: &'a [Upvar],\n+    upvars: &'a [Upvar<'tcx>],\n }\n \n crate struct MirTypeckResults<'tcx> {\n@@ -2490,7 +2490,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             body,\n         );\n         let category = if let Some(field) = field {\n-            ConstraintCategory::ClosureUpvar(self.borrowck_context.upvars[field.index()].var_hir_id)\n+            let var_hir_id = self.borrowck_context.upvars[field.index()].place.get_root_variable();\n+            // FIXME(project-rfc-2229#8): Use Place for better diagnostics\n+            ConstraintCategory::ClosureUpvar(var_hir_id)\n         } else {\n             ConstraintCategory::Boring\n         };"}, {"sha": "e4891eb5a3c0cc1305fbd1203bc41a8cc154632b", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -851,22 +851,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         _ => bug!(\"Expected an upvar\")\n                     };\n \n-                    let mut mutability = Mutability::Not;\n+                    let mutability = captured_place.mutability;\n \n                     // FIXME(project-rfc-2229#8): Store more precise information\n                     let mut name = kw::Empty;\n                     if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n                         if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                             name = ident.name;\n-                            match hir_typeck_results\n-                                .extract_binding_mode(tcx.sess, pat.hir_id, pat.span)\n-                            {\n-                                Some(ty::BindByValue(hir::Mutability::Mut)) => {\n-                                    mutability = Mutability::Mut;\n-                                }\n-                                Some(_) => mutability = Mutability::Not,\n-                                _ => {}\n-                            }\n                         }\n                     }\n "}, {"sha": "f039445bf7780b60304289e25c0e24537ddd7b01", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 114, "deletions": 17, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -184,10 +184,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let origin = if self.tcx.features().capture_disjoint_fields {\n                     origin\n                 } else {\n-                    // FIXME(project-rfc-2229#26): Once rust-lang#80092 is merged, we should restrict the\n-                    // precision of origin as well. Otherwise, this will cause issues when project-rfc-2229#26\n-                    // is fixed as we might see Index projections in the origin, which we can't print because\n-                    // we don't store enough information.\n+                    // FIXME(project-rfc-2229#31): Once the changes to support reborrowing are\n+                    //                             made, make sure we are selecting and restricting\n+                    //                             the origin correctly.\n                     (origin.0, Place { projections: vec![], ..origin.1 })\n                 };\n \n@@ -252,8 +251,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let capture = captured_place.info.capture_kind;\n \n                 debug!(\n-                    \"place={:?} upvar_ty={:?} capture={:?}\",\n-                    captured_place.place, upvar_ty, capture\n+                    \"final_upvar_tys: place={:?} upvar_ty={:?} capture={:?}, mutability={:?}\",\n+                    captured_place.place, upvar_ty, capture, captured_place.mutability,\n                 );\n \n                 match capture {\n@@ -419,19 +418,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            // Arrays are captured in entirety, drop Index projections and projections\n-            // after Index projections.\n-            let first_index_projection =\n-                place.projections.split(|proj| ProjectionKind::Index == proj.kind).next();\n-            let place = Place {\n-                base_ty: place.base_ty,\n-                base: place.base,\n-                projections: first_index_projection.map_or(Vec::new(), |p| p.to_vec()),\n-            };\n+            let place = restrict_capture_precision(place, capture_info.capture_kind);\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n-                    let min_cap_list = vec![ty::CapturedPlace { place, info: capture_info }];\n+                    let mutability = self.determine_capture_mutability(&place);\n+                    let min_cap_list =\n+                        vec![ty::CapturedPlace { place, info: capture_info, mutability }];\n                     root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n                     continue;\n                 }\n@@ -494,8 +487,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Only need to insert when we don't have an ancestor in the existing min capture list\n             if !ancestor_found {\n+                let mutability = self.determine_capture_mutability(&place);\n                 let captured_place =\n-                    ty::CapturedPlace { place: place.clone(), info: updated_capture_info };\n+                    ty::CapturedPlace { place, info: updated_capture_info, mutability };\n                 min_cap_list.push(captured_place);\n             }\n         }\n@@ -615,6 +609,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    /// A captured place is mutable if\n+    /// 1. Projections don't include a Deref of an immut-borrow, **and**\n+    /// 2. PlaceBase is mut or projections include a Deref of a mut-borrow.\n+    fn determine_capture_mutability(&self, place: &Place<'tcx>) -> hir::Mutability {\n+        let var_hir_id = match place.base {\n+            PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+            _ => unreachable!(),\n+        };\n+\n+        let bm = *self\n+            .typeck_results\n+            .borrow()\n+            .pat_binding_modes()\n+            .get(var_hir_id)\n+            .expect(\"missing binding mode\");\n+\n+        let mut is_mutbl = match bm {\n+            ty::BindByValue(mutability) => mutability,\n+            ty::BindByReference(_) => hir::Mutability::Not,\n+        };\n+\n+        for pointer_ty in place.deref_tys() {\n+            match pointer_ty.kind() {\n+                // We don't capture derefs of raw ptrs\n+                ty::RawPtr(_) => unreachable!(),\n+\n+                // Derefencing a mut-ref allows us to mut the Place if we don't deref\n+                // an immut-ref after on top of this.\n+                ty::Ref(.., hir::Mutability::Mut) => is_mutbl = hir::Mutability::Mut,\n+\n+                // The place isn't mutable once we dereference a immutable reference.\n+                ty::Ref(.., hir::Mutability::Not) => return hir::Mutability::Not,\n+\n+                // Dereferencing a box doesn't change mutability\n+                ty::Adt(def, ..) if def.is_box() => {}\n+\n+                unexpected_ty => bug!(\"deref of unexpected pointer type {:?}\", unexpected_ty),\n+            }\n+        }\n+\n+        is_mutbl\n+    }\n }\n \n struct InferBorrowKind<'a, 'tcx> {\n@@ -960,6 +997,66 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     }\n }\n \n+/// Truncate projections so that following rules are obeyed by the captured `place`:\n+///\n+/// - No Derefs in move closure, this will result in value behind a reference getting moved.\n+/// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n+///   them completely.\n+/// - No Index projections are captured, since arrays are captured completely.\n+fn restrict_capture_precision<'tcx>(\n+    mut place: Place<'tcx>,\n+    capture_kind: ty::UpvarCapture<'tcx>,\n+) -> Place<'tcx> {\n+    if place.projections.is_empty() {\n+        // Nothing to do here\n+        return place;\n+    }\n+\n+    if place.base_ty.is_unsafe_ptr() {\n+        place.projections.truncate(0);\n+        return place;\n+    }\n+\n+    let mut truncated_length = usize::MAX;\n+    let mut first_deref_projection = usize::MAX;\n+\n+    for (i, proj) in place.projections.iter().enumerate() {\n+        if proj.ty.is_unsafe_ptr() {\n+            // Don't apply any projections on top of an unsafe ptr\n+            truncated_length = truncated_length.min(i + 1);\n+            break;\n+        }\n+        match proj.kind {\n+            ProjectionKind::Index => {\n+                // Arrays are completely captured, so we drop Index projections\n+                truncated_length = truncated_length.min(i);\n+                break;\n+            }\n+            ProjectionKind::Deref => {\n+                // We only drop Derefs in case of move closures\n+                // There might be an index projection or raw ptr ahead, so we don't stop here.\n+                first_deref_projection = first_deref_projection.min(i);\n+            }\n+            ProjectionKind::Field(..) => {} // ignore\n+            ProjectionKind::Subslice => {}  // We never capture this\n+        }\n+    }\n+\n+    let length = place\n+        .projections\n+        .len()\n+        .min(truncated_length)\n+        // In case of capture `ByValue` we want to not capture derefs\n+        .min(match capture_kind {\n+            ty::UpvarCapture::ByValue(..) => first_deref_projection,\n+            ty::UpvarCapture::ByRef(..) => usize::MAX,\n+        });\n+\n+    place.projections.truncate(length);\n+\n+    place\n+}\n+\n fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n     let variable_name = match place.base {\n         PlaceBase::Upvar(upvar_id) => var_name(tcx, upvar_id.var_path.hir_id).to_string(),"}, {"sha": "1007fb582e5eda6e68f00f04f22fadd569b233fb", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,41 @@\n+// Test that we handle derferences properly when only some of the captures are being moved with\n+// `capture_disjoint_fields` enabled.\n+\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug, Default)]\n+struct SomeLargeType;\n+struct MuchLargerType([SomeLargeType; 32]);\n+\n+// Ensure that we don't capture any derefs when moving captures into the closures,\n+// i.e. only data from the enclosing stack is moved.\n+fn big_box() {\n+    let s = MuchLargerType(Default::default());\n+    let b = Box::new(s);\n+    let t = (b, 10);\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        let p = t.0.0;\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n+        println!(\"{} {:?}\", t.1, p);\n+        //~^ NOTE: Capturing t[(1, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture t[(1, 0)] -> ImmBorrow\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    big_box();\n+}"}, {"sha": "fe04dbef6d8b55a56637bef5c78057e2981ebab1", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,67 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/by_value.rs:22:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/by_value.rs:5:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/by_value.rs:25:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let p = t.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+  --> $DIR/by_value.rs:28:17\n+   |\n+LL |         let p = t.0.0;\n+   |                 ^^^^^\n+note: Capturing t[(1, 0)] -> ImmBorrow\n+  --> $DIR/by_value.rs:31:29\n+   |\n+LL |         println!(\"{} {:?}\", t.1, p);\n+   |                             ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/by_value.rs:25:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let p = t.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0)] -> ByValue\n+  --> $DIR/by_value.rs:28:17\n+   |\n+LL |         let p = t.0.0;\n+   |                 ^^^^^\n+note: Min Capture t[(1, 0)] -> ImmBorrow\n+  --> $DIR/by_value.rs:31:29\n+   |\n+LL |         println!(\"{} {:?}\", t.1, p);\n+   |                             ^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "1ea38e260b645d91d6ed09da639fbe57fbafa4e0", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/cant-mutate-imm-borrow.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,20 @@\n+// Test that if we deref an immutable borrow to access a Place,\n+// then we can't mutate the final place.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+fn main() {\n+    let mut x = (format!(\"\"), format!(\"X2\"));\n+    let mut y = (&x, \"Y\");\n+    let z = (&mut y, \"Z\");\n+\n+    // `x.0` is mutable but we access `x` via `z.0.0`, which is an immutable reference and\n+    // therefore can't be mutated.\n+    let mut c = || {\n+    //~^ ERROR: cannot borrow `z.0.0.0` as mutable, as it is behind a `&` reference\n+        z.0.0.0 = format!(\"X1\");\n+    };\n+\n+    c();\n+}"}, {"sha": "861bc44b78ded3a7c08c554d2796ec5e6546ee0c", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/cant-mutate-imm-borrow.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.stderr?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,21 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/cant-mutate-imm-borrow.rs:4:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0596]: cannot borrow `z.0.0.0` as mutable, as it is behind a `&` reference\n+  --> $DIR/cant-mutate-imm-borrow.rs:14:17\n+   |\n+LL |     let mut c = || {\n+   |                 ^^ cannot borrow as mutable\n+LL |\n+LL |         z.0.0.0 = format!(\"X1\");\n+   |         - mutable borrow occurs due to use of `z.0.0.0` in closure\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "997ecc7ddddf1eb33048f08f50c2a8c48aa28205", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/cant-mutate-imm.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,35 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+// Ensure that diagnostics for mutability error (because the root variable\n+// isn't mutable) work with `capture_disjoint_fields` enabled.\n+\n+fn mut_error_struct() {\n+    let x = (10, 10);\n+    let y = (x, 10);\n+    let z = (y, 10);\n+\n+    let mut c = || {\n+        z.0.0.0 = 20;\n+        //~^ ERROR: cannot assign to `z`, as it is not declared as mutable\n+    };\n+\n+    c();\n+}\n+\n+fn mut_error_box() {\n+    let x = (10, 10);\n+    let bx = Box::new(x);\n+\n+    let mut c = || {\n+        bx.0 = 20;\n+        //~^ ERROR: cannot assign to `bx`, as it is not declared as mutable\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    mut_error_struct();\n+    mut_error_box();\n+}"}, {"sha": "5e15635ac6e1bf38f7c651c31aa06fd406e2e742", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/cant-mutate-imm.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.stderr?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,30 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/cant-mutate-imm.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0594]: cannot assign to `z`, as it is not declared as mutable\n+  --> $DIR/cant-mutate-imm.rs:13:9\n+   |\n+LL |     let z = (y, 10);\n+   |         - help: consider changing this to be mutable: `mut z`\n+...\n+LL |         z.0.0.0 = 20;\n+   |         ^^^^^^^^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `bx`, as it is not declared as mutable\n+  --> $DIR/cant-mutate-imm.rs:25:9\n+   |\n+LL |     let bx = Box::new(x);\n+   |         -- help: consider changing this to be mutable: `mut bx`\n+...\n+LL |         bx.0 = 20;\n+   |         ^^^^^^^^^ cannot assign\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "676fde558dfbc684d81a732cef204de7effe072b", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/mut_ref.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,38 @@\n+// Test that we can't mutate a place if we need to deref an imm-borrow\n+// to reach it.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+fn imm_mut_ref() {\n+    let mut x = String::new();\n+    let y = String::new();\n+    let mref_x = &mut x;\n+    let ref_mref_x = &mref_x;\n+\n+    let c = || {\n+    //~^ ERROR: cannot borrow `**ref_mref_x` as mutable, as it is behind a `&` reference\n+        **ref_mref_x = y;\n+    };\n+\n+    c();\n+}\n+\n+fn mut_imm_ref() {\n+    let x = String::new();\n+    let y = String::new();\n+    let mut ref_x = &x;\n+    let mref_ref_x = &mut ref_x;\n+\n+    let c = || {\n+    //~^ ERROR: cannot borrow `**mref_ref_x` as mutable, as it is behind a `&` reference\n+        **mref_ref_x = y;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    imm_mut_ref();\n+    mut_imm_ref();\n+}"}, {"sha": "8cb2ed2235d55395f2945d8e58b338e0c42226b1", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/mut_ref.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,33 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/mut_ref.rs:4:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0596]: cannot borrow `**ref_mref_x` as mutable, as it is behind a `&` reference\n+  --> $DIR/mut_ref.rs:13:13\n+   |\n+LL |     let ref_mref_x = &mref_x;\n+   |                      ------- help: consider changing this to be a mutable reference: `&mut mref_x`\n+LL | \n+LL |     let c = || {\n+   |             ^^ `ref_mref_x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n+LL |\n+LL |         **ref_mref_x = y;\n+   |           ---------- mutable borrow occurs due to use of `**ref_mref_x` in closure\n+\n+error[E0596]: cannot borrow `**mref_ref_x` as mutable, as it is behind a `&` reference\n+  --> $DIR/mut_ref.rs:27:13\n+   |\n+LL |     let c = || {\n+   |             ^^ cannot borrow as mutable\n+LL |\n+LL |         **mref_ref_x = y;\n+   |           ---------- mutable borrow occurs due to use of `**mref_ref_x` in closure\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "8bdc999ca3c3feade9f49922806945d452e0e01a", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,72 @@\n+// Test that move closures drop derefs with `capture_disjoint_fields` enabled.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+// Test we truncate derefs properly\n+fn simple_ref() {\n+    let mut s = 10;\n+    let ref_s = &mut s;\n+\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        *ref_s += 10;\n+        //~^ NOTE: Capturing ref_s[Deref] -> ByValue\n+        //~| NOTE: Min Capture ref_s[] -> ByValue\n+    };\n+    c();\n+}\n+\n+// Test we truncate derefs properly\n+fn struct_contains_ref_to_another_struct() {\n+    struct S(String);\n+    struct T<'a>(&'a mut S);\n+\n+    let mut s = S(\"s\".into());\n+    let t = T(&mut s);\n+\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        t.0.0 = \"new s\".into();\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n+    };\n+\n+    c();\n+}\n+\n+// Test that we don't reduce precision when there is nothing deref.\n+fn no_ref() {\n+    struct S(String);\n+    struct T(S);\n+\n+    let t = T(S(\"s\".into()));\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        t.0.0 = \"new S\".into();\n+        //~^ NOTE: Capturing t[(0, 0),(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0),(0, 0)] -> ByValue\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    simple_ref();\n+    struct_contains_ref_to_another_struct();\n+    no_ref();\n+}"}, {"sha": "a745f14598ee2b022f10352b34f729970e223745", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.stderr", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,147 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:14:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:35:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:55:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/move_closure.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:17:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         *ref_s += 10;\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing ref_s[Deref] -> ByValue\n+  --> $DIR/move_closure.rs:20:9\n+   |\n+LL |         *ref_s += 10;\n+   |         ^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:17:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         *ref_s += 10;\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture ref_s[] -> ByValue\n+  --> $DIR/move_closure.rs:20:9\n+   |\n+LL |         *ref_s += 10;\n+   |         ^^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:38:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         t.0.0 = \"new s\".into();\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:41:9\n+   |\n+LL |         t.0.0 = \"new s\".into();\n+   |         ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:38:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         t.0.0 = \"new s\".into();\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:41:9\n+   |\n+LL |         t.0.0 = \"new s\".into();\n+   |         ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:58:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         t.0.0 = \"new S\".into();\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:61:9\n+   |\n+LL |         t.0.0 = \"new S\".into();\n+   |         ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:58:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         t.0.0 = \"new S\".into();\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0),(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:61:9\n+   |\n+LL |         t.0.0 = \"new S\".into();\n+   |         ^^^^^\n+\n+error: aborting due to 9 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "9a93e6cf1e1efd787734c446d3f9105281838ea6", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/by_value.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,28 @@\n+// run-pass\n+\n+// Test that ByValue captures compile sucessefully especially when the captures are\n+// derefenced within the closure.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+#[derive(Debug, Default)]\n+struct SomeLargeType;\n+struct MuchLargerType([SomeLargeType; 32]);\n+\n+fn big_box() {\n+    let s = MuchLargerType(Default::default());\n+    let b = Box::new(s);\n+    let t = (b, 10);\n+\n+    let c = || {\n+        let p = t.0.0;\n+        println!(\"{} {:?}\", t.1, p);\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    big_box();\n+}"}, {"sha": "98715c6b9436589e991cef711ef2a847ad29cde3", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/by_value.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.stderr?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/by_value.rs:6:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "4007a5a48aaecb4d94efedec5dc465996653a36c", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/move_closure.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,64 @@\n+// run-pass\n+\n+// Test that move closures compile properly with `capture_disjoint_fields` enabled.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+fn simple_ref() {\n+    let mut s = 10;\n+    let ref_s = &mut s;\n+\n+    let mut c = move || {\n+        *ref_s += 10;\n+    };\n+    c();\n+}\n+\n+fn struct_contains_ref_to_another_struct() {\n+    struct S(String);\n+    struct T<'a>(&'a mut S);\n+\n+    let mut s = S(\"s\".into());\n+    let t = T(&mut s);\n+\n+    let mut c = move || {\n+        t.0.0 = \"new s\".into();\n+    };\n+\n+    c();\n+}\n+\n+#[derive(Debug)]\n+struct S(String);\n+\n+#[derive(Debug)]\n+struct T(S);\n+\n+fn no_ref() {\n+    let mut t = T(S(\"s\".into()));\n+    let mut c = move || {\n+        t.0.0 = \"new S\".into();\n+    };\n+    c();\n+}\n+\n+fn no_ref_nested() {\n+    let mut t = T(S(\"s\".into()));\n+    let c = || {\n+        println!(\"{:?}\", t.0);\n+        let mut c = move || {\n+            t.0.0 = \"new S\".into();\n+            println!(\"{:?}\", t.0.0);\n+        };\n+        c();\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    simple_ref();\n+    struct_contains_ref_to_another_struct();\n+    no_ref();\n+    no_ref_nested();\n+}"}, {"sha": "c1d8ba575d6fd0bcbf428d25ac4f6525a55c7683", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/move_closure.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.stderr?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/move_closure.rs:5:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "315622443c3cc83da55341277c9cf7a3e66ff6cc", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/mut_ref.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,56 @@\n+// run-pass\n+\n+// Test that we can mutate a place through a mut-borrow\n+// that is captured by the closure\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+// Check that we can mutate when one deref is required\n+fn mut_ref_1() {\n+    let mut x = String::new();\n+    let rx = &mut x;\n+\n+    let mut c = || {\n+        *rx = String::new();\n+    };\n+\n+    c();\n+}\n+\n+// Similar example as mut_ref_1, we don't deref the imm-borrow here,\n+// and so we are allowed to mutate.\n+fn mut_ref_2() {\n+    let x = String::new();\n+    let y = String::new();\n+    let mut ref_x = &x;\n+    let m_ref_x = &mut ref_x;\n+\n+    let mut c = || {\n+        *m_ref_x = &y;\n+    };\n+\n+    c();\n+}\n+\n+// Check that we can mutate when multiple derefs of mut-borrows are required to reach\n+// the target place.\n+// It works because all derefs are mutable, if either of them was an immutable\n+// borrow, then we would not be able to deref.\n+fn mut_mut_ref() {\n+    let mut x = String::new();\n+    let mut mref_x = &mut x;\n+    let m_mref_x = &mut mref_x;\n+\n+    let mut c = || {\n+        **m_mref_x = String::new();\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    mut_ref_1();\n+    mut_ref_2();\n+    mut_mut_ref();\n+}"}, {"sha": "4b37a0b405f5e0a485a8b9c7cfbdaa756e07ce5f", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/mut_ref.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.stderr?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/mut_ref.rs:6:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "2dba923647a2e6f4044a08ad8f467af054e77b98", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/mut_ref_struct_mem.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,45 @@\n+// run-pass\n+\n+// Test that we can mutate a place through a mut-borrow\n+// that is captured by the closure\n+\n+// More specifically we test that the if the mutable reference isn't root variable of a capture\n+// but rather accessed while acessing the precise capture.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+fn mut_tuple() {\n+    let mut t = (10, 10);\n+\n+    let t1 = (&mut t, 10);\n+\n+    let mut c = || {\n+        // Mutable because (*t.0) is mutable\n+        t1.0.0 += 10;\n+    };\n+\n+    c();\n+}\n+\n+fn mut_tuple_nested() {\n+    let mut t = (10, 10);\n+\n+    let t1 = (&mut t, 10);\n+\n+    let mut c = || {\n+        let mut c = || {\n+            // Mutable because (*t.0) is mutable\n+            t1.0.0 += 10;\n+        };\n+\n+        c();\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    mut_tuple();\n+    mut_tuple_nested();\n+}"}, {"sha": "418ab29098b2a59b89bcf8727446b40cdcb0059b", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/mut_ref_struct_mem.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.stderr?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/mut_ref_struct_mem.rs:9:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "f6e9862b26c11d7fafb2af139c1b1534e1d42444", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/unsafe_ptr.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,47 @@\n+// run-pass\n+\n+// Test that we can use raw ptrs when using `capture_disjoint_fields`.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+#[derive(Debug)]\n+struct S {\n+    s: String,\n+    t: String,\n+}\n+\n+struct T(*const S);\n+\n+fn unsafe_imm() {\n+    let s = \"\".into();\n+    let t = \"\".into();\n+    let my_speed: Box<S> = Box::new(S { s, t });\n+\n+    let p : *const S = Box::into_raw(my_speed);\n+    let t = T(p);\n+\n+    let c = || unsafe {\n+        println!(\"{:?}\", (*t.0).s);\n+    };\n+\n+    c();\n+}\n+\n+fn unsafe_mut() {\n+    let s = \"\".into();\n+    let t = \"\".into();\n+    let mut my_speed: Box<S> = Box::new(S { s, t });\n+    let p : *mut S = &mut *my_speed;\n+\n+    let c = || {\n+        let x = unsafe { &mut (*p).s };\n+        *x = \"s\".into();\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    unsafe_mut();\n+    unsafe_imm();\n+}"}, {"sha": "c64c8b72e81512fc16d10467ca233e7c7fd5c8fe", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/unsafe_ptr.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.stderr?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/unsafe_ptr.rs:5:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "79d3ecc2d2bedfeefa1e5469a8a683f100be1167", "filename": "src/test/ui/closures/2229_closure_analysis/unsafe_ptr.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.rs?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,63 @@\n+// Test that we restrict precision of a capture when we access a raw ptr,\n+// i.e. the capture doesn't deref the raw ptr.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct S {\n+    s: String,\n+    t: String,\n+}\n+\n+struct T(*const S);\n+\n+fn unsafe_imm() {\n+    let s = \"\".into();\n+    let t = \"\".into();\n+    let my_speed: Box<S> = Box::new(S { s, t });\n+\n+    let p : *const S = Box::into_raw(my_speed);\n+    let t = T(p);\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+     || unsafe {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        println!(\"{:?}\", (*t.0).s);\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture t[(0, 0)] -> ImmBorrow\n+    };\n+\n+    c();\n+}\n+\n+fn unsafe_mut() {\n+    let s = \"\".into();\n+    let t = \"\".into();\n+    let mut my_speed: Box<S> = Box::new(S { s, t });\n+    let p : *mut S = &mut *my_speed;\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let x = unsafe { &mut (*p).s };\n+        //~^ NOTE: Capturing p[Deref,(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> ImmBorrow\n+        *x = \"s\".into();\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    unsafe_mut();\n+    unsafe_imm();\n+}"}, {"sha": "4508b2426e8ff8d29596dd496fa882663848f9c8", "filename": "src/test/ui/closures/2229_closure_analysis/unsafe_ptr.stderr", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.stderr?ref=7e3a8ec6888a04a4ebc248f6178ae02b48dea3b6", "patch": "@@ -0,0 +1,102 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/unsafe_ptr.rs:26:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/unsafe_ptr.rs:46:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/unsafe_ptr.rs:4:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/unsafe_ptr.rs:29:6\n+   |\n+LL | /      || unsafe {\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?}\", (*t.0).s);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/unsafe_ptr.rs:32:26\n+   |\n+LL |         println!(\"{:?}\", (*t.0).s);\n+   |                          ^^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/unsafe_ptr.rs:29:6\n+   |\n+LL | /      || unsafe {\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?}\", (*t.0).s);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0)] -> ImmBorrow\n+  --> $DIR/unsafe_ptr.rs:32:26\n+   |\n+LL |         println!(\"{:?}\", (*t.0).s);\n+   |                          ^^^^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/unsafe_ptr.rs:49:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = unsafe { &mut (*p).s };\n+...  |\n+LL | |         *x = \"s\".into();\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/unsafe_ptr.rs:52:31\n+   |\n+LL |         let x = unsafe { &mut (*p).s };\n+   |                               ^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/unsafe_ptr.rs:49:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = unsafe { &mut (*p).s };\n+...  |\n+LL | |         *x = \"s\".into();\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> ImmBorrow\n+  --> $DIR/unsafe_ptr.rs:52:31\n+   |\n+LL |         let x = unsafe { &mut (*p).s };\n+   |                               ^^^^^^\n+\n+error: aborting due to 6 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}]}