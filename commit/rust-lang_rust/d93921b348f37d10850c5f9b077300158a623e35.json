{"sha": "d93921b348f37d10850c5f9b077300158a623e35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MzkyMWIzNDhmMzdkMTA4NTBjNWY5YjA3NzMwMDE1OGE2MjNlMzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-16T11:33:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-17T19:25:11Z"}, "message": "Port a simplified versions of pcwalton's \"quick reject\" mechanism for quickly throwing out method candidates. Yields a 40%-50% improvement in typechecking time as well as lowering peak memory use from 2.2GB to 1.8GB (due to creating fewer types).\n\nConflicts:\n\tsrc/librustc/driver/config.rs\n\tsrc/librustc/middle/ty.rs\n\tsrc/librustc/middle/typeck/check/method.rs\n\tsrc/librustc/middle/typeck/check/mod.rs\n\tsrc/librustc/middle/typeck/coherence/mod.rs", "tree": {"sha": "c0de81615a14a381af9e9ef4f55f0a50caae7ff1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0de81615a14a381af9e9ef4f55f0a50caae7ff1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d93921b348f37d10850c5f9b077300158a623e35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d93921b348f37d10850c5f9b077300158a623e35", "html_url": "https://github.com/rust-lang/rust/commit/d93921b348f37d10850c5f9b077300158a623e35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d93921b348f37d10850c5f9b077300158a623e35/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ed0a4633b69793ae9ea42fdf617a4df66a746cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ed0a4633b69793ae9ea42fdf617a4df66a746cf", "html_url": "https://github.com/rust-lang/rust/commit/0ed0a4633b69793ae9ea42fdf617a4df66a746cf"}], "stats": {"total": 153, "additions": 148, "deletions": 5}, "files": [{"sha": "c9a1d47f55856e18b94f9541b987fe245c9bf008", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d93921b348f37d10850c5f9b077300158a623e35/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d93921b348f37d10850c5f9b077300158a623e35/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d93921b348f37d10850c5f9b077300158a623e35", "patch": "@@ -87,6 +87,7 @@ pub mod middle {\n     pub mod effect;\n     pub mod entry;\n     pub mod expr_use_visitor;\n+    pub mod fast_reject;\n     pub mod graph;\n     pub mod intrinsicck;\n     pub mod lang_items;"}, {"sha": "915f12cd3936fe7a7f0953251c44ba781db82ee0", "filename": "src/librustc/middle/fast_reject.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/d93921b348f37d10850c5f9b077300158a623e35/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d93921b348f37d10850c5f9b077300158a623e35/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=d93921b348f37d10850c5f9b077300158a623e35", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty;\n+use syntax::ast;\n+\n+/** See `simplify_type */\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n+pub enum SimplifiedType {\n+    BoolSimplifiedType,\n+    CharSimplifiedType,\n+    IntSimplifiedType(ast::IntTy),\n+    UintSimplifiedType(ast::UintTy),\n+    FloatSimplifiedType(ast::FloatTy),\n+    EnumSimplifiedType(ast::DefId),\n+    StrSimplifiedType,\n+    VecSimplifiedType,\n+    PtrSimplifiedType,\n+    TupleSimplifiedType(uint),\n+    TraitSimplifiedType(ast::DefId),\n+    StructSimplifiedType(ast::DefId),\n+    UnboxedClosureSimplifiedType(ast::DefId),\n+    FunctionSimplifiedType(uint),\n+    ParameterSimplifiedType,\n+}\n+\n+pub fn simplify_type(tcx: &ty::ctxt,\n+                     ty: ty::t,\n+                     can_simplify_params: bool)\n+                     -> Option<SimplifiedType>\n+{\n+    /*!\n+     * Tries to simplify a type by dropping type parameters, deref'ing\n+     * away any reference types, etc. The idea is to get something\n+     * simple that we can use to quickly decide if two types could\n+     * unify during method lookup.\n+     *\n+     * If `can_simplify_params` is false, then we will fail to\n+     * simplify type parameters entirely. This is useful when those\n+     * type parameters would be instantiated with fresh type\n+     * variables, since then we can't say much about whether two types\n+     * would unify. Put another way, `can_simplify_params` should be\n+     * true if type parameters appear free in `ty` and `false` if they\n+     * are to be considered bound.\n+     */\n+\n+    match ty::get(ty).sty {\n+        ty::ty_bool => Some(BoolSimplifiedType),\n+        ty::ty_char => Some(CharSimplifiedType),\n+        ty::ty_int(int_type) => Some(IntSimplifiedType(int_type)),\n+        ty::ty_uint(uint_type) => Some(UintSimplifiedType(uint_type)),\n+        ty::ty_float(float_type) => Some(FloatSimplifiedType(float_type)),\n+        ty::ty_enum(def_id, _) => Some(EnumSimplifiedType(def_id)),\n+        ty::ty_str => Some(StrSimplifiedType),\n+        ty::ty_vec(..) => Some(VecSimplifiedType),\n+        ty::ty_ptr(_) => Some(PtrSimplifiedType),\n+        ty::ty_trait(ref trait_info) => {\n+            Some(TraitSimplifiedType(trait_info.principal.def_id))\n+        }\n+        ty::ty_struct(def_id, _) => {\n+            Some(StructSimplifiedType(def_id))\n+        }\n+        ty::ty_rptr(_, mt) => {\n+            // since we introduce auto-refs during method lookup, we\n+            // just treat &T and T as equivalent from the point of\n+            // view of possibly unifying\n+            simplify_type(tcx, mt.ty, can_simplify_params)\n+        }\n+        ty::ty_uniq(_) => {\n+            // treat like we would treat `Box`\n+            let def_id = tcx.lang_items.owned_box().unwrap();\n+            Some(StructSimplifiedType(def_id))\n+        }\n+        ty::ty_unboxed_closure(def_id, _, _) => {\n+            Some(UnboxedClosureSimplifiedType(def_id))\n+        }\n+        ty::ty_tup(ref tys) => {\n+            Some(TupleSimplifiedType(tys.len()))\n+        }\n+        ty::ty_closure(ref f) => {\n+            Some(FunctionSimplifiedType(f.sig.inputs.len()))\n+        }\n+        ty::ty_bare_fn(ref f) => {\n+            Some(FunctionSimplifiedType(f.sig.inputs.len()))\n+        }\n+        ty::ty_param(_) => {\n+            if can_simplify_params {\n+                Some(ParameterSimplifiedType)\n+            } else {\n+                None\n+            }\n+        }\n+        ty::ty_open(_) | ty::ty_infer(_) | ty::ty_err => None,\n+    }\n+}\n+"}, {"sha": "bc46b975cdb915d0b720153e9fb13556647d0915", "filename": "src/librustc/middle/typeck/check/method/probe.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d93921b348f37d10850c5f9b077300158a623e35/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d93921b348f37d10850c5f9b077300158a623e35/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d93921b348f37d10850c5f9b077300158a623e35", "patch": "@@ -16,6 +16,7 @@ use super::MethodIndex;\n use super::NoMatch;\n use super::TraitSource;\n \n+use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n@@ -36,6 +37,7 @@ struct ProbeContext<'a, 'tcx:'a> {\n     span: Span,\n     method_name: ast::Name,\n     steps: Rc<Vec<CandidateStep>>,\n+    opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate>,\n     extension_candidates: Vec<Candidate>,\n     impl_dups: HashSet<ast::DefId>,\n@@ -44,7 +46,7 @@ struct ProbeContext<'a, 'tcx:'a> {\n \n struct CandidateStep {\n     self_ty: ty::t,\n-    adjustment: PickAdjustment\n+    adjustment: PickAdjustment,\n }\n \n struct Candidate {\n@@ -123,16 +125,31 @@ pub fn probe(fcx: &FnCtxt,\n     // take place in the `fcx.infcx().probe` below.\n     let steps = create_steps(fcx, span, self_ty);\n \n+    // Create a list of simplified self types, if we can.\n+    let mut simplified_steps = Vec::new();\n+    for step in steps.iter() {\n+        match fast_reject::simplify_type(fcx.tcx(), step.self_ty, true) {\n+            None => { break; }\n+            Some(simplified_type) => { simplified_steps.push(simplified_type); }\n+        }\n+    }\n+    let opt_simplified_steps =\n+        if simplified_steps.len() < steps.len() {\n+            None // failed to convert at least one of the steps\n+        } else {\n+            Some(simplified_steps)\n+        };\n+\n     debug!(\"ProbeContext: steps for self_ty={} are {}\",\n            self_ty.repr(fcx.tcx()),\n            steps.repr(fcx.tcx()));\n \n     // this creates one big transaction so that all type variables etc\n     // that we create during the probe process are removed later\n-    let mut steps = Some(steps); // FIXME(#18101) need once closures\n+    let mut dummy = Some((steps, opt_simplified_steps)); // FIXME(#18101) need once closures\n     fcx.infcx().probe(|| {\n-        let steps = steps.take().unwrap();\n-        let mut probe_cx = ProbeContext::new(fcx, span, method_name, steps);\n+        let (steps, opt_simplified_steps) = dummy.take().unwrap();\n+        let mut probe_cx = ProbeContext::new(fcx, span, method_name, steps, opt_simplified_steps);\n         probe_cx.assemble_inherent_candidates();\n         probe_cx.assemble_extension_candidates_for_traits_in_scope(call_expr_id);\n         probe_cx.pick()\n@@ -177,7 +194,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>,\n            span: Span,\n            method_name: ast::Name,\n-           steps: Vec<CandidateStep>)\n+           steps: Vec<CandidateStep>,\n+           opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>)\n            -> ProbeContext<'a,'tcx>\n     {\n         ProbeContext {\n@@ -188,6 +206,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             extension_candidates: Vec::new(),\n             impl_dups: HashSet::new(),\n             steps: Rc::new(steps),\n+            opt_simplified_steps: opt_simplified_steps,\n             static_candidates: Vec::new(),\n         }\n     }\n@@ -473,6 +492,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                    trait_def_id.repr(self.tcx()),\n                    impl_def_id.repr(self.tcx()));\n \n+            if !self.impl_can_possibly_match(impl_def_id) {\n+                continue;\n+            }\n+\n             let impl_pty = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n             let impl_substs = impl_pty.substs;\n \n@@ -499,6 +522,22 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n+    fn impl_can_possibly_match(&self, impl_def_id: ast::DefId) -> bool {\n+        let simplified_steps = match self.opt_simplified_steps {\n+            Some(ref simplified_steps) => simplified_steps,\n+            None => { return true; }\n+        };\n+\n+        let impl_type = ty::lookup_item_type(self.tcx(), impl_def_id);\n+        let impl_simplified_type =\n+            match fast_reject::simplify_type(self.tcx(), impl_type.ty, false) {\n+                Some(simplified_type) => simplified_type,\n+                None => { return true; }\n+            };\n+\n+        simplified_steps.contains(&impl_simplified_type)\n+    }\n+\n     fn assemble_unboxed_closure_candidates(&mut self,\n                                            trait_def_id: ast::DefId,\n                                            method_ty: Rc<ty::Method>,"}]}