{"sha": "ebaa05a4478096aaf3bc2a48d0d171a287422c7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViYWEwNWE0NDc4MDk2YWFmM2JjMmE0OGQwZDE3MWEyODc0MjJjN2M=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-16T19:49:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-16T19:49:01Z"}, "message": "Merge #4472\n\n4472: Fix path resolution for module and function with same name r=hasali19 a=hasali19\n\nThis fixes #3970 and also fixes completion for the same issue.\n\nCo-authored-by: Hasan Ali <git@hasali.co.uk>", "tree": {"sha": "3a28337d2213a819b241d9d950ca64f6dcaf2345", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a28337d2213a819b241d9d950ca64f6dcaf2345"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebaa05a4478096aaf3bc2a48d0d171a287422c7c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJewEOtCRBK7hj4Ov3rIwAAdHIIAFlKQawv+D36hV5sgF0QCapd\n6V4XAdE117YovbJnpi3MHdKG9sc0xfu2nN6JcyBQxZkHDsqpAf1l00Pg+8Cs7R49\nfh5e1Au4pHMCrfWvBdC9jkhxEqBi4JdLXt7u81vcCAMAAe/Wa1y9lJjQJek4wEMt\nGVkW0OCuKs6OxdNE5Oum1ry2HjDRHuAjyEqyIoQllJBSZbe0DmIhzTNSrgIOOtNw\nB2dE1sdMeTidNpHLbD5E/xtNFTgdVb+cu2J6+wfxcXbws7mHXagVkYKYDU0AtW1R\nqAeDczuVl/i6L28uOUoBl6LRZBf2q3WOG5yP5WcKrIrvYYSk0mai/9e9ZqCMbpQ=\n=LATI\n-----END PGP SIGNATURE-----\n", "payload": "tree 3a28337d2213a819b241d9d950ca64f6dcaf2345\nparent 9322790066fe86056965332078bed74ff7f77293\nparent bb78d314e15999a68f5eb865486824966c13402f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1589658541 +0000\ncommitter GitHub <noreply@github.com> 1589658541 +0000\n\nMerge #4472\n\n4472: Fix path resolution for module and function with same name r=hasali19 a=hasali19\n\nThis fixes #3970 and also fixes completion for the same issue.\n\nCo-authored-by: Hasan Ali <git@hasali.co.uk>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebaa05a4478096aaf3bc2a48d0d171a287422c7c", "html_url": "https://github.com/rust-lang/rust/commit/ebaa05a4478096aaf3bc2a48d0d171a287422c7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebaa05a4478096aaf3bc2a48d0d171a287422c7c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9322790066fe86056965332078bed74ff7f77293", "url": "https://api.github.com/repos/rust-lang/rust/commits/9322790066fe86056965332078bed74ff7f77293", "html_url": "https://github.com/rust-lang/rust/commit/9322790066fe86056965332078bed74ff7f77293"}, {"sha": "bb78d314e15999a68f5eb865486824966c13402f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb78d314e15999a68f5eb865486824966c13402f", "html_url": "https://github.com/rust-lang/rust/commit/bb78d314e15999a68f5eb865486824966c13402f"}], "stats": {"total": 117, "additions": 115, "deletions": 2}, "files": [{"sha": "7c1f79f279b655a83c39524f22bf14c58375b3bb", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ebaa05a4478096aaf3bc2a48d0d171a287422c7c/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaa05a4478096aaf3bc2a48d0d171a287422c7c/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=ebaa05a4478096aaf3bc2a48d0d171a287422c7c", "patch": "@@ -23,7 +23,7 @@ use crate::{\n     db::HirDatabase,\n     diagnostics::Diagnostic,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n-    source_analyzer::{resolve_hir_path, SourceAnalyzer},\n+    source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n     AssocItem, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef,\n     Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam,\n };\n@@ -451,6 +451,23 @@ impl<'a, DB: HirDatabase> SemanticsScope<'a, DB> {\n     pub fn resolve_hir_path(&self, path: &Path) -> Option<PathResolution> {\n         resolve_hir_path(self.db, &self.resolver, path)\n     }\n+\n+    /// Resolves a path where we know it is a qualifier of another path.\n+    ///\n+    /// For example, if we have:\n+    /// ```\n+    /// mod my {\n+    ///     pub mod foo {\n+    ///         struct Bar;\n+    ///     }\n+    ///\n+    ///     pub fn foo() {}\n+    /// }\n+    /// ```\n+    /// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.\n+    pub fn resolve_hir_path_qualifier(&self, path: &Path) -> Option<PathResolution> {\n+        resolve_hir_path_qualifier(self.db, &self.resolver, path)\n+    }\n }\n \n // FIXME: Change `HasSource` trait to work with `Semantics` and remove this?"}, {"sha": "4b509f07c6b73303c0d3a53161f33ae147b1df0e", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ebaa05a4478096aaf3bc2a48d0d171a287422c7c/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaa05a4478096aaf3bc2a48d0d171a287422c7c/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=ebaa05a4478096aaf3bc2a48d0d171a287422c7c", "patch": "@@ -226,6 +226,17 @@ impl SourceAnalyzer {\n         // This must be a normal source file rather than macro file.\n         let hir_path =\n             crate::Path::from_src(path.clone(), &Hygiene::new(db.upcast(), self.file_id))?;\n+\n+        // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we\n+        // trying to resolve foo::bar.\n+        if let Some(outer_path) = path.syntax().parent().and_then(ast::Path::cast) {\n+            if let Some(qualifier) = outer_path.qualifier() {\n+                if path == &qualifier {\n+                    return resolve_hir_path_qualifier(db, &self.resolver, &hir_path);\n+                }\n+            }\n+        }\n+\n         resolve_hir_path(db, &self.resolver, &hir_path)\n     }\n \n@@ -404,6 +415,7 @@ pub(crate) fn resolve_hir_path(\n             TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n             TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n         });\n+\n     let body_owner = resolver.body_owner();\n     let values =\n         resolver.resolve_path_in_value_ns_fully(db.upcast(), path.mod_path()).and_then(|val| {\n@@ -426,9 +438,48 @@ pub(crate) fn resolve_hir_path(\n         .resolve_module_path_in_items(db.upcast(), path.mod_path())\n         .take_types()\n         .map(|it| PathResolution::Def(it.into()));\n+\n     types.or(values).or(items).or_else(|| {\n         resolver\n             .resolve_path_as_macro(db.upcast(), path.mod_path())\n             .map(|def| PathResolution::Macro(def.into()))\n     })\n }\n+\n+/// Resolves a path where we know it is a qualifier of another path.\n+///\n+/// For example, if we have:\n+/// ```\n+/// mod my {\n+///     pub mod foo {\n+///         struct Bar;\n+///     }\n+///\n+///     pub fn foo() {}\n+/// }\n+/// ```\n+/// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.\n+pub(crate) fn resolve_hir_path_qualifier(\n+    db: &dyn HirDatabase,\n+    resolver: &Resolver,\n+    path: &crate::Path,\n+) -> Option<PathResolution> {\n+    let items = resolver\n+        .resolve_module_path_in_items(db.upcast(), path.mod_path())\n+        .take_types()\n+        .map(|it| PathResolution::Def(it.into()));\n+\n+    if items.is_some() {\n+        return items;\n+    }\n+\n+    resolver.resolve_path_in_type_ns_fully(db.upcast(), path.mod_path()).map(|ty| match ty {\n+        TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n+        TypeNs::GenericParam(id) => PathResolution::TypeParam(TypeParam { id }),\n+        TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => PathResolution::Def(Adt::from(it).into()),\n+        TypeNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+        TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n+        TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n+        TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n+    })\n+}"}, {"sha": "db7430454c2940ef9276c3b4043835503dac7b49", "filename": "crates/ra_ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ebaa05a4478096aaf3bc2a48d0d171a287422c7c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaa05a4478096aaf3bc2a48d0d171a287422c7c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=ebaa05a4478096aaf3bc2a48d0d171a287422c7c", "patch": "@@ -20,7 +20,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     let scope = ctx.scope();\n     let context_module = scope.module();\n \n-    let res = match scope.resolve_hir_path(&path) {\n+    let res = match scope.resolve_hir_path_qualifier(&path) {\n         Some(res) => res,\n         None => return,\n     };\n@@ -225,6 +225,34 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn completes_mod_with_same_name_as_function() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                use self::my::<|>;\n+\n+                mod my {\n+                    pub struct Bar;\n+                }\n+\n+                fn my() {}\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Bar\",\n+                source_range: 31..31,\n+                delete: 31..31,\n+                insert: \"Bar\",\n+                kind: Struct,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn path_visibility() {\n         assert_debug_snapshot!("}, {"sha": "befa977c7fe7ecae4ebd89d7ac7526b08829c500", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ebaa05a4478096aaf3bc2a48d0d171a287422c7c/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaa05a4478096aaf3bc2a48d0d171a287422c7c/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=ebaa05a4478096aaf3bc2a48d0d171a287422c7c", "patch": "@@ -921,4 +921,21 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             &[\"unsafe trait foo\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_hover_mod_with_same_name_as_function() {\n+        check_hover_result(\n+            \"\n+            //- /lib.rs\n+            use self::m<|>y::Bar;\n+\n+            mod my {\n+                pub struct Bar;\n+            }\n+\n+            fn my() {}\n+            \",\n+            &[\"mod my\"],\n+        );\n+    }\n }"}]}