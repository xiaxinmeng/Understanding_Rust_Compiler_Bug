{"sha": "af75314ecdbc5564f300467e732fdb5c923a873a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNzUzMTRlY2RiYzU1NjRmMzAwNDY3ZTczMmZkYjVjOTIzYTg3M2E=", "commit": {"author": {"name": "sharkdp", "email": "davidpeter@web.de", "date": "2018-06-12T19:03:27Z"}, "committer": {"name": "sharkdp", "email": "davidpeter@web.de", "date": "2018-06-12T19:03:27Z"}, "message": "Fix possibly endless loop in ReadDir iterator\n\nCertain directories in `/proc` can cause the `ReadDir`\niterator to loop indefinitely. We get an error code (22) when\ncalling libc's `readdir_r` on these directories, but `entry_ptr`\nis `NULL` at the same time, signalling the end of the directory\nstream.\n\nThis change introduces an internal state to the iterator such\nthat the `Some(Err(..))` value will only be returned once when\ncalling `next`. Subsequent calls will return `None`.\n\nfixes #50619", "tree": {"sha": "22e6a7cd9ead097b94b3e3ccebf5ea7f0c9d1ca9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22e6a7cd9ead097b94b3e3ccebf5ea7f0c9d1ca9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af75314ecdbc5564f300467e732fdb5c923a873a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af75314ecdbc5564f300467e732fdb5c923a873a", "html_url": "https://github.com/rust-lang/rust/commit/af75314ecdbc5564f300467e732fdb5c923a873a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af75314ecdbc5564f300467e732fdb5c923a873a/comments", "author": {"login": "sharkdp", "id": 4209276, "node_id": "MDQ6VXNlcjQyMDkyNzY=", "avatar_url": "https://avatars.githubusercontent.com/u/4209276?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sharkdp", "html_url": "https://github.com/sharkdp", "followers_url": "https://api.github.com/users/sharkdp/followers", "following_url": "https://api.github.com/users/sharkdp/following{/other_user}", "gists_url": "https://api.github.com/users/sharkdp/gists{/gist_id}", "starred_url": "https://api.github.com/users/sharkdp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sharkdp/subscriptions", "organizations_url": "https://api.github.com/users/sharkdp/orgs", "repos_url": "https://api.github.com/users/sharkdp/repos", "events_url": "https://api.github.com/users/sharkdp/events{/privacy}", "received_events_url": "https://api.github.com/users/sharkdp/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sharkdp", "id": 4209276, "node_id": "MDQ6VXNlcjQyMDkyNzY=", "avatar_url": "https://avatars.githubusercontent.com/u/4209276?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sharkdp", "html_url": "https://github.com/sharkdp", "followers_url": "https://api.github.com/users/sharkdp/followers", "following_url": "https://api.github.com/users/sharkdp/following{/other_user}", "gists_url": "https://api.github.com/users/sharkdp/gists{/gist_id}", "starred_url": "https://api.github.com/users/sharkdp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sharkdp/subscriptions", "organizations_url": "https://api.github.com/users/sharkdp/orgs", "repos_url": "https://api.github.com/users/sharkdp/repos", "events_url": "https://api.github.com/users/sharkdp/events{/privacy}", "received_events_url": "https://api.github.com/users/sharkdp/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef8cb40c9c03fe60aac47c8736045231633dbdac", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef8cb40c9c03fe60aac47c8736045231633dbdac", "html_url": "https://github.com/rust-lang/rust/commit/ef8cb40c9c03fe60aac47c8736045231633dbdac"}], "stats": {"total": 31, "additions": 24, "deletions": 7}, "files": [{"sha": "6579fee14d86109a024a839d31d9f746163c4d20", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/af75314ecdbc5564f300467e732fdb5c923a873a/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af75314ecdbc5564f300467e732fdb5c923a873a/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=af75314ecdbc5564f300467e732fdb5c923a873a", "patch": "@@ -57,7 +57,10 @@ struct InnerReadDir {\n }\n \n #[derive(Clone)]\n-pub struct ReadDir(Arc<InnerReadDir>);\n+pub struct ReadDir {\n+    inner: Arc<InnerReadDir>,\n+    end_of_stream: bool,\n+}\n \n struct Dir(*mut libc::DIR);\n \n@@ -213,7 +216,7 @@ impl fmt::Debug for ReadDir {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n         // Thus the result will be e g 'ReadDir(\"/home\")'\n-        fmt::Debug::fmt(&*self.0.root, f)\n+        fmt::Debug::fmt(&*self.inner.root, f)\n     }\n }\n \n@@ -229,7 +232,7 @@ impl Iterator for ReadDir {\n                 // is safe to use in threaded applications and it is generally preferred\n                 // over the readdir_r(3C) function.\n                 super::os::set_errno(0);\n-                let entry_ptr = libc::readdir(self.0.dirp.0);\n+                let entry_ptr = libc::readdir(self.inner.dirp.0);\n                 if entry_ptr.is_null() {\n                     // NULL can mean either the end is reached or an error occurred.\n                     // So we had to clear errno beforehand to check for an error now.\n@@ -257,14 +260,25 @@ impl Iterator for ReadDir {\n \n     #[cfg(not(any(target_os = \"solaris\", target_os = \"fuchsia\")))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        if self.end_of_stream {\n+            return None;\n+        }\n+\n         unsafe {\n             let mut ret = DirEntry {\n                 entry: mem::zeroed(),\n                 dir: self.clone(),\n             };\n             let mut entry_ptr = ptr::null_mut();\n             loop {\n-                if readdir64_r(self.0.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n+                if readdir64_r(self.inner.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n+                    if entry_ptr.is_null() {\n+                        // We encountered an error (which will be returned in this iteration), but\n+                        // we also reached the end of the directory stream. The `end_of_stream`\n+                        // flag is enabled to make sure that we return `None` in the next iteration\n+                        // (instead of looping forever)\n+                        self.end_of_stream = true;\n+                    }\n                     return Some(Err(Error::last_os_error()))\n                 }\n                 if entry_ptr.is_null() {\n@@ -287,7 +301,7 @@ impl Drop for Dir {\n \n impl DirEntry {\n     pub fn path(&self) -> PathBuf {\n-        self.dir.0.root.join(OsStr::from_bytes(self.name_bytes()))\n+        self.dir.inner.root.join(OsStr::from_bytes(self.name_bytes()))\n     }\n \n     pub fn file_name(&self) -> OsString {\n@@ -296,7 +310,7 @@ impl DirEntry {\n \n     #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\n     pub fn metadata(&self) -> io::Result<FileAttr> {\n-        let fd = cvt(unsafe {dirfd(self.dir.0.dirp.0)})?;\n+        let fd = cvt(unsafe {dirfd(self.dir.inner.dirp.0)})?;\n         let mut stat: stat64 = unsafe { mem::zeroed() };\n         cvt(unsafe {\n             fstatat(fd,\n@@ -692,7 +706,10 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n             Err(Error::last_os_error())\n         } else {\n             let inner = InnerReadDir { dirp: Dir(ptr), root };\n-            Ok(ReadDir(Arc::new(inner)))\n+            Ok(ReadDir{\n+                inner: Arc::new(inner),\n+                end_of_stream: false,\n+            })\n         }\n     }\n }"}]}