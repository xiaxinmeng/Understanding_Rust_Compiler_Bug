{"sha": "e67d2b26635e7c03346a331ba52703a78a1986aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2N2QyYjI2NjM1ZTdjMDMzNDZhMzMxYmE1MjcwM2E3OGExOTg2YWE=", "commit": {"author": {"name": "Donald Robertson", "email": "donaldarobertson89@gmail.com", "date": "2018-06-06T15:53:11Z"}, "committer": {"name": "Donald Robertson", "email": "donaldarobertson89@gmail.com", "date": "2018-06-06T15:53:11Z"}, "message": "Added check to ensure format macro only being handled, refactored extraction and checks to smaller functions.", "tree": {"sha": "956d1c615a70e19cbf8677f14418934771d50e13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/956d1c615a70e19cbf8677f14418934771d50e13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e67d2b26635e7c03346a331ba52703a78a1986aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e67d2b26635e7c03346a331ba52703a78a1986aa", "html_url": "https://github.com/rust-lang/rust/commit/e67d2b26635e7c03346a331ba52703a78a1986aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e67d2b26635e7c03346a331ba52703a78a1986aa/comments", "author": null, "committer": null, "parents": [{"sha": "451fd5feb9d68c0c9a130b5d36ae73bae06c4200", "url": "https://api.github.com/repos/rust-lang/rust/commits/451fd5feb9d68c0c9a130b5d36ae73bae06c4200", "html_url": "https://github.com/rust-lang/rust/commit/451fd5feb9d68c0c9a130b5d36ae73bae06c4200"}], "stats": {"total": 84, "additions": 48, "deletions": 36}, "files": [{"sha": "7d65193b1aa3f6aa16a25f5a24e7b65b02a3d886", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e67d2b26635e7c03346a331ba52703a78a1986aa/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e67d2b26635e7c03346a331ba52703a78a1986aa/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=e67d2b26635e7c03346a331ba52703a78a1986aa", "patch": "@@ -7,8 +7,8 @@ use std::fmt;\n use std::iter;\n use syntax::ast;\n use syntax::codemap::{Span, BytePos};\n-use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_self, is_self_ty,\n-            iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n+use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_expn_of, is_self, \n+            is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n             match_type, method_chain_args, match_var, return_ty, remove_blocks, same_tys, single_segment_path, snippet,\n             span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n use crate::utils::paths;\n@@ -994,6 +994,34 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n \n /// Checks for the `EXPECT_FUN_CALL` lint.\n fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+    fn extract_format_args(arg: &hir::Expr) -> Option<&hir::HirVec<hir::Expr>> {\n+        if let hir::ExprAddrOf(_, ref addr_of) = arg.node {\n+            if let hir::ExprCall(ref inner_fun, ref inner_args) = addr_of.node {\n+                if let Some(_) = is_expn_of(inner_fun.span, \"format\") {\n+                    if inner_args.len() == 1 {\n+                        if let hir::ExprCall(_, ref format_args) = inner_args[0].node {\n+                            return Some(format_args);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn generate_format_arg_snippet(cx: &LateContext, a: &hir::Expr) -> String {\n+        if let hir::ExprAddrOf(_, ref format_arg) = a.node {\n+            if let hir::ExprMatch(ref format_arg_expr, _, _) = format_arg.node {\n+                if let hir::ExprTup(ref format_arg_expr_tup) = format_arg_expr.node {\n+                    return snippet(cx, format_arg_expr_tup[0].span, \"..\").into_owned();\n+                }\n+            }\n+        };\n+        \n+        snippet(cx, a.span, \"..\").into_owned()\n+    }\n+\n     fn check_general_case(\n         cx: &LateContext,\n         name: &str,\n@@ -1024,42 +1052,26 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n         let closure = if match_type(cx, self_type, &paths::OPTION) { \"||\" } else { \"|_|\" };\n         let span_replace_word = method_span.with_hi(span.hi());\n \n-        if let hir::ExprAddrOf(_, ref addr_of) = arg.node {\n-            if let hir::ExprCall(ref _inner_fun, ref inner_args) = addr_of.node {\n-                // TODO: check if inner_fun is call to format!\n-                if inner_args.len() == 1 {\n-                    if let hir::ExprCall(_, ref format_args) = inner_args[0].node {\n-                        let args_len = format_args.len();\n-                        let args: Vec<String> = format_args\n-                            .into_iter()\n-                            .take(args_len - 1)\n-                            .map(|a| {\n-                                if let hir::ExprAddrOf(_, ref format_arg) = a.node {\n-                                    if let hir::ExprMatch(ref format_arg_expr, _, _) = format_arg.node {\n-                                        if let hir::ExprTup(ref format_arg_expr_tup) = format_arg_expr.node {\n-                                            return snippet(cx, format_arg_expr_tup[0].span, \"..\").into_owned();\n-                                        }\n-                                    }\n-                                };\n-                                snippet(cx, a.span, \"..\").into_owned()\n-                            })\n-                            .collect();\n-\n-                        let sugg = args.join(\", \");\n+        if let Some(format_args) = extract_format_args(arg) {\n+            let args_len = format_args.len();\n+            let args: Vec<String> = format_args\n+                .into_iter()\n+                .take(args_len - 1)\n+                .map(|a| generate_format_arg_snippet(cx, a))\n+                .collect();\n \n-                        span_lint_and_sugg(\n-                            cx,\n-                            EXPECT_FUN_CALL,\n-                            span_replace_word,\n-                            &format!(\"use of `{}` followed by a function call\", name),\n-                            \"try this\",\n-                            format!(\"unwrap_or_else({} panic!({}))\", closure, sugg),\n-                        );\n+            let sugg = args.join(\", \");\n \n-                        return;\n-                    }\n-                }\n-            }\n+            span_lint_and_sugg(\n+                cx,\n+                EXPECT_FUN_CALL,\n+                span_replace_word,\n+                &format!(\"use of `{}` followed by a function call\", name),\n+                \"try this\",\n+                format!(\"unwrap_or_else({} panic!({}))\", closure, sugg),\n+            );\n+\n+            return;\n         }\n \n         let sugg: Cow<_> = snippet(cx, arg.span, \"..\");"}]}