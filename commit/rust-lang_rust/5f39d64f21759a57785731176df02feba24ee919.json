{"sha": "5f39d64f21759a57785731176df02feba24ee919", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMzlkNjRmMjE3NTlhNTc3ODU3MzExNzZkZjAyZmViYTI0ZWU5MTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-07T13:56:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-07T13:56:36Z"}, "message": "auto merge of #11342 : huonw/rust/trie-mut, r=alexcrichton\n\n- Add `mut_iter`, `mut_lower_bound`, `mut_upper_bound`\r\n- Remove some internal iterators\r\n- Add benchmarks\r\n- Improve performance of `{mut_,}{lower,upper}_bound`\r\n- Minor clean-up of `extra::treemap` after I realised I wasn't exploiting macros to their full DRY potential.", "tree": {"sha": "0374f0881636606e1d787cbc41d430fc9c6c0084", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0374f0881636606e1d787cbc41d430fc9c6c0084"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f39d64f21759a57785731176df02feba24ee919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f39d64f21759a57785731176df02feba24ee919", "html_url": "https://github.com/rust-lang/rust/commit/5f39d64f21759a57785731176df02feba24ee919", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f39d64f21759a57785731176df02feba24ee919/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba6ed004b0a7bf40dbd906ba9c8677133213c6ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba6ed004b0a7bf40dbd906ba9c8677133213c6ef", "html_url": "https://github.com/rust-lang/rust/commit/ba6ed004b0a7bf40dbd906ba9c8677133213c6ef"}, {"sha": "167d533fe0624963cb3f836ebce06a457043c816", "url": "https://api.github.com/repos/rust-lang/rust/commits/167d533fe0624963cb3f836ebce06a457043c816", "html_url": "https://github.com/rust-lang/rust/commit/167d533fe0624963cb3f836ebce06a457043c816"}], "stats": {"total": 488, "additions": 304, "deletions": 184}, "files": [{"sha": "59f7f2a2ffcb1d8d3564b8dd8a2c1d0628722719", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f39d64f21759a57785731176df02feba24ee919/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f39d64f21759a57785731176df02feba24ee919/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=5f39d64f21759a57785731176df02feba24ee919", "patch": "@@ -768,14 +768,11 @@ impl<\n > Encodable<E> for TrieMap<V> {\n     fn encode(&self, e: &mut E) {\n         e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            self.each(|key, val| {\n-                e.emit_map_elt_key(i, |e| key.encode(e));\n-                e.emit_map_elt_val(i, |e| val.encode(e));\n-                i += 1;\n-                true\n+                for (i, (key, val)) in self.iter().enumerate() {\n+                    e.emit_map_elt_key(i, |e| key.encode(e));\n+                    e.emit_map_elt_val(i, |e| val.encode(e));\n+                }\n             });\n-        })\n     }\n }\n \n@@ -799,13 +796,10 @@ impl<\n impl<S: Encoder> Encodable<S> for TrieSet {\n     fn encode(&self, s: &mut S) {\n         s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            self.each(|e| {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n-                i += 1;\n-                true\n-            });\n-        })\n+                for (i, e) in self.iter().enumerate() {\n+                    s.emit_seq_elt(i, |s| e.encode(s));\n+                }\n+            })\n     }\n }\n "}, {"sha": "9fe419b06d2edb156638909359d09fec03ea0638", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5f39d64f21759a57785731176df02feba24ee919/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f39d64f21759a57785731176df02feba24ee919/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=5f39d64f21759a57785731176df02feba24ee919", "patch": "@@ -327,14 +327,12 @@ pub struct TreeMapMutRevIterator<'a, K, V> {\n // other macros, so this takes the `& <mutability> <operand>` token\n // sequence and forces their evalutation as an expression.\n macro_rules! addr { ($e:expr) => { $e }}\n+// putting an optional mut into type signatures\n+macro_rules! item { ($i:item) => { $i }}\n \n macro_rules! define_iterator {\n     ($name:ident,\n      $rev_name:ident,\n-     // the type of the values of the treemap in the return value of\n-     // the iterator (i.e. &V or &mut V). This is non-hygienic in the\n-     // name of the lifetime.\n-     value_type = $value_type:ty,\n \n      // the function to go from &m Option<~TreeNode> to *m TreeNode\n      deref = $deref:ident,\n@@ -343,10 +341,11 @@ macro_rules! define_iterator {\n      // there's no support for 0-or-1 repeats.\n      addr_mut = $($addr_mut:tt)*\n      ) => {\n-        // private methods on the forward iterator\n-        impl<'a, K, V> $name<'a, K, V> {\n+        // private methods on the forward iterator (item!() for the\n+        // addr_mut in the next_ return value)\n+        item!(impl<'a, K, V> $name<'a, K, V> {\n             #[inline(always)]\n-            fn next_(&mut self, forward: bool) -> Option<(&'a K, $value_type)> {\n+            fn next_(&mut self, forward: bool) -> Option<(&'a K, &'a $($addr_mut)* V)> {\n                 while !self.stack.is_empty() || !self.node.is_null() {\n                     if !self.node.is_null() {\n                         let node = unsafe {addr!(& $($addr_mut)* *self.node)};\n@@ -412,41 +411,40 @@ macro_rules! define_iterator {\n                     self.node = ptr::RawPtr::null();\n                 }\n             }\n-        }\n+        })\n \n         // the forward Iterator impl.\n-        impl<'a, K, V> Iterator<(&'a K, $value_type)> for $name<'a, K, V> {\n+        item!(impl<'a, K, V> Iterator<(&'a K, &'a $($addr_mut)* V)> for $name<'a, K, V> {\n             /// Advance the iterator to the next node (in order) and return a\n             /// tuple with a reference to the key and value. If there are no\n             /// more nodes, return `None`.\n-            fn next(&mut self) -> Option<(&'a K, $value_type)> {\n+            fn next(&mut self) -> Option<(&'a K, &'a $($addr_mut)* V)> {\n                 self.next_(true)\n             }\n \n             #[inline]\n             fn size_hint(&self) -> (uint, Option<uint>) {\n                 (self.remaining_min, Some(self.remaining_max))\n             }\n-        }\n+        })\n \n         // the reverse Iterator impl.\n-        impl<'a, K, V> Iterator<(&'a K, $value_type)> for $rev_name<'a, K, V> {\n-            fn next(&mut self) -> Option<(&'a K, $value_type)> {\n+        item!(impl<'a, K, V> Iterator<(&'a K, &'a $($addr_mut)* V)> for $rev_name<'a, K, V> {\n+            fn next(&mut self) -> Option<(&'a K, &'a $($addr_mut)* V)> {\n                 self.iter.next_(false)\n             }\n \n             #[inline]\n             fn size_hint(&self) -> (uint, Option<uint>) {\n                 self.iter.size_hint()\n             }\n-        }\n+        })\n     }\n } // end of define_iterator\n \n define_iterator! {\n     TreeMapIterator,\n     TreeMapRevIterator,\n-    value_type = &'a V,\n     deref = deref,\n \n     // immutable, so no mut\n@@ -455,7 +453,6 @@ define_iterator! {\n define_iterator! {\n     TreeMapMutIterator,\n     TreeMapMutRevIterator,\n-    value_type = &'a mut V,\n     deref = mut_deref,\n \n     addr_mut = mut"}, {"sha": "d864cde2953ea1ad30760455cbce86f14a803d85", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 283, "deletions": 154, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/5f39d64f21759a57785731176df02feba24ee919/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f39d64f21759a57785731176df02feba24ee919/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=5f39d64f21759a57785731176df02feba24ee919", "patch": "@@ -111,30 +111,6 @@ impl<T> TrieMap<T> {\n         self.root.each_reverse(f)\n     }\n \n-    /// Visit all key-value pairs in order\n-    #[inline]\n-    pub fn each<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n-        self.root.each(f)\n-    }\n-\n-    /// Visit all keys in order\n-    #[inline]\n-    pub fn each_key(&self, f: |&uint| -> bool) -> bool {\n-        self.each(|k, _| f(k))\n-    }\n-\n-    /// Visit all values in order\n-    #[inline]\n-    pub fn each_value<'a>(&'a self, f: |&'a T| -> bool) -> bool {\n-        self.each(|_, v| f(v))\n-    }\n-\n-    /// Iterate over the map and mutate the contained values\n-    #[inline]\n-    pub fn mutate_values(&mut self, f: |&uint, &mut T| -> bool) -> bool {\n-        self.root.mutate_values(f)\n-    }\n-\n     /// Visit all keys in reverse order\n     #[inline]\n     pub fn each_key_reverse(&self, f: |&uint| -> bool) -> bool {\n@@ -156,39 +132,104 @@ impl<T> TrieMap<T> {\n         }\n     }\n \n+    /// Get an iterator over the key-value pairs in the map, with the\n+    /// ability to mutate the values.\n+    pub fn mut_iter<'a>(&'a mut self) -> TrieMapMutIterator<'a, T> {\n+        TrieMapMutIterator {\n+            stack: ~[self.root.children.mut_iter()],\n+            remaining_min: self.length,\n+            remaining_max: self.length\n+        }\n+    }\n+}\n+\n+// FIXME #5846 we want to be able to choose between &x and &mut x\n+// (with many different `x`) below, so we need to optionally pass mut\n+// as a tt, but the only thing we can do with a `tt` is pass them to\n+// other macros, so this takes the `& <mutability> <operand>` token\n+// sequence and forces their evalutation as an expression. (see also\n+// `item!` below.)\n+macro_rules! addr { ($e:expr) => { $e } }\n+\n+macro_rules! bound {\n+    ($iterator_name:ident,\n+     // the current treemap\n+     self = $this:expr,\n+     // the key to look for\n+     key = $key:expr,\n+     // are we looking at the upper bound?\n+     is_upper = $upper:expr,\n+\n+     // method names for slicing/iterating.\n+     slice_from = $slice_from:ident,\n+     iter = $iter:ident,\n+\n+     // see the comment on `addr!`, this is just an optional mut, but\n+     // there's no 0-or-1 repeats yet.\n+     mutability = $($mut_:tt)*) => {\n+        {\n+            // # For `mut`\n+            // We need an unsafe pointer here because we are borrowing\n+            // mutable references to the internals of each of these\n+            // mutable nodes, while still using the outer node.\n+            //\n+            // However, we're allowed to flaunt rustc like this because we\n+            // never actually modify the \"shape\" of the nodes. The only\n+            // place that mutation is can actually occur is of the actual\n+            // values of the TrieMap (as the return value of the\n+            // iterator), i.e. we can never cause a deallocation of any\n+            // TrieNodes so the raw pointer is always valid.\n+            //\n+            // # For non-`mut`\n+            // We like sharing code so much that even a little unsafe won't\n+            // stop us.\n+            let this = $this;\n+            let mut node = addr!(& $($mut_)* this.root as * $($mut_)* TrieNode<T>);\n+\n+            let key = $key;\n+\n+            let mut idx = 0;\n+            let mut it = $iterator_name {\n+                stack: ~[],\n+                remaining_min: 0,\n+                remaining_max: this.length\n+            };\n+            // this addr is necessary for the `Internal` pattern.\n+            addr!(loop {\n+                    let children = unsafe {addr!(& $($mut_)* (*node).children)};\n+                    let child_id = chunk(key, idx);\n+                    let (slice_idx, ret) = match children[child_id] {\n+                        Internal(ref $($mut_)* n) => {\n+                            node = addr!(& $($mut_)* **n as * $($mut_)* TrieNode<T>);\n+                            (child_id + 1, false)\n+                        }\n+                        External(stored, _) => {\n+                            (if stored < key || ($upper && stored == key) {\n+                                child_id + 1\n+                            } else {\n+                                child_id\n+                            }, true)\n+                        }\n+                        Nothing => {\n+                            (child_id + 1, true)\n+                        }\n+                    };\n+                    it.stack.push(children.$slice_from(slice_idx).$iter());\n+                    if ret { return it }\n+                    idx += 1;\n+                })\n+        }\n+    }\n+}\n+\n+impl<T> TrieMap<T> {\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n     #[inline]\n     fn bound<'a>(&'a self, key: uint, upper: bool) -> TrieMapIterator<'a, T> {\n-        let mut node: &'a TrieNode<T> = &self.root;\n-        let mut idx = 0;\n-        let mut it = TrieMapIterator {\n-            stack: ~[],\n-            remaining_min: 0,\n-            remaining_max: self.length\n-        };\n-        loop {\n-            let children = &node.children;\n-            let child_id = chunk(key, idx);\n-            match children[child_id] {\n-                Internal(ref n) => {\n-                    node = &**n;\n-                    it.stack.push(children.slice_from(child_id + 1).iter());\n-                }\n-                External(stored, _) => {\n-                    if stored < key || (upper && stored == key) {\n-                        it.stack.push(children.slice_from(child_id + 1).iter());\n-                    } else {\n-                        it.stack.push(children.slice_from(child_id).iter());\n-                    }\n-                    return it;\n-                }\n-                Nothing => {\n-                    it.stack.push(children.slice_from(child_id + 1).iter());\n-                    return it\n-                }\n-            }\n-            idx += 1;\n-        }\n+        bound!(TrieMapIterator, self = self,\n+               key = key, is_upper = upper,\n+               slice_from = slice_from, iter = iter,\n+               mutability = )\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n@@ -202,6 +243,26 @@ impl<T> TrieMap<T> {\n     pub fn upper_bound<'a>(&'a self, key: uint) -> TrieMapIterator<'a, T> {\n         self.bound(key, true)\n     }\n+    // If `upper` is true then returns upper_bound else returns lower_bound.\n+    #[inline]\n+    fn mut_bound<'a>(&'a mut self, key: uint, upper: bool) -> TrieMapMutIterator<'a, T> {\n+        bound!(TrieMapMutIterator, self = self,\n+               key = key, is_upper = upper,\n+               slice_from = mut_slice_from, iter = mut_iter,\n+               mutability = mut)\n+    }\n+\n+    /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n+    /// If all keys in the map are less than `key` an empty iterator is returned.\n+    pub fn mut_lower_bound<'a>(&'a mut self, key: uint) -> TrieMapMutIterator<'a, T> {\n+        self.mut_bound(key, false)\n+    }\n+\n+    /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n+    /// If all keys in the map are not greater than `key` an empty iterator is returned.\n+    pub fn mut_upper_bound<'a>(&'a mut self, key: uint) -> TrieMapMutIterator<'a, T> {\n+        self.mut_bound(key, true)\n+    }\n }\n \n impl<T> FromIterator<(uint, T)> for TrieMap<T> {\n@@ -264,10 +325,6 @@ impl TrieSet {\n         self.map.remove(value)\n     }\n \n-    /// Visit all values in order\n-    #[inline]\n-    pub fn each(&self, f: |&uint| -> bool) -> bool { self.map.each_key(f) }\n-\n     /// Visit all values in reverse order\n     #[inline]\n     pub fn each_reverse(&self, f: |&uint| -> bool) -> bool {\n@@ -328,17 +385,6 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    fn each<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n-        for elt in self.children.iter() {\n-            match *elt {\n-                Internal(ref x) => if !x.each(|i,t| f(i,t)) { return false },\n-                External(k, ref v) => if !f(&k, v) { return false },\n-                Nothing => ()\n-            }\n-        }\n-        true\n-    }\n-\n     fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         for elt in self.children.rev_iter() {\n             match *elt {\n@@ -349,19 +395,6 @@ impl<T> TrieNode<T> {\n         }\n         true\n     }\n-\n-    fn mutate_values<'a>(&'a mut self, f: |&uint, &mut T| -> bool) -> bool {\n-        for child in self.children.mut_iter() {\n-            match *child {\n-                Internal(ref mut x) => if !x.mutate_values(|i,t| f(i,t)) {\n-                    return false\n-                },\n-                External(k, ref mut v) => if !f(&k, v) { return false },\n-                Nothing => ()\n-            }\n-        }\n-        true\n-    }\n }\n \n // if this was done via a trait, the key could be generic\n@@ -449,39 +482,59 @@ pub struct TrieMapIterator<'a, T> {\n     priv remaining_max: uint\n }\n \n-impl<'a, T> Iterator<(uint, &'a T)> for TrieMapIterator<'a, T> {\n-    fn next(&mut self) -> Option<(uint, &'a T)> {\n-        while !self.stack.is_empty() {\n-            match self.stack[self.stack.len() - 1].next() {\n-                None => {\n-                    self.stack.pop();\n-                }\n-                Some(ref child) => {\n-                    match **child {\n-                        Internal(ref node) => {\n-                            self.stack.push(node.children.iter());\n-                        }\n-                        External(key, ref value) => {\n-                            self.remaining_max -= 1;\n-                            if self.remaining_min > 0 {\n-                                self.remaining_min -= 1;\n+/// Forward iterator over the key-value pairs of a map, with the\n+/// values being mutable.\n+pub struct TrieMapMutIterator<'a, T> {\n+    priv stack: ~[vec::VecMutIterator<'a, Child<T>>],\n+    priv remaining_min: uint,\n+    priv remaining_max: uint\n+}\n+\n+// FIXME #5846: see `addr!` above.\n+macro_rules! item { ($i:item) => {$i}}\n+\n+macro_rules! iterator_impl {\n+    ($name:ident,\n+     iter = $iter:ident,\n+     mutability = $($mut_:tt)*) => {\n+        item!(impl<'a, T> Iterator<(uint, &'a $($mut_)* T)> for $name<'a, T> {\n+                fn next(&mut self) -> Option<(uint, &'a $($mut_)* T)> {\n+                    while !self.stack.is_empty() {\n+                        match self.stack[self.stack.len() - 1].next() {\n+                            None => {\n+                                self.stack.pop();\n+                            }\n+                            Some(child) => {\n+                                addr!(match *child {\n+                                        Internal(ref $($mut_)* node) => {\n+                                            self.stack.push(node.children.$iter());\n+                                        }\n+                                        External(key, ref $($mut_)* value) => {\n+                                            self.remaining_max -= 1;\n+                                            if self.remaining_min > 0 {\n+                                                self.remaining_min -= 1;\n+                                            }\n+                                            return Some((key, value));\n+                                        }\n+                                        Nothing => {}\n+                                    })\n                             }\n-                            return Some((key, value));\n                         }\n-                        Nothing => {}\n                     }\n+                    return None;\n                 }\n-            }\n-        }\n-        return None;\n-    }\n \n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.remaining_min, Some(self.remaining_max))\n+                #[inline]\n+                fn size_hint(&self) -> (uint, Option<uint>) {\n+                    (self.remaining_min, Some(self.remaining_max))\n+                }\n+            })\n     }\n }\n \n+iterator_impl! { TrieMapIterator, iter = iter, mutability = }\n+iterator_impl! { TrieMapMutIterator, iter = mut_iter, mutability = mut }\n+\n /// Forward iterator over a set\n pub struct TrieSetIterator<'a> {\n     priv iter: TrieMapIterator<'a, ()>\n@@ -583,46 +636,6 @@ mod test_map {\n         }\n     }\n \n-    #[test]\n-    fn test_each() {\n-        let mut m = TrieMap::new();\n-\n-        assert!(m.insert(3, 6));\n-        assert!(m.insert(0, 0));\n-        assert!(m.insert(4, 8));\n-        assert!(m.insert(2, 4));\n-        assert!(m.insert(1, 2));\n-\n-        let mut n = 0;\n-        m.each(|k, v| {\n-            assert_eq!(*k, n);\n-            assert_eq!(*v, n * 2);\n-            n += 1;\n-            true\n-        });\n-    }\n-\n-    #[test]\n-    fn test_each_break() {\n-        let mut m = TrieMap::new();\n-\n-        for x in range(uint::max_value - 10000, uint::max_value).invert() {\n-            m.insert(x, x / 2);\n-        }\n-\n-        let mut n = uint::max_value - 10000;\n-        m.each(|k, v| {\n-            if n == uint::max_value - 5000 { false } else {\n-                assert!(n < uint::max_value - 5000);\n-\n-                assert_eq!(*k, n);\n-                assert_eq!(*v, n / 2);\n-                n += 1;\n-                true\n-            }\n-        });\n-    }\n-\n     #[test]\n     fn test_each_reverse() {\n         let mut m = TrieMap::new();\n@@ -712,6 +725,30 @@ mod test_map {\n         assert_eq!(i, last - first);\n     }\n \n+    #[test]\n+    fn test_mut_iter() {\n+        let mut empty_map : TrieMap<uint> = TrieMap::new();\n+        assert!(empty_map.mut_iter().next().is_none());\n+\n+        let first = uint::max_value - 10000;\n+        let last = uint::max_value;\n+\n+        let mut map = TrieMap::new();\n+        for x in range(first, last).invert() {\n+            map.insert(x, x / 2);\n+        }\n+\n+        let mut i = 0;\n+        for (k, v) in map.mut_iter() {\n+            assert_eq!(k, first + i);\n+            *v -= k / 2;\n+            i += 1;\n+        }\n+        assert_eq!(i, last - first);\n+\n+        assert!(map.iter().all(|(_, &v)| v == 0));\n+    }\n+\n     #[test]\n     fn test_bound() {\n         let empty_map : TrieMap<uint> = TrieMap::new();\n@@ -753,6 +790,102 @@ mod test_map {\n             assert_eq!(ub.next(), None);\n         }\n     }\n+\n+    #[test]\n+    fn test_mut_bound() {\n+        let empty_map : TrieMap<uint> = TrieMap::new();\n+        assert_eq!(empty_map.lower_bound(0).next(), None);\n+        assert_eq!(empty_map.upper_bound(0).next(), None);\n+\n+        let mut m_lower = TrieMap::new();\n+        let mut m_upper = TrieMap::new();\n+        for i in range(0u, 100) {\n+            m_lower.insert(2 * i, 4 * i);\n+            m_upper.insert(2 * i, 4 * i);\n+        }\n+\n+        for i in range(0u, 199) {\n+            let mut lb_it = m_lower.mut_lower_bound(i);\n+            let (k, v) = lb_it.next().unwrap();\n+            let lb = i + i % 2;\n+            assert_eq!(lb, k);\n+            *v -= k;\n+        }\n+\n+        for i in range(0u, 198) {\n+            let mut ub_it = m_upper.mut_upper_bound(i);\n+            let (k, v) = ub_it.next().unwrap();\n+            let ub = i + 2 - i % 2;\n+            assert_eq!(ub, k);\n+            *v -= k;\n+        }\n+\n+        assert!(m_lower.mut_lower_bound(199).next().is_none());\n+        assert!(m_upper.mut_upper_bound(198).next().is_none());\n+\n+        assert!(m_lower.iter().all(|(_, &x)| x == 0));\n+        assert!(m_upper.iter().all(|(_, &x)| x == 0));\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench_map {\n+    use super::*;\n+    use prelude::*;\n+    use rand::{weak_rng, Rng};\n+    use extra::test::BenchHarness;\n+\n+    #[bench]\n+    fn bench_iter_small(bh: &mut BenchHarness) {\n+        let mut m = TrieMap::<uint>::new();\n+        let mut rng = weak_rng();\n+        for _ in range(0, 20) {\n+            m.insert(rng.gen(), rng.gen());\n+        }\n+\n+        bh.iter(|| for _ in m.iter() {})\n+    }\n+\n+    #[bench]\n+    fn bench_iter_large(bh: &mut BenchHarness) {\n+        let mut m = TrieMap::<uint>::new();\n+        let mut rng = weak_rng();\n+        for _ in range(0, 1000) {\n+            m.insert(rng.gen(), rng.gen());\n+        }\n+\n+        bh.iter(|| for _ in m.iter() {})\n+    }\n+\n+    #[bench]\n+    fn bench_lower_bound(bh: &mut BenchHarness) {\n+        let mut m = TrieMap::<uint>::new();\n+        let mut rng = weak_rng();\n+        for _ in range(0, 1000) {\n+            m.insert(rng.gen(), rng.gen());\n+        }\n+\n+        bh.iter(|| {\n+                for _ in range(0, 10) {\n+                    m.lower_bound(rng.gen());\n+                }\n+            });\n+    }\n+\n+    #[bench]\n+    fn bench_upper_bound(bh: &mut BenchHarness) {\n+        let mut m = TrieMap::<uint>::new();\n+        let mut rng = weak_rng();\n+        for _ in range(0, 1000) {\n+            m.insert(rng.gen(), rng.gen());\n+        }\n+\n+        bh.iter(|| {\n+                for _ in range(0, 10) {\n+                    m.upper_bound(rng.gen());\n+                }\n+            });\n+    }\n }\n \n #[cfg(test)]\n@@ -775,13 +908,9 @@ mod test_set {\n \n         let expected = [x, y];\n \n-        let mut i = 0;\n-\n-        trie.each(|x| {\n-            assert_eq!(expected[i], *x);\n-            i += 1;\n-            true\n-        });\n+        for (i, x) in trie.iter().enumerate() {\n+            assert_eq!(expected[i], x);\n+        }\n     }\n \n     #[test]"}]}