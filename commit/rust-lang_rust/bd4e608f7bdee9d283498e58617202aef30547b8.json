{"sha": "bd4e608f7bdee9d283498e58617202aef30547b8", "node_id": "C_kwDOAAsO6NoAKGJkNGU2MDhmN2JkZWU5ZDI4MzQ5OGU1ODYxNzIwMmFlZjMwNTQ3Yjg", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2022-11-09T02:03:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-09T02:03:52Z"}, "message": "Rollup merge of #101381 - Urgau:target-mixup-homogenous-floats, r=Amanieu\n\nTest that target feature mix up with homogeneous floats is sound\n\nThis pull-request adds a test in `src/test/abi/` that test that target feature mix up with homogeneous floats is sound.\n\nThis is basically is ripoff of [src/test/ui/simd/target-feature-mixup.rs](https://github.com/rust-lang/rust/blob/47d1cdb0bcac8e417071ce1929d261efe2399ae2/src/test/ui/simd/target-feature-mixup.rs) but for floats and without `#[repr(simd)]`.\n\n*Extracted from https://github.com/rust-lang/rust/pull/97559 since I don't yet know what to do with that PR.*", "tree": {"sha": "76e916235b2be20876cbdb8abd7fea1503e6a027", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76e916235b2be20876cbdb8abd7fea1503e6a027"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd4e608f7bdee9d283498e58617202aef30547b8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjawqICRBK7hj4Ov3rIwAAsUAIAKBcg0bDseIvni8FRefBcPbO\nbHWKYpJW2QQK8WVChhMcS6Mb5Ypo45sQt/0eAewJ8g9ZtNNeUGAMF4vpm9CXX3vh\nGUJak9ZeM/JdJosN3wTpJ6LjtQ1pc1WjLqMjGSvoOFuuBpWhNKB1gHsTKElNtM7R\n6WG3m6Zpgs7J0zBY7d+XhbpOmvOwPuK1u6H01/TqKfyu21BGzfkc36ZY/fU6kiCL\nYvXG5ekAnfqEOB1qeM7BPRJj2Gz453Fx+ahCFnIbudWSSMQOEkUtDVBX/Rlu7SOE\nTRYQgEAA6UJFnaFd1q8nUA6Zr2+VJJXCtWP51FYsajtNHVAu6Cmu3FjbPQjphKw=\n=vUX4\n-----END PGP SIGNATURE-----\n", "payload": "tree 76e916235b2be20876cbdb8abd7fea1503e6a027\nparent f162e3a1b1e8025435c177bc0659155bab50ad92\nparent 66847ff56b933609618b0899cb3bfdd74f9817d5\nauthor Manish Goregaokar <manishsmail@gmail.com> 1667959432 -0500\ncommitter GitHub <noreply@github.com> 1667959432 -0500\n\nRollup merge of #101381 - Urgau:target-mixup-homogenous-floats, r=Amanieu\n\nTest that target feature mix up with homogeneous floats is sound\n\nThis pull-request adds a test in `src/test/abi/` that test that target feature mix up with homogeneous floats is sound.\n\nThis is basically is ripoff of [src/test/ui/simd/target-feature-mixup.rs](https://github.com/rust-lang/rust/blob/47d1cdb0bcac8e417071ce1929d261efe2399ae2/src/test/ui/simd/target-feature-mixup.rs) but for floats and without `#[repr(simd)]`.\n\n*Extracted from https://github.com/rust-lang/rust/pull/97559 since I don't yet know what to do with that PR.*\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd4e608f7bdee9d283498e58617202aef30547b8", "html_url": "https://github.com/rust-lang/rust/commit/bd4e608f7bdee9d283498e58617202aef30547b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd4e608f7bdee9d283498e58617202aef30547b8/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f162e3a1b1e8025435c177bc0659155bab50ad92", "url": "https://api.github.com/repos/rust-lang/rust/commits/f162e3a1b1e8025435c177bc0659155bab50ad92", "html_url": "https://github.com/rust-lang/rust/commit/f162e3a1b1e8025435c177bc0659155bab50ad92"}, {"sha": "66847ff56b933609618b0899cb3bfdd74f9817d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/66847ff56b933609618b0899cb3bfdd74f9817d5", "html_url": "https://github.com/rust-lang/rust/commit/66847ff56b933609618b0899cb3bfdd74f9817d5"}], "stats": {"total": 192, "additions": 192, "deletions": 0}, "files": [{"sha": "d7f5e19219ed6b7723adb8d9acc4a69910380110", "filename": "src/test/ui/abi/homogenous-floats-target-feature-mixup.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/bd4e608f7bdee9d283498e58617202aef30547b8/src%2Ftest%2Fui%2Fabi%2Fhomogenous-floats-target-feature-mixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4e608f7bdee9d283498e58617202aef30547b8/src%2Ftest%2Fui%2Fabi%2Fhomogenous-floats-target-feature-mixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Fhomogenous-floats-target-feature-mixup.rs?ref=bd4e608f7bdee9d283498e58617202aef30547b8", "patch": "@@ -0,0 +1,192 @@\n+// This test check that even if we mixup target feature of function with homogenous floats,\n+// the abi is sound and still produce the right answer.\n+//\n+// This is basically the same test as src/test/ui/simd/target-feature-mixup.rs but for floats and\n+// without #[repr(simd)]\n+\n+// run-pass\n+// ignore-emscripten\n+// ignore-sgx no processes\n+\n+#![feature(avx512_target_feature)]\n+\n+#![allow(overflowing_literals)]\n+#![allow(unused_variables)]\n+\n+use std::process::{Command, ExitStatus};\n+use std::env;\n+\n+fn main() {\n+    if let Some(level) = env::args().nth(1) {\n+        return test::main(&level)\n+    }\n+\n+    match std::env::var(\"TARGET\") {\n+        Ok(s) => {\n+            // Skip this tests on i586-unknown-linux-gnu where sse2 is disabled\n+            if s.contains(\"i586\") {\n+                return\n+            }\n+        }\n+        Err(_) => return,\n+    }\n+\n+    let me = env::current_exe().unwrap();\n+    for level in [\"sse\", \"avx\", \"avx512\"].iter() {\n+        let status = Command::new(&me).arg(level).status().unwrap();\n+        if status.success() {\n+            println!(\"success with {}\", level);\n+            continue\n+        }\n+\n+        // We don't actually know if our computer has the requisite target features\n+        // for the test below. Testing for that will get added to libstd later so\n+        // for now just assume sigill means this is a machine that can't run this test.\n+        if is_sigill(status) {\n+            println!(\"sigill with {}, assuming spurious\", level);\n+            continue\n+        }\n+        panic!(\"invalid status at {}: {}\", level, status);\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn is_sigill(status: ExitStatus) -> bool {\n+    use std::os::unix::prelude::*;\n+    status.signal() == Some(4)\n+}\n+\n+#[cfg(windows)]\n+fn is_sigill(status: ExitStatus) -> bool {\n+    status.code() == Some(0xc000001d)\n+}\n+\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+#[allow(nonstandard_style)]\n+mod test {\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct f32x2(f32, f32);\n+\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct f32x4(f32, f32, f32, f32);\n+\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct f32x8(f32, f32, f32, f32, f32, f32, f32, f32);\n+\n+    pub fn main(level: &str) {\n+        unsafe {\n+            main_normal(level);\n+            main_sse(level);\n+            if level == \"sse\" {\n+                return\n+            }\n+            main_avx(level);\n+            if level == \"avx\" {\n+                return\n+            }\n+            main_avx512(level);\n+        }\n+    }\n+\n+    macro_rules! mains {\n+        ($(\n+            $(#[$attr:meta])*\n+            unsafe fn $main:ident(level: &str) {\n+                ...\n+            }\n+        )*) => ($(\n+            $(#[$attr])*\n+            unsafe fn $main(level: &str) {\n+                let m128 = f32x2(1., 2.);\n+                let m256 = f32x4(3., 4., 5., 6.);\n+                let m512 = f32x8(7., 8., 9., 10., 11., 12., 13., 14.);\n+                assert_eq!(id_sse_128(m128), m128);\n+                assert_eq!(id_sse_256(m256), m256);\n+                assert_eq!(id_sse_512(m512), m512);\n+\n+                if level == \"sse\" {\n+                    return\n+                }\n+                assert_eq!(id_avx_128(m128), m128);\n+                assert_eq!(id_avx_256(m256), m256);\n+                assert_eq!(id_avx_512(m512), m512);\n+\n+                if level == \"avx\" {\n+                    return\n+                }\n+                assert_eq!(id_avx512_128(m128), m128);\n+                assert_eq!(id_avx512_256(m256), m256);\n+                assert_eq!(id_avx512_512(m512), m512);\n+            }\n+        )*)\n+    }\n+\n+    mains! {\n+        unsafe fn main_normal(level: &str) { ... }\n+        #[target_feature(enable = \"sse2\")]\n+        unsafe fn main_sse(level: &str) { ... }\n+        #[target_feature(enable = \"avx\")]\n+        unsafe fn main_avx(level: &str) { ... }\n+        #[target_feature(enable = \"avx512bw\")]\n+        unsafe fn main_avx512(level: &str) { ... }\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_128(a: f32x2) -> f32x2 {\n+        assert_eq!(a, f32x2(1., 2.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_256(a: f32x4) -> f32x4 {\n+        assert_eq!(a, f32x4(3., 4., 5., 6.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_512(a: f32x8) -> f32x8 {\n+        assert_eq!(a, f32x8(7., 8., 9., 10., 11., 12., 13., 14.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_128(a: f32x2) -> f32x2 {\n+        assert_eq!(a, f32x2(1., 2.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_256(a: f32x4) -> f32x4 {\n+        assert_eq!(a, f32x4(3., 4., 5., 6.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_512(a: f32x8) -> f32x8 {\n+        assert_eq!(a, f32x8(7., 8., 9., 10., 11., 12., 13., 14.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_128(a: f32x2) -> f32x2 {\n+        assert_eq!(a, f32x2(1., 2.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_256(a: f32x4) -> f32x4 {\n+        assert_eq!(a, f32x4(3., 4., 5., 6.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_512(a: f32x8) -> f32x8 {\n+        assert_eq!(a, f32x8(7., 8., 9., 10., 11., 12., 13., 14.));\n+        a.clone()\n+    }\n+}\n+\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+mod test {\n+    pub fn main(level: &str) {}\n+}"}]}