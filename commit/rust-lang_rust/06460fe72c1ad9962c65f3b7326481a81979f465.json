{"sha": "06460fe72c1ad9962c65f3b7326481a81979f465", "node_id": "C_kwDOAAsO6NoAKDA2NDYwZmU3MmMxYWQ5OTYyYzY1ZjNiNzMyNjQ4MWE4MTk3OWY0NjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-03T10:14:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-03T10:14:04Z"}, "message": "Auto merge of #94548 - matthiaskrgr:rollup-spa38z8, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #93562 (Update the documentation for `{As,Into,From}Raw{Fd,Handle,Socket}`.)\n - #94101 (rustdoc: add test cases for hidden enum variants)\n - #94484 (8 - Make more use of `let_chains`)\n - #94522 (Remove out-of-context line at end of E0284 message)\n - #94534 (Re-export (unstable) core::ffi types from std::ffi)\n - #94536 (Move transmute_undefined_repr back to nursery again)\n - #94537 (Use ? operator in one instance instead of manual match)\n - #94544 (Add some examples to comments in mbe code)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "995e3fa69bd6b31587cf138f51b7441aadf188e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/995e3fa69bd6b31587cf138f51b7441aadf188e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06460fe72c1ad9962c65f3b7326481a81979f465", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06460fe72c1ad9962c65f3b7326481a81979f465", "html_url": "https://github.com/rust-lang/rust/commit/06460fe72c1ad9962c65f3b7326481a81979f465", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06460fe72c1ad9962c65f3b7326481a81979f465/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "html_url": "https://github.com/rust-lang/rust/commit/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a"}, {"sha": "88aa75ba8e88666a78cf703f004e480471ceea90", "url": "https://api.github.com/repos/rust-lang/rust/commits/88aa75ba8e88666a78cf703f004e480471ceea90", "html_url": "https://github.com/rust-lang/rust/commit/88aa75ba8e88666a78cf703f004e480471ceea90"}], "stats": {"total": 676, "additions": 363, "deletions": 313}, "files": [{"sha": "5a92f8352d2c194be6d369b7788129311612947b", "filename": "compiler/rustc_error_codes/src/error_codes/E0284.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0284.md", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0284.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0284.md?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -30,5 +30,3 @@ fn main() {\n     d = d + m;\n }\n ```\n-\n-Note that the type of `v` can now be inferred from the type of `temp`."}, {"sha": "a419612e315df2fea566a58fe2f299a007ef90e5", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -345,6 +345,38 @@ fn initial_matcher_pos<'root, 'tt>(ms: &'tt [TokenTree]) -> MatcherPos<'root, 't\n /// token tree. The depth of the `NamedMatch` structure will therefore depend\n /// only on the nesting depth of `ast::TTSeq`s in the originating\n /// token tree it was derived from.\n+///\n+/// In layman's terms: `NamedMatch` will form a tree representing nested matches of a particular\n+/// meta variable. For example, if we are matching the following macro against the following\n+/// invocation...\n+///\n+/// ```rust\n+/// macro_rules! foo {\n+///   ($($($x:ident),+);+) => {}\n+/// }\n+///\n+/// foo!(a, b, c, d; a, b, c, d, e);\n+/// ```\n+///\n+/// Then, the tree will have the following shape:\n+///\n+/// ```rust\n+/// MatchedSeq([\n+///   MatchedSeq([\n+///     MatchedNonterminal(a),\n+///     MatchedNonterminal(b),\n+///     MatchedNonterminal(c),\n+///     MatchedNonterminal(d),\n+///   ]),\n+///   MatchedSeq([\n+///     MatchedNonterminal(a),\n+///     MatchedNonterminal(b),\n+///     MatchedNonterminal(c),\n+///     MatchedNonterminal(d),\n+///     MatchedNonterminal(e),\n+///   ])\n+/// ])\n+/// ```\n #[derive(Debug, Clone)]\n crate enum NamedMatch {\n     MatchedSeq(Lrc<NamedMatchVec>),"}, {"sha": "54000527c15b9bf240b240e8ddd87ec92bbb0911", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -358,6 +358,12 @@ impl LockstepIterSize {\n /// Note that if `repeats` does not match the exact correct depth of a meta-var,\n /// `lookup_cur_matched` will return `None`, which is why this still works even in the presence of\n /// multiple nested matcher sequences.\n+///\n+/// Example: `$($($x $y)+*);+` -- we need to make sure that `x` and `y` repeat the same amount as\n+/// each other at the given depth when the macro was invoked. If they don't it might mean they were\n+/// declared at unequal depths or there was a compile bug. For example, if we have 3 repetitions of\n+/// the outer sequence and 4 repetitions of the inner sequence for `x`, we should have the same for\n+/// `y`; otherwise, we can't transcribe them both at the given depth.\n fn lockstep_iter_size(\n     tree: &mbe::TokenTree,\n     interpolations: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,"}, {"sha": "bf4882d4595730537318ffde91e49cdb1d86e048", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -606,17 +606,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // don't show type `_`\n                     err.span_label(span, format!(\"this expression has type `{}`\", ty));\n                 }\n-                if let Some(ty::error::ExpectedFound { found, .. }) = exp_found {\n-                    if ty.is_box() && ty.boxed_ty() == found {\n-                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                            err.span_suggestion(\n-                                span,\n-                                \"consider dereferencing the boxed value\",\n-                                format!(\"*{}\", snippet),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    }\n+                if let Some(ty::error::ExpectedFound { found, .. }) = exp_found\n+                    && ty.is_box() && ty.boxed_ty() == found\n+                    && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+                {\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider dereferencing the boxed value\",\n+                        format!(\"*{}\", snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n             }\n             ObligationCauseCode::Pattern { origin_expr: false, span: Some(span), .. } => {\n@@ -1748,13 +1747,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.check_and_note_conflicting_crates(diag, terr);\n         self.tcx.note_and_explain_type_err(diag, terr, cause, span, body_owner_def_id.to_def_id());\n \n-        if let Some(ValuePairs::PolyTraitRefs(exp_found)) = values {\n-            if let ty::Closure(def_id, _) = exp_found.expected.skip_binder().self_ty().kind() {\n-                if let Some(def_id) = def_id.as_local() {\n-                    let span = self.tcx.def_span(def_id);\n-                    diag.span_note(span, \"this closure does not fulfill the lifetime requirements\");\n-                }\n-            }\n+        if let Some(ValuePairs::PolyTraitRefs(exp_found)) = values\n+            && let ty::Closure(def_id, _) = exp_found.expected.skip_binder().self_ty().kind()\n+            && let Some(def_id) = def_id.as_local()\n+        {\n+            let span = self.tcx.def_span(def_id);\n+            diag.span_note(span, \"this closure does not fulfill the lifetime requirements\");\n         }\n \n         // It reads better to have the error origin as the final\n@@ -2046,19 +2044,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // containing a single character, perhaps the user meant to write `'c'` to\n                         // specify a character literal (issue #92479)\n                         (ty::Char, ty::Ref(_, r, _)) if r.is_str() => {\n-                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n-                                if let Some(code) =\n-                                    code.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n-                                {\n-                                    if code.chars().count() == 1 {\n-                                        err.span_suggestion(\n-                                            span,\n-                                            \"if you meant to write a `char` literal, use single quotes\",\n-                                            format!(\"'{}'\", code),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                    }\n-                                }\n+                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n+                                && let Some(code) = code.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n+                                && code.chars().count() == 1\n+                            {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"if you meant to write a `char` literal, use single quotes\",\n+                                    format!(\"'{}'\", code),\n+                                    Applicability::MachineApplicable,\n+                                );\n                             }\n                         }\n                         // If a string was expected and the found expression is a character literal,\n@@ -2080,18 +2075,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         _ => {}\n                     }\n                 }\n-                if let MatchExpressionArm(box MatchExpressionArmCause { source, .. }) =\n-                    *trace.cause.code()\n+                let code = trace.cause.code();\n+                if let &MatchExpressionArm(box MatchExpressionArmCause { source, .. }) = code\n+                    && let hir::MatchSource::TryDesugar = source\n+                    && let Some((expected_ty, found_ty)) = self.values_str(trace.values)\n                 {\n-                    if let hir::MatchSource::TryDesugar = source {\n-                        if let Some((expected_ty, found_ty)) = self.values_str(trace.values) {\n-                            err.note(&format!(\n-                                \"`?` operator cannot convert from `{}` to `{}`\",\n-                                found_ty.content(),\n-                                expected_ty.content(),\n-                            ));\n-                        }\n-                    }\n+                    err.note(&format!(\n+                        \"`?` operator cannot convert from `{}` to `{}`\",\n+                        found_ty.content(),\n+                        expected_ty.content(),\n+                    ));\n                 }\n                 err\n             }"}, {"sha": "3bc30f0220d40f64217375936a9bcf802d7f1d32", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -114,28 +114,25 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::Match(scrutinee, [_, arm], MatchSource::ForLoopDesugar) = expr.kind {\n-            if let Some(pat) = arm.pat.for_loop_some() {\n-                if let Some(ty) = self.node_ty_contains_target(pat.hir_id) {\n-                    self.found_for_loop_iter = Some(scrutinee);\n-                    self.found_node_ty = Some(ty);\n-                    return;\n-                }\n-            }\n+        if let ExprKind::Match(scrutinee, [_, arm], MatchSource::ForLoopDesugar) = expr.kind\n+            && let Some(pat) = arm.pat.for_loop_some()\n+            && let Some(ty) = self.node_ty_contains_target(pat.hir_id)\n+        {\n+            self.found_for_loop_iter = Some(scrutinee);\n+            self.found_node_ty = Some(ty);\n+            return;\n         }\n-        if let ExprKind::MethodCall(segment, exprs, _) = expr.kind {\n-            if segment.ident.span == self.target_span\n-                && Some(self.target)\n-                    == self.infcx.in_progress_typeck_results.and_then(|typeck_results| {\n-                        typeck_results\n-                            .borrow()\n-                            .node_type_opt(exprs.first().unwrap().hir_id)\n-                            .map(Into::into)\n-                    })\n-            {\n-                self.found_exact_method_call = Some(&expr);\n-                return;\n-            }\n+        if let ExprKind::MethodCall(segment, exprs, _) = expr.kind\n+            && segment.ident.span == self.target_span\n+            && Some(self.target) == self.infcx.in_progress_typeck_results.and_then(|typeck_results| {\n+                typeck_results\n+                    .borrow()\n+                    .node_type_opt(exprs.first().unwrap().hir_id)\n+                    .map(Into::into)\n+            })\n+        {\n+            self.found_exact_method_call = Some(&expr);\n+            return;\n         }\n \n         // FIXME(const_generics): Currently, any uninferred `const` generics arguments\n@@ -602,10 +599,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         );\n \n         let use_diag = local_visitor.found_use_diagnostic.as_ref();\n-        if let Some(use_diag) = use_diag {\n-            if use_diag.applies_to(err_span) {\n-                use_diag.attach_note(&mut err);\n-            }\n+        if let Some(use_diag) = use_diag && use_diag.applies_to(err_span) {\n+            use_diag.attach_note(&mut err);\n         }\n \n         let param_type = arg_data.kind.descr();\n@@ -736,29 +731,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 //    |               help: specify type like: `<Impl as Into<u32>>::into(foo_impl)`\n                 //    |\n                 //    = note: cannot satisfy `Impl: Into<_>`\n-                if !impl_candidates.is_empty() && e.span.contains(span) {\n-                    if let Some(expr) = exprs.first() {\n-                        if let ExprKind::Path(hir::QPath::Resolved(_, path)) = expr.kind {\n-                            if let [path_segment] = path.segments {\n-                                let candidate_len = impl_candidates.len();\n-                                let suggestions = impl_candidates.iter().map(|candidate| {\n-                                    format!(\n-                                        \"{}::{}({})\",\n-                                        candidate, segment.ident, path_segment.ident\n-                                    )\n-                                });\n-                                err.span_suggestions(\n-                                    e.span,\n-                                    &format!(\n-                                        \"use the fully qualified path for the potential candidate{}\",\n-                                        pluralize!(candidate_len),\n-                                    ),\n-                                    suggestions,\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                        }\n-                    };\n+                if !impl_candidates.is_empty() && e.span.contains(span)\n+                    && let Some(expr) = exprs.first()\n+                    && let ExprKind::Path(hir::QPath::Resolved(_, path)) = expr.kind\n+                    && let [path_segment] = path.segments\n+                {\n+                    let candidate_len = impl_candidates.len();\n+                    let suggestions = impl_candidates.iter().map(|candidate| {\n+                        format!(\n+                            \"{}::{}({})\",\n+                            candidate, segment.ident, path_segment.ident\n+                        )\n+                    });\n+                    err.span_suggestions(\n+                        e.span,\n+                        &format!(\n+                            \"use the fully qualified path for the potential candidate{}\",\n+                            pluralize!(candidate_len),\n+                        ),\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n                 // Suggest specifying type params or point out the return type of the call:\n                 //"}, {"sha": "99dd418015b14e8fa3c43fbb625624aca29453d2", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -223,35 +223,32 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let fn_returns = tcx.return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n \n         let mut override_error_code = None;\n-        if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sup_origin {\n-            if let ObligationCauseCode::UnifyReceiver(ctxt) = cause.code() {\n-                // Handle case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a\n-                // `'static` lifetime when called as a method on a binding: `bar.qux()`.\n-                if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt) {\n-                    override_error_code = Some(ctxt.assoc_item.name);\n-                }\n-            }\n+        if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sup_origin\n+            && let ObligationCauseCode::UnifyReceiver(ctxt) = cause.code()\n+            // Handle case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a\n+            // `'static` lifetime when called as a method on a binding: `bar.qux()`.\n+            && self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt)\n+        {\n+            override_error_code = Some(ctxt.assoc_item.name);\n         }\n-        if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sub_origin {\n-            let code = match cause.code() {\n+\n+        if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sub_origin\n+            && let code = match cause.code() {\n                 ObligationCauseCode::MatchImpl(parent, ..) => parent.code(),\n                 _ => cause.code(),\n-            };\n-            if let (ObligationCauseCode::ItemObligation(item_def_id), None) =\n-                (code, override_error_code)\n+            }\n+            && let (ObligationCauseCode::ItemObligation(item_def_id), None) = (code, override_error_code)\n+        {\n+            // Same case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a `'static`\n+            // lifetime as above, but called using a fully-qualified path to the method:\n+            // `Foo::qux(bar)`.\n+            let mut v = TraitObjectVisitor(FxHashSet::default());\n+            v.visit_ty(param.param_ty);\n+            if let Some((ident, self_ty)) =\n+                self.get_impl_ident_and_self_ty_from_trait(*item_def_id, &v.0)\n+                && self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty)\n             {\n-                // Same case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a `'static`\n-                // lifetime as above, but called using a fully-qualified path to the method:\n-                // `Foo::qux(bar)`.\n-                let mut v = TraitObjectVisitor(FxHashSet::default());\n-                v.visit_ty(param.param_ty);\n-                if let Some((ident, self_ty)) =\n-                    self.get_impl_ident_and_self_ty_from_trait(*item_def_id, &v.0)\n-                {\n-                    if self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty) {\n-                        override_error_code = Some(ident.name);\n-                    }\n-                }\n+                override_error_code = Some(ident.name);\n             }\n         }\n         if let (Some(ident), true) = (override_error_code, fn_returns.is_empty()) {"}, {"sha": "3f0f50bb75af150f32cf25ae190e80142565047e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 26, "deletions": 38, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -23,51 +23,39 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let error = self.error.as_ref()?;\n         debug!(\"try_report_impl_not_conforming_to_trait {:?}\", error);\n         if let RegionResolutionError::SubSupConflict(\n-            _,\n-            var_origin,\n-            sub_origin,\n-            _sub,\n-            sup_origin,\n-            _sup,\n-            _,\n-        ) = error.clone()\n+                _, var_origin, sub_origin, _sub, sup_origin, _sup, _,\n+            ) = error.clone()\n+            && let (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) = (&sup_origin, &sub_origin)\n+            && let (\n+                sub_expected_found @ Some((sub_expected, sub_found)),\n+                sup_expected_found @ Some(_),\n+                CompareImplMethodObligation { trait_item_def_id, .. },\n+            ) = (sub_trace.values.ty(), sup_trace.values.ty(), sub_trace.cause.code())\n+            && sup_expected_found == sub_expected_found\n         {\n-            if let (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) = (&sup_origin, &sub_origin) {\n-                if let (\n-                    sub_expected_found @ Some((sub_expected, sub_found)),\n-                    sup_expected_found @ Some(_),\n-                    CompareImplMethodObligation { trait_item_def_id, .. },\n-                ) = (&sub_trace.values.ty(), &sup_trace.values.ty(), sub_trace.cause.code())\n-                {\n-                    if sup_expected_found == sub_expected_found {\n-                        self.emit_err(\n-                            var_origin.span(),\n-                            *sub_expected,\n-                            *sub_found,\n-                            *trait_item_def_id,\n-                        );\n-                        return Some(ErrorGuaranteed);\n-                    }\n-                }\n-            }\n+            self.emit_err(\n+                var_origin.span(),\n+                sub_expected,\n+                sub_found,\n+                *trait_item_def_id,\n+            );\n+            return Some(ErrorGuaranteed);\n         }\n         if let RegionResolutionError::ConcreteFailure(origin, _, _)\n-        | RegionResolutionError::GenericBoundFailure(origin, _, _) = error.clone()\n-        {\n-            if let SubregionOrigin::CompareImplTypeObligation {\n+            | RegionResolutionError::GenericBoundFailure(origin, _, _) = error.clone()\n+            && let SubregionOrigin::CompareImplTypeObligation {\n                 span,\n                 impl_item_def_id,\n                 trait_item_def_id,\n             } = origin\n-            {\n-                self.emit_associated_type_err(\n-                    span,\n-                    self.infcx.tcx.item_name(impl_item_def_id),\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                );\n-                return Some(ErrorGuaranteed);\n-            }\n+        {\n+            self.emit_associated_type_err(\n+                span,\n+                self.infcx.tcx.item_name(impl_item_def_id),\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            );\n+            return Some(ErrorGuaranteed);\n         }\n         None\n     }"}, {"sha": "c5b90f79dc284645c6e2143ad24e47f51afcc402", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -220,12 +220,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        if let ty::ReVar(vid) = *r {\n-            if self.region_vars.0.contains(&vid) {\n-                let idx = vid.index() - self.region_vars.0.start.index();\n-                let origin = self.region_vars.1[idx];\n-                return self.infcx.next_region_var(origin);\n-            }\n+        if let ty::ReVar(vid) = *r && self.region_vars.0.contains(&vid) {\n+            let idx = vid.index() - self.region_vars.0.start.index();\n+            let origin = self.region_vars.1[idx];\n+            return self.infcx.next_region_var(origin);\n         }\n         r\n     }"}, {"sha": "0f341a947ad35c451ecf692a318e2b576863107a", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -304,10 +304,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // check below for a common case, here purely as an\n                 // optimization.\n                 let b_universe = self.var_infos[b_vid].universe;\n-                if let ReEmpty(a_universe) = *a_region {\n-                    if a_universe == b_universe {\n-                        return false;\n-                    }\n+                if let ReEmpty(a_universe) = *a_region && a_universe == b_universe {\n+                    return false;\n                 }\n \n                 let mut lub = self.lub_concrete_regions(a_region, cur_region);\n@@ -324,10 +322,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // tighter bound than `'static`.\n                 //\n                 // (This might e.g. arise from being asked to prove `for<'a> { 'b: 'a }`.)\n-                if let ty::RePlaceholder(p) = *lub {\n-                    if b_universe.cannot_name(p.universe) {\n-                        lub = self.tcx().lifetimes.re_static;\n-                    }\n+                if let ty::RePlaceholder(p) = *lub && b_universe.cannot_name(p.universe) {\n+                    lub = self.tcx().lifetimes.re_static;\n                 }\n \n                 debug!(\"Expanding value of {:?} from {:?} to {:?}\", b_vid, cur_region, lub);"}, {"sha": "69db6509b798dfa098b1936a04fd41e1b0750cf8", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -963,10 +963,8 @@ where\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"TypeGeneralizer::regions(a={:?})\", a);\n \n-        if let ty::ReLateBound(debruijn, _) = *a {\n-            if debruijn < self.first_free_index {\n-                return Ok(a);\n-            }\n+        if let ty::ReLateBound(debruijn, _) = *a && debruijn < self.first_free_index {\n+            return Ok(a);\n         }\n \n         // For now, we just always create a fresh region variable to"}, {"sha": "6966f5014464ed7c63a69e6d7f89bdd1ecd06c9c", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -470,10 +470,8 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         debug!(\"RegionConstraintCollector: add_verify({:?})\", verify);\n \n         // skip no-op cases known to be satisfied\n-        if let VerifyBound::AllBounds(ref bs) = verify.bound {\n-            if bs.is_empty() {\n-                return;\n-            }\n+        if let VerifyBound::AllBounds(ref bs) = verify.bound && bs.is_empty() {\n+            return;\n         }\n \n         let index = self.data.verifys.len();"}, {"sha": "08e005364ce6410f13d313976fe80424f92ed2b7", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -12,18 +12,19 @@\n //!\n //! This API is completely unstable and subject to change.\n \n+#![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n+#![feature(control_flow_enum)]\n #![feature(derive_default_enum)]\n #![feature(extend_one)]\n+#![feature(label_break_value)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n-#![feature(never_type)]\n-#![feature(control_flow_enum)]\n #![feature(min_specialization)]\n-#![feature(label_break_value)]\n+#![feature(never_type)]\n #![recursion_limit = \"512\"] // For rustdoc\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "c8ef08f48b609b265bbe4b49f70def7dc24edc3a", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -60,12 +60,10 @@ pub fn report_object_safety_error<'tcx>(\n     let mut multi_span = vec![];\n     let mut messages = vec![];\n     for violation in violations {\n-        if let ObjectSafetyViolation::SizedSelf(sp) = &violation {\n-            if !sp.is_empty() {\n-                // Do not report `SizedSelf` without spans pointing at `SizedSelf` obligations\n-                // with a `Span`.\n-                reported_violations.insert(ObjectSafetyViolation::SizedSelf(vec![].into()));\n-            }\n+        if let ObjectSafetyViolation::SizedSelf(sp) = &violation && !sp.is_empty() {\n+            // Do not report `SizedSelf` without spans pointing at `SizedSelf` obligations\n+            // with a `Span`.\n+            reported_violations.insert(ObjectSafetyViolation::SizedSelf(vec![].into()));\n         }\n         if reported_violations.insert(violation.clone()) {\n             let spans = violation.spans();"}, {"sha": "13e3dacc30d63b3636d5766a2af057cddf7b76bb", "filename": "library/std/src/ffi/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -159,6 +159,15 @@ pub use self::os_str::{OsStr, OsString};\n #[stable(feature = \"core_c_void\", since = \"1.30.0\")]\n pub use core::ffi::c_void;\n \n+#[unstable(feature = \"core_ffi_c\", issue = \"94501\")]\n+pub use core::ffi::{\n+    c_char, c_double, c_float, c_int, c_long, c_longlong, c_schar, c_short, c_uchar, c_uint,\n+    c_ulong, c_ulonglong, c_ushort,\n+};\n+\n+#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n+pub use core::ffi::{c_ptrdiff_t, c_size_t, c_ssize_t};\n+\n #[unstable(\n     feature = \"c_variadic\",\n     reason = \"the `c_variadic` feature has not been properly tested on \\"}, {"sha": "10fec8e1152458aaf7f243ea7742025f5cb1fa8d", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -261,6 +261,7 @@\n #![feature(const_socketaddr)]\n #![feature(const_trait_impl)]\n #![feature(container_error_extra)]\n+#![feature(c_size_t)]\n #![feature(core_ffi_c)]\n #![feature(core_intrinsics)]\n #![feature(core_panic)]"}, {"sha": "f9c883dd6bf083d49ffed3dbdafc9ba2a9b3f0b0", "filename": "library/std/src/os/fd/raw.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -5,6 +5,8 @@\n use crate::fs;\n use crate::io;\n use crate::os::raw;\n+#[cfg(doc)]\n+use crate::os::unix::io::AsFd;\n #[cfg(unix)]\n use crate::os::unix::io::OwnedFd;\n #[cfg(target_os = \"wasi\")]\n@@ -24,9 +26,14 @@ pub type RawFd = raw::c_int;\n pub trait AsRawFd {\n     /// Extracts the raw file descriptor.\n     ///\n-    /// This method does **not** pass ownership of the raw file descriptor\n-    /// to the caller. The descriptor is only guaranteed to be valid while\n-    /// the original object has not yet been destroyed.\n+    /// This function is typically used to **borrow** an owned file descriptor.\n+    /// When used in this way, this method does **not** pass ownership of the\n+    /// raw file descriptor to the caller, and the file descriptor is only\n+    /// guaranteed to be valid while the original object has not yet been\n+    /// destroyed.\n+    ///\n+    /// However, borrowing is not strictly required. See [`AsFd::as_fd`]\n+    /// for an API which strictly borrows a file descriptor.\n     ///\n     /// # Example\n     ///\n@@ -55,15 +62,18 @@ pub trait FromRawFd {\n     /// Constructs a new instance of `Self` from the given raw file\n     /// descriptor.\n     ///\n-    /// This function **consumes ownership** of the specified file\n-    /// descriptor. The returned object will take responsibility for closing\n-    /// it when the object goes out of scope.\n+    /// This function is typically used to **consume ownership** of the\n+    /// specified file descriptor. When used in this way, the returned object\n+    /// will take responsibility for closing it when the object goes out of\n+    /// scope.\n+    ///\n+    /// However, consuming ownership is not strictly required. Use a\n+    /// [`From<OwnedFd>::from`] implementation for an API which strictly\n+    /// consumes ownership.\n     ///\n-    /// This function is also unsafe as the primitives currently returned\n-    /// have the contract that they are the sole owner of the file\n-    /// descriptor they are wrapping. Usage of this function could\n-    /// accidentally allow violating this contract which can cause memory\n-    /// unsafety in code that relies on it being true.\n+    /// # Safety\n+    ///\n+    /// The `fd` passed in must be a valid an open file descriptor.\n     ///\n     /// # Example\n     ///\n@@ -94,9 +104,13 @@ pub trait FromRawFd {\n pub trait IntoRawFd {\n     /// Consumes this object, returning the raw underlying file descriptor.\n     ///\n-    /// This function **transfers ownership** of the underlying file descriptor\n-    /// to the caller. Callers are then the unique owners of the file descriptor\n-    /// and must close the descriptor once it's no longer needed.\n+    /// This function is typically used to **transfer ownership** of the underlying\n+    /// file descriptor to the caller. When used in this way, callers are then the unique\n+    /// owners of the file descriptor and must close it once it's no longer needed.\n+    ///\n+    /// However, transferring ownership is not strictly required. Use a\n+    /// [`Into<OwnedFd>::into`] implementation for an API which strictly\n+    /// transfers ownership.\n     ///\n     /// # Example\n     ///"}, {"sha": "d378d591ba3a9f4c5508ba9c2c6c931ef02d25e8", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -214,29 +214,13 @@ impl IntoRawHandle for OwnedHandle {\n }\n \n impl FromRawHandle for OwnedHandle {\n-    /// Constructs a new instance of `Self` from the given raw handle.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The resource pointed to by `handle` must be open and suitable for\n-    /// assuming ownership. The resource must not require any cleanup other\n-    /// than `CloseHandle`.\n-    ///\n-    /// In particular, it must not be used with handles to open registry\n-    /// keys which need to be closed with [`RegCloseKey`] instead.\n-    ///\n-    /// Note that it *may* have the value `INVALID_HANDLE_VALUE` (-1), which is\n-    /// sometimes a valid handle value. See [here] for the full story.\n-    ///\n-    /// [`RegCloseKey`]: https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regclosekey\n-    /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n     #[inline]\n     unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n         Self { handle }\n     }\n }\n \n-impl FromRawHandle for HandleOrNull {\n+impl HandleOrNull {\n     /// Constructs a new instance of `Self` from the given `RawHandle` returned\n     /// from a Windows API that uses null to indicate failure, such as\n     /// `CreateThread`.\n@@ -246,18 +230,18 @@ impl FromRawHandle for HandleOrNull {\n     ///\n     /// # Safety\n     ///\n-    /// The resource pointed to by `handle` must be either open and otherwise\n-    /// unowned, or null. Note that not all Windows APIs use null for errors;\n-    /// see [here] for the full story.\n+    /// The passed `handle` value must either satisfy the safety requirements\n+    /// of [`FromRawHandle::from_raw_handle`], or be null. Note that not all\n+    /// Windows APIs use null for errors; see [here] for the full story.\n     ///\n     /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n     #[inline]\n-    unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n+    pub unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n         Self(OwnedHandle::from_raw_handle(handle))\n     }\n }\n \n-impl FromRawHandle for HandleOrInvalid {\n+impl HandleOrInvalid {\n     /// Constructs a new instance of `Self` from the given `RawHandle` returned\n     /// from a Windows API that uses `INVALID_HANDLE_VALUE` to indicate\n     /// failure, such as `CreateFileW`.\n@@ -267,14 +251,14 @@ impl FromRawHandle for HandleOrInvalid {\n     ///\n     /// # Safety\n     ///\n-    /// The resource pointed to by `handle` must be either open and otherwise\n-    /// unowned, null, or equal to `INVALID_HANDLE_VALUE` (-1). Note that not\n-    /// all Windows APIs use `INVALID_HANDLE_VALUE` for errors; see [here] for\n-    /// the full story.\n+    /// The passed `handle` value must either satisfy the safety requirements\n+    /// of [`FromRawHandle::from_raw_handle`], or be\n+    /// `INVALID_HANDLE_VALUE` (-1). Note that not all Windows APIs use\n+    /// `INVALID_HANDLE_VALUE` for errors; see [here] for the full story.\n     ///\n     /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n     #[inline]\n-    unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n+    pub unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n         Self(OwnedHandle::from_raw_handle(handle))\n     }\n }"}, {"sha": "48c5fd358d9dbbd500c18579bdfcd99cabca3590", "filename": "library/std/src/os/windows/io/raw.rs", "status": "modified", "additions": 72, "deletions": 24, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -5,6 +5,8 @@\n use crate::fs;\n use crate::io;\n use crate::net;\n+#[cfg(doc)]\n+use crate::os::windows::io::{AsHandle, AsSocket};\n use crate::os::windows::io::{OwnedHandle, OwnedSocket};\n use crate::os::windows::raw;\n use crate::sys;\n@@ -22,7 +24,15 @@ pub type RawSocket = raw::SOCKET;\n /// Extracts raw handles.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsRawHandle {\n-    /// Extracts the raw handle, without taking any ownership.\n+    /// Extracts the raw handle.\n+    ///\n+    /// This function is typically used to **borrow** an owned handle.\n+    /// When used in this way, this method does **not** pass ownership of the\n+    /// raw handle to the caller, and the handle is only guaranteed\n+    /// to be valid while the original object has not yet been destroyed.\n+    ///\n+    /// However, borrowing is not strictly required. See [`AsHandle::as_handle`]\n+    /// for an API which strictly borrows a handle.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_raw_handle(&self) -> RawHandle;\n }\n@@ -32,15 +42,28 @@ pub trait AsRawHandle {\n pub trait FromRawHandle {\n     /// Constructs a new I/O object from the specified raw handle.\n     ///\n-    /// This function will **consume ownership** of the handle given,\n-    /// passing responsibility for closing the handle to the returned\n-    /// object.\n+    /// This function is typically used to **consume ownership** of the handle\n+    /// given, passing responsibility for closing the handle to the returned\n+    /// object. When used in this way, the returned object\n+    /// will take responsibility for closing it when the object goes out of\n+    /// scope.\n+    ///\n+    /// However, consuming ownership is not strictly required. Use a\n+    /// `From<OwnedHandle>::from` implementation for an API which strictly\n+    /// consumes ownership.\n+    ///\n+    /// # Safety\n     ///\n-    /// This function is also unsafe as the primitives currently returned\n-    /// have the contract that they are the sole owner of the file\n-    /// descriptor they are wrapping. Usage of this function could\n-    /// accidentally allow violating this contract which can cause memory\n-    /// unsafety in code that relies on it being true.\n+    /// The `handle` passed in must:\n+    ///   - be a valid an open handle,\n+    ///   - be a handle for a resource that may be freed via [`CloseHandle`]\n+    ///     (as opposed to `RegCloseKey` or other close functions).\n+    ///\n+    /// Note that the handle *may* have the value `INVALID_HANDLE_VALUE` (-1),\n+    /// which is sometimes a valid handle value. See [here] for the full story.\n+    ///\n+    /// [`CloseHandle`]: https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle\n+    /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n     #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n     unsafe fn from_raw_handle(handle: RawHandle) -> Self;\n }\n@@ -51,9 +74,13 @@ pub trait FromRawHandle {\n pub trait IntoRawHandle {\n     /// Consumes this object, returning the raw underlying handle.\n     ///\n-    /// This function **transfers ownership** of the underlying handle to the\n-    /// caller. Callers are then the unique owners of the handle and must close\n-    /// it once it's no longer needed.\n+    /// This function is typically used to **transfer ownership** of the underlying\n+    /// handle to the caller. When used in this way, callers are then the unique\n+    /// owners of the handle and must close it once it's no longer needed.\n+    ///\n+    /// However, transferring ownership is not strictly required. Use a\n+    /// `Into<OwnedHandle>::into` implementation for an API which strictly\n+    /// transfers ownership.\n     #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n     fn into_raw_handle(self) -> RawHandle;\n }\n@@ -130,24 +157,41 @@ impl IntoRawHandle for fs::File {\n /// Extracts raw sockets.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsRawSocket {\n-    /// Extracts the underlying raw socket from this object.\n+    /// Extracts the raw socket.\n+    ///\n+    /// This function is typically used to **borrow** an owned socket.\n+    /// When used in this way, this method does **not** pass ownership of the\n+    /// raw socket to the caller, and the socket is only guaranteed\n+    /// to be valid while the original object has not yet been destroyed.\n+    ///\n+    /// However, borrowing is not strictly required. See [`AsSocket::as_socket`]\n+    /// for an API which strictly borrows a socket.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_raw_socket(&self) -> RawSocket;\n }\n \n /// Creates I/O objects from raw sockets.\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n pub trait FromRawSocket {\n-    /// Creates a new I/O object from the given raw socket.\n+    /// Constructs a new I/O object from the specified raw socket.\n+    ///\n+    /// This function is typically used to **consume ownership** of the socket\n+    /// given, passing responsibility for closing the socket to the returned\n+    /// object. When used in this way, the returned object\n+    /// will take responsibility for closing it when the object goes out of\n+    /// scope.\n     ///\n-    /// This function will **consume ownership** of the socket provided and\n-    /// it will be closed when the returned object goes out of scope.\n+    /// However, consuming ownership is not strictly required. Use a\n+    /// `From<OwnedSocket>::from` implementation for an API which strictly\n+    /// consumes ownership.\n     ///\n-    /// This function is also unsafe as the primitives currently returned\n-    /// have the contract that they are the sole owner of the file\n-    /// descriptor they are wrapping. Usage of this function could\n-    /// accidentally allow violating this contract which can cause memory\n-    /// unsafety in code that relies on it being true.\n+    /// # Safety\n+    ///\n+    /// The `socket` passed in must:\n+    ///   - be a valid an open socket,\n+    ///   - be a socket that may be freed via [`closesocket`].\n+    ///\n+    /// [`closesocket`]: https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-closesocket\n     #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n     unsafe fn from_raw_socket(sock: RawSocket) -> Self;\n }\n@@ -158,9 +202,13 @@ pub trait FromRawSocket {\n pub trait IntoRawSocket {\n     /// Consumes this object, returning the raw underlying socket.\n     ///\n-    /// This function **transfers ownership** of the underlying socket to the\n-    /// caller. Callers are then the unique owners of the socket and must close\n-    /// it once it's no longer needed.\n+    /// This function is typically used to **transfer ownership** of the underlying\n+    /// socket to the caller. When used in this way, callers are then the unique\n+    /// owners of the socket and must close it once it's no longer needed.\n+    ///\n+    /// However, transferring ownership is not strictly required. Use a\n+    /// `Into<OwnedSocket>::into` implementation for an API which strictly\n+    /// transfers ownership.\n     #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n     fn into_raw_socket(self) -> RawSocket;\n }"}, {"sha": "a6b979cc22bd3777d33bb0f25f9b34e72c84a698", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -172,13 +172,6 @@ impl IntoRawSocket for OwnedSocket {\n }\n \n impl FromRawSocket for OwnedSocket {\n-    /// Constructs a new instance of `Self` from the given raw socket.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The resource pointed to by `socket` must be open and suitable for\n-    /// assuming ownership. The resource must not require cleanup other than\n-    /// `closesocket`.\n     #[inline]\n     unsafe fn from_raw_socket(socket: RawSocket) -> Self {\n         debug_assert_ne!(socket, c::INVALID_SOCKET as RawSocket);"}, {"sha": "63a8e85f7c54044413df3e4c6551f6697fe6b059", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 48, "deletions": 51, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -111,58 +111,55 @@ crate fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n     let externs = options.externs.clone();\n     let json_unused_externs = options.json_unused_externs;\n \n-    let res = interface::run_compiler(config, |compiler| {\n-        compiler.enter(|queries| {\n-            let mut global_ctxt = queries.global_ctxt()?.take();\n-\n-            let collector = global_ctxt.enter(|tcx| {\n-                let crate_attrs = tcx.hir().attrs(CRATE_HIR_ID);\n-\n-                let opts = scrape_test_config(crate_attrs);\n-                let enable_per_target_ignores = options.enable_per_target_ignores;\n-                let mut collector = Collector::new(\n-                    tcx.crate_name(LOCAL_CRATE),\n-                    options,\n-                    false,\n-                    opts,\n-                    Some(compiler.session().parse_sess.clone_source_map()),\n-                    None,\n-                    enable_per_target_ignores,\n-                );\n-\n-                let mut hir_collector = HirCollector {\n-                    sess: compiler.session(),\n-                    collector: &mut collector,\n-                    map: tcx.hir(),\n-                    codes: ErrorCodes::from(\n-                        compiler.session().opts.unstable_features.is_nightly_build(),\n-                    ),\n-                    tcx,\n-                };\n-                hir_collector.visit_testable(\n-                    \"\".to_string(),\n-                    CRATE_HIR_ID,\n-                    tcx.hir().span(CRATE_HIR_ID),\n-                    |this| tcx.hir().walk_toplevel_module(this),\n-                );\n-\n-                collector\n-            });\n-            if compiler.session().diagnostic().has_errors_or_lint_errors() {\n-                FatalError.raise();\n-            }\n+    let (tests, unused_extern_reports, compiling_test_count) =\n+        interface::run_compiler(config, |compiler| {\n+            compiler.enter(|queries| {\n+                let mut global_ctxt = queries.global_ctxt()?.take();\n+\n+                let collector = global_ctxt.enter(|tcx| {\n+                    let crate_attrs = tcx.hir().attrs(CRATE_HIR_ID);\n+\n+                    let opts = scrape_test_config(crate_attrs);\n+                    let enable_per_target_ignores = options.enable_per_target_ignores;\n+                    let mut collector = Collector::new(\n+                        tcx.crate_name(LOCAL_CRATE),\n+                        options,\n+                        false,\n+                        opts,\n+                        Some(compiler.session().parse_sess.clone_source_map()),\n+                        None,\n+                        enable_per_target_ignores,\n+                    );\n+\n+                    let mut hir_collector = HirCollector {\n+                        sess: compiler.session(),\n+                        collector: &mut collector,\n+                        map: tcx.hir(),\n+                        codes: ErrorCodes::from(\n+                            compiler.session().opts.unstable_features.is_nightly_build(),\n+                        ),\n+                        tcx,\n+                    };\n+                    hir_collector.visit_testable(\n+                        \"\".to_string(),\n+                        CRATE_HIR_ID,\n+                        tcx.hir().span(CRATE_HIR_ID),\n+                        |this| tcx.hir().walk_toplevel_module(this),\n+                    );\n+\n+                    collector\n+                });\n+                if compiler.session().diagnostic().has_errors_or_lint_errors() {\n+                    FatalError.raise();\n+                }\n \n-            let unused_extern_reports = collector.unused_extern_reports.clone();\n-            let compiling_test_count = collector.compiling_test_count.load(Ordering::SeqCst);\n-            let ret: Result<_, ErrorGuaranteed> =\n-                Ok((collector.tests, unused_extern_reports, compiling_test_count));\n-            ret\n-        })\n-    });\n-    let (tests, unused_extern_reports, compiling_test_count) = match res {\n-        Ok(res) => res,\n-        Err(ErrorGuaranteed) => return Err(ErrorGuaranteed),\n-    };\n+                let unused_extern_reports = collector.unused_extern_reports.clone();\n+                let compiling_test_count = collector.compiling_test_count.load(Ordering::SeqCst);\n+                let ret: Result<_, ErrorGuaranteed> =\n+                    Ok((collector.tests, unused_extern_reports, compiling_test_count));\n+                ret\n+            })\n+        })?;\n \n     run_tests(test_args, nocapture, tests);\n "}, {"sha": "12e576100710ac346bd04a0aae45971967da9ca1", "filename": "src/test/rustdoc/strip-enum-variant.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Ftest%2Frustdoc%2Fstrip-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Ftest%2Frustdoc%2Fstrip-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstrip-enum-variant.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -0,0 +1,9 @@\n+// @has strip_enum_variant/enum.MyThing.html\n+// @has - '//code' 'Shown'\n+// @!has - '//code' 'NotShown'\n+// @has - '//code' '// some variants omitted'\n+pub enum MyThing {\n+    Shown,\n+    #[doc(hidden)]\n+    NotShown,\n+}"}, {"sha": "abfb46035376a3cd792ed6c3ea9cf67746591848", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -281,7 +281,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n     LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n-    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "d7bf91eb69214e813ddf10133ab03f2bcbee0d4d", "filename": "src/tools/clippy/clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -58,7 +58,6 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(serde_api::SERDE_API_MISUSE),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),\n-    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "8d4dde42bbecad322b0d3ba28da5e24a8ac8d7f2", "filename": "src/tools/clippy/clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -26,6 +26,7 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(strings::STRING_LIT_AS_BYTES),\n     LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n     LintId::of(trailing_empty_array::TRAILING_EMPTY_ARRAY),\n+    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::USELESS_TRANSMUTE),\n     LintId::of(use_self::USE_SELF),\n ])"}, {"sha": "1da3b765904813d4407d31d622b6a36049392d6e", "filename": "src/tools/clippy/clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06460fe72c1ad9962c65f3b7326481a81979f465/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=06460fe72c1ad9962c65f3b7326481a81979f465", "patch": "@@ -377,7 +377,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.60.0\"]\n     pub TRANSMUTE_UNDEFINED_REPR,\n-    correctness,\n+    nursery,\n     \"transmute to or from a type with an undefined representation\"\n }\n "}]}