{"sha": "62f594b390e5f648a32b5b08863a6413b4271d19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZjU5NGIzOTBlNWY2NDhhMzJiNWIwODg2M2E2NDEzYjQyNzFkMTk=", "commit": {"author": {"name": "Kevin Mehall", "email": "km@kevinmehall.net", "date": "2021-03-06T16:46:32Z"}, "committer": {"name": "Kevin Mehall", "email": "km@kevinmehall.net", "date": "2021-03-06T16:48:30Z"}, "message": "Refactor TokenStream to hold Vec<TokenTree> instead of tt::Subtree\n\n`TokenStream` assumes that its subtree's delimeter is `None`, and this\nshould be encoded in the type system instead of having a delimiter field\nthat is mostly ignored.\n\n`tt::Subtree` is just `pub delimiter: Option<Delimiter>, pub\ntoken_trees: Vec<TokenTree>`, so a Subtree that is statically guaranteed\nnot to have a delimiter is just Vec<TokenTree>.", "tree": {"sha": "47de88bc047e957149544f48f2696f2706b9ed4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47de88bc047e957149544f48f2696f2706b9ed4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62f594b390e5f648a32b5b08863a6413b4271d19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62f594b390e5f648a32b5b08863a6413b4271d19", "html_url": "https://github.com/rust-lang/rust/commit/62f594b390e5f648a32b5b08863a6413b4271d19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62f594b390e5f648a32b5b08863a6413b4271d19/comments", "author": {"login": "kevinmehall", "id": 119951, "node_id": "MDQ6VXNlcjExOTk1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/119951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kevinmehall", "html_url": "https://github.com/kevinmehall", "followers_url": "https://api.github.com/users/kevinmehall/followers", "following_url": "https://api.github.com/users/kevinmehall/following{/other_user}", "gists_url": "https://api.github.com/users/kevinmehall/gists{/gist_id}", "starred_url": "https://api.github.com/users/kevinmehall/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kevinmehall/subscriptions", "organizations_url": "https://api.github.com/users/kevinmehall/orgs", "repos_url": "https://api.github.com/users/kevinmehall/repos", "events_url": "https://api.github.com/users/kevinmehall/events{/privacy}", "received_events_url": "https://api.github.com/users/kevinmehall/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kevinmehall", "id": 119951, "node_id": "MDQ6VXNlcjExOTk1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/119951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kevinmehall", "html_url": "https://github.com/kevinmehall", "followers_url": "https://api.github.com/users/kevinmehall/followers", "following_url": "https://api.github.com/users/kevinmehall/following{/other_user}", "gists_url": "https://api.github.com/users/kevinmehall/gists{/gist_id}", "starred_url": "https://api.github.com/users/kevinmehall/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kevinmehall/subscriptions", "organizations_url": "https://api.github.com/users/kevinmehall/orgs", "repos_url": "https://api.github.com/users/kevinmehall/repos", "events_url": "https://api.github.com/users/kevinmehall/events{/privacy}", "received_events_url": "https://api.github.com/users/kevinmehall/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "632fa8ef4a3c9e7440b79e04a9f7dd9bd23a4de4", "url": "https://api.github.com/repos/rust-lang/rust/commits/632fa8ef4a3c9e7440b79e04a9f7dd9bd23a4de4", "html_url": "https://github.com/rust-lang/rust/commit/632fa8ef4a3c9e7440b79e04a9f7dd9bd23a4de4"}], "stats": {"total": 121, "additions": 56, "deletions": 65}, "files": [{"sha": "baf10fea9376166273ef0e6248b07b971cf81dca", "filename": "crates/proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62f594b390e5f648a32b5b08863a6413b4271d19/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f594b390e5f648a32b5b08863a6413b4271d19/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs?ref=62f594b390e5f648a32b5b08863a6413b4271d19", "patch": "@@ -138,7 +138,7 @@ impl Expander {\n                         parsed_body,\n                         false,\n                     );\n-                    return res.map(|it| it.subtree);\n+                    return res.map(|it| it.into_subtree());\n                 }\n                 bridge::client::ProcMacro::Bang { name, client } if *name == macro_name => {\n                     let res = client.run(\n@@ -147,7 +147,7 @@ impl Expander {\n                         parsed_body,\n                         false,\n                     );\n-                    return res.map(|it| it.subtree);\n+                    return res.map(|it| it.into_subtree());\n                 }\n                 bridge::client::ProcMacro::Attr { name, client } if *name == macro_name => {\n                     let res = client.run(\n@@ -157,7 +157,7 @@ impl Expander {\n                         parsed_body,\n                         false,\n                     );\n-                    return res.map(|it| it.subtree);\n+                    return res.map(|it| it.into_subtree());\n                 }\n                 _ => continue,\n             }"}, {"sha": "2798dbf0d7f33b3cafeae367589cb5bb426a8a45", "filename": "crates/proc_macro_srv/src/rustc_server.rs", "status": "modified", "additions": 52, "deletions": 61, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/62f594b390e5f648a32b5b08863a6413b4271d19/crates%2Fproc_macro_srv%2Fsrc%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f594b390e5f648a32b5b08863a6413b4271d19/crates%2Fproc_macro_srv%2Fsrc%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Frustc_server.rs?ref=62f594b390e5f648a32b5b08863a6413b4271d19", "patch": "@@ -25,36 +25,35 @@ type Span = tt::TokenId;\n \n #[derive(Debug, Clone)]\n pub struct TokenStream {\n-    pub subtree: tt::Subtree,\n+    pub token_trees: Vec<TokenTree>,\n }\n \n impl TokenStream {\n     pub fn new() -> Self {\n-        TokenStream { subtree: Default::default() }\n+        TokenStream { token_trees: Default::default() }\n     }\n \n     pub fn with_subtree(subtree: tt::Subtree) -> Self {\n         if subtree.delimiter.is_some() {\n-            TokenStream {\n-                subtree: tt::Subtree {\n-                    token_trees: vec![TokenTree::Subtree(subtree)],\n-                    delimiter: None,\n-                },\n-            }\n+            TokenStream { token_trees: vec![TokenTree::Subtree(subtree)] }\n         } else {\n-            TokenStream { subtree }\n+            TokenStream { token_trees: subtree.token_trees }\n         }\n     }\n \n+    pub fn into_subtree(self) -> tt::Subtree {\n+        tt::Subtree { delimiter: None, token_trees: self.token_trees }\n+    }\n+\n     pub fn is_empty(&self) -> bool {\n-        self.subtree.token_trees.is_empty()\n+        self.token_trees.is_empty()\n     }\n }\n \n /// Creates a token stream containing a single token tree.\n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream { subtree: tt::Subtree { delimiter: None, token_trees: vec![tree] } }\n+        TokenStream { token_trees: vec![tree] }\n     }\n }\n \n@@ -87,10 +86,10 @@ impl Extend<TokenStream> for TokenStream {\n             for tkn in item {\n                 match tkn {\n                     tt::TokenTree::Subtree(subtree) if subtree.delimiter.is_none() => {\n-                        self.subtree.token_trees.extend(subtree.token_trees);\n+                        self.token_trees.extend(subtree.token_trees);\n                     }\n                     _ => {\n-                        self.subtree.token_trees.push(tkn);\n+                        self.token_trees.push(tkn);\n                     }\n                 }\n             }\n@@ -173,7 +172,7 @@ pub mod token_stream {\n         type IntoIter = super::IntoIter<TokenTree>;\n \n         fn into_iter(self) -> Self::IntoIter {\n-            self.subtree.token_trees.into_iter()\n+            self.token_trees.into_iter()\n         }\n     }\n \n@@ -200,32 +199,32 @@ pub mod token_stream {\n \n     impl ToString for TokenStream {\n         fn to_string(&self) -> String {\n-            let tt = self.subtree.clone().into();\n-            to_text(&tt)\n+            tokentrees_to_text(&self.token_trees[..])\n         }\n     }\n \n-    fn to_text(tkn: &tt::TokenTree) -> String {\n+    fn tokentrees_to_text(tkns: &[tt::TokenTree]) -> String {\n+        tkns.iter()\n+            .fold((String::new(), true), |(last, last_to_joint), tkn| {\n+                let s = [last, tokentree_to_text(tkn)].join(if last_to_joint { \"\" } else { \" \" });\n+                let mut is_joint = false;\n+                if let tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) = tkn {\n+                    if punct.spacing == tt::Spacing::Joint {\n+                        is_joint = true;\n+                    }\n+                }\n+                (s, is_joint)\n+            })\n+            .0\n+    }\n+\n+    fn tokentree_to_text(tkn: &tt::TokenTree) -> String {\n         match tkn {\n             tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => ident.text.clone().into(),\n             tt::TokenTree::Leaf(tt::Leaf::Literal(literal)) => literal.text.clone().into(),\n             tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => format!(\"{}\", punct.char),\n             tt::TokenTree::Subtree(subtree) => {\n-                let content = subtree\n-                    .token_trees\n-                    .iter()\n-                    .fold((String::new(), true), |(last, last_to_joint), tkn| {\n-                        let s = [last, to_text(tkn)].join(if last_to_joint { \"\" } else { \" \" });\n-                        let mut is_joint = false;\n-                        if let tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) = tkn {\n-                            if punct.spacing == tt::Spacing::Joint {\n-                                is_joint = true;\n-                            }\n-                        }\n-                        (s, is_joint)\n-                    })\n-                    .0;\n-\n+                let content = tokentrees_to_text(&subtree.token_trees);\n                 let (open, close) = match subtree.delimiter.map(|it| it.kind) {\n                     None => (\"\", \"\"),\n                     Some(tt::DelimiterKind::Brace) => (\"{\", \"}\"),\n@@ -442,20 +441,15 @@ fn spacing_to_external(spacing: Spacing) -> bridge::Spacing {\n \n impl server::Group for Rustc {\n     fn new(&mut self, delimiter: bridge::Delimiter, stream: Self::TokenStream) -> Self::Group {\n-        Self::Group {\n-            delimiter: delim_to_internal(delimiter),\n-            token_trees: stream.subtree.token_trees,\n-        }\n+        Self::Group { delimiter: delim_to_internal(delimiter), token_trees: stream.token_trees }\n     }\n     fn delimiter(&mut self, group: &Self::Group) -> bridge::Delimiter {\n         delim_to_external(group.delimiter)\n     }\n \n     // NOTE: Return value of do not include delimiter\n     fn stream(&mut self, group: &Self::Group) -> Self::TokenStream {\n-        TokenStream {\n-            subtree: tt::Subtree { delimiter: None, token_trees: group.token_trees.clone() },\n-        }\n+        TokenStream { token_trees: group.token_trees.clone() }\n     }\n \n     fn span(&mut self, group: &Self::Group) -> Self::Span {\n@@ -764,26 +758,23 @@ mod tests {\n     #[test]\n     fn test_rustc_server_to_string() {\n         let s = TokenStream {\n-            subtree: tt::Subtree {\n-                delimiter: None,\n-                token_trees: vec![\n-                    tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                        text: \"struct\".into(),\n-                        id: tt::TokenId::unspecified(),\n-                    })),\n-                    tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                        text: \"T\".into(),\n+            token_trees: vec![\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                    text: \"struct\".into(),\n+                    id: tt::TokenId::unspecified(),\n+                })),\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                    text: \"T\".into(),\n+                    id: tt::TokenId::unspecified(),\n+                })),\n+                tt::TokenTree::Subtree(tt::Subtree {\n+                    delimiter: Some(tt::Delimiter {\n                         id: tt::TokenId::unspecified(),\n-                    })),\n-                    tt::TokenTree::Subtree(tt::Subtree {\n-                        delimiter: Some(tt::Delimiter {\n-                            id: tt::TokenId::unspecified(),\n-                            kind: tt::DelimiterKind::Brace,\n-                        }),\n-                        token_trees: vec![],\n+                        kind: tt::DelimiterKind::Brace,\n                     }),\n-                ],\n-            },\n+                    token_trees: vec![],\n+                }),\n+            ],\n         };\n \n         assert_eq!(s.to_string(), \"struct T {}\");\n@@ -804,11 +795,11 @@ mod tests {\n         });\n \n         let t1 = TokenStream::from_str(\"(a)\").unwrap();\n-        assert_eq!(t1.subtree.token_trees.len(), 1);\n-        assert_eq!(t1.subtree.token_trees[0], subtree_paren_a);\n+        assert_eq!(t1.token_trees.len(), 1);\n+        assert_eq!(t1.token_trees[0], subtree_paren_a);\n \n         let t2 = TokenStream::from_str(\"(a);\").unwrap();\n-        assert_eq!(t2.subtree.token_trees.len(), 2);\n-        assert_eq!(t2.subtree.token_trees[0], subtree_paren_a);\n+        assert_eq!(t2.token_trees.len(), 2);\n+        assert_eq!(t2.token_trees[0], subtree_paren_a);\n     }\n }"}, {"sha": "0484c3af449831205254f6cb2d8f4be07493a44c", "filename": "crates/proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62f594b390e5f648a32b5b08863a6413b4271d19/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f594b390e5f648a32b5b08863a6413b4271d19/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=62f594b390e5f648a32b5b08863a6413b4271d19", "patch": "@@ -52,7 +52,7 @@ pub fn assert_expand(\n     let expander = dylib::Expander::new(&path).unwrap();\n     let fixture = parse_string(ra_fixture).unwrap();\n \n-    let res = expander.expand(macro_name, &fixture.subtree, None).unwrap();\n+    let res = expander.expand(macro_name, &fixture.into_subtree(), None).unwrap();\n     assert_eq_text!(&expect.trim(), &format!(\"{:?}\", res));\n }\n "}]}