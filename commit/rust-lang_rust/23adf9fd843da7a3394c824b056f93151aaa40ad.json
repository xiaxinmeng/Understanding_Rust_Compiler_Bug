{"sha": "23adf9fd843da7a3394c824b056f93151aaa40ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzYWRmOWZkODQzZGE3YTMzOTRjODI0YjA1NmY5MzE1MWFhYTQwYWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-05T18:21:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-05T18:21:47Z"}, "message": "Auto merge of #81215 - cjgillot:defkey-mir, r=oli-obk\n\nEncode MIR metadata by iterating on DefId instead of traversing the HIR tree\n\nSplit out of https://github.com/rust-lang/rust/pull/80347.\n\nThis part only traverses `mir_keys` and encodes MIR according to the def kind.\n\nr? `@oli-obk`", "tree": {"sha": "d64ce9f20fab4af918ae21132975f3f8a13d2f7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d64ce9f20fab4af918ae21132975f3f8a13d2f7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23adf9fd843da7a3394c824b056f93151aaa40ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23adf9fd843da7a3394c824b056f93151aaa40ad", "html_url": "https://github.com/rust-lang/rust/commit/23adf9fd843da7a3394c824b056f93151aaa40ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23adf9fd843da7a3394c824b056f93151aaa40ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5605b5d693ac0aba5b506923e3e99ec927969d04", "url": "https://api.github.com/repos/rust-lang/rust/commits/5605b5d693ac0aba5b506923e3e99ec927969d04", "html_url": "https://github.com/rust-lang/rust/commit/5605b5d693ac0aba5b506923e3e99ec927969d04"}, {"sha": "09ac459bc71c496a94db9d1a6e13c5d3ed35716c", "url": "https://api.github.com/repos/rust-lang/rust/commits/09ac459bc71c496a94db9d1a6e13c5d3ed35716c", "html_url": "https://github.com/rust-lang/rust/commit/09ac459bc71c496a94db9d1a6e13c5d3ed35716c"}], "stats": {"total": 318, "additions": 103, "deletions": 215}, "files": [{"sha": "dd6a6fe62487fd3df68db4de03c281875a3351e0", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 103, "deletions": 215, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/23adf9fd843da7a3394c824b056f93151aaa40ad/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23adf9fd843da7a3394c824b056f93151aaa40ad/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=23adf9fd843da7a3394c824b056f93151aaa40ad", "patch": "@@ -2,15 +2,15 @@ use crate::rmeta::table::{FixedSizeEncoding, TableBuilder};\n use crate::rmeta::*;\n \n use rustc_data_structures::fingerprint::{Fingerprint, FingerprintEncoder};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n-use rustc_data_structures::sync::{join, Lrc};\n+use rustc_data_structures::sync::{join, par_iter, Lrc, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::itemlikevisit::{ItemLikeVisitor, ParItemLikeVisitor};\n+use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items;\n use rustc_hir::{AnonConst, GenericParamKind};\n use rustc_index::bit_set::GrowableBitSet;\n@@ -65,11 +65,6 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n     required_source_files: Option<GrowableBitSet<usize>>,\n     is_proc_macro: bool,\n     hygiene_ctxt: &'a HygieneEncodeContext,\n-\n-    // Determines if MIR used for code generation will be included in the crate\n-    // metadata. When emitting only metadata (e.g., cargo check), we can avoid\n-    // generating optimized MIR altogether.\n-    emit_codegen_mir: bool,\n }\n \n /// If the current crate is a proc-macro, returns early with `Lazy:empty()`.\n@@ -580,6 +575,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // Encode the items.\n         i = self.position();\n         self.encode_def_ids();\n+        self.encode_mir();\n         self.encode_info_for_items();\n         let item_bytes = self.position() - i;\n \n@@ -785,6 +781,53 @@ fn should_encode_stability(def_kind: DefKind) -> bool {\n     }\n }\n \n+/// Whether we should encode MIR.\n+///\n+/// Computing, optimizing and encoding the MIR is a relatively expensive operation.\n+/// We want to avoid this work when not required. Therefore:\n+/// - we only compute `mir_for_ctfe` on items with const-eval semantics;\n+/// - we skip `optimized_mir` for check runs.\n+///\n+/// Return a pair, resp. for CTFE and for LLVM.\n+fn should_encode_mir(tcx: TyCtxt<'_>, def_id: LocalDefId) -> (bool, bool) {\n+    match tcx.def_kind(def_id) {\n+        // Constructors\n+        DefKind::Ctor(_, _) => {\n+            let mir_opt_base = tcx.sess.opts.output_types.should_codegen()\n+                || tcx.sess.opts.debugging_opts.always_encode_mir;\n+            (true, mir_opt_base)\n+        }\n+        // Constants\n+        DefKind::AnonConst | DefKind::AssocConst | DefKind::Static | DefKind::Const => {\n+            (true, false)\n+        }\n+        // Full-fledged functions\n+        DefKind::AssocFn | DefKind::Fn => {\n+            let generics = tcx.generics_of(def_id);\n+            let needs_inline = (generics.requires_monomorphization(tcx)\n+                || tcx.codegen_fn_attrs(def_id).requests_inline())\n+                && tcx.sess.opts.output_types.should_codegen();\n+            // Only check the presence of the `const` modifier.\n+            let is_const_fn = tcx.is_const_fn_raw(def_id.to_def_id());\n+            let always_encode_mir = tcx.sess.opts.debugging_opts.always_encode_mir;\n+            (is_const_fn, needs_inline || always_encode_mir)\n+        }\n+        // Closures can't be const fn.\n+        DefKind::Closure => {\n+            let generics = tcx.generics_of(def_id);\n+            let needs_inline = (generics.requires_monomorphization(tcx)\n+                || tcx.codegen_fn_attrs(def_id).requests_inline())\n+                && tcx.sess.opts.output_types.should_codegen();\n+            let always_encode_mir = tcx.sess.opts.debugging_opts.always_encode_mir;\n+            (false, needs_inline || always_encode_mir)\n+        }\n+        // Generators require optimized MIR to compute layout.\n+        DefKind::Generator => (false, true),\n+        // The others don't have MIR.\n+        _ => (false, false),\n+    }\n+}\n+\n impl EncodeContext<'a, 'tcx> {\n     fn encode_def_ids(&mut self) {\n         if self.is_proc_macro {\n@@ -882,11 +925,6 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n         self.encode_inferred_outlives(def_id);\n-        let opt_mir = tcx.sess.opts.debugging_opts.always_encode_mir || self.emit_codegen_mir;\n-        if opt_mir {\n-            self.encode_optimized_mir(def_id.expect_local());\n-        }\n-        self.encode_mir_for_ctfe(def_id.expect_local());\n     }\n \n     fn encode_info_for_mod(&mut self, id: hir::HirId, md: &hir::Mod<'_>) {\n@@ -972,11 +1010,6 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n         self.encode_inferred_outlives(def_id);\n-        let opt_mir = tcx.sess.opts.debugging_opts.always_encode_mir || self.emit_codegen_mir;\n-        if opt_mir {\n-            self.encode_optimized_mir(def_id.expect_local());\n-        }\n-        self.encode_mir_for_ctfe(def_id.expect_local());\n     }\n \n     fn encode_generics(&mut self, def_id: DefId) {\n@@ -1082,34 +1115,6 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n         self.encode_inferred_outlives(def_id);\n-\n-        // This should be kept in sync with `PrefetchVisitor.visit_trait_item`.\n-        match trait_item.kind {\n-            ty::AssocKind::Type => {}\n-            ty::AssocKind::Const => {\n-                if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id.expect_local()) {\n-                    self.encode_mir_for_ctfe(def_id.expect_local());\n-                    self.encode_promoted_mir(def_id.expect_local());\n-                }\n-            }\n-            ty::AssocKind::Fn => {\n-                let opt_mir =\n-                    tcx.sess.opts.debugging_opts.always_encode_mir || self.emit_codegen_mir;\n-                if opt_mir {\n-                    if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id.expect_local()) {\n-                        self.encode_optimized_mir(def_id.expect_local());\n-                        self.encode_promoted_mir(def_id.expect_local());\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn should_encode_fn_opt_mir(&self, def_id: DefId) -> bool {\n-        self.tcx.sess.opts.debugging_opts.always_encode_mir\n-            || (self.emit_codegen_mir\n-                && (self.tcx.generics_of(def_id).requires_monomorphization(self.tcx)\n-                    || self.tcx.codegen_fn_attrs(def_id).requests_inline()))\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) {\n@@ -1171,27 +1176,6 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n         self.encode_inferred_outlives(def_id);\n-\n-        // The following part should be kept in sync with `PrefetchVisitor.visit_impl_item`.\n-\n-        let (mir, mir_const) = match ast_item.kind {\n-            hir::ImplItemKind::Const(..) => (false, true),\n-            hir::ImplItemKind::Fn(ref sig, _) => {\n-                let opt_mir = self.should_encode_fn_opt_mir(def_id);\n-                let is_const_fn = sig.header.constness == hir::Constness::Const;\n-                (opt_mir, is_const_fn)\n-            }\n-            hir::ImplItemKind::TyAlias(..) => (false, false),\n-        };\n-        if mir {\n-            self.encode_optimized_mir(def_id.expect_local());\n-        }\n-        if mir || mir_const {\n-            self.encode_promoted_mir(def_id.expect_local());\n-        }\n-        if mir_const {\n-            self.encode_mir_for_ctfe(def_id.expect_local());\n-        }\n     }\n \n     fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId) -> Lazy<[Ident]> {\n@@ -1202,34 +1186,48 @@ impl EncodeContext<'a, 'tcx> {\n         self.lazy(param_names.iter())\n     }\n \n-    fn encode_mir_for_ctfe(&mut self, def_id: LocalDefId) {\n-        debug!(\"EntryBuilder::encode_mir_for_ctfe({:?})\", def_id);\n-        record!(self.tables.mir_for_ctfe[def_id.to_def_id()] <- self.tcx.mir_for_ctfe(def_id));\n-\n-        let unused = self.tcx.unused_generic_params(def_id);\n-        if !unused.is_empty() {\n-            record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n+    fn encode_mir(&mut self) {\n+        if self.is_proc_macro {\n+            return;\n         }\n \n-        let abstract_const = self.tcx.mir_abstract_const(def_id);\n-        if let Ok(Some(abstract_const)) = abstract_const {\n-            record!(self.tables.mir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n-        }\n-    }\n+        let mut keys_and_jobs = self\n+            .tcx\n+            .mir_keys(LOCAL_CRATE)\n+            .iter()\n+            .filter_map(|&def_id| {\n+                let (encode_const, encode_opt) = should_encode_mir(self.tcx, def_id);\n+                if encode_const || encode_opt {\n+                    Some((def_id, encode_const, encode_opt))\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+        // Sort everything to ensure a stable order for diagnotics.\n+        keys_and_jobs.sort_by_key(|&(def_id, _, _)| def_id);\n+        for (def_id, encode_const, encode_opt) in keys_and_jobs.into_iter() {\n+            debug_assert!(encode_const || encode_opt);\n \n-    fn encode_optimized_mir(&mut self, def_id: LocalDefId) {\n-        debug!(\"EntryBuilder::encode_optimized_mir({:?})\", def_id);\n-        record!(self.tables.mir[def_id.to_def_id()] <- self.tcx.optimized_mir(def_id));\n+            debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n+            if encode_opt {\n+                record!(self.tables.mir[def_id.to_def_id()] <- self.tcx.optimized_mir(def_id));\n+            }\n+            if encode_const {\n+                record!(self.tables.mir_for_ctfe[def_id.to_def_id()] <- self.tcx.mir_for_ctfe(def_id));\n \n-        let unused = self.tcx.unused_generic_params(def_id);\n-        if !unused.is_empty() {\n-            record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n-        }\n-    }\n+                let abstract_const = self.tcx.mir_abstract_const(def_id);\n+                if let Ok(Some(abstract_const)) = abstract_const {\n+                    record!(self.tables.mir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n+                }\n+            }\n+            record!(self.tables.promoted_mir[def_id.to_def_id()] <- self.tcx.promoted_mir(def_id));\n \n-    fn encode_promoted_mir(&mut self, def_id: LocalDefId) {\n-        debug!(\"EncodeContext::encode_promoted_mir({:?})\", def_id);\n-        record!(self.tables.promoted_mir[def_id.to_def_id()] <- self.tcx.promoted_mir(def_id));\n+            let unused = self.tcx.unused_generic_params(def_id);\n+            if !unused.is_empty() {\n+                record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n+            }\n+        }\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n@@ -1487,28 +1485,6 @@ impl EncodeContext<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-\n-        // The following part should be kept in sync with `PrefetchVisitor.visit_item`.\n-\n-        let (mir, const_mir) = match item.kind {\n-            hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => (false, true),\n-            hir::ItemKind::Fn(ref sig, ..) => {\n-                let opt_mir = self.should_encode_fn_opt_mir(def_id);\n-                let is_const_fn = sig.header.constness == hir::Constness::Const;\n-                // We don't need the optimized MIR for const fns.\n-                (opt_mir, is_const_fn)\n-            }\n-            _ => (false, false),\n-        };\n-        if mir {\n-            self.encode_optimized_mir(def_id.expect_local());\n-        }\n-        if mir || const_mir {\n-            self.encode_promoted_mir(def_id.expect_local());\n-        }\n-        if const_mir {\n-            self.encode_mir_for_ctfe(def_id.expect_local());\n-        }\n     }\n \n     /// Serialize the text of exported macros\n@@ -1550,14 +1526,6 @@ impl EncodeContext<'a, 'tcx> {\n             record!(self.tables.fn_sig[def_id] <- substs.as_closure().sig());\n         }\n         self.encode_generics(def_id.to_def_id());\n-        let opt_mir = // FIXME: Optimized MIR is necessary to determine the layout of generators.\n-            matches!(ty.kind(), ty::Generator(..))\n-            || self.tcx.sess.opts.debugging_opts.always_encode_mir\n-            || self.emit_codegen_mir;\n-        if opt_mir {\n-            self.encode_optimized_mir(def_id);\n-            self.encode_promoted_mir(def_id);\n-        }\n     }\n \n     fn encode_info_for_anon_const(&mut self, def_id: LocalDefId) {\n@@ -1572,8 +1540,6 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_generics(def_id.to_def_id());\n         self.encode_explicit_predicates(def_id.to_def_id());\n         self.encode_inferred_outlives(def_id.to_def_id());\n-        self.encode_mir_for_ctfe(def_id);\n-        self.encode_promoted_mir(def_id);\n     }\n \n     fn encode_native_libraries(&mut self) -> Lazy<[NativeLib]> {\n@@ -2038,90 +2004,25 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n \n /// Used to prefetch queries which will be needed later by metadata encoding.\n /// Only a subset of the queries are actually prefetched to keep this code smaller.\n-struct PrefetchVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    mir_keys: &'tcx FxHashSet<LocalDefId>,\n-}\n-\n-impl<'tcx> PrefetchVisitor<'tcx> {\n-    fn prefetch_ctfe_mir(&self, def_id: LocalDefId) {\n-        if self.mir_keys.contains(&def_id) {\n-            self.tcx.ensure().mir_for_ctfe(def_id);\n-            self.tcx.ensure().promoted_mir(def_id);\n-        }\n-    }\n-    fn prefetch_mir(&self, def_id: LocalDefId) {\n-        if self.mir_keys.contains(&def_id) {\n-            self.tcx.ensure().optimized_mir(def_id);\n-            self.tcx.ensure().promoted_mir(def_id);\n-        }\n+fn prefetch_mir(tcx: TyCtxt<'_>) {\n+    if !tcx.sess.opts.output_types.should_codegen() {\n+        // We won't emit MIR, so don't prefetch it.\n+        return;\n     }\n-}\n \n-impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n-    fn visit_item(&self, item: &hir::Item<'_>) {\n-        // This should be kept in sync with `encode_info_for_item`.\n-        let tcx = self.tcx;\n-        match item.kind {\n-            hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => {\n-                self.prefetch_ctfe_mir(tcx.hir().local_def_id(item.hir_id))\n-            }\n-            hir::ItemKind::Fn(ref sig, ..) => {\n-                let def_id = tcx.hir().local_def_id(item.hir_id);\n-                let opt_mir = tcx.generics_of(def_id.to_def_id()).requires_monomorphization(tcx)\n-                    || tcx.codegen_fn_attrs(def_id.to_def_id()).requests_inline();\n-                if opt_mir {\n-                    self.prefetch_mir(def_id)\n-                }\n-                if sig.header.constness == hir::Constness::Const {\n-                    self.prefetch_ctfe_mir(def_id);\n-                }\n-            }\n-            _ => (),\n-        }\n-    }\n+    par_iter(tcx.mir_keys(LOCAL_CRATE)).for_each(|&def_id| {\n+        let (encode_const, encode_opt) = should_encode_mir(tcx, def_id);\n \n-    fn visit_trait_item(&self, trait_item: &'v hir::TraitItem<'v>) {\n-        // This should be kept in sync with `encode_info_for_trait_item`.\n-        let def_id = self.tcx.hir().local_def_id(trait_item.hir_id);\n-        match trait_item.kind {\n-            hir::TraitItemKind::Type(..) => {}\n-            hir::TraitItemKind::Const(..) => {\n-                self.prefetch_ctfe_mir(def_id);\n-            }\n-            hir::TraitItemKind::Fn(..) => {\n-                self.prefetch_mir(def_id);\n-            }\n+        if encode_const {\n+            tcx.ensure().mir_for_ctfe(def_id);\n         }\n-    }\n-\n-    fn visit_impl_item(&self, impl_item: &'v hir::ImplItem<'v>) {\n-        // This should be kept in sync with `encode_info_for_impl_item`.\n-        let tcx = self.tcx;\n-        match impl_item.kind {\n-            hir::ImplItemKind::Const(..) => {\n-                self.prefetch_ctfe_mir(tcx.hir().local_def_id(impl_item.hir_id))\n-            }\n-            hir::ImplItemKind::Fn(ref sig, _) => {\n-                let def_id = tcx.hir().local_def_id(impl_item.hir_id);\n-                let opt_mir = tcx.generics_of(def_id.to_def_id()).requires_monomorphization(tcx)\n-                    || tcx.codegen_fn_attrs(def_id.to_def_id()).requests_inline();\n-                let is_const_fn = sig.header.constness == hir::Constness::Const;\n-                if opt_mir {\n-                    self.prefetch_mir(def_id)\n-                }\n-                if is_const_fn {\n-                    self.prefetch_ctfe_mir(def_id);\n-                }\n-            }\n-            hir::ImplItemKind::TyAlias(..) => (),\n+        if encode_opt {\n+            tcx.ensure().optimized_mir(def_id);\n         }\n-    }\n-\n-    fn visit_foreign_item(&self, _foreign_item: &'v hir::ForeignItem<'v>) {\n-        // This should be kept in sync with `encode_info_for_foreign_item`.\n-        // Foreign items contain no MIR.\n-    }\n+        if encode_opt || encode_const {\n+            tcx.ensure().promoted_mir(def_id);\n+        }\n+    })\n }\n \n // NOTE(eddyb) The following comment was preserved for posterity, even\n@@ -2161,19 +2062,7 @@ pub(super) fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n             // Prefetch some queries used by metadata encoding.\n             // This is not necessary for correctness, but is only done for performance reasons.\n             // It can be removed if it turns out to cause trouble or be detrimental to performance.\n-            join(\n-                || {\n-                    if !tcx.sess.opts.output_types.should_codegen() {\n-                        // We won't emit MIR, so don't prefetch it.\n-                        return;\n-                    }\n-                    tcx.hir().krate().par_visit_all_item_likes(&PrefetchVisitor {\n-                        tcx,\n-                        mir_keys: tcx.mir_keys(LOCAL_CRATE),\n-                    });\n-                },\n-                || tcx.exported_symbols(LOCAL_CRATE),\n-            );\n+            join(|| prefetch_mir(tcx), || tcx.exported_symbols(LOCAL_CRATE));\n         },\n     )\n     .0\n@@ -2206,7 +2095,6 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n         required_source_files,\n         is_proc_macro: tcx.sess.crate_types().contains(&CrateType::ProcMacro),\n         hygiene_ctxt: &hygiene_ctxt,\n-        emit_codegen_mir: tcx.sess.opts.output_types.should_codegen(),\n     };\n \n     // Encode the rustc version string in a predictable location."}]}