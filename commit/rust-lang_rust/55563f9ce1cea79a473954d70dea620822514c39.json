{"sha": "55563f9ce1cea79a473954d70dea620822514c39", "node_id": "C_kwDOAAsO6NoAKDU1NTYzZjljZTFjZWE3OWE0NzM5NTRkNzBkZWE2MjA4MjI1MTRjMzk", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-07-08T19:29:23Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-07-09T00:07:55Z"}, "message": "Fixes for `branches_sharing_code`\n* Don't suggest moving modifications to locals used in any of the condition expressions\n* Don't suggest moving anything after a local with a significant drop", "tree": {"sha": "ece6ff7b8796235023e63b12e223ea140ca19876", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ece6ff7b8796235023e63b12e223ea140ca19876"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55563f9ce1cea79a473954d70dea620822514c39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55563f9ce1cea79a473954d70dea620822514c39", "html_url": "https://github.com/rust-lang/rust/commit/55563f9ce1cea79a473954d70dea620822514c39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55563f9ce1cea79a473954d70dea620822514c39/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d251bd96e7d4681ed9be9c13bc7539c17aa58e85", "url": "https://api.github.com/repos/rust-lang/rust/commits/d251bd96e7d4681ed9be9c13bc7539c17aa58e85", "html_url": "https://github.com/rust-lang/rust/commit/d251bd96e7d4681ed9be9c13bc7539c17aa58e85"}], "stats": {"total": 120, "additions": 113, "deletions": 7}, "files": [{"sha": "0e3d9317590f3c80782c517e5c64fc66019dc40d", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/55563f9ce1cea79a473954d70dea620822514c39/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55563f9ce1cea79a473954d70dea620822514c39/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=55563f9ce1cea79a473954d70dea620822514c39", "patch": "@@ -1,13 +1,16 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_then};\n use clippy_utils::source::{first_line_of_span, indent_of, reindent_multiline, snippet, snippet_opt};\n+use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{\n-    eq_expr_value, get_enclosing_block, hash_expr, hash_stmt, if_sequence, is_else_clause, is_lint_allowed,\n-    search_same, ContainsName, HirEqInterExpr, SpanlessEq,\n+    capture_local_usage, eq_expr_value, get_enclosing_block, hash_expr, hash_stmt, if_sequence, is_else_clause,\n+    is_lint_allowed, path_to_local, search_same, ContainsName, HirEqInterExpr, SpanlessEq,\n };\n use core::iter;\n+use core::ops::ControlFlow;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit;\n-use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Stmt, StmtKind};\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, HirIdSet, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::walk_chain;\n@@ -214,7 +217,7 @@ fn lint_if_same_then_else(cx: &LateContext<'_>, conds: &[&Expr<'_>], blocks: &[&\n fn lint_branches_sharing_code<'tcx>(\n     cx: &LateContext<'tcx>,\n     conds: &[&'tcx Expr<'_>],\n-    blocks: &[&Block<'tcx>],\n+    blocks: &[&'tcx Block<'_>],\n     expr: &'tcx Expr<'_>,\n ) {\n     // We only lint ifs with multiple blocks\n@@ -340,6 +343,21 @@ fn eq_binding_names(s: &Stmt<'_>, names: &[(HirId, Symbol)]) -> bool {\n     }\n }\n \n+/// Checks if the statement modifies or moves any of the given locals.\n+fn modifies_any_local<'tcx>(cx: &LateContext<'tcx>, s: &'tcx Stmt<'_>, locals: &HirIdSet) -> bool {\n+    for_each_expr(s, |e| {\n+        if let Some(id) = path_to_local(e)\n+            && locals.contains(&id)\n+            && !capture_local_usage(cx, e).is_imm_ref()\n+        {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    })\n+    .is_some()\n+}\n+\n /// Checks if the given statement should be considered equal to the statement in the same position\n /// for each block.\n fn eq_stmts(\n@@ -365,18 +383,52 @@ fn eq_stmts(\n         .all(|b| get_stmt(b).map_or(false, |s| eq.eq_stmt(s, stmt)))\n }\n \n-fn scan_block_for_eq(cx: &LateContext<'_>, _conds: &[&Expr<'_>], block: &Block<'_>, blocks: &[&Block<'_>]) -> BlockEq {\n+#[expect(clippy::too_many_lines)]\n+fn scan_block_for_eq<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    conds: &[&'tcx Expr<'_>],\n+    block: &'tcx Block<'_>,\n+    blocks: &[&'tcx Block<'_>],\n+) -> BlockEq {\n     let mut eq = SpanlessEq::new(cx);\n     let mut eq = eq.inter_expr();\n     let mut moved_locals = Vec::new();\n \n+    let mut cond_locals = HirIdSet::default();\n+    for &cond in conds {\n+        let _: Option<!> = for_each_expr(cond, |e| {\n+            if let Some(id) = path_to_local(e) {\n+                cond_locals.insert(id);\n+            }\n+            ControlFlow::Continue(())\n+        });\n+    }\n+\n+    let mut local_needs_ordered_drop = false;\n     let start_end_eq = block\n         .stmts\n         .iter()\n         .enumerate()\n-        .find(|&(i, stmt)| !eq_stmts(stmt, blocks, |b| b.stmts.get(i), &mut eq, &mut moved_locals))\n+        .find(|&(i, stmt)| {\n+            if let StmtKind::Local(l) = stmt.kind\n+                && needs_ordered_drop(cx, cx.typeck_results().node_type(l.hir_id))\n+            {\n+                local_needs_ordered_drop = true;\n+                return true;\n+            }\n+            modifies_any_local(cx, stmt, &cond_locals)\n+                || !eq_stmts(stmt, blocks, |b| b.stmts.get(i), &mut eq, &mut moved_locals)\n+        })\n         .map_or(block.stmts.len(), |(i, _)| i);\n \n+    if local_needs_ordered_drop {\n+        return BlockEq {\n+            start_end_eq,\n+            end_begin_eq: None,\n+            moved_locals,\n+        };\n+    }\n+\n     // Walk backwards through the final expression/statements so long as their hashes are equal. Note\n     // `SpanlessHash` treats all local references as equal allowing locals declared earlier in the block\n     // to match those in other blocks. e.g. If each block ends with the following the hash value will be"}, {"sha": "fd0c6869929720177690dce1fb2e91866942d0ca", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55563f9ce1cea79a473954d70dea620822514c39/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55563f9ce1cea79a473954d70dea620822514c39/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=55563f9ce1cea79a473954d70dea620822514c39", "patch": "@@ -890,7 +890,7 @@ pub fn capture_local_usage<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Captur\n             Node::Expr(e) => match e.kind {\n                 ExprKind::AddrOf(_, mutability, _) => return CaptureKind::Ref(mutability),\n                 ExprKind::Index(..) | ExprKind::Unary(UnOp::Deref, _) => capture = CaptureKind::Ref(Mutability::Not),\n-                ExprKind::Assign(lhs, ..) | ExprKind::Assign(_, lhs, _) if lhs.hir_id == child_id => {\n+                ExprKind::Assign(lhs, ..) | ExprKind::AssignOp(_, lhs, _) if lhs.hir_id == child_id => {\n                     return CaptureKind::Ref(Mutability::Mut);\n                 },\n                 ExprKind::Field(..) => {"}, {"sha": "5e3a1a29693f58ae5e392e222d6fb9b467216ee3", "filename": "tests/ui/branches_sharing_code/false_positives.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/55563f9ce1cea79a473954d70dea620822514c39/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55563f9ce1cea79a473954d70dea620822514c39/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs?ref=55563f9ce1cea79a473954d70dea620822514c39", "patch": "@@ -1,6 +1,8 @@\n #![allow(dead_code)]\n #![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n \n+use std::sync::Mutex;\n+\n // ##################################\n // # Issue clippy#7369\n // ##################################\n@@ -38,4 +40,56 @@ fn main() {\n         let (y, x) = x;\n         foo(x, y)\n     };\n+\n+    let m = Mutex::new(0u32);\n+    let l = m.lock().unwrap();\n+    let _ = if true {\n+        drop(l);\n+        println!(\"foo\");\n+        m.lock().unwrap();\n+        0\n+    } else if *l == 0 {\n+        drop(l);\n+        println!(\"foo\");\n+        println!(\"bar\");\n+        m.lock().unwrap();\n+        1\n+    } else {\n+        drop(l);\n+        println!(\"foo\");\n+        println!(\"baz\");\n+        m.lock().unwrap();\n+        2\n+    };\n+\n+    if true {\n+        let _guard = m.lock();\n+        println!(\"foo\");\n+    } else {\n+        println!(\"foo\");\n+    }\n+\n+    if true {\n+        let _guard = m.lock();\n+        println!(\"foo\");\n+        println!(\"bar\");\n+    } else {\n+        let _guard = m.lock();\n+        println!(\"foo\");\n+        println!(\"baz\");\n+    }\n+\n+    let mut c = 0;\n+    for _ in 0..5 {\n+        if c == 0 {\n+            c += 1;\n+            println!(\"0\");\n+        } else if c == 1 {\n+            c += 1;\n+            println!(\"1\");\n+        } else {\n+            c += 1;\n+            println!(\"more\");\n+        }\n+    }\n }"}]}