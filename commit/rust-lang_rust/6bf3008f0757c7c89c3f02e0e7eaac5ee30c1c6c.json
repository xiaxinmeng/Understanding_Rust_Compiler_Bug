{"sha": "6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "node_id": "C_kwDOAAsO6NoAKDZiZjMwMDhmMDc1N2M3Yzg5YzNmMDJlMGU3ZWFhYzVlZTMwYzFjNmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-15T16:48:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-15T16:48:26Z"}, "message": "Auto merge of #94024 - matthiaskrgr:rollup-0hwxm0w, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #93899 (Describe VecDeque with more consistent names)\n - #93949 (Add basic platform support to library/{panic_}unwind for m68k)\n - #93999 (suggest using raw strings when invalid escapes appear in literals)\n - #94001 (llvm: migrate to new parameter-bearing uwtable attr)\n - #94014 (Move transmute_undefined_repr back to nursery)\n\nFailed merges:\n\n - #94020 (Support pretty printing of invalid constants)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a7a234b7a8a29df52935d01d839313636e3960bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7a234b7a8a29df52935d01d839313636e3960bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "html_url": "https://github.com/rust-lang/rust/commit/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55697574915ca58c3fcd7b1c854c1c93e002dc85", "url": "https://api.github.com/repos/rust-lang/rust/commits/55697574915ca58c3fcd7b1c854c1c93e002dc85", "html_url": "https://github.com/rust-lang/rust/commit/55697574915ca58c3fcd7b1c854c1c93e002dc85"}, {"sha": "cc836ee292188da1c0c29e369fada75606bfb74c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc836ee292188da1c0c29e369fada75606bfb74c", "html_url": "https://github.com/rust-lang/rust/commit/cc836ee292188da1c0c29e369fada75606bfb74c"}], "stats": {"total": 298, "additions": 180, "deletions": 118}, "files": [{"sha": "7680d4fd233be498e81688d21e0a92c7151466c0", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -64,7 +64,7 @@ pub(crate) unsafe fn codegen(\n             llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n         }\n         if tcx.sess.must_emit_unwind_tables() {\n-            attributes::emit_uwtable(llfn, true);\n+            attributes::emit_uwtable(llfn);\n         }\n \n         let callee = kind.fn_name(method.name);\n@@ -111,7 +111,7 @@ pub(crate) unsafe fn codegen(\n         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n     }\n     if tcx.sess.must_emit_unwind_tables() {\n-        attributes::emit_uwtable(llfn, true);\n+        attributes::emit_uwtable(llfn);\n     }\n \n     let kind = if has_alloc_error_handler { AllocatorKind::Global } else { AllocatorKind::Default };"}, {"sha": "30a52d6bd67fc5f49b51a223f4ac4b4f9302aa47", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -59,8 +59,11 @@ pub fn sanitize<'ll>(cx: &CodegenCx<'ll, '_>, no_sanitize: SanitizerSet, llfn: &\n \n /// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n #[inline]\n-pub fn emit_uwtable(val: &Value, emit: bool) {\n-    Attribute::UWTable.toggle_llfn(Function, val, emit);\n+pub fn emit_uwtable(val: &Value) {\n+    // NOTE: We should determine if we even need async unwind tables, as they\n+    // take have more overhead and if we can use sync unwind tables we\n+    // probably should.\n+    llvm::EmitUWTableAttr(val, true);\n }\n \n /// Tell LLVM if this function should be 'naked', i.e., skip the epilogue and prologue.\n@@ -275,7 +278,7 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n     // You can also find more info on why Windows always requires uwtables here:\n     //      https://bugzilla.mozilla.org/show_bug.cgi?id=1302078\n     if cx.sess().must_emit_unwind_tables() {\n-        attributes::emit_uwtable(llfn, true);\n+        attributes::emit_uwtable(llfn);\n     }\n \n     if cx.sess().opts.debugging_opts.profile_sample_use.is_some() {"}, {"sha": "90d4367a280a48fc34642a1e63dc36fec21b2f23", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -1182,6 +1182,7 @@ extern \"C\" {\n     pub fn LLVMRustAddByValAttr(Fn: &Value, index: c_uint, ty: &Type);\n     pub fn LLVMRustAddStructRetAttr(Fn: &Value, index: c_uint, ty: &Type);\n     pub fn LLVMRustAddFunctionAttribute(Fn: &Value, index: c_uint, attr: Attribute);\n+    pub fn LLVMRustEmitUWTableAttr(Fn: &Value, async_: bool);\n     pub fn LLVMRustAddFunctionAttrStringValue(\n         Fn: &Value,\n         index: c_uint,"}, {"sha": "8586b0466c8d0208d51b17d0a4517ba20c388893", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -31,6 +31,10 @@ impl LLVMRustResult {\n     }\n }\n \n+pub fn EmitUWTableAttr(llfn: &Value, async_: bool) {\n+    unsafe { LLVMRustEmitUWTableAttr(llfn, async_) }\n+}\n+\n pub fn AddFunctionAttrStringValue(llfn: &Value, idx: AttributePlace, attr: &CStr, value: &CStr) {\n     unsafe {\n         LLVMRustAddFunctionAttrStringValue(llfn, idx.as_uint(), attr.as_ptr(), value.as_ptr())"}, {"sha": "23333199506515712d5a32e678086e477f87c48b", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -334,6 +334,17 @@ extern \"C\" void LLVMRustAddStructRetAttr(LLVMValueRef Fn, unsigned Index,\n   AddAttribute(F, Index, Attr);\n }\n \n+extern \"C\" void LLVMRustEmitUWTableAttr(LLVMValueRef Fn, bool Async) {\n+  Function *F = unwrap<Function>(Fn);\n+#if LLVM_VERSION_LT(15, 0)\n+  Attribute Attr = Attribute::get(F->getContext(), Attribute::UWTable);\n+#else\n+  Attribute Attr = Attribute::getWithUWTableKind(\n+      F->getContext(), Async ? UWTableKind::Async : UWTableKind::Sync);\n+#endif\n+  AddAttribute(F, AttributeList::AttrIndex::FunctionIndex, Attr);\n+}\n+\n extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n                                                    unsigned Index,\n                                                    const char *Name,"}, {"sha": "a41956c58f005af4b4a6c0ce43df5fc784094c3c", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -185,6 +185,15 @@ pub(crate) fn emit_unescape_error(\n                      version control settings\",\n                 );\n             } else {\n+                if !mode.is_bytes() {\n+                    diag.span_suggestion(\n+                        span_with_quotes,\n+                        \"if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\",\n+                        format!(\"r\\\"{}\\\"\", lit),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+\n                 diag.help(\n                     \"for more information, visit \\\n                      <https://static.rust-lang.org/doc/master/reference.html#literals>\","}, {"sha": "db2ad5e8d285c60d4c01dd09741bad248a09abe8", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 110, "deletions": 110, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -1,4 +1,4 @@\n-//! A double-ended queue implemented with a growable ring buffer.\n+//! A double-ended queue (deque) implemented with a growable ring buffer.\n //!\n //! This queue has *O*(1) amortized inserts and removals from both ends of the\n //! container. It also has *O*(1) indexing like a vector. The contained elements\n@@ -156,7 +156,7 @@ unsafe impl<#[may_dangle] T, A: Allocator> Drop for VecDeque<T, A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for VecDeque<T> {\n-    /// Creates an empty `VecDeque<T>`.\n+    /// Creates an empty deque.\n     #[inline]\n     fn default() -> VecDeque<T> {\n         VecDeque::new()\n@@ -483,14 +483,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n }\n \n impl<T> VecDeque<T> {\n-    /// Creates an empty `VecDeque`.\n+    /// Creates an empty deque.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let vector: VecDeque<u32> = VecDeque::new();\n+    /// let deque: VecDeque<u32> = VecDeque::new();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -499,14 +499,14 @@ impl<T> VecDeque<T> {\n         VecDeque::new_in(Global)\n     }\n \n-    /// Creates an empty `VecDeque` with space for at least `capacity` elements.\n+    /// Creates an empty deque with space for at least `capacity` elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let vector: VecDeque<u32> = VecDeque::with_capacity(10);\n+    /// let deque: VecDeque<u32> = VecDeque::with_capacity(10);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -517,29 +517,29 @@ impl<T> VecDeque<T> {\n }\n \n impl<T, A: Allocator> VecDeque<T, A> {\n-    /// Creates an empty `VecDeque`.\n+    /// Creates an empty deque.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let vector: VecDeque<u32> = VecDeque::new();\n+    /// let deque: VecDeque<u32> = VecDeque::new();\n     /// ```\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub fn new_in(alloc: A) -> VecDeque<T, A> {\n         VecDeque::with_capacity_in(INITIAL_CAPACITY, alloc)\n     }\n \n-    /// Creates an empty `VecDeque` with space for at least `capacity` elements.\n+    /// Creates an empty deque with space for at least `capacity` elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let vector: VecDeque<u32> = VecDeque::with_capacity(10);\n+    /// let deque: VecDeque<u32> = VecDeque::with_capacity(10);\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub fn with_capacity_in(capacity: usize, alloc: A) -> VecDeque<T, A> {\n@@ -636,7 +636,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         unsafe { ptr::swap(self.ptr().add(ri), self.ptr().add(rj)) }\n     }\n \n-    /// Returns the number of elements the `VecDeque` can hold without\n+    /// Returns the number of elements the deque can hold without\n     /// reallocating.\n     ///\n     /// # Examples\n@@ -654,7 +654,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `VecDeque`. Does nothing if the capacity is already sufficient.\n+    /// given deque. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n     /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n@@ -681,7 +681,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted in the given\n-    /// `VecDeque`. The collection may reserve more space to avoid frequent reallocations.\n+    /// deque. The collection may reserve more space to avoid frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -714,7 +714,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     /// Tries to reserve the minimum capacity for exactly `additional` more elements to\n-    /// be inserted in the given `VecDeque<T>`. After calling `try_reserve_exact`,\n+    /// be inserted in the given deque. After calling `try_reserve_exact`,\n     /// capacity will be greater than or equal to `self.len() + additional`.\n     /// Does nothing if the capacity is already sufficient.\n     ///\n@@ -756,7 +756,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n-    /// in the given `VecDeque<T>`. The collection may reserve more space to avoid\n+    /// in the given deque. The collection may reserve more space to avoid\n     /// frequent reallocations. After calling `try_reserve`, capacity will be\n     /// greater than or equal to `self.len() + additional`. Does nothing if\n     /// capacity is already sufficient.\n@@ -805,10 +805,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         Ok(())\n     }\n \n-    /// Shrinks the capacity of the `VecDeque` as much as possible.\n+    /// Shrinks the capacity of the deque as much as possible.\n     ///\n     /// It will drop down as close as possible to the length but the allocator may still inform the\n-    /// `VecDeque` that there is space for a few more elements.\n+    /// deque that there is space for a few more elements.\n     ///\n     /// # Examples\n     ///\n@@ -826,7 +826,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.shrink_to(0);\n     }\n \n-    /// Shrinks the capacity of the `VecDeque` with a lower bound.\n+    /// Shrinks the capacity of the deque with a lower bound.\n     ///\n     /// The capacity will remain at least as large as both the length\n     /// and the supplied value.\n@@ -909,10 +909,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Shortens the `VecDeque`, keeping the first `len` elements and dropping\n+    /// Shortens the deque, keeping the first `len` elements and dropping\n     /// the rest.\n     ///\n-    /// If `len` is greater than the `VecDeque`'s current length, this has no\n+    /// If `len` is greater than the deque's current length, this has no\n     /// effect.\n     ///\n     /// # Examples\n@@ -1027,10 +1027,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n-    /// `VecDeque`.\n+    /// deque.\n     ///\n     /// If [`make_contiguous`] was previously called, all elements of the\n-    /// `VecDeque` will be in the first slice and the second slice will be empty.\n+    /// deque will be in the first slice and the second slice will be empty.\n     ///\n     /// [`make_contiguous`]: VecDeque::make_contiguous\n     ///\n@@ -1039,18 +1039,18 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut vector = VecDeque::new();\n+    /// let mut deque = VecDeque::new();\n     ///\n-    /// vector.push_back(0);\n-    /// vector.push_back(1);\n-    /// vector.push_back(2);\n+    /// deque.push_back(0);\n+    /// deque.push_back(1);\n+    /// deque.push_back(2);\n     ///\n-    /// assert_eq!(vector.as_slices(), (&[0, 1, 2][..], &[][..]));\n+    /// assert_eq!(deque.as_slices(), (&[0, 1, 2][..], &[][..]));\n     ///\n-    /// vector.push_front(10);\n-    /// vector.push_front(9);\n+    /// deque.push_front(10);\n+    /// deque.push_front(9);\n     ///\n-    /// assert_eq!(vector.as_slices(), (&[9, 10][..], &[0, 1, 2][..]));\n+    /// assert_eq!(deque.as_slices(), (&[9, 10][..], &[0, 1, 2][..]));\n     /// ```\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n@@ -1062,10 +1062,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n-    /// `VecDeque`.\n+    /// deque.\n     ///\n     /// If [`make_contiguous`] was previously called, all elements of the\n-    /// `VecDeque` will be in the first slice and the second slice will be empty.\n+    /// deque will be in the first slice and the second slice will be empty.\n     ///\n     /// [`make_contiguous`]: VecDeque::make_contiguous\n     ///\n@@ -1074,17 +1074,17 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut vector = VecDeque::new();\n+    /// let mut deque = VecDeque::new();\n     ///\n-    /// vector.push_back(0);\n-    /// vector.push_back(1);\n+    /// deque.push_back(0);\n+    /// deque.push_back(1);\n     ///\n-    /// vector.push_front(10);\n-    /// vector.push_front(9);\n+    /// deque.push_front(10);\n+    /// deque.push_front(9);\n     ///\n-    /// vector.as_mut_slices().0[0] = 42;\n-    /// vector.as_mut_slices().1[0] = 24;\n-    /// assert_eq!(vector.as_slices(), (&[42, 10][..], &[24, 1][..]));\n+    /// deque.as_mut_slices().0[0] = 42;\n+    /// deque.as_mut_slices().1[0] = 24;\n+    /// assert_eq!(deque.as_slices(), (&[42, 10][..], &[24, 1][..]));\n     /// ```\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n@@ -1097,34 +1097,34 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Returns the number of elements in the `VecDeque`.\n+    /// Returns the number of elements in the deque.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = VecDeque::new();\n-    /// assert_eq!(v.len(), 0);\n-    /// v.push_back(1);\n-    /// assert_eq!(v.len(), 1);\n+    /// let mut deque = VecDeque::new();\n+    /// assert_eq!(deque.len(), 0);\n+    /// deque.push_back(1);\n+    /// assert_eq!(deque.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n         count(self.tail, self.head, self.cap())\n     }\n \n-    /// Returns `true` if the `VecDeque` is empty.\n+    /// Returns `true` if the deque is empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = VecDeque::new();\n-    /// assert!(v.is_empty());\n-    /// v.push_front(1);\n-    /// assert!(!v.is_empty());\n+    /// let mut deque = VecDeque::new();\n+    /// assert!(deque.is_empty());\n+    /// deque.push_front(1);\n+    /// assert!(!deque.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n@@ -1141,24 +1141,24 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         (tail, head)\n     }\n \n-    /// Creates an iterator that covers the specified range in the `VecDeque`.\n+    /// Creates an iterator that covers the specified range in the deque.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the starting point is greater than the end point or if\n-    /// the end point is greater than the length of the vector.\n+    /// the end point is greater than the length of the deque.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let v: VecDeque<_> = [1, 2, 3].into();\n-    /// let range = v.range(2..).copied().collect::<VecDeque<_>>();\n+    /// let deque: VecDeque<_> = [1, 2, 3].into();\n+    /// let range = deque.range(2..).copied().collect::<VecDeque<_>>();\n     /// assert_eq!(range, [3]);\n     ///\n     /// // A full range covers all contents\n-    /// let all = v.range(..);\n+    /// let all = deque.range(..);\n     /// assert_eq!(all.len(), 3);\n     /// ```\n     #[inline]\n@@ -1176,29 +1176,29 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Creates an iterator that covers the specified mutable range in the `VecDeque`.\n+    /// Creates an iterator that covers the specified mutable range in the deque.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the starting point is greater than the end point or if\n-    /// the end point is greater than the length of the vector.\n+    /// the end point is greater than the length of the deque.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut v: VecDeque<_> = [1, 2, 3].into();\n-    /// for v in v.range_mut(2..) {\n+    /// let mut deque: VecDeque<_> = [1, 2, 3].into();\n+    /// for v in deque.range_mut(2..) {\n     ///   *v *= 2;\n     /// }\n-    /// assert_eq!(v, [1, 2, 6]);\n+    /// assert_eq!(deque, [1, 2, 6]);\n     ///\n     /// // A full range covers all contents\n-    /// for v in v.range_mut(..) {\n+    /// for v in deque.range_mut(..) {\n     ///   *v *= 2;\n     /// }\n-    /// assert_eq!(v, [2, 4, 12]);\n+    /// assert_eq!(deque, [2, 4, 12]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"deque_range\", since = \"1.51.0\")]\n@@ -1216,7 +1216,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     /// Creates a draining iterator that removes the specified range in the\n-    /// `VecDeque` and yields the removed items.\n+    /// deque and yields the removed items.\n     ///\n     /// Note 1: The element range is removed even if the iterator is not\n     /// consumed until the end.\n@@ -1228,21 +1228,21 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// # Panics\n     ///\n     /// Panics if the starting point is greater than the end point or if\n-    /// the end point is greater than the length of the vector.\n+    /// the end point is greater than the length of the deque.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut v: VecDeque<_> = [1, 2, 3].into();\n-    /// let drained = v.drain(2..).collect::<VecDeque<_>>();\n+    /// let mut deque: VecDeque<_> = [1, 2, 3].into();\n+    /// let drained = deque.drain(2..).collect::<VecDeque<_>>();\n     /// assert_eq!(drained, [3]);\n-    /// assert_eq!(v, [1, 2]);\n+    /// assert_eq!(deque, [1, 2]);\n     ///\n     /// // A full range clears all contents\n-    /// v.drain(..);\n-    /// assert!(v.is_empty());\n+    /// deque.drain(..);\n+    /// assert!(deque.is_empty());\n     /// ```\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n@@ -1297,39 +1297,39 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         unsafe { Drain::new(drain_head, head, iter, deque) }\n     }\n \n-    /// Clears the `VecDeque`, removing all values.\n+    /// Clears the deque, removing all values.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = VecDeque::new();\n-    /// v.push_back(1);\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n+    /// let mut deque = VecDeque::new();\n+    /// deque.push_back(1);\n+    /// deque.clear();\n+    /// assert!(deque.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n         self.truncate(0);\n     }\n \n-    /// Returns `true` if the `VecDeque` contains an element equal to the\n+    /// Returns `true` if the deque contains an element equal to the\n     /// given value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut vector: VecDeque<u32> = VecDeque::new();\n+    /// let mut deque: VecDeque<u32> = VecDeque::new();\n     ///\n-    /// vector.push_back(0);\n-    /// vector.push_back(1);\n+    /// deque.push_back(0);\n+    /// deque.push_back(1);\n     ///\n-    /// assert_eq!(vector.contains(&1), true);\n-    /// assert_eq!(vector.contains(&10), false);\n+    /// assert_eq!(deque.contains(&1), true);\n+    /// assert_eq!(deque.contains(&10), false);\n     /// ```\n     #[stable(feature = \"vec_deque_contains\", since = \"1.12.0\")]\n     pub fn contains(&self, x: &T) -> bool\n@@ -1340,7 +1340,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         a.contains(x) || b.contains(x)\n     }\n \n-    /// Provides a reference to the front element, or `None` if the `VecDeque` is\n+    /// Provides a reference to the front element, or `None` if the deque is\n     /// empty.\n     ///\n     /// # Examples\n@@ -1361,7 +1361,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the\n-    /// `VecDeque` is empty.\n+    /// deque is empty.\n     ///\n     /// # Examples\n     ///\n@@ -1384,7 +1384,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.get_mut(0)\n     }\n \n-    /// Provides a reference to the back element, or `None` if the `VecDeque` is\n+    /// Provides a reference to the back element, or `None` if the deque is\n     /// empty.\n     ///\n     /// # Examples\n@@ -1405,7 +1405,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the\n-    /// `VecDeque` is empty.\n+    /// deque is empty.\n     ///\n     /// # Examples\n     ///\n@@ -1428,7 +1428,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.get_mut(self.len().wrapping_sub(1))\n     }\n \n-    /// Removes the first element and returns it, or `None` if the `VecDeque` is\n+    /// Removes the first element and returns it, or `None` if the deque is\n     /// empty.\n     ///\n     /// # Examples\n@@ -1455,7 +1455,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Removes the last element from the `VecDeque` and returns it, or `None` if\n+    /// Removes the last element from the deque and returns it, or `None` if\n     /// it is empty.\n     ///\n     /// # Examples\n@@ -1480,7 +1480,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Prepends an element to the `VecDeque`.\n+    /// Prepends an element to the deque.\n     ///\n     /// # Examples\n     ///\n@@ -1505,7 +1505,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Appends an element to the back of the `VecDeque`.\n+    /// Appends an element to the back of the deque.\n     ///\n     /// # Examples\n     ///\n@@ -1535,7 +1535,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.tail <= self.head\n     }\n \n-    /// Removes an element from anywhere in the `VecDeque` and returns it,\n+    /// Removes an element from anywhere in the deque and returns it,\n     /// replacing it with the first element.\n     ///\n     /// This does not preserve ordering, but is *O*(1).\n@@ -1570,8 +1570,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.pop_front()\n     }\n \n-    /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n-    /// last element.\n+    /// Removes an element from anywhere in the deque and returns it,\n+    /// replacing it with the last element.\n     ///\n     /// This does not preserve ordering, but is *O*(1).\n     ///\n@@ -1605,14 +1605,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.pop_back()\n     }\n \n-    /// Inserts an element at `index` within the `VecDeque`, shifting all elements with indices\n-    /// greater than or equal to `index` towards the back.\n+    /// Inserts an element at `index` within the deque, shifting all elements\n+    /// with indices greater than or equal to `index` towards the back.\n     ///\n     /// Element at index 0 is the front of the queue.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `index` is greater than `VecDeque`'s length\n+    /// Panics if `index` is greater than deque's length\n     ///\n     /// # Examples\n     ///\n@@ -1829,7 +1829,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Removes and returns the element at `index` from the `VecDeque`.\n+    /// Removes and returns the element at `index` from the deque.\n     /// Whichever end is closer to the removal point will be moved to make\n     /// room, and all the affected elements will be moved to new positions.\n     /// Returns `None` if `index` is out of bounds.\n@@ -2007,10 +2007,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         elem\n     }\n \n-    /// Splits the `VecDeque` into two at the given index.\n+    /// Splits the deque into two at the given index.\n     ///\n     /// Returns a newly allocated `VecDeque`. `self` contains elements `[0, at)`,\n-    /// and the returned `VecDeque` contains elements `[at, len)`.\n+    /// and the returned deque contains elements `[at, len)`.\n     ///\n     /// Note that the capacity of `self` does not change.\n     ///\n@@ -2227,7 +2227,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         debug_assert!(!self.is_full());\n     }\n \n-    /// Modifies the `VecDeque` in-place so that `len()` is equal to `new_len`,\n+    /// Modifies the deque in-place so that `len()` is equal to `new_len`,\n     /// either by removing excess elements from the back or by appending\n     /// elements generated by calling `generator` to the back.\n     ///\n@@ -2272,7 +2272,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     ///\n     /// Once the internal storage is contiguous, the [`as_slices`] and\n     /// [`as_mut_slices`] methods will return the entire contents of the\n-    /// `VecDeque` in a single slice.\n+    /// deque in a single slice.\n     ///\n     /// [`as_slices`]: VecDeque::as_slices\n     /// [`as_mut_slices`]: VecDeque::as_mut_slices\n@@ -2524,7 +2524,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Binary searches this sorted `VecDeque` for a given element.\n+    /// Binary searches the sorted deque for a given element.\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n     /// index of the matching element. If there are multiple matches, then any\n@@ -2556,7 +2556,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// assert!(matches!(r, Ok(1..=4)));\n     /// ```\n     ///\n-    /// If you want to insert an item to a sorted `VecDeque`, while maintaining\n+    /// If you want to insert an item to a sorted deque, while maintaining\n     /// sort order:\n     ///\n     /// ```\n@@ -2577,12 +2577,12 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.binary_search_by(|e| e.cmp(x))\n     }\n \n-    /// Binary searches this sorted `VecDeque` with a comparator function.\n+    /// Binary searches the sorted deque with a comparator function.\n     ///\n     /// The comparator function should implement an order consistent\n-    /// with the sort order of the underlying `VecDeque`, returning an\n-    /// order code that indicates whether its argument is `Less`,\n-    /// `Equal` or `Greater` than the desired target.\n+    /// with the sort order of the deque, returning an order code that\n+    /// indicates whether its argument is `Less`, `Equal` or `Greater`\n+    /// than the desired target.\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n     /// index of the matching element. If there are multiple matches, then any\n@@ -2630,9 +2630,9 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Binary searches this sorted `VecDeque` with a key extraction function.\n+    /// Binary searches the sorted deque with a key extraction function.\n     ///\n-    /// Assumes that the `VecDeque` is sorted by the key, for instance with\n+    /// Assumes that the deque is sorted by the key, for instance with\n     /// [`make_contiguous().sort_by_key()`] using the same key extraction function.\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n@@ -2687,7 +2687,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0\n     /// (all odd numbers are at the start, all even at the end).\n     ///\n-    /// If this deque is not partitioned, the returned result is unspecified and meaningless,\n+    /// If the deque is not partitioned, the returned result is unspecified and meaningless,\n     /// as this method performs a kind of binary search.\n     ///\n     /// See also [`binary_search`], [`binary_search_by`], and [`binary_search_by_key`].\n@@ -2724,7 +2724,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n }\n \n impl<T: Clone, A: Allocator> VecDeque<T, A> {\n-    /// Modifies the `VecDeque` in-place so that `len()` is equal to new_len,\n+    /// Modifies the deque in-place so that `len()` is equal to new_len,\n     /// either by removing excess elements from the back or by appending clones of `value`\n     /// to the back.\n     ///\n@@ -2878,7 +2878,7 @@ impl<T, A: Allocator> IntoIterator for VecDeque<T, A> {\n     type Item = T;\n     type IntoIter = IntoIter<T, A>;\n \n-    /// Consumes the `VecDeque` into a front-to-back iterator yielding elements by\n+    /// Consumes the deque into a front-to-back iterator yielding elements by\n     /// value.\n     fn into_iter(self) -> IntoIter<T, A> {\n         IntoIter::new(self)"}, {"sha": "a0297b4b2f524f783a535b16254730bb633aba59", "filename": "library/panic_unwind/src/gcc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -105,6 +105,9 @@ const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX\n #[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1 / X0, X1\n \n+#[cfg(target_arch = \"m68k\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // D0, D1\n+\n #[cfg(any(target_arch = \"mips\", target_arch = \"mips64\"))]\n const UNWIND_DATA_REG: (i32, i32) = (4, 5); // A0, A1\n "}, {"sha": "c8c5528b104ebeb24e6e76592f3d0137ec9cda96", "filename": "library/unwind/src/libunwind.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/library%2Funwind%2Fsrc%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/library%2Funwind%2Fsrc%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flibunwind.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -42,6 +42,9 @@ pub const unwinder_private_data_size: usize = 2;\n #[cfg(all(target_arch = \"aarch64\", target_pointer_width = \"32\"))]\n pub const unwinder_private_data_size: usize = 5;\n \n+#[cfg(target_arch = \"m68k\")]\n+pub const unwinder_private_data_size: usize = 2;\n+\n #[cfg(target_arch = \"mips\")]\n pub const unwinder_private_data_size: usize = 2;\n "}, {"sha": "e6ff1f662bde9c9b85cd6ee359854cc865f640e9", "filename": "src/test/ui/lexer/lex-bad-char-literals-1.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftest%2Fui%2Flexer%2Flex-bad-char-literals-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftest%2Fui%2Flexer%2Flex-bad-char-literals-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flexer%2Flex-bad-char-literals-1.stderr?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -17,6 +17,10 @@ LL |     '\\\u25cf'\n    |       ^ unknown character escape\n    |\n    = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n+help: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n+   |\n+LL |     r\"\\\u25cf\"\n+   |     ~~~~~\n \n error: unknown character escape: `\\u{25cf}`\n   --> $DIR/lex-bad-char-literals-1.rs:14:7\n@@ -25,6 +29,10 @@ LL |     \"\\\u25cf\"\n    |       ^ unknown character escape\n    |\n    = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n+help: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n+   |\n+LL |     r\"\\\u25cf\"\n+   |     ~~~~~\n \n error: aborting due to 4 previous errors\n "}, {"sha": "978b92cbcd2116c761daf66dd0a2045180536812", "filename": "src/test/ui/parser/bad-escape-suggest-raw-string.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftest%2Fui%2Fparser%2Fbad-escape-suggest-raw-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftest%2Fui%2Fparser%2Fbad-escape-suggest-raw-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-escape-suggest-raw-string.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let ok = r\"ab\\[c\";\n+    let bad = \"ab\\[c\";\n+    //~^ ERROR unknown character escape: `[`\n+    //~| HELP for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n+    //~| HELP if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n+}"}, {"sha": "fc34bd3281af5bae4a1331cdd50728623612467a", "filename": "src/test/ui/parser/bad-escape-suggest-raw-string.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftest%2Fui%2Fparser%2Fbad-escape-suggest-raw-string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftest%2Fui%2Fparser%2Fbad-escape-suggest-raw-string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-escape-suggest-raw-string.stderr?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -0,0 +1,14 @@\n+error: unknown character escape: `[`\n+  --> $DIR/bad-escape-suggest-raw-string.rs:3:19\n+   |\n+LL |     let bad = \"ab\\[c\";\n+   |                   ^ unknown character escape\n+   |\n+   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n+help: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n+   |\n+LL |     let bad = r\"ab\\[c\";\n+   |               ~~~~~~~~\n+\n+error: aborting due to previous error\n+"}, {"sha": "4721b7f2b472b3ffaab9da2a2e21b8f486cf8457", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -277,7 +277,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n     LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n-    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "4217fd3a3ea72c04af802f688f39d34f1f501c7a", "filename": "src/tools/clippy/clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -58,7 +58,6 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),\n     LintId::of(to_string_in_display::TO_STRING_IN_DISPLAY),\n-    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "8d4dde42bbecad322b0d3ba28da5e24a8ac8d7f2", "filename": "src/tools/clippy/clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -26,6 +26,7 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(strings::STRING_LIT_AS_BYTES),\n     LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n     LintId::of(trailing_empty_array::TRAILING_EMPTY_ARRAY),\n+    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::USELESS_TRANSMUTE),\n     LintId::of(use_self::USE_SELF),\n ])"}, {"sha": "5e94ab6d04820afe307d36b4915ec11617e2aff6", "filename": "src/tools/clippy/clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "patch": "@@ -376,7 +376,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.60.0\"]\n     pub TRANSMUTE_UNDEFINED_REPR,\n-    correctness,\n+    nursery,\n     \"transmute to or from a type with an undefined representation\"\n }\n "}]}