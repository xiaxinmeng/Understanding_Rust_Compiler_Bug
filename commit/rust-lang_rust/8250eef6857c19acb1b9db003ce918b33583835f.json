{"sha": "8250eef6857c19acb1b9db003ce918b33583835f", "node_id": "C_kwDOAAsO6NoAKDgyNTBlZWY2ODU3YzE5YWNiMWI5ZGIwMDNjZTkxOGIzMzU4MzgzNWY", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2021-12-08T17:11:13Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2021-12-13T22:04:09Z"}, "message": "normalize_generic_arg_after in terms of try version", "tree": {"sha": "1c0dc1d6f468f4b18398ab1c9d786c8036556e86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c0dc1d6f468f4b18398ab1c9d786c8036556e86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8250eef6857c19acb1b9db003ce918b33583835f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8250eef6857c19acb1b9db003ce918b33583835f", "html_url": "https://github.com/rust-lang/rust/commit/8250eef6857c19acb1b9db003ce918b33583835f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8250eef6857c19acb1b9db003ce918b33583835f/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1796de7bb123df3f3d32124ededf1344434f672e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1796de7bb123df3f3d32124ededf1344434f672e", "html_url": "https://github.com/rust-lang/rust/commit/1796de7bb123df3f3d32124ededf1344434f672e"}], "stats": {"total": 45, "additions": 11, "deletions": 34}, "files": [{"sha": "f7d1ebed7d72feec8c1a0c7cb1b623dd9f4a3bbb", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 11, "deletions": 34, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8250eef6857c19acb1b9db003ce918b33583835f/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8250eef6857c19acb1b9db003ce918b33583835f/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=8250eef6857c19acb1b9db003ce918b33583835f", "patch": "@@ -15,10 +15,19 @@ crate fn provide(p: &mut Providers) {\n                 .perf_stats\n                 .normalize_generic_arg_after_erasing_regions\n                 .fetch_add(1, Ordering::Relaxed);\n-            normalize_after_erasing_regions(tcx, goal)\n+\n+            let (param_env, goal) = goal.into_parts();\n+            tcx.try_normalize_erasing_regions(param_env, goal).unwrap_or_else(|_| bug!(\n+                \"Failed to normalize {:?}, maybe try to call `try_normalize_erasing_regions` instead\",\n+                goal\n+            ))\n         },\n         normalize_mir_const_after_erasing_regions: |tcx, goal| {\n-            normalize_after_erasing_regions(tcx, goal)\n+            let (param_env, goal) = goal.into_parts();\n+            tcx.try_normalize_erasing_regions(param_env, goal).unwrap_or_else(|_| bug!(\n+                \"Failed to normalize {:?}, maybe try to call `try_normalize_erasing_regions` instead\",\n+                goal\n+            ))\n         },\n         try_normalize_generic_arg_after_erasing_regions: |tcx, goal| {\n             debug!(\"try_normalize_generic_arg_after_erasing_regions(goal={:#?}\", goal);\n@@ -32,38 +41,6 @@ crate fn provide(p: &mut Providers) {\n     };\n }\n \n-#[instrument(level = \"debug\", skip(tcx))]\n-fn normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq + Copy>(\n-    tcx: TyCtxt<'tcx>,\n-    goal: ParamEnvAnd<'tcx, T>,\n-) -> T {\n-    let ParamEnvAnd { param_env, value } = goal;\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let cause = ObligationCause::dummy();\n-        match infcx.at(&cause, param_env).normalize(value) {\n-            Ok(Normalized { value: normalized_value, obligations: normalized_obligations }) => {\n-                // We don't care about the `obligations`; they are\n-                // always only region relations, and we are about to\n-                // erase those anyway:\n-                debug_assert_eq!(\n-                    normalized_obligations.iter().find(|p| not_outlives_predicate(&p.predicate)),\n-                    None,\n-                );\n-\n-                let resolved_value = infcx.resolve_vars_if_possible(normalized_value);\n-                // It's unclear when `resolve_vars` would have an effect in a\n-                // fresh `InferCtxt`. If this assert does trigger, it will give\n-                // us a test case.\n-                debug_assert_eq!(normalized_value, resolved_value);\n-                let erased = infcx.tcx.erase_regions(resolved_value);\n-                debug_assert!(!erased.needs_infer(), \"{:?}\", erased);\n-                erased\n-            }\n-            Err(NoSolution) => bug!(\"could not fully normalize `{:?}`\", value),\n-        }\n-    })\n-}\n-\n #[instrument(level = \"debug\", skip(tcx))]\n fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq + Copy>(\n     tcx: TyCtxt<'tcx>,"}]}