{"sha": "85707398809f8b56afc471f228bd4d0137ce0a32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1NzA3Mzk4ODA5ZjhiNTZhZmM0NzFmMjI4YmQ0ZDAxMzdjZTBhMzI=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-11T04:12:55Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-17T02:56:31Z"}, "message": "allow inherent implementations on primitives", "tree": {"sha": "3ea08edc22330aed7134e2270bda546234625060", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ea08edc22330aed7134e2270bda546234625060"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85707398809f8b56afc471f228bd4d0137ce0a32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85707398809f8b56afc471f228bd4d0137ce0a32", "html_url": "https://github.com/rust-lang/rust/commit/85707398809f8b56afc471f228bd4d0137ce0a32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85707398809f8b56afc471f228bd4d0137ce0a32/comments", "author": null, "committer": null, "parents": [{"sha": "92dd995e1705a8c398a5266c8483e2519e494f47", "url": "https://api.github.com/repos/rust-lang/rust/commits/92dd995e1705a8c398a5266c8483e2519e494f47", "html_url": "https://github.com/rust-lang/rust/commit/92dd995e1705a8c398a5266c8483e2519e494f47"}], "stats": {"total": 278, "additions": 278, "deletions": 0}, "files": [{"sha": "1ad4611dc9ee338ae1c06dd836aedf9cf7300012", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/85707398809f8b56afc471f228bd4d0137ce0a32/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85707398809f8b56afc471f228bd4d0137ce0a32/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=85707398809f8b56afc471f228bd4d0137ce0a32", "patch": "@@ -239,6 +239,24 @@ pub fn collect_language_items(krate: &ast::Crate,\n \n lets_do_this! {\n //  Variant name,                    Name,                      Method name;\n+    CharImplItem,                    \"char\",                    char_impl;\n+    StrImplItem,                     \"str\",                     str_impl;\n+    SliceImplItem,                   \"slice\",                   slice_impl;\n+    ConstPtrImplItem,                \"const_ptr\",               const_ptr_impl;\n+    MutPtrImplItem,                  \"mut_ptr\",                 mut_ptr_impl;\n+    I8ImplItem,                      \"i8\",                      i8_impl;\n+    I16ImplItem,                     \"i16\",                     i16_impl;\n+    I32ImplItem,                     \"i32\",                     i32_impl;\n+    I64ImplItem,                     \"i64\",                     i64_impl;\n+    IsizeImplItem,                   \"isize\",                   isize_impl;\n+    U8ImplItem,                      \"u8\",                      u8_impl;\n+    U16ImplItem,                     \"u16\",                     u16_impl;\n+    U32ImplItem,                     \"u32\",                     u32_impl;\n+    U64ImplItem,                     \"u64\",                     u64_impl;\n+    UsizeImplItem,                   \"usize\",                   usize_impl;\n+    F32ImplItem,                     \"f32\",                     f32_impl;\n+    F64ImplItem,                     \"f64\",                     f64_impl;\n+\n     SendTraitLangItem,               \"send\",                    send_trait;\n     SizedTraitLangItem,              \"sized\",                   sized_trait;\n     CopyTraitLangItem,               \"copy\",                    copy_trait;"}, {"sha": "c3e1879fca8ea7e3aba508f9cc312a84e6770086", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/85707398809f8b56afc471f228bd4d0137ce0a32/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85707398809f8b56afc471f228bd4d0137ce0a32/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=85707398809f8b56afc471f228bd4d0137ce0a32", "patch": "@@ -788,6 +788,9 @@ pub struct ctxt<'tcx> {\n     /// is used for lazy resolution of traits.\n     pub populated_external_traits: RefCell<DefIdSet>,\n \n+    /// The set of external primitive inherent implementations that have been read.\n+    pub populated_external_primitive_impls: RefCell<DefIdSet>,\n+\n     /// Borrows\n     pub upvar_capture_map: RefCell<UpvarCaptureMap>,\n \n@@ -2599,6 +2602,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         used_mut_nodes: RefCell::new(NodeSet()),\n         populated_external_types: RefCell::new(DefIdSet()),\n         populated_external_traits: RefCell::new(DefIdSet()),\n+        populated_external_primitive_impls: RefCell::new(DefIdSet()),\n         upvar_capture_map: RefCell::new(FnvHashMap()),\n         extern_const_statics: RefCell::new(DefIdMap()),\n         extern_const_variants: RefCell::new(DefIdMap()),\n@@ -5988,6 +5992,25 @@ pub fn record_trait_implementation(tcx: &ctxt,\n     tcx.trait_impls.borrow_mut().insert(trait_def_id, Rc::new(RefCell::new(vec!(impl_def_id))));\n }\n \n+/// Load primitive inherent implementations if necessary\n+pub fn populate_implementations_for_primitive_if_necessary(tcx: &ctxt, lang_def_id: ast::DefId) {\n+    if lang_def_id.krate == LOCAL_CRATE {\n+        return\n+    }\n+    if tcx.populated_external_primitive_impls.borrow().contains(&lang_def_id) {\n+        return\n+    }\n+\n+    debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\", lang_def_id);\n+\n+    let impl_items = csearch::get_impl_items(&tcx.sess.cstore, lang_def_id);\n+\n+    // Store the implementation info.\n+    tcx.impl_items.borrow_mut().insert(lang_def_id, impl_items);\n+\n+    tcx.populated_external_primitive_impls.borrow_mut().insert(lang_def_id);\n+}\n+\n /// Populates the type context with all the implementations for the given type\n /// if necessary.\n pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,"}, {"sha": "1f7cc3bb64782c714feca91fd27fabddfa9bb3e2", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/85707398809f8b56afc471f228bd4d0137ce0a32/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85707398809f8b56afc471f228bd4d0137ce0a32/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=85707398809f8b56afc471f228bd4d0137ce0a32", "patch": "@@ -289,11 +289,87 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             ty::ty_param(p) => {\n                 self.assemble_inherent_candidates_from_param(self_ty, p);\n             }\n+            ty::ty_char => {\n+                let lang_def_id = self.tcx().lang_items.char_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_str => {\n+                let lang_def_id = self.tcx().lang_items.str_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_vec(_, None) => {\n+                let lang_def_id = self.tcx().lang_items.slice_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_ptr(ty::mt { ty: _, mutbl: ast::MutImmutable }) => {\n+                let lang_def_id = self.tcx().lang_items.const_ptr_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_ptr(ty::mt { ty: _, mutbl: ast::MutMutable }) => {\n+                let lang_def_id = self.tcx().lang_items.mut_ptr_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_int(ast::TyI8) => {\n+                let lang_def_id = self.tcx().lang_items.i8_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_int(ast::TyI16) => {\n+                let lang_def_id = self.tcx().lang_items.i16_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_int(ast::TyI32) => {\n+                let lang_def_id = self.tcx().lang_items.i32_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_int(ast::TyI64) => {\n+                let lang_def_id = self.tcx().lang_items.i64_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_int(ast::TyIs(_)) => {\n+                let lang_def_id = self.tcx().lang_items.isize_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_uint(ast::TyU8) => {\n+                let lang_def_id = self.tcx().lang_items.u8_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_uint(ast::TyU16) => {\n+                let lang_def_id = self.tcx().lang_items.u16_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_uint(ast::TyU32) => {\n+                let lang_def_id = self.tcx().lang_items.u32_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_uint(ast::TyU64) => {\n+                let lang_def_id = self.tcx().lang_items.u64_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_uint(ast::TyUs(_)) => {\n+                let lang_def_id = self.tcx().lang_items.usize_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_float(ast::TyF32) => {\n+                let lang_def_id = self.tcx().lang_items.f32_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n+            ty::ty_float(ast::TyF64) => {\n+                let lang_def_id = self.tcx().lang_items.f64_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n             _ => {\n             }\n         }\n     }\n \n+    fn assemble_inherent_impl_for_primitive(&mut self, lang_def_id: Option<ast::DefId>) {\n+        if let Some(impl_def_id) = lang_def_id {\n+            ty::populate_implementations_for_primitive_if_necessary(self.tcx(), impl_def_id);\n+\n+            self.assemble_inherent_impl_probe(impl_def_id);\n+        }\n+    }\n+\n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: ast::DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary."}, {"sha": "ab694d26b155c9c10a36cbad6becc685d28c7631", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/85707398809f8b56afc471f228bd4d0137ce0a32/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85707398809f8b56afc471f228bd4d0137ce0a32/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=85707398809f8b56afc471f228bd4d0137ce0a32", "patch": "@@ -16,6 +16,7 @@ use middle::ty;\n use syntax::ast::{Item, ItemImpl};\n use syntax::ast;\n use syntax::ast_util;\n+use syntax::codemap::Span;\n use syntax::visit;\n use util::ppaux::{Repr, UserString};\n \n@@ -38,6 +39,23 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n         }\n     }\n \n+    fn check_primitive_impl(&self,\n+                            impl_def_id: ast::DefId,\n+                            lang_def_id: Option<ast::DefId>,\n+                            lang: &str,\n+                            ty: &str,\n+                            span: Span) {\n+        match lang_def_id {\n+            Some(lang_def_id) if lang_def_id == impl_def_id => { /* OK */ },\n+            _ => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    &format!(\"only a single inherent implementation marked with `#[lang = \\\"{}\\\"]` \\\n+                              is allowed for the `{}` primitive\", lang, ty));\n+            }\n+        }\n+    }\n+\n     /// Checks exactly one impl for orphan rules and other such\n     /// restrictions.  In this fn, it can happen that multiple errors\n     /// apply to a specific impl, so just return after reporting one\n@@ -62,6 +80,125 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                     ty::ty_uniq(..) => {\n                         self.check_def_id(item, self.tcx.lang_items.owned_box().unwrap());\n                     }\n+                    ty::ty_char => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.char_impl(),\n+                                                  \"char\",\n+                                                  \"char\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_str => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.str_impl(),\n+                                                  \"str\",\n+                                                  \"str\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_vec(_, None) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.slice_impl(),\n+                                                  \"slice\",\n+                                                  \"[T]\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_ptr(ty::mt { ty: _, mutbl: ast::MutImmutable }) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.const_ptr_impl(),\n+                                                  \"const_ptr\",\n+                                                  \"*const T\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_ptr(ty::mt { ty: _, mutbl: ast::MutMutable }) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.mut_ptr_impl(),\n+                                                  \"mut_ptr\",\n+                                                  \"*mut T\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_int(ast::TyI8) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.i8_impl(),\n+                                                  \"i8\",\n+                                                  \"i8\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_int(ast::TyI16) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.i16_impl(),\n+                                                  \"i16\",\n+                                                  \"i16\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_int(ast::TyI32) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.i32_impl(),\n+                                                  \"i32\",\n+                                                  \"i32\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_int(ast::TyI64) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.i64_impl(),\n+                                                  \"i64\",\n+                                                  \"i64\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_int(ast::TyIs(_)) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.isize_impl(),\n+                                                  \"isize\",\n+                                                  \"isize\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_uint(ast::TyU8) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.u8_impl(),\n+                                                  \"u8\",\n+                                                  \"u8\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_uint(ast::TyU16) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.u16_impl(),\n+                                                  \"u16\",\n+                                                  \"u16\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_uint(ast::TyU32) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.u32_impl(),\n+                                                  \"u32\",\n+                                                  \"u32\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_uint(ast::TyU64) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.u64_impl(),\n+                                                  \"u64\",\n+                                                  \"u64\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_uint(ast::TyUs(_)) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.usize_impl(),\n+                                                  \"usize\",\n+                                                  \"usize\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_float(ast::TyF32) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.f32_impl(),\n+                                                  \"f32\",\n+                                                  \"f32\",\n+                                                  item.span);\n+                    }\n+                    ty::ty_float(ast::TyF64) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.f64_impl(),\n+                                                  \"f64\",\n+                                                  \"f64\",\n+                                                  item.span);\n+                    }\n                     _ => {\n                         span_err!(self.tcx.sess, item.span, E0118,\n                                   \"no base type found for inherent implementation; \\"}, {"sha": "b2cfcfab78b3775c7c003cd9c7584c604d86c11d", "filename": "src/test/compile-fail/single-primitive-inherent-impl.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/85707398809f8b56afc471f228bd4d0137ce0a32/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85707398809f8b56afc471f228bd4d0137ce0a32/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs?ref=85707398809f8b56afc471f228bd4d0137ce0a32", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+#![crate_type = \"lib\"]\n+#![feature(lang_items)]\n+#![feature(no_std)]\n+#![no_std]\n+\n+// OK\n+#[lang = \"char\"]\n+impl char {}\n+\n+impl char {\n+//~^ error: only a single inherent implementation marked with `#[lang = \"char\"]` is allowed for the `char` primitive\n+}"}]}