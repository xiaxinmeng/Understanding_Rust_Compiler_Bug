{"sha": "b68fd9e6bfd40802afc2a8379824fdcf541c9c1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2OGZkOWU2YmZkNDA4MDJhZmMyYTgzNzk4MjRmZGNmNTQxYzljMWQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-06-28T00:02:05Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-12T09:37:28Z"}, "message": "Move pair handling to its own module", "tree": {"sha": "bcecbdb4f44d781db0c874e475a8feac71d13051", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcecbdb4f44d781db0c874e475a8feac71d13051"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d", "html_url": "https://github.com/rust-lang/rust/commit/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6ea973d19ff1063ff97a95666e988bae226ebb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6ea973d19ff1063ff97a95666e988bae226ebb2", "html_url": "https://github.com/rust-lang/rust/commit/b6ea973d19ff1063ff97a95666e988bae226ebb2"}], "stats": {"total": 234, "additions": 125, "deletions": 109}, "files": [{"sha": "8f167650507b2b00ceddb5d74612efceeee1350e", "filename": "src/expr.rs", "status": "modified", "additions": 1, "deletions": 103, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=b68fd9e6bfd40802afc2a8379824fdcf541c9c1d", "patch": "@@ -31,6 +31,7 @@ use lists::{\n use macros::{rewrite_macro, MacroArg, MacroPosition};\n use matches::rewrite_match;\n use overflow;\n+use pairs::{rewrite_pair, PairParts};\n use patterns::{can_be_overflowed_pat, is_short_pattern, TuplePatField};\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n@@ -435,109 +436,6 @@ fn rewrite_simple_binaries(\n     None\n }\n \n-/// Sigils that decorate a binop pair.\n-#[derive(new, Clone, Copy)]\n-pub struct PairParts<'a> {\n-    prefix: &'a str,\n-    infix: &'a str,\n-    suffix: &'a str,\n-}\n-\n-impl<'a> PairParts<'a> {\n-    pub fn infix(infix: &'a str) -> PairParts<'a> {\n-        PairParts {\n-            prefix: \"\",\n-            infix,\n-            suffix: \"\",\n-        }\n-    }\n-}\n-\n-pub fn rewrite_pair<LHS, RHS>(\n-    lhs: &LHS,\n-    rhs: &RHS,\n-    pp: PairParts,\n-    context: &RewriteContext,\n-    shape: Shape,\n-    separator_place: SeparatorPlace,\n-) -> Option<String>\n-where\n-    LHS: Rewrite,\n-    RHS: Rewrite,\n-{\n-    let lhs_overhead = match separator_place {\n-        SeparatorPlace::Back => shape.used_width() + pp.prefix.len() + pp.infix.trim_right().len(),\n-        SeparatorPlace::Front => shape.used_width(),\n-    };\n-    let lhs_shape = Shape {\n-        width: context.budget(lhs_overhead),\n-        ..shape\n-    };\n-    let lhs_result = lhs\n-        .rewrite(context, lhs_shape)\n-        .map(|lhs_str| format!(\"{}{}\", pp.prefix, lhs_str))?;\n-\n-    // Try to put both lhs and rhs on the same line.\n-    let rhs_orig_result = shape\n-        .offset_left(last_line_width(&lhs_result) + pp.infix.len())\n-        .and_then(|s| s.sub_width(pp.suffix.len()))\n-        .and_then(|rhs_shape| rhs.rewrite(context, rhs_shape));\n-    if let Some(ref rhs_result) = rhs_orig_result {\n-        // If the length of the lhs is equal to or shorter than the tab width or\n-        // the rhs looks like block expression, we put the rhs on the same\n-        // line with the lhs even if the rhs is multi-lined.\n-        let allow_same_line = lhs_result.len() <= context.config.tab_spaces()\n-            || rhs_result\n-                .lines()\n-                .next()\n-                .map(|first_line| first_line.ends_with('{'))\n-                .unwrap_or(false);\n-        if !rhs_result.contains('\\n') || allow_same_line {\n-            let one_line_width = last_line_width(&lhs_result)\n-                + pp.infix.len()\n-                + first_line_width(rhs_result)\n-                + pp.suffix.len();\n-            if one_line_width <= shape.width {\n-                return Some(format!(\n-                    \"{}{}{}{}\",\n-                    lhs_result, pp.infix, rhs_result, pp.suffix\n-                ));\n-            }\n-        }\n-    }\n-\n-    // We have to use multiple lines.\n-    // Re-evaluate the rhs because we have more space now:\n-    let mut rhs_shape = match context.config.indent_style() {\n-        IndentStyle::Visual => shape\n-            .sub_width(pp.suffix.len() + pp.prefix.len())?\n-            .visual_indent(pp.prefix.len()),\n-        IndentStyle::Block => {\n-            // Try to calculate the initial constraint on the right hand side.\n-            let rhs_overhead = shape.rhs_overhead(context.config);\n-            Shape::indented(shape.indent.block_indent(context.config), context.config)\n-                .sub_width(rhs_overhead)?\n-        }\n-    };\n-    let infix = match separator_place {\n-        SeparatorPlace::Back => pp.infix.trim_right(),\n-        SeparatorPlace::Front => pp.infix.trim_left(),\n-    };\n-    if separator_place == SeparatorPlace::Front {\n-        rhs_shape = rhs_shape.offset_left(infix.len())?;\n-    }\n-    let rhs_result = rhs.rewrite(context, rhs_shape)?;\n-    let indent_str = rhs_shape.indent.to_string_with_newline(context.config);\n-    let infix_with_sep = match separator_place {\n-        SeparatorPlace::Back => format!(\"{}{}\", infix, indent_str),\n-        SeparatorPlace::Front => format!(\"{}{}\", indent_str, infix),\n-    };\n-    Some(format!(\n-        \"{}{}{}{}\",\n-        lhs_result, infix_with_sep, rhs_result, pp.suffix\n-    ))\n-}\n-\n pub fn rewrite_array<T: Rewrite + Spanned + ToExpr>(\n     name: &str,\n     exprs: &[&T],"}, {"sha": "2c9a792d92d311444cfe2070d30eb32550a3096c", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b68fd9e6bfd40802afc2a8379824fdcf541c9c1d", "patch": "@@ -86,6 +86,7 @@ mod matches;\n mod missed_spans;\n pub(crate) mod modules;\n mod overflow;\n+mod pairs;\n mod patterns;\n mod reorder;\n mod rewrite;"}, {"sha": "55c78b641a0112153f2af9ff335842f7f6f66d17", "filename": "src/pairs.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d/src%2Fpairs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d/src%2Fpairs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpairs.rs?ref=b68fd9e6bfd40802afc2a8379824fdcf541c9c1d", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use config::lists::*;\n+\n+use config::IndentStyle;\n+use rewrite::{Rewrite, RewriteContext};\n+use shape::Shape;\n+use utils::{first_line_width, last_line_width};\n+\n+/// Sigils that decorate a binop pair.\n+#[derive(new, Clone, Copy)]\n+pub struct PairParts<'a> {\n+    prefix: &'a str,\n+    infix: &'a str,\n+    suffix: &'a str,\n+}\n+\n+impl<'a> PairParts<'a> {\n+    pub fn infix(infix: &'a str) -> PairParts<'a> {\n+        PairParts {\n+            prefix: \"\",\n+            infix,\n+            suffix: \"\",\n+        }\n+    }\n+}\n+\n+pub fn rewrite_pair<LHS, RHS>(\n+    lhs: &LHS,\n+    rhs: &RHS,\n+    pp: PairParts,\n+    context: &RewriteContext,\n+    shape: Shape,\n+    separator_place: SeparatorPlace,\n+) -> Option<String>\n+where\n+    LHS: Rewrite,\n+    RHS: Rewrite,\n+{\n+    let lhs_overhead = match separator_place {\n+        SeparatorPlace::Back => shape.used_width() + pp.prefix.len() + pp.infix.trim_right().len(),\n+        SeparatorPlace::Front => shape.used_width(),\n+    };\n+    let lhs_shape = Shape {\n+        width: context.budget(lhs_overhead),\n+        ..shape\n+    };\n+    let lhs_result = lhs\n+        .rewrite(context, lhs_shape)\n+        .map(|lhs_str| format!(\"{}{}\", pp.prefix, lhs_str))?;\n+\n+    // Try to put both lhs and rhs on the same line.\n+    let rhs_orig_result = shape\n+        .offset_left(last_line_width(&lhs_result) + pp.infix.len())\n+        .and_then(|s| s.sub_width(pp.suffix.len()))\n+        .and_then(|rhs_shape| rhs.rewrite(context, rhs_shape));\n+    if let Some(ref rhs_result) = rhs_orig_result {\n+        // If the length of the lhs is equal to or shorter than the tab width or\n+        // the rhs looks like block expression, we put the rhs on the same\n+        // line with the lhs even if the rhs is multi-lined.\n+        let allow_same_line = lhs_result.len() <= context.config.tab_spaces()\n+            || rhs_result\n+                .lines()\n+                .next()\n+                .map(|first_line| first_line.ends_with('{'))\n+                .unwrap_or(false);\n+        if !rhs_result.contains('\\n') || allow_same_line {\n+            let one_line_width = last_line_width(&lhs_result)\n+                + pp.infix.len()\n+                + first_line_width(rhs_result)\n+                + pp.suffix.len();\n+            if one_line_width <= shape.width {\n+                return Some(format!(\n+                    \"{}{}{}{}\",\n+                    lhs_result, pp.infix, rhs_result, pp.suffix\n+                ));\n+            }\n+        }\n+    }\n+\n+    // We have to use multiple lines.\n+    // Re-evaluate the rhs because we have more space now:\n+    let mut rhs_shape = match context.config.indent_style() {\n+        IndentStyle::Visual => shape\n+            .sub_width(pp.suffix.len() + pp.prefix.len())?\n+            .visual_indent(pp.prefix.len()),\n+        IndentStyle::Block => {\n+            // Try to calculate the initial constraint on the right hand side.\n+            let rhs_overhead = shape.rhs_overhead(context.config);\n+            Shape::indented(shape.indent.block_indent(context.config), context.config)\n+                .sub_width(rhs_overhead)?\n+        }\n+    };\n+    let infix = match separator_place {\n+        SeparatorPlace::Back => pp.infix.trim_right(),\n+        SeparatorPlace::Front => pp.infix.trim_left(),\n+    };\n+    if separator_place == SeparatorPlace::Front {\n+        rhs_shape = rhs_shape.offset_left(infix.len())?;\n+    }\n+    let rhs_result = rhs.rewrite(context, rhs_shape)?;\n+    let indent_str = rhs_shape.indent.to_string_with_newline(context.config);\n+    let infix_with_sep = match separator_place {\n+        SeparatorPlace::Back => format!(\"{}{}\", infix, indent_str),\n+        SeparatorPlace::Front => format!(\"{}{}\", indent_str, infix),\n+    };\n+    Some(format!(\n+        \"{}{}{}{}\",\n+        lhs_result, infix_with_sep, rhs_result, pp.suffix\n+    ))\n+}"}, {"sha": "dbe0c8a6f6623cb49dcd9460e11a887ddc33a419", "filename": "src/patterns.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=b68fd9e6bfd40802afc2a8379824fdcf541c9c1d", "patch": "@@ -15,15 +15,14 @@ use syntax::ptr;\n \n use codemap::SpanUtils;\n use comment::FindUncommented;\n-use expr::{\n-    can_be_overflowed_expr, rewrite_pair, rewrite_unary_prefix, wrap_struct_field, PairParts,\n-};\n+use expr::{can_be_overflowed_expr, rewrite_unary_prefix, wrap_struct_field};\n use lists::{\n     itemize_list, shape_for_tactic, struct_lit_formatting, struct_lit_shape, struct_lit_tactic,\n     write_list,\n };\n use macros::{rewrite_macro, MacroPosition};\n use overflow;\n+use pairs::{rewrite_pair, PairParts};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;"}, {"sha": "0c978ea28a6792c739c1cb76fc164de9434af064", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=b68fd9e6bfd40802afc2a8379824fdcf541c9c1d", "patch": "@@ -18,12 +18,11 @@ use syntax::symbol::keywords;\n \n use codemap::SpanUtils;\n use config::{IndentStyle, TypeDensity};\n-use expr::{\n-    rewrite_assign_rhs, rewrite_pair, rewrite_tuple, rewrite_unary_prefix, PairParts, ToExpr,\n-};\n+use expr::{rewrite_assign_rhs, rewrite_tuple, rewrite_unary_prefix, ToExpr};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n use macros::{rewrite_macro, MacroPosition};\n use overflow;\n+use pairs::{rewrite_pair, PairParts};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;"}]}