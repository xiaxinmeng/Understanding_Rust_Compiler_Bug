{"sha": "d67d1f24dc8b7ba8c00dacde3ee86c75aa85e91e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2N2QxZjI0ZGM4YjdiYThjMDBkYWNkZTNlZTg2Yzc1YWE4NWU5MWU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-29T06:15:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-29T06:15:48Z"}, "message": "Rollup merge of #58975 - jtdowney:iter_arith_traits_option, r=dtolnay\n\nImplement `iter::Sum` and `iter::Product` for `Option`\n\nThis is similar to the existing implementation for `Result`. It will take each item into the accumulator unless a `None` is returned.\n\nI based a lot of this on #38580. From that discussion it didn't seem like this addition would be too controversial or difficult. One thing I still don't understand is picking the values for the `stable` attribute. This is my first non-documentation PR for rust so I am open to any feedback on improvements.", "tree": {"sha": "969814388705377c8cecbf68e70d12ace3667853", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/969814388705377c8cecbf68e70d12ace3667853"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d67d1f24dc8b7ba8c00dacde3ee86c75aa85e91e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc7iOUCRBK7hj4Ov3rIwAAdHIIAI5g3vWEk+mCrULvEuKWFxUT\nDhv6IXgxIu6H6LrPixbD8mJrOy+8gcsvfnxyzKuDtofRnBA9jvH/1W/DJoHCGPRt\nDEmLXpaM4Oa8Ld2L79lNDBblAfKoOb3YJmQO+FzQe8rwSkA+UK5CrLiP7JauInQA\naPHVvCTa/zqjiXPeNkVAvfxVeba9JRRyOn8H+qad/9JO/5CXvygWHtfm6kExnFFz\nspweBsSDYGMg1PC4nZgYClaNi1E5YTeTsDOy+lFMApeGRxYpE26J8vStKfsBqjSd\nUshnHuih3Dk6bj4Bf3k01MS/MICEO74X81gY0mwkrPtXmlM+bGt2I+68gKbJ0dI=\n=yA5s\n-----END PGP SIGNATURE-----\n", "payload": "tree 969814388705377c8cecbf68e70d12ace3667853\nparent 4b9d80325a65b0375eea526409a0f3aaf1cbc23c\nparent 9f8d934f271fcaf9c34aefa8062b7563cfd34721\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1559110548 +0200\ncommitter GitHub <noreply@github.com> 1559110548 +0200\n\nRollup merge of #58975 - jtdowney:iter_arith_traits_option, r=dtolnay\n\nImplement `iter::Sum` and `iter::Product` for `Option`\n\nThis is similar to the existing implementation for `Result`. It will take each item into the accumulator unless a `None` is returned.\n\nI based a lot of this on #38580. From that discussion it didn't seem like this addition would be too controversial or difficult. One thing I still don't understand is picking the values for the `stable` attribute. This is my first non-documentation PR for rust so I am open to any feedback on improvements.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d67d1f24dc8b7ba8c00dacde3ee86c75aa85e91e", "html_url": "https://github.com/rust-lang/rust/commit/d67d1f24dc8b7ba8c00dacde3ee86c75aa85e91e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d67d1f24dc8b7ba8c00dacde3ee86c75aa85e91e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "html_url": "https://github.com/rust-lang/rust/commit/4b9d80325a65b0375eea526409a0f3aaf1cbc23c"}, {"sha": "9f8d934f271fcaf9c34aefa8062b7563cfd34721", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f8d934f271fcaf9c34aefa8062b7563cfd34721", "html_url": "https://github.com/rust-lang/rust/commit/9f8d934f271fcaf9c34aefa8062b7563cfd34721"}], "stats": {"total": 126, "additions": 126, "deletions": 0}, "files": [{"sha": "4eac5cbc8e6623142563d8e3186994e4ceb3bfe1", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d67d1f24dc8b7ba8c00dacde3ee86c75aa85e91e/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67d1f24dc8b7ba8c00dacde3ee86c75aa85e91e/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=d67d1f24dc8b7ba8c00dacde3ee86c75aa85e91e", "patch": "@@ -223,3 +223,113 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n         ResultShunt::process(iter, |i| i.product())\n     }\n }\n+\n+/// An iterator adapter that produces output as long as the underlying\n+/// iterator produces `Option::Some` values.\n+struct OptionShunt<I> {\n+    iter: I,\n+    exited_early: bool,\n+}\n+\n+impl<I, T> OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    /// Process the given iterator as if it yielded a `T` instead of a\n+    /// `Option<T>`. Any `None` value will stop the inner iterator and\n+    /// the overall result will be a `None`.\n+    pub fn process<F, U>(iter: I, mut f: F) -> Option<U>\n+    where\n+        F: FnMut(&mut Self) -> U,\n+    {\n+        let mut shunt = OptionShunt::new(iter);\n+        let value = f(shunt.by_ref());\n+        shunt.reconstruct(value)\n+    }\n+\n+    fn new(iter: I) -> Self {\n+        OptionShunt {\n+            iter,\n+            exited_early: false,\n+        }\n+    }\n+\n+    /// Consume the adapter and rebuild a `Option` value.\n+    fn reconstruct<U>(self, val: U) -> Option<U> {\n+        if self.exited_early {\n+            None\n+        } else {\n+            Some(val)\n+        }\n+    }\n+}\n+\n+impl<I, T> Iterator for OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.iter.next() {\n+            Some(Some(v)) => Some(v),\n+            Some(None) => {\n+                self.exited_early = true;\n+                None\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.exited_early {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_option\", since = \"1.37.0\")]\n+impl<T, U> Sum<Option<U>> for Option<T>\n+where\n+    T: Sum<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is a `None`, no further\n+    /// elements are taken, and the `None` is returned. Should no `None` occur,\n+    /// the sum of all elements is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This sums up the position of the character 'a' in a vector of strings,\n+    /// if a word did not have the character 'a' the operation returns `None`:\n+    ///\n+    /// ```\n+    /// let words = vec![\"have\", \"a\", \"great\", \"day\"];\n+    /// let total: Option<usize> = words.iter().map(|w| w.find('a')).sum();\n+    /// assert_eq!(total, Some(5));\n+    /// ```\n+    fn sum<I>(iter: I) -> Option<T>\n+    where\n+        I: Iterator<Item = Option<U>>,\n+    {\n+        OptionShunt::process(iter, |i| i.sum())\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_option\", since = \"1.37.0\")]\n+impl<T, U> Product<Option<U>> for Option<T>\n+where\n+    T: Product<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is a `None`, no further\n+    /// elements are taken, and the `None` is returned. Should no `None` occur,\n+    /// the product of all elements is returned.\n+    fn product<I>(iter: I) -> Option<T>\n+    where\n+        I: Iterator<Item = Option<U>>,\n+    {\n+        OptionShunt::process(iter, |i| i.product())\n+    }\n+}"}, {"sha": "bedb9e756129c5a0322e3dbe22bbbbeb74992950", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d67d1f24dc8b7ba8c00dacde3ee86c75aa85e91e/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d67d1f24dc8b7ba8c00dacde3ee86c75aa85e91e/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=d67d1f24dc8b7ba8c00dacde3ee86c75aa85e91e", "patch": "@@ -1084,6 +1084,14 @@ fn test_iterator_sum_result() {\n     assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Err(()));\n }\n \n+#[test]\n+fn test_iterator_sum_option() {\n+    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), Some(10));\n+    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), None);\n+}\n+\n #[test]\n fn test_iterator_product() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n@@ -1126,6 +1134,14 @@ impl Ord for Mod3 {\n     }\n }\n \n+#[test]\n+fn test_iterator_product_option() {\n+    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().product::<Option<i32>>(), Some(24));\n+    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().product::<Option<i32>>(), None);\n+}\n+\n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];"}]}