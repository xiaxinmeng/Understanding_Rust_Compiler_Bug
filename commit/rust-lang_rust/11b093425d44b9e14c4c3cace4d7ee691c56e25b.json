{"sha": "11b093425d44b9e14c4c3cace4d7ee691c56e25b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExYjA5MzQyNWQ0NGI5ZTE0YzRjM2NhY2U0ZDdlZTY5MWM1NmUyNWI=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-06-20T23:42:21Z"}, "committer": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-07-04T00:30:45Z"}, "message": "liburl: Simplify encoding/decoding using iterators.", "tree": {"sha": "04d17fe02e04c01d0b53369f88e8f17da897660c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04d17fe02e04c01d0b53369f88e8f17da897660c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11b093425d44b9e14c4c3cace4d7ee691c56e25b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11b093425d44b9e14c4c3cace4d7ee691c56e25b", "html_url": "https://github.com/rust-lang/rust/commit/11b093425d44b9e14c4c3cace4d7ee691c56e25b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11b093425d44b9e14c4c3cace4d7ee691c56e25b/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed47c479d73fd7b57d3b493e03c74e2932733163", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed47c479d73fd7b57d3b493e03c74e2932733163", "html_url": "https://github.com/rust-lang/rust/commit/ed47c479d73fd7b57d3b493e03c74e2932733163"}], "stats": {"total": 602, "additions": 266, "deletions": 336}, "files": [{"sha": "29df376a28f1e24b13f83ea6e148e4762654a15d", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 266, "deletions": 336, "changes": 602, "blob_url": "https://github.com/rust-lang/rust/blob/11b093425d44b9e14c4c3cace4d7ee691c56e25b/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b093425d44b9e14c4c3cace4d7ee691c56e25b/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=11b093425d44b9e14c4c3cace4d7ee691c56e25b", "patch": "@@ -25,8 +25,6 @@ use std::collections::HashMap;\n use std::fmt;\n use std::from_str::FromStr;\n use std::hash;\n-use std::io::BufReader;\n-use std::string::String;\n use std::uint;\n \n /// A Uniform Resource Locator (URL).  A URL is a form of URI (Uniform Resource\n@@ -110,7 +108,7 @@ impl Url {\n     /// `Err(e)` if the string did not represent a valid URL, where `e` is a\n     /// `String` error message. Otherwise, `Ok(u)` where `u` is a `Url` struct\n     /// representing the URL.\n-    pub fn parse(rawurl: &str) -> Result<Url, String> {\n+    pub fn parse(rawurl: &str) -> DecodeResult<Url> {\n         // scheme\n         let (scheme, rest) = try!(get_scheme(rawurl));\n \n@@ -155,7 +153,7 @@ impl Path {\n     /// `Err(e)` if the string did not represent a valid URL path, where `e` is a\n     /// `String` error message. Otherwise, `Ok(p)` where `p` is a `Path` struct\n     /// representing the URL path.\n-    pub fn parse(rawpath: &str) -> Result<Path, String> {\n+    pub fn parse(rawpath: &str) -> DecodeResult<Path> {\n         let (path, rest) = try!(get_path(rawpath, false));\n \n         // query and fragment\n@@ -178,293 +176,220 @@ impl UserInfo {\n }\n \n fn encode_inner(s: &str, full_url: bool) -> String {\n-    let mut rdr = BufReader::new(s.as_bytes());\n-    let mut out = String::new();\n-\n-    loop {\n-        let mut buf = [0];\n-        let ch = match rdr.read(buf) {\n-            Err(..) => break,\n-            Ok(..) => buf[0] as char,\n+    s.bytes().fold(String::new(), |mut out, b| {\n+        match b as char {\n+            // unreserved:\n+            'A' .. 'Z'\n+            | 'a' .. 'z'\n+            | '0' .. '9'\n+            | '-' | '.' | '_' | '~' => out.push_char(b as char),\n+\n+            // gen-delims:\n+            ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+            // sub-delims:\n+            '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+            '+' | ',' | ';' | '='\n+                if full_url => out.push_char(b as char),\n+\n+            ch => out.push_str(format!(\"%{:02X}\", ch as uint).as_slice()),\n         };\n \n-        match ch {\n-          // unreserved:\n-          'A' .. 'Z' |\n-          'a' .. 'z' |\n-          '0' .. '9' |\n-          '-' | '.' | '_' | '~' => {\n-            out.push_char(ch);\n-          }\n-          _ => {\n-              if full_url {\n-                match ch {\n-                  // gen-delims:\n-                  ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-\n-                  // sub-delims:\n-                  '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                  '+' | ',' | ';' | '=' => {\n-                    out.push_char(ch);\n-                  }\n-\n-                  _ => out.push_str(format!(\"%{:02X}\", ch as uint).as_slice())\n-                }\n-            } else {\n-                out.push_str(format!(\"%{:02X}\", ch as uint).as_slice());\n-            }\n-          }\n-        }\n-    }\n-\n-    out\n+        out\n+    })\n }\n \n-/**\n- * Encodes a URI by replacing reserved characters with percent-encoded\n- * character sequences.\n- *\n- * This function is compliant with RFC 3986.\n- *\n- * # Example\n- *\n- * ```rust\n- * use url::encode;\n- *\n- * let url = encode(\"https://example.com/Rust (programming language)\");\n- * println!(\"{}\", url); // https://example.com/Rust%20(programming%20language)\n- * ```\n- */\n+/// Encodes a URI by replacing reserved characters with percent-encoded\n+/// character sequences.\n+///\n+/// This function is compliant with RFC 3986.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use url::encode;\n+///\n+/// let url = encode(\"https://example.com/Rust (programming language)\");\n+/// println!(\"{}\", url); // https://example.com/Rust%20(programming%20language)\n+/// ```\n pub fn encode(s: &str) -> String {\n     encode_inner(s, true)\n }\n \n-/**\n- * Encodes a URI component by replacing reserved characters with percent-\n- * encoded character sequences.\n- *\n- * This function is compliant with RFC 3986.\n- */\n \n+/// Encodes a URI component by replacing reserved characters with percent-\n+/// encoded character sequences.\n+///\n+/// This function is compliant with RFC 3986.\n pub fn encode_component(s: &str) -> String {\n     encode_inner(s, false)\n }\n \n-fn decode_inner(s: &str, full_url: bool) -> String {\n-    let mut rdr = BufReader::new(s.as_bytes());\n-    let mut out = String::new();\n+pub type DecodeResult<T> = Result<T, String>;\n \n-    loop {\n-        let mut buf = [0];\n-        let ch = match rdr.read(buf) {\n-            Err(..) => break,\n-            Ok(..) => buf[0] as char\n-        };\n-        match ch {\n-          '%' => {\n-            let mut bytes = [0, 0];\n-            match rdr.read(bytes) {\n-                Ok(2) => {}\n-                _ => fail!() // FIXME: malformed url?\n-            }\n-            let ch = uint::parse_bytes(bytes, 16u).unwrap() as u8 as char;\n-\n-            if full_url {\n-                // Only decode some characters:\n-                match ch {\n-                  // gen-delims:\n-                  ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-\n-                  // sub-delims:\n-                  '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                  '+' | ',' | ';' | '=' => {\n-                    out.push_char('%');\n-                    out.push_char(bytes[0u] as char);\n-                    out.push_char(bytes[1u] as char);\n-                  }\n-\n-                  ch => out.push_char(ch)\n-                }\n-            } else {\n-                  out.push_char(ch);\n-            }\n-          }\n-          ch => out.push_char(ch)\n-        }\n-    }\n-\n-    out\n-}\n-\n-/**\n- * Decodes a percent-encoded string representing a URI.\n- *\n- * This will only decode escape sequences generated by `encode`.\n- *\n- * # Example\n- *\n- * ```rust\n- * use url::decode;\n- *\n- * let url = decode(\"https://example.com/Rust%20(programming%20language)\");\n- * println!(\"{}\", url); // https://example.com/Rust (programming language)\n- * ```\n- */\n-pub fn decode(s: &str) -> String {\n+/// Decodes a percent-encoded string representing a URI.\n+///\n+/// This will only decode escape sequences generated by `encode`.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use url::decode;\n+///\n+/// let url = decode(\"https://example.com/Rust%20(programming%20language)\");\n+/// println!(\"{}\", url); // https://example.com/Rust (programming language)\n+/// ```\n+pub fn decode(s: &str) -> DecodeResult<String> {\n     decode_inner(s, true)\n }\n \n-/**\n- * Decode a string encoded with percent encoding.\n- */\n-pub fn decode_component(s: &str) -> String {\n+/// Decode a string encoded with percent encoding.\n+pub fn decode_component(s: &str) -> DecodeResult<String> {\n     decode_inner(s, false)\n }\n \n-fn encode_plus(s: &str) -> String {\n-    let mut rdr = BufReader::new(s.as_bytes());\n+fn decode_inner(s: &str, full_url: bool) -> DecodeResult<String> {\n     let mut out = String::new();\n+    let mut iter = s.bytes();\n \n     loop {\n-        let mut buf = [0];\n-        let ch = match rdr.read(buf) {\n-            Ok(..) => buf[0] as char,\n-            Err(..) => break,\n-        };\n-        match ch {\n-          'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n-            out.push_char(ch);\n-          }\n-          ' ' => out.push_char('+'),\n-          _ => out.push_str(format!(\"%{:X}\", ch as uint).as_slice())\n+        match iter.next() {\n+            Some(b) => match b as char {\n+                '%' => {\n+                    let bytes = match (iter.next(), iter.next()) {\n+                        (Some(one), Some(two)) => [one as u8, two as u8],\n+                        _ => return Err(format!(\"Malformed input: found '%' \\\n+                                                without two trailing bytes\")),\n+                    };\n+\n+                    // Only decode some characters if full_url:\n+                    match uint::parse_bytes(bytes, 16u).unwrap() as u8 as char {\n+                        // gen-delims:\n+                        ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+\n+                        // sub-delims:\n+                        '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+                        '+' | ',' | ';' | '='\n+                            if full_url => {\n+                            out.push_char('%');\n+                            out.push_char(bytes[0u] as char);\n+                            out.push_char(bytes[1u] as char);\n+                        }\n+\n+                        ch => out.push_char(ch)\n+                    }\n+                }\n+                ch => out.push_char(ch)\n+            },\n+            None => return Ok(out),\n         }\n     }\n-\n-    out\n }\n \n-/**\n- * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n- */\n+/// Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n pub fn encode_form_urlencoded(m: &HashMap<String, Vec<String>>) -> String {\n-    let mut out = String::new();\n-    let mut first = true;\n+    fn encode_plus<T: Str>(s: &T) -> String {\n+        s.as_slice().bytes().fold(String::new(), |mut out, b| {\n+            match b as char {\n+              'A' .. 'Z'\n+              | 'a' .. 'z'\n+              | '0' .. '9'\n+              | '_' | '.' | '-' => out.push_char(b as char),\n+              ' ' => out.push_char('+'),\n+              ch => out.push_str(format!(\"%{:X}\", ch as uint).as_slice())\n+            }\n+\n+            out\n+        })\n+    }\n \n-    for (key, values) in m.iter() {\n-        let key = encode_plus(key.as_slice());\n+    let mut first = true;\n+    m.iter().fold(String::new(), |mut out, (key, values)| {\n+        let key = encode_plus(key);\n \n         for value in values.iter() {\n             if first {\n                 first = false;\n             } else {\n                 out.push_char('&');\n-                first = false;\n             }\n \n-            out.push_str(format!(\"{}={}\",\n-                                 key,\n-                                 encode_plus(value.as_slice())).as_slice());\n+            out.push_str(key.as_slice());\n+            out.push_char('=');\n+            out.push_str(encode_plus(value).as_slice());\n         }\n-    }\n \n-    out\n+        out\n+    })\n }\n \n-/**\n- * Decode a string encoded with the 'application/x-www-form-urlencoded' media\n- * type into a hashmap.\n- */\n-#[allow(experimental)]\n-pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<String, Vec<String>> {\n-    let mut rdr = BufReader::new(s);\n-    let mut m: HashMap<String,Vec<String>> = HashMap::new();\n+/// Decode a string encoded with the 'application/x-www-form-urlencoded' media\n+/// type into a hashmap.\n+pub fn decode_form_urlencoded(s: &[u8])\n+                            -> DecodeResult<HashMap<String, Vec<String>>> {\n+    fn maybe_push_value(map: &mut HashMap<String, Vec<String>>,\n+                        key: String,\n+                        value: String) {\n+        if key.len() > 0 && value.len() > 0 {\n+            let values = map.find_or_insert_with(key, |_| vec!());\n+            values.push(value);\n+        }\n+    }\n+\n+    let mut out = HashMap::new();\n+    let mut iter = s.iter().map(|&x| x);\n+\n     let mut key = String::new();\n     let mut value = String::new();\n     let mut parsing_key = true;\n \n     loop {\n-        let mut buf = [0];\n-        let ch = match rdr.read(buf) {\n-            Ok(..) => buf[0] as char,\n-            Err(..) => break,\n-        };\n-        match ch {\n-            '&' | ';' => {\n-                if key.len() > 0 && value.len() > 0 {\n-                    let mut values = match m.pop_equiv(&key.as_slice()) {\n-                        Some(values) => values,\n-                        None => vec!(),\n-                    };\n-\n-                    values.push(value);\n-                    m.insert(key, values);\n+        match iter.next() {\n+            Some(b) => match b as char {\n+                '&' | ';' => {\n+                    maybe_push_value(&mut out, key, value);\n+\n+                    parsing_key = true;\n+                    key = String::new();\n+                    value = String::new();\n                 }\n-\n-                parsing_key = true;\n-                key = String::new();\n-                value = String::new();\n-            }\n-            '=' => parsing_key = false,\n-            ch => {\n-                let ch = match ch {\n-                    '%' => {\n-                        let mut bytes = [0, 0];\n-                        match rdr.read(bytes) {\n-                            Ok(2) => {}\n-                            _ => fail!() // FIXME: malformed?\n+                '=' => parsing_key = false,\n+                ch => {\n+                    let ch = match ch {\n+                        '%' => {\n+                            let bytes = match (iter.next(), iter.next()) {\n+                                (Some(one), Some(two)) => [one as u8, two as u8],\n+                                _ => return Err(format!(\"Malformed input: found \\\n+                                                '%' without two trailing bytes\"))\n+                            };\n+\n+                            uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n                         }\n-                        uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n-                    }\n-                    '+' => ' ',\n-                    ch => ch\n-                };\n+                        '+' => ' ',\n+                        ch => ch\n+                    };\n \n-                if parsing_key {\n-                    key.push_char(ch)\n-                } else {\n-                    value.push_char(ch)\n+                    if parsing_key {\n+                        key.push_char(ch)\n+                    } else {\n+                        value.push_char(ch)\n+                    }\n                 }\n+            },\n+            None => {\n+                maybe_push_value(&mut out, key, value);\n+                return Ok(out)\n             }\n         }\n     }\n-\n-    if key.len() > 0 && value.len() > 0 {\n-        let mut values = match m.pop_equiv(&key.as_slice()) {\n-            Some(values) => values,\n-            None => vec!(),\n-        };\n-\n-        values.push(value);\n-        m.insert(key, values);\n-    }\n-\n-    m\n }\n \n+fn split_char_first<'a>(s: &'a str, c: char) -> (&'a str, &'a str) {\n+    let mut iter = s.splitn(c, 1);\n \n-fn split_char_first(s: &str, c: char) -> (String, String) {\n-    let len = s.len();\n-    let mut index = len;\n-    let mut mat = 0;\n-    let mut rdr = BufReader::new(s.as_bytes());\n-    loop {\n-        let mut buf = [0];\n-        let ch = match rdr.read(buf) {\n-            Ok(..) => buf[0] as char,\n-            Err(..) => break,\n-        };\n-        if ch == c {\n-            // found a match, adjust markers\n-            index = (rdr.tell().unwrap() as uint) - 1;\n-            mat = 1;\n-            break;\n-        }\n-    }\n-    if index+mat == len {\n-        return (s.slice(0, index).to_string(), \"\".to_string());\n-    } else {\n-        return (s.slice(0, index).to_string(),\n-                s.slice(index + mat, s.len()).to_string());\n+    match (iter.next(), iter.next()) {\n+        (Some(a), Some(b)) => (a, b),\n+        (Some(a), None) => (a, \"\"),\n+        (None, _) => unreachable!(),\n     }\n }\n \n@@ -477,42 +402,40 @@ impl fmt::Show for UserInfo {\n     }\n }\n \n-fn query_from_str(rawquery: &str) -> Query {\n+fn query_from_str(rawquery: &str) -> DecodeResult<Query> {\n     let mut query: Query = vec!();\n     if !rawquery.is_empty() {\n         for p in rawquery.split('&') {\n             let (k, v) = split_char_first(p, '=');\n-            query.push((decode_component(k.as_slice()),\n-                        decode_component(v.as_slice())));\n-        };\n+            query.push((try!(decode_component(k)),\n+                        try!(decode_component(v))));\n+        }\n     }\n-    return query;\n+\n+    Ok(query)\n }\n \n-/**\n- * Converts an instance of a URI `Query` type to a string.\n- *\n- * # Example\n- *\n- * ```rust\n- * let query = vec!((\"title\".to_string(), \"The Village\".to_string()),\n- *                  (\"north\".to_string(), \"52.91\".to_string()),\n- *                  (\"west\".to_string(), \"4.10\".to_string()));\n- * println!(\"{}\", url::query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n- * ```\n- */\n-#[allow(unused_must_use)]\n+/// Converts an instance of a URI `Query` type to a string.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// let query = vec!((\"title\".to_string(), \"The Village\".to_string()),\n+///                  (\"north\".to_string(), \"52.91\".to_string()),\n+///                  (\"west\".to_string(), \"4.10\".to_string()));\n+/// println!(\"{}\", url::query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n+/// ```\n pub fn query_to_str(query: &Query) -> String {\n-    use std::io::MemWriter;\n-    use std::str;\n-\n-    let mut writer = MemWriter::new();\n-    for (i, &(ref k, ref v)) in query.iter().enumerate() {\n-        if i != 0 { write!(&mut writer, \"&\"); }\n-        write!(&mut writer, \"{}={}\", encode_component(k.as_slice()),\n-               encode_component(v.as_slice()));\n-    }\n-    str::from_utf8_lossy(writer.unwrap().as_slice()).to_string()\n+    query.iter().enumerate().fold(String::new(), |mut out, (i, &(ref k, ref v))| {\n+        if i != 0 {\n+            out.push_char('&');\n+        }\n+\n+        out.push_str(encode_component(k.as_slice()).as_slice());\n+        out.push_char('=');\n+        out.push_str(encode_component(v.as_slice()).as_slice());\n+        out\n+    })\n }\n \n /**\n@@ -532,7 +455,7 @@ pub fn query_to_str(query: &Query) -> String {\n  * println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n  * ```\n  */\n-pub fn get_scheme(rawurl: &str) -> Result<(String, String), String> {\n+pub fn get_scheme(rawurl: &str) -> DecodeResult<(String, String)> {\n     for (i,c) in rawurl.chars().enumerate() {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => continue,\n@@ -568,7 +491,7 @@ enum Input {\n \n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: &str) ->\n-    Result<(Option<UserInfo>, String, Option<String>, String), String> {\n+    DecodeResult<(Option<UserInfo>, String, Option<String>, String)> {\n     if !rawurl.starts_with(\"//\") {\n         // there is no authority.\n         return Ok((None, \"\".to_string(), None, rawurl.to_str()));\n@@ -727,8 +650,7 @@ fn get_authority(rawurl: &str) ->\n \n \n // returns the path and unparsed part of url, or an error\n-fn get_path(rawurl: &str, authority: bool) ->\n-    Result<(String, String), String> {\n+fn get_path(rawurl: &str, authority: bool) -> DecodeResult<(String, String)> {\n     let len = rawurl.len();\n     let mut end = len;\n     for (i,c) in rawurl.chars().enumerate() {\n@@ -746,37 +668,33 @@ fn get_path(rawurl: &str, authority: bool) ->\n         }\n     }\n \n-    if authority {\n-        if end != 0 && !rawurl.starts_with(\"/\") {\n-            return Err(\"Non-empty path must begin with\\\n-                              '/' in presence of authority.\".to_string());\n-        }\n+    if authority && end != 0 && !rawurl.starts_with(\"/\") {\n+        Err(\"Non-empty path must begin with \\\n+            '/' in presence of authority.\".to_string())\n+    } else {\n+        Ok((try!(decode_component(rawurl.slice(0, end))),\n+            rawurl.slice(end, len).to_string()))\n     }\n-\n-    return Ok((decode_component(rawurl.slice(0, end)),\n-                    rawurl.slice(end, len).to_string()));\n }\n \n // returns the parsed query and the fragment, if present\n-fn get_query_fragment(rawurl: &str) ->\n-    Result<(Query, Option<String>), String> {\n+fn get_query_fragment(rawurl: &str) -> DecodeResult<(Query, Option<String>)> {\n     if !rawurl.starts_with(\"?\") {\n         if rawurl.starts_with(\"#\") {\n-            let f = decode_component(rawurl.slice(\n-                                                1,\n-                                                rawurl.len()));\n+            let f = try!(decode_component(rawurl.slice(1, rawurl.len())));\n             return Ok((vec!(), Some(f)));\n         } else {\n             return Ok((vec!(), None));\n         }\n     }\n     let (q, r) = split_char_first(rawurl.slice(1, rawurl.len()), '#');\n     let f = if r.len() != 0 {\n-        Some(decode_component(r.as_slice()))\n+        Some(try!(decode_component(r)))\n     } else {\n         None\n     };\n-    return Ok((query_from_str(q.as_slice()), f));\n+\n+    Ok((try!(query_from_str(q)), f))\n }\n \n impl FromStr for Url {\n@@ -866,12 +784,12 @@ impl<S: hash::Writer> hash::Hash<S> for Path {\n #[test]\n fn test_split_char_first() {\n     let (u,v) = split_char_first(\"hello, sweet world\", ',');\n-    assert_eq!(u, \"hello\".to_string());\n-    assert_eq!(v, \" sweet world\".to_string());\n+    assert_eq!(u, \"hello\");\n+    assert_eq!(v, \" sweet world\");\n \n     let (u,v) = split_char_first(\"hello sweet world\", ',');\n-    assert_eq!(u, \"hello sweet world\".to_string());\n-    assert_eq!(v, \"\".to_string());\n+    assert_eq!(u, \"hello sweet world\");\n+    assert_eq!(v, \"\");\n }\n \n #[test]\n@@ -1195,58 +1113,70 @@ mod tests {\n \n     #[test]\n     fn test_decode() {\n-        assert_eq!(decode(\"\"), \"\".to_string());\n-        assert_eq!(decode(\"abc/def 123\"), \"abc/def 123\".to_string());\n-        assert_eq!(decode(\"abc%2Fdef%20123\"), \"abc%2Fdef 123\".to_string());\n-        assert_eq!(decode(\"%20\"), \" \".to_string());\n-        assert_eq!(decode(\"%21\"), \"%21\".to_string());\n-        assert_eq!(decode(\"%22\"), \"%22\".to_string());\n-        assert_eq!(decode(\"%23\"), \"%23\".to_string());\n-        assert_eq!(decode(\"%24\"), \"%24\".to_string());\n-        assert_eq!(decode(\"%25\"), \"%\".to_string());\n-        assert_eq!(decode(\"%26\"), \"%26\".to_string());\n-        assert_eq!(decode(\"%27\"), \"'\".to_string());\n-        assert_eq!(decode(\"%28\"), \"%28\".to_string());\n-        assert_eq!(decode(\"%29\"), \"%29\".to_string());\n-        assert_eq!(decode(\"%2A\"), \"%2A\".to_string());\n-        assert_eq!(decode(\"%2B\"), \"%2B\".to_string());\n-        assert_eq!(decode(\"%2C\"), \"%2C\".to_string());\n-        assert_eq!(decode(\"%2F\"), \"%2F\".to_string());\n-        assert_eq!(decode(\"%3A\"), \"%3A\".to_string());\n-        assert_eq!(decode(\"%3B\"), \"%3B\".to_string());\n-        assert_eq!(decode(\"%3D\"), \"%3D\".to_string());\n-        assert_eq!(decode(\"%3F\"), \"%3F\".to_string());\n-        assert_eq!(decode(\"%40\"), \"%40\".to_string());\n-        assert_eq!(decode(\"%5B\"), \"%5B\".to_string());\n-        assert_eq!(decode(\"%5D\"), \"%5D\".to_string());\n+        fn t(input: &str, expected: &str) {\n+            assert_eq!(decode(input), Ok(expected.to_string()))\n+        }\n+\n+        assert!(decode(\"sadsadsda%\").is_err());\n+        assert!(decode(\"waeasd%4\").is_err());\n+        t(\"\", \"\");\n+        t(\"abc/def 123\", \"abc/def 123\");\n+        t(\"abc%2Fdef%20123\", \"abc%2Fdef 123\");\n+        t(\"%20\", \" \");\n+        t(\"%21\", \"%21\");\n+        t(\"%22\", \"%22\");\n+        t(\"%23\", \"%23\");\n+        t(\"%24\", \"%24\");\n+        t(\"%25\", \"%\");\n+        t(\"%26\", \"%26\");\n+        t(\"%27\", \"'\");\n+        t(\"%28\", \"%28\");\n+        t(\"%29\", \"%29\");\n+        t(\"%2A\", \"%2A\");\n+        t(\"%2B\", \"%2B\");\n+        t(\"%2C\", \"%2C\");\n+        t(\"%2F\", \"%2F\");\n+        t(\"%3A\", \"%3A\");\n+        t(\"%3B\", \"%3B\");\n+        t(\"%3D\", \"%3D\");\n+        t(\"%3F\", \"%3F\");\n+        t(\"%40\", \"%40\");\n+        t(\"%5B\", \"%5B\");\n+        t(\"%5D\", \"%5D\");\n     }\n \n     #[test]\n     fn test_decode_component() {\n-        assert_eq!(decode_component(\"\"), \"\".to_string());\n-        assert_eq!(decode_component(\"abc/def 123\"), \"abc/def 123\".to_string());\n-        assert_eq!(decode_component(\"abc%2Fdef%20123\"), \"abc/def 123\".to_string());\n-        assert_eq!(decode_component(\"%20\"), \" \".to_string());\n-        assert_eq!(decode_component(\"%21\"), \"!\".to_string());\n-        assert_eq!(decode_component(\"%22\"), \"\\\"\".to_string());\n-        assert_eq!(decode_component(\"%23\"), \"#\".to_string());\n-        assert_eq!(decode_component(\"%24\"), \"$\".to_string());\n-        assert_eq!(decode_component(\"%25\"), \"%\".to_string());\n-        assert_eq!(decode_component(\"%26\"), \"&\".to_string());\n-        assert_eq!(decode_component(\"%27\"), \"'\".to_string());\n-        assert_eq!(decode_component(\"%28\"), \"(\".to_string());\n-        assert_eq!(decode_component(\"%29\"), \")\".to_string());\n-        assert_eq!(decode_component(\"%2A\"), \"*\".to_string());\n-        assert_eq!(decode_component(\"%2B\"), \"+\".to_string());\n-        assert_eq!(decode_component(\"%2C\"), \",\".to_string());\n-        assert_eq!(decode_component(\"%2F\"), \"/\".to_string());\n-        assert_eq!(decode_component(\"%3A\"), \":\".to_string());\n-        assert_eq!(decode_component(\"%3B\"), \";\".to_string());\n-        assert_eq!(decode_component(\"%3D\"), \"=\".to_string());\n-        assert_eq!(decode_component(\"%3F\"), \"?\".to_string());\n-        assert_eq!(decode_component(\"%40\"), \"@\".to_string());\n-        assert_eq!(decode_component(\"%5B\"), \"[\".to_string());\n-        assert_eq!(decode_component(\"%5D\"), \"]\".to_string());\n+        fn t(input: &str, expected: &str) {\n+            assert_eq!(decode_component(input), Ok(expected.to_string()))\n+        }\n+\n+        assert!(decode_component(\"asacsa%\").is_err());\n+        assert!(decode_component(\"acsas%4\").is_err());\n+        t(\"\", \"\");\n+        t(\"abc/def 123\", \"abc/def 123\");\n+        t(\"abc%2Fdef%20123\", \"abc/def 123\");\n+        t(\"%20\", \" \");\n+        t(\"%21\", \"!\");\n+        t(\"%22\", \"\\\"\");\n+        t(\"%23\", \"#\");\n+        t(\"%24\", \"$\");\n+        t(\"%25\", \"%\");\n+        t(\"%26\", \"&\");\n+        t(\"%27\", \"'\");\n+        t(\"%28\", \"(\");\n+        t(\"%29\", \")\");\n+        t(\"%2A\", \"*\");\n+        t(\"%2B\", \"+\");\n+        t(\"%2C\", \",\");\n+        t(\"%2F\", \"/\");\n+        t(\"%3A\", \":\");\n+        t(\"%3B\", \";\");\n+        t(\"%3D\", \"=\");\n+        t(\"%3F\", \"?\");\n+        t(\"%40\", \"@\");\n+        t(\"%5B\", \"[\");\n+        t(\"%5D\", \"]\");\n     }\n \n     #[test]\n@@ -1270,10 +1200,10 @@ mod tests {\n \n     #[test]\n     fn test_decode_form_urlencoded() {\n-        assert_eq!(decode_form_urlencoded([]).len(), 0);\n+        assert_eq!(decode_form_urlencoded([]).unwrap().len(), 0);\n \n         let s = \"a=1&foo+bar=abc&foo+bar=12+%3D+34\".as_bytes();\n-        let form = decode_form_urlencoded(s);\n+        let form = decode_form_urlencoded(s).unwrap();\n         assert_eq!(form.len(), 2);\n         assert_eq!(form.get(&\"a\".to_string()), &vec!(\"1\".to_string()));\n         assert_eq!(form.get(&\"foo bar\".to_string()),"}]}