{"sha": "1dd18801216b26595a7b374e5dc8ee32eb577954", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZDE4ODAxMjE2YjI2NTk1YTdiMzc0ZTVkYzhlZTMyZWI1Nzc5NTQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-06T14:36:59Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-08T01:13:27Z"}, "message": "syntax: convert the lexer to use Option<char> over transmute(-1).\n\nThe transmute was unsound.\n\nThere are many instances of .unwrap_or('\\x00') for \"ignoring\" EOF which\neither do not make the situation worse than it was (well, actually make\nit better, since it's easy to grep for places that don't handle EOF) or\ncan never ever be read.\n\nFixes #8971.", "tree": {"sha": "2c894b95cc8b8096df6a14698deae26e2f62051c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c894b95cc8b8096df6a14698deae26e2f62051c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dd18801216b26595a7b374e5dc8ee32eb577954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd18801216b26595a7b374e5dc8ee32eb577954", "html_url": "https://github.com/rust-lang/rust/commit/1dd18801216b26595a7b374e5dc8ee32eb577954", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dd18801216b26595a7b374e5dc8ee32eb577954/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7908c0a6676db2dbf29c46ecf66d61a315e74cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7908c0a6676db2dbf29c46ecf66d61a315e74cf", "html_url": "https://github.com/rust-lang/rust/commit/e7908c0a6676db2dbf29c46ecf66d61a315e74cf"}], "stats": {"total": 273, "additions": 157, "deletions": 116}, "files": [{"sha": "138f9d7164067571bd0f99e1269e65e1d45c5935", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1dd18801216b26595a7b374e5dc8ee32eb577954/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd18801216b26595a7b374e5dc8ee32eb577954/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=1dd18801216b26595a7b374e5dc8ee32eb577954", "patch": "@@ -12,7 +12,7 @@ use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos};\n use diagnostic;\n use parse::lexer::{is_whitespace, with_str_from, Reader};\n-use parse::lexer::{StringReader, bump, is_eof, nextch, TokenAndSpan};\n+use parse::lexer::{StringReader, bump, is_eof, nextch_is, TokenAndSpan};\n use parse::lexer::{is_line_non_doc_comment, is_block_non_doc_comment};\n use parse::lexer;\n use parse::token;\n@@ -136,11 +136,11 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n \n fn read_to_eol(rdr: &StringReader) -> ~str {\n     let mut val = ~\"\";\n-    while rdr.curr.get() != '\\n' && !is_eof(rdr) {\n-        val.push_char(rdr.curr.get());\n+    while !rdr.curr_is('\\n') && !is_eof(rdr) {\n+        val.push_char(rdr.curr.get().unwrap());\n         bump(rdr);\n     }\n-    if rdr.curr.get() == '\\n' { bump(rdr); }\n+    if rdr.curr_is('\\n') { bump(rdr); }\n     return val;\n }\n \n@@ -152,7 +152,7 @@ fn read_one_line_comment(rdr: &StringReader) -> ~str {\n }\n \n fn consume_non_eol_whitespace(rdr: &StringReader) {\n-    while is_whitespace(rdr.curr.get()) && rdr.curr.get() != '\\n' &&\n+    while is_whitespace(rdr.curr.get()) && !rdr.curr_is('\\n') &&\n             !is_eof(rdr) {\n         bump(rdr);\n     }\n@@ -171,7 +171,7 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut ~[Comment]) {\n fn consume_whitespace_counting_blank_lines(rdr: &StringReader,\n                                            comments: &mut ~[Comment]) {\n     while is_whitespace(rdr.curr.get()) && !is_eof(rdr) {\n-        if rdr.col.get() == CharPos(0u) && rdr.curr.get() == '\\n' {\n+        if rdr.col.get() == CharPos(0u) && rdr.curr_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n         }\n         bump(rdr);\n@@ -196,7 +196,7 @@ fn read_line_comments(rdr: &StringReader, code_to_the_left: bool,\n     debug!(\">>> line comments\");\n     let p = rdr.last_pos.get();\n     let mut lines: ~[~str] = ~[];\n-    while rdr.curr.get() == '/' && nextch(rdr) == '/' {\n+    while rdr.curr_is('/') && nextch_is(rdr, '/') {\n         let line = read_one_line_comment(rdr);\n         debug!(\"{}\", line);\n         if is_doc_comment(line) { // doc-comments are not put in comments\n@@ -261,9 +261,9 @@ fn read_block_comment(rdr: &StringReader,\n     let mut curr_line = ~\"/*\";\n \n     // doc-comments are not really comments, they are attributes\n-    if rdr.curr.get() == '*' || rdr.curr.get() == '!' {\n-        while !(rdr.curr.get() == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n-            curr_line.push_char(rdr.curr.get());\n+    if rdr.curr_is('*') || rdr.curr_is('!') {\n+        while !(rdr.curr_is('*') && nextch_is(rdr, '/')) && !is_eof(rdr) {\n+            curr_line.push_char(rdr.curr.get().unwrap());\n             bump(rdr);\n         }\n         if !is_eof(rdr) {\n@@ -281,20 +281,20 @@ fn read_block_comment(rdr: &StringReader,\n             if is_eof(rdr) {\n                 rdr.fatal(~\"unterminated block comment\");\n             }\n-            if rdr.curr.get() == '\\n' {\n+            if rdr.curr_is('\\n') {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line,\n                                                      col);\n                 curr_line = ~\"\";\n                 bump(rdr);\n             } else {\n-                curr_line.push_char(rdr.curr.get());\n-                if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n+                curr_line.push_char(rdr.curr.get().unwrap());\n+                if rdr.curr_is('/') && nextch_is(rdr, '*') {\n                     bump(rdr);\n                     bump(rdr);\n                     curr_line.push_char('*');\n                     level += 1;\n                 } else {\n-                    if rdr.curr.get() == '*' && nextch(rdr) == '/' {\n+                    if rdr.curr_is('*') && nextch_is(rdr, '/') {\n                         bump(rdr);\n                         bump(rdr);\n                         curr_line.push_char('/');\n@@ -310,28 +310,28 @@ fn read_block_comment(rdr: &StringReader,\n \n     let mut style = if code_to_the_left { Trailing } else { Isolated };\n     consume_non_eol_whitespace(rdr);\n-    if !is_eof(rdr) && rdr.curr.get() != '\\n' && lines.len() == 1u {\n+    if !is_eof(rdr) && !rdr.curr_is('\\n') && lines.len() == 1u {\n         style = Mixed;\n     }\n     debug!(\"<<< block comment\");\n     comments.push(Comment {style: style, lines: lines, pos: p});\n }\n \n fn peeking_at_comment(rdr: &StringReader) -> bool {\n-    return ((rdr.curr.get() == '/' && nextch(rdr) == '/') ||\n-         (rdr.curr.get() == '/' && nextch(rdr) == '*')) ||\n-         (rdr.curr.get() == '#' && nextch(rdr) == '!');\n+    return (rdr.curr_is('/') && nextch_is(rdr, '/')) ||\n+         (rdr.curr_is('/') && nextch_is(rdr, '*')) ||\n+         (rdr.curr_is('#') && nextch_is(rdr, '!'));\n }\n \n fn consume_comment(rdr: &StringReader,\n                    code_to_the_left: bool,\n                    comments: &mut ~[Comment]) {\n     debug!(\">>> consume comment\");\n-    if rdr.curr.get() == '/' && nextch(rdr) == '/' {\n+    if rdr.curr_is('/') && nextch_is(rdr, '/') {\n         read_line_comments(rdr, code_to_the_left, comments);\n-    } else if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n+    } else if rdr.curr_is('/') && nextch_is(rdr, '*') {\n         read_block_comment(rdr, code_to_the_left, comments);\n-    } else if rdr.curr.get() == '#' && nextch(rdr) == '!' {\n+    } else if rdr.curr_is('#') && nextch_is(rdr, '!') {\n         read_shebang_comment(rdr, code_to_the_left, comments);\n     } else { fail!(); }\n     debug!(\"<<< consume comment\");\n@@ -363,7 +363,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         loop {\n             let mut code_to_the_left = !first_read;\n             consume_non_eol_whitespace(&rdr);\n-            if rdr.curr.get() == '\\n' {\n+            if rdr.curr_is('\\n') {\n                 code_to_the_left = false;\n                 consume_whitespace_counting_blank_lines(&rdr, &mut comments);\n             }"}, {"sha": "f6ebfbfcc3b2e17cb9cb0e8c962b8306bfa8bb21", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 135, "deletions": 94, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/1dd18801216b26595a7b374e5dc8ee32eb577954/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd18801216b26595a7b374e5dc8ee32eb577954/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=1dd18801216b26595a7b374e5dc8ee32eb577954", "patch": "@@ -16,7 +16,6 @@ use ext::tt::transcribe::{dup_tt_reader, tt_next_token};\n use parse::token;\n use parse::token::{str_to_ident};\n \n-use std::cast::transmute;\n use std::cell::{Cell, RefCell};\n use std::char;\n use std::num::from_str_radix;\n@@ -48,13 +47,19 @@ pub struct StringReader {\n     // The column of the next character to read\n     col: Cell<CharPos>,\n     // The last character to be read\n-    curr: Cell<char>,\n+    curr: Cell<Option<char>>,\n     filemap: @codemap::FileMap,\n     /* cached: */\n     peek_tok: RefCell<token::Token>,\n     peek_span: RefCell<Span>,\n }\n \n+impl StringReader {\n+    pub fn curr_is(&self, c: char) -> bool {\n+        self.curr.get() == Some(c)\n+    }\n+}\n+\n pub fn new_string_reader(span_diagnostic: @SpanHandler,\n                          filemap: @codemap::FileMap)\n                       -> StringReader {\n@@ -74,7 +79,7 @@ pub fn new_low_level_string_reader(span_diagnostic: @SpanHandler,\n         pos: Cell::new(filemap.start_pos),\n         last_pos: Cell::new(filemap.start_pos),\n         col: Cell::new(CharPos(0)),\n-        curr: Cell::new(initial_char),\n+        curr: Cell::new(Some(initial_char)),\n         filemap: filemap,\n         /* dummy values; not read */\n         peek_tok: RefCell::new(token::EOF),\n@@ -246,14 +251,12 @@ pub fn bump(rdr: &StringReader) {\n     rdr.last_pos.set(rdr.pos.get());\n     let current_byte_offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n     if current_byte_offset < (rdr.filemap.src).len() {\n-        assert!(rdr.curr.get() != unsafe {\n-            transmute(-1u32)\n-        }); // FIXME: #8971: unsound\n-        let last_char = rdr.curr.get();\n+        assert!(rdr.curr.get().is_some());\n+        let last_char = rdr.curr.get().unwrap();\n         let next = rdr.filemap.src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n         rdr.pos.set(rdr.pos.get() + Pos::from_uint(byte_offset_diff));\n-        rdr.curr.set(next.ch);\n+        rdr.curr.set(Some(next.ch));\n         rdr.col.set(rdr.col.get() + CharPos(1u));\n         if last_char == '\\n' {\n             rdr.filemap.next_line(rdr.last_pos.get());\n@@ -265,37 +268,50 @@ pub fn bump(rdr: &StringReader) {\n                 Pos::from_uint(current_byte_offset), byte_offset_diff);\n         }\n     } else {\n-        rdr.curr.set(unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n+        rdr.curr.set(None);\n     }\n }\n pub fn is_eof(rdr: &StringReader) -> bool {\n-    rdr.curr.get() == unsafe { transmute(-1u32) } // FIXME: #8971: unsound\n+    rdr.curr.get().is_none()\n }\n-pub fn nextch(rdr: &StringReader) -> char {\n+pub fn nextch(rdr: &StringReader) -> Option<char> {\n     let offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n     if offset < (rdr.filemap.src).len() {\n-        return rdr.filemap.src.char_at(offset);\n-    } else { return unsafe { transmute(-1u32) }; } // FIXME: #8971: unsound\n+        Some(rdr.filemap.src.char_at(offset))\n+    } else {\n+        None\n+    }\n+}\n+pub fn nextch_is(rdr: &StringReader, c: char) -> bool {\n+    nextch(rdr) == Some(c)\n }\n \n-fn hex_digit_val(c: char) -> int {\n-    if in_range(c, '0', '9') { return (c as int) - ('0' as int); }\n-    if in_range(c, 'a', 'f') { return (c as int) - ('a' as int) + 10; }\n-    if in_range(c, 'A', 'F') { return (c as int) - ('A' as int) + 10; }\n+fn hex_digit_val(c: Option<char>) -> int {\n+    let d = c.unwrap_or('\\x00');\n+\n+    if in_range(c, '0', '9') { return (d as int) - ('0' as int); }\n+    if in_range(c, 'a', 'f') { return (d as int) - ('a' as int) + 10; }\n+    if in_range(c, 'A', 'F') { return (d as int) - ('A' as int) + 10; }\n     fail!();\n }\n \n-pub fn is_whitespace(c: char) -> bool {\n-    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n+pub fn is_whitespace(c: Option<char>) -> bool {\n+    match c.unwrap_or('\\x00') { // None can be null for now... it's not whitespace\n+        ' ' | '\\n' | '\\t' | '\\r' => true,\n+        _ => false\n+    }\n }\n \n-fn in_range(c: char, lo: char, hi: char) -> bool {\n-    return lo <= c && c <= hi\n+fn in_range(c: Option<char>, lo: char, hi: char) -> bool {\n+    match c {\n+        Some(c) => lo <= c && c <= hi,\n+        _ => false\n+    }\n }\n \n-fn is_dec_digit(c: char) -> bool { return in_range(c, '0', '9'); }\n+fn is_dec_digit(c: Option<char>) -> bool { return in_range(c, '0', '9'); }\n \n-fn is_hex_digit(c: char) -> bool {\n+fn is_hex_digit(c: Option<char>) -> bool {\n     return in_range(c, '0', '9') || in_range(c, 'a', 'f') ||\n             in_range(c, 'A', 'F');\n }\n@@ -317,15 +333,15 @@ pub fn is_line_non_doc_comment(s: &str) -> bool {\n // returns a Some(sugared-doc-attr) if one exists, None otherwise\n fn consume_any_line_comment(rdr: &StringReader)\n                          -> Option<TokenAndSpan> {\n-    if rdr.curr.get() == '/' {\n+    if rdr.curr_is('/') {\n         match nextch(rdr) {\n-          '/' => {\n+          Some('/') => {\n             bump(rdr);\n             bump(rdr);\n             // line comments starting with \"///\" or \"//!\" are doc-comments\n-            if rdr.curr.get() == '/' || rdr.curr.get() == '!' {\n+            if rdr.curr_is('/') || rdr.curr_is('!') {\n                 let start_bpos = rdr.pos.get() - BytePos(3);\n-                while rdr.curr.get() != '\\n' && !is_eof(rdr) {\n+                while !rdr.curr_is('\\n') && !is_eof(rdr) {\n                     bump(rdr);\n                 }\n                 let ret = with_str_from(rdr, start_bpos, |string| {\n@@ -344,16 +360,16 @@ fn consume_any_line_comment(rdr: &StringReader)\n                     return ret;\n                 }\n             } else {\n-                while rdr.curr.get() != '\\n' && !is_eof(rdr) { bump(rdr); }\n+                while !rdr.curr_is('\\n') && !is_eof(rdr) { bump(rdr); }\n             }\n             // Restart whitespace munch.\n             return consume_whitespace_and_comments(rdr);\n           }\n-          '*' => { bump(rdr); bump(rdr); return consume_block_comment(rdr); }\n+          Some('*') => { bump(rdr); bump(rdr); return consume_block_comment(rdr); }\n           _ => ()\n         }\n-    } else if rdr.curr.get() == '#' {\n-        if nextch(rdr) == '!' {\n+    } else if rdr.curr_is('#') {\n+        if nextch_is(rdr, '!') {\n             // I guess this is the only way to figure out if\n             // we're at the beginning of the file...\n             let cmap = @CodeMap::new();\n@@ -363,7 +379,7 @@ fn consume_any_line_comment(rdr: &StringReader)\n             }\n             let loc = cmap.lookup_char_pos_adj(rdr.last_pos.get());\n             if loc.line == 1u && loc.col == CharPos(0u) {\n-                while rdr.curr.get() != '\\n' && !is_eof(rdr) { bump(rdr); }\n+                while !rdr.curr_is('\\n') && !is_eof(rdr) { bump(rdr); }\n                 return consume_whitespace_and_comments(rdr);\n             }\n         }\n@@ -378,7 +394,7 @@ pub fn is_block_non_doc_comment(s: &str) -> bool {\n // might return a sugared-doc-attr\n fn consume_block_comment(rdr: &StringReader) -> Option<TokenAndSpan> {\n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n-    let is_doc_comment = rdr.curr.get() == '*' || rdr.curr.get() == '!';\n+    let is_doc_comment = rdr.curr_is('*') || rdr.curr_is('!');\n     let start_bpos = rdr.pos.get() - BytePos(if is_doc_comment {3} else {2});\n \n     let mut level: int = 1;\n@@ -390,11 +406,11 @@ fn consume_block_comment(rdr: &StringReader) -> Option<TokenAndSpan> {\n                 ~\"unterminated block comment\"\n             };\n             fatal_span(rdr, start_bpos, rdr.last_pos.get(), msg);\n-        } else if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n+        } else if rdr.curr_is('/') && nextch_is(rdr, '*') {\n             level += 1;\n             bump(rdr);\n             bump(rdr);\n-        } else if rdr.curr.get() == '*' && nextch(rdr) == '/' {\n+        } else if rdr.curr_is('*') && nextch_is(rdr, '/') {\n             level -= 1;\n             bump(rdr);\n             bump(rdr);\n@@ -424,12 +440,13 @@ fn consume_block_comment(rdr: &StringReader) -> Option<TokenAndSpan> {\n }\n \n fn scan_exponent(rdr: &StringReader, start_bpos: BytePos) -> Option<~str> {\n-    let mut c = rdr.curr.get();\n+    // \\x00 hits the `return None` case immediately, so this is fine.\n+    let mut c = rdr.curr.get().unwrap_or('\\x00');\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n         rslt.push_char(c);\n         bump(rdr);\n-        c = rdr.curr.get();\n+        c = rdr.curr.get().unwrap_or('\\x00');\n         if c == '-' || c == '+' {\n             rslt.push_char(c);\n             bump(rdr);\n@@ -448,10 +465,10 @@ fn scan_digits(rdr: &StringReader, radix: uint) -> ~str {\n     let mut rslt = ~\"\";\n     loop {\n         let c = rdr.curr.get();\n-        if c == '_' { bump(rdr); continue; }\n-        match char::to_digit(c, radix) {\n+        if c == Some('_') { bump(rdr); continue; }\n+        match c.and_then(|cc| char::to_digit(cc, radix)) {\n           Some(_) => {\n-            rslt.push_char(c);\n+            rslt.push_char(c.unwrap());\n             bump(rdr);\n           }\n           _ => return rslt\n@@ -476,7 +493,7 @@ fn scan_number(c: char, rdr: &StringReader) -> token::Token {\n     let mut num_str;\n     let mut base = 10u;\n     let mut c = c;\n-    let mut n = nextch(rdr);\n+    let mut n = nextch(rdr).unwrap_or('\\x00');\n     let start_bpos = rdr.last_pos.get();\n     if c == '0' && n == 'x' {\n         bump(rdr);\n@@ -492,7 +509,7 @@ fn scan_number(c: char, rdr: &StringReader) -> token::Token {\n         base = 2u;\n     }\n     num_str = scan_digits(rdr, base);\n-    c = rdr.curr.get();\n+    c = rdr.curr.get().unwrap_or('\\x00');\n     nextch(rdr);\n     if c == 'u' || c == 'i' {\n         enum Result { Signed(ast::IntTy), Unsigned(ast::UintTy) }\n@@ -502,13 +519,13 @@ fn scan_number(c: char, rdr: &StringReader) -> token::Token {\n             else { Unsigned(ast::TyU) }\n         };\n         bump(rdr);\n-        c = rdr.curr.get();\n+        c = rdr.curr.get().unwrap_or('\\x00');\n         if c == '8' {\n             bump(rdr);\n             tp = if signed { Signed(ast::TyI8) }\n                       else { Unsigned(ast::TyU8) };\n         }\n-        n = nextch(rdr);\n+        n = nextch(rdr).unwrap_or('\\x00');\n         if c == '1' && n == '6' {\n             bump(rdr);\n             bump(rdr);\n@@ -541,8 +558,7 @@ fn scan_number(c: char, rdr: &StringReader) -> token::Token {\n         }\n     }\n     let mut is_float = false;\n-    if rdr.curr.get() == '.' && !(ident_start(nextch(rdr)) || nextch(rdr) ==\n-                                  '.') {\n+    if rdr.curr_is('.') && !(ident_start(nextch(rdr)) || nextch_is(rdr, '.')) {\n         is_float = true;\n         bump(rdr);\n         let dec_part = scan_digits(rdr, 10u);\n@@ -557,10 +573,10 @@ fn scan_number(c: char, rdr: &StringReader) -> token::Token {\n       None => ()\n     }\n \n-    if rdr.curr.get() == 'f' {\n+    if rdr.curr_is('f') {\n         bump(rdr);\n-        c = rdr.curr.get();\n-        n = nextch(rdr);\n+        c = rdr.curr.get().unwrap_or('\\x00');\n+        n = nextch(rdr).unwrap_or('\\x00');\n         if c == '3' && n == '2' {\n             bump(rdr);\n             bump(rdr);\n@@ -602,33 +618,42 @@ fn scan_numeric_escape(rdr: &StringReader, n_hex_digits: uint) -> char {\n     let mut accum_int = 0;\n     let mut i = n_hex_digits;\n     let start_bpos = rdr.last_pos.get();\n-    while i != 0u {\n+    while i != 0u && !is_eof(rdr) {\n         let n = rdr.curr.get();\n         if !is_hex_digit(n) {\n             fatal_span_char(rdr, rdr.last_pos.get(), rdr.pos.get(),\n                             ~\"illegal character in numeric character escape\",\n-                            n);\n+                            n.unwrap());\n         }\n         bump(rdr);\n         accum_int *= 16;\n         accum_int += hex_digit_val(n);\n         i -= 1u;\n     }\n+    if i != 0 && is_eof(rdr) {\n+        fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n+                   ~\"unterminated numeric character escape\");\n+    }\n+\n     match char::from_u32(accum_int as u32) {\n         Some(x) => x,\n         None => fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"illegal numeric character escape\")\n     }\n }\n \n-fn ident_start(c: char) -> bool {\n+fn ident_start(c: Option<char>) -> bool {\n+    let c = match c { Some(c) => c, None => return false };\n+\n     (c >= 'a' && c <= 'z')\n         || (c >= 'A' && c <= 'Z')\n         || c == '_'\n         || (c > '\\x7f' && char::is_XID_start(c))\n }\n \n-fn ident_continue(c: char) -> bool {\n+fn ident_continue(c: Option<char>) -> bool {\n+    let c = match c { Some(c) => c, None => return false };\n+\n     (c >= 'a' && c <= 'z')\n         || (c >= 'A' && c <= 'Z')\n         || (c >= '0' && c <= '9')\n@@ -641,7 +666,7 @@ fn ident_continue(c: char) -> bool {\n // EFFECT: updates the interner\n fn next_token_inner(rdr: &StringReader) -> token::Token {\n     let c = rdr.curr.get();\n-    if ident_start(c) && nextch(rdr) != '\"' && nextch(rdr) != '#' {\n+    if ident_start(c) && !nextch_is(rdr, '\"') && !nextch_is(rdr, '#') {\n         // Note: r as in r\" or r#\" is part of a raw string literal,\n         // not an identifier, and is handled further down.\n \n@@ -654,24 +679,24 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n             if string == \"_\" {\n                 token::UNDERSCORE\n             } else {\n-                let is_mod_name = rdr.curr.get() == ':' && nextch(rdr) == ':';\n+                let is_mod_name = rdr.curr_is(':') && nextch_is(rdr, ':');\n \n                 // FIXME: perform NFKC normalization here. (Issue #2253)\n                 token::IDENT(str_to_ident(string), is_mod_name)\n             }\n         })\n     }\n     if is_dec_digit(c) {\n-        return scan_number(c, rdr);\n+        return scan_number(c.unwrap(), rdr);\n     }\n     fn binop(rdr: &StringReader, op: token::BinOp) -> token::Token {\n         bump(rdr);\n-        if rdr.curr.get() == '=' {\n+        if rdr.curr_is('=') {\n             bump(rdr);\n             return token::BINOPEQ(op);\n         } else { return token::BINOP(op); }\n     }\n-    match c {\n+    match c.expect(\"next_token_inner called at EOF\") {\n \n \n \n@@ -682,9 +707,9 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n       ',' => { bump(rdr); return token::COMMA; }\n       '.' => {\n           bump(rdr);\n-          return if rdr.curr.get() == '.' {\n+          return if rdr.curr_is('.') {\n               bump(rdr);\n-              if rdr.curr.get() == '.' {\n+              if rdr.curr_is('.') {\n                   bump(rdr);\n                   token::DOTDOTDOT\n               } else {\n@@ -705,7 +730,7 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n       '~' => { bump(rdr); return token::TILDE; }\n       ':' => {\n         bump(rdr);\n-        if rdr.curr.get() == ':' {\n+        if rdr.curr_is(':') {\n             bump(rdr);\n             return token::MOD_SEP;\n         } else { return token::COLON; }\n@@ -720,10 +745,10 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n       // Multi-byte tokens.\n       '=' => {\n         bump(rdr);\n-        if rdr.curr.get() == '=' {\n+        if rdr.curr_is('=') {\n             bump(rdr);\n             return token::EQEQ;\n-        } else if rdr.curr.get() == '>' {\n+        } else if rdr.curr_is('>') {\n             bump(rdr);\n             return token::FAT_ARROW;\n         } else {\n@@ -732,19 +757,19 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n       }\n       '!' => {\n         bump(rdr);\n-        if rdr.curr.get() == '=' {\n+        if rdr.curr_is('=') {\n             bump(rdr);\n             return token::NE;\n         } else { return token::NOT; }\n       }\n       '<' => {\n         bump(rdr);\n-        match rdr.curr.get() {\n+        match rdr.curr.get().unwrap_or('\\x00') {\n           '=' => { bump(rdr); return token::LE; }\n           '<' => { return binop(rdr, token::SHL); }\n           '-' => {\n             bump(rdr);\n-            match rdr.curr.get() {\n+            match rdr.curr.get().unwrap_or('\\x00') {\n               '>' => { bump(rdr); return token::DARROW; }\n               _ => { return token::LARROW; }\n             }\n@@ -754,7 +779,7 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n       }\n       '>' => {\n         bump(rdr);\n-        match rdr.curr.get() {\n+        match rdr.curr.get().unwrap_or('\\x00') {\n           '=' => { bump(rdr); return token::GE; }\n           '>' => { return binop(rdr, token::SHR); }\n           _ => { return token::GT; }\n@@ -764,12 +789,14 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n         // Either a character constant 'a' OR a lifetime name 'abc\n         bump(rdr);\n         let start = rdr.last_pos.get();\n-        let mut c2 = rdr.curr.get();\n+\n+        // the eof will be picked up by the final `'` check below\n+        let mut c2 = rdr.curr.get().unwrap_or('\\x00');\n         bump(rdr);\n \n         // If the character is an ident start not followed by another single\n         // quote, then this is a lifetime name:\n-        if ident_start(c2) && rdr.curr.get() != '\\'' {\n+        if ident_start(Some(c2)) && !rdr.curr_is('\\'') {\n             while ident_continue(rdr.curr.get()) {\n                 bump(rdr);\n             }\n@@ -798,19 +825,24 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n                 let escaped_pos = rdr.last_pos.get();\n                 bump(rdr);\n                 match escaped {\n-                    'n' => { c2 = '\\n'; }\n-                    'r' => { c2 = '\\r'; }\n-                    't' => { c2 = '\\t'; }\n-                    '\\\\' => { c2 = '\\\\'; }\n-                    '\\'' => { c2 = '\\''; }\n-                    '\"' => { c2 = '\"'; }\n-                    '0' => { c2 = '\\x00'; }\n-                    'x' => { c2 = scan_numeric_escape(rdr, 2u); }\n-                    'u' => { c2 = scan_numeric_escape(rdr, 4u); }\n-                    'U' => { c2 = scan_numeric_escape(rdr, 8u); }\n-                    c2 => {\n-                        fatal_span_char(rdr, escaped_pos, rdr.last_pos.get(),\n-                                        ~\"unknown character escape\", c2);\n+                    None => {}\n+                    Some(e) => {\n+                        c2 = match e {\n+                            'n' => '\\n',\n+                            'r' => '\\r',\n+                            't' => '\\t',\n+                            '\\\\' => '\\\\',\n+                            '\\'' => '\\'',\n+                            '\"' => '\"',\n+                            '0' => '\\x00',\n+                            'x' => scan_numeric_escape(rdr, 2u),\n+                            'u' => scan_numeric_escape(rdr, 4u),\n+                            'U' => scan_numeric_escape(rdr, 8u),\n+                            c2 => {\n+                                fatal_span_char(rdr, escaped_pos, rdr.last_pos.get(),\n+                                                ~\"unknown character escape\", c2)\n+                            }\n+                        }\n                     }\n                 }\n             }\n@@ -820,7 +852,7 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n             }\n             _ => {}\n         }\n-        if rdr.curr.get() != '\\'' {\n+        if !rdr.curr_is('\\'') {\n             fatal_span_verbose(rdr,\n                                // Byte offsetting here is okay because the\n                                // character before position `start` is an\n@@ -836,17 +868,22 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n         let mut accum_str = ~\"\";\n         let start_bpos = rdr.last_pos.get();\n         bump(rdr);\n-        while rdr.curr.get() != '\"' {\n+        while !rdr.curr_is('\"') {\n             if is_eof(rdr) {\n                 fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"unterminated double quote string\");\n             }\n \n-            let ch = rdr.curr.get();\n+            let ch = rdr.curr.get().unwrap();\n             bump(rdr);\n             match ch {\n               '\\\\' => {\n-                let escaped = rdr.curr.get();\n+                if is_eof(rdr) {\n+                    fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n+                           ~\"unterminated double quote string\");\n+                }\n+\n+                let escaped = rdr.curr.get().unwrap();\n                 let escaped_pos = rdr.last_pos.get();\n                 bump(rdr);\n                 match escaped {\n@@ -883,15 +920,19 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n         let start_bpos = rdr.last_pos.get();\n         bump(rdr);\n         let mut hash_count = 0u;\n-        while rdr.curr.get() == '#' {\n+        while rdr.curr_is('#') {\n             bump(rdr);\n             hash_count += 1;\n         }\n-        if rdr.curr.get() != '\"' {\n+\n+        if is_eof(rdr) {\n+            fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n+                       ~\"unterminated raw string\");\n+        } else if !rdr.curr_is('\"') {\n             fatal_span_char(rdr, start_bpos, rdr.last_pos.get(),\n                             ~\"only `#` is allowed in raw string delimitation; \\\n                               found illegal character\",\n-                            rdr.curr.get());\n+                            rdr.curr.get().unwrap());\n         }\n         bump(rdr);\n         let content_start_bpos = rdr.last_pos.get();\n@@ -901,11 +942,11 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n                 fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"unterminated raw string\");\n             }\n-            if rdr.curr.get() == '\"' {\n+            if rdr.curr_is('\"') {\n                 content_end_bpos = rdr.last_pos.get();\n                 for _ in range(0, hash_count) {\n                     bump(rdr);\n-                    if rdr.curr.get() != '#' {\n+                    if !rdr.curr_is('#') {\n                         continue 'outer;\n                     }\n                 }\n@@ -921,22 +962,22 @@ fn next_token_inner(rdr: &StringReader) -> token::Token {\n         return token::LIT_STR_RAW(str_content, hash_count);\n       }\n       '-' => {\n-        if nextch(rdr) == '>' {\n+        if nextch_is(rdr, '>') {\n             bump(rdr);\n             bump(rdr);\n             return token::RARROW;\n         } else { return binop(rdr, token::MINUS); }\n       }\n       '&' => {\n-        if nextch(rdr) == '&' {\n+        if nextch_is(rdr, '&') {\n             bump(rdr);\n             bump(rdr);\n             return token::ANDAND;\n         } else { return binop(rdr, token::AND); }\n       }\n       '|' => {\n         match nextch(rdr) {\n-          '|' => { bump(rdr); bump(rdr); return token::OROR; }\n+          Some('|') => { bump(rdr); bump(rdr); return token::OROR; }\n           _ => { return binop(rdr, token::OR); }\n         }\n       }"}]}