{"sha": "2f28361936f4709043a447d48fd3b8150ead868f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMjgzNjE5MzZmNDcwOTA0M2E0NDdkNDhmZDNiODE1MGVhZDg2OGY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-03-04T20:56:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-04T20:56:27Z"}, "message": "Rollup merge of #82088 - Nicholas-Baron:shorten_html_render, r=GuillaumeGomez\n\nShorten html::render\n\nThe `mod.rs` for librustdoc's `html::render` was over 3,000 lines. This PR reduces it to around 2,300 by\n1. Moving `Context` and associated `impl`s to a separate file\n2. Moving the `print_item` function and its helpers to a separate file\n3. Moving `write_shared` and `write_minify` to their own file\n\nRelated to issue #60302.\nEdit 1: `SharedContext` and related `impl`s is only 72 lines and so will not be moved.", "tree": {"sha": "cbd18bda38c45f7e10b7debc4e5133f2b7569ce3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbd18bda38c45f7e10b7debc4e5133f2b7569ce3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f28361936f4709043a447d48fd3b8150ead868f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgQUl8CRBK7hj4Ov3rIwAAdHIIAH5f2K3RkcxFw4HwIceFB4RQ\nmBmAhgi0/XNctWObg+xko+3ayy0FxggAg2eAsXb1JKBh7hU5NuECoUQdXNBN7XMr\nUL3CnOXmfIhT10FvwUBM1TjsM3cH6vucKiWT7xFJf51UbNAUSy+WrE5ubPxHB7/R\nO7CfqmgODZriEEIV/dIFziSzQ9oxMp7T+w0yX94YWGTVeMDAkYVw+CujVoZ4cxH2\nMQlXHWWues9LI08DzlIub2a+WZxUTe4U1N1Ho7M0Ox2rRCzM7GAC/k33cIu9CVrP\njCgn2VKykvgGgOsm/hPi4+TuNn6UzYUgXpz5dE1p+Kkp8gUgIuORuiYjIlkDrXw=\n=ObKn\n-----END PGP SIGNATURE-----\n", "payload": "tree cbd18bda38c45f7e10b7debc4e5133f2b7569ce3\nparent 95bbc7ef33ae8436a058a51a2ec8c5c4cc6da8d6\nparent afb8220d0af762189168a0f0b4f5c385f5a630e5\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1614891387 +0100\ncommitter GitHub <noreply@github.com> 1614891387 +0100\n\nRollup merge of #82088 - Nicholas-Baron:shorten_html_render, r=GuillaumeGomez\n\nShorten html::render\n\nThe `mod.rs` for librustdoc's `html::render` was over 3,000 lines. This PR reduces it to around 2,300 by\n1. Moving `Context` and associated `impl`s to a separate file\n2. Moving the `print_item` function and its helpers to a separate file\n3. Moving `write_shared` and `write_minify` to their own file\n\nRelated to issue #60302.\nEdit 1: `SharedContext` and related `impl`s is only 72 lines and so will not be moved.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f28361936f4709043a447d48fd3b8150ead868f", "html_url": "https://github.com/rust-lang/rust/commit/2f28361936f4709043a447d48fd3b8150ead868f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f28361936f4709043a447d48fd3b8150ead868f/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95bbc7ef33ae8436a058a51a2ec8c5c4cc6da8d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/95bbc7ef33ae8436a058a51a2ec8c5c4cc6da8d6", "html_url": "https://github.com/rust-lang/rust/commit/95bbc7ef33ae8436a058a51a2ec8c5c4cc6da8d6"}, {"sha": "afb8220d0af762189168a0f0b4f5c385f5a630e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/afb8220d0af762189168a0f0b4f5c385f5a630e5", "html_url": "https://github.com/rust-lang/rust/commit/afb8220d0af762189168a0f0b4f5c385f5a630e5"}], "stats": {"total": 5355, "additions": 2711, "deletions": 2644}, "files": [{"sha": "976168a9ac407a126802d3e72ae9376f24a12e62", "filename": "src/librustdoc/html/render/context.rs", "status": "added", "additions": 617, "deletions": 0, "changes": 617, "blob_url": "https://github.com/rust-lang/rust/blob/2f28361936f4709043a447d48fd3b8150ead868f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f28361936f4709043a447d48fd3b8150ead868f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=2f28361936f4709043a447d48fd3b8150ead868f", "patch": "@@ -0,0 +1,617 @@\n+use std::cell::RefCell;\n+use std::collections::BTreeMap;\n+use std::io;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+use std::sync::mpsc::{channel, Receiver};\n+use std::sync::Arc;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::Session;\n+use rustc_span::edition::Edition;\n+use rustc_span::source_map::FileName;\n+use rustc_span::symbol::sym;\n+\n+use super::cache::{build_index, ExternalLocation};\n+use super::print_item::{full_path, item_path, print_item};\n+use super::write_shared::write_shared;\n+use super::{\n+    print_sidebar, settings, AllTypes, NameDoc, SharedContext, StylePath, BASIC_KEYWORDS,\n+    CURRENT_DEPTH, INITIAL_IDS,\n+};\n+\n+use crate::clean::{self, AttributesExt};\n+use crate::config::RenderOptions;\n+use crate::docfs::{DocFS, PathError};\n+use crate::error::Error;\n+use crate::formats::cache::Cache;\n+use crate::formats::item_type::ItemType;\n+use crate::formats::FormatRenderer;\n+use crate::html::escape::Escape;\n+use crate::html::format::Buffer;\n+use crate::html::markdown::{self, plain_text_summary, ErrorCodes, IdMap};\n+use crate::html::{layout, sources};\n+\n+/// Major driving force in all rustdoc rendering. This contains information\n+/// about where in the tree-like hierarchy rendering is occurring and controls\n+/// how the current page is being rendered.\n+///\n+/// It is intended that this context is a lightweight object which can be fairly\n+/// easily cloned because it is cloned per work-job (about once per item in the\n+/// rustdoc tree).\n+#[derive(Clone)]\n+crate struct Context<'tcx> {\n+    /// Current hierarchy of components leading down to what's currently being\n+    /// rendered\n+    crate current: Vec<String>,\n+    /// The current destination folder of where HTML artifacts should be placed.\n+    /// This changes as the context descends into the module hierarchy.\n+    crate dst: PathBuf,\n+    /// A flag, which when `true`, will render pages which redirect to the\n+    /// real location of an item. This is used to allow external links to\n+    /// publicly reused items to redirect to the right location.\n+    crate render_redirect_pages: bool,\n+    /// `None` by default, depends on the `generate-redirect-map` option flag. If this field is set\n+    /// to `Some(...)`, it'll store redirections and then generate a JSON file at the top level of\n+    /// the crate.\n+    crate redirections: Option<Rc<RefCell<FxHashMap<String, String>>>>,\n+    /// The map used to ensure all generated 'id=' attributes are unique.\n+    pub(super) id_map: Rc<RefCell<IdMap>>,\n+    /// Tracks section IDs for `Deref` targets so they match in both the main\n+    /// body and the sidebar.\n+    pub(super) deref_id_map: Rc<RefCell<FxHashMap<DefId, String>>>,\n+    crate shared: Arc<SharedContext<'tcx>>,\n+    all: Rc<RefCell<AllTypes>>,\n+    /// Storage for the errors produced while generating documentation so they\n+    /// can be printed together at the end.\n+    crate errors: Rc<Receiver<String>>,\n+    crate cache: Rc<Cache>,\n+}\n+\n+impl<'tcx> Context<'tcx> {\n+    pub(super) fn path(&self, filename: &str) -> PathBuf {\n+        // We use splitn vs Path::extension here because we might get a filename\n+        // like `style.min.css` and we want to process that into\n+        // `style-suffix.min.css`.  Path::extension would just return `css`\n+        // which would result in `style.min-suffix.css` which isn't what we\n+        // want.\n+        let (base, ext) = filename.split_once('.').unwrap();\n+        let filename = format!(\"{}{}.{}\", base, self.shared.resource_suffix, ext);\n+        self.dst.join(&filename)\n+    }\n+\n+    pub(super) fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.shared.tcx\n+    }\n+\n+    fn sess(&self) -> &'tcx Session {\n+        &self.shared.tcx.sess\n+    }\n+\n+    pub(super) fn derive_id(&self, id: String) -> String {\n+        let mut map = self.id_map.borrow_mut();\n+        map.derive(id)\n+    }\n+\n+    /// String representation of how to get back to the root path of the 'doc/'\n+    /// folder in terms of a relative URL.\n+    pub(super) fn root_path(&self) -> String {\n+        \"../\".repeat(self.current.len())\n+    }\n+\n+    fn render_item(&self, it: &clean::Item, pushname: bool) -> String {\n+        // A little unfortunate that this is done like this, but it sure\n+        // does make formatting *a lot* nicer.\n+        CURRENT_DEPTH.with(|slot| {\n+            slot.set(self.current.len());\n+        });\n+\n+        let mut title = if it.is_primitive() || it.is_keyword() {\n+            // No need to include the namespace for primitive types and keywords\n+            String::new()\n+        } else {\n+            self.current.join(\"::\")\n+        };\n+        if pushname {\n+            if !title.is_empty() {\n+                title.push_str(\"::\");\n+            }\n+            title.push_str(&it.name.unwrap().as_str());\n+        }\n+        title.push_str(\" - Rust\");\n+        let tyname = it.type_();\n+        let desc = it.doc_value().as_ref().map(|doc| plain_text_summary(&doc));\n+        let desc = if let Some(desc) = desc {\n+            desc\n+        } else if it.is_crate() {\n+            format!(\"API documentation for the Rust `{}` crate.\", self.shared.layout.krate)\n+        } else {\n+            format!(\n+                \"API documentation for the Rust `{}` {} in crate `{}`.\",\n+                it.name.as_ref().unwrap(),\n+                tyname,\n+                self.shared.layout.krate\n+            )\n+        };\n+        let keywords = make_item_keywords(it);\n+        let page = layout::Page {\n+            css_class: tyname.as_str(),\n+            root_path: &self.root_path(),\n+            static_root_path: self.shared.static_root_path.as_deref(),\n+            title: &title,\n+            description: &desc,\n+            keywords: &keywords,\n+            resource_suffix: &self.shared.resource_suffix,\n+            extra_scripts: &[],\n+            static_extra_scripts: &[],\n+        };\n+\n+        {\n+            self.id_map.borrow_mut().reset();\n+            self.id_map.borrow_mut().populate(&INITIAL_IDS);\n+        }\n+\n+        if !self.render_redirect_pages {\n+            layout::render(\n+                &self.shared.layout,\n+                &page,\n+                |buf: &mut _| print_sidebar(self, it, buf),\n+                |buf: &mut _| print_item(self, it, buf),\n+                &self.shared.style_files,\n+            )\n+        } else {\n+            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n+                let mut path = String::new();\n+                for name in &names[..names.len() - 1] {\n+                    path.push_str(name);\n+                    path.push('/');\n+                }\n+                path.push_str(&item_path(ty, names.last().unwrap()));\n+                match self.redirections {\n+                    Some(ref redirections) => {\n+                        let mut current_path = String::new();\n+                        for name in &self.current {\n+                            current_path.push_str(name);\n+                            current_path.push('/');\n+                        }\n+                        current_path.push_str(&item_path(ty, names.last().unwrap()));\n+                        redirections.borrow_mut().insert(current_path, path);\n+                    }\n+                    None => return layout::redirect(&format!(\"{}{}\", self.root_path(), path)),\n+                }\n+            }\n+            String::new()\n+        }\n+    }\n+\n+    /// Construct a map of items shown in the sidebar to a plain-text summary of their docs.\n+    fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n+        // BTreeMap instead of HashMap to get a sorted output\n+        let mut map: BTreeMap<_, Vec<_>> = BTreeMap::new();\n+        for item in &m.items {\n+            if item.is_stripped() {\n+                continue;\n+            }\n+\n+            let short = item.type_();\n+            let myname = match item.name {\n+                None => continue,\n+                Some(ref s) => s.to_string(),\n+            };\n+            let short = short.to_string();\n+            map.entry(short).or_default().push((\n+                myname,\n+                Some(item.doc_value().map_or_else(String::new, |s| plain_text_summary(&s))),\n+            ));\n+        }\n+\n+        if self.shared.sort_modules_alphabetically {\n+            for items in map.values_mut() {\n+                items.sort();\n+            }\n+        }\n+        map\n+    }\n+\n+    /// Generates a url appropriate for an `href` attribute back to the source of\n+    /// this item.\n+    ///\n+    /// The url generated, when clicked, will redirect the browser back to the\n+    /// original source code.\n+    ///\n+    /// If `None` is returned, then a source link couldn't be generated. This\n+    /// may happen, for example, with externally inlined items where the source\n+    /// of their crate documentation isn't known.\n+    pub(super) fn src_href(&self, item: &clean::Item) -> Option<String> {\n+        if item.source.is_dummy() {\n+            return None;\n+        }\n+        let mut root = self.root_path();\n+        let mut path = String::new();\n+        let cnum = item.source.cnum(self.sess());\n+\n+        // We can safely ignore synthetic `SourceFile`s.\n+        let file = match item.source.filename(self.sess()) {\n+            FileName::Real(ref path) => path.local_path().to_path_buf(),\n+            _ => return None,\n+        };\n+        let file = &file;\n+\n+        let symbol;\n+        let (krate, path) = if cnum == LOCAL_CRATE {\n+            if let Some(path) = self.shared.local_sources.get(file) {\n+                (self.shared.layout.krate.as_str(), path)\n+            } else {\n+                return None;\n+            }\n+        } else {\n+            let (krate, src_root) = match *self.cache.extern_locations.get(&cnum)? {\n+                (name, ref src, ExternalLocation::Local) => (name, src),\n+                (name, ref src, ExternalLocation::Remote(ref s)) => {\n+                    root = s.to_string();\n+                    (name, src)\n+                }\n+                (_, _, ExternalLocation::Unknown) => return None,\n+            };\n+\n+            sources::clean_path(&src_root, file, false, |component| {\n+                path.push_str(&component.to_string_lossy());\n+                path.push('/');\n+            });\n+            let mut fname = file.file_name().expect(\"source has no filename\").to_os_string();\n+            fname.push(\".html\");\n+            path.push_str(&fname.to_string_lossy());\n+            symbol = krate.as_str();\n+            (&*symbol, &path)\n+        };\n+\n+        let loline = item.source.lo(self.sess()).line;\n+        let hiline = item.source.hi(self.sess()).line;\n+        let lines =\n+            if loline == hiline { loline.to_string() } else { format!(\"{}-{}\", loline, hiline) };\n+        Some(format!(\n+            \"{root}src/{krate}/{path}#{lines}\",\n+            root = Escape(&root),\n+            krate = krate,\n+            path = path,\n+            lines = lines\n+        ))\n+    }\n+}\n+\n+/// Generates the documentation for `crate` into the directory `dst`\n+impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n+    fn descr() -> &'static str {\n+        \"html\"\n+    }\n+\n+    fn init(\n+        mut krate: clean::Crate,\n+        options: RenderOptions,\n+        edition: Edition,\n+        mut cache: Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Result<(Self, clean::Crate), Error> {\n+        // need to save a copy of the options for rendering the index page\n+        let md_opts = options.clone();\n+        let RenderOptions {\n+            output,\n+            external_html,\n+            id_map,\n+            playground_url,\n+            sort_modules_alphabetically,\n+            themes: style_files,\n+            default_settings,\n+            extension_css,\n+            resource_suffix,\n+            static_root_path,\n+            generate_search_filter,\n+            unstable_features,\n+            generate_redirect_map,\n+            ..\n+        } = options;\n+\n+        let src_root = match krate.src {\n+            FileName::Real(ref p) => match p.local_path().parent() {\n+                Some(p) => p.to_path_buf(),\n+                None => PathBuf::new(),\n+            },\n+            _ => PathBuf::new(),\n+        };\n+        // If user passed in `--playground-url` arg, we fill in crate name here\n+        let mut playground = None;\n+        if let Some(url) = playground_url {\n+            playground =\n+                Some(markdown::Playground { crate_name: Some(krate.name.to_string()), url });\n+        }\n+        let mut layout = layout::Layout {\n+            logo: String::new(),\n+            favicon: String::new(),\n+            external_html,\n+            default_settings,\n+            krate: krate.name.to_string(),\n+            css_file_extension: extension_css,\n+            generate_search_filter,\n+        };\n+        let mut issue_tracker_base_url = None;\n+        let mut include_sources = true;\n+\n+        // Crawl the crate attributes looking for attributes which control how we're\n+        // going to emit HTML\n+        if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n+            for attr in attrs.lists(sym::doc) {\n+                match (attr.name_or_empty(), attr.value_str()) {\n+                    (sym::html_favicon_url, Some(s)) => {\n+                        layout.favicon = s.to_string();\n+                    }\n+                    (sym::html_logo_url, Some(s)) => {\n+                        layout.logo = s.to_string();\n+                    }\n+                    (sym::html_playground_url, Some(s)) => {\n+                        playground = Some(markdown::Playground {\n+                            crate_name: Some(krate.name.to_string()),\n+                            url: s.to_string(),\n+                        });\n+                    }\n+                    (sym::issue_tracker_base_url, Some(s)) => {\n+                        issue_tracker_base_url = Some(s.to_string());\n+                    }\n+                    (sym::html_no_source, None) if attr.is_word() => {\n+                        include_sources = false;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        let (sender, receiver) = channel();\n+        let mut scx = SharedContext {\n+            tcx,\n+            collapsed: krate.collapsed,\n+            src_root,\n+            include_sources,\n+            local_sources: Default::default(),\n+            issue_tracker_base_url,\n+            layout,\n+            created_dirs: Default::default(),\n+            sort_modules_alphabetically,\n+            style_files,\n+            resource_suffix,\n+            static_root_path,\n+            fs: DocFS::new(sender),\n+            edition,\n+            codes: ErrorCodes::from(unstable_features.is_nightly_build()),\n+            playground,\n+        };\n+\n+        // Add the default themes to the `Vec` of stylepaths\n+        //\n+        // Note that these must be added before `sources::render` is called\n+        // so that the resulting source pages are styled\n+        //\n+        // `light.css` is not disabled because it is the stylesheet that stays loaded\n+        // by the browser as the theme stylesheet. The theme system (hackily) works by\n+        // changing the href to this stylesheet. All other themes are disabled to\n+        // prevent rule conflicts\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\"), disabled: false });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\"), disabled: true });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\"), disabled: true });\n+\n+        let dst = output;\n+        scx.ensure_dir(&dst)?;\n+        krate = sources::render(&dst, &mut scx, krate)?;\n+\n+        // Build our search index\n+        let index = build_index(&krate, &mut cache, tcx);\n+\n+        let mut cx = Context {\n+            current: Vec::new(),\n+            dst,\n+            render_redirect_pages: false,\n+            id_map: Rc::new(RefCell::new(id_map)),\n+            deref_id_map: Rc::new(RefCell::new(FxHashMap::default())),\n+            shared: Arc::new(scx),\n+            all: Rc::new(RefCell::new(AllTypes::new())),\n+            errors: Rc::new(receiver),\n+            cache: Rc::new(cache),\n+            redirections: if generate_redirect_map { Some(Default::default()) } else { None },\n+        };\n+\n+        CURRENT_DEPTH.with(|s| s.set(0));\n+\n+        // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n+        write_shared(&cx, &krate, index, &md_opts)?;\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n+        Ok((cx, krate))\n+    }\n+\n+    fn after_krate(\n+        &mut self,\n+        krate: &clean::Crate,\n+        diag: &rustc_errors::Handler,\n+    ) -> Result<(), Error> {\n+        let final_file = self.dst.join(&*krate.name.as_str()).join(\"all.html\");\n+        let settings_file = self.dst.join(\"settings.html\");\n+        let crate_name = krate.name;\n+\n+        let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n+        if !root_path.ends_with('/') {\n+            root_path.push('/');\n+        }\n+        let mut page = layout::Page {\n+            title: \"List of all items in this crate\",\n+            css_class: \"mod\",\n+            root_path: \"../\",\n+            static_root_path: self.shared.static_root_path.as_deref(),\n+            description: \"List of all items in this crate\",\n+            keywords: BASIC_KEYWORDS,\n+            resource_suffix: &self.shared.resource_suffix,\n+            extra_scripts: &[],\n+            static_extra_scripts: &[],\n+        };\n+        let sidebar = if let Some(ref version) = self.cache.crate_version {\n+            format!(\n+                \"<p class=\\\"location\\\">Crate {}</p>\\\n+                     <div class=\\\"block version\\\">\\\n+                         <p>Version {}</p>\\\n+                     </div>\\\n+                     <a id=\\\"all-types\\\" href=\\\"index.html\\\"><p>Back to index</p></a>\",\n+                crate_name,\n+                Escape(version),\n+            )\n+        } else {\n+            String::new()\n+        };\n+        let all = self.all.replace(AllTypes::new());\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            |buf: &mut Buffer| all.print(buf),\n+            &self.shared.style_files,\n+        );\n+        self.shared.fs.write(&final_file, v.as_bytes())?;\n+\n+        // Generating settings page.\n+        page.title = \"Rustdoc settings\";\n+        page.description = \"Settings of Rustdoc\";\n+        page.root_path = \"./\";\n+\n+        let mut style_files = self.shared.style_files.clone();\n+        let sidebar = \"<p class=\\\"location\\\">Settings</p><div class=\\\"sidebar-elems\\\"></div>\";\n+        style_files.push(StylePath { path: PathBuf::from(\"settings.css\"), disabled: false });\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            settings(\n+                self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n+                &self.shared.resource_suffix,\n+                &self.shared.style_files,\n+            )?,\n+            &style_files,\n+        );\n+        self.shared.fs.write(&settings_file, v.as_bytes())?;\n+        if let Some(redirections) = self.redirections.take() {\n+            if !redirections.borrow().is_empty() {\n+                let redirect_map_path =\n+                    self.dst.join(&*krate.name.as_str()).join(\"redirect-map.json\");\n+                let paths = serde_json::to_string(&*redirections.borrow()).unwrap();\n+                self.shared.ensure_dir(&self.dst.join(&*krate.name.as_str()))?;\n+                self.shared.fs.write(&redirect_map_path, paths.as_bytes())?;\n+            }\n+        }\n+\n+        // Flush pending errors.\n+        Arc::get_mut(&mut self.shared).unwrap().fs.close();\n+        let nb_errors = self.errors.iter().map(|err| diag.struct_err(&err).emit()).count();\n+        if nb_errors > 0 {\n+            Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    fn mod_item_in(&mut self, item: &clean::Item, item_name: &str) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+        let scx = &self.shared;\n+        self.dst.push(item_name);\n+        self.current.push(item_name.to_owned());\n+\n+        info!(\"Recursing into {}\", self.dst.display());\n+\n+        let buf = self.render_item(item, false);\n+        // buf will be empty if the module is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(\"index.html\");\n+            scx.fs.write(&joint_dst, buf.as_bytes())?;\n+        }\n+\n+        // Render sidebar-items.js used throughout this module.\n+        if !self.render_redirect_pages {\n+            let module = match *item.kind {\n+                clean::StrippedItem(box clean::ModuleItem(ref m)) | clean::ModuleItem(ref m) => m,\n+                _ => unreachable!(),\n+            };\n+            let items = self.build_sidebar_items(module);\n+            let js_dst = self.dst.join(\"sidebar-items.js\");\n+            let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n+            scx.fs.write(&js_dst, &v)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn mod_item_out(&mut self, _item_name: &str) -> Result<(), Error> {\n+        info!(\"Recursed; leaving {}\", self.dst.display());\n+\n+        // Go back to where we were at\n+        self.dst.pop();\n+        self.current.pop();\n+        Ok(())\n+    }\n+\n+    fn item(&mut self, item: clean::Item) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+\n+        let buf = self.render_item(&item, true);\n+        // buf will be empty if the item is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            let name = item.name.as_ref().unwrap();\n+            let item_type = item.type_();\n+            let file_name = &item_path(item_type, &name.as_str());\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(file_name);\n+            self.shared.fs.write(&joint_dst, buf.as_bytes())?;\n+\n+            if !self.render_redirect_pages {\n+                self.all.borrow_mut().append(full_path(self, &item), &item_type);\n+            }\n+            // If the item is a macro, redirect from the old macro URL (with !)\n+            // to the new one (without).\n+            if item_type == ItemType::Macro {\n+                let redir_name = format!(\"{}.{}!.html\", item_type, name);\n+                if let Some(ref redirections) = self.redirections {\n+                    let crate_name = &self.shared.layout.krate;\n+                    redirections.borrow_mut().insert(\n+                        format!(\"{}/{}\", crate_name, redir_name),\n+                        format!(\"{}/{}\", crate_name, file_name),\n+                    );\n+                } else {\n+                    let v = layout::redirect(file_name);\n+                    let redir_dst = self.dst.join(redir_name);\n+                    self.shared.fs.write(&redir_dst, v.as_bytes())?;\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn cache(&self) -> &Cache {\n+        &self.cache\n+    }\n+}\n+\n+fn make_item_keywords(it: &clean::Item) -> String {\n+    format!(\"{}, {}\", BASIC_KEYWORDS, it.name.as_ref().unwrap())\n+}"}, {"sha": "50cae50c2c3eb964f64257e39cef6162ae96d8a8", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 128, "deletions": 2643, "changes": 2771, "blob_url": "https://github.com/rust-lang/rust/blob/2f28361936f4709043a447d48fd3b8150ead868f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f28361936f4709043a447d48fd3b8150ead868f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=2f28361936f4709043a447d48fd3b8150ead868f"}, {"sha": "6d61248f28ef0936bacfbfa656edb9d1fe84f942", "filename": "src/librustdoc/html/render/print_item.rs", "status": "added", "additions": 1420, "deletions": 0, "changes": 1420, "blob_url": "https://github.com/rust-lang/rust/blob/2f28361936f4709043a447d48fd3b8150ead868f/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f28361936f4709043a447d48fd3b8150ead868f/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=2f28361936f4709043a447d48fd3b8150ead868f", "patch": "@@ -0,0 +1,1420 @@\n+use std::cmp::Ordering;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_hir::def::CtorKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::middle::stability;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::hygiene::MacroKind;\n+use rustc_span::symbol::{kw, sym, Symbol};\n+\n+use super::{\n+    collect_paths_for_type, document, ensure_trailing_slash, item_ty_to_strs, render_assoc_item,\n+    render_assoc_items, render_attributes, render_impl, render_stability_since_raw, spotlight_decl,\n+    write_srclink, AssocItemLink, Context,\n+};\n+use crate::clean::{self, GetDefId};\n+use crate::formats::cache::Cache;\n+use crate::formats::item_type::ItemType;\n+use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n+use crate::html::escape::Escape;\n+use crate::html::format::{print_abi_with_space, Buffer, Function, PrintWithSpace, WhereClause};\n+use crate::html::highlight;\n+use crate::html::markdown::MarkdownSummaryLine;\n+\n+pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n+    debug_assert!(!item.is_stripped());\n+    // Write the breadcrumb trail header for the top\n+    buf.write_str(\"<h1 class=\\\"fqn\\\"><span class=\\\"in-band\\\">\");\n+    let name = match *item.kind {\n+        clean::ModuleItem(ref m) => {\n+            if m.is_crate {\n+                \"Crate \"\n+            } else {\n+                \"Module \"\n+            }\n+        }\n+        clean::FunctionItem(..) | clean::ForeignFunctionItem(..) => \"Function \",\n+        clean::TraitItem(..) => \"Trait \",\n+        clean::StructItem(..) => \"Struct \",\n+        clean::UnionItem(..) => \"Union \",\n+        clean::EnumItem(..) => \"Enum \",\n+        clean::TypedefItem(..) => \"Type Definition \",\n+        clean::MacroItem(..) => \"Macro \",\n+        clean::ProcMacroItem(ref mac) => match mac.kind {\n+            MacroKind::Bang => \"Macro \",\n+            MacroKind::Attr => \"Attribute Macro \",\n+            MacroKind::Derive => \"Derive Macro \",\n+        },\n+        clean::PrimitiveItem(..) => \"Primitive Type \",\n+        clean::StaticItem(..) | clean::ForeignStaticItem(..) => \"Static \",\n+        clean::ConstantItem(..) => \"Constant \",\n+        clean::ForeignTypeItem => \"Foreign Type \",\n+        clean::KeywordItem(..) => \"Keyword \",\n+        clean::OpaqueTyItem(..) => \"Opaque Type \",\n+        clean::TraitAliasItem(..) => \"Trait Alias \",\n+        _ => {\n+            // We don't generate pages for any other type.\n+            unreachable!();\n+        }\n+    };\n+    buf.write_str(name);\n+    if !item.is_primitive() && !item.is_keyword() {\n+        let cur = &cx.current;\n+        let amt = if item.is_mod() { cur.len() - 1 } else { cur.len() };\n+        for (i, component) in cur.iter().enumerate().take(amt) {\n+            write!(\n+                buf,\n+                \"<a href=\\\"{}index.html\\\">{}</a>::<wbr>\",\n+                \"../\".repeat(cur.len() - i - 1),\n+                component\n+            );\n+        }\n+    }\n+    write!(buf, \"<a class=\\\"{}\\\" href=\\\"\\\">{}</a>\", item.type_(), item.name.as_ref().unwrap());\n+\n+    buf.write_str(\"</span>\"); // in-band\n+    buf.write_str(\"<span class=\\\"out-of-band\\\">\");\n+    render_stability_since_raw(\n+        buf,\n+        item.stable_since(cx.tcx()).as_deref(),\n+        item.const_stable_since(cx.tcx()).as_deref(),\n+        None,\n+        None,\n+    );\n+    buf.write_str(\n+        \"<span id=\\\"render-detail\\\">\\\n+                <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n+                    title=\\\"collapse all docs\\\">\\\n+                    [<span class=\\\"inner\\\">&#x2212;</span>]\\\n+                </a>\\\n+            </span>\",\n+    );\n+\n+    // Write `src` tag\n+    //\n+    // When this item is part of a `crate use` in a downstream crate, the\n+    // [src] link in the downstream documentation will actually come back to\n+    // this page, and this link will be auto-clicked. The `id` attribute is\n+    // used to find the link to auto-click.\n+    if cx.shared.include_sources && !item.is_primitive() {\n+        write_srclink(cx, item, buf);\n+    }\n+\n+    buf.write_str(\"</span></h1>\"); // out-of-band\n+\n+    match *item.kind {\n+        clean::ModuleItem(ref m) => item_module(buf, cx, item, &m.items),\n+        clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n+            item_function(buf, cx, item, f)\n+        }\n+        clean::TraitItem(ref t) => item_trait(buf, cx, item, t),\n+        clean::StructItem(ref s) => item_struct(buf, cx, item, s),\n+        clean::UnionItem(ref s) => item_union(buf, cx, item, s),\n+        clean::EnumItem(ref e) => item_enum(buf, cx, item, e),\n+        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t),\n+        clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n+        clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n+        clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n+        clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) => item_static(buf, cx, item, i),\n+        clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n+        clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n+        clean::KeywordItem(_) => item_keyword(buf, cx, item),\n+        clean::OpaqueTyItem(ref e) => item_opaque_ty(buf, cx, item, e),\n+        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n+        _ => {\n+            // We don't generate pages for any other type.\n+            unreachable!();\n+        }\n+    }\n+}\n+\n+fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n+    document(w, cx, item, None);\n+\n+    let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped()).collect::<Vec<usize>>();\n+\n+    // the order of item types in the listing\n+    fn reorder(ty: ItemType) -> u8 {\n+        match ty {\n+            ItemType::ExternCrate => 0,\n+            ItemType::Import => 1,\n+            ItemType::Primitive => 2,\n+            ItemType::Module => 3,\n+            ItemType::Macro => 4,\n+            ItemType::Struct => 5,\n+            ItemType::Enum => 6,\n+            ItemType::Constant => 7,\n+            ItemType::Static => 8,\n+            ItemType::Trait => 9,\n+            ItemType::Function => 10,\n+            ItemType::Typedef => 12,\n+            ItemType::Union => 13,\n+            _ => 14 + ty as u8,\n+        }\n+    }\n+\n+    fn cmp(\n+        i1: &clean::Item,\n+        i2: &clean::Item,\n+        idx1: usize,\n+        idx2: usize,\n+        tcx: TyCtxt<'_>,\n+    ) -> Ordering {\n+        let ty1 = i1.type_();\n+        let ty2 = i2.type_();\n+        if ty1 != ty2 {\n+            return (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2));\n+        }\n+        let s1 = i1.stability(tcx).as_ref().map(|s| s.level);\n+        let s2 = i2.stability(tcx).as_ref().map(|s| s.level);\n+        if let (Some(a), Some(b)) = (s1, s2) {\n+            match (a.is_stable(), b.is_stable()) {\n+                (true, true) | (false, false) => {}\n+                (false, true) => return Ordering::Less,\n+                (true, false) => return Ordering::Greater,\n+            }\n+        }\n+        let lhs = i1.name.unwrap_or(kw::Empty).as_str();\n+        let rhs = i2.name.unwrap_or(kw::Empty).as_str();\n+        compare_names(&lhs, &rhs)\n+    }\n+\n+    if cx.shared.sort_modules_alphabetically {\n+        indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2, cx.tcx()));\n+    }\n+    // This call is to remove re-export duplicates in cases such as:\n+    //\n+    // ```\n+    // crate mod foo {\n+    //     crate mod bar {\n+    //         crate trait Double { fn foo(); }\n+    //     }\n+    // }\n+    //\n+    // crate use foo::bar::*;\n+    // crate use foo::*;\n+    // ```\n+    //\n+    // `Double` will appear twice in the generated docs.\n+    //\n+    // FIXME: This code is quite ugly and could be improved. Small issue: DefId\n+    // can be identical even if the elements are different (mostly in imports).\n+    // So in case this is an import, we keep everything by adding a \"unique id\"\n+    // (which is the position in the vector).\n+    indices.dedup_by_key(|i| {\n+        (\n+            items[*i].def_id,\n+            if items[*i].name.as_ref().is_some() { Some(full_path(cx, &items[*i])) } else { None },\n+            items[*i].type_(),\n+            if items[*i].is_import() { *i } else { 0 },\n+        )\n+    });\n+\n+    debug!(\"{:?}\", indices);\n+    let mut curty = None;\n+    for &idx in &indices {\n+        let myitem = &items[idx];\n+        if myitem.is_stripped() {\n+            continue;\n+        }\n+\n+        let myty = Some(myitem.type_());\n+        if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n+            // Put `extern crate` and `use` re-exports in the same section.\n+            curty = myty;\n+        } else if myty != curty {\n+            if curty.is_some() {\n+                w.write_str(\"</table>\");\n+            }\n+            curty = myty;\n+            let (short, name) = item_ty_to_strs(&myty.unwrap());\n+            write!(\n+                w,\n+                \"<h2 id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n+                       <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n+                id = cx.derive_id(short.to_owned()),\n+                name = name\n+            );\n+        }\n+\n+        match *myitem.kind {\n+            clean::ExternCrateItem(ref name, ref src) => {\n+                use crate::html::format::anchor;\n+\n+                match *src {\n+                    Some(ref src) => write!(\n+                        w,\n+                        \"<tr><td><code>{}extern crate {} as {};\",\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                        anchor(myitem.def_id, &*src.as_str(), cx.cache()),\n+                        name\n+                    ),\n+                    None => write!(\n+                        w,\n+                        \"<tr><td><code>{}extern crate {};\",\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                        anchor(myitem.def_id, &*name.as_str(), cx.cache())\n+                    ),\n+                }\n+                w.write_str(\"</code></td></tr>\");\n+            }\n+\n+            clean::ImportItem(ref import) => {\n+                write!(\n+                    w,\n+                    \"<tr><td><code>{}{}</code></td></tr>\",\n+                    myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                    import.print(cx.cache())\n+                );\n+            }\n+\n+            _ => {\n+                if myitem.name.is_none() {\n+                    continue;\n+                }\n+\n+                let unsafety_flag = match *myitem.kind {\n+                    clean::FunctionItem(ref func) | clean::ForeignFunctionItem(ref func)\n+                        if func.header.unsafety == hir::Unsafety::Unsafe =>\n+                    {\n+                        \"<a title=\\\"unsafe function\\\" href=\\\"#\\\"><sup>\u26a0</sup></a>\"\n+                    }\n+                    _ => \"\",\n+                };\n+\n+                let stab = myitem.stability_class(cx.tcx());\n+                let add = if stab.is_some() { \" \" } else { \"\" };\n+\n+                let doc_value = myitem.doc_value().unwrap_or_default();\n+                write!(\n+                    w,\n+                    \"<tr class=\\\"{stab}{add}module-item\\\">\\\n+                         <td><a class=\\\"{class}\\\" href=\\\"{href}\\\" \\\n+                             title=\\\"{title}\\\">{name}</a>{unsafety_flag}</td>\\\n+                         <td class=\\\"docblock-short\\\">{stab_tags}{docs}</td>\\\n+                     </tr>\",\n+                    name = *myitem.name.as_ref().unwrap(),\n+                    stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n+                    docs = MarkdownSummaryLine(&doc_value, &myitem.links(&cx.cache)).into_string(),\n+                    class = myitem.type_(),\n+                    add = add,\n+                    stab = stab.unwrap_or_else(String::new),\n+                    unsafety_flag = unsafety_flag,\n+                    href = item_path(myitem.type_(), &myitem.name.unwrap().as_str()),\n+                    title = [full_path(cx, myitem), myitem.type_().to_string()]\n+                        .iter()\n+                        .filter_map(|s| if !s.is_empty() { Some(s.as_str()) } else { None })\n+                        .collect::<Vec<_>>()\n+                        .join(\" \"),\n+                );\n+            }\n+        }\n+    }\n+\n+    if curty.is_some() {\n+        w.write_str(\"</table>\");\n+    }\n+}\n+\n+/// Render the stability, deprecation and portability tags that are displayed in the item's summary\n+/// at the module level.\n+fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) -> String {\n+    let mut tags = String::new();\n+\n+    fn tag_html(class: &str, title: &str, contents: &str) -> String {\n+        format!(r#\"<span class=\"stab {}\" title=\"{}\">{}</span>\"#, class, Escape(title), contents)\n+    }\n+\n+    // The trailing space after each tag is to space it properly against the rest of the docs.\n+    if let Some(depr) = &item.deprecation(tcx) {\n+        let mut message = \"Deprecated\";\n+        if !stability::deprecation_in_effect(\n+            depr.is_since_rustc_version,\n+            depr.since.map(|s| s.as_str()).as_deref(),\n+        ) {\n+            message = \"Deprecation planned\";\n+        }\n+        tags += &tag_html(\"deprecated\", \"\", message);\n+    }\n+\n+    // The \"rustc_private\" crates are permanently unstable so it makes no sense\n+    // to render \"unstable\" everywhere.\n+    if item\n+        .stability(tcx)\n+        .as_ref()\n+        .map(|s| s.level.is_unstable() && s.feature != sym::rustc_private)\n+        == Some(true)\n+    {\n+        tags += &tag_html(\"unstable\", \"\", \"Experimental\");\n+    }\n+\n+    let cfg = match (&item.attrs.cfg, parent.attrs.cfg.as_ref()) {\n+        (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n+        (cfg, _) => cfg.as_deref().cloned(),\n+    };\n+\n+    debug!(\"Portability {:?} - {:?} = {:?}\", item.attrs.cfg, parent.attrs.cfg, cfg);\n+    if let Some(ref cfg) = cfg {\n+        tags += &tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html());\n+    }\n+\n+    tags\n+}\n+\n+fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n+    let header_len = format!(\n+        \"{}{}{}{}{:#}fn {}{:#}\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        f.header.constness.print_with_space(),\n+        f.header.asyncness.print_with_space(),\n+        f.header.unsafety.print_with_space(),\n+        print_abi_with_space(f.header.abi),\n+        it.name.as_ref().unwrap(),\n+        f.generics.print(cx.cache())\n+    )\n+    .len();\n+    w.write_str(\"<pre class=\\\"rust fn\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n+         {name}{generics}{decl}{spotlight}{where_clause}</pre>\",\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        constness = f.header.constness.print_with_space(),\n+        asyncness = f.header.asyncness.print_with_space(),\n+        unsafety = f.header.unsafety.print_with_space(),\n+        abi = print_abi_with_space(f.header.abi),\n+        name = it.name.as_ref().unwrap(),\n+        generics = f.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &f.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        decl = Function { decl: &f.decl, header_len, indent: 0, asyncness: f.header.asyncness }\n+            .print(cx.cache()),\n+        spotlight = spotlight_decl(&f.decl, cx.cache()),\n+    );\n+    document(w, cx, it, None)\n+}\n+\n+fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait) {\n+    let bounds = bounds(&t.bounds, false, cx.cache());\n+    let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n+    let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n+    let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n+    let provided = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();\n+\n+    // Output the trait definition\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust trait\\\">\");\n+        render_attributes(w, it, true);\n+        write!(\n+            w,\n+            \"{}{}{}trait {}{}{}\",\n+            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+            t.unsafety.print_with_space(),\n+            if t.is_auto { \"auto \" } else { \"\" },\n+            it.name.as_ref().unwrap(),\n+            t.generics.print(cx.cache()),\n+            bounds\n+        );\n+\n+        if !t.generics.where_predicates.is_empty() {\n+            let where_ = WhereClause { gens: &t.generics, indent: 0, end_newline: true };\n+            write!(w, \"{}\", where_.print(cx.cache()));\n+        } else {\n+            w.write_str(\" \");\n+        }\n+\n+        if t.items.is_empty() {\n+            w.write_str(\"{ }\");\n+        } else {\n+            // FIXME: we should be using a derived_id for the Anchors here\n+            w.write_str(\"{\\n\");\n+            for t in &types {\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                w.write_str(\";\\n\");\n+            }\n+            if !types.is_empty() && !consts.is_empty() {\n+                w.write_str(\"\\n\");\n+            }\n+            for t in &consts {\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                w.write_str(\";\\n\");\n+            }\n+            if !consts.is_empty() && !required.is_empty() {\n+                w.write_str(\"\\n\");\n+            }\n+            for (pos, m) in required.iter().enumerate() {\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                w.write_str(\";\\n\");\n+\n+                if pos < required.len() - 1 {\n+                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n+                }\n+            }\n+            if !required.is_empty() && !provided.is_empty() {\n+                w.write_str(\"\\n\");\n+            }\n+            for (pos, m) in provided.iter().enumerate() {\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n+                match *m.kind {\n+                    clean::MethodItem(ref inner, _)\n+                        if !inner.generics.where_predicates.is_empty() =>\n+                    {\n+                        w.write_str(\",\\n    { ... }\\n\");\n+                    }\n+                    _ => {\n+                        w.write_str(\" { ... }\\n\");\n+                    }\n+                }\n+                if pos < provided.len() - 1 {\n+                    w.write_str(\"<div class=\\\"item-spacer\\\"></div>\");\n+                }\n+            }\n+            w.write_str(\"}\");\n+        }\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    // Trait documentation\n+    document(w, cx, it, None);\n+\n+    fn write_small_section_header(w: &mut Buffer, id: &str, title: &str, extra_content: &str) {\n+        write!(\n+            w,\n+            \"<h2 id=\\\"{0}\\\" class=\\\"small-section-header\\\">\\\n+                {1}<a href=\\\"#{0}\\\" class=\\\"anchor\\\"></a>\\\n+             </h2>{2}\",\n+            id, title, extra_content\n+        )\n+    }\n+\n+    fn write_loading_content(w: &mut Buffer, extra_content: &str) {\n+        write!(w, \"{}<span class=\\\"loading-content\\\">Loading content...</span>\", extra_content)\n+    }\n+\n+    fn trait_item(w: &mut Buffer, cx: &Context<'_>, m: &clean::Item, t: &clean::Item) {\n+        let name = m.name.as_ref().unwrap();\n+        info!(\"Documenting {} on {:?}\", name, t.name);\n+        let item_type = m.type_();\n+        let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+        write!(w, \"<h3 id=\\\"{id}\\\" class=\\\"method\\\"><code>\", id = id,);\n+        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl, cx);\n+        w.write_str(\"</code>\");\n+        render_stability_since(w, m, t, cx.tcx());\n+        write_srclink(cx, m, w);\n+        w.write_str(\"</h3>\");\n+        document(w, cx, m, Some(t));\n+    }\n+\n+    if !types.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"associated-types\",\n+            \"Associated Types\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for t in types {\n+            trait_item(w, cx, t, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+\n+    if !consts.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"associated-const\",\n+            \"Associated Constants\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for t in consts {\n+            trait_item(w, cx, t, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+\n+    // Output the documentation for each function individually\n+    if !required.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"required-methods\",\n+            \"Required methods\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for m in required {\n+            trait_item(w, cx, m, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+    if !provided.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"provided-methods\",\n+            \"Provided methods\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for m in provided {\n+            trait_item(w, cx, m, it);\n+        }\n+        write_loading_content(w, \"</div>\");\n+    }\n+\n+    // If there are methods directly on this trait object, render them here.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n+\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n+        // The DefId is for the first Type found with that name. The bool is\n+        // if any Types with the same name but different DefId have been found.\n+        let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n+        for implementor in implementors {\n+            match implementor.inner_impl().for_ {\n+                clean::ResolvedPath { ref path, did, is_generic: false, .. }\n+                | clean::BorrowedRef {\n+                    type_: box clean::ResolvedPath { ref path, did, is_generic: false, .. },\n+                    ..\n+                } => {\n+                    let &mut (prev_did, ref mut has_duplicates) =\n+                        implementor_dups.entry(path.last()).or_insert((did, false));\n+                    if prev_did != did {\n+                        *has_duplicates = true;\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n+            i.inner_impl()\n+                .for_\n+                .def_id_full(cx.cache())\n+                .map_or(true, |d| cx.cache.paths.contains_key(&d))\n+        });\n+\n+        let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n+            local.iter().partition(|i| i.inner_impl().synthetic);\n+\n+        synthetic.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n+        concrete.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n+\n+        if !foreign.is_empty() {\n+            write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n+\n+            for implementor in foreign {\n+                let assoc_link = AssocItemLink::GotoSource(\n+                    implementor.impl_item.def_id,\n+                    &implementor.inner_impl().provided_trait_methods,\n+                );\n+                render_impl(\n+                    w,\n+                    cx,\n+                    &implementor,\n+                    it,\n+                    assoc_link,\n+                    RenderMode::Normal,\n+                    implementor.impl_item.stable_since(cx.tcx()).as_deref(),\n+                    implementor.impl_item.const_stable_since(cx.tcx()).as_deref(),\n+                    false,\n+                    None,\n+                    true,\n+                    false,\n+                    &[],\n+                );\n+            }\n+            write_loading_content(w, \"\");\n+        }\n+\n+        write_small_section_header(\n+            w,\n+            \"implementors\",\n+            \"Implementors\",\n+            \"<div class=\\\"item-list\\\" id=\\\"implementors-list\\\">\",\n+        );\n+        for implementor in concrete {\n+            render_implementor(cx, implementor, it, w, &implementor_dups, &[]);\n+        }\n+        write_loading_content(w, \"</div>\");\n+\n+        if t.is_auto {\n+            write_small_section_header(\n+                w,\n+                \"synthetic-implementors\",\n+                \"Auto implementors\",\n+                \"<div class=\\\"item-list\\\" id=\\\"synthetic-implementors-list\\\">\",\n+            );\n+            for implementor in synthetic {\n+                render_implementor(\n+                    cx,\n+                    implementor,\n+                    it,\n+                    w,\n+                    &implementor_dups,\n+                    &collect_paths_for_type(implementor.inner_impl().for_.clone(), &cx.cache),\n+                );\n+            }\n+            write_loading_content(w, \"</div>\");\n+        }\n+    } else {\n+        // even without any implementations to write in, we still want the heading and list, so the\n+        // implementors javascript file pulled in below has somewhere to write the impls into\n+        write_small_section_header(\n+            w,\n+            \"implementors\",\n+            \"Implementors\",\n+            \"<div class=\\\"item-list\\\" id=\\\"implementors-list\\\">\",\n+        );\n+        write_loading_content(w, \"</div>\");\n+\n+        if t.is_auto {\n+            write_small_section_header(\n+                w,\n+                \"synthetic-implementors\",\n+                \"Auto implementors\",\n+                \"<div class=\\\"item-list\\\" id=\\\"synthetic-implementors-list\\\">\",\n+            );\n+            write_loading_content(w, \"</div>\");\n+        }\n+    }\n+\n+    write!(\n+        w,\n+        \"<script type=\\\"text/javascript\\\" \\\n+                 src=\\\"{root_path}/implementors/{path}/{ty}.{name}.js\\\" async>\\\n+         </script>\",\n+        root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n+        path = if it.def_id.is_local() {\n+            cx.current.join(\"/\")\n+        } else {\n+            let (ref path, _) = cx.cache.external_paths[&it.def_id];\n+            path[..path.len() - 1].join(\"/\")\n+        },\n+        ty = it.type_(),\n+        name = *it.name.as_ref().unwrap()\n+    );\n+}\n+\n+fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n+    w.write_str(\"<pre class=\\\"rust trait-alias\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"trait {}{}{} = {};</pre>\",\n+        it.name.as_ref().unwrap(),\n+        t.generics.print(cx.cache()),\n+        WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        bounds(&t.bounds, true, cx.cache())\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    // Render any items associated directly to this alias, as otherwise they\n+    // won't be visible anywhere in the docs. It would be nice to also show\n+    // associated items from the aliased type (see discussion in #32077), but\n+    // we need #14072 to make sense of the generics.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n+    w.write_str(\"<pre class=\\\"rust opaque\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"type {}{}{where_clause} = impl {bounds};</pre>\",\n+        it.name.as_ref().unwrap(),\n+        t.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        bounds = bounds(&t.bounds, false, cx.cache())\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    // Render any items associated directly to this alias, as otherwise they\n+    // won't be visible anywhere in the docs. It would be nice to also show\n+    // associated items from the aliased type (see discussion in #32077), but\n+    // we need #14072 to make sense of the generics.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n+    w.write_str(\"<pre class=\\\"rust typedef\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"type {}{}{where_clause} = {type_};</pre>\",\n+        it.name.as_ref().unwrap(),\n+        t.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        type_ = t.type_.print(cx.cache())\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    // Render any items associated directly to this alias, as otherwise they\n+    // won't be visible anywhere in the docs. It would be nice to also show\n+    // associated items from the aliased type (see discussion in #32077), but\n+    // we need #14072 to make sense of the generics.\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union) {\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust union\\\">\");\n+        render_attributes(w, it, true);\n+        render_union(w, it, Some(&s.generics), &s.fields, \"\", true, cx);\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    document(w, cx, it, None);\n+    let mut fields = s\n+        .fields\n+        .iter()\n+        .filter_map(|f| match *f.kind {\n+            clean::StructFieldItem(ref ty) => Some((f, ty)),\n+            _ => None,\n+        })\n+        .peekable();\n+    if fields.peek().is_some() {\n+        write!(\n+            w,\n+            \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\n+                   Fields<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a></h2>\"\n+        );\n+        for (field, ty) in fields {\n+            let name = field.name.as_ref().expect(\"union field name\");\n+            let id = format!(\"{}.{}\", ItemType::StructField, name);\n+            write!(\n+                w,\n+                \"<span id=\\\"{id}\\\" class=\\\"{shortty} small-section-header\\\">\\\n+                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                     <code>{name}: {ty}</code>\\\n+                 </span>\",\n+                id = id,\n+                name = name,\n+                shortty = ItemType::StructField,\n+                ty = ty.print(cx.cache())\n+            );\n+            if let Some(stability_class) = field.stability_class(cx.tcx()) {\n+                write!(w, \"<span class=\\\"stab {stab}\\\"></span>\", stab = stability_class);\n+            }\n+            document(w, cx, field, Some(it));\n+        }\n+    }\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum) {\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust enum\\\">\");\n+        render_attributes(w, it, true);\n+        write!(\n+            w,\n+            \"{}enum {}{}{}\",\n+            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+            it.name.as_ref().unwrap(),\n+            e.generics.print(cx.cache()),\n+            WhereClause { gens: &e.generics, indent: 0, end_newline: true }.print(cx.cache())\n+        );\n+        if e.variants.is_empty() && !e.variants_stripped {\n+            w.write_str(\" {}\");\n+        } else {\n+            w.write_str(\" {\\n\");\n+            for v in &e.variants {\n+                w.write_str(\"    \");\n+                let name = v.name.as_ref().unwrap();\n+                match *v.kind {\n+                    clean::VariantItem(ref var) => match var {\n+                        clean::Variant::CLike => write!(w, \"{}\", name),\n+                        clean::Variant::Tuple(ref tys) => {\n+                            write!(w, \"{}(\", name);\n+                            for (i, ty) in tys.iter().enumerate() {\n+                                if i > 0 {\n+                                    w.write_str(\",&nbsp;\")\n+                                }\n+                                write!(w, \"{}\", ty.print(cx.cache()));\n+                            }\n+                            w.write_str(\")\");\n+                        }\n+                        clean::Variant::Struct(ref s) => {\n+                            render_struct(w, v, None, s.struct_type, &s.fields, \"    \", false, cx);\n+                        }\n+                    },\n+                    _ => unreachable!(),\n+                }\n+                w.write_str(\",\\n\");\n+            }\n+\n+            if e.variants_stripped {\n+                w.write_str(\"    // some variants omitted\\n\");\n+            }\n+            w.write_str(\"}\");\n+        }\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    document(w, cx, it, None);\n+    if !e.variants.is_empty() {\n+        write!(\n+            w,\n+            \"<h2 id=\\\"variants\\\" class=\\\"variants small-section-header\\\">\n+                   Variants{}<a href=\\\"#variants\\\" class=\\\"anchor\\\"></a></h2>\\n\",\n+            document_non_exhaustive_header(it)\n+        );\n+        document_non_exhaustive(w, it);\n+        for variant in &e.variants {\n+            let id =\n+                cx.derive_id(format!(\"{}.{}\", ItemType::Variant, variant.name.as_ref().unwrap()));\n+            write!(\n+                w,\n+                \"<div id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n+                    <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                    <code>{name}\",\n+                id = id,\n+                name = variant.name.as_ref().unwrap()\n+            );\n+            if let clean::VariantItem(clean::Variant::Tuple(ref tys)) = *variant.kind {\n+                w.write_str(\"(\");\n+                for (i, ty) in tys.iter().enumerate() {\n+                    if i > 0 {\n+                        w.write_str(\",&nbsp;\");\n+                    }\n+                    write!(w, \"{}\", ty.print(cx.cache()));\n+                }\n+                w.write_str(\")\");\n+            }\n+            w.write_str(\"</code></div>\");\n+            document(w, cx, variant, Some(it));\n+            document_non_exhaustive(w, variant);\n+\n+            use crate::clean::Variant;\n+            if let clean::VariantItem(Variant::Struct(ref s)) = *variant.kind {\n+                let variant_id = cx.derive_id(format!(\n+                    \"{}.{}.fields\",\n+                    ItemType::Variant,\n+                    variant.name.as_ref().unwrap()\n+                ));\n+                write!(w, \"<div class=\\\"autohide sub-variant\\\" id=\\\"{id}\\\">\", id = variant_id);\n+                write!(\n+                    w,\n+                    \"<h3>Fields of <b>{name}</b></h3><div>\",\n+                    name = variant.name.as_ref().unwrap()\n+                );\n+                for field in &s.fields {\n+                    use crate::clean::StructFieldItem;\n+                    if let StructFieldItem(ref ty) = *field.kind {\n+                        let id = cx.derive_id(format!(\n+                            \"variant.{}.field.{}\",\n+                            variant.name.as_ref().unwrap(),\n+                            field.name.as_ref().unwrap()\n+                        ));\n+                        write!(\n+                            w,\n+                            \"<span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n+                                 <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                                 <code>{f}:&nbsp;{t}</code>\\\n+                             </span>\",\n+                            id = id,\n+                            f = field.name.as_ref().unwrap(),\n+                            t = ty.print(cx.cache())\n+                        );\n+                        document(w, cx, field, Some(variant));\n+                    }\n+                }\n+                w.write_str(\"</div></div>\");\n+            }\n+            render_stability_since(w, variant, it, cx.tcx());\n+        }\n+    }\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Macro) {\n+    wrap_into_docblock(w, |w| {\n+        highlight::render_with_highlighting(\n+            &t.source,\n+            w,\n+            Some(\"macro\"),\n+            None,\n+            None,\n+            it.source.span().edition(),\n+        );\n+    });\n+    document(w, cx, it, None)\n+}\n+\n+fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n+    let name = it.name.as_ref().expect(\"proc-macros always have names\");\n+    match m.kind {\n+        MacroKind::Bang => {\n+            w.push_str(\"<pre class=\\\"rust macro\\\">\");\n+            write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n+            w.push_str(\"</pre>\");\n+        }\n+        MacroKind::Attr => {\n+            w.push_str(\"<pre class=\\\"rust attr\\\">\");\n+            write!(w, \"#[{}]\", name);\n+            w.push_str(\"</pre>\");\n+        }\n+        MacroKind::Derive => {\n+            w.push_str(\"<pre class=\\\"rust derive\\\">\");\n+            write!(w, \"#[derive({})]\", name);\n+            if !m.helpers.is_empty() {\n+                w.push_str(\"\\n{\\n\");\n+                w.push_str(\"    // Attributes available to this derive:\\n\");\n+                for attr in &m.helpers {\n+                    writeln!(w, \"    #[{}]\", attr);\n+                }\n+                w.push_str(\"}\\n\");\n+            }\n+            w.push_str(\"</pre>\");\n+        }\n+    }\n+    document(w, cx, it, None)\n+}\n+\n+fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+    document(w, cx, it, None);\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n+    w.write_str(\"<pre class=\\\"rust const\\\">\");\n+    render_attributes(w, it, false);\n+\n+    write!(\n+        w,\n+        \"{vis}const {name}: {typ}\",\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        name = it.name.as_ref().unwrap(),\n+        typ = c.type_.print(cx.cache()),\n+    );\n+\n+    if c.value.is_some() || c.is_literal {\n+        write!(w, \" = {expr};\", expr = Escape(&c.expr));\n+    } else {\n+        w.write_str(\";\");\n+    }\n+\n+    if let Some(value) = &c.value {\n+        if !c.is_literal {\n+            let value_lowercase = value.to_lowercase();\n+            let expr_lowercase = c.expr.to_lowercase();\n+\n+            if value_lowercase != expr_lowercase\n+                && value_lowercase.trim_end_matches(\"i32\") != expr_lowercase\n+            {\n+                write!(w, \" // {value}\", value = Escape(value));\n+            }\n+        }\n+    }\n+\n+    w.write_str(\"</pre>\");\n+    document(w, cx, it, None)\n+}\n+\n+fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Struct) {\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(\"<pre class=\\\"rust struct\\\">\");\n+        render_attributes(w, it, true);\n+        render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n+        w.write_str(\"</pre>\")\n+    });\n+\n+    document(w, cx, it, None);\n+    let mut fields = s\n+        .fields\n+        .iter()\n+        .filter_map(|f| match *f.kind {\n+            clean::StructFieldItem(ref ty) => Some((f, ty)),\n+            _ => None,\n+        })\n+        .peekable();\n+    if let CtorKind::Fictive = s.struct_type {\n+        if fields.peek().is_some() {\n+            write!(\n+                w,\n+                \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\n+                       Fields{}<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a></h2>\",\n+                document_non_exhaustive_header(it)\n+            );\n+            document_non_exhaustive(w, it);\n+            for (field, ty) in fields {\n+                let id = cx.derive_id(format!(\n+                    \"{}.{}\",\n+                    ItemType::StructField,\n+                    field.name.as_ref().unwrap()\n+                ));\n+                write!(\n+                    w,\n+                    \"<span id=\\\"{id}\\\" class=\\\"{item_type} small-section-header\\\">\\\n+                         <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n+                         <code>{name}: {ty}</code>\\\n+                     </span>\",\n+                    item_type = ItemType::StructField,\n+                    id = id,\n+                    name = field.name.as_ref().unwrap(),\n+                    ty = ty.print(cx.cache())\n+                );\n+                document(w, cx, field, Some(it));\n+            }\n+        }\n+    }\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Static) {\n+    w.write_str(\"<pre class=\\\"rust static\\\">\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"{vis}static {mutability}{name}: {typ}</pre>\",\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        mutability = s.mutability.print_with_space(),\n+        name = it.name.as_ref().unwrap(),\n+        typ = s.type_.print(cx.cache())\n+    );\n+    document(w, cx, it, None)\n+}\n+\n+fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+    w.write_str(\"<pre class=\\\"rust foreigntype\\\">extern {\\n\");\n+    render_attributes(w, it, false);\n+    write!(\n+        w,\n+        \"    {}type {};\\n}}</pre>\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        it.name.as_ref().unwrap(),\n+    );\n+\n+    document(w, cx, it, None);\n+\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n+fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+    document(w, cx, it, None)\n+}\n+\n+/// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n+crate fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n+    /// Takes a non-numeric and a numeric part from the given &str.\n+    fn take_parts<'a>(s: &mut &'a str) -> (&'a str, &'a str) {\n+        let i = s.find(|c: char| c.is_ascii_digit());\n+        let (a, b) = s.split_at(i.unwrap_or(s.len()));\n+        let i = b.find(|c: char| !c.is_ascii_digit());\n+        let (b, c) = b.split_at(i.unwrap_or(b.len()));\n+        *s = c;\n+        (a, b)\n+    }\n+\n+    while !lhs.is_empty() || !rhs.is_empty() {\n+        let (la, lb) = take_parts(&mut lhs);\n+        let (ra, rb) = take_parts(&mut rhs);\n+        // First process the non-numeric part.\n+        match la.cmp(ra) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n+        // Then process the numeric part, if both sides have one (and they fit in a u64).\n+        if let (Ok(ln), Ok(rn)) = (lb.parse::<u64>(), rb.parse::<u64>()) {\n+            match ln.cmp(&rn) {\n+                Ordering::Equal => (),\n+                x => return x,\n+            }\n+        }\n+        // Then process the numeric part again, but this time as strings.\n+        match lb.cmp(rb) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n+    }\n+\n+    Ordering::Equal\n+}\n+\n+pub(super) fn full_path(cx: &Context<'_>, item: &clean::Item) -> String {\n+    let mut s = cx.current.join(\"::\");\n+    s.push_str(\"::\");\n+    s.push_str(&item.name.unwrap().as_str());\n+    s\n+}\n+\n+pub(super) fn item_path(ty: ItemType, name: &str) -> String {\n+    match ty {\n+        ItemType::Module => format!(\"{}index.html\", ensure_trailing_slash(name)),\n+        _ => format!(\"{}.{}.html\", ty, name),\n+    }\n+}\n+\n+fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool, cache: &Cache) -> String {\n+    let mut bounds = String::new();\n+    if !t_bounds.is_empty() {\n+        if !trait_alias {\n+            bounds.push_str(\": \");\n+        }\n+        for (i, p) in t_bounds.iter().enumerate() {\n+            if i > 0 {\n+                bounds.push_str(\" + \");\n+            }\n+            bounds.push_str(&p.print(cache).to_string());\n+        }\n+    }\n+    bounds\n+}\n+\n+fn wrap_into_docblock<F>(w: &mut Buffer, f: F)\n+where\n+    F: FnOnce(&mut Buffer),\n+{\n+    w.write_str(\"<div class=\\\"docblock type-decl hidden-by-usual-hider\\\">\");\n+    f(w);\n+    w.write_str(\"</div>\")\n+}\n+\n+fn render_stability_since(\n+    w: &mut Buffer,\n+    item: &clean::Item,\n+    containing_item: &clean::Item,\n+    tcx: TyCtxt<'_>,\n+) {\n+    render_stability_since_raw(\n+        w,\n+        item.stable_since(tcx).as_deref(),\n+        item.const_stable_since(tcx).as_deref(),\n+        containing_item.stable_since(tcx).as_deref(),\n+        containing_item.const_stable_since(tcx).as_deref(),\n+    )\n+}\n+\n+fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl, cache: &Cache) -> Ordering {\n+    let lhs = format!(\"{}\", lhs.inner_impl().print(cache, false));\n+    let rhs = format!(\"{}\", rhs.inner_impl().print(cache, false));\n+\n+    // lhs and rhs are formatted as HTML, which may be unnecessary\n+    compare_names(&lhs, &rhs)\n+}\n+\n+fn render_implementor(\n+    cx: &Context<'_>,\n+    implementor: &Impl,\n+    trait_: &clean::Item,\n+    w: &mut Buffer,\n+    implementor_dups: &FxHashMap<Symbol, (DefId, bool)>,\n+    aliases: &[String],\n+) {\n+    // If there's already another implementor that has the same abbridged name, use the\n+    // full path, for example in `std::iter::ExactSizeIterator`\n+    let use_absolute = match implementor.inner_impl().for_ {\n+        clean::ResolvedPath { ref path, is_generic: false, .. }\n+        | clean::BorrowedRef {\n+            type_: box clean::ResolvedPath { ref path, is_generic: false, .. },\n+            ..\n+        } => implementor_dups[&path.last()].1,\n+        _ => false,\n+    };\n+    render_impl(\n+        w,\n+        cx,\n+        implementor,\n+        trait_,\n+        AssocItemLink::Anchor(None),\n+        RenderMode::Normal,\n+        trait_.stable_since(cx.tcx()).as_deref(),\n+        trait_.const_stable_since(cx.tcx()).as_deref(),\n+        false,\n+        Some(use_absolute),\n+        false,\n+        false,\n+        aliases,\n+    );\n+}\n+\n+fn render_union(\n+    w: &mut Buffer,\n+    it: &clean::Item,\n+    g: Option<&clean::Generics>,\n+    fields: &[clean::Item],\n+    tab: &str,\n+    structhead: bool,\n+    cx: &Context<'_>,\n+) {\n+    write!(\n+        w,\n+        \"{}{}{}\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        if structhead { \"union \" } else { \"\" },\n+        it.name.as_ref().unwrap()\n+    );\n+    if let Some(g) = g {\n+        write!(w, \"{}\", g.print(cx.cache()));\n+        write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache()));\n+    }\n+\n+    write!(w, \" {{\\n{}\", tab);\n+    for field in fields {\n+        if let clean::StructFieldItem(ref ty) = *field.kind {\n+            write!(\n+                w,\n+                \"    {}{}: {},\\n{}\",\n+                field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                field.name.as_ref().unwrap(),\n+                ty.print(cx.cache()),\n+                tab\n+            );\n+        }\n+    }\n+\n+    if it.has_stripped_fields().unwrap() {\n+        write!(w, \"    // some fields omitted\\n{}\", tab);\n+    }\n+    w.write_str(\"}\");\n+}\n+\n+fn render_struct(\n+    w: &mut Buffer,\n+    it: &clean::Item,\n+    g: Option<&clean::Generics>,\n+    ty: CtorKind,\n+    fields: &[clean::Item],\n+    tab: &str,\n+    structhead: bool,\n+    cx: &Context<'_>,\n+) {\n+    write!(\n+        w,\n+        \"{}{}{}\",\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        if structhead { \"struct \" } else { \"\" },\n+        it.name.as_ref().unwrap()\n+    );\n+    if let Some(g) = g {\n+        write!(w, \"{}\", g.print(cx.cache()))\n+    }\n+    match ty {\n+        CtorKind::Fictive => {\n+            if let Some(g) = g {\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache())\n+                )\n+            }\n+            let mut has_visible_fields = false;\n+            w.write_str(\" {\");\n+            for field in fields {\n+                if let clean::StructFieldItem(ref ty) = *field.kind {\n+                    write!(\n+                        w,\n+                        \"\\n{}    {}{}: {},\",\n+                        tab,\n+                        field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                        field.name.as_ref().unwrap(),\n+                        ty.print(cx.cache())\n+                    );\n+                    has_visible_fields = true;\n+                }\n+            }\n+\n+            if has_visible_fields {\n+                if it.has_stripped_fields().unwrap() {\n+                    write!(w, \"\\n{}    // some fields omitted\", tab);\n+                }\n+                write!(w, \"\\n{}\", tab);\n+            } else if it.has_stripped_fields().unwrap() {\n+                // If there are no visible fields we can just display\n+                // `{ /* fields omitted */ }` to save space.\n+                write!(w, \" /* fields omitted */ \");\n+            }\n+            w.write_str(\"}\");\n+        }\n+        CtorKind::Fn => {\n+            w.write_str(\"(\");\n+            for (i, field) in fields.iter().enumerate() {\n+                if i > 0 {\n+                    w.write_str(\", \");\n+                }\n+                match *field.kind {\n+                    clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n+                    clean::StructFieldItem(ref ty) => {\n+                        write!(\n+                            w,\n+                            \"{}{}\",\n+                            field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                            ty.print(cx.cache())\n+                        )\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+            w.write_str(\")\");\n+            if let Some(g) = g {\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n+                )\n+            }\n+            w.write_str(\";\");\n+        }\n+        CtorKind::Const => {\n+            // Needed for PhantomData.\n+            if let Some(g) = g {\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n+                )\n+            }\n+            w.write_str(\";\");\n+        }\n+    }\n+}\n+\n+fn document_non_exhaustive_header(item: &clean::Item) -> &str {\n+    if item.is_non_exhaustive() { \" (Non-exhaustive)\" } else { \"\" }\n+}\n+\n+fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n+    if item.is_non_exhaustive() {\n+        write!(w, \"<div class=\\\"docblock non-exhaustive non-exhaustive-{}\\\">\", {\n+            if item.is_struct() {\n+                \"struct\"\n+            } else if item.is_enum() {\n+                \"enum\"\n+            } else if item.is_variant() {\n+                \"variant\"\n+            } else {\n+                \"type\"\n+            }\n+        });\n+\n+        if item.is_struct() {\n+            w.write_str(\n+                \"Non-exhaustive structs could have additional fields added in future. \\\n+                 Therefore, non-exhaustive structs cannot be constructed in external crates \\\n+                 using the traditional <code>Struct {{ .. }}</code> syntax; cannot be \\\n+                 matched against without a wildcard <code>..</code>; and \\\n+                 struct update syntax will not work.\",\n+            );\n+        } else if item.is_enum() {\n+            w.write_str(\n+                \"Non-exhaustive enums could have additional variants added in future. \\\n+                 Therefore, when matching against variants of non-exhaustive enums, an \\\n+                 extra wildcard arm must be added to account for any future variants.\",\n+            );\n+        } else if item.is_variant() {\n+            w.write_str(\n+                \"Non-exhaustive enum variants could have additional fields added in future. \\\n+                 Therefore, non-exhaustive enum variants cannot be constructed in external \\\n+                 crates and cannot be matched against.\",\n+            );\n+        } else {\n+            w.write_str(\n+                \"This type will require a wildcard arm in any match statements or constructors.\",\n+            );\n+        }\n+\n+        w.write_str(\"</div>\");\n+    }\n+}"}, {"sha": "3175fbe5666d893c0b616dbe99235ca20caf9689", "filename": "src/librustdoc/html/render/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f28361936f4709043a447d48fd3b8150ead868f/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f28361936f4709043a447d48fd3b8150ead868f/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs?ref=2f28361936f4709043a447d48fd3b8150ead868f", "patch": "@@ -1,4 +1,7 @@\n-use super::*;\n+use std::cmp::Ordering;\n+\n+use super::print_item::compare_names;\n+use super::{AllTypes, Buffer};\n \n #[test]\n fn test_compare_names() {"}, {"sha": "cbf0f9a4927c61b279e836e3d97a5f2d5a378450", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "added", "additions": 542, "deletions": 0, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/2f28361936f4709043a447d48fd3b8150ead868f/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f28361936f4709043a447d48fd3b8150ead868f/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=2f28361936f4709043a447d48fd3b8150ead868f", "patch": "@@ -0,0 +1,542 @@\n+use std::ffi::OsStr;\n+use std::fmt::Write;\n+use std::fs::{self, File};\n+use std::io::prelude::*;\n+use std::io::{self, BufReader};\n+use std::path::{Component, Path, PathBuf};\n+\n+use itertools::Itertools;\n+use rustc_data_structures::flock;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use serde::Serialize;\n+\n+use super::{collect_paths_for_type, ensure_trailing_slash, Context, BASIC_KEYWORDS};\n+use crate::clean::Crate;\n+use crate::config::RenderOptions;\n+use crate::docfs::{DocFS, PathError};\n+use crate::error::Error;\n+use crate::formats::FormatRenderer;\n+use crate::html::{layout, static_files};\n+\n+pub(super) fn write_shared(\n+    cx: &Context<'_>,\n+    krate: &Crate,\n+    search_index: String,\n+    options: &RenderOptions,\n+) -> Result<(), Error> {\n+    // Write out the shared files. Note that these are shared among all rustdoc\n+    // docs placed in the output directory, so this needs to be a synchronized\n+    // operation with respect to all other rustdocs running around.\n+    let lock_file = cx.dst.join(\".lock\");\n+    let _lock = try_err!(flock::Lock::new(&lock_file, true, true, true), &lock_file);\n+\n+    // Add all the static files. These may already exist, but we just\n+    // overwrite them anyway to make sure that they're fresh and up-to-date.\n+\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"rustdoc.css\"),\n+        static_files::RUSTDOC_CSS,\n+        options.enable_minification,\n+    )?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"settings.css\"),\n+        static_files::SETTINGS_CSS,\n+        options.enable_minification,\n+    )?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"noscript.css\"),\n+        static_files::NOSCRIPT_CSS,\n+        options.enable_minification,\n+    )?;\n+\n+    // To avoid \"light.css\" to be overwritten, we'll first run over the received themes and only\n+    // then we'll run over the \"official\" styles.\n+    let mut themes: FxHashSet<String> = FxHashSet::default();\n+\n+    for entry in &cx.shared.style_files {\n+        let theme = try_none!(try_none!(entry.path.file_stem(), &entry.path).to_str(), &entry.path);\n+        let extension =\n+            try_none!(try_none!(entry.path.extension(), &entry.path).to_str(), &entry.path);\n+\n+        // Handle the official themes\n+        match theme {\n+            \"light\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"light.css\"),\n+                static_files::themes::LIGHT,\n+                options.enable_minification,\n+            )?,\n+            \"dark\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"dark.css\"),\n+                static_files::themes::DARK,\n+                options.enable_minification,\n+            )?,\n+            \"ayu\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"ayu.css\"),\n+                static_files::themes::AYU,\n+                options.enable_minification,\n+            )?,\n+            _ => {\n+                // Handle added third-party themes\n+                let content = try_err!(fs::read(&entry.path), &entry.path);\n+                cx.shared\n+                    .fs\n+                    .write(cx.path(&format!(\"{}.{}\", theme, extension)), content.as_slice())?;\n+            }\n+        };\n+\n+        themes.insert(theme.to_owned());\n+    }\n+\n+    let write = |p, c| cx.shared.fs.write(p, c);\n+    if (*cx.shared).layout.logo.is_empty() {\n+        write(cx.path(\"rust-logo.png\"), static_files::RUST_LOGO)?;\n+    }\n+    if (*cx.shared).layout.favicon.is_empty() {\n+        write(cx.path(\"favicon.svg\"), static_files::RUST_FAVICON_SVG)?;\n+        write(cx.path(\"favicon-16x16.png\"), static_files::RUST_FAVICON_PNG_16)?;\n+        write(cx.path(\"favicon-32x32.png\"), static_files::RUST_FAVICON_PNG_32)?;\n+    }\n+    write(cx.path(\"brush.svg\"), static_files::BRUSH_SVG)?;\n+    write(cx.path(\"wheel.svg\"), static_files::WHEEL_SVG)?;\n+    write(cx.path(\"down-arrow.svg\"), static_files::DOWN_ARROW_SVG)?;\n+\n+    let mut themes: Vec<&String> = themes.iter().collect();\n+    themes.sort();\n+    // To avoid theme switch latencies as much as possible, we put everything theme related\n+    // at the beginning of the html files into another js file.\n+    let theme_js = format!(\n+        r#\"var themes = document.getElementById(\"theme-choices\");\n+var themePicker = document.getElementById(\"theme-picker\");\n+\n+function showThemeButtonState() {{\n+    themes.style.display = \"block\";\n+    themePicker.style.borderBottomRightRadius = \"0\";\n+    themePicker.style.borderBottomLeftRadius = \"0\";\n+}}\n+\n+function hideThemeButtonState() {{\n+    themes.style.display = \"none\";\n+    themePicker.style.borderBottomRightRadius = \"3px\";\n+    themePicker.style.borderBottomLeftRadius = \"3px\";\n+}}\n+\n+function switchThemeButtonState() {{\n+    if (themes.style.display === \"block\") {{\n+        hideThemeButtonState();\n+    }} else {{\n+        showThemeButtonState();\n+    }}\n+}};\n+\n+function handleThemeButtonsBlur(e) {{\n+    var active = document.activeElement;\n+    var related = e.relatedTarget;\n+\n+    if (active.id !== \"theme-picker\" &&\n+        (!active.parentNode || active.parentNode.id !== \"theme-choices\") &&\n+        (!related ||\n+         (related.id !== \"theme-picker\" &&\n+          (!related.parentNode || related.parentNode.id !== \"theme-choices\")))) {{\n+        hideThemeButtonState();\n+    }}\n+}}\n+\n+themePicker.onclick = switchThemeButtonState;\n+themePicker.onblur = handleThemeButtonsBlur;\n+{}.forEach(function(item) {{\n+    var but = document.createElement(\"button\");\n+    but.textContent = item;\n+    but.onclick = function(el) {{\n+        switchTheme(currentTheme, mainTheme, item, true);\n+        useSystemTheme(false);\n+    }};\n+    but.onblur = handleThemeButtonsBlur;\n+    themes.appendChild(but);\n+}});\"#,\n+        serde_json::to_string(&themes).unwrap()\n+    );\n+\n+    write_minify(&cx.shared.fs, cx.path(\"theme.js\"), &theme_js, options.enable_minification)?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"main.js\"),\n+        static_files::MAIN_JS,\n+        options.enable_minification,\n+    )?;\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"settings.js\"),\n+        static_files::SETTINGS_JS,\n+        options.enable_minification,\n+    )?;\n+    if cx.shared.include_sources {\n+        write_minify(\n+            &cx.shared.fs,\n+            cx.path(\"source-script.js\"),\n+            static_files::sidebar::SOURCE_SCRIPT,\n+            options.enable_minification,\n+        )?;\n+    }\n+\n+    {\n+        write_minify(\n+            &cx.shared.fs,\n+            cx.path(\"storage.js\"),\n+            &format!(\n+                \"var resourcesSuffix = \\\"{}\\\";{}\",\n+                cx.shared.resource_suffix,\n+                static_files::STORAGE_JS\n+            ),\n+            options.enable_minification,\n+        )?;\n+    }\n+\n+    if let Some(ref css) = cx.shared.layout.css_file_extension {\n+        let out = cx.path(\"theme.css\");\n+        let buffer = try_err!(fs::read_to_string(css), css);\n+        if !options.enable_minification {\n+            cx.shared.fs.write(&out, &buffer)?;\n+        } else {\n+            write_minify(&cx.shared.fs, out, &buffer, options.enable_minification)?;\n+        }\n+    }\n+    write_minify(\n+        &cx.shared.fs,\n+        cx.path(\"normalize.css\"),\n+        static_files::NORMALIZE_CSS,\n+        options.enable_minification,\n+    )?;\n+    write(cx.dst.join(\"FiraSans-Regular.woff2\"), static_files::fira_sans::REGULAR2)?;\n+    write(cx.dst.join(\"FiraSans-Medium.woff2\"), static_files::fira_sans::MEDIUM2)?;\n+    write(cx.dst.join(\"FiraSans-Regular.woff\"), static_files::fira_sans::REGULAR)?;\n+    write(cx.dst.join(\"FiraSans-Medium.woff\"), static_files::fira_sans::MEDIUM)?;\n+    write(cx.dst.join(\"FiraSans-LICENSE.txt\"), static_files::fira_sans::LICENSE)?;\n+    write(cx.dst.join(\"SourceSerifPro-Regular.ttf.woff\"), static_files::source_serif_pro::REGULAR)?;\n+    write(cx.dst.join(\"SourceSerifPro-Bold.ttf.woff\"), static_files::source_serif_pro::BOLD)?;\n+    write(cx.dst.join(\"SourceSerifPro-It.ttf.woff\"), static_files::source_serif_pro::ITALIC)?;\n+    write(cx.dst.join(\"SourceSerifPro-LICENSE.md\"), static_files::source_serif_pro::LICENSE)?;\n+    write(cx.dst.join(\"SourceCodePro-Regular.woff\"), static_files::source_code_pro::REGULAR)?;\n+    write(cx.dst.join(\"SourceCodePro-Semibold.woff\"), static_files::source_code_pro::SEMIBOLD)?;\n+    write(cx.dst.join(\"SourceCodePro-LICENSE.txt\"), static_files::source_code_pro::LICENSE)?;\n+    write(cx.dst.join(\"LICENSE-MIT.txt\"), static_files::LICENSE_MIT)?;\n+    write(cx.dst.join(\"LICENSE-APACHE.txt\"), static_files::LICENSE_APACHE)?;\n+    write(cx.dst.join(\"COPYRIGHT.txt\"), static_files::COPYRIGHT)?;\n+\n+    fn collect(path: &Path, krate: &str, key: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n+        let mut ret = Vec::new();\n+        let mut krates = Vec::new();\n+\n+        if path.exists() {\n+            let prefix = format!(r#\"{}[\"{}\"]\"#, key, krate);\n+            for line in BufReader::new(File::open(path)?).lines() {\n+                let line = line?;\n+                if !line.starts_with(key) {\n+                    continue;\n+                }\n+                if line.starts_with(&prefix) {\n+                    continue;\n+                }\n+                ret.push(line.to_string());\n+                krates.push(\n+                    line[key.len() + 2..]\n+                        .split('\"')\n+                        .next()\n+                        .map(|s| s.to_owned())\n+                        .unwrap_or_else(String::new),\n+                );\n+            }\n+        }\n+        Ok((ret, krates))\n+    }\n+\n+    fn collect_json(path: &Path, krate: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n+        let mut ret = Vec::new();\n+        let mut krates = Vec::new();\n+\n+        if path.exists() {\n+            let prefix = format!(\"\\\"{}\\\"\", krate);\n+            for line in BufReader::new(File::open(path)?).lines() {\n+                let line = line?;\n+                if !line.starts_with('\"') {\n+                    continue;\n+                }\n+                if line.starts_with(&prefix) {\n+                    continue;\n+                }\n+                if line.ends_with(\",\\\\\") {\n+                    ret.push(line[..line.len() - 2].to_string());\n+                } else {\n+                    // Ends with \"\\\\\" (it's the case for the last added crate line)\n+                    ret.push(line[..line.len() - 1].to_string());\n+                }\n+                krates.push(\n+                    line.split('\"')\n+                        .find(|s| !s.is_empty())\n+                        .map(|s| s.to_owned())\n+                        .unwrap_or_else(String::new),\n+                );\n+            }\n+        }\n+        Ok((ret, krates))\n+    }\n+\n+    use std::ffi::OsString;\n+\n+    #[derive(Debug)]\n+    struct Hierarchy {\n+        elem: OsString,\n+        children: FxHashMap<OsString, Hierarchy>,\n+        elems: FxHashSet<OsString>,\n+    }\n+\n+    impl Hierarchy {\n+        fn new(elem: OsString) -> Hierarchy {\n+            Hierarchy { elem, children: FxHashMap::default(), elems: FxHashSet::default() }\n+        }\n+\n+        fn to_json_string(&self) -> String {\n+            let mut subs: Vec<&Hierarchy> = self.children.values().collect();\n+            subs.sort_unstable_by(|a, b| a.elem.cmp(&b.elem));\n+            let mut files = self\n+                .elems\n+                .iter()\n+                .map(|s| format!(\"\\\"{}\\\"\", s.to_str().expect(\"invalid osstring conversion\")))\n+                .collect::<Vec<_>>();\n+            files.sort_unstable();\n+            let subs = subs.iter().map(|s| s.to_json_string()).collect::<Vec<_>>().join(\",\");\n+            let dirs =\n+                if subs.is_empty() { String::new() } else { format!(\",\\\"dirs\\\":[{}]\", subs) };\n+            let files = files.join(\",\");\n+            let files =\n+                if files.is_empty() { String::new() } else { format!(\",\\\"files\\\":[{}]\", files) };\n+            format!(\n+                \"{{\\\"name\\\":\\\"{name}\\\"{dirs}{files}}}\",\n+                name = self.elem.to_str().expect(\"invalid osstring conversion\"),\n+                dirs = dirs,\n+                files = files\n+            )\n+        }\n+    }\n+\n+    if cx.shared.include_sources {\n+        let mut hierarchy = Hierarchy::new(OsString::new());\n+        for source in cx\n+            .shared\n+            .local_sources\n+            .iter()\n+            .filter_map(|p| p.0.strip_prefix(&cx.shared.src_root).ok())\n+        {\n+            let mut h = &mut hierarchy;\n+            let mut elems = source\n+                .components()\n+                .filter_map(|s| match s {\n+                    Component::Normal(s) => Some(s.to_owned()),\n+                    _ => None,\n+                })\n+                .peekable();\n+            loop {\n+                let cur_elem = elems.next().expect(\"empty file path\");\n+                if elems.peek().is_none() {\n+                    h.elems.insert(cur_elem);\n+                    break;\n+                } else {\n+                    let e = cur_elem.clone();\n+                    h = h.children.entry(cur_elem.clone()).or_insert_with(|| Hierarchy::new(e));\n+                }\n+            }\n+        }\n+\n+        let dst = cx.dst.join(&format!(\"source-files{}.js\", cx.shared.resource_suffix));\n+        let (mut all_sources, _krates) =\n+            try_err!(collect(&dst, &krate.name.as_str(), \"sourcesIndex\"), &dst);\n+        all_sources.push(format!(\n+            \"sourcesIndex[\\\"{}\\\"] = {};\",\n+            &krate.name,\n+            hierarchy.to_json_string()\n+        ));\n+        all_sources.sort();\n+        let v = format!(\n+            \"var N = null;var sourcesIndex = {{}};\\n{}\\ncreateSourceSidebar();\\n\",\n+            all_sources.join(\"\\n\")\n+        );\n+        cx.shared.fs.write(&dst, v.as_bytes())?;\n+    }\n+\n+    // Update the search index and crate list.\n+    let dst = cx.dst.join(&format!(\"search-index{}.js\", cx.shared.resource_suffix));\n+    let (mut all_indexes, mut krates) = try_err!(collect_json(&dst, &krate.name.as_str()), &dst);\n+    all_indexes.push(search_index);\n+    krates.push(krate.name.to_string());\n+    krates.sort();\n+\n+    // Sort the indexes by crate so the file will be generated identically even\n+    // with rustdoc running in parallel.\n+    all_indexes.sort();\n+    {\n+        let mut v = String::from(\"var searchIndex = JSON.parse('{\\\\\\n\");\n+        v.push_str(&all_indexes.join(\",\\\\\\n\"));\n+        v.push_str(\"\\\\\\n}');\\ninitSearch(searchIndex);\");\n+        cx.shared.fs.write(&dst, &v)?;\n+    }\n+\n+    let crate_list_dst = cx.dst.join(&format!(\"crates{}.js\", cx.shared.resource_suffix));\n+    let crate_list =\n+        format!(\"window.ALL_CRATES = [{}];\", krates.iter().map(|k| format!(\"\\\"{}\\\"\", k)).join(\",\"));\n+    cx.shared.fs.write(&crate_list_dst, &crate_list)?;\n+\n+    if options.enable_index_page {\n+        if let Some(index_page) = options.index_page.clone() {\n+            let mut md_opts = options.clone();\n+            md_opts.output = cx.dst.clone();\n+            md_opts.external_html = (*cx.shared).layout.external_html.clone();\n+\n+            crate::markdown::render(&index_page, md_opts, cx.shared.edition)\n+                .map_err(|e| Error::new(e, &index_page))?;\n+        } else {\n+            let dst = cx.dst.join(\"index.html\");\n+            let page = layout::Page {\n+                title: \"Index of crates\",\n+                css_class: \"mod\",\n+                root_path: \"./\",\n+                static_root_path: cx.shared.static_root_path.as_deref(),\n+                description: \"List of crates\",\n+                keywords: BASIC_KEYWORDS,\n+                resource_suffix: &cx.shared.resource_suffix,\n+                extra_scripts: &[],\n+                static_extra_scripts: &[],\n+            };\n+\n+            let content = format!(\n+                \"<h1 class=\\\"fqn\\\">\\\n+                     <span class=\\\"in-band\\\">List of all crates</span>\\\n+                </h1><ul class=\\\"crate mod\\\">{}</ul>\",\n+                krates\n+                    .iter()\n+                    .map(|s| {\n+                        format!(\n+                            \"<li><a class=\\\"crate mod\\\" href=\\\"{}index.html\\\">{}</a></li>\",\n+                            ensure_trailing_slash(s),\n+                            s\n+                        )\n+                    })\n+                    .collect::<String>()\n+            );\n+            let v = layout::render(&cx.shared.layout, &page, \"\", content, &cx.shared.style_files);\n+            cx.shared.fs.write(&dst, v.as_bytes())?;\n+        }\n+    }\n+\n+    // Update the list of all implementors for traits\n+    let dst = cx.dst.join(\"implementors\");\n+    for (&did, imps) in &cx.cache.implementors {\n+        // Private modules can leak through to this phase of rustdoc, which\n+        // could contain implementations for otherwise private types. In some\n+        // rare cases we could find an implementation for an item which wasn't\n+        // indexed, so we just skip this step in that case.\n+        //\n+        // FIXME: this is a vague explanation for why this can't be a `get`, in\n+        //        theory it should be...\n+        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n+            Some(p) => p,\n+            None => match cx.cache.external_paths.get(&did) {\n+                Some(p) => p,\n+                None => continue,\n+            },\n+        };\n+\n+        #[derive(Serialize)]\n+        struct Implementor {\n+            text: String,\n+            synthetic: bool,\n+            types: Vec<String>,\n+        }\n+\n+        let implementors = imps\n+            .iter()\n+            .filter_map(|imp| {\n+                // If the trait and implementation are in the same crate, then\n+                // there's no need to emit information about it (there's inlining\n+                // going on). If they're in different crates then the crate defining\n+                // the trait will be interested in our implementation.\n+                //\n+                // If the implementation is from another crate then that crate\n+                // should add it.\n+                if imp.impl_item.def_id.krate == did.krate || !imp.impl_item.def_id.is_local() {\n+                    None\n+                } else {\n+                    Some(Implementor {\n+                        text: imp.inner_impl().print(cx.cache(), false).to_string(),\n+                        synthetic: imp.inner_impl().synthetic,\n+                        types: collect_paths_for_type(imp.inner_impl().for_.clone(), cx.cache()),\n+                    })\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+\n+        // Only create a js file if we have impls to add to it. If the trait is\n+        // documented locally though we always create the file to avoid dead\n+        // links.\n+        if implementors.is_empty() && !cx.cache.paths.contains_key(&did) {\n+            continue;\n+        }\n+\n+        let implementors = format!(\n+            r#\"implementors[\"{}\"] = {};\"#,\n+            krate.name,\n+            serde_json::to_string(&implementors).unwrap()\n+        );\n+\n+        let mut mydst = dst.clone();\n+        for part in &remote_path[..remote_path.len() - 1] {\n+            mydst.push(part);\n+        }\n+        cx.shared.ensure_dir(&mydst)?;\n+        mydst.push(&format!(\"{}.{}.js\", remote_item_type, remote_path[remote_path.len() - 1]));\n+\n+        let (mut all_implementors, _) =\n+            try_err!(collect(&mydst, &krate.name.as_str(), \"implementors\"), &mydst);\n+        all_implementors.push(implementors);\n+        // Sort the implementors by crate so the file will be generated\n+        // identically even with rustdoc running in parallel.\n+        all_implementors.sort();\n+\n+        let mut v = String::from(\"(function() {var implementors = {};\\n\");\n+        for implementor in &all_implementors {\n+            writeln!(v, \"{}\", *implementor).unwrap();\n+        }\n+        v.push_str(\n+            \"if (window.register_implementors) {\\\n+                 window.register_implementors(implementors);\\\n+             } else {\\\n+                 window.pending_implementors = implementors;\\\n+             }\",\n+        );\n+        v.push_str(\"})()\");\n+        cx.shared.fs.write(&mydst, &v)?;\n+    }\n+    Ok(())\n+}\n+\n+fn write_minify(\n+    fs: &DocFS,\n+    dst: PathBuf,\n+    contents: &str,\n+    enable_minification: bool,\n+) -> Result<(), Error> {\n+    if enable_minification {\n+        if dst.extension() == Some(&OsStr::new(\"css\")) {\n+            let res = try_none!(minifier::css::minify(contents).ok(), &dst);\n+            fs.write(dst, res.as_bytes())\n+        } else {\n+            fs.write(dst, minifier::js::minify(contents).as_bytes())\n+        }\n+    } else {\n+        fs.write(dst, contents.as_bytes())\n+    }\n+}"}]}