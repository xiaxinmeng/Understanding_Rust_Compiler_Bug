{"sha": "785a8a6681963ff389b5902e7d6bd30006fafe0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NWE4YTY2ODE5NjNmZjM4OWI1OTAyZTdkNmJkMzAwMDZmYWZlMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-16T12:16:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-16T12:16:43Z"}, "message": "Auto merge of #30410 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #30320, #30368, #30372, #30376, #30388, #30392\n- Failed merges: #30354, #30389", "tree": {"sha": "60b51ca2c9f0efd343f24eb564f90b5697a74c87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60b51ca2c9f0efd343f24eb564f90b5697a74c87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/785a8a6681963ff389b5902e7d6bd30006fafe0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/785a8a6681963ff389b5902e7d6bd30006fafe0a", "html_url": "https://github.com/rust-lang/rust/commit/785a8a6681963ff389b5902e7d6bd30006fafe0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/785a8a6681963ff389b5902e7d6bd30006fafe0a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce7bc51933e2facb4eca029ac17b398f372f5b41", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce7bc51933e2facb4eca029ac17b398f372f5b41", "html_url": "https://github.com/rust-lang/rust/commit/ce7bc51933e2facb4eca029ac17b398f372f5b41"}, {"sha": "f0361a05028ec9bf8ef256432c212f1d7f3bc115", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0361a05028ec9bf8ef256432c212f1d7f3bc115", "html_url": "https://github.com/rust-lang/rust/commit/f0361a05028ec9bf8ef256432c212f1d7f3bc115"}], "stats": {"total": 725, "additions": 455, "deletions": 270}, "files": [{"sha": "12d3465e5188d646706889aa795320b516868a83", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -26,12 +26,17 @@ use Bound;\n \n /// A set based on a B-Tree.\n ///\n-/// See BTreeMap's documentation for a detailed discussion of this collection's performance\n+/// See [`BTreeMap`]'s documentation for a detailed discussion of this collection's performance\n /// benefits and drawbacks.\n ///\n /// It is a logic error for an item to be modified in such a way that the item's ordering relative\n-/// to any other item, as determined by the `Ord` trait, changes while it is in the set. This is\n-/// normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n+/// to any other item, as determined by the [`Ord`] trait, changes while it is in the set. This is\n+/// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n+///\n+/// [`BTreeMap`]: ../struct.BTreeMap.html\n+/// [`Ord`]: ../../core/cmp/trait.Ord.html\n+/// [`Cell`]: ../../std/cell/struct.Cell.html\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n #[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeSet<T> {"}, {"sha": "0882f3f1137eca0c4a829d6b1206a0a5d0da6544", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -99,8 +99,9 @@ pub fn check_crate<'ast>(sess: &Session,\n         ast_map: ast_map,\n         discriminant_map: RefCell::new(NodeMap()),\n     };\n-    krate.visit_all_items(&mut visitor);\n-    sess.abort_if_errors();\n+    sess.abort_if_new_errors(|| {\n+        krate.visit_all_items(&mut visitor);\n+    });\n }\n \n struct CheckItemRecursionVisitor<'a, 'ast: 'a> {"}, {"sha": "809c6084b769f74c8dabeeddcbb0955bc6d89403", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -52,6 +52,7 @@ pub enum Def {\n     DefStruct(DefId),\n     DefLabel(ast::NodeId),\n     DefMethod(DefId),\n+    DefErr,\n }\n \n /// The result of resolving a path.\n@@ -124,7 +125,7 @@ impl Def {\n             DefVariant(..) | DefTy(..) | DefAssociatedTy(..) |\n             DefTyParam(..) | DefUse(..) | DefStruct(..) | DefTrait(..) |\n             DefMethod(..) | DefConst(..) | DefAssociatedConst(..) |\n-            DefPrimTy(..) | DefLabel(..) | DefSelfTy(..) => {\n+            DefPrimTy(..) | DefLabel(..) | DefSelfTy(..) | DefErr => {\n                 panic!(\"attempted .def_id() on invalid {:?}\", self)\n             }\n         }\n@@ -142,7 +143,8 @@ impl Def {\n \n             DefLabel(..)  |\n             DefPrimTy(..) |\n-            DefSelfTy(..) => {\n+            DefSelfTy(..) |\n+            DefErr => {\n                 panic!(\"attempted .def_id() on invalid def: {:?}\", self)\n             }\n         }"}, {"sha": "e148aecd241f2797c5ca3f5017adaffc69e63c59", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -18,6 +18,7 @@ pub use self::RegionResolutionError::*;\n pub use self::VarValue::*;\n \n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n+use super::unify_key;\n \n use rustc_data_structures::graph::{self, Direction, NodeIndex};\n use rustc_data_structures::unify::{self, UnificationTable};\n@@ -345,10 +346,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n-        let id = self.num_vars();\n+        let vid = RegionVid { index: self.num_vars() };\n         self.var_origins.borrow_mut().push(origin.clone());\n-        let vid = self.unification_table.borrow_mut().new_key(());\n-        assert_eq!(vid.index, id);\n+\n+        let u_vid = self.unification_table.borrow_mut().new_key(\n+            unify_key::RegionVidKey { min_vid: vid }\n+            );\n+        assert_eq!(vid, u_vid);\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n@@ -581,7 +585,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> ty::Region {\n-        ty::ReVar(self.unification_table.borrow_mut().find(rid))\n+        ty::ReVar(self.unification_table.borrow_mut().find_value(rid).min_vid)\n     }\n \n     fn combine_map(&self, t: CombineMapType) -> &RefCell<CombineMap> {"}, {"sha": "c83231930f502e0302d0c29327c8a05b43e3241d", "filename": "src/librustc/middle/infer/unify_key.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -10,7 +10,7 @@\n \n use syntax::ast;\n use middle::ty::{self, IntVarValue, Ty};\n-use rustc_data_structures::unify::UnifyKey;\n+use rustc_data_structures::unify::{Combine, UnifyKey};\n \n pub trait ToType<'tcx> {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n@@ -23,8 +23,28 @@ impl UnifyKey for ty::IntVid {\n     fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n }\n \n+#[derive(PartialEq, Copy, Clone, Debug)]\n+pub struct RegionVidKey {\n+    /// The minimum region vid in the unification set. This is needed\n+    /// to have a canonical name for a type to prevent infinite\n+    /// recursion.\n+    pub min_vid: ty::RegionVid\n+}\n+\n+impl Combine for RegionVidKey {\n+    fn combine(&self, other: &RegionVidKey) -> RegionVidKey {\n+        let min_vid = if self.min_vid.index < other.min_vid.index {\n+            self.min_vid\n+        } else {\n+            other.min_vid\n+        };\n+\n+        RegionVidKey { min_vid: min_vid }\n+    }\n+}\n+\n impl UnifyKey for ty::RegionVid {\n-    type Value = ();\n+    type Value = RegionVidKey;\n     fn index(&self) -> u32 { self.index }\n     fn from_index(i: u32) -> ty::RegionVid { ty::RegionVid { index: i } }\n     fn tag(_: Option<ty::RegionVid>) -> &'static str { \"RegionVid\" }"}, {"sha": "f869cac9236f6e710095d2a13048c33112c31334", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -609,6 +609,8 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 note: NoteNone\n             }))\n           }\n+\n+          def::DefErr => panic!(\"DefErr in memory categorization\")\n         }\n     }\n \n@@ -1196,7 +1198,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         (*op)(self, cmt.clone(), pat);\n \n         let opt_def = if let Some(path_res) = self.tcx().def_map.borrow().get(&pat.id) {\n-            if path_res.depth != 0 {\n+            if path_res.depth != 0 || path_res.base_def == def::DefErr {\n                 // Since patterns can be associated constants\n                 // which are resolved during typeck, we might have\n                 // some unresolved patterns reaching this stage\n@@ -1261,7 +1263,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 _ => {\n                     self.tcx().sess.span_bug(\n                         pat.span,\n-                        \"enum pattern didn't resolve to enum or struct\");\n+                        &format!(\"enum pattern didn't resolve to enum or struct {:?}\", opt_def));\n                 }\n             }\n           }"}, {"sha": "15d1546d2d5483e20edd5feb59d7b5df82a41d31", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -95,15 +95,16 @@ static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n pub fn krate(sess: &Session, krate: &hir::Crate, def_map: &DefMap) -> NamedRegionMap {\n     let mut named_region_map = NodeMap();\n-    krate.visit_all_items(&mut LifetimeContext {\n-        sess: sess,\n-        named_region_map: &mut named_region_map,\n-        scope: &ROOT_SCOPE,\n-        def_map: def_map,\n-        trait_ref_hack: false,\n-        labels_in_fn: vec![],\n+    sess.abort_if_new_errors(|| {\n+        krate.visit_all_items(&mut LifetimeContext {\n+            sess: sess,\n+            named_region_map: &mut named_region_map,\n+            scope: &ROOT_SCOPE,\n+            def_map: def_map,\n+            trait_ref_hack: false,\n+            labels_in_fn: vec![],\n+        });\n     });\n-    sess.abort_if_errors();\n     named_region_map\n }\n "}, {"sha": "5161a28ca31e88e492146d0ca60879e6b2a1b43f", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -2100,9 +2100,8 @@ impl<'tcx> ctxt<'tcx> {\n                     }) => {\n                         true\n                     }\n-\n+                    Some(&def::PathResolution { base_def: def::DefErr, .. })=> true,\n                     Some(..) => false,\n-\n                     None => self.sess.span_bug(expr.span, &format!(\n                         \"no def for path {}\", expr.id))\n                 }"}, {"sha": "b7bfc2f8db53ecc4569c2b63cde8f22cab34bda1", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -156,6 +156,15 @@ impl Session {\n             _ => {}\n         }\n     }\n+    pub fn abort_if_new_errors<F>(&self, mut f: F)\n+        where F: FnMut()\n+    {\n+        let count = self.err_count();\n+        f();\n+        if self.err_count() > count {\n+            self.abort_if_errors();\n+        }\n+    }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n         if self.can_print_warnings {\n             self.diagnostic().span_warn(sp, msg)"}, {"sha": "c07a27043c27501694fbe55e7bd96f6c03435cb5", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -33,6 +33,8 @@ use rustc_front::hir::{Expr, FnDecl, Block, Pat};\n use rustc_front::intravisit;\n use rustc_front::intravisit::Visitor;\n \n+use self::restrictions::RestrictionResult;\n+\n mod lifetime;\n mod restrictions;\n mod gather_moves;\n@@ -354,12 +356,12 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n         // Create the loan record (if needed).\n         let loan = match restr {\n-            restrictions::Safe => {\n+            RestrictionResult::Safe => {\n                 // No restrictions---no loan record necessary\n                 return;\n             }\n \n-            restrictions::SafeIf(loan_path, restricted_paths) => {\n+            RestrictionResult::SafeIf(loan_path, restricted_paths) => {\n                 let loan_scope = match loan_region {\n                     ty::ReScope(scope) => scope,\n "}, {"sha": "2a0d8ef276648a30f34d57973a90595b3cd6c870", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -10,8 +10,6 @@\n \n //! Computes the restrictions that result from a borrow.\n \n-pub use self::RestrictionResult::*;\n-\n use borrowck::*;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n@@ -69,19 +67,19 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 // are inherently non-aliasable, they can only be\n                 // accessed later through the borrow itself and hence\n                 // must inherently comply with its terms.\n-                Safe\n+                RestrictionResult::Safe\n             }\n \n             Categorization::Local(local_id) => {\n                 // R-Variable, locally declared\n                 let lp = new_lp(LpVar(local_id));\n-                SafeIf(lp.clone(), vec![lp])\n+                RestrictionResult::SafeIf(lp.clone(), vec![lp])\n             }\n \n             Categorization::Upvar(mc::Upvar { id, .. }) => {\n                 // R-Variable, captured into closure\n                 let lp = new_lp(LpUpvar(id));\n-                SafeIf(lp.clone(), vec![lp])\n+                RestrictionResult::SafeIf(lp.clone(), vec![lp])\n             }\n \n             Categorization::Downcast(cmt_base, _) => {\n@@ -106,7 +104,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n             }\n \n             Categorization::StaticItem => {\n-                Safe\n+                RestrictionResult::Safe\n             }\n \n             Categorization::Deref(cmt_base, _, pk) => {\n@@ -133,11 +131,11 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                                     cmt: cmt_base,\n                                     code: err_borrowed_pointer_too_short(\n                                         self.loan_region, lt)});\n-                            return Safe;\n+                            return RestrictionResult::Safe;\n                         }\n \n                         match bk {\n-                            ty::ImmBorrow => Safe,\n+                            ty::ImmBorrow => RestrictionResult::Safe,\n                             ty::MutBorrow | ty::UniqueImmBorrow => {\n                                 // R-Deref-Mut-Borrowed\n                                 //\n@@ -150,7 +148,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                         }\n                     }\n                     // Borrowck is not relevant for raw pointers\n-                    mc::UnsafePtr(..) => Safe\n+                    mc::UnsafePtr(..) => RestrictionResult::Safe\n                 }\n             }\n         }\n@@ -161,12 +159,12 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n               cmt: &mc::cmt<'tcx>,\n               elem: LoanPathElem) -> RestrictionResult<'tcx> {\n         match result {\n-            Safe => Safe,\n-            SafeIf(base_lp, mut base_vec) => {\n+            RestrictionResult::Safe => RestrictionResult::Safe,\n+            RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n                 let v = LpExtend(base_lp, cmt.mutbl, elem);\n                 let lp = Rc::new(LoanPath::new(v, cmt.ty));\n                 base_vec.push(lp.clone());\n-                SafeIf(lp, base_vec)\n+                RestrictionResult::SafeIf(lp, base_vec)\n             }\n         }\n     }"}, {"sha": "c6da70eef750a89f0947b0388bb2ba650f396ee4", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -37,6 +37,16 @@ pub trait UnifyKey : Copy + Clone + Debug + PartialEq {\n     fn tag(k: Option<Self>) -> &'static str;\n }\n \n+/// This trait is implemented for unify values that can be\n+/// combined. This relation should be a monoid.\n+pub trait Combine {\n+    fn combine(&self, other: &Self) -> Self;\n+}\n+\n+impl Combine for () {\n+    fn combine(&self, _other: &()) {}\n+}\n+\n /// Value of a unification key. We implement Tarjan's union-find\n /// algorithm: when two keys are unified, one of them is converted\n /// into a \"redirect\" pointing at the other. These redirects form a\n@@ -243,23 +253,28 @@ impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n ///////////////////////////////////////////////////////////////////////////\n // Base union-find algorithm, where we are just making sets\n \n-impl<'tcx,K> UnificationTable<K>\n-    where K : UnifyKey<Value=()>,\n+impl<'tcx,K:UnifyKey> UnificationTable<K>\n+    where K::Value: Combine\n {\n     pub fn union(&mut self, a_id: K, b_id: K) {\n         let node_a = self.get(a_id);\n         let node_b = self.get(b_id);\n         let a_id = node_a.key();\n         let b_id = node_b.key();\n         if a_id != b_id {\n-            self.unify(node_a, node_b, ());\n+            let new_value = node_a.value.combine(&node_b.value);\n+            self.unify(node_a, node_b, new_value);\n         }\n     }\n \n     pub fn find(&mut self, id: K) -> K {\n         self.get(id).key()\n     }\n \n+    pub fn find_value(&mut self, id: K) -> K::Value {\n+        self.get(id).value\n+    }\n+\n     pub fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n         self.find(a_id) == self.find(b_id)\n     }"}, {"sha": "d43ffb0fc3f3e071616857740b3208069521c435", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -407,7 +407,8 @@ impl tr for def::Def {\n               def::DefUpvar(did1, nid1, index, nid2)\n           }\n           def::DefStruct(did) => def::DefStruct(did.tr(dcx)),\n-          def::DefLabel(nid) => def::DefLabel(dcx.tr_id(nid))\n+          def::DefLabel(nid) => def::DefLabel(dcx.tr_id(nid)),\n+          def::DefErr => def::DefErr,\n         }\n     }\n }"}, {"sha": "8b5b6ff781e070c177cdfb439f65dd4c6a155698", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -709,7 +709,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             DefUse(..) |\n             DefUpvar(..) |\n             DefLabel(..) |\n-            DefSelfTy(..) => {\n+            DefSelfTy(..) |\n+            DefErr => {\n                 panic!(\"didn't expect `{:?}`\", def);\n             }\n         }"}, {"sha": "4d5978f5560781eea3e31a63e003c165299ac8d8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -566,6 +566,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n             Ok(def) => self.record_def(tref.trait_ref.ref_id, def),\n             Err(_) => {\n                 // error already reported\n+                self.record_def(tref.trait_ref.ref_id, err_path_resolution())\n             }\n         }\n         intravisit::walk_poly_trait_ref(self, tref, m);\n@@ -2005,6 +2006,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                   prefix.span,\n                                                   ResolutionError::FailedToResolve(\n                                                       &path_names_to_string(prefix, 0)));\n+                                    self.record_def(item.id, err_path_resolution());\n                                 }\n                             }\n                         }\n@@ -2164,6 +2166,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         resolve_error(self,\n                                       eq_pred.span,\n                                       ResolutionError::UndeclaredAssociatedType);\n+                        self.record_def(eq_pred.id, err_path_resolution());\n                     }\n                 }\n             }\n@@ -2194,6 +2197,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.record_def(trait_ref.ref_id, path_res);\n                 new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n                 new_id = Some(path_res.base_def.def_id());\n+            } else {\n+                self.record_def(trait_ref.ref_id, err_path_resolution());\n             }\n             intravisit::walk_trait_ref(self, trait_ref);\n         }\n@@ -2463,6 +2468,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.record_def(ty.id, def);\n                     }\n                     None => {\n+                        self.record_def(ty.id, err_path_resolution());\n+\n                         // Keep reporting some errors even if they're ignored above.\n                         self.resolve_path(ty.id, path, 0, TypeNS, true);\n \n@@ -2545,6 +2552,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(\n                                     renamed)\n                             );\n+                            self.record_def(pattern.id, err_path_resolution());\n                         }\n                         FoundConst(def, lp, _) if const_ok => {\n                             debug!(\"(resolving pattern) resolving `{}` to constant\", renamed);\n@@ -2564,6 +2572,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 ResolutionError::OnlyIrrefutablePatternsAllowedHere(def.def_id(),\n                                                                                     name)\n                             );\n+                            self.record_def(pattern.id, err_path_resolution());\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `{}`\", renamed);\n@@ -2647,6 +2656,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 resolve_error(&self,\n                                               path.span,\n                                               ResolutionError::StaticVariableReference);\n+                                self.record_def(pattern.id, err_path_resolution());\n                             }\n                             _ => {\n                                 // If anything ends up here entirely resolved,\n@@ -2665,6 +2675,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                  .name\n                                                  .as_str())\n                                     );\n+                                    self.record_def(pattern.id, err_path_resolution());\n                                 } else {\n                                     let const_name = path.segments\n                                                          .last()\n@@ -2684,6 +2695,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             ResolutionError::UnresolvedEnumVariantStructOrConst(\n                                 &path.segments.last().unwrap().identifier.name.as_str())\n                         );\n+                        self.record_def(pattern.id, err_path_resolution());\n                     }\n                     intravisit::walk_path(self, path);\n                 }\n@@ -2726,6 +2738,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         &path.segments.last().unwrap().identifier.name.as_str()\n                                     )\n                                 );\n+                                self.record_def(pattern.id, err_path_resolution());\n                             }\n                         }\n                     } else {\n@@ -2737,6 +2750,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                                       .identifier\n                                                                                       .name\n                                                                                       .as_str()));\n+                        self.record_def(pattern.id, err_path_resolution());\n                     }\n                     intravisit::walk_pat(self, pattern);\n                 }\n@@ -2754,6 +2768,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 ResolutionError::DoesNotNameAStruct(\n                                     &*path_names_to_string(path, 0))\n                             );\n+                            self.record_def(pattern.id, err_path_resolution());\n                         }\n                     }\n                     intravisit::walk_path(self, path);\n@@ -3430,6 +3445,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         } else {\n                             self.session.span_help(expr.span, &msg);\n                         }\n+                        self.record_def(expr.id, err_path_resolution());\n                     } else {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `{}`\",\n@@ -3454,6 +3470,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let type_res = self.with_no_errors(|this| {\n                         this.resolve_path(expr.id, path, 0, TypeNS, false)\n                     });\n+\n+                    self.record_def(expr.id, err_path_resolution());\n                     match type_res.map(|r| r.base_def) {\n                         Some(DefTy(struct_id, _)) if self.structs.contains_key(&struct_id) => {\n                             resolve_error(\n@@ -3540,6 +3558,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                       ResolutionError::DoesNotNameAStruct(\n                                                                 &*path_names_to_string(path, 0))\n                                      );\n+                        self.record_def(expr.id, err_path_resolution());\n                     }\n                 }\n \n@@ -3562,6 +3581,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 match self.search_label(label.node.name) {\n                     None => {\n+                        self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n                                       label.span,\n                                       ResolutionError::UndeclaredLabel(&label.node.name.as_str()))\n@@ -3811,6 +3831,14 @@ fn module_to_string(module: &Module) -> String {\n     names_to_string(&names.into_iter().rev().collect::<Vec<ast::Name>>())\n }\n \n+fn err_path_resolution() -> PathResolution {\n+    PathResolution {\n+        base_def: DefErr,\n+        last_private: LastMod(AllPublic),\n+        depth: 0,\n+    }\n+}\n+\n \n pub struct CrateMap {\n     pub def_map: RefCell<DefMap>,\n@@ -3836,7 +3864,6 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, None);\n \n     resolver.resolve_crate(krate);\n-    session.abort_if_errors();\n \n     check_unused::check_crate(&mut resolver, krate);\n "}, {"sha": "b3e7ed7ed5e8e3a0dc479cc5cd39a8353b13b000", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -276,7 +276,8 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             def::DefTyParam(..) |\n             def::DefUse(_) |\n             def::DefMethod(..) |\n-            def::DefPrimTy(_) => {\n+            def::DefPrimTy(_) |\n+            def::DefErr => {\n                 self.sess.span_bug(span,\n                                    &format!(\"lookup_def_kind for unexpected item: {:?}\", def));\n             }"}, {"sha": "a22c12588e5f74a9e86703fcfa923f3f3151f8d8", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -216,7 +216,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n             def::DefMod(..) | def::DefForeignMod(..) | def::DefTrait(..) |\n             def::DefTy(..) | def::DefPrimTy(..) | def::DefAssociatedTy(..) |\n             def::DefUse(..) | def::DefLabel(..) | def::DefTyParam(..) |\n-            def::DefSelfTy(..) => {\n+            def::DefSelfTy(..) | def::DefErr => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     &format!(\"cannot translate def {:?} \\"}, {"sha": "752dd6e57f64fc86fbba86c35e26d0ed9dc41d01", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -719,6 +719,9 @@ fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &hir::TraitRef) -> DefId\n     let path = &trait_ref.path;\n     match ::lookup_full_def(this.tcx(), path.span, trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => trait_def_id,\n+        def::DefErr => {\n+            this.tcx().sess.fatal(\"cannot continue compilation due to previous error\");\n+        }\n         _ => {\n             span_fatal!(this.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n                         path);\n@@ -1533,6 +1536,9 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         def::DefPrimTy(prim_ty) => {\n             prim_ty_to_ty(tcx, base_segments, prim_ty)\n         }\n+        def::DefErr => {\n+            return this.tcx().types.err;\n+        }\n         _ => {\n             let id_node = tcx.map.as_local_node_id(def.def_id()).unwrap();\n             span_err!(tcx.sess, span, E0248,"}, {"sha": "efcc08c69f8246f83e9321b7bbe43a528db707c5", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -142,20 +142,24 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     return;\n                 }\n             }\n-            let const_did = tcx.def_map.borrow().get(&pat.id).unwrap().def_id();\n-            let const_scheme = tcx.lookup_item_type(const_did);\n-            assert!(const_scheme.generics.is_empty());\n-            let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n-                                                           &Substs::empty(),\n-                                                           &const_scheme.ty);\n-            fcx.write_ty(pat.id, const_ty);\n-\n-            // FIXME(#20489) -- we should limit the types here to scalars or something!\n-\n-            // As with PatLit, what we really want here is that there\n-            // exist a LUB, but for the cases that can occur, subtype\n-            // is good enough.\n-            demand::suptype(fcx, pat.span, expected, const_ty);\n+            if let Some(pat_def) = tcx.def_map.borrow().get(&pat.id) {\n+                let const_did = pat_def.def_id();\n+                let const_scheme = tcx.lookup_item_type(const_did);\n+                assert!(const_scheme.generics.is_empty());\n+                let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n+                                                               &Substs::empty(),\n+                                                               &const_scheme.ty);\n+                fcx.write_ty(pat.id, const_ty);\n+\n+                // FIXME(#20489) -- we should limit the types here to scalars or something!\n+\n+                // As with PatLit, what we really want here is that there\n+                // exist a LUB, but for the cases that can occur, subtype\n+                // is good enough.\n+                demand::suptype(fcx, pat.span, expected, const_ty);\n+            } else {\n+                fcx.write_error(pat.id);\n+            }\n         }\n         hir::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n             let typ = fcx.local_ty(pat.span, pat.id);\n@@ -186,14 +190,15 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             // if there are multiple arms, make sure they all agree on\n             // what the type of the binding `x` ought to be\n-            let canon_id = *pcx.map.get(&path.node.name).unwrap();\n-            if canon_id != pat.id {\n-                let ct = fcx.local_ty(pat.span, canon_id);\n-                demand::eqtype(fcx, pat.span, ct, typ);\n-            }\n+            if let Some(&canon_id) = pcx.map.get(&path.node.name) {\n+                if canon_id != pat.id {\n+                    let ct = fcx.local_ty(pat.span, canon_id);\n+                    demand::eqtype(fcx, pat.span, ct, typ);\n+                }\n \n-            if let Some(ref p) = *sub {\n-                check_pat(pcx, &**p, expected);\n+                if let Some(ref p) = *sub {\n+                    check_pat(pcx, &**p, expected);\n+                }\n             }\n         }\n         hir::PatIdent(_, ref path, _) => {\n@@ -208,6 +213,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         hir::PatQPath(ref qself, ref path) => {\n             let self_ty = fcx.to_ty(&qself.ty);\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n+                if d.base_def == def::DefErr {\n+                    fcx.write_error(pat.id);\n+                    return;\n+                }\n                 d\n             } else if qself.position == 0 {\n                 // This is just a sentinel for finish_resolving_def_to_ty.\n@@ -218,8 +227,9 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     depth: path.segments.len()\n                 }\n             } else {\n-                tcx.sess.span_bug(pat.span,\n-                                  &format!(\"unbound path {:?}\", pat))\n+                debug!(\"unbound path {:?}\", pat);\n+                fcx.write_error(pat.id);\n+                return;\n             };\n             if let Some((opt_ty, segments, def)) =\n                     resolve_ty_and_def_ufcs(fcx, path_res, Some(self_ty),\n@@ -597,7 +607,20 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let path_res = *tcx.def_map.borrow().get(&pat.id).unwrap();\n+    let path_res = match tcx.def_map.borrow().get(&pat.id) {\n+        Some(&path_res) if path_res.base_def != def::DefErr => path_res,\n+        _ => {\n+            fcx.write_error(pat.id);\n+\n+            if let Some(subpats) = subpats {\n+                for pat in subpats {\n+                    check_pat(pcx, &**pat, tcx.types.err);\n+                }\n+            }\n+\n+            return;\n+        }\n+    };\n \n     let (opt_ty, segments, def) = match resolve_ty_and_def_ufcs(fcx, path_res,\n                                                                 None, path,\n@@ -636,7 +659,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let report_bad_struct_kind = |is_warning| {\n         bad_struct_kind_err(tcx.sess, pat.span, path, is_warning);\n         if is_warning {\n-            return\n+            return;\n         }\n \n         fcx.write_error(pat.id);"}, {"sha": "1e20cd3985467f45284d72c82229e9f875b5c21b", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -26,6 +26,7 @@ use super::write_call;\n \n use CrateCtxt;\n use middle::cstore::LOCAL_CRATE;\n+use middle::def;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::ty::{self, LvaluePreference, Ty};\n@@ -234,7 +235,7 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             if let hir::ExprCall(ref expr, _) = call_expr.node {\n                 let tcx = fcx.tcx();\n                 if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n-                    if pr.depth == 0 {\n+                    if pr.depth == 0 && pr.base_def != def::DefErr {\n                         if let Some(span) = tcx.map.span_if_local(pr.def_id()) {\n                             tcx.sess.span_note(span, \"defined here\")\n                         }"}, {"sha": "59025346ce3bd029b3cce2d000a306cf1bd4712c", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -17,6 +17,7 @@ use middle::region;\n use middle::subst::{self, Subst};\n use middle::traits;\n use middle::ty::{self, Ty};\n+use util::nodemap::FnvHashSet;\n \n use syntax::ast;\n use syntax::codemap::{self, Span};\n@@ -279,7 +280,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n             rcx: rcx,\n             span: span,\n             parent_scope: parent_scope,\n-            breadcrumbs: Vec::new(),\n+            breadcrumbs: FnvHashSet()\n         },\n         TypeContext::Root,\n         typ,\n@@ -340,7 +341,7 @@ enum TypeContext {\n struct DropckContext<'a, 'b: 'a, 'tcx: 'b> {\n     rcx: &'a mut Rcx<'b, 'tcx>,\n     /// types that have already been traversed\n-    breadcrumbs: Vec<Ty<'tcx>>,\n+    breadcrumbs: FnvHashSet<Ty<'tcx>>,\n     /// span for error reporting\n     span: Span,\n     /// the scope reachable dtorck types must outlive\n@@ -355,8 +356,6 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     depth: usize) -> Result<(), Error<'tcx>>\n {\n     let tcx = cx.rcx.tcx();\n-    let ty = cx.rcx.infcx().resolve_type_and_region_vars_if_possible(&ty);\n-\n     // Issue #22443: Watch out for overflow. While we are careful to\n     // handle regular types properly, non-regular ones cause problems.\n     let recursion_limit = tcx.sess.recursion_limit.get();\n@@ -367,19 +366,17 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n         return Err(Error::Overflow(context, ty))\n     }\n \n-    for breadcrumb in &mut cx.breadcrumbs {\n-        *breadcrumb =\n-            cx.rcx.infcx().resolve_type_and_region_vars_if_possible(breadcrumb);\n-        if *breadcrumb == ty {\n-            debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-                   {}ty: {} scope: {:?} - cached\",\n-                   (0..depth).map(|_| ' ').collect::<String>(),\n-                   ty, cx.parent_scope);\n-            return Ok(()); // we already visited this type\n-        }\n-    }\n-    cx.breadcrumbs.push(ty);\n+    // canoncialize the regions in `ty` before inserting - infinitely many\n+    // region variables can refer to the same region.\n+    let ty = cx.rcx.infcx().resolve_type_and_region_vars_if_possible(&ty);\n \n+    if !cx.breadcrumbs.insert(ty) {\n+        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+               {}ty: {} scope: {:?} - cached\",\n+               (0..depth).map(|_| ' ').collect::<String>(),\n+               ty, cx.parent_scope);\n+        return Ok(()); // we already visited this type\n+    }\n     debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n            {}ty: {} scope: {:?}\",\n            (0..depth).map(|_| ' ').collect::<String>(),"}, {"sha": "1f3d8f55120aa4456517d1bc67859c976dc1d483", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 118, "deletions": 113, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -385,61 +385,60 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n }\n \n pub fn check_wf_old(ccx: &CrateCtxt) {\n-    // FIXME(#25759). The new code below is much more reliable but (for now)\n-    // only generates warnings. So as to ensure that we continue\n-    // getting errors where we used to get errors, we run the old wf\n-    // code first and abort if it encounters any errors. If no abort\n-    // comes, we run the new code and issue warnings.\n-    let krate = ccx.tcx.map.krate();\n-    let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n-    krate.visit_all_items(&mut visit);\n-\n     // If types are not well-formed, it leads to all manner of errors\n     // downstream, so stop reporting errors at this point.\n-    ccx.tcx.sess.abort_if_errors();\n+    ccx.tcx.sess.abort_if_new_errors(|| {\n+        // FIXME(#25759). The new code below is much more reliable but (for now)\n+        // only generates warnings. So as to ensure that we continue\n+        // getting errors where we used to get errors, we run the old wf\n+        // code first and abort if it encounters any errors. If no abort\n+        // comes, we run the new code and issue warnings.\n+        let krate = ccx.tcx.map.krate();\n+        let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n+        krate.visit_all_items(&mut visit);\n+    });\n }\n \n pub fn check_wf_new(ccx: &CrateCtxt) {\n-    let krate = ccx.tcx.map.krate();\n-    let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n-    krate.visit_all_items(&mut visit);\n-\n-    // If types are not well-formed, it leads to all manner of errors\n-    // downstream, so stop reporting errors at this point.\n-    ccx.tcx.sess.abort_if_errors();\n+    ccx.tcx.sess.abort_if_new_errors(|| {\n+        let krate = ccx.tcx.map.krate();\n+        let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n+        krate.visit_all_items(&mut visit);\n+    });\n }\n \n pub fn check_item_types(ccx: &CrateCtxt) {\n-    let krate = ccx.tcx.map.krate();\n-    let mut visit = CheckItemTypesVisitor { ccx: ccx };\n-    krate.visit_all_items(&mut visit);\n-    ccx.tcx.sess.abort_if_errors();\n+    ccx.tcx.sess.abort_if_new_errors(|| {\n+        let krate = ccx.tcx.map.krate();\n+        let mut visit = CheckItemTypesVisitor { ccx: ccx };\n+        krate.visit_all_items(&mut visit);\n+    });\n }\n \n pub fn check_item_bodies(ccx: &CrateCtxt) {\n-    let krate = ccx.tcx.map.krate();\n-    let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n-    krate.visit_all_items(&mut visit);\n-\n-    ccx.tcx.sess.abort_if_errors();\n+    ccx.tcx.sess.abort_if_new_errors(|| {\n+        let krate = ccx.tcx.map.krate();\n+        let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n+        krate.visit_all_items(&mut visit);\n+    });\n }\n \n pub fn check_drop_impls(ccx: &CrateCtxt) {\n-    let drop_trait = match ccx.tcx.lang_items.drop_trait() {\n-        Some(id) => ccx.tcx.lookup_trait_def(id), None => { return }\n-    };\n-    drop_trait.for_each_impl(ccx.tcx, |drop_impl_did| {\n-        if drop_impl_did.is_local() {\n-            match dropck::check_drop_impl(ccx.tcx, drop_impl_did) {\n-                Ok(()) => {}\n-                Err(()) => {\n-                    assert!(ccx.tcx.sess.has_errors());\n+    ccx.tcx.sess.abort_if_new_errors(|| {\n+        let drop_trait = match ccx.tcx.lang_items.drop_trait() {\n+            Some(id) => ccx.tcx.lookup_trait_def(id), None => { return }\n+        };\n+        drop_trait.for_each_impl(ccx.tcx, |drop_impl_did| {\n+            if drop_impl_did.is_local() {\n+                match dropck::check_drop_impl(ccx.tcx, drop_impl_did) {\n+                    Ok(()) => {}\n+                    Err(()) => {\n+                        assert!(ccx.tcx.sess.has_errors());\n+                    }\n                 }\n             }\n-        }\n+        });\n     });\n-\n-    ccx.tcx.sess.abort_if_errors();\n }\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -891,75 +890,71 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     for impl_item in impl_items {\n         let ty_impl_item = ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(impl_item.id));\n         let ty_trait_item = trait_items.iter()\n-            .find(|ac| ac.name() == ty_impl_item.name())\n-            .unwrap_or_else(|| {\n-                // This is checked by resolve\n-                tcx.sess.span_bug(impl_item.span,\n-                                  &format!(\"impl-item `{}` is not a member of `{:?}`\",\n-                                           ty_impl_item.name(),\n-                                           impl_trait_ref));\n-            });\n-        match impl_item.node {\n-            hir::ImplItemKind::Const(..) => {\n-                let impl_const = match ty_impl_item {\n-                    ty::ConstTraitItem(ref cti) => cti,\n-                    _ => tcx.sess.span_bug(impl_item.span, \"non-const impl-item for const\")\n-                };\n+            .find(|ac| ac.name() == ty_impl_item.name());\n \n-                // Find associated const definition.\n-                if let &ty::ConstTraitItem(ref trait_const) = ty_trait_item {\n-                    compare_const_impl(ccx.tcx,\n-                                       &impl_const,\n-                                       impl_item.span,\n-                                       trait_const,\n-                                       &*impl_trait_ref);\n-                } else {\n-                    span_err!(tcx.sess, impl_item.span, E0323,\n-                              \"item `{}` is an associated const, \\\n-                              which doesn't match its trait `{:?}`\",\n-                              impl_const.name,\n-                              impl_trait_ref)\n+        if let Some(ty_trait_item) = ty_trait_item {\n+            match impl_item.node {\n+                hir::ImplItemKind::Const(..) => {\n+                    let impl_const = match ty_impl_item {\n+                        ty::ConstTraitItem(ref cti) => cti,\n+                        _ => tcx.sess.span_bug(impl_item.span, \"non-const impl-item for const\")\n+                    };\n+\n+                    // Find associated const definition.\n+                    if let &ty::ConstTraitItem(ref trait_const) = ty_trait_item {\n+                        compare_const_impl(ccx.tcx,\n+                                           &impl_const,\n+                                           impl_item.span,\n+                                           trait_const,\n+                                           &*impl_trait_ref);\n+                    } else {\n+                        span_err!(tcx.sess, impl_item.span, E0323,\n+                                  \"item `{}` is an associated const, \\\n+                                  which doesn't match its trait `{:?}`\",\n+                                  impl_const.name,\n+                                  impl_trait_ref)\n+                    }\n                 }\n-            }\n-            hir::ImplItemKind::Method(ref sig, ref body) => {\n-                check_trait_fn_not_const(ccx, impl_item.span, sig.constness);\n+                hir::ImplItemKind::Method(ref sig, ref body) => {\n+                    check_trait_fn_not_const(ccx, impl_item.span, sig.constness);\n \n-                let impl_method = match ty_impl_item {\n-                    ty::MethodTraitItem(ref mti) => mti,\n-                    _ => tcx.sess.span_bug(impl_item.span, \"non-method impl-item for method\")\n-                };\n+                    let impl_method = match ty_impl_item {\n+                        ty::MethodTraitItem(ref mti) => mti,\n+                        _ => tcx.sess.span_bug(impl_item.span, \"non-method impl-item for method\")\n+                    };\n \n-                if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n-                    compare_impl_method(ccx.tcx,\n-                                        &impl_method,\n-                                        impl_item.span,\n-                                        body.id,\n-                                        &trait_method,\n-                                        &impl_trait_ref);\n-                } else {\n-                    span_err!(tcx.sess, impl_item.span, E0324,\n-                              \"item `{}` is an associated method, \\\n-                              which doesn't match its trait `{:?}`\",\n-                              impl_method.name,\n-                              impl_trait_ref)\n+                    if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n+                        compare_impl_method(ccx.tcx,\n+                                            &impl_method,\n+                                            impl_item.span,\n+                                            body.id,\n+                                            &trait_method,\n+                                            &impl_trait_ref);\n+                    } else {\n+                        span_err!(tcx.sess, impl_item.span, E0324,\n+                                  \"item `{}` is an associated method, \\\n+                                  which doesn't match its trait `{:?}`\",\n+                                  impl_method.name,\n+                                  impl_trait_ref)\n+                    }\n                 }\n-            }\n-            hir::ImplItemKind::Type(_) => {\n-                let impl_type = match ty_impl_item {\n-                    ty::TypeTraitItem(ref tti) => tti,\n-                    _ => tcx.sess.span_bug(impl_item.span, \"non-type impl-item for type\")\n-                };\n+                hir::ImplItemKind::Type(_) => {\n+                    let impl_type = match ty_impl_item {\n+                        ty::TypeTraitItem(ref tti) => tti,\n+                        _ => tcx.sess.span_bug(impl_item.span, \"non-type impl-item for type\")\n+                    };\n \n-                if let &ty::TypeTraitItem(ref at) = ty_trait_item {\n-                    if let Some(_) = at.ty {\n-                        overridden_associated_type = Some(impl_item);\n+                    if let &ty::TypeTraitItem(ref at) = ty_trait_item {\n+                        if let Some(_) = at.ty {\n+                            overridden_associated_type = Some(impl_item);\n+                        }\n+                    } else {\n+                        span_err!(tcx.sess, impl_item.span, E0325,\n+                                  \"item `{}` is an associated type, \\\n+                                  which doesn't match its trait `{:?}`\",\n+                                  impl_type.name,\n+                                  impl_trait_ref)\n                     }\n-                } else {\n-                    span_err!(tcx.sess, impl_item.span, E0325,\n-                              \"item `{}` is an associated type, \\\n-                              which doesn't match its trait `{:?}`\",\n-                              impl_type.name,\n-                              impl_trait_ref)\n                 }\n             }\n         }\n@@ -3193,6 +3188,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // Find the relevant variant\n         let def = lookup_full_def(tcx, path.span, expr.id);\n+        if def == def::DefErr {\n+            check_struct_fields_on_error(fcx, expr.id, fields, base_expr);\n+            return;\n+        }\n         let (adt, variant) = match fcx.def_struct_variant(def, path.span) {\n             Some((adt, variant)) => (adt, variant),\n             None => {\n@@ -3371,17 +3370,21 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           if let Some((opt_ty, segments, def)) =\n                   resolve_ty_and_def_ufcs(fcx, path_res, opt_self_ty, path,\n                                           expr.span, expr.id) {\n-              let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx,\n-                                                                            expr.span,\n-                                                                            def);\n-              instantiate_path(fcx,\n-                               segments,\n-                               scheme,\n-                               &predicates,\n-                               opt_ty,\n-                               def,\n-                               expr.span,\n-                               id);\n+              if def != def::DefErr {\n+                  let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx,\n+                                                                                expr.span,\n+                                                                                def);\n+                  instantiate_path(fcx,\n+                                   segments,\n+                                   scheme,\n+                                   &predicates,\n+                                   opt_ty,\n+                                   def,\n+                                   expr.span,\n+                                   id);\n+              } else {\n+                  fcx.write_ty(id, fcx.tcx().types.err);\n+              }\n           }\n \n           // We always require that the type provided as the value for\n@@ -4326,7 +4329,8 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefForeignMod(..) |\n         def::DefUse(..) |\n         def::DefLabel(..) |\n-        def::DefSelfTy(..) => {\n+        def::DefSelfTy(..) |\n+        def::DefErr => {\n             fcx.ccx.tcx.sess.span_bug(sp, &format!(\"expected value, found {:?}\", defn));\n         }\n     }\n@@ -4496,7 +4500,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefLocal(..) |\n         def::DefUse(..) |\n         def::DefLabel(..) |\n-        def::DefUpvar(..) => {\n+        def::DefUpvar(..) |\n+        def::DefErr => {\n             segment_spaces = vec![None; segments.len()];\n         }\n     }"}, {"sha": "c24a416a0109c7a52e789d1d9d14e6f4dd66e024", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -122,10 +122,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 } else {\n                     let tcx = self.tcx();\n \n-                    if let hir::ExprAssignOp(..) = e.node {\n+                    if let hir::ExprAssignOp(_, ref lhs, ref rhs) = e.node {\n                         if\n                             !tcx.sess.features.borrow().augmented_assignments &&\n-                            !self.fcx.expr_ty(e).references_error()\n+                            !self.fcx.expr_ty(e).references_error() &&\n+                            !self.fcx.expr_ty(lhs).references_error() &&\n+                            !self.fcx.expr_ty(rhs).references_error()\n                         {\n                             tcx.sess.span_err(\n                                 e.span,"}, {"sha": "b436a5ee524acf7dc88bc112c7d6bc707b4c6ea0", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -205,6 +205,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                                   \"f64\",\n                                                   item.span);\n                     }\n+                    ty::TyError => {\n+                        return;\n+                    }\n                     _ => {\n                         span_err!(self.tcx.sess, item.span, E0118,\n                                   \"no base type found for inherent implementation; \\"}, {"sha": "02c1f3973c61a0875b3c636e9a864165f8038e57", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -331,18 +331,21 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n         tcx: tcx\n     };\n \n-    time(time_passes, \"type collecting\", ||\n-         collect::collect_item_types(tcx));\n-\n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n-    tcx.sess.abort_if_errors();\n+    tcx.sess.abort_if_new_errors(|| {\n+        time(time_passes, \"type collecting\", ||\n+             collect::collect_item_types(tcx));\n+\n+    });\n \n     time(time_passes, \"variance inference\", ||\n          variance::infer_variance(tcx));\n \n-    time(time_passes, \"coherence checking\", ||\n-        coherence::check_coherence(&ccx));\n+    tcx.sess.abort_if_new_errors(|| {\n+      time(time_passes, \"coherence checking\", ||\n+          coherence::check_coherence(&ccx));\n+    });\n \n     time(time_passes, \"wf checking (old)\", ||\n         check::check_wf_old(&ccx));"}, {"sha": "af6510cb3870e1fcf44b9739f30e596c692b68ca", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -261,7 +261,7 @@ pub fn main_args(args: &[String]) -> isize {\n \n     match (should_test, markdown_input) {\n         (true, true) => {\n-            return markdown::test(input, libs, externs, test_args)\n+            return markdown::test(input, cfgs, libs, externs, test_args)\n         }\n         (true, false) => {\n             return test::run(input, cfgs, libs, externs, test_args, crate_name)"}, {"sha": "03d2c1a1b4d0d3ea2189e37ec9858faf7b68bf7b", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -142,13 +142,13 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n }\n \n /// Run any tests/code examples in the markdown file `input`.\n-pub fn test(input: &str, libs: SearchPaths, externs: core::Externs,\n+pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: core::Externs,\n             mut test_args: Vec<String>) -> isize {\n     let input_str = load_or_return!(input, 1, 2);\n \n     let mut opts = TestOptions::default();\n     opts.no_crate_inject = true;\n-    let mut collector = Collector::new(input.to_string(), libs, externs,\n+    let mut collector = Collector::new(input.to_string(), cfgs, libs, externs,\n                                        true, opts);\n     find_testable_code(&input_str, &mut collector);\n     test_args.insert(0, \"rustdoctest\".to_string());"}, {"sha": "3322794c7781e28827a66df5cb66ebb52a49d445", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -85,7 +85,7 @@ pub fn run(input: &str,\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess);\n-    cfg.extend(config::parse_cfgspecs(cfgs));\n+    cfg.extend(config::parse_cfgspecs(cfgs.clone()));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n     let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate,\n                                                      \"rustdoc-test\", None)\n@@ -122,6 +122,7 @@ pub fn run(input: &str,\n     let (krate, _) = passes::unindent_comments(krate);\n \n     let mut collector = Collector::new(krate.name.to_string(),\n+                                       cfgs,\n                                        libs,\n                                        externs,\n                                        false,\n@@ -168,7 +169,7 @@ fn scrape_test_config(krate: &::rustc_front::hir::Crate) -> TestOptions {\n     return opts;\n }\n \n-fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n+fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n            externs: core::Externs,\n            should_panic: bool, no_run: bool, as_test_harness: bool,\n            opts: &TestOptions) {\n@@ -239,7 +240,8 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n \n     let outdir = TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\");\n     let out = Some(outdir.path().to_path_buf());\n-    let cfg = config::build_configuration(&sess);\n+    let mut cfg = config::build_configuration(&sess);\n+    cfg.extend(config::parse_cfgspecs(cfgs));\n     let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n     let mut control = driver::CompileController::basic();\n     if no_run {\n@@ -349,6 +351,7 @@ fn partition_source(s: &str) -> (String, String) {\n pub struct Collector {\n     pub tests: Vec<testing::TestDescAndFn>,\n     names: Vec<String>,\n+    cfgs: Vec<String>,\n     libs: SearchPaths,\n     externs: core::Externs,\n     cnt: usize,\n@@ -359,11 +362,12 @@ pub struct Collector {\n }\n \n impl Collector {\n-    pub fn new(cratename: String, libs: SearchPaths, externs: core::Externs,\n+    pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: core::Externs,\n                use_headers: bool, opts: TestOptions) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n+            cfgs: cfgs,\n             libs: libs,\n             externs: externs,\n             cnt: 0,\n@@ -384,6 +388,7 @@ impl Collector {\n             format!(\"{}_{}\", self.names.join(\"::\"), self.cnt)\n         };\n         self.cnt += 1;\n+        let cfgs = self.cfgs.clone();\n         let libs = self.libs.clone();\n         let externs = self.externs.clone();\n         let cratename = self.cratename.to_string();\n@@ -399,6 +404,7 @@ impl Collector {\n             testfn: testing::DynTestFn(Box::new(move|| {\n                 runtest(&test,\n                         &cratename,\n+                        cfgs,\n                         libs,\n                         externs,\n                         should_panic,"}, {"sha": "16764e5af5cce91bc1c66abf9fa56c3f129a54aa", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -79,8 +79,8 @@ pub use self::ParseResult::*;\n use self::TokenTreeOrTokenTreeVec::*;\n \n use ast;\n-use ast::{TokenTree, Name};\n-use codemap::{BytePos, mk_sp, Span};\n+use ast::{TokenTree, Name, Ident};\n+use codemap::{BytePos, mk_sp, Span, Spanned};\n use codemap;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n@@ -526,7 +526,10 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n         \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n         \"ident\" => match p.token {\n-            token::Ident(sn,b) => { panictry!(p.bump()); token::NtIdent(Box::new(sn),b) }\n+            token::Ident(sn,b) => {\n+                panictry!(p.bump());\n+                token::NtIdent(Box::new(Spanned::<Ident>{node: sn, span: p.span}),b)\n+            }\n             _ => {\n                 let token_str = pprust::token_to_string(&p.token);\n                 panic!(p.fatal(&format!(\"expected ident, found {}\","}, {"sha": "ba781ae3cc21275d570b929423158d40abe53cc8", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -293,8 +293,8 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                             // (a) idents can be in lots of places, so it'd be a pain\n                             // (b) we actually can, since it's a token.\n                             MatchedNonterminal(NtIdent(ref sn, b)) => {\n-                                r.cur_span = sp;\n-                                r.cur_tok = token::Ident(**sn, b);\n+                                r.cur_span = sn.span;\n+                                r.cur_tok = token::Ident(sn.node, b);\n                                 return ret_val;\n                             }\n                             MatchedNonterminal(ref other_whole_nt) => {"}, {"sha": "cd976884d2fadc97c31ba7eac31be615f98a2fc8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -663,7 +663,8 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n         token::NtIdent(id, is_mod_name) =>\n-            token::NtIdent(Box::new(fld.fold_ident(*id)), is_mod_name),\n+            token::NtIdent(Box::new(Spanned::<Ident>{node: fld.fold_ident(id.node), .. *id}),\n+                           is_mod_name),\n         token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n         token::NtPath(path) => token::NtPath(Box::new(fld.fold_path(*path))),\n         token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&tt))),"}, {"sha": "b942954c1874af963453d1b81050d3365d0c76ce", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -377,7 +377,7 @@ pub enum Nonterminal {\n     NtPat(P<ast::Pat>),\n     NtExpr(P<ast::Expr>),\n     NtTy(P<ast::Ty>),\n-    NtIdent(Box<ast::Ident>, IdentStyle),\n+    NtIdent(Box<ast::SpannedIdent>, IdentStyle),\n     /// Stuff inside brackets for attributes\n     NtMeta(P<ast::MetaItem>),\n     NtPath(Box<ast::Path>),"}, {"sha": "4e2289cb7f401324d83fb01e62204690a080f2ff", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -295,7 +295,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtBlock(ref e)       => block_to_string(&**e),\n             token::NtStmt(ref e)        => stmt_to_string(&**e),\n             token::NtPat(ref e)         => pat_to_string(&**e),\n-            token::NtIdent(ref e, _)    => ident_to_string(**e),\n+            token::NtIdent(ref e, _)    => ident_to_string(e.node),\n             token::NtTT(ref e)          => tt_to_string(&**e),\n             token::NtArm(ref e)         => arm_to_string(&*e),\n             token::NtImplItem(ref e)    => impl_item_to_string(&**e),"}, {"sha": "3e153a21e5d38c8f0dfe86adcdb706a4420a7ea7", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -23,7 +23,8 @@ fn main() {\n     let ps = syntax::parse::ParseSess::new();\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n-        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()));\n+        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n+        &mut Vec::new());\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "6d68da54112f24da473b778e0780319813873246", "filename": "src/test/compile-fail/associated-types-coherence-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -32,13 +32,13 @@ impl<'a, B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n impl<'a, B: ?Sized> IntoCow<'a, B> for <B as ToOwned>::Owned where B: ToOwned {\n //~^ ERROR E0119\n     fn into_cow(self) -> Cow<'a, B> {\n-        Cow\n+        Cow(PhantomData)\n     }\n }\n \n impl<'a, B: ?Sized> IntoCow<'a, B> for &'a B where B: ToOwned {\n     fn into_cow(self) -> Cow<'a, B> {\n-        Cow\n+        Cow(PhantomData)\n     }\n }\n "}, {"sha": "a1021500be3d7ed959b035c997a1b59e88492644", "filename": "src/test/compile-fail/bogus-tag.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -9,14 +9,12 @@\n // except according to those terms.\n \n \n-// error-pattern: unresolved\n-\n enum color { rgb(isize, isize, isize), rgba(isize, isize, isize, isize), }\n \n fn main() {\n-    let red: color = rgb(255, 0, 0);\n+    let red: color = color::rgb(255, 0, 0);\n     match red {\n-      rgb(r, g, b) => { println!(\"rgb\"); }\n-      hsl(h, s, l) => { println!(\"hsl\"); }\n+      color::rgb(r, g, b) => { println!(\"rgb\"); }\n+      color::hsl(h, s, l) => { println!(\"hsl\"); }  //~ ERROR no associated\n     }\n }"}, {"sha": "b08e4bad1e9c9b127dde7d7b43388b5df7fd9b5b", "filename": "src/test/compile-fail/coherence-impl-trait-for-trait-object-safe.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -13,7 +13,9 @@\n \n // If the trait is not object-safe, we give a more tailored message\n // because we're such schnuckels:\n-trait NotObjectSafe { fn eq(&self, other: Self); }\n-impl NotObjectSafe for NotObjectSafe { } //~ ERROR E0372\n+trait NotObjectSafe { fn eq(&self, other: &Self); }\n+impl NotObjectSafe for NotObjectSafe {  //~ ERROR E0372\n+    fn eq(&self, other: &Self) { panic!(); }\n+}\n \n fn main() { }"}, {"sha": "9c210c132a3131084733aead1eabdf7b34870d8c", "filename": "src/test/compile-fail/coherence-impls-copy.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -28,8 +28,6 @@ impl Copy for MyType {}\n \n impl Copy for &'static mut MyType {}\n //~^ ERROR E0206\n-//~| ERROR E0277\n-//~| ERROR E0277\n impl Clone for MyType { fn clone(&self) -> Self { *self } }\n \n impl Copy for (MyType, MyType) {}\n@@ -42,8 +40,6 @@ impl Copy for &'static NotSync {}\n impl Copy for [MyType] {}\n //~^ ERROR E0206\n //~| ERROR E0117\n-//~| ERROR E0277\n-//~| ERROR E0277\n \n impl Copy for &'static [NotSync] {}\n //~^ ERROR E0206"}, {"sha": "167067cb5fc0aec45ac48d9c282b1f5703875bbb", "filename": "src/test/compile-fail/coherence-impls-sized.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -30,7 +30,6 @@ impl Sized for (MyType, MyType) {} //~ ERROR E0117\n impl Sized for &'static NotSync {} //~ ERROR E0322\n \n impl Sized for [MyType] {} //~ ERROR E0117\n-//~^ ERROR E0277\n \n impl Sized for &'static [NotSync] {} //~ ERROR E0117\n "}, {"sha": "3b0f8ee5bda7ac041e72feadd4105ae706e96766", "filename": "src/test/compile-fail/duplicate-type-parameter.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fduplicate-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fduplicate-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fduplicate-type-parameter.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -33,6 +33,7 @@ trait Qux<T,T> {}\n \n impl<T,T> Qux<T,T> for Option<T> {}\n //~^ ERROR the name `T` is already used\n+//~^^ ERROR the type parameter `T` is not constrained\n \n fn main() {\n }"}, {"sha": "56b681378cc9daf1141d41845dc302ee66d33463", "filename": "src/test/compile-fail/inner-static-type-parameter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -10,7 +10,7 @@\n \n // see #9186\n \n-enum Bar<T> { What }\n+enum Bar<T> { What } //~ ERROR parameter `T` is never used\n \n fn foo<T>() {\n     static a: Bar<T> = Bar::What;"}, {"sha": "33fbdce4ee25a2b50fd3a4474bc31c840ccd7879", "filename": "src/test/compile-fail/issue-12796.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n trait Trait {\n-    fn outer(self) {\n-        fn inner(_: Self) {\n+    fn outer(&self) {\n+        fn inner(_: &Self) {\n             //~^ ERROR can't use type parameters from outer function\n             //~^^ ERROR use of `Self` outside of an impl or trait\n         }"}, {"sha": "5f8ccd0b0634ee22b1c9e313b319a74f2cdedd25", "filename": "src/test/compile-fail/issue-14254.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -11,7 +11,7 @@\n trait Foo {\n     fn bar(&self);\n     fn baz(&self) { }\n-    fn bah(_: Option<Self>) { }\n+    fn bah(_: Option<&Self>) { }\n }\n \n struct BarTy {"}, {"sha": "7ec3093a6e0588533f7d2ee4844d03b7ae60b044", "filename": "src/test/compile-fail/issue-19883.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -14,7 +14,7 @@ trait From<Src> {\n     fn from(src: Src) -> <Self as From<Src>>::Output;\n }\n \n-trait To {\n+trait To: Sized {\n     fn to<Dst: From<Self>>(self) ->\n         <Dst as From<Self>>::Dst\n         //~^ ERROR use of undeclared associated type `From::Dst`"}, {"sha": "99dd22a888cb56508f759f0a2183cfe23354200e", "filename": "src/test/compile-fail/issue-20427.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-20427.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-20427.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20427.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -62,7 +62,7 @@ fn usize<'usize>(usize: &'usize usize) -> &'usize usize { usize }\n fn main() {\n     let bool = true;\n     match bool {\n-        str @ true => if str { i32 as i64 } else { 0 },\n+        str @ true => if str { i32 as i64 } else { i64 },\n         false => i64,\n-    }\n+    };\n }"}, {"sha": "68f053c357bed341e4f2742b046f5288b3888ad0", "filename": "src/test/compile-fail/issue-23305.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-23305.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-23305.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23305.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -13,5 +13,6 @@ pub trait ToNbt<T> {\n }\n \n impl ToNbt<Self> {} //~ ERROR use of `Self` outside of an impl or trait\n+//~^ WARNING the trait `ToNbt` cannot be made into an object\n \n fn main() {}"}, {"sha": "6b81afe13c671d5fca639f058b7c8fdc4ada1e03", "filename": "src/test/compile-fail/issue-2356.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n trait Groom {\n-    fn shave();\n+    fn shave(other: usize);\n }\n \n pub struct cat {\n@@ -30,7 +30,7 @@ impl MaybeDog {\n }\n \n impl Groom for cat {\n-  fn shave(&self, other: usize) {\n+  fn shave(other: usize) {\n     whiskers -= other;\n     //~^ ERROR: unresolved name `whiskers`. Did you mean `self.whiskers`?\n     shave(4);"}, {"sha": "0d372d300154af67727e1e7e9ec102df9896dec1", "filename": "src/test/compile-fail/issue-28109.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-28109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-28109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28109.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -11,10 +11,12 @@\n // Make sure that label for continue and break is spanned correctly\n \n fn main() {\n-    continue\n-    'b //~ ERROR use of undeclared label\n-    ;\n-    break\n-    'c //~ ERROR use of undeclared label\n-    ;\n+    loop {\n+        continue\n+        'b //~ ERROR use of undeclared label\n+        ;\n+        break\n+        'c //~ ERROR use of undeclared label\n+        ;\n+    }\n }"}, {"sha": "ecc8ac34ecf2ba5f45cc5cf2c47805a385eed093", "filename": "src/test/compile-fail/issue-3021-d.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -13,13 +13,13 @@ trait siphash {\n     fn reset(&self);\n }\n \n-fn siphash(k0 : u64, k1 : u64) -> siphash {\n+fn siphash(k0 : u64, k1 : u64) {\n     struct SipState {\n         v0: u64,\n         v1: u64,\n     }\n \n-    fn mk_result(st : SipState) -> u64 {\n+    fn mk_result(st : &SipState) -> u64 {\n \n         let v0 = st.v0;\n         let v1 = st.v1;"}, {"sha": "7cf772b0728795334680a6b3ff01c68e27447623", "filename": "src/test/compile-fail/issue-3021.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -12,7 +12,7 @@ trait SipHash {\n     fn reset(&self);\n }\n \n-fn siphash(k0 : u64) -> SipHash {\n+fn siphash(k0 : u64) {\n     struct SipState {\n         v0: u64,\n     }"}, {"sha": "27b7fb752750347690c63ac7189b8245a7b54db7", "filename": "src/test/compile-fail/issue-3214.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -15,6 +15,8 @@ fn foo<T>() {\n     }\n \n     impl<T> Drop for foo<T> {\n+        //~^ ERROR wrong number of type arguments\n+        //~^^ ERROR the type parameter `T` is not constrained\n         fn drop(&mut self) {}\n     }\n }"}, {"sha": "34cd8cae2de32a64a3255c45b05354428b7c5910", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -16,6 +16,7 @@ fn main() {\n         Bar = foo\n         //~^ ERROR attempt to use a non-constant value in a constant\n         //~| ERROR unresolved name `foo`\n+        //~^^^ ERROR constant evaluation error: non-constant path in constant expression\n     }\n \n     println!(\"{}\", Stuff::Bar);"}, {"sha": "1fda423e9ee8d37ab30f2bafef90a2312ededdcd", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -30,5 +30,7 @@ impl ToString_ for Point {\n \n fn main() {\n     let p = Point::new(0.0, 0.0);\n+    //~^ ERROR no associated item named `new` found for type `Point` in the current scope\n     println!(\"{}\", p.to_string());\n+    //~^ ERROR the type of this value must be known in this context\n }"}, {"sha": "e5f091d873df9c1384207472e4f6061713bf5152", "filename": "src/test/compile-fail/issue-5927.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -9,12 +9,10 @@\n // except according to those terms.\n \n \n-\n-// error-pattern:unresolved enum variant\n-\n fn main() {\n     let z = match 3 {\n-        x(1) => x(1)\n+        x(1) => x(1) //~ ERROR unresolved enum variant\n+        //~^ ERROR unresolved name `x`\n     };\n-    assert_eq!(z,3);\n+    assert!(z == 3);\n }"}, {"sha": "f53122d19c1bd8bc25912ca75332e2a943bc7f2d", "filename": "src/test/compile-fail/issue-9725.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-9725.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fissue-9725.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-9725.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -13,4 +13,5 @@ struct A { foo: isize }\n fn main() {\n     let A { foo, foo } = A { foo: 3 };\n     //~^ ERROR: identifier `foo` is bound more than once in the same pattern\n+    //~^^ ERROR: field `foo` bound multiple times\n }"}, {"sha": "2ef697591284dc2ddbabd227de841355840bde61", "filename": "src/test/compile-fail/macro-parameter-span.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fmacro-parameter-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fmacro-parameter-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-parameter-span.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! foo {\n+    ($id: ident) => {\n+        $id\n+    }\n+}\n+\n+// Testing that the error span points to the parameter 'x' in the callsite,\n+// not to the macro variable '$id'\n+fn main() {\n+    foo!(\n+        x //~ ERROR unresolved name `x`\n+        );\n+}"}, {"sha": "f8ea5dda183366df38ecfa9544f08d21d4406a97", "filename": "src/test/compile-fail/mod_file_correct_spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -13,5 +13,5 @@\n mod mod_file_aux;\n \n fn main() {\n-    assert_eq!(mod_file_aux::bar(), 10); //~ ERROR unresolved name\n+    assert!(mod_file_aux::bar() == 10); //~ ERROR unresolved name\n }"}, {"sha": "bc18b52a0c1c9e3f8fdfd0f65994e4e2e0daf464", "filename": "src/test/compile-fail/opt-in-copy.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fopt-in-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fopt-in-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fopt-in-copy.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -16,7 +16,6 @@ struct IWantToCopyThis {\n \n impl Copy for IWantToCopyThis {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n-//~| ERROR E0277\n \n enum CantCopyThisEither {\n     A,\n@@ -29,6 +28,5 @@ enum IWantToCopyThisToo {\n \n impl Copy for IWantToCopyThisToo {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n-//~| ERROR E0277\n \n fn main() {}"}, {"sha": "284c08ef09b28fa4c475ab575af71d706fce72db", "filename": "src/test/compile-fail/resolve-inconsistent-binding-mode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -16,6 +16,7 @@ fn matcher1(x: opts) {\n     match x {\n       opts::a(ref i) | opts::b(i) => {}\n       //~^ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      //~^^ ERROR mismatched types\n       opts::c(_) => {}\n     }\n }\n@@ -24,6 +25,7 @@ fn matcher2(x: opts) {\n     match x {\n       opts::a(ref i) | opts::b(i) => {}\n       //~^ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      //~^^ ERROR mismatched types\n       opts::c(_) => {}\n     }\n }\n@@ -32,6 +34,7 @@ fn matcher4(x: opts) {\n     match x {\n       opts::a(ref mut i) | opts::b(ref i) => {}\n       //~^ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      //~^^ ERROR mismatched types\n       opts::c(_) => {}\n     }\n }"}, {"sha": "88f09233d107ee07f5f9079220fd2dcaef924ebe", "filename": "src/test/compile-fail/resolve-type-param-in-item-in-trait.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -15,6 +15,7 @@\n trait TraitA<A> {\n     fn outer(self) {\n         enum Foo<B> {\n+            //~^ ERROR parameter `B` is never used\n             Variance(A)\n                 //~^ ERROR can't use type parameters from outer function\n                 //~^^ ERROR use of undeclared type name `A`\n@@ -27,6 +28,7 @@ trait TraitB<A> {\n         struct Foo<B>(A);\n                 //~^ ERROR can't use type parameters from outer function\n                 //~^^ ERROR use of undeclared type name `A`\n+                //~^^^ ERROR parameter `B` is never used\n     }\n }\n \n@@ -35,6 +37,7 @@ trait TraitC<A> {\n         struct Foo<B> { a: A }\n                 //~^ ERROR can't use type parameters from outer function\n                 //~^^ ERROR use of undeclared type name `A`\n+                //~^^^ ERROR parameter `B` is never used\n     }\n }\n "}, {"sha": "38a6834a9c46034772d41ffd94c7bebd76cabac3", "filename": "src/test/compile-fail/syntax-extension-minor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -14,7 +14,7 @@\n \n pub fn main() {\n     let asdf_fdsa = \"<.<\".to_string();\n-    assert_eq!(concat_idents!(asd, f_f, dsa), \"<.<\".to_string());\n+    assert!(concat_idents!(asd, f_f, dsa) == \"<.<\".to_string());\n     //~^ ERROR: unresolved name `asdf_fdsa`\n \n     assert_eq!(stringify!(use_mention_distinction), \"use_mention_distinction\");"}, {"sha": "f30c8f521bdc75b919c2dccbbeefa1c8d5cf8853", "filename": "src/test/compile-fail/trait-safety-trait-impl-cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl-cc.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -18,7 +18,7 @@ extern crate trait_safety_lib as lib;\n struct Bar;\n impl lib::Foo for Bar { //~ ERROR requires an `unsafe impl` declaration\n     fn foo(&self) -> isize {\n-        *self as isize\n+        panic!();\n     }\n }\n "}, {"sha": "e846b660c2a175f3380f5621feb580ecbe066bce", "filename": "src/test/compile-fail/trait-safety-trait-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-safety-trait-impl.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -12,11 +12,11 @@\n // impls cannot be unsafe.\n \n trait SafeTrait {\n-    fn foo(self) { }\n+    fn foo(&self) { }\n }\n \n unsafe trait UnsafeTrait {\n-    fn foo(self) { }\n+    fn foo(&self) { }\n }\n \n unsafe impl UnsafeTrait for u8 { } // OK"}, {"sha": "11d161fe188e962dd092d48ace6ca1b084b4050c", "filename": "src/test/rustdoc/issue-30252.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Frustdoc%2Fissue-30252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785a8a6681963ff389b5902e7d6bd30006fafe0a/src%2Ftest%2Frustdoc%2Fissue-30252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-30252.rs?ref=785a8a6681963ff389b5902e7d6bd30006fafe0a", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test --cfg feature=\"bar\"\n+\n+/// ```rust\n+/// assert_eq!(cfg!(feature = \"bar\"), true);\n+/// ```\n+pub fn foo() {}"}]}