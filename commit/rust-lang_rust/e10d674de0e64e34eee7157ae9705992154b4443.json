{"sha": "e10d674de0e64e34eee7157ae9705992154b4443", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMGQ2NzRkZTBlNjRlMzRlZWU3MTU3YWU5NzA1OTkyMTU0YjQ0NDM=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-26T01:33:10Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-26T01:33:10Z"}, "message": "librustc: Use dereferenceable attribute instead of nonnull where we can.", "tree": {"sha": "bd7f1a7e6d2caf348534039937893c862b095fad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd7f1a7e6d2caf348534039937893c862b095fad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e10d674de0e64e34eee7157ae9705992154b4443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e10d674de0e64e34eee7157ae9705992154b4443", "html_url": "https://github.com/rust-lang/rust/commit/e10d674de0e64e34eee7157ae9705992154b4443", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e10d674de0e64e34eee7157ae9705992154b4443/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17256197a963561d02faff0634e11d7a079e7105", "url": "https://api.github.com/repos/rust-lang/rust/commits/17256197a963561d02faff0634e11d7a079e7105", "html_url": "https://github.com/rust-lang/rust/commit/17256197a963561d02faff0634e11d7a079e7105"}], "stats": {"total": 70, "additions": 55, "deletions": 15}, "files": [{"sha": "5433923441a7b912b1c4a30d5cb09bf0a267afe0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e10d674de0e64e34eee7157ae9705992154b4443/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10d674de0e64e34eee7157ae9705992154b4443/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e10d674de0e64e34eee7157ae9705992154b4443", "patch": "@@ -2070,12 +2070,15 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n     // implications directly to the call instruction. Right now,\n     // the only attribute we need to worry about is `sret`.\n     if type_of::return_uses_outptr(ccx, ret_ty) {\n+        let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, ret_ty));\n+\n         // The outptr can be noalias and nocapture because it's entirely\n-        // invisible to the program. We can also mark it as nonnull\n+        // invisible to the program. We also know it's nonnull as well\n+        // as how many bytes we can dereference\n         attrs.arg(1, llvm::StructRetAttribute)\n              .arg(1, llvm::NoAliasAttribute)\n              .arg(1, llvm::NoCaptureAttribute)\n-             .arg(1, llvm::NonNullAttribute);\n+             .arg(1, llvm::DereferenceableAttribute(llret_sz));\n \n         // Add one more since there's an outptr\n         first_arg_offset += 1;\n@@ -2094,15 +2097,16 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n             _ => {}\n         }\n \n-        // We can also mark the return value as `nonnull` in certain cases\n+        // We can also mark the return value as `dereferenceable` in certain cases\n         match ty::get(ret_ty).sty {\n             // These are not really pointers but pairs, (pointer, len)\n             ty::ty_uniq(it) |\n             ty::ty_rptr(_, ty::mt { ty: it, .. }) if match ty::get(it).sty {\n                 ty::ty_str | ty::ty_vec(..) | ty::ty_trait(..) => true, _ => false\n             } => {}\n-            ty::ty_uniq(_) | ty::ty_rptr(_, _) => {\n-                attrs.ret(llvm::NonNullAttribute);\n+            ty::ty_uniq(inner) | ty::ty_rptr(_, ty::mt { ty: inner, .. }) => {\n+                let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n+                attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n             }\n             _ => {}\n         }\n@@ -2119,44 +2123,77 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         match ty::get(t).sty {\n             // this needs to be first to prevent fat pointers from falling through\n             _ if !type_is_immediate(ccx, t) => {\n+                let llarg_sz = llsize_of_real(ccx, type_of::type_of(ccx, t));\n+\n                 // For non-immediate arguments the callee gets its own copy of\n                 // the value on the stack, so there are no aliases. It's also\n                 // program-invisible so can't possibly capture\n                 attrs.arg(idx, llvm::NoAliasAttribute)\n                      .arg(idx, llvm::NoCaptureAttribute)\n-                     .arg(idx, llvm::NonNullAttribute);\n+                     .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n             }\n+\n             ty::ty_bool => {\n                 attrs.arg(idx, llvm::ZExtAttribute);\n             }\n+\n             // `~` pointer parameters never alias because ownership is transferred\n-            ty::ty_uniq(_) => {\n+            ty::ty_uniq(inner) => {\n+                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n+\n+                attrs.arg(idx, llvm::NoAliasAttribute)\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n+            }\n+\n+            // The visit glue deals only with opaque pointers so we don't\n+            // actually know the concrete type of Self thus we don't know how\n+            // many bytes to mark as dereferenceable so instead we just mark\n+            // it as nonnull which still holds true\n+            ty::ty_rptr(b, ty::mt { ty: it, mutbl }) if match ty::get(it).sty {\n+                ty::ty_param(_) => true, _ => false\n+            } && mutbl == ast::MutMutable => {\n                 attrs.arg(idx, llvm::NoAliasAttribute)\n                      .arg(idx, llvm::NonNullAttribute);\n+\n+                match b {\n+                    ReLateBound(_, BrAnon(_)) => {\n+                        attrs.arg(idx, llvm::NoCaptureAttribute);\n+                    }\n+                    _ => {}\n+                }\n             }\n+\n             // `&mut` pointer parameters never alias other parameters, or mutable global data\n             // `&` pointer parameters never alias either (for LLVM's purposes) as long as the\n             // interior is safe\n             ty::ty_rptr(b, mt) if mt.mutbl == ast::MutMutable ||\n                                   !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n+\n+                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n                 attrs.arg(idx, llvm::NoAliasAttribute)\n-                     .arg(idx, llvm::NonNullAttribute);\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n+\n                 match b {\n                     ReLateBound(_, BrAnon(_)) => {\n                         attrs.arg(idx, llvm::NoCaptureAttribute);\n                     }\n                     _ => {}\n                 }\n             }\n+\n             // When a reference in an argument has no named lifetime, it's impossible for that\n             // reference to escape this function (returned or stored beyond the call by a closure).\n-            ty::ty_rptr(ReLateBound(_, BrAnon(_)), _) => {\n+            ty::ty_rptr(ReLateBound(_, BrAnon(_)), mt) => {\n+                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n                 attrs.arg(idx, llvm::NoCaptureAttribute)\n-                     .arg(idx, llvm::NonNullAttribute);\n+                     .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n-            // & pointer parameters are never null\n-            ty::ty_rptr(_, _) => {\n-                attrs.arg(idx, llvm::NonNullAttribute);\n+\n+            // & pointer parameters are also never null and we know exactly how\n+            // many bytes we can dereference\n+            ty::ty_rptr(_, mt) => {\n+                let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n+                attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n             _ => ()\n         }"}, {"sha": "f305ae90d46af69f9ed01dfe2a4de098257eccd3", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e10d674de0e64e34eee7157ae9705992154b4443/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e10d674de0e64e34eee7157ae9705992154b4443/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=e10d674de0e64e34eee7157ae9705992154b4443", "patch": "@@ -386,11 +386,14 @@ pub fn trans_native_call<'a>(\n \n     // Add attributes that are always applicable, independent of the concrete foreign ABI\n     if fn_type.ret_ty.is_indirect() {\n+        let llret_sz = machine::llsize_of_real(ccx, fn_type.ret_ty.ty);\n+\n         // The outptr can be noalias and nocapture because it's entirely\n-        // invisible to the program. We can also mark it as nonnull\n+        // invisible to the program. We also know it's nonnull as well\n+        // as how many bytes we can dereference\n         attrs.arg(1, llvm::NoAliasAttribute)\n              .arg(1, llvm::NoCaptureAttribute)\n-             .arg(1, llvm::NonNullAttribute);\n+             .arg(1, llvm::DereferenceableAttribute(llret_sz));\n     };\n \n     // Add attributes that depend on the concrete foreign ABI"}]}