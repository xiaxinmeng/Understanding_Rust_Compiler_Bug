{"sha": "65e337cdf3e9a54dbabcdb92aebdfb79b5660e24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZTMzN2NkZjNlOWE1NGRiYWJjZGI5MmFlYmRmYjc5YjU2NjBlMjQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-20T15:57:00Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-26T09:29:35Z"}, "message": "Implement 128bit multiply with overflow", "tree": {"sha": "6697b3ac7c90f56af6ca4b4cbbface7054716348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6697b3ac7c90f56af6ca4b4cbbface7054716348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65e337cdf3e9a54dbabcdb92aebdfb79b5660e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65e337cdf3e9a54dbabcdb92aebdfb79b5660e24", "html_url": "https://github.com/rust-lang/rust/commit/65e337cdf3e9a54dbabcdb92aebdfb79b5660e24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65e337cdf3e9a54dbabcdb92aebdfb79b5660e24/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88ad25f45e9adbf08871ce77449e1b1193d23df4", "url": "https://api.github.com/repos/rust-lang/rust/commits/88ad25f45e9adbf08871ce77449e1b1193d23df4", "html_url": "https://github.com/rust-lang/rust/commit/88ad25f45e9adbf08871ce77449e1b1193d23df4"}], "stats": {"total": 90, "additions": 34, "deletions": 56}, "files": [{"sha": "9e9a7a67e05e6c5e5ea3d5726ec43fd123d1991d", "filename": "example/std_example.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/65e337cdf3e9a54dbabcdb92aebdfb79b5660e24/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e337cdf3e9a54dbabcdb92aebdfb79b5660e24/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=65e337cdf3e9a54dbabcdb92aebdfb79b5660e24", "patch": "@@ -22,4 +22,9 @@ fn main() {\n     checked_div_i128(0i128, 2i128);\n     checked_div_u128(0u128, 2u128);\n     assert_eq!(1u128 + 2, 3);\n+\n+    println!(\"{}\", 0b100010000000000000000000000000000u128 >> 10);\n+    println!(\"{}\", 0xFEDCBA987654321123456789ABCDEFu128 >> 64);\n+    println!(\"{} >> 64 == {}\", 0xFEDCBA987654321123456789ABCDEFu128 as i128, 0xFEDCBA987654321123456789ABCDEFu128 as i128 >> 64);\n+    println!(\"{}\", 353985398u128 * 932490u128);\n }"}, {"sha": "b884d80b3944e82eaebdb70937145b7104e73ba3", "filename": "src/abi.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/65e337cdf3e9a54dbabcdb92aebdfb79b5660e24/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e337cdf3e9a54dbabcdb92aebdfb79b5660e24/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=65e337cdf3e9a54dbabcdb92aebdfb79b5660e24", "patch": "@@ -252,14 +252,12 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n         &mut self,\n         name: &str,\n         input_tys: Vec<types::Type>,\n-        output_ty: Option<types::Type>,\n+        output_tys: Vec<types::Type>,\n         args: &[Value],\n-    ) -> Option<Value> {\n+    ) -> &[Value] {\n         let sig = Signature {\n             params: input_tys.iter().cloned().map(AbiParam::new).collect(),\n-            returns: output_ty\n-                .map(|output_ty| vec![AbiParam::new(output_ty)])\n-                .unwrap_or(Vec::new()),\n+            returns: output_tys.iter().cloned().map(AbiParam::new).collect(),\n             call_conv: CallConv::SystemV,\n         };\n         let func_id = self\n@@ -271,12 +269,9 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n             .declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         self.add_comment(call_inst, format!(\"easy_call {}\", name));\n-        if output_ty.is_none() {\n-            return None;\n-        }\n         let results = self.bcx.inst_results(call_inst);\n-        assert_eq!(results.len(), 1);\n-        Some(results[0])\n+        assert!(results.len() <= 2, \"{}\", results.len());\n+        results\n     }\n \n     pub fn easy_call(\n@@ -295,23 +290,22 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n             })\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n-        let return_ty = if let ty::Tuple(tup) = return_ty.sty {\n-            if !tup.is_empty() {\n-                bug!(\"easy_call( (...) -> <non empty tuple> ) is not allowed\");\n-            }\n-            None\n+        let return_tys = if let ty::Tuple(tup) = return_ty.sty {\n+            tup.types().map(|ty| self.clif_type(ty).unwrap()).collect()\n         } else {\n-            Some(self.clif_type(return_ty).unwrap())\n+            vec![self.clif_type(return_ty).unwrap()]\n         };\n-        if let Some(val) = self.lib_call(name, input_tys, return_ty, &args) {\n-            CValue::by_val(val, return_layout)\n-        } else {\n-            CValue::by_ref(\n+        let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n+        match *ret_vals {\n+            [] => CValue::by_ref(\n                 self.bcx\n                     .ins()\n                     .iconst(self.pointer_type, self.pointer_type.bytes() as i64),\n                 return_layout,\n-            )\n+            ),\n+            [val] => CValue::by_val(val, return_layout),\n+            [val, extra] => CValue::by_val_pair(val, extra, return_layout),\n+            _ => unreachable!(),\n         }\n     }\n "}, {"sha": "b5e2bb6b3c96232b1df8cb41597d3c24bb12c030", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 14, "deletions": 35, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/65e337cdf3e9a54dbabcdb92aebdfb79b5660e24/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e337cdf3e9a54dbabcdb92aebdfb79b5660e24/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=65e337cdf3e9a54dbabcdb92aebdfb79b5660e24", "patch": "@@ -30,19 +30,9 @@ pub fn maybe_codegen<'a, 'tcx>(\n         BinOp::Mul => {\n             let res = if checked {\n                 if is_signed {\n-                    let oflow_place = CPlace::new_stack_slot(fx, fx.tcx.types.i32);\n-                    let oflow_addr = oflow_place.to_addr(fx);\n-                    let oflow_addr = CValue::by_val(oflow_addr, fx.layout_of(fx.tcx.mk_mut_ptr(fx.tcx.types.i32)));\n-                    let val = fx.easy_call(\"__muloti4\", &[lhs, rhs, oflow_addr], fx.tcx.types.i128);\n-                    let val = val.load_scalar(fx);\n-                    let oflow = oflow_place.to_cvalue(fx).load_scalar(fx);\n-                    let oflow = fx.bcx.ins().icmp_imm(IntCC::NotEqual, oflow, 0);\n-                    let oflow = fx.bcx.ins().bint(types::I8, oflow);\n-                    CValue::by_val_pair(val, oflow, fx.layout_of(out_ty))\n+                    fx.easy_call(\"__rust_i128_mulo\", &[lhs, rhs], out_ty)\n                 } else {\n-                    // FIXME implement it\n-                let out_layout = fx.layout_of(out_ty);\n-                    return Some(crate::trap::trap_unreachable_ret_value(fx, out_layout, format!(\"unimplemented 128bit checked binop unsigned mul\")));\n+                    fx.easy_call(\"__rust_u128_mulo\", &[lhs, rhs], out_ty)\n                 }\n             } else {\n                 let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n@@ -51,32 +41,20 @@ pub fn maybe_codegen<'a, 'tcx>(\n             return Some(res);\n         }\n         BinOp::Div => {\n-            let res = if checked {\n-                // FIXME implement it\n-                let out_layout = fx.layout_of(out_ty);\n-                return Some(crate::trap::trap_unreachable_ret_value(fx, out_layout, format!(\"unimplemented 128bit checked binop div\")));\n+            assert!(!checked);\n+            if is_signed {\n+                Some(fx.easy_call(\"__divti3\", &[lhs, rhs], fx.tcx.types.i128))\n             } else {\n-                if is_signed {\n-                    fx.easy_call(\"__divti3\", &[lhs, rhs], fx.tcx.types.i128)\n-                } else {\n-                    fx.easy_call(\"__udivti3\", &[lhs, rhs], fx.tcx.types.u128)\n-                }\n-            };\n-            return Some(res);\n+                Some(fx.easy_call(\"__udivti3\", &[lhs, rhs], fx.tcx.types.u128))\n+            }\n         }\n         BinOp::Rem => {\n-            let res = if checked {\n-                // FIXME implement it\n-                let out_layout = fx.layout_of(out_ty);\n-                return Some(crate::trap::trap_unreachable_ret_value(fx, out_layout, format!(\"unimplemented 128bit checked binop rem\")));\n+            assert!(!checked);\n+            if is_signed {\n+                Some(fx.easy_call(\"__modti3\", &[lhs, rhs], fx.tcx.types.i128))\n             } else {\n-                if is_signed {\n-                    fx.easy_call(\"__modti3\", &[lhs, rhs], fx.tcx.types.i128)\n-                } else {\n-                    fx.easy_call(\"__umodti3\", &[lhs, rhs], fx.tcx.types.u128)\n-                }\n-            };\n-            return Some(res);\n+                Some(fx.easy_call(\"__umodti3\", &[lhs, rhs], fx.tcx.types.u128))\n+            }\n         }\n         BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {\n             assert!(!checked);\n@@ -140,8 +118,9 @@ pub fn maybe_codegen<'a, 'tcx>(\n                         Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.i128)))\n                     }\n                     (BinOp::Shl, _) => {\n+                        let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n                         let val = fx.bcx.ins().iconcat(all_zeros, lhs_lsb);\n-                        Some(CValue::by_val(val, fx.layout_of(out_ty)))\n+                        Some(CValue::by_val(val, fx.layout_of(val_ty)))\n                     }\n                     _ => None\n                 };"}]}