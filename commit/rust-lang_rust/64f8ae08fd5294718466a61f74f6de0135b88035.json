{"sha": "64f8ae08fd5294718466a61f74f6de0135b88035", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZjhhZTA4ZmQ1Mjk0NzE4NDY2YTYxZjc0ZjZkZTAxMzViODgwMzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-03T09:08:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-03T09:08:58Z"}, "message": "Auto merge of #51889 - spastorino:make-causal-tracking-lazy, r=nikomatsakis\n\nMake causal tracking lazy\n\nCloses #51710\n\nr? @nikomatsakis", "tree": {"sha": "1016739eb90e36c137299f9411df19891aeefbb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1016739eb90e36c137299f9411df19891aeefbb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64f8ae08fd5294718466a61f74f6de0135b88035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64f8ae08fd5294718466a61f74f6de0135b88035", "html_url": "https://github.com/rust-lang/rust/commit/64f8ae08fd5294718466a61f74f6de0135b88035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64f8ae08fd5294718466a61f74f6de0135b88035/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fa9bfeb154e18b6a9caaabd1494fddea9d0d63a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa9bfeb154e18b6a9caaabd1494fddea9d0d63a", "html_url": "https://github.com/rust-lang/rust/commit/8fa9bfeb154e18b6a9caaabd1494fddea9d0d63a"}, {"sha": "71f25b408de9da1fb8f6faec4fa833068f17978d", "url": "https://api.github.com/repos/rust-lang/rust/commits/71f25b408de9da1fb8f6faec4fa833068f17978d", "html_url": "https://github.com/rust-lang/rust/commit/71f25b408de9da1fb8f6faec4fa833068f17978d"}], "stats": {"total": 773, "additions": 336, "deletions": 437}, "files": [{"sha": "dca0d4f442a4cbf0971e759cc30fdddfdc7c69a7", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -1000,6 +1000,10 @@ impl<'tcx> Terminator<'tcx> {\n         self.kind.successors_mut()\n     }\n \n+    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n+        self.kind.unwind()\n+    }\n+\n     pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n         self.kind.unwind_mut()\n     }\n@@ -1195,6 +1199,31 @@ impl<'tcx> TerminatorKind<'tcx> {\n         }\n     }\n \n+    pub fn unwind(&self) -> Option<&Option<BasicBlock>> {\n+        match *self {\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::FalseEdges { .. } => None,\n+            TerminatorKind::Call {\n+                cleanup: ref unwind,\n+                ..\n+            }\n+            | TerminatorKind::Assert {\n+                cleanup: ref unwind,\n+                ..\n+            }\n+            | TerminatorKind::DropAndReplace { ref unwind, .. }\n+            | TerminatorKind::Drop { ref unwind, .. }\n+            | TerminatorKind::FalseUnwind { ref unwind, .. } => Some(unwind),\n+        }\n+    }\n+\n     pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n         match *self {\n             TerminatorKind::Goto { .. }"}, {"sha": "25a0123755f2c586e540d18fd7bbecf34f1f388d", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -12,7 +12,7 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::type_check::AtLocation;\n use rustc::hir;\n use rustc::infer::InferCtxt;\n@@ -33,7 +33,7 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n-    liveness_set_from_typeck: &[(ty::Region<'tcx>, Location, Cause)],\n+    liveness_set_from_typeck: &[(ty::Region<'tcx>, Location)],\n ) {\n     let mut cg = ConstraintGeneration {\n         borrow_set,\n@@ -69,14 +69,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// We sometimes have `substs` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_substs(&mut self, substs: &&'tcx Substs<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location, Cause::LiveOther(location));\n+        self.add_regular_live_constraint(*substs, location);\n         self.super_substs(substs);\n     }\n \n     /// We sometimes have `region` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_region(&mut self, region: &ty::Region<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*region, location, Cause::LiveOther(location));\n+        self.add_regular_live_constraint(*region, location);\n         self.super_region(region);\n     }\n \n@@ -94,7 +94,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n                 );\n             }\n             TyContext::Location(location) => {\n-                self.add_regular_live_constraint(*ty, location, Cause::LiveOther(location));\n+                self.add_regular_live_constraint(*ty, location);\n             }\n         }\n \n@@ -104,14 +104,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// We sometimes have `generator_substs` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_generator_substs(&mut self, substs: &GeneratorSubsts<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location, Cause::LiveOther(location));\n+        self.add_regular_live_constraint(*substs, location);\n         self.super_generator_substs(substs);\n     }\n \n     /// We sometimes have `closure_substs` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_closure_substs(&mut self, substs: &ClosureSubsts<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location, Cause::LiveOther(location));\n+        self.add_regular_live_constraint(*substs, location);\n         self.super_closure_substs(substs);\n     }\n \n@@ -233,7 +233,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     /// that we also have to respect.\n     fn add_region_liveness_constraints_from_type_check(\n         &mut self,\n-        liveness_set: &[(ty::Region<'tcx>, Location, Cause)],\n+        liveness_set: &[(ty::Region<'tcx>, Location)],\n     ) {\n         debug!(\n             \"add_region_liveness_constraints_from_type_check(liveness_set={} items)\",\n@@ -247,16 +247,16 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             ..\n         } = self;\n \n-        for (region, location, cause) in liveness_set {\n+        for (region, location) in liveness_set {\n             debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n             let region_vid = regioncx.to_region_vid(region);\n-            regioncx.add_live_point(region_vid, *location, &cause);\n+            regioncx.add_live_point(region_vid, *location);\n         }\n \n         if let Some(all_facts) = all_facts {\n             all_facts\n                 .region_live_at\n-                .extend(liveness_set.into_iter().flat_map(|(region, location, _)| {\n+                .extend(liveness_set.into_iter().flat_map(|(region, location)| {\n                     let r = regioncx.to_region_vid(region);\n                     let p1 = location_table.start_index(*location);\n                     let p2 = location_table.mid_index(*location);\n@@ -269,7 +269,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at\n     /// `location`.\n-    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location, cause: Cause)\n+    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -282,7 +282,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             .tcx\n             .for_each_free_region(&live_ty, |live_region| {\n                 let vid = live_region.to_region_vid();\n-                self.regioncx.add_live_point(vid, location, &cause);\n+                self.regioncx.add_live_point(vid, location);\n             });\n     }\n "}, {"sha": "a65019690e3077488bf9c341721fafac2d0c943b", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -0,0 +1,168 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::VecDeque;\n+use std::rc::Rc;\n+\n+use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n+use borrow_check::nll::ToRegionVid;\n+use rustc::mir::visit::{MirVisitable, PlaceContext, Visitor};\n+use rustc::mir::{Local, Location, Mir};\n+use rustc::ty::{RegionVid, TyCtxt};\n+use rustc_data_structures::fx::FxHashSet;\n+use util::liveness::{self, DefUse, LivenessMode};\n+\n+crate fn find<'cx, 'gcx: 'tcx, 'tcx: 'cx>(\n+    mir: &'cx Mir<'tcx>,\n+    regioncx: &'cx Rc<RegionInferenceContext<'tcx>>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    region_vid: RegionVid,\n+    start_point: Location,\n+) -> Option<Cause> {\n+    let mut uf = UseFinder {\n+        mir,\n+        regioncx,\n+        tcx,\n+        region_vid,\n+        start_point,\n+        liveness_mode: LivenessMode {\n+            include_regular_use: true,\n+            include_drops: true,\n+        },\n+    };\n+\n+    uf.find()\n+}\n+\n+struct UseFinder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    mir: &'cx Mir<'tcx>,\n+    regioncx: &'cx Rc<RegionInferenceContext<'tcx>>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    region_vid: RegionVid,\n+    start_point: Location,\n+    liveness_mode: LivenessMode,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n+    fn find(&mut self) -> Option<Cause> {\n+        let mut queue = VecDeque::new();\n+        let mut visited = FxHashSet();\n+\n+        queue.push_back(self.start_point);\n+        while let Some(p) = queue.pop_front() {\n+            if !self.regioncx.region_contains_point(self.region_vid, p) {\n+                continue;\n+            }\n+\n+            if !visited.insert(p) {\n+                continue;\n+            }\n+\n+            let block_data = &self.mir[p.block];\n+\n+            match self.def_use(p, block_data.visitable(p.statement_index)) {\n+                Some(DefUseResult::Def) => {}\n+\n+                Some(DefUseResult::UseLive { local }) => {\n+                    return Some(Cause::LiveVar(local, p));\n+                }\n+\n+                Some(DefUseResult::UseDrop { local }) => {\n+                    return Some(Cause::DropVar(local, p));\n+                }\n+\n+                None => {\n+                    if p.statement_index < block_data.statements.len() {\n+                        queue.push_back(Location {\n+                            statement_index: p.statement_index + 1,\n+                            ..p\n+                        });\n+                    } else {\n+                        queue.extend(\n+                            block_data\n+                                .terminator()\n+                                .successors()\n+                                .filter(|&bb| Some(&Some(*bb)) != block_data.terminator().unwind())\n+                                .map(|&bb| Location {\n+                                    statement_index: 0,\n+                                    block: bb,\n+                                }),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn def_use(&self, location: Location, thing: &dyn MirVisitable<'tcx>) -> Option<DefUseResult> {\n+        let mut visitor = DefUseVisitor {\n+            mir: self.mir,\n+            tcx: self.tcx,\n+            region_vid: self.region_vid,\n+            liveness_mode: self.liveness_mode,\n+            def_use_result: None,\n+        };\n+\n+        thing.apply(location, &mut visitor);\n+\n+        visitor.def_use_result\n+    }\n+}\n+\n+struct DefUseVisitor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    mir: &'cx Mir<'tcx>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    region_vid: RegionVid,\n+    liveness_mode: LivenessMode,\n+    def_use_result: Option<DefUseResult>,\n+}\n+\n+enum DefUseResult {\n+    Def,\n+\n+    UseLive { local: Local },\n+\n+    UseDrop { local: Local },\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for DefUseVisitor<'cx, 'gcx, 'tcx> {\n+    fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n+        let local_ty = self.mir.local_decls[local].ty;\n+\n+        let mut found_it = false;\n+        self.tcx.for_each_free_region(&local_ty, |r| {\n+            if r.to_region_vid() == self.region_vid {\n+                found_it = true;\n+            }\n+        });\n+\n+        if found_it {\n+            match liveness::categorize(context, self.liveness_mode) {\n+                Some(DefUse::Def) => {\n+                    self.def_use_result = Some(DefUseResult::Def);\n+                }\n+\n+                Some(DefUse::Use) => {\n+                    self.def_use_result = if context.is_drop() {\n+                        Some(DefUseResult::UseDrop { local })\n+                    } else {\n+                        Some(DefUseResult::UseLive { local })\n+                    };\n+                }\n+\n+                None => {\n+                    self.def_use_result = None;\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "bc4646b7c789a1724cdc51d0e89589a9cf2c8d0c", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 57, "deletions": 199, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -9,13 +9,12 @@\n // except according to those terms.\n \n use borrow_check::borrow_set::BorrowData;\n-use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n+use borrow_check::nll::region_infer::Cause;\n use borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n-use rustc::mir::visit::{MirVisitable, PlaceContext, Visitor};\n-use rustc::mir::{Local, Location, Mir, Place};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc::mir::Place;\n use rustc_errors::DiagnosticBuilder;\n-use util::liveness::{self, DefUse, LivenessMode};\n+\n+mod find_use;\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Adds annotations to `err` explaining *why* the borrow contains the\n@@ -39,214 +38,73 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n-        let regioncx = &&self.nonlexical_regioncx;\n+        debug!(\n+            \"explain_why_borrow_contains_point(context={:?}, borrow={:?}, kind_place={:?})\",\n+            context, borrow, kind_place,\n+        );\n+\n+        let regioncx = &self.nonlexical_regioncx;\n         let mir = self.mir;\n+        let tcx = self.tcx;\n \n         let borrow_region_vid = regioncx.to_region_vid(borrow.region);\n-        if let Some(cause) = regioncx.why_region_contains_point(borrow_region_vid, context.loc) {\n-            match cause {\n-                Cause::LiveVar(local, location) => match find_regular_use(\n-                    mir, regioncx, borrow, location, local,\n-                ) {\n-                    Some(p) => {\n-                        err.span_label(mir.source_info(p).span, format!(\"borrow later used here\"));\n-                    }\n \n-                    None => {\n-                        span_bug!(\n-                            mir.source_info(context.loc).span,\n-                            \"Cause should end in a LiveVar\"\n-                        );\n-                    }\n-                },\n+        debug!(\n+            \"explain_why_borrow_contains_point: borrow_region_vid={:?}\",\n+            borrow_region_vid\n+        );\n \n-                Cause::DropVar(local, location) => match find_drop_use(\n-                    mir, regioncx, borrow, location, local,\n-                ) {\n-                    Some(p) => match &mir.local_decls[local].name {\n-                        Some(local_name) => {\n-                            err.span_label(\n-                                mir.source_info(p).span,\n-                                format!(\"borrow later used here, when `{}` is dropped\", local_name),\n-                            );\n+        let region_sub = regioncx.find_constraint(borrow_region_vid, context.loc);\n \n-                            if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n-                                if let Place::Local(borrowed_local) = place {\n-                                    let dropped_local_scope =\n-                                        mir.local_decls[local].visibility_scope;\n-                                    let borrowed_local_scope =\n-                                        mir.local_decls[*borrowed_local].visibility_scope;\n+        debug!(\n+            \"explain_why_borrow_contains_point: region_sub={:?}\",\n+            region_sub\n+        );\n \n-                                    if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope) {\n-                                        err.note(\n-                                            \"values in a scope are dropped \\\n-                                             in the opposite order they are defined\",\n-                                        );\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        None => {\n-                            err.span_label(\n-                                mir.local_decls[local].source_info.span,\n-                                \"borrow may end up in a temporary, created here\",\n-                            );\n+        match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n+            Some(Cause::LiveVar(_local, location)) => {\n+                err.span_label(\n+                    mir.source_info(location).span,\n+                    format!(\"borrow later used here\"),\n+                );\n+            }\n \n-                            err.span_label(\n-                                mir.source_info(p).span,\n-                                \"temporary later dropped here, \\\n-                                 potentially using the reference\",\n-                            );\n+            Some(Cause::DropVar(local, location)) => match &mir.local_decls[local].name {\n+                Some(local_name) => {\n+                    err.span_label(\n+                        mir.source_info(location).span,\n+                        format!(\"borrow later used here, when `{}` is dropped\", local_name),\n+                    );\n+\n+                    if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n+                        if let Place::Local(borrowed_local) = place {\n+                            let dropped_local_scope = mir.local_decls[local].visibility_scope;\n+                            let borrowed_local_scope =\n+                                mir.local_decls[*borrowed_local].visibility_scope;\n+\n+                            if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope) {\n+                                err.note(\n+                                    \"values in a scope are dropped \\\n+                                     in the opposite order they are defined\",\n+                                );\n+                            }\n                         }\n-                    },\n-\n-                    None => {\n-                        span_bug!(\n-                            mir.source_info(context.loc).span,\n-                            \"Cause should end in a DropVar\"\n-                        );\n-                    }\n-                },\n-\n-                Cause::UniversalRegion(region_vid) => {\n-                    if let Some(region) = regioncx.to_error_region(region_vid) {\n-                        self.tcx.note_and_explain_free_region(\n-                            err,\n-                            \"borrowed value must be valid for \",\n-                            region,\n-                            \"...\",\n-                        );\n                     }\n                 }\n \n-                _ => {}\n-            }\n-        }\n-    }\n-}\n-\n-fn find_regular_use<'gcx, 'tcx>(\n-    mir: &'gcx Mir,\n-    regioncx: &'tcx RegionInferenceContext,\n-    borrow: &'tcx BorrowData,\n-    start_point: Location,\n-    local: Local,\n-) -> Option<Location> {\n-    let mut uf = UseFinder {\n-        mir,\n-        regioncx,\n-        borrow,\n-        start_point,\n-        local,\n-        liveness_mode: LivenessMode {\n-            include_regular_use: true,\n-            include_drops: false,\n-        },\n-    };\n-\n-    uf.find()\n-}\n-\n-fn find_drop_use<'gcx, 'tcx>(\n-    mir: &'gcx Mir,\n-    regioncx: &'tcx RegionInferenceContext,\n-    borrow: &'tcx BorrowData,\n-    start_point: Location,\n-    local: Local,\n-) -> Option<Location> {\n-    let mut uf = UseFinder {\n-        mir,\n-        regioncx,\n-        borrow,\n-        start_point,\n-        local,\n-        liveness_mode: LivenessMode {\n-            include_regular_use: false,\n-            include_drops: true,\n-        },\n-    };\n-\n-    uf.find()\n-}\n-\n-struct UseFinder<'gcx, 'tcx> {\n-    mir: &'gcx Mir<'gcx>,\n-    regioncx: &'tcx RegionInferenceContext<'tcx>,\n-    borrow: &'tcx BorrowData<'tcx>,\n-    start_point: Location,\n-    local: Local,\n-    liveness_mode: LivenessMode,\n-}\n-\n-impl<'gcx, 'tcx> UseFinder<'gcx, 'tcx> {\n-    fn find(&mut self) -> Option<Location> {\n-        let mut stack = vec![];\n-        let mut visited = FxHashSet();\n-\n-        stack.push(self.start_point);\n-        while let Some(p) = stack.pop() {\n-            if !self.regioncx.region_contains_point(self.borrow.region, p) {\n-                continue;\n-            }\n-\n-            if !visited.insert(p) {\n-                continue;\n-            }\n-\n-            let block_data = &self.mir[p.block];\n-            let (defined, used) = self.def_use(p, block_data.visitable(p.statement_index));\n-\n-            if used {\n-                return Some(p);\n-            } else if !defined {\n-                if p.statement_index < block_data.statements.len() {\n-                    stack.push(Location {\n-                        statement_index: p.statement_index + 1,\n-                        ..p\n-                    });\n-                } else {\n-                    stack.extend(block_data.terminator().successors().map(|&basic_block| {\n-                        Location {\n-                            statement_index: 0,\n-                            block: basic_block,\n-                        }\n-                    }));\n+                None => {}\n+            },\n+\n+            None => {\n+                if let Some(region) = regioncx.to_error_region(region_sub) {\n+                    self.tcx.note_and_explain_free_region(\n+                        err,\n+                        \"borrowed value must be valid for \",\n+                        region,\n+                        \"...\",\n+                    );\n                 }\n             }\n         }\n-\n-        None\n-    }\n-\n-    fn def_use(&self, location: Location, thing: &dyn MirVisitable<'tcx>) -> (bool, bool) {\n-        let mut visitor = DefUseVisitor {\n-            defined: false,\n-            used: false,\n-            local: self.local,\n-            liveness_mode: self.liveness_mode,\n-        };\n-\n-        thing.apply(location, &mut visitor);\n-\n-        (visitor.defined, visitor.used)\n-    }\n-}\n-\n-struct DefUseVisitor {\n-    defined: bool,\n-    used: bool,\n-    local: Local,\n-    liveness_mode: LivenessMode,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for DefUseVisitor {\n-    fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n-        if local == self.local {\n-            match liveness::categorize(context, self.liveness_mode) {\n-                Some(DefUse::Def) => self.defined = true,\n-                Some(DefUse::Use) => self.used = true,\n-                None => (),\n-            }\n-        }\n     }\n }"}, {"sha": "6543516b9c2c642e75c7b9e8382eebfd5693470f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::fmt;\n-use borrow_check::nll::region_infer::{Cause, ConstraintIndex, RegionInferenceContext};\n+use borrow_check::nll::region_infer::{ConstraintIndex, RegionInferenceContext};\n use borrow_check::nll::region_infer::values::ToElementIndex;\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n@@ -259,15 +259,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    crate fn why_region_contains_point(&self, fr1: RegionVid, elem: Location) -> Option<Cause> {\n-        // Find some constraint `X: Y` where:\n-        // - `fr1: X` transitively\n-        // - and `Y` is live at `elem`\n+    // Find some constraint `X: Y` where:\n+    // - `fr1: X` transitively\n+    // - and `Y` is live at `elem`\n+    crate fn find_constraint(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         let index = self.blame_constraint(fr1, elem);\n-        let region_sub = self.constraints[index].sub;\n-\n-        // then return why `Y` was live at `elem`\n-        self.liveness_constraints.cause(region_sub, elem)\n+        self.constraints[index].sub\n     }\n \n     /// Tries to finds a good span to blame for the fact that `fr1`"}, {"sha": "13cc0c0419eab1673e0064fd9ab637f209161e71", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 23, "deletions": 51, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -19,7 +19,7 @@ use rustc::infer::NLLRegionVariableOrigin;\n use rustc::infer::RegionVariableOrigin;\n use rustc::mir::{\n     ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n-    Mir\n+    Mir,\n };\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common;\n@@ -75,8 +75,6 @@ pub struct RegionInferenceContext<'tcx> {\n     universal_regions: UniversalRegions<'tcx>,\n }\n \n-struct TrackCauses(bool);\n-\n struct RegionDefinition<'tcx> {\n     /// Why we created this variable. Mostly these will be\n     /// `RegionVariableOrigin::NLL`, but some variables get created\n@@ -105,13 +103,6 @@ pub(crate) enum Cause {\n \n     /// point inserted because Local was dropped at the given Location\n     DropVar(Local, Location),\n-\n-    /// point inserted because the type was live at the given Location,\n-    /// but not as part of some local variable\n-    LiveOther(Location),\n-\n-    /// part of the initial set of values for a universally quantified region\n-    UniversalRegion(RegionVid),\n }\n \n /// A \"type test\" corresponds to an outlives constraint between a type\n@@ -280,19 +271,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             // Add all nodes in the CFG to liveness constraints\n             for point_index in self.elements.all_point_indices() {\n-                self.liveness_constraints.add_element(\n-                    variable,\n-                    point_index,\n-                    &Cause::UniversalRegion(variable),\n-                );\n+                self.liveness_constraints.add_element(variable, point_index);\n             }\n \n             // Add `end(X)` into the set for X.\n-            self.liveness_constraints.add_element(\n-                variable,\n-                variable,\n-                &Cause::UniversalRegion(variable),\n-            );\n+            self.liveness_constraints.add_element(variable, variable);\n         }\n     }\n \n@@ -337,26 +320,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Returns `true` if this constraint is new and `false` is the\n     /// constraint was already present.\n-    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location, cause: &Cause) -> bool {\n+    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) -> bool {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        debug!(\"add_live_point: @{:?} Adding cause {:?}\", point, cause);\n \n         let element = self.elements.index(point);\n-        if self.liveness_constraints.add_element(v, element, &cause) {\n-            true\n-        } else {\n-            false\n-        }\n+        self.liveness_constraints.add_element(v, element)\n     }\n \n     /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n-    pub(super) fn add_outlives(\n-        &mut self,\n-        locations: Locations,\n-        sup: RegionVid,\n-        sub: RegionVid,\n-    ) {\n+    pub(super) fn add_outlives(&mut self, locations: Locations, sup: RegionVid, sub: RegionVid) {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n         self.constraints.push(OutlivesConstraint {\n             locations,\n@@ -440,7 +413,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // The initial values for each region are derived from the liveness\n         // constraints we have accumulated.\n-        let mut inferred_values = self.liveness_constraints.duplicate(TrackCauses(false));\n+        let mut inferred_values = self.liveness_constraints.clone();\n \n         let dependency_map = self.dependency_map.as_ref().unwrap();\n \n@@ -461,11 +434,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n                 debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n \n-                self.constraints.each_affected_by_dirty(dependency_map[constraint.sup], |dep_idx| {\n-                    if clean_bit_vec.remove(dep_idx.index()) {\n-                        dirty_list.push(dep_idx);\n-                    }\n-                });\n+                self.constraints.each_affected_by_dirty(\n+                    dependency_map[constraint.sup],\n+                    |dep_idx| {\n+                        if clean_bit_vec.remove(dep_idx.index()) {\n+                            dirty_list.push(dep_idx);\n+                        }\n+                    },\n+                );\n             }\n \n             debug!(\"\\n\");\n@@ -503,8 +479,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             if let Some(propagated_outlives_requirements) = &mut propagated_outlives_requirements {\n-                if self.try_promote_type_test(infcx, mir, type_test,\n-                                              propagated_outlives_requirements) {\n+                if self.try_promote_type_test(\n+                    infcx,\n+                    mir,\n+                    type_test,\n+                    propagated_outlives_requirements,\n+                ) {\n                     continue;\n                 }\n             }\n@@ -760,12 +740,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Test if `test` is true when applied to `lower_bound` at\n     /// `point`, and returns true or false.\n-    fn eval_region_test(\n-        &self,\n-        mir: &Mir<'tcx>,\n-        lower_bound: RegionVid,\n-        test: &RegionTest,\n-    ) -> bool {\n+    fn eval_region_test(&self, mir: &Mir<'tcx>, lower_bound: RegionVid, test: &RegionTest) -> bool {\n         debug!(\n             \"eval_region_test(lower_bound={:?}, test={:?})\",\n             lower_bound, test\n@@ -797,10 +772,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         sup_region: RegionVid,\n         sub_region: RegionVid,\n     ) -> bool {\n-        debug!(\n-            \"eval_outlives({:?}: {:?})\",\n-            sup_region, sub_region\n-        );\n+        debug!(\"eval_outlives({:?}: {:?})\", sup_region, sub_region);\n \n         let inferred_values = self\n             .inferred_values"}, {"sha": "1039e6d7b972cbcc1acda41f8303b100775e47c6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 8, "deletions": 88, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -8,18 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::region_infer::TrackCauses;\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::RegionVid;\n use rustc_data_structures::bitvec::SparseBitMatrix;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n use std::rc::Rc;\n \n-use super::Cause;\n-\n /// Maps between the various kinds of elements of a region value to\n /// the internal indices that w use.\n pub(super) struct RegionValueElements {\n@@ -32,7 +28,8 @@ pub(super) struct RegionValueElements {\n impl RegionValueElements {\n     pub(super) fn new(mir: &Mir<'_>, num_universal_regions: usize) -> Self {\n         let mut num_points = 0;\n-        let statements_before_block = mir.basic_blocks()\n+        let statements_before_block = mir\n+            .basic_blocks()\n             .iter()\n             .map(|block_data| {\n                 let v = num_points;\n@@ -100,7 +97,8 @@ impl RegionValueElements {\n             // be (BB2, 20).\n             //\n             // Nit: we could do a binary search here but I'm too lazy.\n-            let (block, &first_index) = self.statements_before_block\n+            let (block, &first_index) = self\n+                .statements_before_block\n                 .iter_enumerated()\n                 .filter(|(_, first_index)| **first_index <= point_index)\n                 .last()\n@@ -180,19 +178,12 @@ impl ToElementIndex for RegionElementIndex {\n /// compact `SparseBitMatrix` representation, with one row per region\n /// variable. The columns consist of either universal regions or\n /// points in the CFG.\n+#[derive(Clone)]\n pub(super) struct RegionValues {\n     elements: Rc<RegionValueElements>,\n     matrix: SparseBitMatrix<RegionVid, RegionElementIndex>,\n-\n-    /// If cause tracking is enabled, maps from a pair (r, e)\n-    /// consisting of a region `r` that contains some element `e` to\n-    /// the reason that the element is contained. There should be an\n-    /// entry for every bit set to 1 in `SparseBitMatrix`.\n-    causes: Option<CauseMap>,\n }\n \n-type CauseMap = FxHashMap<(RegionVid, RegionElementIndex), Cause>;\n-\n impl RegionValues {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n@@ -209,38 +200,15 @@ impl RegionValues {\n                 RegionVid::new(num_region_variables),\n                 RegionElementIndex::new(elements.num_elements()),\n             ),\n-            causes: Some(CauseMap::default()),\n-        }\n-    }\n-\n-    /// Duplicates the region values. If track_causes is false, then the\n-    /// resulting value will not track causal information (and any existing\n-    /// causal information is dropped). Otherwise, the causal information is\n-    /// preserved and maintained. Tracking the causal information makes region\n-    /// propagation significantly slower, so we prefer not to do it until an\n-    /// error is reported.\n-    pub(super) fn duplicate(&self, track_causes: TrackCauses) -> Self {\n-        Self {\n-            elements: self.elements.clone(),\n-            matrix: self.matrix.clone(),\n-            causes: if track_causes.0 {\n-                self.causes.clone()\n-            } else {\n-                None\n-            },\n         }\n     }\n \n     /// Adds the given element to the value for the given region. Returns true if\n     /// the element is newly added (i.e., was not already present).\n-    pub(super) fn add_element<E: ToElementIndex>(\n-        &mut self,\n-        r: RegionVid,\n-        elem: E,\n-        cause: &Cause,\n-    ) -> bool {\n+    pub(super) fn add_element<E: ToElementIndex>(&mut self, r: RegionVid, elem: E) -> bool {\n         let i = self.elements.index(elem);\n-        self.add_internal(r, i, |_| cause.clone())\n+        debug!(\"add(r={:?}, elem={:?})\", r, elem);\n+        self.matrix.add(r, i)\n     }\n \n     /// Add all elements in `r_from` to `r_to` (because e.g. `r_to:\n@@ -249,40 +217,6 @@ impl RegionValues {\n         self.matrix.merge(r_from, r_to)\n     }\n \n-    /// Internal method to add an element to a region.\n-    ///\n-    /// Takes a \"lazy\" cause -- this function will return the cause, but it will only\n-    /// be invoked if cause tracking is enabled.\n-    fn add_internal<F>(&mut self, r: RegionVid, i: RegionElementIndex, make_cause: F) -> bool\n-    where\n-        F: FnOnce(&CauseMap) -> Cause,\n-    {\n-        if self.matrix.add(r, i) {\n-            debug!(\"add(r={:?}, i={:?})\", r, self.elements.to_element(i));\n-\n-            if let Some(causes) = &mut self.causes {\n-                let cause = make_cause(causes);\n-                causes.insert((r, i), cause);\n-            }\n-\n-            true\n-        } else {\n-            if let Some(causes) = &mut self.causes {\n-                let cause = make_cause(causes);\n-                let old_cause = causes.get_mut(&(r, i)).unwrap();\n-                // #49998: compare using root cause alone to avoid\n-                // useless traffic from similar outlives chains.\n-\n-                if cause < *old_cause {\n-                    *old_cause = cause;\n-                    return true;\n-                }\n-            }\n-\n-            false\n-        }\n-    }\n-\n     /// True if the region `r` contains the given element.\n     pub(super) fn contains<E: ToElementIndex>(&self, r: RegionVid, elem: E) -> bool {\n         let i = self.elements.index(elem);\n@@ -398,18 +332,4 @@ impl RegionValues {\n             ));\n         }\n     }\n-\n-    /// Given a region `r` that contains the element `elem`, returns the `Cause`\n-    /// that tells us *why* `elem` is found in that region.\n-    ///\n-    /// Returns None if cause tracking is disabled or `elem` is not\n-    /// actually found in `r`.\n-    pub(super) fn cause<T: ToElementIndex>(&self, r: RegionVid, elem: T) -> Option<Cause> {\n-        let index = self.elements.index(elem);\n-        if let Some(causes) = &self.causes {\n-            causes.get(&(r, index)).cloned()\n-        } else {\n-            None\n-        }\n-    }\n }"}, {"sha": "91025e3f4afc016e13e7d2048f1fd19baaccc06a", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::region_infer::Cause;\n use borrow_check::nll::type_check::AtLocation;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow::MaybeInitializedPlaces;\n@@ -88,8 +87,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             .simulate_block(self.mir, bb, |location, live_locals| {\n                 for live_local in live_locals.iter() {\n                     let live_local_ty = self.mir.local_decls[live_local].ty;\n-                    let cause = Cause::LiveVar(live_local, location);\n-                    Self::push_type_live_constraint(&mut self.cx, live_local_ty, location, cause);\n+                    Self::push_type_live_constraint(&mut self.cx, live_local_ty, location);\n                 }\n             });\n \n@@ -161,7 +159,6 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n         value: T,\n         location: Location,\n-        cause: Cause,\n     ) where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -171,9 +168,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         );\n \n         cx.tcx().for_each_free_region(&value, |live_region| {\n-            cx.constraints\n-                .liveness_set\n-                .push((live_region, location, cause.clone()));\n+            cx.constraints.liveness_set.push((live_region, location));\n         });\n     }\n \n@@ -210,9 +205,8 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n \n         // All things in the `outlives` array may be touched by\n         // the destructor and must be live at this point.\n-        let cause = Cause::DropVar(dropped_local, location);\n         for &kind in &drop_data.dropck_result.kinds {\n-            Self::push_type_live_constraint(&mut self.cx, kind, location, cause);\n+            Self::push_type_live_constraint(&mut self.cx, kind, location);\n         }\n     }\n "}, {"sha": "2b47d50b4c2c7a2d29ee5796cbedc5603d6e5435", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -14,7 +14,6 @@\n use borrow_check::location::LocationTable;\n use borrow_check::nll::constraint_set::ConstraintSet;\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::Cause;\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::move_paths::MoveData;\n@@ -312,7 +311,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n         debug!(\"sanitize_constant: expected_ty={:?}\", expected_ty);\n \n-        if let Err(terr) = self.cx.eq_types(expected_ty, constant.ty, location.boring()) {\n+        if let Err(terr) = self\n+            .cx\n+            .eq_types(expected_ty, constant.ty, location.boring())\n+        {\n             span_mirbug!(\n                 self,\n                 constant,\n@@ -615,7 +617,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// not otherwise appear in the MIR -- in particular, the\n     /// late-bound regions that it instantiates at call-sites -- and\n     /// hence it must report on their liveness constraints.\n-    crate liveness_set: Vec<(ty::Region<'tcx>, Location, Cause)>,\n+    crate liveness_set: Vec<(ty::Region<'tcx>, Location)>,\n \n     crate outlives_constraints: ConstraintSet,\n \n@@ -771,12 +773,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn sub_types(\n-        &mut self,\n-        sub: Ty<'tcx>,\n-        sup: Ty<'tcx>,\n-        locations: Locations,\n-    ) -> Fallible<()> {\n+    fn sub_types(&mut self, sub: Ty<'tcx>, sup: Ty<'tcx>, locations: Locations) -> Fallible<()> {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             locations,\n@@ -808,7 +805,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     false\n                 };\n \n-                let locations = if is_temp { location.boring() } else { location.interesting() };\n+                let locations = if is_temp {\n+                    location.boring()\n+                } else {\n+                    location.interesting()\n+                };\n \n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n@@ -983,11 +984,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // output) types in the signature must be live, since\n                 // all the inputs that fed into it were live.\n                 for &late_bound_region in map.values() {\n-                    self.constraints.liveness_set.push((\n-                        late_bound_region,\n-                        term_location,\n-                        Cause::LiveOther(term_location),\n-                    ));\n+                    self.constraints\n+                        .liveness_set\n+                        .push((late_bound_region, term_location));\n                 }\n \n                 self.check_call_inputs(mir, term, &sig, args, term_location);\n@@ -1507,10 +1506,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n \n                     // Hmm, are these constraints *really* boring?\n-                    self.push_region_constraints(\n-                        location.boring(),\n-                        &closure_constraints,\n-                    );\n+                    self.push_region_constraints(location.boring(), &closure_constraints);\n                 }\n \n                 tcx.predicates_of(*def_id).instantiate(tcx, substs.substs)"}, {"sha": "015538b16f971e4d94d9dc87df35a81aa7894b46", "filename": "src/test/ui/generator/borrowing.nll.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -2,15 +2,10 @@ error[E0597]: `a` does not live long enough\n   --> $DIR/borrowing.rs:18:18\n    |\n LL |         unsafe { (|| yield &a).resume() }\n-   |                  ^^^^^^^^^^^^^\n-   |                  |\n-   |                  borrowed value does not live long enough\n-   |                  borrow may end up in a temporary, created here\n+   |                  ^^^^^^^^^^^^^ borrowed value does not live long enough\n LL |         //~^ ERROR: `a` does not live long enough\n LL |     };\n-   |     -- temporary later dropped here, potentially using the reference\n-   |     |\n-   |     borrowed value only lives until here\n+   |     - borrowed value only lives until here\n \n error[E0597]: `a` does not live long enough\n   --> $DIR/borrowing.rs:24:9"}, {"sha": "08839c23c37622261aa1cb76e3a157e323af6534", "filename": "src/test/ui/generator/ref-escapes-but-not-over-yield.nll.stderr", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fref-escapes-but-not-over-yield.nll.stderr?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -1,19 +1,11 @@\n error[E0597]: `b` does not live long enough\n   --> $DIR/ref-escapes-but-not-over-yield.rs:24:13\n    |\n-LL |       let mut b = move || {\n-   |  _________________-\n-LL | |         yield();\n-LL | |         let b = 5;\n-LL | |         a = &b;\n-   | |             ^^ borrowed value does not live long enough\n-LL | |         //~^ ERROR `b` does not live long enough\n-LL | |     };\n-   | |     -\n-   | |     |\n-   | |     borrowed value only lives until here\n-   | |_____temporary later dropped here, potentially using the reference\n-   |       borrow may end up in a temporary, created here\n+LL |         a = &b;\n+   |             ^^ borrowed value does not live long enough\n+LL |         //~^ ERROR `b` does not live long enough\n+LL |     };\n+   |     - borrowed value only lives until here\n \n error: aborting due to previous error\n "}, {"sha": "4bdce85d18b5feff02dbd3340dd7a1ef64f9e79b", "filename": "src/test/ui/issue-47646.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Ftest%2Fui%2Fissue-47646.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Ftest%2Fui%2Fissue-47646.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47646.stderr?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -3,15 +3,9 @@ error[E0502]: cannot borrow `heap` as immutable because it is also borrowed as m\n    |\n LL |     let borrow = heap.peek_mut();\n    |                  ---- mutable borrow occurs here\n-LL | \n-LL |     match (borrow, ()) {\n-   |           ------------ borrow may end up in a temporary, created here\n-LL |         (Some(_), ()) => {\n+...\n LL |             println!(\"{:?}\", heap); //~ ERROR cannot borrow `heap` as immutable\n    |                              ^^^^ immutable borrow occurs here\n-...\n-LL |     };\n-   |      - temporary later dropped here, potentially using the reference\n \n error: aborting due to previous error\n "}, {"sha": "8be4cf445da3f77c2261843cd1c3b8a39c445176", "filename": "src/test/ui/span/destructor-restrictions.nll.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.nll.stderr?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -2,14 +2,9 @@ error[E0597]: `*a` does not live long enough\n   --> $DIR/destructor-restrictions.rs:18:10\n    |\n LL |         *a.borrow() + 1\n-   |          ^---------\n-   |          |\n-   |          borrowed value does not live long enough\n-   |          borrow may end up in a temporary, created here\n+   |          ^ borrowed value does not live long enough\n LL |     }; //~^ ERROR `*a` does not live long enough\n-   |     -- temporary later dropped here, potentially using the reference\n-   |     |\n-   |     borrowed value only lives until here\n+   |     - borrowed value only lives until here\n \n error: aborting due to previous error\n "}, {"sha": "ec2f5a25631c4aedb4748dbde77c01a39c9e5190", "filename": "src/test/ui/span/issue-23338-locals-die-before-temps-of-body.nll.stderr", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Ftest%2Fui%2Fspan%2Fissue-23338-locals-die-before-temps-of-body.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f8ae08fd5294718466a61f74f6de0135b88035/src%2Ftest%2Fui%2Fspan%2Fissue-23338-locals-die-before-temps-of-body.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23338-locals-die-before-temps-of-body.nll.stderr?ref=64f8ae08fd5294718466a61f74f6de0135b88035", "patch": "@@ -2,28 +2,17 @@ error[E0597]: `y` does not live long enough\n   --> $DIR/issue-23338-locals-die-before-temps-of-body.rs:20:5\n    |\n LL |     y.borrow().clone()\n-   |     ^---------\n-   |     |\n-   |     borrowed value does not live long enough\n-   |     borrow may end up in a temporary, created here\n+   |     ^ borrowed value does not live long enough\n LL | }\n-   | -\n-   | |\n-   | borrowed value only lives until here\n-   | temporary later dropped here, potentially using the reference\n+   | - borrowed value only lives until here\n \n error[E0597]: `y` does not live long enough\n   --> $DIR/issue-23338-locals-die-before-temps-of-body.rs:27:9\n    |\n LL |         y.borrow().clone()\n-   |         ^---------\n-   |         |\n-   |         borrowed value does not live long enough\n-   |         borrow may end up in a temporary, created here\n+   |         ^ borrowed value does not live long enough\n LL |     };\n-   |     -- temporary later dropped here, potentially using the reference\n-   |     |\n-   |     borrowed value only lives until here\n+   |     - borrowed value only lives until here\n \n error: aborting due to 2 previous errors\n "}]}