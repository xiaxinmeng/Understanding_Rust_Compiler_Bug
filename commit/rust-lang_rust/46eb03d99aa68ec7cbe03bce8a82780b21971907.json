{"sha": "46eb03d99aa68ec7cbe03bce8a82780b21971907", "node_id": "C_kwDOAAsO6NoAKDQ2ZWIwM2Q5OWFhNjhlYzdjYmUwM2JjZThhODI3ODBiMjE5NzE5MDc", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-02T09:18:18Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-02T09:18:18Z"}, "message": "internal: use naming that matches intended use-case", "tree": {"sha": "c4b40511d948ceeb24394219ced513331bd12656", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4b40511d948ceeb24394219ced513331bd12656"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46eb03d99aa68ec7cbe03bce8a82780b21971907", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46eb03d99aa68ec7cbe03bce8a82780b21971907", "html_url": "https://github.com/rust-lang/rust/commit/46eb03d99aa68ec7cbe03bce8a82780b21971907", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46eb03d99aa68ec7cbe03bce8a82780b21971907/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59c758d0cb86122ecc926f2cb89cff72fbc71749", "url": "https://api.github.com/repos/rust-lang/rust/commits/59c758d0cb86122ecc926f2cb89cff72fbc71749", "html_url": "https://github.com/rust-lang/rust/commit/59c758d0cb86122ecc926f2cb89cff72fbc71749"}], "stats": {"total": 107, "additions": 61, "deletions": 46}, "files": [{"sha": "ee504ffe44acc573bd3f8a27b8a48d15665100ad", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=46eb03d99aa68ec7cbe03bce8a82780b21971907", "patch": "@@ -3,7 +3,7 @@ use ide_db::{\n     base_db::FilePosition,\n     defs::{Definition, NameClass, NameRefClass},\n     helpers::{for_each_break_expr, for_each_tail_expr, node_ext::walk_expr, pick_best_token},\n-    search::{FileReference, ReferenceAccess, SearchScope},\n+    search::{FileReference, ReferenceCategory, SearchScope},\n     RootDatabase,\n };\n use rustc_hash::FxHashSet;\n@@ -19,7 +19,7 @@ use crate::{display::TryToNav, references, NavigationTarget};\n #[derive(PartialEq, Eq, Hash)]\n pub struct HighlightedRange {\n     pub range: TextRange,\n-    pub access: Option<ReferenceAccess>,\n+    pub access: Option<ReferenceCategory>,\n }\n \n #[derive(Default, Clone)]\n@@ -87,7 +87,7 @@ fn highlight_references(\n                 .remove(&file_id)\n         })\n         .flatten()\n-        .map(|FileReference { access, range, .. }| HighlightedRange { range, access });\n+        .map(|FileReference { category: access, range, .. }| HighlightedRange { range, access });\n \n     let declarations = defs.iter().flat_map(|def| {\n         match def {\n@@ -355,8 +355,8 @@ mod tests {\n                     hl.range,\n                     hl.access.map(|it| {\n                         match it {\n-                            ReferenceAccess::Read => \"read\",\n-                            ReferenceAccess::Write => \"write\",\n+                            ReferenceCategory::Read => \"read\",\n+                            ReferenceCategory::Write => \"write\",\n                         }\n                         .to_string()\n                     }),"}, {"sha": "5c47227990700e1d07c91c2ad414cd2e12eecd63", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=46eb03d99aa68ec7cbe03bce8a82780b21971907", "patch": "@@ -108,7 +108,7 @@ pub use ide_db::{\n     call_info::CallInfo,\n     label::Label,\n     line_index::{LineCol, LineColUtf16, LineIndex},\n-    search::{ReferenceAccess, SearchScope},\n+    search::{ReferenceCategory, SearchScope},\n     source_change::{FileSystemEdit, SourceChange},\n     symbol_index::Query,\n     RootDatabase, SymbolKind,"}, {"sha": "993f212544e0f8aedd3ea5a425fcd58ce08bc81f", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=46eb03d99aa68ec7cbe03bce8a82780b21971907", "patch": "@@ -16,7 +16,7 @@ use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n-    search::{ReferenceAccess, SearchScope, UsageSearchResult},\n+    search::{ReferenceCategory, SearchScope, UsageSearchResult},\n     RootDatabase,\n };\n use rustc_hash::FxHashMap;\n@@ -31,13 +31,13 @@ use crate::{display::TryToNav, FilePosition, NavigationTarget};\n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n     pub declaration: Option<Declaration>,\n-    pub references: FxHashMap<FileId, Vec<(TextRange, Option<ReferenceAccess>)>>,\n+    pub references: FxHashMap<FileId, Vec<(TextRange, Option<ReferenceCategory>)>>,\n }\n \n #[derive(Debug, Clone)]\n pub struct Declaration {\n     pub nav: NavigationTarget,\n-    pub access: Option<ReferenceAccess>,\n+    pub access: Option<ReferenceCategory>,\n }\n \n // Feature: Find All References\n@@ -102,7 +102,7 @@ pub(crate) fn find_all_refs(\n                         (\n                             file_id,\n                             refs.into_iter()\n-                                .map(|file_ref| (file_ref.range, file_ref.access))\n+                                .map(|file_ref| (file_ref.range, file_ref.category))\n                                 .collect(),\n                         )\n                     })\n@@ -149,7 +149,7 @@ pub(crate) fn decl_access(\n     def: &Definition,\n     syntax: &SyntaxNode,\n     range: TextRange,\n-) -> Option<ReferenceAccess> {\n+) -> Option<ReferenceCategory> {\n     match def {\n         Definition::Local(_) | Definition::Field(_) => {}\n         _ => return None,\n@@ -160,7 +160,7 @@ pub(crate) fn decl_access(\n         let pat = stmt.pat()?;\n         if let ast::Pat::IdentPat(it) = pat {\n             if it.mut_token().is_some() {\n-                return Some(ReferenceAccess::Write);\n+                return Some(ReferenceCategory::Write);\n             }\n         }\n     }"}, {"sha": "585ef31daf2e73cbd4170f1757df5007ab1c20a6", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=46eb03d99aa68ec7cbe03bce8a82780b21971907", "patch": "@@ -6,7 +6,7 @@ use hir::{HirDisplay, InFile, Local, Semantics, TypeInfo};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n     helpers::node_ext::{preorder_expr, walk_expr, walk_pat, walk_patterns_in_expr},\n-    search::{FileReference, ReferenceAccess, SearchScope},\n+    search::{FileReference, ReferenceCategory, SearchScope},\n     RootDatabase,\n };\n use itertools::Itertools;\n@@ -877,7 +877,7 @@ fn reference_is_exclusive(\n     ctx: &AssistContext,\n ) -> bool {\n     // we directly modify variable with set: `n = 0`, `n += 1`\n-    if reference.access == Some(ReferenceAccess::Write) {\n+    if reference.category == Some(ReferenceCategory::Write) {\n         return true;\n     }\n "}, {"sha": "707323272974f5308eb988f51fa4f8542d4e66f3", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=46eb03d99aa68ec7cbe03bce8a82780b21971907", "patch": "@@ -58,13 +58,18 @@ impl IntoIterator for UsageSearchResult {\n pub struct FileReference {\n     pub range: TextRange,\n     pub name: ast::NameLike,\n-    pub access: Option<ReferenceAccess>,\n+    pub category: Option<ReferenceCategory>,\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub enum ReferenceAccess {\n-    Read,\n+pub enum ReferenceCategory {\n+    // FIXME: Add this variant and delete the `retain_adt_literal_usages` function.\n+    // Create\n     Write,\n+    Read,\n+    // FIXME: Some day should be able to search in doc comments. Would probably\n+    // need to switch from enum to bitflags then?\n+    // DocComment\n }\n \n /// Generally, `search_scope` returns files that might contain references for the element.\n@@ -472,7 +477,7 @@ impl<'a> FindUsages<'a> {\n                 let reference = FileReference {\n                     range,\n                     name: ast::NameLike::NameRef(name_ref.clone()),\n-                    access: None,\n+                    category: None,\n                 };\n                 sink(file_id, reference)\n             }\n@@ -491,7 +496,7 @@ impl<'a> FindUsages<'a> {\n                 let reference = FileReference {\n                     range,\n                     name: ast::NameLike::NameRef(name_ref.clone()),\n-                    access: None,\n+                    category: None,\n                 };\n                 sink(file_id, reference)\n             }\n@@ -510,7 +515,7 @@ impl<'a> FindUsages<'a> {\n                 let reference = FileReference {\n                     range,\n                     name: ast::NameLike::Lifetime(lifetime.clone()),\n-                    access: None,\n+                    category: None,\n                 };\n                 sink(file_id, reference)\n             }\n@@ -529,7 +534,7 @@ impl<'a> FindUsages<'a> {\n                 let reference = FileReference {\n                     range,\n                     name: ast::NameLike::NameRef(name_ref.clone()),\n-                    access: reference_access(&def, name_ref),\n+                    category: ReferenceCategory::new(&def, name_ref),\n                 };\n                 sink(file_id, reference)\n             }\n@@ -539,7 +544,7 @@ impl<'a> FindUsages<'a> {\n                     let reference = FileReference {\n                         range,\n                         name: ast::NameLike::NameRef(name_ref.clone()),\n-                        access: reference_access(&def, name_ref),\n+                        category: ReferenceCategory::new(&def, name_ref),\n                     };\n                     sink(file_id, reference)\n                 } else {\n@@ -550,14 +555,19 @@ impl<'a> FindUsages<'a> {\n                 let field = Definition::Field(field);\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let access = match self.def {\n-                    Definition::Field(_) if field == self.def => reference_access(&field, name_ref),\n+                    Definition::Field(_) if field == self.def => {\n+                        ReferenceCategory::new(&field, name_ref)\n+                    }\n                     Definition::Local(l) if local == l => {\n-                        reference_access(&Definition::Local(local), name_ref)\n+                        ReferenceCategory::new(&Definition::Local(local), name_ref)\n                     }\n                     _ => return false,\n                 };\n-                let reference =\n-                    FileReference { range, name: ast::NameLike::NameRef(name_ref.clone()), access };\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::NameRef(name_ref.clone()),\n+                    category: access,\n+                };\n                 sink(file_id, reference)\n             }\n             _ => false,\n@@ -580,14 +590,17 @@ impl<'a> FindUsages<'a> {\n                     range,\n                     name: ast::NameLike::Name(name.clone()),\n                     // FIXME: mutable patterns should have `Write` access\n-                    access: Some(ReferenceAccess::Read),\n+                    category: Some(ReferenceCategory::Read),\n                 };\n                 sink(file_id, reference)\n             }\n             Some(NameClass::ConstReference(def)) if self.def == def => {\n                 let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n-                let reference =\n-                    FileReference { range, name: ast::NameLike::Name(name.clone()), access: None };\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::Name(name.clone()),\n+                    category: None,\n+                };\n                 sink(file_id, reference)\n             }\n             // Resolve trait impl function definitions to the trait definition's version if self.def is the trait definition's\n@@ -611,7 +624,7 @@ impl<'a> FindUsages<'a> {\n                         let reference = FileReference {\n                             range,\n                             name: ast::NameLike::Name(name.clone()),\n-                            access: None,\n+                            category: None,\n                         };\n                         sink(file_id, reference)\n                     })\n@@ -642,32 +655,34 @@ fn def_to_ty(sema: &Semantics<RootDatabase>, def: &Definition) -> Option<hir::Ty\n     }\n }\n \n-fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n-    // Only Locals and Fields have accesses for now.\n-    if !matches!(def, Definition::Local(_) | Definition::Field(_)) {\n-        return None;\n-    }\n+impl ReferenceCategory {\n+    fn new(def: &Definition, r: &ast::NameRef) -> Option<ReferenceCategory> {\n+        // Only Locals and Fields have accesses for now.\n+        if !matches!(def, Definition::Local(_) | Definition::Field(_)) {\n+            return None;\n+        }\n \n-    let mode = name_ref.syntax().ancestors().find_map(|node| {\n+        let mode = r.syntax().ancestors().find_map(|node| {\n         match_ast! {\n             match (node) {\n                 ast::BinExpr(expr) => {\n                     if matches!(expr.op_kind()?, ast::BinaryOp::Assignment { .. }) {\n                         // If the variable or field ends on the LHS's end then it's a Write (covers fields and locals).\n                         // FIXME: This is not terribly accurate.\n                         if let Some(lhs) = expr.lhs() {\n-                            if lhs.syntax().text_range().end() == name_ref.syntax().text_range().end() {\n-                                return Some(ReferenceAccess::Write);\n+                            if lhs.syntax().text_range().end() == r.syntax().text_range().end() {\n+                                return Some(ReferenceCategory::Write);\n                             }\n                         }\n                     }\n-                    Some(ReferenceAccess::Read)\n+                    Some(ReferenceCategory::Read)\n                 },\n                 _ => None\n             }\n         }\n     });\n \n-    // Default Locals and Fields to read\n-    mode.or(Some(ReferenceAccess::Read))\n+        // Default Locals and Fields to read\n+        mode.or(Some(ReferenceCategory::Read))\n+    }\n }"}, {"sha": "59a768397fefe5b408dec5d232d0597d542f2ab5", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46eb03d99aa68ec7cbe03bce8a82780b21971907/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=46eb03d99aa68ec7cbe03bce8a82780b21971907", "patch": "@@ -9,7 +9,7 @@ use ide::{\n     Annotation, AnnotationKind, Assist, AssistKind, CallInfo, Cancellable, CompletionItem,\n     CompletionItemKind, CompletionRelevance, Documentation, FileId, FileRange, FileSystemEdit,\n     Fold, FoldKind, Highlight, HlMod, HlOperator, HlPunct, HlRange, HlTag, Indel, InlayHint,\n-    InlayKind, Markup, NavigationTarget, ReferenceAccess, RenameError, Runnable, Severity,\n+    InlayKind, Markup, NavigationTarget, ReferenceCategory, RenameError, Runnable, Severity,\n     SourceChange, StructureNodeKind, SymbolKind, TextEdit, TextRange, TextSize,\n };\n use itertools::Itertools;\n@@ -75,11 +75,11 @@ pub(crate) fn structure_node_kind(kind: StructureNodeKind) -> lsp_types::SymbolK\n }\n \n pub(crate) fn document_highlight_kind(\n-    reference_access: ReferenceAccess,\n+    category: ReferenceCategory,\n ) -> lsp_types::DocumentHighlightKind {\n-    match reference_access {\n-        ReferenceAccess::Read => lsp_types::DocumentHighlightKind::Read,\n-        ReferenceAccess::Write => lsp_types::DocumentHighlightKind::Write,\n+    match category {\n+        ReferenceCategory::Read => lsp_types::DocumentHighlightKind::Read,\n+        ReferenceCategory::Write => lsp_types::DocumentHighlightKind::Write,\n     }\n }\n "}]}