{"sha": "581b1664c92f78f3d15181c78a16480987256ecb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MWIxNjY0YzkyZjc4ZjNkMTUxODFjNzhhMTY0ODA5ODcyNTZlY2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-29T02:51:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-29T02:51:19Z"}, "message": "Auto merge of #87416 - Aaron1011:query-side-effect, r=cjgillot\n\nCreate `QuerySideEffects` and use it for diagnostics\n\nThe code for saving and loading diagnostics during execution is generalized to handle a new `QuerySideEffects` struct. Currently, this struct just holds diagnostics - in a follow-up PR, I plan to add support for storing attriutes marked as used during query execution.\n\nThis is a pure refactor, with no intended behavior changes.", "tree": {"sha": "d4b6485f097c0855c18e700b637adf918333999c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4b6485f097c0855c18e700b637adf918333999c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/581b1664c92f78f3d15181c78a16480987256ecb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/581b1664c92f78f3d15181c78a16480987256ecb", "html_url": "https://github.com/rust-lang/rust/commit/581b1664c92f78f3d15181c78a16480987256ecb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/581b1664c92f78f3d15181c78a16480987256ecb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85237886df31ba237acd3b7912336704026813f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/85237886df31ba237acd3b7912336704026813f5", "html_url": "https://github.com/rust-lang/rust/commit/85237886df31ba237acd3b7912336704026813f5"}, {"sha": "87740bac642860e794e11965a8d03ecd195880ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/87740bac642860e794e11965a8d03ecd195880ac", "html_url": "https://github.com/rust-lang/rust/commit/87740bac642860e794e11965a8d03ecd195880ac"}], "stats": {"total": 219, "additions": 102, "deletions": 117}, "files": [{"sha": "ee64f22618e7e000c98d82fa84f2a4f6e2d430e0", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 38, "deletions": 49, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/581b1664c92f78f3d15181c78a16480987256ecb/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/581b1664c92f78f3d15181c78a16480987256ecb/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=581b1664c92f78f3d15181c78a16480987256ecb", "patch": "@@ -1,9 +1,7 @@\n use crate::QueryCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell};\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::unhash::UnhashMap;\n-use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathHash;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -13,7 +11,7 @@ use rustc_middle::mir::{self, interpret};\n use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n-use rustc_query_system::query::QueryContext;\n+use rustc_query_system::query::{QueryContext, QuerySideEffects};\n use rustc_serialize::{\n     opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize},\n     Decodable, Decoder, Encodable, Encoder,\n@@ -41,14 +39,14 @@ const TAG_EXPN_DATA: u8 = 1;\n /// Provides an interface to incremental compilation data cached from the\n /// previous compilation session. This data will eventually include the results\n /// of a few selected queries (like `typeck` and `mir_optimized`) and\n-/// any diagnostics that have been emitted during a query.\n+/// any side effects that have been emitted during a query.\n pub struct OnDiskCache<'sess> {\n     // The complete cache data in serialized form.\n     serialized_data: Vec<u8>,\n \n-    // Collects all `Diagnostic`s emitted during the current compilation\n+    // Collects all `QuerySideEffects` created during the current compilation\n     // session.\n-    current_diagnostics: Lock<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n+    current_side_effects: Lock<FxHashMap<DepNodeIndex, QuerySideEffects>>,\n \n     cnum_map: OnceCell<UnhashMap<StableCrateId, CrateNum>>,\n \n@@ -62,9 +60,9 @@ pub struct OnDiskCache<'sess> {\n     // `serialized_data`.\n     query_result_index: FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n \n-    // A map from dep-node to the position of any associated diagnostics in\n+    // A map from dep-node to the position of any associated `QuerySideEffects` in\n     // `serialized_data`.\n-    prev_diagnostics_index: FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n+    prev_side_effects_index: FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n \n     alloc_decoding_state: AllocDecodingState,\n \n@@ -113,8 +111,8 @@ pub struct OnDiskCache<'sess> {\n #[derive(Encodable, Decodable)]\n struct Footer {\n     file_index_to_stable_id: FxHashMap<SourceFileIndex, EncodedSourceFileId>,\n-    query_result_index: EncodedQueryResultIndex,\n-    diagnostics_index: EncodedQueryResultIndex,\n+    query_result_index: EncodedDepNodeIndex,\n+    side_effects_index: EncodedDepNodeIndex,\n     // The location of all allocations.\n     interpret_alloc_index: Vec<u32>,\n     // See `OnDiskCache.syntax_contexts`\n@@ -125,9 +123,7 @@ struct Footer {\n     foreign_expn_data: UnhashMap<ExpnHash, u32>,\n }\n \n-pub type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n-type EncodedDiagnosticsIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n-type EncodedDiagnostics = Vec<Diagnostic>;\n+pub type EncodedDepNodeIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable)]\n struct SourceFileIndex(u32);\n@@ -213,9 +209,9 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             file_index_to_file: Default::default(),\n             cnum_map: OnceCell::new(),\n             source_map: sess.source_map(),\n-            current_diagnostics: Default::default(),\n+            current_side_effects: Default::default(),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n-            prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n+            prev_side_effects_index: footer.side_effects_index.into_iter().collect(),\n             alloc_decoding_state: AllocDecodingState::new(footer.interpret_alloc_index),\n             syntax_contexts: footer.syntax_contexts,\n             expn_data: footer.expn_data,\n@@ -234,9 +230,9 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             file_index_to_file: Default::default(),\n             cnum_map: OnceCell::new(),\n             source_map,\n-            current_diagnostics: Default::default(),\n+            current_side_effects: Default::default(),\n             query_result_index: Default::default(),\n-            prev_diagnostics_index: Default::default(),\n+            prev_side_effects_index: Default::default(),\n             alloc_decoding_state: AllocDecodingState::new(Vec::new()),\n             syntax_contexts: FxHashMap::default(),\n             expn_data: UnhashMap::default(),\n@@ -301,26 +297,24 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             };\n \n             // Encode query results.\n-            let mut query_result_index = EncodedQueryResultIndex::new();\n+            let mut query_result_index = EncodedDepNodeIndex::new();\n \n             tcx.sess.time(\"encode_query_results\", || -> FileEncodeResult {\n                 let enc = &mut encoder;\n                 let qri = &mut query_result_index;\n                 QueryCtxt::from_tcx(tcx).encode_query_results(enc, qri)\n             })?;\n \n-            // Encode diagnostics.\n-            let diagnostics_index: EncodedDiagnosticsIndex = self\n-                .current_diagnostics\n+            // Encode side effects.\n+            let side_effects_index: EncodedDepNodeIndex = self\n+                .current_side_effects\n                 .borrow()\n                 .iter()\n                 .map(\n-                    |(dep_node_index, diagnostics)| -> Result<_, <FileEncoder as Encoder>::Error> {\n+                    |(dep_node_index, side_effects)| -> Result<_, <FileEncoder as Encoder>::Error> {\n                         let pos = AbsoluteBytePos::new(encoder.position());\n-                        // Let's make sure we get the expected type here.\n-                        let diagnostics: &EncodedDiagnostics = diagnostics;\n                         let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n-                        encoder.encode_tagged(dep_node_index, diagnostics)?;\n+                        encoder.encode_tagged(dep_node_index, side_effects)?;\n \n                         Ok((dep_node_index, pos))\n                     },\n@@ -386,7 +380,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                 &Footer {\n                     file_index_to_stable_id,\n                     query_result_index,\n-                    diagnostics_index,\n+                    side_effects_index,\n                     interpret_alloc_index,\n                     syntax_contexts,\n                     expn_data,\n@@ -488,30 +482,26 @@ impl<'sess> OnDiskCache<'sess> {\n         self as _\n     }\n \n-    /// Loads a diagnostic emitted during the previous compilation session.\n-    pub fn load_diagnostics(\n+    /// Loads a `QuerySideEffects` created during the previous compilation session.\n+    pub fn load_side_effects(\n         &self,\n         tcx: TyCtxt<'_>,\n         dep_node_index: SerializedDepNodeIndex,\n-    ) -> Vec<Diagnostic> {\n-        let diagnostics: Option<EncodedDiagnostics> =\n-            self.load_indexed(tcx, dep_node_index, &self.prev_diagnostics_index, \"diagnostics\");\n+    ) -> QuerySideEffects {\n+        let side_effects: Option<QuerySideEffects> =\n+            self.load_indexed(tcx, dep_node_index, &self.prev_side_effects_index, \"side_effects\");\n \n-        diagnostics.unwrap_or_default()\n+        side_effects.unwrap_or_default()\n     }\n \n-    /// Stores a diagnostic emitted during the current compilation session.\n-    /// Anything stored like this will be available via `load_diagnostics` in\n+    /// Stores a `QuerySideEffects` emitted during the current compilation session.\n+    /// Anything stored like this will be available via `load_side_effects` in\n     /// the next compilation session.\n     #[inline(never)]\n     #[cold]\n-    pub fn store_diagnostics(\n-        &self,\n-        dep_node_index: DepNodeIndex,\n-        diagnostics: ThinVec<Diagnostic>,\n-    ) {\n-        let mut current_diagnostics = self.current_diagnostics.borrow_mut();\n-        let prev = current_diagnostics.insert(dep_node_index, diagnostics.into());\n+    pub fn store_side_effects(&self, dep_node_index: DepNodeIndex, side_effects: QuerySideEffects) {\n+        let mut current_side_effects = self.current_side_effects.borrow_mut();\n+        let prev = current_side_effects.insert(dep_node_index, side_effects);\n         debug_assert!(prev.is_none());\n     }\n \n@@ -539,22 +529,21 @@ impl<'sess> OnDiskCache<'sess> {\n         self.load_indexed(tcx, dep_node_index, &self.query_result_index, \"query result\")\n     }\n \n-    /// Stores a diagnostic emitted during computation of an anonymous query.\n+    /// Stores side effect emitted during computation of an anonymous query.\n     /// Since many anonymous queries can share the same `DepNode`, we aggregate\n     /// them -- as opposed to regular queries where we assume that there is a\n     /// 1:1 relationship between query-key and `DepNode`.\n     #[inline(never)]\n     #[cold]\n-    pub fn store_diagnostics_for_anon_node(\n+    pub fn store_side_effects_for_anon_node(\n         &self,\n         dep_node_index: DepNodeIndex,\n-        diagnostics: ThinVec<Diagnostic>,\n+        side_effects: QuerySideEffects,\n     ) {\n-        let mut current_diagnostics = self.current_diagnostics.borrow_mut();\n-\n-        let x = current_diagnostics.entry(dep_node_index).or_default();\n+        let mut current_side_effects = self.current_side_effects.borrow_mut();\n \n-        x.extend(Into::<Vec<_>>::into(diagnostics));\n+        let x = current_side_effects.entry(dep_node_index).or_default();\n+        x.append(side_effects);\n     }\n \n     fn load_indexed<'tcx, T>(\n@@ -1155,7 +1144,7 @@ impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx, FileEncoder>> for [u8] {\n pub fn encode_query_results<'a, 'tcx, CTX, Q>(\n     tcx: CTX,\n     encoder: &mut CacheEncoder<'a, 'tcx, FileEncoder>,\n-    query_result_index: &mut EncodedQueryResultIndex,\n+    query_result_index: &mut EncodedDepNodeIndex,\n ) -> FileEncodeResult\n where\n     CTX: QueryContext + 'tcx,"}, {"sha": "5774d021373bb16ebb7fb5907c24f93d2dec9790", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/581b1664c92f78f3d15181c78a16480987256ecb/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/581b1664c92f78f3d15181c78a16480987256ecb/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=581b1664c92f78f3d15181c78a16480987256ecb", "patch": "@@ -7,7 +7,9 @@ use rustc_middle::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeI\n use rustc_middle::ty::tls::{self, ImplicitCtxt};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_query_system::dep_graph::HasDepContext;\n-use rustc_query_system::query::{QueryContext, QueryDescription, QueryJobId, QueryMap};\n+use rustc_query_system::query::{\n+    QueryContext, QueryDescription, QueryJobId, QueryMap, QuerySideEffects,\n+};\n \n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n@@ -83,27 +85,27 @@ impl QueryContext for QueryCtxt<'tcx> {\n     }\n \n     // Interactions with on_disk_cache\n-    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic> {\n+    fn load_side_effects(&self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects {\n         self.queries\n             .on_disk_cache\n             .as_ref()\n-            .map(|c| c.load_diagnostics(**self, prev_dep_node_index))\n+            .map(|c| c.load_side_effects(**self, prev_dep_node_index))\n             .unwrap_or_default()\n     }\n \n-    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>) {\n+    fn store_side_effects(&self, dep_node_index: DepNodeIndex, side_effects: QuerySideEffects) {\n         if let Some(c) = self.queries.on_disk_cache.as_ref() {\n-            c.store_diagnostics(dep_node_index, diagnostics)\n+            c.store_side_effects(dep_node_index, side_effects)\n         }\n     }\n \n-    fn store_diagnostics_for_anon_node(\n+    fn store_side_effects_for_anon_node(\n         &self,\n         dep_node_index: DepNodeIndex,\n-        diagnostics: ThinVec<Diagnostic>,\n+        side_effects: QuerySideEffects,\n     ) {\n         if let Some(c) = self.queries.on_disk_cache.as_ref() {\n-            c.store_diagnostics_for_anon_node(dep_node_index, diagnostics)\n+            c.store_side_effects_for_anon_node(dep_node_index, side_effects)\n         }\n     }\n \n@@ -163,7 +165,7 @@ impl<'tcx> QueryCtxt<'tcx> {\n     pub(super) fn encode_query_results(\n         self,\n         encoder: &mut on_disk_cache::CacheEncoder<'a, 'tcx, opaque::FileEncoder>,\n-        query_result_index: &mut on_disk_cache::EncodedQueryResultIndex,\n+        query_result_index: &mut on_disk_cache::EncodedDepNodeIndex,\n     ) -> opaque::FileEncodeResult {\n         macro_rules! encode_queries {\n             ($($query:ident,)*) => {"}, {"sha": "9c3dad8bd63499caa9204a38ea434506dcb19feb", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 14, "deletions": 49, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/581b1664c92f78f3d15181c78a16480987256ecb/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/581b1664c92f78f3d15181c78a16480987256ecb/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=581b1664c92f78f3d15181c78a16480987256ecb", "patch": "@@ -5,23 +5,20 @@ use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n-use rustc_data_structures::unlikely;\n-use rustc_errors::Diagnostic;\n use rustc_index::vec::IndexVec;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n \n-use parking_lot::{Condvar, Mutex};\n+use parking_lot::Mutex;\n use smallvec::{smallvec, SmallVec};\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n use std::marker::PhantomData;\n-use std::mem;\n use std::sync::atomic::Ordering::Relaxed;\n \n use super::query::DepGraphQuery;\n use super::serialized::{GraphEncoder, SerializedDepGraph, SerializedDepNodeIndex};\n use super::{DepContext, DepKind, DepNode, HasDepContext, WorkProductId};\n-use crate::query::QueryContext;\n+use crate::query::{QueryContext, QuerySideEffects};\n \n #[cfg(debug_assertions)]\n use {super::debug::EdgeFilter, std::env};\n@@ -87,11 +84,7 @@ struct DepGraphData<K: DepKind> {\n \n     colors: DepNodeColorMap,\n \n-    /// A set of loaded diagnostics that is in the progress of being emitted.\n-    emitting_diagnostics: Mutex<FxHashSet<DepNodeIndex>>,\n-\n-    /// Used to wait for diagnostics to be emitted.\n-    emitting_diagnostics_cond_var: Condvar,\n+    processed_side_effects: Mutex<FxHashSet<DepNodeIndex>>,\n \n     /// When we load, there may be `.o` files, cached MIR, or other such\n     /// things available to us. If we find that they are not dirty, we\n@@ -144,8 +137,7 @@ impl<K: DepKind> DepGraph<K> {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n                 current,\n-                emitting_diagnostics: Default::default(),\n-                emitting_diagnostics_cond_var: Condvar::new(),\n+                processed_side_effects: Default::default(),\n                 previous: prev_graph,\n                 colors: DepNodeColorMap::new(prev_graph_node_count),\n             })),\n@@ -691,7 +683,7 @@ impl<K: DepKind> DepGraph<K> {\n \n         // FIXME: Store the fact that a node has diagnostics in a bit in the dep graph somewhere\n         // Maybe store a list on disk and encode this fact in the DepNodeState\n-        let diagnostics = tcx.load_diagnostics(prev_dep_node_index);\n+        let side_effects = tcx.load_side_effects(prev_dep_node_index);\n \n         #[cfg(not(parallel_compiler))]\n         debug_assert!(\n@@ -701,8 +693,8 @@ impl<K: DepKind> DepGraph<K> {\n             dep_node\n         );\n \n-        if unlikely!(!diagnostics.is_empty()) {\n-            self.emit_diagnostics(tcx, data, dep_node_index, prev_dep_node_index, diagnostics);\n+        if unlikely!(!side_effects.is_empty()) {\n+            self.emit_side_effects(tcx, data, dep_node_index, side_effects);\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n@@ -717,54 +709,27 @@ impl<K: DepKind> DepGraph<K> {\n     /// This may be called concurrently on multiple threads for the same dep node.\n     #[cold]\n     #[inline(never)]\n-    fn emit_diagnostics<Ctxt: QueryContext<DepKind = K>>(\n+    fn emit_side_effects<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n         tcx: Ctxt,\n         data: &DepGraphData<K>,\n         dep_node_index: DepNodeIndex,\n-        prev_dep_node_index: SerializedDepNodeIndex,\n-        diagnostics: Vec<Diagnostic>,\n+        side_effects: QuerySideEffects,\n     ) {\n-        let mut emitting = data.emitting_diagnostics.lock();\n-\n-        if data.colors.get(prev_dep_node_index) == Some(DepNodeColor::Green(dep_node_index)) {\n-            // The node is already green so diagnostics must have been emitted already\n-            return;\n-        }\n+        let mut processed = data.processed_side_effects.lock();\n \n-        if emitting.insert(dep_node_index) {\n+        if processed.insert(dep_node_index) {\n             // We were the first to insert the node in the set so this thread\n-            // must emit the diagnostics and signal other potentially waiting\n-            // threads after.\n-            mem::drop(emitting);\n+            // must process side effects\n \n             // Promote the previous diagnostics to the current session.\n-            tcx.store_diagnostics(dep_node_index, diagnostics.clone().into());\n+            tcx.store_side_effects(dep_node_index, side_effects.clone());\n \n             let handle = tcx.dep_context().sess().diagnostic();\n \n-            for diagnostic in diagnostics {\n+            for diagnostic in side_effects.diagnostics {\n                 handle.emit_diagnostic(&diagnostic);\n             }\n-\n-            // Mark the node as green now that diagnostics are emitted\n-            data.colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n-\n-            // Remove the node from the set\n-            data.emitting_diagnostics.lock().remove(&dep_node_index);\n-\n-            // Wake up waiters\n-            data.emitting_diagnostics_cond_var.notify_all();\n-        } else {\n-            // We must wait for the other thread to finish emitting the diagnostic\n-\n-            loop {\n-                data.emitting_diagnostics_cond_var.wait(&mut emitting);\n-                if data.colors.get(prev_dep_node_index) == Some(DepNodeColor::Green(dep_node_index))\n-                {\n-                    break;\n-                }\n-            }\n         }\n     }\n "}, {"sha": "7288aaef8f20beb4c7cdad1e0a1867717239652c", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/581b1664c92f78f3d15181c78a16480987256ecb/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/581b1664c92f78f3d15181c78a16480987256ecb/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=581b1664c92f78f3d15181c78a16480987256ecb", "patch": "@@ -62,6 +62,31 @@ impl QueryStackFrame {\n     }\n }\n \n+/// Tracks 'side effects' for a particular query.\n+/// This struct is saved to disk along with the query result,\n+/// and loaded from disk if we mark the query as green.\n+/// This allows us to 'replay' changes to global state\n+/// that would otherwise only occur if we actually\n+/// executed the query method.\n+#[derive(Debug, Clone, Default, Encodable, Decodable)]\n+pub struct QuerySideEffects {\n+    /// Stores any diagnostics emitted during query execution.\n+    /// These diagnostics will be re-emitted if we mark\n+    /// the query as green.\n+    pub(super) diagnostics: ThinVec<Diagnostic>,\n+}\n+\n+impl QuerySideEffects {\n+    pub fn is_empty(&self) -> bool {\n+        let QuerySideEffects { diagnostics } = self;\n+        diagnostics.is_empty()\n+    }\n+    pub fn append(&mut self, other: QuerySideEffects) {\n+        let QuerySideEffects { diagnostics } = self;\n+        diagnostics.extend(other.diagnostics);\n+    }\n+}\n+\n pub trait QueryContext: HasDepContext {\n     /// Get the query information from the TLS context.\n     fn current_query_job(&self) -> Option<QueryJobId<Self::DepKind>>;\n@@ -74,17 +99,17 @@ pub trait QueryContext: HasDepContext {\n     /// Try to force a dep node to execute and see if it's green.\n     fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n \n-    /// Load diagnostics associated to the node in the previous session.\n-    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic>;\n+    /// Load side effects associated to the node in the previous session.\n+    fn load_side_effects(&self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects;\n \n     /// Register diagnostics for the given node, for use in next session.\n-    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>);\n+    fn store_side_effects(&self, dep_node_index: DepNodeIndex, side_effects: QuerySideEffects);\n \n     /// Register diagnostics for the given node, for use in next session.\n-    fn store_diagnostics_for_anon_node(\n+    fn store_side_effects_for_anon_node(\n         &self,\n         dep_node_index: DepNodeIndex,\n-        diagnostics: ThinVec<Diagnostic>,\n+        side_effects: QuerySideEffects,\n     );\n \n     /// Executes a job by changing the `ImplicitCtxt` to point to the"}, {"sha": "5f53a19b3f922a3d0ba34237bf1a8a27a4e0c7ed", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/581b1664c92f78f3d15181c78a16480987256ecb/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/581b1664c92f78f3d15181c78a16480987256ecb/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=581b1664c92f78f3d15181c78a16480987256ecb", "patch": "@@ -9,7 +9,7 @@ use crate::query::config::{QueryDescription, QueryVtable, QueryVtableExt};\n use crate::query::job::{\n     report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId,\n };\n-use crate::query::{QueryContext, QueryMap, QueryStackFrame};\n+use crate::query::{QueryContext, QueryMap, QuerySideEffects, QueryStackFrame};\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHasher};\n@@ -479,8 +479,10 @@ where\n \n         dep_graph.read_index(dep_node_index);\n \n-        if unlikely!(!diagnostics.is_empty()) {\n-            tcx.store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+        let side_effects = QuerySideEffects { diagnostics };\n+\n+        if unlikely!(!side_effects.is_empty()) {\n+            tcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n         }\n \n         return job.complete(result, dep_node_index);\n@@ -677,8 +679,10 @@ where\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n-    if unlikely!(!diagnostics.is_empty()) && dep_node.kind != DepKind::NULL {\n-        tcx.store_diagnostics(dep_node_index, diagnostics);\n+    let side_effects = QuerySideEffects { diagnostics };\n+\n+    if unlikely!(!side_effects.is_empty()) && dep_node.kind != DepKind::NULL {\n+        tcx.store_side_effects(dep_node_index, side_effects);\n     }\n \n     let result = job.complete(result, dep_node_index);"}]}