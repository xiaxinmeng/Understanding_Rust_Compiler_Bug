{"sha": "baccdc01ae608920602fda8411f1ff8f127ebef2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhY2NkYzAxYWU2MDg5MjA2MDJmZGE4NDExZjFmZjhmMTI3ZWJlZjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-11T01:37:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T13:24:58Z"}, "message": "make record take a closure", "tree": {"sha": "b51a9fd6a9122b245c76da88218eb5847af175e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b51a9fd6a9122b245c76da88218eb5847af175e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baccdc01ae608920602fda8411f1ff8f127ebef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baccdc01ae608920602fda8411f1ff8f127ebef2", "html_url": "https://github.com/rust-lang/rust/commit/baccdc01ae608920602fda8411f1ff8f127ebef2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baccdc01ae608920602fda8411f1ff8f127ebef2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b76932ba84958666d0866d5ae21703b3be14701", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b76932ba84958666d0866d5ae21703b3be14701", "html_url": "https://github.com/rust-lang/rust/commit/6b76932ba84958666d0866d5ae21703b3be14701"}], "stats": {"total": 1061, "additions": 518, "deletions": 543}, "files": [{"sha": "87c7b36cf87e60d960a7fd6152a5e5a6055d9e24", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 509, "deletions": 540, "changes": 1049, "blob_url": "https://github.com/rust-lang/rust/blob/baccdc01ae608920602fda8411f1ff8f127ebef2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baccdc01ae608920602fda8411f1ff8f127ebef2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=baccdc01ae608920602fda8411f1ff8f127ebef2", "patch": "@@ -221,37 +221,35 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n                 self.encode_field(rbml_w, field);\n             }\n \n-            let _task = self.record(vid, rbml_w);\n-            rbml_w.start_tag(tag_items_data_item);\n-            encode_def_id_and_key(ecx, rbml_w, vid);\n-            encode_family(rbml_w, match variant.kind {\n-                ty::VariantKind::Struct => 'V',\n-                ty::VariantKind::Tuple => 'v',\n-                ty::VariantKind::Unit => 'w',\n-            });\n-            encode_name(rbml_w, variant.name);\n-            self.encode_parent_item(rbml_w, did);\n-            self.encode_visibility(rbml_w, vis);\n-\n-            let attrs = ecx.tcx.get_attrs(vid);\n-            encode_attributes(rbml_w, &attrs);\n-            self.encode_repr_attrs(rbml_w, &attrs);\n+            self.record(vid, rbml_w, |this, rbml_w| {\n+                encode_def_id_and_key(ecx, rbml_w, vid);\n+                encode_family(rbml_w, match variant.kind {\n+                    ty::VariantKind::Struct => 'V',\n+                    ty::VariantKind::Tuple => 'v',\n+                    ty::VariantKind::Unit => 'w',\n+                });\n+                encode_name(rbml_w, variant.name);\n+                this.encode_parent_item(rbml_w, did);\n+                this.encode_visibility(rbml_w, vis);\n \n-            let stab = ecx.tcx.lookup_stability(vid);\n-            let depr = ecx.tcx.lookup_deprecation(vid);\n-            encode_stability(rbml_w, stab);\n-            encode_deprecation(rbml_w, depr);\n+                let attrs = ecx.tcx.get_attrs(vid);\n+                encode_attributes(rbml_w, &attrs);\n+                this.encode_repr_attrs(rbml_w, &attrs);\n \n-            self.encode_struct_fields(rbml_w, variant);\n+                let stab = ecx.tcx.lookup_stability(vid);\n+                let depr = ecx.tcx.lookup_deprecation(vid);\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n \n-            let specified_disr_val = variant.disr_val;\n-            if specified_disr_val != disr_val {\n-                self.encode_disr_val(rbml_w, specified_disr_val);\n-                disr_val = specified_disr_val;\n-            }\n-            self.encode_bounds_and_type_for_item(rbml_w, variant_node_id);\n+                this.encode_struct_fields(rbml_w, variant);\n \n-            rbml_w.end_tag();\n+                let specified_disr_val = variant.disr_val;\n+                if specified_disr_val != disr_val {\n+                    this.encode_disr_val(rbml_w, specified_disr_val);\n+                    disr_val = specified_disr_val;\n+                }\n+                this.encode_bounds_and_type_for_item(rbml_w, variant_node_id);\n+            });\n \n             disr_val = disr_val.wrap_incr();\n         }\n@@ -314,7 +312,6 @@ impl<'a, 'tcx> ItemContentBuilder<'a, 'tcx> {\n                            vis: &hir::Visibility) {\n         let ecx = self.ecx();\n \n-        rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, ecx.tcx.map.local_def_id(id));\n         encode_family(rbml_w, 'm');\n         encode_name(rbml_w, name);\n@@ -346,8 +343,6 @@ impl<'a, 'tcx> ItemContentBuilder<'a, 'tcx> {\n             encode_reexports(ecx, rbml_w, id);\n         }\n         encode_attributes(rbml_w, attrs);\n-\n-        rbml_w.end_tag();\n     }\n \n     fn encode_struct_field_family(&mut self, rbml_w: &mut Encoder,\n@@ -438,20 +433,18 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n         let nm = field.name;\n         let id = ecx.local_id(field.did);\n \n-        let _task = self.record(field.did, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        debug!(\"encode_field: encoding {} {}\", nm, id);\n-        self.encode_struct_field_family(rbml_w, field.vis);\n-        encode_name(rbml_w, nm);\n-        self.encode_bounds_and_type_for_item(rbml_w, id);\n-        encode_def_id_and_key(ecx, rbml_w, field.did);\n-\n-        let stab = ecx.tcx.lookup_stability(field.did);\n-        let depr = ecx.tcx.lookup_deprecation(field.did);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n+        self.record(field.did, rbml_w, |this, rbml_w| {\n+            debug!(\"encode_field: encoding {} {}\", nm, id);\n+            this.encode_struct_field_family(rbml_w, field.vis);\n+            encode_name(rbml_w, nm);\n+            this.encode_bounds_and_type_for_item(rbml_w, id);\n+            encode_def_id_and_key(ecx, rbml_w, field.did);\n \n-        rbml_w.end_tag();\n+            let stab = ecx.tcx.lookup_stability(field.did);\n+            let depr = ecx.tcx.lookup_deprecation(field.did);\n+            encode_stability(rbml_w, stab);\n+            encode_deprecation(rbml_w, depr);\n+        });\n     }\n }\n \n@@ -465,29 +458,29 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n         let ctor_id = struct_def.id();\n         let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n \n-        let _task = self.record(ctor_def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n-        encode_family(rbml_w, match *struct_def {\n-            hir::VariantData::Struct(..) => 'S',\n-            hir::VariantData::Tuple(..) => 's',\n-            hir::VariantData::Unit(..) => 'u',\n-        });\n-        self.encode_bounds_and_type_for_item(rbml_w, ctor_id);\n-        encode_name(rbml_w, name);\n-        self.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(struct_id));\n-\n-        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(ctor_id));\n-        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(ctor_id));\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n+        self.record(ctor_def_id, rbml_w, |this, rbml_w| {\n+            encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n+            encode_family(rbml_w, match *struct_def {\n+                hir::VariantData::Struct(..) => 'S',\n+                hir::VariantData::Tuple(..) => 's',\n+                hir::VariantData::Unit(..) => 'u',\n+            });\n+            this.encode_bounds_and_type_for_item(rbml_w, ctor_id);\n+            encode_name(rbml_w, name);\n+            this.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(struct_id));\n \n-        // indicate that this is a tuple struct ctor, because downstream users will normally want\n-        // the tuple struct definition, but without this there is no way for them to tell that\n-        // they actually have a ctor rather than a normal function\n-        rbml_w.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n+            let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(ctor_id));\n+            let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(ctor_id));\n+            encode_stability(rbml_w, stab);\n+            encode_deprecation(rbml_w, depr);\n \n-        rbml_w.end_tag();\n+            // indicate that this is a tuple struct ctor, because\n+            // downstream users will normally want the tuple struct\n+            // definition, but without this there is no way for them\n+            // to tell that they actually have a ctor rather than a\n+            // normal function\n+            rbml_w.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n+        });\n     }\n }\n \n@@ -549,35 +542,32 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n                associated_const.def_id,\n                associated_const.name);\n \n-        let _task = self.record(associated_const.def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-\n-        encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n-        encode_name(rbml_w, associated_const.name);\n-        self.encode_visibility(rbml_w, associated_const.vis);\n-        encode_family(rbml_w, 'C');\n-\n-        self.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-        encode_item_sort(rbml_w, 'C');\n+        self.record(associated_const.def_id, rbml_w, |this, rbml_w| {\n+            encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n+            encode_name(rbml_w, associated_const.name);\n+            this.encode_visibility(rbml_w, associated_const.vis);\n+            encode_family(rbml_w, 'C');\n \n-        self.encode_bounds_and_type_for_item(rbml_w, ecx.local_id(associated_const.def_id));\n+            this.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n+            encode_item_sort(rbml_w, 'C');\n \n-        let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n-        let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n+            this.encode_bounds_and_type_for_item(rbml_w, ecx.local_id(associated_const.def_id));\n \n-        if let Some(ii) = impl_item_opt {\n-            encode_attributes(rbml_w, &ii.attrs);\n-            encode_defaultness(rbml_w, ii.defaultness);\n-            encode_inlined_item(ecx,\n-                                rbml_w,\n-                                InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n-                                                         ii));\n-            self.encode_mir(rbml_w, ii.id);\n-        }\n+            let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n+            let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n+            encode_stability(rbml_w, stab);\n+            encode_deprecation(rbml_w, depr);\n \n-        rbml_w.end_tag();\n+            if let Some(ii) = impl_item_opt {\n+                encode_attributes(rbml_w, &ii.attrs);\n+                encode_defaultness(rbml_w, ii.defaultness);\n+                encode_inlined_item(ecx,\n+                                    rbml_w,\n+                                    InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                             ii));\n+                this.encode_mir(rbml_w, ii.id);\n+            }\n+        });\n     }\n \n     fn encode_info_for_method(&mut self,\n@@ -590,43 +580,40 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n \n         debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n                m.name);\n-        let _task = self.record(m.def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-\n-        self.encode_method_ty_fields(rbml_w, m);\n-        self.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-        encode_item_sort(rbml_w, 'r');\n+        self.record(m.def_id, rbml_w, |this, rbml_w| {\n+            this.encode_method_ty_fields(rbml_w, m);\n+            this.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n+            encode_item_sort(rbml_w, 'r');\n \n-        let stab = ecx.tcx.lookup_stability(m.def_id);\n-        let depr = ecx.tcx.lookup_deprecation(m.def_id);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n+            let stab = ecx.tcx.lookup_stability(m.def_id);\n+            let depr = ecx.tcx.lookup_deprecation(m.def_id);\n+            encode_stability(rbml_w, stab);\n+            encode_deprecation(rbml_w, depr);\n \n-        let m_node_id = ecx.local_id(m.def_id);\n-        self.encode_bounds_and_type_for_item(rbml_w, m_node_id);\n-\n-        if let Some(impl_item) = impl_item_opt {\n-            if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                encode_attributes(rbml_w, &impl_item.attrs);\n-                let generics = ecx.tcx.lookup_generics(m.def_id);\n-                let types = generics.parent_types as usize + generics.types.len();\n-                let needs_inline = types > 0 || is_default_impl ||\n-                    attr::requests_inline(&impl_item.attrs);\n-                if needs_inline || sig.constness == hir::Constness::Const {\n-                    encode_inlined_item(\n-                        ecx,\n-                        rbml_w,\n-                        InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n-                                                 impl_item));\n-                    self.encode_mir(rbml_w, impl_item.id);\n+            let m_node_id = ecx.local_id(m.def_id);\n+            this.encode_bounds_and_type_for_item(rbml_w, m_node_id);\n+\n+            if let Some(impl_item) = impl_item_opt {\n+                if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n+                    encode_attributes(rbml_w, &impl_item.attrs);\n+                    let generics = ecx.tcx.lookup_generics(m.def_id);\n+                    let types = generics.parent_types as usize + generics.types.len();\n+                    let needs_inline = types > 0 || is_default_impl ||\n+                        attr::requests_inline(&impl_item.attrs);\n+                    if needs_inline || sig.constness == hir::Constness::Const {\n+                        encode_inlined_item(\n+                            ecx,\n+                            rbml_w,\n+                            InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                     impl_item));\n+                        this.encode_mir(rbml_w, impl_item.id);\n+                    }\n+                    encode_constness(rbml_w, sig.constness);\n+                    encode_defaultness(rbml_w, impl_item.defaultness);\n+                    this.encode_method_argument_names(rbml_w, &sig.decl);\n                 }\n-                encode_constness(rbml_w, sig.constness);\n-                encode_defaultness(rbml_w, impl_item.defaultness);\n-                self.encode_method_argument_names(rbml_w, &sig.decl);\n             }\n-        }\n-\n-        rbml_w.end_tag();\n+        });\n     }\n \n     fn encode_info_for_associated_type(&mut self,\n@@ -639,38 +626,37 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n                associated_type.def_id,\n                associated_type.name);\n \n-        let _task = self.record(associated_type.def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-\n-        encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n-        encode_name(rbml_w, associated_type.name);\n-        self.encode_visibility(rbml_w, associated_type.vis);\n-        encode_family(rbml_w, 'y');\n-        self.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-        encode_item_sort(rbml_w, 't');\n-\n-        let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n-        let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n+        self.record(associated_type.def_id, rbml_w, |this, rbml_w| {\n+            encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n+            encode_name(rbml_w, associated_type.name);\n+            this.encode_visibility(rbml_w, associated_type.vis);\n+            encode_family(rbml_w, 'y');\n+            this.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n+            encode_item_sort(rbml_w, 't');\n \n-        if let Some(ii) = impl_item_opt {\n-            encode_attributes(rbml_w, &ii.attrs);\n-            encode_defaultness(rbml_w, ii.defaultness);\n-        } else {\n-            // TODO this looks bogus and unnecessary\n-            self.encode_predicates(rbml_w,\n-                                   &ecx.tcx.lookup_predicates(associated_type.def_id),\n-                                   tag_item_generics);\n-        }\n+            let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n+            let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n+            encode_stability(rbml_w, stab);\n+            encode_deprecation(rbml_w, depr);\n \n-        if let Some(ty) = associated_type.ty {\n-            self.encode_type(rbml_w, ty);\n-        }\n+            if let Some(ii) = impl_item_opt {\n+                encode_attributes(rbml_w, &ii.attrs);\n+                encode_defaultness(rbml_w, ii.defaultness);\n+            } else {\n+                // TODO this looks bogus and unnecessary\n+                this.encode_predicates(rbml_w,\n+                                       &ecx.tcx.lookup_predicates(associated_type.def_id),\n+                                       tag_item_generics);\n+            }\n \n-        rbml_w.end_tag();\n+            if let Some(ty) = associated_type.ty {\n+                this.encode_type(rbml_w, ty);\n+            }\n+        });\n     }\n+}\n \n+impl<'a, 'tcx> ItemContentBuilder<'a, 'tcx> {\n     fn encode_method_argument_names(&mut self,\n                                     rbml_w: &mut Encoder,\n                                     decl: &hir::FnDecl) {\n@@ -686,9 +672,7 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n         }\n         rbml_w.end_tag();\n     }\n-}\n \n-impl<'a, 'tcx> ItemContentBuilder<'a, 'tcx> {\n     fn encode_repr_attrs(&mut self,\n                          rbml_w: &mut Encoder,\n                          attrs: &[ast::Attribute]) {\n@@ -802,168 +786,159 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n \n         match item.node {\n             hir::ItemStatic(_, m, _) => {\n-                let _task = self.record(def_id, rbml_w);\n-                rbml_w.start_tag(tag_items_data_item);\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                if m == hir::MutMutable {\n-                    encode_family(rbml_w, 'b');\n-                } else {\n-                    encode_family(rbml_w, 'c');\n-                }\n-                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                encode_name(rbml_w, item.name);\n-                self.encode_visibility(rbml_w, vis);\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n-                encode_attributes(rbml_w, &item.attrs);\n-                rbml_w.end_tag();\n+                self.record(def_id, rbml_w, |this, rbml_w| {\n+                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                    if m == hir::MutMutable {\n+                        encode_family(rbml_w, 'b');\n+                    } else {\n+                        encode_family(rbml_w, 'c');\n+                    }\n+                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                    encode_name(rbml_w, item.name);\n+                    this.encode_visibility(rbml_w, vis);\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n+                    encode_attributes(rbml_w, &item.attrs);\n+                });\n             }\n             hir::ItemConst(_, _) => {\n-                let _task = self.record(def_id, rbml_w);\n-                rbml_w.start_tag(tag_items_data_item);\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                encode_family(rbml_w, 'C');\n-                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                encode_name(rbml_w, item.name);\n-                encode_attributes(rbml_w, &item.attrs);\n-                encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-                self.encode_mir(rbml_w, item.id);\n-                self.encode_visibility(rbml_w, vis);\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n-                rbml_w.end_tag();\n+                self.record(def_id, rbml_w, |this, rbml_w| {\n+                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                    encode_family(rbml_w, 'C');\n+                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                    encode_name(rbml_w, item.name);\n+                    encode_attributes(rbml_w, &item.attrs);\n+                    encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n+                    this.encode_mir(rbml_w, item.id);\n+                    this.encode_visibility(rbml_w, vis);\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n+                });\n             }\n             hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-                let _task = self.record(def_id, rbml_w);\n-                rbml_w.start_tag(tag_items_data_item);\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                encode_family(rbml_w, FN_FAMILY);\n-                let tps_len = generics.ty_params.len();\n-                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                encode_name(rbml_w, item.name);\n-                encode_attributes(rbml_w, &item.attrs);\n-                let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n-                if needs_inline || constness == hir::Constness::Const {\n-                    encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-                    self.encode_mir(rbml_w, item.id);\n-                }\n-                encode_constness(rbml_w, constness);\n-                self.encode_visibility(rbml_w, vis);\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n-                self.encode_method_argument_names(rbml_w, &decl);\n-                rbml_w.end_tag();\n+                self.record(def_id, rbml_w, |this, rbml_w| {\n+                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                    encode_family(rbml_w, FN_FAMILY);\n+                    let tps_len = generics.ty_params.len();\n+                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                    encode_name(rbml_w, item.name);\n+                    encode_attributes(rbml_w, &item.attrs);\n+                    let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n+                    if needs_inline || constness == hir::Constness::Const {\n+                        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n+                        this.encode_mir(rbml_w, item.id);\n+                    }\n+                    encode_constness(rbml_w, constness);\n+                    this.encode_visibility(rbml_w, vis);\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n+                    this.encode_method_argument_names(rbml_w, &decl);\n+                });\n             }\n             hir::ItemMod(ref m) => {\n-                let _task = self.record(def_id, rbml_w);\n-                self.encode_info_for_mod(rbml_w,\n-                                         m,\n-                                         &item.attrs,\n-                                         item.id,\n-                                         item.name,\n-                                         &item.vis);\n+                self.record(def_id, rbml_w, |this, rbml_w| {\n+                    this.encode_info_for_mod(rbml_w,\n+                                             m,\n+                                             &item.attrs,\n+                                             item.id,\n+                                             item.name,\n+                                             &item.vis);\n+                });\n             }\n             hir::ItemForeignMod(ref fm) => {\n-                let _task = self.record(def_id, rbml_w);\n-                rbml_w.start_tag(tag_items_data_item);\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                encode_family(rbml_w, 'n');\n-                encode_name(rbml_w, item.name);\n-\n-                // Encode all the items in this module.\n-                for foreign_item in &fm.items {\n-                    rbml_w.wr_tagged_u64(tag_mod_child,\n-                                         def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n-                }\n-                self.encode_visibility(rbml_w, vis);\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n-                rbml_w.end_tag();\n+                self.record(def_id, rbml_w, |this, rbml_w| {\n+                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                    encode_family(rbml_w, 'n');\n+                    encode_name(rbml_w, item.name);\n+\n+                    // Encode all the items in this module.\n+                    for foreign_item in &fm.items {\n+                        rbml_w.wr_tagged_u64(tag_mod_child,\n+                                             def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n+                    }\n+                    this.encode_visibility(rbml_w, vis);\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n+                });\n             }\n             hir::ItemTy(..) => {\n-                let _task = self.record(def_id, rbml_w);\n-                rbml_w.start_tag(tag_items_data_item);\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                encode_family(rbml_w, 'y');\n-                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                encode_name(rbml_w, item.name);\n-                self.encode_visibility(rbml_w, vis);\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n-                rbml_w.end_tag();\n+                self.record(def_id, rbml_w, |this, rbml_w| {\n+                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                    encode_family(rbml_w, 'y');\n+                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                    encode_name(rbml_w, item.name);\n+                    this.encode_visibility(rbml_w, vis);\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n+                });\n             }\n             hir::ItemEnum(ref enum_definition, _) => {\n-                let _task = self.record(def_id, rbml_w);\n-\n-                rbml_w.start_tag(tag_items_data_item);\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                encode_family(rbml_w, 't');\n-                encode_item_variances(rbml_w, ecx, item.id);\n-                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                encode_name(rbml_w, item.name);\n-                encode_attributes(rbml_w, &item.attrs);\n-                self.encode_repr_attrs(rbml_w, &item.attrs);\n-                for v in &enum_definition.variants {\n-                    encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n-                }\n-                encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-                self.encode_mir(rbml_w, item.id);\n+                self.record(def_id, rbml_w, |this, rbml_w| {\n+                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                    encode_family(rbml_w, 't');\n+                    encode_item_variances(rbml_w, ecx, item.id);\n+                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                    encode_name(rbml_w, item.name);\n+                    encode_attributes(rbml_w, &item.attrs);\n+                    this.encode_repr_attrs(rbml_w, &item.attrs);\n+                    for v in &enum_definition.variants {\n+                        encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n+                    }\n+                    encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n+                    this.encode_mir(rbml_w, item.id);\n \n-                // Encode inherent implementations for this enumeration.\n-                encode_inherent_implementations(ecx, rbml_w, def_id);\n+                    // Encode inherent implementations for this enumeration.\n+                    encode_inherent_implementations(ecx, rbml_w, def_id);\n \n-                self.encode_visibility(rbml_w, vis);\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n-                rbml_w.end_tag();\n+                    this.encode_visibility(rbml_w, vis);\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n+                });\n \n                 self.encode_enum_variant_info(rbml_w,\n                                               def_id,\n                                               vis);\n             }\n             hir::ItemStruct(ref struct_def, _) => {\n                 /* Index the class*/\n-                let _task = self.record(def_id, rbml_w);\n-\n                 let def = ecx.tcx.lookup_adt_def(def_id);\n                 let variant = def.struct_variant();\n \n-                /* Now, make an item for the class itself */\n-                rbml_w.start_tag(tag_items_data_item);\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                encode_family(rbml_w, match *struct_def {\n-                    hir::VariantData::Struct(..) => 'S',\n-                    hir::VariantData::Tuple(..) => 's',\n-                    hir::VariantData::Unit(..) => 'u',\n-                });\n-                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n-\n-                encode_item_variances(rbml_w, ecx, item.id);\n-                encode_name(rbml_w, item.name);\n-                encode_attributes(rbml_w, &item.attrs);\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n-                self.encode_visibility(rbml_w, vis);\n-                self.encode_repr_attrs(rbml_w, &item.attrs);\n-\n-                /* Encode def_ids for each field and method\n-                for methods, write all the stuff get_trait_method\n-                needs to know*/\n-                self.encode_struct_fields(rbml_w, variant);\n+                self.record(def_id, rbml_w, |this, rbml_w| {\n+                    /* Now, make an item for the class itself */\n+                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                    encode_family(rbml_w, match *struct_def {\n+                        hir::VariantData::Struct(..) => 'S',\n+                        hir::VariantData::Tuple(..) => 's',\n+                        hir::VariantData::Unit(..) => 'u',\n+                    });\n+                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n+\n+                    encode_item_variances(rbml_w, ecx, item.id);\n+                    encode_name(rbml_w, item.name);\n+                    encode_attributes(rbml_w, &item.attrs);\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n+                    this.encode_visibility(rbml_w, vis);\n+                    this.encode_repr_attrs(rbml_w, &item.attrs);\n \n-                encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-                self.encode_mir(rbml_w, item.id);\n+                    /* Encode def_ids for each field and method\n+                    for methods, write all the stuff get_trait_method\n+                    needs to know*/\n+                    this.encode_struct_fields(rbml_w, variant);\n \n-                // Encode inherent implementations for this structure.\n-                encode_inherent_implementations(ecx, rbml_w, def_id);\n+                    encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n+                    this.encode_mir(rbml_w, item.id);\n \n-                if !struct_def.is_struct() {\n-                    let ctor_did = ecx.tcx.map.local_def_id(struct_def.id());\n-                    rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n-                                         def_to_u64(ctor_did));\n-                }\n+                    // Encode inherent implementations for this structure.\n+                    encode_inherent_implementations(ecx, rbml_w, def_id);\n \n-                rbml_w.end_tag();\n+                    if !struct_def.is_struct() {\n+                        let ctor_did = ecx.tcx.map.local_def_id(struct_def.id());\n+                        rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n+                                             def_to_u64(ctor_did));\n+                    }\n+                });\n \n                 for field in &variant.fields {\n                     self.encode_field(rbml_w, field);\n@@ -975,81 +950,81 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n                 }\n             }\n             hir::ItemDefaultImpl(unsafety, _) => {\n-                let _task = self.record(def_id, rbml_w);\n-                rbml_w.start_tag(tag_items_data_item);\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                encode_family(rbml_w, 'd');\n-                encode_name(rbml_w, item.name);\n-                encode_unsafety(rbml_w, unsafety);\n+                self.record(def_id, rbml_w, |_this, rbml_w| {\n+                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                    encode_family(rbml_w, 'd');\n+                    encode_name(rbml_w, item.name);\n+                    encode_unsafety(rbml_w, unsafety);\n \n-                let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n-                encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n-                rbml_w.end_tag();\n+                    let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n+                    encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+                });\n             }\n             hir::ItemImpl(unsafety, polarity, _, _, _, ref ast_items) => {\n-                let _task = self.record(def_id, rbml_w);\n-\n                 // We need to encode information about the default methods we\n                 // have inherited, so we drive this based on the impl structure.\n                 let impl_items = tcx.impl_items.borrow();\n-                let items = impl_items.get(&def_id).unwrap();\n-\n-                rbml_w.start_tag(tag_items_data_item);\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                encode_family(rbml_w, 'i');\n-                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n-                encode_name(rbml_w, item.name);\n-                encode_attributes(rbml_w, &item.attrs);\n-                encode_unsafety(rbml_w, unsafety);\n-                encode_polarity(rbml_w, polarity);\n-\n-                match tcx.custom_coerce_unsized_kinds\n-                         .borrow()\n-                         .get(&ecx.tcx.map.local_def_id(item.id)) {\n-                    Some(&kind) => {\n-                        rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n-                        kind.encode(rbml_w);\n-                        rbml_w.end_tag();\n+                let items = &impl_items[&def_id];\n+\n+                self.record(def_id, rbml_w, |this, rbml_w| {\n+                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                    encode_family(rbml_w, 'i');\n+                    this.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                    encode_name(rbml_w, item.name);\n+                    encode_attributes(rbml_w, &item.attrs);\n+                    encode_unsafety(rbml_w, unsafety);\n+                    encode_polarity(rbml_w, polarity);\n+\n+                    match\n+                        tcx.custom_coerce_unsized_kinds\n+                           .borrow()\n+                           .get(&ecx.tcx.map.local_def_id(item.id))\n+                    {\n+                        Some(&kind) => {\n+                            rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n+                            kind.encode(rbml_w);\n+                            rbml_w.end_tag();\n+                        }\n+                        None => {}\n                     }\n-                    None => {}\n-                }\n \n-                for &item_def_id in items {\n-                    rbml_w.start_tag(tag_item_impl_item);\n-                    match item_def_id {\n-                        ty::ConstTraitItemId(item_def_id) => {\n-                            encode_def_id(rbml_w, item_def_id);\n-                            encode_item_sort(rbml_w, 'C');\n-                        }\n-                        ty::MethodTraitItemId(item_def_id) => {\n-                            encode_def_id(rbml_w, item_def_id);\n-                            encode_item_sort(rbml_w, 'r');\n-                        }\n-                        ty::TypeTraitItemId(item_def_id) => {\n-                            encode_def_id(rbml_w, item_def_id);\n-                            encode_item_sort(rbml_w, 't');\n+                    for &item_def_id in items {\n+                        rbml_w.start_tag(tag_item_impl_item);\n+                        match item_def_id {\n+                            ty::ConstTraitItemId(item_def_id) => {\n+                                encode_def_id(rbml_w, item_def_id);\n+                                encode_item_sort(rbml_w, 'C');\n+                            }\n+                            ty::MethodTraitItemId(item_def_id) => {\n+                                encode_def_id(rbml_w, item_def_id);\n+                                encode_item_sort(rbml_w, 'r');\n+                            }\n+                            ty::TypeTraitItemId(item_def_id) => {\n+                                encode_def_id(rbml_w, item_def_id);\n+                                encode_item_sort(rbml_w, 't');\n+                            }\n                         }\n+                        rbml_w.end_tag();\n                     }\n-                    rbml_w.end_tag();\n-                }\n-                let did = ecx.tcx.map.local_def_id(item.id);\n-                if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n-                    encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n \n-                    let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n-                    let parent = trait_def.ancestors(did)\n-                                          .skip(1)\n-                                          .next()\n-                                          .and_then(|node| match node {\n-                                              specialization_graph::Node::Impl(parent) =>\n-                                                  Some(parent),\n-                                              _ => None,\n-                                          });\n-                    encode_parent_impl(rbml_w, parent);\n-                }\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n-                rbml_w.end_tag();\n+                    let did = ecx.tcx.map.local_def_id(item.id);\n+                    if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n+                        encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+\n+                        let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n+                        let parent = trait_def.ancestors(did)\n+                                              .skip(1)\n+                                              .next()\n+                                              .and_then(|node| match node {\n+                                                  specialization_graph::Node::Impl(parent) =>\n+                                                      Some(parent),\n+                                                  _ => None,\n+                                              });\n+                        encode_parent_impl(rbml_w, parent);\n+                    }\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n+                });\n \n                 // Iterate down the trait items, emitting them. We rely on the\n                 // assumption that all of the actually implemented trait items\n@@ -1087,157 +1062,157 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n                 }\n             }\n             hir::ItemTrait(_, _, _, ref ms) => {\n-                let _task = self.record(def_id, rbml_w);\n-                rbml_w.start_tag(tag_items_data_item);\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                encode_family(rbml_w, 'I');\n-                encode_item_variances(rbml_w, ecx, item.id);\n-                let trait_def = tcx.lookup_trait_def(def_id);\n-                let trait_predicates = tcx.lookup_predicates(def_id);\n-                encode_unsafety(rbml_w, trait_def.unsafety);\n-                encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n-                encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n-                encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n-                self.encode_generics(rbml_w, &trait_def.generics, &trait_predicates);\n-                self.encode_predicates(rbml_w, &tcx.lookup_super_predicates(def_id), tag_item_super_predicates);\n-                encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n-                encode_name(rbml_w, item.name);\n-                encode_attributes(rbml_w, &item.attrs);\n-                self.encode_visibility(rbml_w, vis);\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n-                for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n-                    rbml_w.start_tag(tag_item_trait_item);\n-                    match method_def_id {\n-                        ty::ConstTraitItemId(const_def_id) => {\n-                            encode_def_id(rbml_w, const_def_id);\n-                            encode_item_sort(rbml_w, 'C');\n-                        }\n-                        ty::MethodTraitItemId(method_def_id) => {\n-                            encode_def_id(rbml_w, method_def_id);\n-                            encode_item_sort(rbml_w, 'r');\n-                        }\n-                        ty::TypeTraitItemId(type_def_id) => {\n-                            encode_def_id(rbml_w, type_def_id);\n-                            encode_item_sort(rbml_w, 't');\n+                self.record(def_id, rbml_w, |this, rbml_w| {\n+                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                    encode_family(rbml_w, 'I');\n+                    encode_item_variances(rbml_w, ecx, item.id);\n+                    let trait_def = tcx.lookup_trait_def(def_id);\n+                    let trait_predicates = tcx.lookup_predicates(def_id);\n+                    encode_unsafety(rbml_w, trait_def.unsafety);\n+                    encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n+                    encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n+                    encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n+                    this.encode_generics(rbml_w, &trait_def.generics, &trait_predicates);\n+                    this.encode_predicates(rbml_w,\n+                                           &tcx.lookup_super_predicates(def_id),\n+                                           tag_item_super_predicates);\n+                    encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n+                    encode_name(rbml_w, item.name);\n+                    encode_attributes(rbml_w, &item.attrs);\n+                    this.encode_visibility(rbml_w, vis);\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n+                    for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n+                        rbml_w.start_tag(tag_item_trait_item);\n+                        match method_def_id {\n+                            ty::ConstTraitItemId(const_def_id) => {\n+                                encode_def_id(rbml_w, const_def_id);\n+                                encode_item_sort(rbml_w, 'C');\n+                            }\n+                            ty::MethodTraitItemId(method_def_id) => {\n+                                encode_def_id(rbml_w, method_def_id);\n+                                encode_item_sort(rbml_w, 'r');\n+                            }\n+                            ty::TypeTraitItemId(type_def_id) => {\n+                                encode_def_id(rbml_w, type_def_id);\n+                                encode_item_sort(rbml_w, 't');\n+                            }\n                         }\n-                    }\n-                    rbml_w.end_tag();\n-\n-                    rbml_w.wr_tagged_u64(tag_mod_child,\n-                                         def_to_u64(method_def_id.def_id()));\n-                }\n+                        rbml_w.end_tag();\n \n-                // Encode inherent implementations for this trait.\n-                encode_inherent_implementations(ecx, rbml_w, def_id);\n+                        rbml_w.wr_tagged_u64(tag_mod_child,\n+                                             def_to_u64(method_def_id.def_id()));\n+                    }\n \n-                rbml_w.end_tag();\n+                    // Encode inherent implementations for this trait.\n+                    encode_inherent_implementations(ecx, rbml_w, def_id);\n+                });\n \n                 // Now output the trait item info for each trait item.\n                 let r = tcx.trait_item_def_ids(def_id);\n                 for (i, &item_def_id) in r.iter().enumerate() {\n                     assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n-                    let _task = self.record(item_def_id.def_id(), rbml_w);\n-                    rbml_w.start_tag(tag_items_data_item);\n+                    self.record(item_def_id.def_id(), rbml_w, |this, rbml_w| {\n+                        this.encode_parent_item(rbml_w, def_id);\n \n-                    self.encode_parent_item(rbml_w, def_id);\n+                        let stab = tcx.lookup_stability(item_def_id.def_id());\n+                        let depr = tcx.lookup_deprecation(item_def_id.def_id());\n+                        encode_stability(rbml_w, stab);\n+                        encode_deprecation(rbml_w, depr);\n \n-                    let stab = tcx.lookup_stability(item_def_id.def_id());\n-                    let depr = tcx.lookup_deprecation(item_def_id.def_id());\n-                    encode_stability(rbml_w, stab);\n-                    encode_deprecation(rbml_w, depr);\n-\n-                    let trait_item_type =\n-                        tcx.impl_or_trait_item(item_def_id.def_id());\n-                    let is_nonstatic_method;\n-                    match trait_item_type {\n-                        ty::ConstTraitItem(associated_const) => {\n-                            encode_name(rbml_w, associated_const.name);\n-                            encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n-                            self.encode_visibility(rbml_w, associated_const.vis);\n-\n-                            encode_family(rbml_w, 'C');\n+                        let trait_item_type =\n+                            tcx.impl_or_trait_item(item_def_id.def_id());\n+                        let is_nonstatic_method;\n+                        match trait_item_type {\n+                            ty::ConstTraitItem(associated_const) => {\n+                                encode_name(rbml_w, associated_const.name);\n+                                encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n+                                this.encode_visibility(rbml_w, associated_const.vis);\n \n-                            self.encode_bounds_and_type_for_item(\n-                                rbml_w,\n-                                ecx.local_id(associated_const.def_id));\n+                                encode_family(rbml_w, 'C');\n \n-                            is_nonstatic_method = false;\n-                        }\n-                        ty::MethodTraitItem(method_ty) => {\n-                            let method_def_id = item_def_id.def_id();\n-\n-                            self.encode_method_ty_fields(rbml_w, &method_ty);\n+                                this.encode_bounds_and_type_for_item(\n+                                    rbml_w,\n+                                    ecx.local_id(associated_const.def_id));\n \n-                            match method_ty.explicit_self {\n-                                ty::ExplicitSelfCategory::Static => {\n-                                    encode_family(rbml_w,\n-                                                  STATIC_METHOD_FAMILY);\n-                                }\n-                                _ => {\n-                                    encode_family(rbml_w,\n-                                                  METHOD_FAMILY);\n-                                }\n+                                is_nonstatic_method = false;\n                             }\n-                            self.encode_bounds_and_type_for_item(rbml_w,\n-                                                                 ecx.local_id(method_def_id));\n+                            ty::MethodTraitItem(method_ty) => {\n+                                let method_def_id = item_def_id.def_id();\n+\n+                                this.encode_method_ty_fields(rbml_w, &method_ty);\n+\n+                                match method_ty.explicit_self {\n+                                    ty::ExplicitSelfCategory::Static => {\n+                                        encode_family(rbml_w,\n+                                                      STATIC_METHOD_FAMILY);\n+                                    }\n+                                    _ => {\n+                                        encode_family(rbml_w,\n+                                                      METHOD_FAMILY);\n+                                    }\n+                                }\n+                                this.encode_bounds_and_type_for_item(rbml_w,\n+                                                                     ecx.local_id(method_def_id));\n \n-                            is_nonstatic_method = method_ty.explicit_self !=\n-                                ty::ExplicitSelfCategory::Static;\n-                        }\n-                        ty::TypeTraitItem(associated_type) => {\n-                            encode_name(rbml_w, associated_type.name);\n-                            encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n-                            encode_item_sort(rbml_w, 't');\n-                            encode_family(rbml_w, 'y');\n-\n-                            if let Some(ty) = associated_type.ty {\n-                                self.encode_type(rbml_w, ty);\n+                                is_nonstatic_method = method_ty.explicit_self !=\n+                                    ty::ExplicitSelfCategory::Static;\n                             }\n+                            ty::TypeTraitItem(associated_type) => {\n+                                encode_name(rbml_w, associated_type.name);\n+                                encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n+                                encode_item_sort(rbml_w, 't');\n+                                encode_family(rbml_w, 'y');\n+\n+                                if let Some(ty) = associated_type.ty {\n+                                    this.encode_type(rbml_w, ty);\n+                                }\n \n-                            is_nonstatic_method = false;\n-                        }\n-                    }\n-\n-                    let trait_item = &ms[i];\n-                    encode_attributes(rbml_w, &trait_item.attrs);\n-                    match trait_item.node {\n-                        hir::ConstTraitItem(_, ref default) => {\n-                            if default.is_some() {\n-                                encode_item_sort(rbml_w, 'C');\n-                            } else {\n-                                encode_item_sort(rbml_w, 'c');\n+                                is_nonstatic_method = false;\n                             }\n-\n-                            encode_inlined_item(ecx, rbml_w,\n-                                                InlinedItemRef::TraitItem(def_id, trait_item));\n-                            self.encode_mir(rbml_w, trait_item.id);\n                         }\n-                        hir::MethodTraitItem(ref sig, ref body) => {\n-                            // If this is a static method, we've already\n-                            // encoded this.\n-                            if is_nonstatic_method {\n-                                self.encode_bounds_and_type_for_item(\n-                                    rbml_w,\n-                                    ecx.local_id(item_def_id.def_id()));\n-                            }\n \n-                            if body.is_some() {\n-                                encode_item_sort(rbml_w, 'p');\n+                        let trait_item = &ms[i];\n+                        encode_attributes(rbml_w, &trait_item.attrs);\n+                        match trait_item.node {\n+                            hir::ConstTraitItem(_, ref default) => {\n+                                if default.is_some() {\n+                                    encode_item_sort(rbml_w, 'C');\n+                                } else {\n+                                    encode_item_sort(rbml_w, 'c');\n+                                }\n+\n                                 encode_inlined_item(ecx, rbml_w,\n                                                     InlinedItemRef::TraitItem(def_id, trait_item));\n-                                self.encode_mir(rbml_w, trait_item.id);\n-                            } else {\n-                                encode_item_sort(rbml_w, 'r');\n+                                this.encode_mir(rbml_w, trait_item.id);\n                             }\n-                            self.encode_method_argument_names(rbml_w, &sig.decl);\n-                        }\n+                            hir::MethodTraitItem(ref sig, ref body) => {\n+                                // If this is a static method, we've already\n+                                // encoded this.\n+                                if is_nonstatic_method {\n+                                    this.encode_bounds_and_type_for_item(\n+                                        rbml_w,\n+                                        ecx.local_id(item_def_id.def_id()));\n+                                }\n \n-                        hir::TypeTraitItem(..) => {}\n-                    }\n+                                if body.is_some() {\n+                                    encode_item_sort(rbml_w, 'p');\n+                                    encode_inlined_item(ecx,\n+                                                        rbml_w,\n+                                                        InlinedItemRef::TraitItem(\n+                                                            def_id,\n+                                                            trait_item));\n+                                    this.encode_mir(rbml_w, trait_item.id);\n+                                } else {\n+                                    encode_item_sort(rbml_w, 'r');\n+                                }\n+                                this.encode_method_argument_names(rbml_w, &sig.decl);\n+                            }\n \n-                    rbml_w.end_tag();\n+                            hir::TypeTraitItem(..) => {}\n+                        }\n+                    });\n                 }\n             }\n             hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n@@ -1255,44 +1230,43 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n         let def_id = ecx.tcx.map.local_def_id(nitem.id);\n         let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n \n-        let _task = self.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        let parent_id = ecx.tcx.map.get_parent(nitem.id);\n-        self.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-        self.encode_visibility(rbml_w, &nitem.vis);\n-        match nitem.node {\n-            hir::ForeignItemFn(ref fndecl, _) => {\n-                encode_family(rbml_w, FN_FAMILY);\n-                self.encode_bounds_and_type_for_item(rbml_w, nitem.id);\n-                encode_name(rbml_w, nitem.name);\n-                if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                    encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(def_id, nitem));\n-                    self.encode_mir(rbml_w, nitem.id);\n+        self.record(def_id, rbml_w, |this, rbml_w| {\n+            encode_def_id_and_key(ecx, rbml_w, def_id);\n+            let parent_id = ecx.tcx.map.get_parent(nitem.id);\n+            this.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n+            this.encode_visibility(rbml_w, &nitem.vis);\n+            match nitem.node {\n+                hir::ForeignItemFn(ref fndecl, _) => {\n+                    encode_family(rbml_w, FN_FAMILY);\n+                    this.encode_bounds_and_type_for_item(rbml_w, nitem.id);\n+                    encode_name(rbml_w, nitem.name);\n+                    if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n+                        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(def_id, nitem));\n+                        this.encode_mir(rbml_w, nitem.id);\n+                    }\n+                    encode_attributes(rbml_w, &nitem.attrs);\n+                    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+                    let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n+                    this.encode_method_argument_names(rbml_w, &fndecl);\n                 }\n-                encode_attributes(rbml_w, &nitem.attrs);\n-                let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n-                let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n-                self.encode_method_argument_names(rbml_w, &fndecl);\n-            }\n-            hir::ForeignItemStatic(_, mutbl) => {\n-                if mutbl {\n-                    encode_family(rbml_w, 'b');\n-                } else {\n-                    encode_family(rbml_w, 'c');\n+                hir::ForeignItemStatic(_, mutbl) => {\n+                    if mutbl {\n+                        encode_family(rbml_w, 'b');\n+                    } else {\n+                        encode_family(rbml_w, 'c');\n+                    }\n+                    this.encode_bounds_and_type_for_item(rbml_w, nitem.id);\n+                    encode_attributes(rbml_w, &nitem.attrs);\n+                    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+                    let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n+                    encode_name(rbml_w, nitem.name);\n                 }\n-                self.encode_bounds_and_type_for_item(rbml_w, nitem.id);\n-                encode_attributes(rbml_w, &nitem.attrs);\n-                let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n-                let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-                encode_stability(rbml_w, stab);\n-                encode_deprecation(rbml_w, depr);\n-                encode_name(rbml_w, nitem.name);\n             }\n-        }\n-        rbml_w.end_tag();\n+        });\n     }\n }\n \n@@ -1316,7 +1290,7 @@ impl<'a, 'data, 'ecx, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'data, 'ecx, 'tc\n     }\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         intravisit::walk_ty(self, ty);\n-        encode_info_for_ty(ty, self.rbml_w_for_visit_item, self.index);\n+        self.index.encode_info_for_ty(ty, self.rbml_w);\n     }\n }\n \n@@ -1327,12 +1301,11 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n         let ecx = self.ecx();\n         if let hir::TyImplTrait(_) = ty.node {\n             let def_id = ecx.tcx.map.local_def_id(ty.id);\n-            let _task = self.record(def_id, rbml_w);\n-            rbml_w.start_tag(tag_items_data_item);\n-            encode_def_id_and_key(ecx, rbml_w, def_id);\n-            encode_family(rbml_w, 'y');\n-            self.encode_bounds_and_type_for_item(rbml_w, ecx, ty.id);\n-            rbml_w.end_tag();\n+            self.record(def_id, rbml_w, |this, rbml_w| {\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                encode_family(rbml_w, 'y');\n+                this.encode_bounds_and_type_for_item(rbml_w, ty.id);\n+            });\n         }\n     }\n \n@@ -1343,24 +1316,21 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n             hir::ExprClosure(..) => {\n                 let def_id = ecx.tcx.map.local_def_id(expr.id);\n \n-                let _task = self.record(def_id, rbml_w);\n-\n-                rbml_w.start_tag(tag_items_data_item);\n-                encode_def_id_and_key(ecx, rbml_w, def_id);\n-                encode_name(rbml_w, syntax::parse::token::intern(\"<closure>\"));\n-\n-                rbml_w.start_tag(tag_items_closure_ty);\n-                write_closure_type(ecx, rbml_w, &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n-                rbml_w.end_tag();\n+                self.record(def_id, rbml_w, |this, rbml_w| {\n+                    encode_def_id_and_key(ecx, rbml_w, def_id);\n+                    encode_name(rbml_w, syntax::parse::token::intern(\"<closure>\"));\n \n-                rbml_w.start_tag(tag_items_closure_kind);\n-                ecx.tcx.closure_kind(def_id).encode(rbml_w).unwrap();\n-                rbml_w.end_tag();\n+                    rbml_w.start_tag(tag_items_closure_ty);\n+                    write_closure_type(ecx, rbml_w, &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n+                    rbml_w.end_tag();\n \n-                assert!(ecx.mir_map.map.contains_key(&def_id));\n-                self.encode_mir(rbml_w, expr.id);\n+                    rbml_w.start_tag(tag_items_closure_kind);\n+                    ecx.tcx.closure_kind(def_id).encode(rbml_w).unwrap();\n+                    rbml_w.end_tag();\n \n-                rbml_w.end_tag();\n+                    assert!(ecx.mir_map.map.contains_key(&def_id));\n+                    this.encode_mir(rbml_w, expr.id);\n+                });\n             }\n             _ => { }\n         }\n@@ -1375,15 +1345,14 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &'a EncodeContext<'a, 'tcx>,\n     let mut index = IndexBuilder::new(ecx);\n     rbml_w.start_tag(tag_items_data);\n \n-    {\n-        let _task = index.record(DefId::local(CRATE_DEF_INDEX), rbml_w);\n-        index.encode_info_for_mod(rbml_w,\n-                                  &krate.module,\n-                                  &[],\n-                                  CRATE_NODE_ID,\n-                                  syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                                  &hir::Public);\n-    }\n+    index.record(DefId::local(CRATE_DEF_INDEX), rbml_w, |this, rbml_w| {\n+        this.encode_info_for_mod(rbml_w,\n+                                 &krate.module,\n+                                 &[],\n+                                 CRATE_NODE_ID,\n+                                 syntax::parse::token::intern(&ecx.link_meta.crate_name),\n+                                 &hir::Public);\n+    });\n \n     krate.visit_all_items(&mut EncodeVisitor {\n         index: &mut index,"}, {"sha": "2ccd1fd4254d7f3d7c79278bf333e405ab3c4683", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/baccdc01ae608920602fda8411f1ff8f127ebef2/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baccdc01ae608920602fda8411f1ff8f127ebef2/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=baccdc01ae608920602fda8411f1ff8f127ebef2", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use common::tag_items_data_item;\n use encoder::EncodeContext;\n use index::IndexData;\n use rbml::writer::Encoder;\n-use rustc::dep_graph::{DepNode, DepTask};\n+use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc_data_structures::fnv::FnvHashMap;\n@@ -52,10 +53,15 @@ impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n     ///\n     /// Returns a dep-graph task that you should keep live as long as\n     /// the data for this item is being emitted.\n-    pub fn record(&mut self, id: DefId, rbml_w: &mut Encoder) -> DepTask<'a> {\n+    pub fn record<OP>(&mut self, id: DefId, rbml_w: &mut Encoder, op: OP)\n+        where OP: FnOnce(&mut ItemContentBuilder<'a, 'tcx>, &mut Encoder)\n+    {\n         let position = rbml_w.mark_stable_position();\n         self.items.record(id, position);\n-        self.ecx.tcx.dep_graph.in_task(DepNode::MetaData(id))\n+        let _task = self.ecx.tcx.dep_graph.in_task(DepNode::MetaData(id));\n+        rbml_w.start_tag(tag_items_data_item).unwrap();\n+        op(self, rbml_w);\n+        rbml_w.end_tag().unwrap();\n     }\n \n     pub fn into_fields(self) -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {"}]}