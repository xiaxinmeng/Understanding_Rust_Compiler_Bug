{"sha": "215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNWJmM2FiZDljMGViMWZkMGM2Y2FlN2M5MmE4NDI3MzJkYzAzM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-04T16:12:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-04T16:12:39Z"}, "message": "Auto merge of #53056 - kennytm:rollup, r=kennytm\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #51919 (Provide `{to,from}_{ne,le,be}_bytes` functions on integers)\n - #52940 (Align 6-week cycle check with beta promotion instead of stable release.)\n - #52968 (App-lint-cability)\n - #52969 (rustbuild: fix local_rebuild)\n - #52995 (Remove unnecessary local in await! generator)\n - #52996 (RELEASES.md: fix the `hash_map::Entry::or_default` link)\n - #53001 (privacy: Fix an ICE in `path_is_private_type`)\n - #53003 (Stabilize --color and --error-format options in rustdoc)\n - #53022 (volatile operations docs: clarify that this does not help wrt. concurrency)\n - #53024 (Specify reentrancy gurantees of `Once::call_once`)\n - #53041 (Fix invalid code css rule)\n - #53047 (Make entire row of doc search results clickable)\n - #53050 (Make left column of rustdoc search results narrower)\n - #53062 (Remove redundant field names in structs)", "tree": {"sha": "ec0774a68324a0b81cc699137de200d8fb1c296d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec0774a68324a0b81cc699137de200d8fb1c296d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "html_url": "https://github.com/rust-lang/rust/commit/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "579adf8c727861841b4819b4913385c2782977fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/579adf8c727861841b4819b4913385c2782977fb", "html_url": "https://github.com/rust-lang/rust/commit/579adf8c727861841b4819b4913385c2782977fb"}, {"sha": "396dda0a6ab57cd89c0e2c28032d05bd91caba08", "url": "https://api.github.com/repos/rust-lang/rust/commits/396dda0a6ab57cd89c0e2c28032d05bd91caba08", "html_url": "https://github.com/rust-lang/rust/commit/396dda0a6ab57cd89c0e2c28032d05bd91caba08"}], "stats": {"total": 368, "additions": 261, "deletions": 107}, "files": [{"sha": "1f7ffb53d3cadcfcb6811da4cafcc7583b5c276a", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -144,7 +144,7 @@ Compatibility Notes\n [`alloc::handle_alloc_error`]: https://doc.rust-lang.org/std/alloc/fn.handle_alloc_error.html\n [`btree_map::Entry::or_default`]: https://doc.rust-lang.org/std/collections/btree_map/enum.Entry.html#method.or_default\n [`fmt::Alignment`]: https://doc.rust-lang.org/std/fmt/enum.Alignment.html\n-[`hash_map::Entry::or_default`]: https://doc.rust-lang.org/std/collections/btree_map/enum.Entry.html#method.or_default\n+[`hash_map::Entry::or_default`]: https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html#method.or_default\n [`iter::repeat_with`]: https://doc.rust-lang.org/std/iter/fn.repeat_with.html\n [`num::NonZeroUsize`]: https://doc.rust-lang.org/std/num/struct.NonZeroUsize.html\n [`num::NonZeroU128`]: https://doc.rust-lang.org/std/num/struct.NonZeroU128.html"}, {"sha": "dc0b0aaf0bb3c894802f18be4d2e21e94b11a57c", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -777,7 +777,7 @@ impl<'a> Builder<'a> {\n         // compiler, but for tools we just use the precompiled libraries that\n         // we've downloaded\n         let use_snapshot = mode == Mode::ToolBootstrap;\n-        assert!(!use_snapshot || stage == 0);\n+        assert!(!use_snapshot || stage == 0 || self.local_rebuild);\n \n         let maybe_sysroot = self.sysroot(compiler);\n         let sysroot = if use_snapshot {"}, {"sha": "d876cb7f37a41b91dea2148a05f95818f55bb8ae", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -17,9 +17,11 @@ TOOLSTATE_FILE=\"$(realpath $2)\"\n OS=\"$3\"\n COMMIT=\"$(git rev-parse HEAD)\"\n CHANGED_FILES=\"$(git diff --name-status HEAD HEAD^)\"\n-SIX_WEEK_CYCLE=\"$(( ($(date +%s) / 604800 - 3) % 6 ))\"\n-# ^ 1970 Jan 1st is a Thursday, and our release dates are also on Thursdays,\n-#   thus we could divide by 604800 (7 days in seconds) directly.\n+SIX_WEEK_CYCLE=\"$(( ($(date +%s) / 86400 - 20) % 42 ))\"\n+# ^ Number of days after the last promotion of beta.\n+#   Its value is 41 on the Tuesday where \"Promote master to beta (T-2)\" happens.\n+#   The Wednesday after this has value 0.\n+#   We track this value to prevent regressing tools in the last week of the 6-week cycle.\n \n touch \"$TOOLSTATE_FILE\"\n \n@@ -98,7 +100,7 @@ change_toolstate() {\n     if python2.7 \"$CHECK_NOT\" \"$OS\" \"$TOOLSTATE_FILE\" \"_data/latest.json\" changed; then\n         echo 'Toolstate is not changed. Not updating.'\n     else\n-        if [ $SIX_WEEK_CYCLE -eq 5 ]; then\n+        if [ $SIX_WEEK_CYCLE -ge 35 ]; then\n             python2.7 \"$CHECK_NOT\" \"$OS\" \"$TOOLSTATE_FILE\" \"_data/latest.json\" regressed\n         fi\n         sed -i \"1 a\\\\"}, {"sha": "009aba5f59869d0c01500a5f485fc633028c73e4", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -1258,7 +1258,7 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         let RefMut { value, borrow } = orig;\n         RefMut {\n             value: f(value),\n-            borrow: borrow,\n+            borrow,\n         }\n     }\n \n@@ -1324,7 +1324,7 @@ impl<'b> BorrowRefMut<'b> {\n         match borrow.get() {\n             UNUSED => {\n                 borrow.set(UNUSED - 1);\n-                Some(BorrowRefMut { borrow: borrow })\n+                Some(BorrowRefMut { borrow })\n             },\n             _ => None,\n         }\n@@ -1467,7 +1467,7 @@ impl<T> UnsafeCell<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub const fn new(value: T) -> UnsafeCell<T> {\n-        UnsafeCell { value: value }\n+        UnsafeCell { value }\n     }\n \n     /// Unwraps the value."}, {"sha": "5681cfb04f2088c1fece1a7ede7c9d835b3eb0b5", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -507,7 +507,7 @@ pub trait Iterator {\n     fn map<B, F>(self, f: F) -> Map<Self, F> where\n         Self: Sized, F: FnMut(Self::Item) -> B,\n     {\n-        Map{iter: self, f: f}\n+        Map { iter: self, f }\n     }\n \n     /// Calls a closure on each element of an iterator.\n@@ -618,7 +618,7 @@ pub trait Iterator {\n     fn filter<P>(self, predicate: P) -> Filter<Self, P> where\n         Self: Sized, P: FnMut(&Self::Item) -> bool,\n     {\n-        Filter{iter: self, predicate: predicate}\n+        Filter {iter: self, predicate }\n     }\n \n     /// Creates an iterator that both filters and maps.\n@@ -675,7 +675,7 @@ pub trait Iterator {\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n         Self: Sized, F: FnMut(Self::Item) -> Option<B>,\n     {\n-        FilterMap { iter: self, f: f }\n+        FilterMap { iter: self, f }\n     }\n \n     /// Creates an iterator which gives the current iteration count as well as\n@@ -828,7 +828,7 @@ pub trait Iterator {\n     fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where\n         Self: Sized, P: FnMut(&Self::Item) -> bool,\n     {\n-        SkipWhile{iter: self, flag: false, predicate: predicate}\n+        SkipWhile { iter: self, flag: false, predicate }\n     }\n \n     /// Creates an iterator that yields elements based on a predicate.\n@@ -908,7 +908,7 @@ pub trait Iterator {\n     fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n         Self: Sized, P: FnMut(&Self::Item) -> bool,\n     {\n-        TakeWhile{iter: self, flag: false, predicate: predicate}\n+        TakeWhile { iter: self, flag: false, predicate }\n     }\n \n     /// Creates an iterator that skips the first `n` elements.\n@@ -930,7 +930,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn skip(self, n: usize) -> Skip<Self> where Self: Sized {\n-        Skip{iter: self, n: n}\n+        Skip { iter: self, n }\n     }\n \n     /// Creates an iterator that yields its first `n` elements.\n@@ -962,7 +962,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, n: usize) -> Take<Self> where Self: Sized, {\n-        Take{iter: self, n: n}\n+        Take { iter: self, n }\n     }\n \n     /// An iterator adaptor similar to [`fold`] that holds internal state and\n@@ -1007,7 +1007,7 @@ pub trait Iterator {\n     fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>\n         where Self: Sized, F: FnMut(&mut St, Self::Item) -> Option<B>,\n     {\n-        Scan{iter: self, f: f, state: initial_state}\n+        Scan { iter: self, f, state: initial_state }\n     }\n \n     /// Creates an iterator that works like map, but flattens nested structure.\n@@ -1256,7 +1256,7 @@ pub trait Iterator {\n     fn inspect<F>(self, f: F) -> Inspect<Self, F> where\n         Self: Sized, F: FnMut(&Self::Item),\n     {\n-        Inspect{iter: self, f: f}\n+        Inspect { iter: self, f }\n     }\n \n     /// Borrows an iterator, rather than consuming it."}, {"sha": "e7ed94d4d91c2a0646dc7545849108bc4ae36582", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -40,7 +40,7 @@ pub struct Decimal<'a> {\n \n impl<'a> Decimal<'a> {\n     pub fn new(integral: &'a [u8], fractional: &'a [u8], exp: i64) -> Decimal<'a> {\n-        Decimal { integral: integral, fractional: fractional, exp: exp }\n+        Decimal { integral, fractional, exp }\n     }\n }\n "}, {"sha": "38f4e4687a99b6358b946eb7ced49fd7796bcb2e", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -45,7 +45,7 @@ pub struct Unpacked {\n \n impl Unpacked {\n     pub fn new(sig: u64, k: i16) -> Self {\n-        Unpacked { sig: sig, k: k }\n+        Unpacked { sig, k }\n     }\n }\n \n@@ -317,13 +317,13 @@ pub fn big_to_fp(f: &Big) -> Fp {\n     // We cut off all bits prior to the index `start`, i.e., we effectively right-shift by\n     // an amount of `start`, so this is also the exponent we need.\n     let e = start as i16;\n-    let rounded_down = Fp { f: leading, e: e }.normalize();\n+    let rounded_down = Fp { f: leading, e }.normalize();\n     // Round (half-to-even) depending on the truncated bits.\n     match num::compare_with_half_ulp(f, start) {\n         Less => rounded_down,\n         Equal if leading % 2 == 0 => rounded_down,\n         Equal | Greater => match leading.checked_add(1) {\n-            Some(f) => Fp { f: f, e: e }.normalize(),\n+            Some(f) => Fp { f, e }.normalize(),\n             None => Fp { f: 1 << 63, e: e + 1 },\n         }\n     }"}, {"sha": "b0561da5934c0be5fa06e8dd0b9ec7da27ab04da", "filename": "src/libcore/num/diy_float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fdiy_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fdiy_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdiy_float.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -42,7 +42,7 @@ impl Fp {\n         let tmp = (bd >> 32) + (ad & MASK) + (bc & MASK) + (1 << 31) /* round */;\n         let f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);\n         let e = self.e + other.e + 64;\n-        Fp { f: f, e: e }\n+        Fp { f, e }\n     }\n \n     /// Normalizes itself so that the resulting mantissa is at least `2^63`.\n@@ -74,7 +74,7 @@ impl Fp {\n             e -= 1;\n         }\n         debug_assert!(f >= (1 >> 63));\n-        Fp { f: f, e: e }\n+        Fp { f, e }\n     }\n \n     /// Normalizes itself to have the shared exponent."}, {"sha": "c34a56f288fd44c3555f6dabf3fe18e99a641306", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -77,8 +77,8 @@ pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n             // neighbors: (mant - 2, exp) -- (mant, exp) -- (mant + 2, exp)\n             // Float::integer_decode always preserves the exponent,\n             // so the mantissa is scaled for subnormals.\n-            FullDecoded::Finite(Decoded { mant: mant, minus: 1, plus: 1,\n-                                          exp: exp, inclusive: even })\n+            FullDecoded::Finite(Decoded { mant, minus: 1, plus: 1,\n+                                          exp, inclusive: even })\n         }\n         FpCategory::Normal => {\n             let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();"}, {"sha": "21a2e72dac8c37f7411b18841087689a37bc1b24", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -424,20 +424,20 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n     match full_decoded {\n         FullDecoded::Nan => {\n             parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n             if frac_digits > 0 { // [0.][0000]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(frac_digits);\n-                Formatted { sign: sign, parts: &parts[..2] }\n+                Formatted { sign, parts: &parts[..2] }\n             } else {\n                 parts[0] = Part::Copy(b\"0\");\n-                Formatted { sign: sign, parts: &parts[..1] }\n+                Formatted { sign, parts: &parts[..1] }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n@@ -480,19 +480,19 @@ pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n     match full_decoded {\n         FullDecoded::Nan => {\n             parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n             parts[0] = if dec_bounds.0 <= 0 && 0 < dec_bounds.1 {\n                 Part::Copy(b\"0\")\n             } else {\n                 Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" })\n             };\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Finite(ref decoded) => {\n             let (len, exp) = format_shortest(decoded, buf);\n@@ -502,7 +502,7 @@ pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n             } else {\n                 digits_to_exp_str(&buf[..len], exp, 0, upper, parts)\n             };\n-            Formatted { sign: sign, parts: parts }\n+            Formatted { sign, parts }\n         }\n     }\n }\n@@ -558,21 +558,21 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n     match full_decoded {\n         FullDecoded::Nan => {\n             parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n             if ndigits > 1 { // [0.][0000][e0]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(ndigits - 1);\n                 parts[2] = Part::Copy(if upper { b\"E0\" } else { b\"e0\" });\n-                Formatted { sign: sign, parts: &parts[..3] }\n+                Formatted { sign, parts: &parts[..3] }\n             } else {\n                 parts[0] = Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" });\n-                Formatted { sign: sign, parts: &parts[..1] }\n+                Formatted { sign, parts: &parts[..1] }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n@@ -613,20 +613,20 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n     match full_decoded {\n         FullDecoded::Nan => {\n             parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n             if frac_digits > 0 { // [0.][0000]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(frac_digits);\n-                Formatted { sign: sign, parts: &parts[..2] }\n+                Formatted { sign, parts: &parts[..2] }\n             } else {\n                 parts[0] = Part::Copy(b\"0\");\n-                Formatted { sign: sign, parts: &parts[..1] }\n+                Formatted { sign, parts: &parts[..1] }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n@@ -646,10 +646,10 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n                 if frac_digits > 0 { // [0.][0000]\n                     parts[0] = Part::Copy(b\"0.\");\n                     parts[1] = Part::Zero(frac_digits);\n-                    Formatted { sign: sign, parts: &parts[..2] }\n+                    Formatted { sign, parts: &parts[..2] }\n                 } else {\n                     parts[0] = Part::Copy(b\"0\");\n-                    Formatted { sign: sign, parts: &parts[..1] }\n+                    Formatted { sign, parts: &parts[..1] }\n                 }\n             } else {\n                 Formatted { sign,"}, {"sha": "effe073c3816c4936eabadc58944a62679c34f7f", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -129,7 +129,7 @@ pub fn cached_power(alpha: i16, gamma: i16) -> (i16, Fp) {\n     let idx = ((gamma as i32) - offset) * range / domain;\n     let (f, e, k) = CACHED_POW10[idx as usize];\n     debug_assert!(alpha <= e && e <= gamma);\n-    (k, Fp { f: f, e: e })\n+    (k, Fp { f, e })\n }\n \n /// Given `x > 0`, returns `(k, 10^k)` such that `10^k <= x < 10^(k+1)`."}, {"sha": "6e2fbf6f84f0f48a63832f877f69d78256362187", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 90, "deletions": 18, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -1892,47 +1892,119 @@ $EndFeature, \"\n             pub fn is_negative(self) -> bool { self < 0 }\n         }\n \n-        /// Return the memory representation of this integer as a byte array.\n+        /// Return the memory representation of this integer as a byte array in\n+        /// big-endian (network) byte order.\n         ///\n-        /// The target platform\u2019s native endianness is used.\n-        /// Portable code likely wants to use this after [`to_be`] or [`to_le`].\n+        /// # Examples\n         ///\n-        /// [`to_be`]: #method.to_be\n-        /// [`to_le`]: #method.to_le\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let bytes = 0x12345678i32.to_be_bytes();\n+        /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_be().to_ne_bytes()\n+        }\n+\n+        /// Return the memory representation of this integer as a byte array in\n+        /// little-endian byte order.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let bytes = 0x12345678i32.to_le_bytes();\n+        /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_le().to_ne_bytes()\n+        }\n+\n+        /// Return the memory representation of this integer as a byte array in\n+        /// native byte order.\n+        ///\n+        /// As the target platform's native endianness is used, portable code\n+        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n+        /// instead.\n+        ///\n+        /// [`to_be_bytes`]: #method.to_be_bytes\n+        /// [`to_le_bytes`]: #method.to_le_bytes\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let bytes = i32::min_value().to_be().to_bytes();\n+        /// let bytes = i32::min_value().to_be().to_ne_bytes();\n         /// assert_eq!(bytes, [0x80, 0, 0, 0]);\n         /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n-        pub fn to_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+        pub fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             unsafe { mem::transmute(self) }\n         }\n \n-        /// Create an integer value from its memory representation as a byte array.\n+        /// Create an integer value from its representation as a byte array in\n+        /// big endian.\n         ///\n-        /// The target platform\u2019s native endianness is used.\n-        /// Portable code likely wants to use [`from_be`] or [`from_le`] after this.\n+        /// # Examples\n         ///\n-        /// [`from_be`]: #method.from_be\n-        /// [`from_le`]: #method.from_le\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let int = i32::from_be_bytes([0x12, 0x34, 0x56, 0x78]);\n+        /// assert_eq!(int, 0x12_34_56_78);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_be(Self::from_ne_bytes(bytes))\n+        }\n+\n+        /// Create an integer value from its representation as a byte array in\n+        /// little endian.\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let int = i32::from_be(i32::from_bytes([0x80, 0, 0, 0]));\n+        /// let int = i32::from_le_bytes([0x12, 0x34, 0x56, 0x78]);\n+        /// assert_eq!(int, 0x78_56_34_12);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_le(Self::from_ne_bytes(bytes))\n+        }\n+\n+        /// Create an integer value from its memory representation as a byte\n+        /// array in native endianness.\n+        ///\n+        /// As the target platform's native endianness is used, portable code\n+        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+        /// appropriate instead.\n+        ///\n+        /// [`from_be_bytes`]: #method.from_be_bytes\n+        /// [`from_le_bytes`]: #method.from_le_bytes\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let int = i32::from_be(i32::from_ne_bytes([0x80, 0, 0, 0]));\n         /// assert_eq!(int, i32::min_value());\n         /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n-        pub fn from_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+        pub fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             unsafe { mem::transmute(bytes) }\n         }\n     }\n@@ -3517,7 +3589,7 @@ $EndFeature, \"\n         /// let bytes = 0x1234_5678_u32.to_be().to_bytes();\n         /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n         /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n         pub fn to_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             unsafe { mem::transmute(self) }\n@@ -3539,7 +3611,7 @@ $EndFeature, \"\n         /// let int = u32::from_be(u32::from_bytes([0x12, 0x34, 0x56, 0x78]));\n         /// assert_eq!(int, 0x1234_5678_u32);\n         /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n         pub fn from_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             unsafe { mem::transmute(bytes) }"}, {"sha": "c8670e5ec34d347b9f2f5aef6180ee29f10a0b4f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -448,6 +448,12 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n ///\n+/// Just like in C, whether an operation is volatile has no bearing whatsoever\n+/// on questions involving concurrent access from multiple threads. Volatile\n+/// accesses behave exactly like non-atomic accesses in that regard. In particular,\n+/// a race between a `read_volatile` and any write operation to the same location\n+/// is undefined behavior.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -498,6 +504,12 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n ///\n+/// Just like in C, whether an operation is volatile has no bearing whatsoever\n+/// on questions involving concurrent access from multiple threads. Volatile\n+/// accesses behave exactly like non-atomic accesses in that regard. In particular,\n+/// a race between a `write_volatile` and any other operation (reading or writing)\n+/// on the same location is undefined behavior.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -1057,6 +1069,12 @@ impl<T: ?Sized> *const T {\n     /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n+    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n+    /// on questions involving concurrent access from multiple threads. Volatile\n+    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n+    /// a race between a `read_volatile` and any write operation to the same location\n+    /// is undefined behavior.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1790,6 +1808,12 @@ impl<T: ?Sized> *mut T {\n     /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n+    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n+    /// on questions involving concurrent access from multiple threads. Volatile\n+    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n+    /// a race between a `read_volatile` and any write operation to the same location\n+    /// is undefined behavior.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -2105,6 +2129,12 @@ impl<T: ?Sized> *mut T {\n     /// This is appropriate for initializing uninitialized memory, or overwriting\n     /// memory that has previously been `read` from.\n     ///\n+    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n+    /// on questions involving concurrent access from multiple threads. Volatile\n+    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n+    /// a race between a `write_volatile` and any other operation (reading or writing)\n+    /// on the same location is undefined behavior.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:"}, {"sha": "dfebe460ff80150eb1f44e1075f723d18e6fb9ce", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -621,7 +621,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn windows(&self, size: usize) -> Windows<T> {\n         assert!(size != 0);\n-        Windows { v: self, size: size }\n+        Windows { v: self, size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a\n@@ -652,7 +652,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n         assert!(chunk_size != 0);\n-        Chunks { v: self, chunk_size: chunk_size }\n+        Chunks { v: self, chunk_size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n@@ -687,7 +687,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n         assert!(chunk_size != 0);\n-        ChunksMut { v: self, chunk_size: chunk_size }\n+        ChunksMut { v: self, chunk_size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a\n@@ -724,7 +724,7 @@ impl<T> [T] {\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n         let (fst, snd) = self.split_at(len);\n-        ExactChunks { v: fst, rem: snd, chunk_size: chunk_size}\n+        ExactChunks { v: fst, rem: snd, chunk_size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n@@ -766,7 +766,7 @@ impl<T> [T] {\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n         let (fst, snd) = self.split_at_mut(len);\n-        ExactChunksMut { v: fst, rem: snd, chunk_size: chunk_size}\n+        ExactChunksMut { v: fst, rem: snd, chunk_size }\n     }\n \n     /// Divides one slice into two at an index.\n@@ -916,7 +916,7 @@ impl<T> [T] {\n     pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n         where F: FnMut(&T) -> bool\n     {\n-        SplitMut { v: self, pred: pred, finished: false }\n+        SplitMut { v: self, pred, finished: false }\n     }\n \n     /// Returns an iterator over subslices separated by elements that match"}, {"sha": "121f93b666bcecbe3dbe4e180e1a68e5fa33473b", "filename": "src/libcore/task/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Ftask%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Ftask%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fcontext.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -86,7 +86,7 @@ impl<'a> Context<'a> {\n     {\n         Context {\n             local_waker: self.local_waker,\n-            executor: executor,\n+            executor,\n         }\n     }\n }"}, {"sha": "b58920224eb702217dd6009740fe5c11b0ea0ae7", "filename": "src/libcore/time.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -91,7 +91,7 @@ impl Duration {\n         let secs = secs.checked_add((nanos / NANOS_PER_SEC) as u64)\n             .expect(\"overflow in Duration::new\");\n         let nanos = nanos % NANOS_PER_SEC;\n-        Duration { secs: secs, nanos: nanos }\n+        Duration { secs, nanos }\n     }\n \n     /// Creates a new `Duration` from the specified number of whole seconds.\n@@ -109,7 +109,7 @@ impl Duration {\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub const fn from_secs(secs: u64) -> Duration {\n-        Duration { secs: secs, nanos: 0 }\n+        Duration { secs, nanos: 0 }\n     }\n \n     /// Creates a new `Duration` from the specified number of milliseconds.\n@@ -387,7 +387,7 @@ impl Duration {\n                 }\n             };\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration { secs: secs, nanos: nanos })\n+            Some(Duration { secs, nanos })\n         } else {\n             None\n         }\n@@ -453,7 +453,7 @@ impl Duration {\n             let extra_nanos = carry * (NANOS_PER_SEC as u64) / (rhs as u64);\n             let nanos = self.nanos / rhs + (extra_nanos as u32);\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration { secs: secs, nanos: nanos })\n+            Some(Duration { secs, nanos })\n         } else {\n             None\n         }"}, {"sha": "4ef4397d974c420254d2b3b465690a56a298d285", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -84,7 +84,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n                         let condition_span = cx.tcx.sess.codemap().def_span(e.span);\n                         let mut err = cx.struct_span_lint(WHILE_TRUE, condition_span, msg);\n-                        err.span_suggestion_short(condition_span, \"use `loop`\", \"loop\".to_owned());\n+                        err.span_suggestion_short_with_applicability(\n+                            condition_span,\n+                            \"use `loop`\",\n+                            \"loop\".to_owned(),\n+                            Applicability::MachineApplicable\n+                        );\n                         err.emit();\n                     }\n                 }\n@@ -191,7 +196,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                                      fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant\", ident));\n                         let subspan = cx.tcx.sess.codemap().span_through_char(fieldpat.span, ':');\n-                        err.span_suggestion_short(subspan, \"remove this\", ident.to_string());\n+                        err.span_suggestion_short_with_applicability(\n+                            subspan,\n+                            \"remove this\",\n+                            ident.to_string(),\n+                            Applicability::MachineApplicable\n+                        );\n                         err.emit();\n                     }\n                 }\n@@ -708,10 +718,11 @@ impl EarlyLintPass for BadRepr {\n                         | \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"i128\" | \"isize\" => {\n                             // if the literal could have been a valid `repr` arg,\n                             // suggest the correct syntax\n-                            warn.span_suggestion(\n+                            warn.span_suggestion_with_applicability(\n                                 attr.span,\n                                 \"give `repr` a hint\",\n                                 repr_str(&lit.as_str()),\n+                                Applicability::MachineApplicable\n                             );\n                             suggested = true;\n                         }\n@@ -779,7 +790,12 @@ impl EarlyLintPass for DeprecatedAttr {\n                     let msg = format!(\"use of deprecated attribute `{}`: {}. See {}\",\n                                       name, reason, link);\n                     let mut err = cx.struct_span_lint(DEPRECATED, attr.span, &msg);\n-                    err.span_suggestion_short(attr.span, \"remove this attribute\", \"\".to_owned());\n+                    err.span_suggestion_short_with_applicability(\n+                        attr.span,\n+                        \"remove this attribute\",\n+                        \"\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    );\n                     err.emit();\n                 }\n                 return;\n@@ -1201,7 +1217,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                 }\n             };\n             if let Some(replacement) = suggestion {\n-                err.span_suggestion(vis.span, \"try making it public\", replacement);\n+                err.span_suggestion_with_applicability(\n+                    vis.span,\n+                    \"try making it public\",\n+                    replacement,\n+                    Applicability::MachineApplicable\n+                );\n             }\n         };\n \n@@ -1225,9 +1246,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                                                                   it.span,\n                                                                   \"functions generic over \\\n                                                                    types must be mangled\");\n-                                err.span_suggestion_short(no_mangle_attr.span,\n-                                                          \"remove this attribute\",\n-                                                          \"\".to_owned());\n+                                err.span_suggestion_short_with_applicability(\n+                                    no_mangle_attr.span,\n+                                    \"remove this attribute\",\n+                                    \"\".to_owned(),\n+                                    // Use of `#[no_mangle]` suggests FFI intent; correct\n+                                    // fix may be to monomorphize source by hand\n+                                    Applicability::MaybeIncorrect\n+                                );\n                                 err.emit();\n                                 break;\n                             }\n@@ -1257,9 +1283,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                         .unwrap_or(0) as u32;\n                     // `const` is 5 chars\n                     let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n-                    err.span_suggestion(const_span,\n-                                        \"try a static value\",\n-                                        \"pub static\".to_owned());\n+                    err.span_suggestion_with_applicability(\n+                        const_span,\n+                        \"try a static value\",\n+                        \"pub static\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    );\n                     err.emit();\n                 }\n             }"}, {"sha": "4dc66fb812144d884476b0d5ef354824caee9ae9", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -22,6 +22,7 @@ use std::cmp;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n use syntax::{ast, attr};\n+use syntax::errors::Applicability;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::Span;\n use syntax::codemap;\n@@ -143,9 +144,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                                              OVERFLOWING_LITERALS,\n                                                              parent_expr.span,\n                                                              \"only u8 can be cast into char\");\n-                                        err.span_suggestion(parent_expr.span,\n-                                                            &\"use a char literal instead\",\n-                                                            format!(\"'\\\\u{{{:X}}}'\", lit_val));\n+                                        err.span_suggestion_with_applicability(\n+                                            parent_expr.span,\n+                                            &\"use a char literal instead\",\n+                                            format!(\"'\\\\u{{{:X}}}'\", lit_val),\n+                                            Applicability::MachineApplicable\n+                                        );\n                                         err.emit();\n                                         return\n                                     }\n@@ -398,10 +402,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             {\n                 if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n                     let (sans_suffix, _) = repr_str.split_at(pos);\n-                    err.span_suggestion(\n+                    err.span_suggestion_with_applicability(\n                         expr.span,\n                         &format!(\"consider using `{}` instead\", sugg_ty),\n                         format!(\"{}{}\", sans_suffix, sugg_ty),\n+                        Applicability::MachineApplicable\n                     );\n                 } else {\n                     err.help(&format!(\"consider using `{}` instead\", sugg_ty));"}, {"sha": "2b8540ea3861a25761de61597d1cae79f8ebefc6", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -17,6 +17,7 @@ use lint::{LintPass, EarlyLintPass, LateLintPass};\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::errors::Applicability;\n use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n use syntax::print::pprust;\n use syntax::symbol::keywords;\n@@ -303,9 +304,12 @@ impl UnusedParens {\n                             _ => false,\n                         }\n                     }).to_owned();\n-                err.span_suggestion_short(value.span,\n-                                          \"remove these parentheses\",\n-                                          parens_removed);\n+                err.span_suggestion_short_with_applicability(\n+                    value.span,\n+                    \"remove these parentheses\",\n+                    parens_removed,\n+                    Applicability::MachineApplicable\n+                );\n                 err.emit();\n             }\n         }"}, {"sha": "5c3a016a82b4c599955f62c1204333966b530bc3", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -1015,7 +1015,7 @@ struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path: &hir::Path) -> bool {\n         let did = match path.def {\n-            Def::PrimTy(..) | Def::SelfTy(..) => return false,\n+            Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => return false,\n             def => def.def_id(),\n         };\n "}, {"sha": "496029e33fc65cebf2541ec3155aa68b1a788d5a", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -610,11 +610,16 @@ a {\n \n .content .search-results td:first-child {\n \tpadding-right: 0;\n-\twidth: 75%;\n+\twidth: 50%;\n }\n .content .search-results td:first-child a {\n \tpadding-right: 10px;\n }\n+.content .search-results td:first-child a:after {\n+    clear: both;\n+    content: \"\";\n+    display: block;\n+}\n .content .search-results td:first-child a span {\n \tfloat: left;\n }"}, {"sha": "faca264ea1006c47467f224a07053e13457748af", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -33,7 +33,7 @@ h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.t\n \tbackground: rgba(0, 0, 0, 0);\n }\n \n-.docblock p > code, .docblock-short p > code {\n+.docblock code, .docblock-short code {\n \tbackground-color: #2A2A2A;\n }\n pre {"}, {"sha": "5725a41d939d55947b321e74944e04fa7abb72d0", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -35,7 +35,7 @@ h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.t\n \tbackground: rgba(0, 0, 0, 0);\n }\n \n-.docblock p > code, .docblock-short p > code {\n+.docblock code, .docblock-short code {\n \tbackground-color: #F5F5F5;\n }\n pre {"}, {"sha": "dda97cfdb2c4b7cfb8ae1cce29914ace90affac1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -290,7 +290,7 @@ fn opts() -> Vec<RustcOptGroup> {\n                      \"edition to use when compiling rust code (default: 2015)\",\n                      \"EDITION\")\n         }),\n-        unstable(\"color\", |o| {\n+        stable(\"color\", |o| {\n             o.optopt(\"\",\n                      \"color\",\n                      \"Configure coloring of output:\n@@ -299,7 +299,7 @@ fn opts() -> Vec<RustcOptGroup> {\n                                           never  = never colorize output\",\n                      \"auto|always|never\")\n         }),\n-        unstable(\"error-format\", |o| {\n+        stable(\"error-format\", |o| {\n             o.optopt(\"\",\n                      \"error-format\",\n                      \"How errors and other messages are produced\","}, {"sha": "12ea1ea9f9d49cc56a0ef0c4b3890647cd6a5013", "filename": "src/libstd/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -108,9 +108,9 @@ where\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Polls a future in the current thread-local task context.\n-pub fn poll_in_task_cx<F>(f: &mut PinMut<F>) -> Poll<F::Output>\n+pub fn poll_in_task_cx<F>(f: PinMut<F>) -> Poll<F::Output>\n where\n     F: Future\n {\n-    get_task_cx(|cx| f.reborrow().poll(cx))\n+    get_task_cx(|cx| f.poll(cx))\n }"}, {"sha": "f15494c5fd7f59beeab250014135eeb81f1ef5da", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -227,14 +227,17 @@ macro_rules! eprintln {\n macro_rules! await {\n     ($e:expr) => { {\n         let mut pinned = $e;\n-        let mut pinned = unsafe { $crate::mem::PinMut::new_unchecked(&mut pinned) };\n         loop {\n-            match $crate::future::poll_in_task_cx(&mut pinned) {\n-                // FIXME(cramertj) prior to stabilizing await, we have to ensure that this\n-                // can't be used to create a generator on stable via `|| await!()`.\n-                $crate::task::Poll::Pending => yield,\n-                $crate::task::Poll::Ready(x) => break x,\n+            if let $crate::task::Poll::Ready(x) =\n+                $crate::future::poll_in_task_cx(unsafe {\n+                    $crate::mem::PinMut::new_unchecked(&mut pinned)\n+                })\n+            {\n+                break x;\n             }\n+            // FIXME(cramertj) prior to stabilizing await, we have to ensure that this\n+            // can't be used to create a generator on stable via `|| await!()`.\n+            yield\n         }\n     } }\n }"}, {"sha": "3abc260b4586878b8d17b139e1a2e8387c2d20e1", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -178,6 +178,10 @@ impl Once {\n     /// happens-before relation between the closure and code executing after the\n     /// return).\n     ///\n+    /// If the given closure recusively invokes `call_once` on the same `Once`\n+    /// instance the exact behavior is not specified, allowed outcomes are\n+    /// a panic or a deadlock.\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "2a9bd2948ffeb4fbe96302fe80957a6d4ddf7632", "filename": "src/test/ui/lint/unused_parens_json_suggestion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/215bf3abd9c0eb1fd0c6cae7c92a842732dc033d/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_json_suggestion.stderr?ref=215bf3abd9c0eb1fd0c6cae7c92a842732dc033d", "patch": "@@ -82,7 +82,7 @@\n           ],\n           \"label\": null,\n           \"suggested_replacement\": \"1 / (2 + 3)\",\n-          \"suggestion_applicability\": \"Unspecified\",\n+          \"suggestion_applicability\": \"MachineApplicable\",\n           \"expansion\": null\n         }\n       ],"}]}