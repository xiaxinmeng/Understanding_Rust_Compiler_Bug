{"sha": "a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MTQ2ZDM1YjE2MTVjZjVmYjkwOGIyOWYzNGU1OGJmZGUzYmY5NmQ=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-10T12:54:58Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-14T12:52:55Z"}, "message": "Implement type inference for literals (WIP)", "tree": {"sha": "70613ee98eee67c1df6aff1e663be75a33c348f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70613ee98eee67c1df6aff1e663be75a33c348f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "html_url": "https://github.com/rust-lang/rust/commit/a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8caff4e03475c20392f13e8c6ad469bd01a4b4ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/8caff4e03475c20392f13e8c6ad469bd01a4b4ce", "html_url": "https://github.com/rust-lang/rust/commit/8caff4e03475c20392f13e8c6ad469bd01a4b4ce"}], "stats": {"total": 171, "additions": 166, "deletions": 5}, "files": [{"sha": "e07725d0586be920d1686fdd88c80d3fe7b7ad9a", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "patch": "@@ -5,7 +5,10 @@ use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_db::{LocalSyntaxPtr, Cancelable};\n-use ra_syntax::ast::{self, AstNode, LoopBodyOwner, ArgListOwner, NameOwner};\n+use ra_syntax::{\n+    SyntaxKind,\n+    ast::{self, AstNode, LoopBodyOwner, ArgListOwner, NameOwner}\n+};\n \n use crate::{Path, type_ref::{Mutability, TypeRef}, Name, HirDatabase, DefId, Def, name::AsName};\n \n@@ -103,6 +106,19 @@ impl BodySyntaxMapping {\n     }\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Literal {\n+    String(String),\n+    ByteString(Vec<u8>),\n+    Char(char),\n+    Bool(bool),\n+    Byte(u8),\n+    Int, // this and float need additional information\n+    Float,\n+    Tuple { values: Vec<ExprId> },\n+    Array { values: Vec<ExprId> },\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Expr {\n     /// This is produced if syntax tree does not have a required expression piece.\n@@ -186,6 +202,7 @@ pub enum Expr {\n     Tuple {\n         exprs: Vec<ExprId>,\n     },\n+    Literal(Literal),\n }\n \n pub use ra_syntax::ast::PrefixOp as UnaryOp;\n@@ -305,6 +322,20 @@ impl Expr {\n                     f(*expr);\n                 }\n             }\n+            Expr::Literal(l) => match l {\n+                Literal::Array { values } | Literal::Tuple { values } => {\n+                    for &val in values {\n+                        f(val);\n+                    }\n+                }\n+                Literal::String(..)\n+                | Literal::ByteString(..)\n+                | Literal::Byte(..)\n+                | Literal::Bool(..)\n+                | Literal::Char(..)\n+                | Literal::Int\n+                | Literal::Float => {}\n+            },\n         }\n     }\n }\n@@ -633,13 +664,56 @@ impl ExprCollector {\n                 let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n                 self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n             }\n+            ast::ExprKind::Literal(e) => {\n+                let child = e.syntax().children().next();\n+\n+                if let Some(c) = child {\n+                    let lit = match c.kind() {\n+                        SyntaxKind::INT_NUMBER => Literal::Int,\n+                        SyntaxKind::FLOAT_NUMBER => Literal::Float,\n+                        SyntaxKind::STRING => {\n+                            // FIXME: this likely includes the \" characters\n+                            let text = c.text().to_string();\n+                            Literal::String(text)\n+                        }\n+                        SyntaxKind::ARRAY_EXPR => {\n+                            // TODO: recursively call to self\n+                            Literal::Array { values: vec![] }\n+                        }\n+                        SyntaxKind::PAREN_EXPR => {\n+                            // TODO: recursively call to self\n+                            Literal::Tuple { values: vec![] }\n+                        }\n+                        SyntaxKind::TRUE_KW => Literal::Bool(true),\n+                        SyntaxKind::FALSE_KW => Literal::Bool(false),\n+                        SyntaxKind::BYTE_STRING => {\n+                            // FIXME: this is completely incorrect for a variety\n+                            // of reasons, but at least it gives the right type\n+                            let bytes = c.text().to_string().into_bytes();\n+                            Literal::ByteString(bytes)\n+                        }\n+                        SyntaxKind::CHAR => {\n+                            let character = c.text().char_at(1).unwrap_or('X');\n+                            Literal::Char(character)\n+                        }\n+                        SyntaxKind::BYTE => {\n+                            let character = c.text().char_at(1).unwrap_or('X');\n+                            Literal::Byte(character as u8)\n+                        }\n+                        _ => return self.alloc_expr(Expr::Missing, syntax_ptr),\n+                    };\n+\n+                    self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n+                } else {\n+                    self.alloc_expr(Expr::Missing, syntax_ptr)\n+                }\n+            }\n \n             // TODO implement HIR for these:\n             ast::ExprKind::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::ArrayExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::ExprKind::Literal(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n         }\n     }\n "}, {"sha": "0baa205a17f9c62b618b691f3440855f688ee013", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "patch": "@@ -38,7 +38,7 @@ use crate::{\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n-    expr::{Body, Expr, ExprId, PatId, UnaryOp, BinaryOp, Statement},\n+    expr::{Body, Expr, Literal, ExprId, PatId, UnaryOp, BinaryOp, Statement},\n };\n \n fn transpose<T>(x: Cancelable<Option<T>>) -> Option<Cancelable<T>> {\n@@ -1067,6 +1067,37 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 Ty::Tuple(Arc::from(ty_vec))\n             }\n+            Expr::Literal(lit) => match lit {\n+                Literal::Bool(..) => Ty::Bool,\n+                Literal::String(..) => Ty::Ref(Arc::new(Ty::Str), Mutability::Shared),\n+                Literal::ByteString(..) => {\n+                    let byte_type = Arc::new(Ty::Uint(primitive::UintTy::U8));\n+                    let slice_type = Arc::new(Ty::Slice(byte_type));\n+                    Ty::Ref(slice_type, Mutability::Shared)\n+                }\n+                Literal::Byte(..) => Ty::Uint(primitive::UintTy::U8),\n+                Literal::Char(..) => Ty::Char,\n+                Literal::Tuple { values } => {\n+                    let mut inner_tys = Vec::new();\n+                    for &expr in values {\n+                        let inner_ty = self.infer_expr(expr, &Expectation::none())?;\n+                        inner_tys.push(inner_ty);\n+                    }\n+                    Ty::Tuple(Arc::from(inner_tys))\n+                }\n+                Literal::Array { values } => {\n+                    // simply take the type of the first element for now\n+                    let inner_ty = match values.get(0) {\n+                        Some(&expr) => self.infer_expr(expr, &Expectation::none())?,\n+                        None => Ty::Unknown,\n+                    };\n+                    // TODO: we should return a Ty::Array when it becomes\n+                    // available\n+                    Ty::Slice(Arc::new(inner_ty))\n+                }\n+                // TODO\n+                Literal::Int | Literal::Float => Ty::Unknown,\n+            },\n         };\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);"}, {"sha": "97d3d222fa5e3e531d7a858f6eada4838b178d2f", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "patch": "@@ -132,6 +132,26 @@ fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n     );\n }\n \n+#[test]\n+fn infer_literals() {\n+    check_inference(\n+        r#\"\n+fn test() {\n+    5i32;\n+    \"hello\";\n+    b\"bytes\";\n+    'c';\n+    b'b';\n+    3.14;\n+    5000;\n+    (0u32, -5isize);\n+    [true, true, false]\n+}\n+\"#,\n+        \"literals.txt\",\n+    );\n+}\n+\n #[test]\n fn infer_backwards() {\n     check_inference("}, {"sha": "e02947ba8bbd18e05220b05353361d9bd4e58c25", "filename": "crates/ra_hir/src/ty/tests/data/basics.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt?ref=a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "patch": "@@ -9,5 +9,5 @@\n [69; 70) 'd': &str\n [76; 82) '1usize': [unknown]\n [88; 94) '1isize': [unknown]\n-[100; 106) '\"test\"': [unknown]\n+[100; 106) '\"test\"': &str\n [112; 118) '1.0f32': [unknown]"}, {"sha": "8b22eee31866f9e901a78c965f7dde61cf80061e", "filename": "crates/ra_hir/src/ty/tests/data/literals.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt?ref=a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "patch": "@@ -0,0 +1,10 @@\n+[11; 135) '{     ...lse] }': ()\n+[17; 21) '5i32': [unknown]\n+[27; 34) '\"hello\"': &str\n+[40; 48) 'b\"bytes\"': &[u8]\n+[54; 57) ''c'': char\n+[63; 67) 'b'b'': u8\n+[73; 77) '3.14': [unknown]\n+[83; 87) '5000': [unknown]\n+[93; 108) '(0u32, -5isize)': [unknown]\n+[114; 133) '[true,...false]': ()"}, {"sha": "6181df9d7d6e7565d3a5710e78b450c5cf35a32f", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "patch": "@@ -59,24 +59,29 @@ impl SourceFile {\n         assert_eq!(root.kind(), SyntaxKind::SOURCE_FILE);\n         TreeArc::cast(root)\n     }\n+    \n     pub fn parse(text: &str) -> TreeArc<SourceFile> {\n         let tokens = tokenize(&text);\n         let (green, errors) =\n             parser_impl::parse_with(yellow::GreenBuilder::new(), text, &tokens, grammar::root);\n         SourceFile::new(green, errors)\n     }\n+\n     pub fn reparse(&self, edit: &AtomTextEdit) -> TreeArc<SourceFile> {\n         self.incremental_reparse(edit)\n             .unwrap_or_else(|| self.full_reparse(edit))\n     }\n+\n     pub fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<TreeArc<SourceFile>> {\n         reparsing::incremental_reparse(self.syntax(), edit, self.errors())\n             .map(|(green_node, errors)| SourceFile::new(green_node, errors))\n     }\n+\n     fn full_reparse(&self, edit: &AtomTextEdit) -> TreeArc<SourceFile> {\n         let text = edit.apply(self.syntax().text().to_string());\n         SourceFile::parse(&text)\n     }\n+\n     pub fn errors(&self) -> Vec<SyntaxError> {\n         let mut errors = self.syntax.root_data().clone();\n         errors.extend(validation::validate(self));"}, {"sha": "03df00fc6662e1ff22d02ce93d79094768d0f060", "filename": "crates/ra_syntax/src/yellow.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow.rs?ref=a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "patch": "@@ -128,40 +128,52 @@ impl SyntaxNode {\n     pub(crate) fn root_data(&self) -> &Vec<SyntaxError> {\n         self.0.root_data()\n     }\n+    \n     pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n         self.0.replace_self(replacement)\n     }\n+\n     pub fn to_owned(&self) -> TreeArc<SyntaxNode> {\n         let ptr = TreeArc(self.0.to_owned());\n         TreeArc::cast(ptr)\n     }\n+\n     pub fn kind(&self) -> SyntaxKind {\n         self.0.kind()\n     }\n+\n     pub fn range(&self) -> TextRange {\n         self.0.range()\n     }\n+\n     pub fn text(&self) -> SyntaxText {\n         SyntaxText::new(self)\n     }\n+\n     pub fn is_leaf(&self) -> bool {\n         self.0.is_leaf()\n     }\n+\n     pub fn parent(&self) -> Option<&SyntaxNode> {\n         self.0.parent().map(SyntaxNode::from_repr)\n     }\n+\n     pub fn first_child(&self) -> Option<&SyntaxNode> {\n         self.0.first_child().map(SyntaxNode::from_repr)\n     }\n+\n     pub fn last_child(&self) -> Option<&SyntaxNode> {\n         self.0.last_child().map(SyntaxNode::from_repr)\n     }\n+\n     pub fn next_sibling(&self) -> Option<&SyntaxNode> {\n         self.0.next_sibling().map(SyntaxNode::from_repr)\n     }\n+\n     pub fn prev_sibling(&self) -> Option<&SyntaxNode> {\n         self.0.prev_sibling().map(SyntaxNode::from_repr)\n     }\n+\n     pub fn children(&self) -> SyntaxNodeChildren {\n         SyntaxNodeChildren(self.0.children())\n     }"}, {"sha": "378cd1b2e21c6ad888d67f70e3720fdbd7f5becd", "filename": "crates/ra_syntax/src/yellow/syntax_text.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6146d35b1615cf5fb908b29f34e58bfde3bf96d/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs?ref=a6146d35b1615cf5fb908b29f34e58bfde3bf96d", "patch": "@@ -15,6 +15,7 @@ impl<'a> SyntaxText<'a> {\n             range: node.range(),\n         }\n     }\n+\n     pub fn chunks(&self) -> impl Iterator<Item = &'a str> {\n         let range = self.range;\n         self.node.descendants().filter_map(move |node| {\n@@ -24,15 +25,19 @@ impl<'a> SyntaxText<'a> {\n             Some(&text[range])\n         })\n     }\n+\n     pub fn push_to(&self, buf: &mut String) {\n         self.chunks().for_each(|it| buf.push_str(it));\n     }\n+\n     pub fn to_string(&self) -> String {\n         self.chunks().collect()\n     }\n+\n     pub fn contains(&self, c: char) -> bool {\n         self.chunks().any(|it| it.contains(c))\n     }\n+\n     pub fn find(&self, c: char) -> Option<TextUnit> {\n         let mut acc: TextUnit = 0.into();\n         for chunk in self.chunks() {\n@@ -44,9 +49,11 @@ impl<'a> SyntaxText<'a> {\n         }\n         None\n     }\n+\n     pub fn len(&self) -> TextUnit {\n         self.range.len()\n     }\n+\n     pub fn slice(&self, range: impl SyntaxTextSlice) -> SyntaxText<'a> {\n         let range = range.restrict(self.range).unwrap_or_else(|| {\n             panic!(\"invalid slice, range: {:?}, slice: {:?}\", self.range, range)\n@@ -56,8 +63,10 @@ impl<'a> SyntaxText<'a> {\n             range,\n         }\n     }\n-    pub fn char_at(&self, offset: TextUnit) -> Option<char> {\n+\n+    pub fn char_at(&self, offset: impl Into<TextUnit>) -> Option<char> {\n         let mut start: TextUnit = 0.into();\n+        let offset = offset.into();\n         for chunk in self.chunks() {\n             let end = start + TextUnit::of_str(chunk);\n             if start <= offset && offset < end {"}]}