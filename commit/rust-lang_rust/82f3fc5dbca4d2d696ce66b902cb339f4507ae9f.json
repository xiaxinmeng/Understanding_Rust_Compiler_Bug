{"sha": "82f3fc5dbca4d2d696ce66b902cb339f4507ae9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZjNmYzVkYmNhNGQyZDY5NmNlNjZiOTAyY2IzMzlmNDUwN2FlOWY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-04T11:01:50Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-05T22:34:02Z"}, "message": "fix handling of immutable variables", "tree": {"sha": "389f01b3827698e5cf12bf3af29470043996b87d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/389f01b3827698e5cf12bf3af29470043996b87d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82f3fc5dbca4d2d696ce66b902cb339f4507ae9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82f3fc5dbca4d2d696ce66b902cb339f4507ae9f", "html_url": "https://github.com/rust-lang/rust/commit/82f3fc5dbca4d2d696ce66b902cb339f4507ae9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82f3fc5dbca4d2d696ce66b902cb339f4507ae9f/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "210f76816fe54ff43ed7eca91a78096589fae953", "url": "https://api.github.com/repos/rust-lang/rust/commits/210f76816fe54ff43ed7eca91a78096589fae953", "html_url": "https://github.com/rust-lang/rust/commit/210f76816fe54ff43ed7eca91a78096589fae953"}], "stats": {"total": 44, "additions": 28, "deletions": 16}, "files": [{"sha": "0f4585c8c040a467fc2585da274a0d97f59f6d60", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/82f3fc5dbca4d2d696ce66b902cb339f4507ae9f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f3fc5dbca4d2d696ce66b902cb339f4507ae9f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=82f3fc5dbca4d2d696ce66b902cb339f4507ae9f", "patch": "@@ -655,8 +655,9 @@ enum WriteKind {\n /// - Take flow state into consideration in `is_assignable()` for local variables\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum LocalMutationIsAllowed {\n+    Move,\n     Yes,\n-    No,\n+    No\n }\n \n #[derive(Copy, Clone)]\n@@ -946,7 +947,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     context,\n                     (place, span),\n                     (Deep, Write(WriteKind::Move)),\n-                    LocalMutationIsAllowed::Yes,\n+                    LocalMutationIsAllowed::Move,\n                     flow_state,\n                 );\n \n@@ -1368,7 +1369,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n-                        LocalMutationIsAllowed::Yes => Ok(()),\n+                        LocalMutationIsAllowed::Yes |\n+                        LocalMutationIsAllowed::Move => Ok(()),\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n                     Mutability::Mut => Ok(()),\n@@ -1393,10 +1395,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        if self.is_upvar_field_projection(&proj.base).is_some() {\n-                                            self.is_mutable(&proj.base, is_local_mutation_allowed)\n-                                        } else {\n-                                            self.is_unique(&proj.base)\n+                                        match self.is_upvar_field_projection(&proj.base) {\n+                                            Some(field) if {\n+                                                self.mir.upvar_decls[field.index()].by_ref\n+                                            } => {\n+                                                self.is_mutable(&proj.base,\n+                                                                is_local_mutation_allowed)\n+                                            }\n+                                            _ => self.is_unique(&proj.base)\n                                         }\n                                     }\n                                 }\n@@ -1412,7 +1418,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n                             _ if base_ty.is_box() => {\n-                                self.is_mutable(&proj.base, LocalMutationIsAllowed::No)\n+                                self.is_mutable(&proj.base, is_local_mutation_allowed)\n                             }\n                             // Deref should only be for reference, pointers or boxes\n                             _ => bug!(\"Deref of unexpected type: {:?}\", base_ty),\n@@ -1429,14 +1435,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                         if let Some(field) = field_projection {\n                             let decl = &self.mir.upvar_decls[field.index()];\n-\n-                            return match decl.mutability {\n-                                Mutability::Mut => self.is_unique(&proj.base),\n-                                Mutability::Not => Err(place),\n+                            debug!(\"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n+                                   decl, is_local_mutation_allowed, place);\n+                            return match (decl.mutability, is_local_mutation_allowed) {\n+                                (Mutability::Not, LocalMutationIsAllowed::No) |\n+                                (Mutability::Not, LocalMutationIsAllowed::Yes) => Err(place),\n+                                (Mutability::Not, LocalMutationIsAllowed::Move) |\n+                                (Mutability::Mut, _) => self.is_unique(&proj.base),\n                             };\n                         }\n \n-                        self.is_mutable(&proj.base, LocalMutationIsAllowed::No)\n+                        self.is_mutable(&proj.base, is_local_mutation_allowed)\n                     }\n                 }\n             }\n@@ -1450,9 +1459,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // Local variables are unique\n                 Ok(())\n             }\n-            Place::Static(..) => {\n-                // Static variables are not\n-                Err(place)\n+            Place::Static(ref static_) => {\n+                if !self.tcx.is_static_mut(static_.def_id) {\n+                    Err(place)\n+                } else {\n+                    Ok(())\n+                }\n             }\n             Place::Projection(ref proj) => {\n                 match proj.elem {"}]}