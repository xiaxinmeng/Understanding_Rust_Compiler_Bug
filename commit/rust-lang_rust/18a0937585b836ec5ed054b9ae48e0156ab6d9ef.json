{"sha": "18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YTA5Mzc1ODViODM2ZWM1ZWQwNTRiOWFlNDhlMDE1NmFiNmQ5ZWY=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-28T07:19:14Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-28T07:19:14Z"}, "message": "Merge branch 'master' of https://github.com/rust-analyzer/rust-analyzer into feature/themes", "tree": {"sha": "9de2c0267ddcc00df717f90034d0843d751a851b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9de2c0267ddcc00df717f90034d0843d751a851b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "html_url": "https://github.com/rust-lang/rust/commit/18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7394b44c870f585eacfeb3036a33471aff49ff8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7394b44c870f585eacfeb3036a33471aff49ff8", "html_url": "https://github.com/rust-lang/rust/commit/a7394b44c870f585eacfeb3036a33471aff49ff8"}, {"sha": "484acc8a61d599662ed63a4cbda091d38a982551", "url": "https://api.github.com/repos/rust-lang/rust/commits/484acc8a61d599662ed63a4cbda091d38a982551", "html_url": "https://github.com/rust-lang/rust/commit/484acc8a61d599662ed63a4cbda091d38a982551"}], "stats": {"total": 6635, "additions": 3558, "deletions": 3077}, "files": [{"sha": "2557b5e59d3242321e1b10e6c932851735703ceb", "filename": "Cargo.lock", "status": "modified", "additions": 143, "deletions": 183, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -10,7 +10,7 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.22\"\n+version = \"1.0.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -105,9 +105,9 @@ version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -123,7 +123,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"chalk-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n+source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -133,67 +133,66 @@ dependencies = [\n [[package]]\n name = \"chalk-engine\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n+source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n dependencies = [\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stacker 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n+source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-macros\"\n version = \"0.1.1\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n+source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n dependencies = [\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-rust-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n+source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n+source = \"git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30#095cd38a4f16337913bba487f2055b9ca0179f30\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chrono\"\n-version = \"0.4.9\"\n+version = \"0.4.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-integer 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -227,7 +226,6 @@ dependencies = [\n  \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termios 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-width 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -292,16 +290,6 @@ dependencies = [\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"derive-new\"\n-version = \"0.5.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"difference\"\n version = \"2.0.0\"\n@@ -356,7 +344,7 @@ name = \"flexi_logger\"\n version = \"0.14.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"chrono 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"chrono 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -472,7 +460,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-normalization 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-normalization 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -483,17 +471,6 @@ dependencies = [\n  \"autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"indicatif\"\n-version = \"0.13.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"console 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"number_prefix 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"inotify\"\n version = \"0.6.1\"\n@@ -520,8 +497,8 @@ dependencies = [\n  \"console 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_yaml 0.8.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"uuid 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -536,7 +513,7 @@ dependencies = [\n \n [[package]]\n name = \"itertools\"\n-version = \"0.8.1\"\n+version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"either 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -622,7 +599,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"lock_api\"\n-version = \"0.3.1\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"scopeguard 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -643,8 +620,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-channel 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -653,8 +630,8 @@ version = \"0.61.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_repr 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -664,11 +641,6 @@ name = \"matches\"\n version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"maybe-uninit\"\n-version = \"2.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"memchr\"\n version = \"2.2.1\"\n@@ -684,9 +656,10 @@ dependencies = [\n \n [[package]]\n name = \"mio\"\n-version = \"0.6.19\"\n+version = \"0.6.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n+ \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"iovec 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -706,7 +679,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"mio 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mio 0.6.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -743,7 +716,7 @@ dependencies = [\n  \"inotify 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"mio 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mio 0.6.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"mio-extras 2.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -755,12 +728,12 @@ version = \"0.1.41\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"num-traits\"\n-version = \"0.2.9\"\n+version = \"0.2.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -775,11 +748,6 @@ dependencies = [\n  \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"number_prefix\"\n-version = \"0.3.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"once_cell\"\n version = \"1.2.0\"\n@@ -792,25 +760,23 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"parking_lot\"\n-version = \"0.9.0\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lock_api 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot_core 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lock_api 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot_core 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.6.2\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"redox_syscall 0.1.56 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -885,7 +851,7 @@ dependencies = [\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -923,7 +889,7 @@ name = \"ra_assists\"\n version = \"0.1.0\"\n dependencies = [\n  \"format-buf 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_db 0.1.0\",\n  \"ra_fmt 0.1.0\",\n@@ -941,9 +907,9 @@ dependencies = [\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_db 0.1.0\",\n  \"ra_hir 0.1.0\",\n- \"ra_ide_api 0.1.0\",\n+ \"ra_ide 0.1.0\",\n  \"ra_project_model 0.1.0\",\n- \"ra_vfs 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_vfs 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_vfs_glob 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -963,12 +929,11 @@ name = \"ra_cli\"\n version = \"0.1.0\"\n dependencies = [\n  \"flexi_logger 0.14.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"indicatif 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pico-args 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_batch 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_hir 0.1.0\",\n- \"ra_ide_api 0.1.0\",\n+ \"ra_ide 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n ]\n@@ -982,43 +947,29 @@ dependencies = [\n  \"ra_syntax 0.1.0\",\n  \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"salsa 0.13.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"salsa 0.14.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n \n [[package]]\n name = \"ra_fmt\"\n version = \"0.1.0\"\n dependencies = [\n- \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_syntax 0.1.0\",\n ]\n \n [[package]]\n name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n- \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n- \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ra_arena 0.1.0\",\n- \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_hir_def 0.1.0\",\n  \"ra_hir_expand 0.1.0\",\n- \"ra_mbe 0.1.0\",\n- \"ra_prof 0.1.0\",\n+ \"ra_hir_ty 0.1.0\",\n  \"ra_syntax 0.1.0\",\n- \"ra_tt 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"test_utils 0.1.0\",\n ]\n \n [[package]]\n@@ -1055,13 +1006,35 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"ra_ide_api\"\n+name = \"ra_hir_ty\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"chalk-solve 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n+ \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_arena 0.1.0\",\n+ \"ra_db 0.1.0\",\n+ \"ra_hir_def 0.1.0\",\n+ \"ra_hir_expand 0.1.0\",\n+ \"ra_prof 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"test_utils 0.1.0\",\n+]\n+\n+[[package]]\n+name = \"ra_ide\"\n version = \"0.1.0\"\n dependencies = [\n  \"format-buf 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fst 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1092,18 +1065,18 @@ dependencies = [\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lsp-server 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lsp-types 0.61.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ra_ide_api 0.1.0\",\n+ \"parking_lot 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_ide 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_project_model 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"ra_vfs 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_vfs 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_vfs_glob 0.1.0\",\n  \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"threadpool 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1134,7 +1107,7 @@ name = \"ra_prof\"\n version = \"0.1.0\"\n dependencies = [\n  \"backtrace 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jemalloc-ctl 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jemallocator 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1150,20 +1123,20 @@ dependencies = [\n  \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"ra_syntax\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"rowan 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rowan 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_lexer 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1189,14 +1162,14 @@ dependencies = [\n \n [[package]]\n name = \"ra_vfs\"\n-version = \"0.5.1\"\n+version = \"0.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-channel 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jod-thread 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"notify 4.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1207,7 +1180,7 @@ name = \"ra_vfs_glob\"\n version = \"0.1.0\"\n dependencies = [\n  \"globset 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ra_vfs 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_vfs 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1423,17 +1396,18 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"base64 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rowan\"\n-version = \"0.7.0\"\n+version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"text_unit 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"thin-dst 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1472,23 +1446,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"salsa\"\n-version = \"0.13.2\"\n+version = \"0.14.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"derive-new 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"indexmap 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"salsa-macros 0.13.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"salsa-macros 0.14.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"salsa-macros\"\n-version = \"0.13.2\"\n+version = \"0.14.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1516,7 +1489,7 @@ version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1526,15 +1499,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.102\"\n+version = \"1.0.103\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde_derive 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.102\"\n+version = \"1.0.103\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1544,12 +1517,12 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.41\"\n+version = \"1.0.42\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ryu 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1569,7 +1542,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"linked-hash-map 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"yaml-rust 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1578,14 +1551,6 @@ name = \"slab\"\n version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"smallvec\"\n-version = \"0.6.13\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"maybe-uninit 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"smallvec\"\n version = \"1.0.0\"\n@@ -1596,7 +1561,7 @@ name = \"smol_str\"\n version = \"0.1.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1652,7 +1617,7 @@ name = \"test_utils\"\n version = \"0.1.0\"\n dependencies = [\n  \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"text_unit 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1661,6 +1626,11 @@ name = \"text_unit\"\n version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"thin-dst\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"thread_local\"\n version = \"0.3.6\"\n@@ -1705,22 +1675,17 @@ dependencies = [\n \n [[package]]\n name = \"unicode-normalization\"\n-version = \"0.1.9\"\n+version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"smallvec 0.6.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"unicode-segmentation\"\n version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"unicode-width\"\n-version = \"0.1.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"unicode-xid\"\n version = \"0.2.0\"\n@@ -1734,7 +1699,7 @@ dependencies = [\n  \"idna 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"percent-encoding 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1743,7 +1708,7 @@ version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rand 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1816,12 +1781,12 @@ dependencies = [\n name = \"xtask\"\n version = \"0.1.0\"\n dependencies = [\n- \"anyhow 1.0.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"anyhow 1.0.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pico-args 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ron 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1840,7 +1805,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n \"checksum aho-corasick 0.7.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"58fb5e95d83b38284460a5fda7d6470aa0b8844d283a0b614b8535e880800d2d\"\n-\"checksum anyhow 1.0.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e19f23ab207147bbdbcdfa7f7e4ca5e84963d79bae3937074682177ab9150968\"\n+\"checksum anyhow 1.0.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b412394828b7ca486b362f300b762d8e43dafd6f0d727b63f1cd2ade207c6cef\"\n \"checksum arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cff77d8686867eceff3105329d4698d96c2391c176d5d03adc90c7389162b5b8\"\n \"checksum atty 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1803c647a3ec87095e7ae7acfca019e98de5ec9a7d01343f611cf3152ed71a90\"\n \"checksum autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2\"\n@@ -1856,13 +1821,13 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cargo_metadata 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d2d1617e838936c0d2323a65cc151e03ae19a7678dd24f72bccf27119b90a5d\"\n \"checksum cc 1.0.47 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aa87058dce70a3ff5621797f1506cb837edd02ac4c0ae642b4542dce802908b8\"\n \"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n-\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n-\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n-\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n-\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n-\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n-\"checksum chrono 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8493056968583b0193c1bb04d6f7684586f3726992d6c573261941a895dbd68\"\n+\"checksum chalk-derive 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n+\"checksum chalk-engine 0.9.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n+\"checksum chalk-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n+\"checksum chalk-macros 0.1.1 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n+\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n+\"checksum chalk-solve 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\" = \"<none>\"\n+\"checksum chrono 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31850b4a4d6bae316f7a09e691c944c28299298837edc0a03f755618c23cbc01\"\n \"checksum clicolors-control 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90082ee5dcdd64dc4e9e0d37fbf3ee325419e39c0092191e0393df65518f741e\"\n \"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n \"checksum console 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f5d540c2d34ac9dd0deb5f3b5f54c36c79efa78f6b3ad19106a554d07a7b5d9f\"\n@@ -1872,7 +1837,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum crossbeam-epoch 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5064ebdbf05ce3cb95e45c8b086f72263f4166b29b97f6baff7ef7fe047b55ac\"\n \"checksum crossbeam-queue 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dfd6515864a82d2f877b42813d4553292c6659498c9a2aa31bab5a15243c2700\"\n \"checksum crossbeam-utils 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ce446db02cdc3165b94ae73111e570793400d0794e46125cc4056c81cbb039f4\"\n-\"checksum derive-new 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"71f31892cd5c62e414316f2963c5689242c43d8e7bbcaaeca97e5e28c95d91d9\"\n \"checksum difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n \"checksum drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"69b26e475fd29098530e709294e94e661974c851aed42512793f120fed4e199f\"\n \"checksum dtoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea57b42383d091c85abcc2706240b94ab2a8fa1fc81c10ff23c4de06e2a90b5e\"\n@@ -1898,12 +1862,11 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum hermit-abi 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"307c3c9f937f38e3534b1d6447ecf090cafcc9744e4a6360e8b037b2cf5af120\"\n \"checksum idna 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"02e2673c30ee86b5b96a9cb52ad15718aa1f966f5ab9ad54a8b95d5ca33120a9\"\n \"checksum indexmap 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"712d7b3ea5827fcb9d4fda14bf4da5f136f0db2ae9c8f4bd4e2d1c6fde4e6db2\"\n-\"checksum indicatif 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8572bccfb0665e70b7faf44ee28841b8e0823450cd4ad562a76b5a3c4bf48487\"\n \"checksum inotify 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40b54539f3910d6f84fbf9a643efd6e3aa6e4f001426c0329576128255994718\"\n \"checksum inotify-sys 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e74a1aa87c59aeff6ef2cc2fa62d41bc43f54952f55652656b18a02fd5e356c0\"\n \"checksum insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d499dc062e841590a67230d853bce62d0abeb91304927871670b7c55c461349\"\n \"checksum iovec 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b2b3ea6ff95e175473f8ffe6a7eb7c00d054240321b84c57051175fe3c1e075e\"\n-\"checksum itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"87fa75c9dea7b07be3138c49abbb83fd4bea199b5cdc76f9804458edc5da0d6e\"\n+\"checksum itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f56a2d0bc861f9165be4eb3442afd3c236d8a98afd426f65d92324ae1091a484\"\n \"checksum itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"501266b7edd0174f8530248f87f99c88fbe60ca4ef3dd486835b8d8d53136f7f\"\n \"checksum jemalloc-ctl 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c502a5ff9dd2924f1ed32ba96e3b65735d837b4bfd978d3161b1702e66aca4b7\"\n \"checksum jemalloc-sys 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d3b9f3f5c9b31aa0f5ed3260385ac205db665baa41d49bb8338008ae94ede45\"\n@@ -1916,27 +1879,25 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \"checksum libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1a31a0627fdf1f6a39ec0dd577e101440b7db22672c0901fe00a9a6fbb5c24e8\"\n \"checksum linked-hash-map 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae91b68aebc4ddb91978b11a1b02ddd8602a05ec19002801c5666000e05e0f83\"\n-\"checksum lock_api 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f8912e782533a93a167888781b836336a6ca5da6175c05944c86cf28c31104dc\"\n+\"checksum lock_api 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e57b3997725d2b60dbec1297f6c2e2957cc383db1cebd6be812163f969c7d586\"\n \"checksum log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"14b6052be84e6b71ab17edffc2eeabf5c2c3ae1fdb464aae35ac50c67a44e1f7\"\n \"checksum lsp-server 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0ba36405bd742139ab79c246ca5adb7fde2fe1a0f495e2c8e2f607b607dedb12\"\n \"checksum lsp-types 0.61.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fa3268fbe8beb2795c2fb327bf44f4f3d24f5fe9ebc18d7e2980afd444d72bcf\"\n \"checksum matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n-\"checksum maybe-uninit 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"60302e4db3a61da70c0cb7991976248362f30319e88850c487b9b95bbf059e00\"\n \"checksum memchr 2.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"88579771288728879b57485cc7d6b07d648c9f0141eb955f8ab7f9d45394468e\"\n \"checksum memoffset 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"75189eb85871ea5c2e2c15abbdd541185f63b408415e5051f5cac122d8c774b9\"\n-\"checksum mio 0.6.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"83f51996a3ed004ef184e16818edc51fadffe8e7ca68be67f9dee67d84d0ff23\"\n+\"checksum mio 0.6.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"302dec22bcf6bae6dfb69c647187f4b4d0fb6f535521f7bc022430ce8e12008f\"\n \"checksum mio-extras 2.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"46e73a04c2fa6250b8d802134d56d554a9ec2922bf977777c805ea5def61ce40\"\n \"checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919\"\n \"checksum net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)\" = \"42550d9fb7b6684a6d404d9fa7250c2eb2646df731d1c06afc06dcee9e1bcf88\"\n \"checksum notify 4.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"199628fc33b21bc767baa057490b00b382ecbae030803a7b36292422d15b778b\"\n \"checksum num-integer 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b85e541ef8255f6cf42bbfe4ef361305c6c135d10919ecc26126c4e5ae94bc09\"\n-\"checksum num-traits 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"443c53b3c3531dfcbfa499d8893944db78474ad7a1d87fa2d94d1a2231693ac6\"\n+\"checksum num-traits 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c81ffc11c212fa327657cb19dd85eb7419e163b5b076bede2bdb5c974c07e4\"\n \"checksum num_cpus 1.11.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76dac5ed2a876980778b8b85f75a71b6cbf0db0b1232ee12f826bccb00d09d72\"\n-\"checksum number_prefix 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"17b02fc0ff9a9e4b35b3342880f48e896ebf69f2967921fe8646bf5b7125956a\"\n \"checksum once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"891f486f630e5c5a4916c7e16c4b24a53e78c860b646e9f8e005e4f16847bfed\"\n \"checksum ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n-\"checksum parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f842b1982eb6c2fe34036a4fbfb06dd185a3f5c8edfaacdf7d1ea10b07de6252\"\n-\"checksum parking_lot_core 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b876b1b9e7ac6e1a74a6da34d25c42e17e8862aa409cbbbdcfc8d86c6f3bc62b\"\n+\"checksum parking_lot 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92e98c49ab0b7ce5b222f2cc9193fc4efe11c6d0bd4f648e374684a6857b1cfc\"\n+\"checksum parking_lot_core 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7582838484df45743c8434fbff785e8edf260c28748353d44bc0da32e0ceabf1\"\n \"checksum paste 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"423a519e1c6e828f1e73b720f9d9ed2fa643dce8a7737fb43235ce0b41eeaa49\"\n \"checksum paste-impl 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4214c9e912ef61bf42b81ba9a47e8aad1b2ffaf739ab162bf96d1e011f54e6c5\"\n \"checksum percent-encoding 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n@@ -1949,7 +1910,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum psm 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b14fc68b454f875abc8354c2555e1d56596f74833ddc0f77f87f4871ed6a30e0\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n-\"checksum ra_vfs 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a95d3d1edc70a98d9e42f145bc92c2071dfdc532571591c9eac407c0e4feb89\"\n+\"checksum ra_vfs 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc898f237e4b4498959ae0100c688793a23e77624d44ef710ba70094217f98e0\"\n \"checksum rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca\"\n \"checksum rand 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ae1b169243eaf61759b8475a998f0a385e42042370f3a7dbaf35246eacc8412\"\n \"checksum rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"556d3a1ca6600bfcbab7c7c91ccb085ac7fbbcd70e008a98742e7847f4f7bcef\"\n@@ -1974,25 +1935,24 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bedde000f40f2921ce439ea165c9c53fd629bfa115140c72e22aceacb4a21954\"\n \"checksum remove_dir_all 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4a83fa3702a688b9359eccba92d153ac33fd2e8462f9e0e3fdf155239ea7792e\"\n \"checksum ron 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2ece421e0c4129b90e4a35b6f625e472e96c552136f5093a2f4fa2bbb75a62d5\"\n-\"checksum rowan 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3a241900475bf2ba302061550ff50c82b45095ca95d23d1872345793fd42407\"\n+\"checksum rowan 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca620bbf9c48c92b5cef19f96354a309ac36b7d8ef7c591e66117335c8b1988b\"\n \"checksum rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c691c0e608126e00913e33f0ccf3727d5fc84573623b8d65b2df340b5201783\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc_lexer 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c86aae0c77166108c01305ee1a36a1e77289d7dc6ca0a3cd91ff4992de2d16a5\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n \"checksum ryu 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bfa8506c1de11c9c4e4c38863ccbe02a305c8188e85a05a784c9e11e1c3910c8\"\n-\"checksum salsa 0.13.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ec0865bdd9d8e614686a0cbb76979c735810131d287eb1683e91e4e64a58c387\"\n-\"checksum salsa-macros 0.13.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cac182212d3a1db75ddc42399ff1461b258a694b8318ee7e0baf6c976e39efee\"\n+\"checksum salsa 0.14.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4a006c56096acaaa5e82e5974c28d05ff1e84aa70615f19c53fecf8a1afb2fd2\"\n+\"checksum salsa-macros 0.14.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"038a09b6271446f1123f142fe7e5bef6d4687c4cf82e6986be574c2af3745530\"\n \"checksum same-file 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"585e8ddcedc187886a30fa705c47985c3fa88d06624095856b36ca0b82ff4421\"\n \"checksum scopeguard 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b42e15e59b18a828bbf5c58ea01debb36b9b096346de35d941dcb89009f24a0d\"\n \"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n-\"checksum serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c4b39bd9b0b087684013a792c59e3e07a46a01d2322518d8a1104641a0b1be0\"\n-\"checksum serde_derive 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca13fc1a832f793322228923fbb3aba9f3f44444898f835d31ad1b74fa0a2bf8\"\n-\"checksum serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f72eb2a68a7dc3f9a691bfda9305a1c017a6215e5a4545c258500d2099a37c2\"\n+\"checksum serde 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1217f97ab8e8904b57dd22eb61cde455fa7446a9c1cf43966066da047c1f3702\"\n+\"checksum serde_derive 1.0.103 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a8c6faef9a2e64b0064f48570289b4bf8823b7581f1d6157c1b52152306651d0\"\n+\"checksum serde_json 1.0.42 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1a3351dcbc1f067e2c92ab7c3c1f288ad1a4cffc470b5aaddb4c2e0a3ae80043\"\n \"checksum serde_repr 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cd02c7587ec314570041b2754829f84d873ced14a96d1fd1823531e11db40573\"\n \"checksum serde_yaml 0.8.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"691b17f19fc1ec9d94ec0b5864859290dff279dbd7b03f017afda54eb36c3c35\"\n \"checksum slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n-\"checksum smallvec 0.6.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7b0758c52e15a8b5e3691eae6cc559f08eee9406e548a4477ba4e67770a82b6\"\n \"checksum smallvec 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4ecf3b85f68e8abaa7555aa5abdb1153079387e60b718283d732f03897fcfc86\"\n \"checksum smol_str 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"34836c9a295c62c2ce3514471117c5cb269891e8421b2aafdd910050576c4d8b\"\n \"checksum stacker 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d96fc4f13a0ac088e9a3cd9af1cc8c5cc1ab5deb2145cef661267dfc9c542f8a\"\n@@ -2001,14 +1961,14 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum tempfile 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n \"checksum termios 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72b620c5ea021d75a735c943269bb07d30c9b77d6ac6b236bc8b5c496ef05625\"\n \"checksum text_unit 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e08bbcb7a3adbda0eb23431206b653bdad3d8dea311e72d36bf2215e27a42579\"\n+\"checksum thin-dst 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c52fd98a9e4913c466d83381a59245691875d2f3e04611fca57f964bd8aa96e1\"\n \"checksum thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b\"\n \"checksum threadpool 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2f0c90a5f3459330ac8bc0d2f879c693bb7a2f59689c1083fc4ef83834da865\"\n \"checksum time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db8dcfca086c1143c9270ac42a2bbd8a7ee477b78ac8e45b19abfb0cbede4b6f\"\n \"checksum unicase 2.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"50f37be617794602aabbeee0be4f259dc1778fabe05e2d67ee8f79326d5cb4f6\"\n \"checksum unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49f2bd0c6468a8230e1db229cff8029217cf623c767ea5d60bfbd42729ea54d5\"\n-\"checksum unicode-normalization 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09c8070a9942f5e7cfccd93f490fdebd230ee3c3c9f107cb25bad5351ef671cf\"\n+\"checksum unicode-normalization 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b561e267b2326bb4cebfc0ef9e68355c7abe6c6f522aeac2f5bf95d56c59bdcf\"\n \"checksum unicode-segmentation 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e83e153d1053cbb5a118eeff7fd5be06ed99153f00dbcd8ae310c5fb2b22edc0\"\n-\"checksum unicode-width 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7007dbd421b92cc6e28410fe7362e2e0a2503394908f417b68ec8d1c364c4e20\"\n \"checksum unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\"\n \"checksum url 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"75b414f6c464c879d7f9babf951f23bc3743fb7313c081b2e6ca719067ea9d61\"\n \"checksum uuid 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9fde2f6a4bea1d6e007c4ad38c6839fa71cbb63b6dbf5b595aa38dc9b1093c11\""}, {"sha": "74c971c0d3dda74737d778e8a94b4c5700f31e3f", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -56,7 +56,7 @@ https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frls-2.2E0\n \n ## Quick Links\n \n-* API docs: https://rust-analyzer.github.io/rust-analyzer/ra_ide_api/\n+* API docs: https://rust-analyzer.github.io/rust-analyzer/ra_ide/\n \n \n ## License"}, {"sha": "eeb4ff39f4c27842ffafa43d53ee5fe618b2b069", "filename": "crates/ra_assists/src/assists/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::HirDatabase, HirDisplay, Ty};\n+use hir::{db::HirDatabase, HirDisplay};\n use ra_syntax::{\n     ast::{self, AstNode, LetStmt, NameOwner},\n     T,\n@@ -43,7 +43,7 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx<impl HirDatabase>) -> Option<Assi\n     let analyzer = ctx.source_analyzer(stmt.syntax(), None);\n     let ty = analyzer.type_of(db, &expr)?;\n     // Assist not applicable if the type is unknown\n-    if is_unknown(&ty) {\n+    if ty.contains_unknown() {\n         return None;\n     }\n \n@@ -53,15 +53,6 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx<impl HirDatabase>) -> Option<Assi\n     })\n }\n \n-/// Returns true if any type parameter is unknown\n-fn is_unknown(ty: &Ty) -> bool {\n-    match ty {\n-        Ty::Unknown => true,\n-        Ty::Apply(a_ty) => a_ty.parameters.iter().any(is_unknown),\n-        _ => false,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "8f68bd5fb13061dbbffd82c2df455d780a8d382c", "filename": "crates/ra_assists/src/assists/add_new.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -35,8 +35,8 @@ pub(crate) fn add_new(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let strukt = ctx.find_node_at_offset::<ast::StructDef>()?;\n \n     // We want to only apply this to non-union structs with named fields\n-    let field_list = match (strukt.kind(), strukt.is_union()) {\n-        (StructKind::Record(named), false) => named,\n+    let field_list = match strukt.kind() {\n+        StructKind::Record(named) => named,\n         _ => return None,\n     };\n "}, {"sha": "b75bd44ebeb00076c6ee9b263876a2348796a2ad", "filename": "crates/ra_assists/src/assists/fill_match_arms.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -83,10 +83,11 @@ fn resolve_enum_def(\n ) -> Option<ast::EnumDef> {\n     let expr_ty = analyzer.type_of(db, &expr)?;\n \n-    analyzer.autoderef(db, expr_ty).find_map(|ty| match ty.as_adt() {\n-        Some((Adt::Enum(e), _)) => Some(e.source(db).value),\n+    let res = expr_ty.autoderef(db).find_map(|ty| match ty.as_adt() {\n+        Some(Adt::Enum(e)) => Some(e.source(db).value),\n         _ => None,\n-    })\n+    });\n+    res\n }\n \n fn build_pat(var: ast::EnumVariant) -> Option<ast::Pat> {"}, {"sha": "523259fd46318af0e6cfe2f4f90e08fd76927e87", "filename": "crates/ra_assists/src/test_db.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftest_db.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -21,6 +21,9 @@ impl salsa::Database for TestDB {\n     fn salsa_runtime(&self) -> &salsa::Runtime<Self> {\n         &self.runtime\n     }\n+    fn salsa_runtime_mut(&mut self) -> &mut salsa::Runtime<Self> {\n+        &mut self.runtime\n+    }\n }\n \n impl std::panic::RefUnwindSafe for TestDB {}"}, {"sha": "3bf351fe3771ce17670cfb91fced6984b110d967", "filename": "crates/ra_batch/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_batch%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_batch%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2FCargo.toml?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -15,6 +15,6 @@ crossbeam-channel = \"0.4.0\"\n ra_vfs = \"0.5.0\"\n ra_vfs_glob = { path = \"../ra_vfs_glob\" }\n ra_db = { path = \"../ra_db\" }\n-ra_ide_api = { path = \"../ra_ide_api\" }\n+ra_ide = { path = \"../ra_ide\" }\n ra_hir = { path = \"../ra_hir\" }\n ra_project_model = { path = \"../ra_project_model\" }"}, {"sha": "2c9645c00a3c430b623ed0b3f2ebce72f46d84ee", "filename": "crates/ra_batch/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_batch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_batch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2Fsrc%2Flib.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -6,7 +6,7 @@ use rustc_hash::FxHashMap;\n \n use crossbeam_channel::{unbounded, Receiver};\n use ra_db::{CrateGraph, FileId, SourceRootId};\n-use ra_ide_api::{AnalysisChange, AnalysisHost, FeatureFlags};\n+use ra_ide::{AnalysisChange, AnalysisHost, FeatureFlags};\n use ra_project_model::{get_rustc_cfg_options, PackageRoot, ProjectWorkspace};\n use ra_vfs::{RootEntry, Vfs, VfsChange, VfsTask, Watch};\n use ra_vfs_glob::RustPackageFilterBuilder;"}, {"sha": "c7e0d0f0f33a9144c012dedde689f3eab7a2771c", "filename": "crates/ra_cli/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2FCargo.toml?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -8,10 +8,9 @@ publish = false\n [dependencies]\n pico-args = \"0.3.0\"\n flexi_logger = \"0.14.0\"\n-indicatif = \"0.13.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n-ra_ide_api = { path = \"../ra_ide_api\" }\n+ra_ide = { path = \"../ra_ide\" }\n ra_batch = { path = \"../ra_batch\" }\n ra_hir = { path = \"../ra_hir\" }\n ra_db = { path = \"../ra_db\" }"}, {"sha": "5485a38ff2702ea4b2b661be7886dc151dad1384", "filename": "crates/ra_cli/src/analysis_bench.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_cli%2Fsrc%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_cli%2Fsrc%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_bench.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -10,7 +10,7 @@ use ra_db::{\n     salsa::{Database, Durability},\n     FileId, SourceDatabaseExt,\n };\n-use ra_ide_api::{Analysis, AnalysisChange, AnalysisHost, FilePosition, LineCol};\n+use ra_ide::{Analysis, AnalysisChange, AnalysisHost, FilePosition, LineCol};\n \n use crate::Result;\n \n@@ -91,7 +91,7 @@ fn do_work<F: Fn(&Analysis) -> T, T>(host: &mut AnalysisHost, file_id: FileId, w\n     {\n         let start = Instant::now();\n         eprint!(\"trivial change: \");\n-        host.raw_database().salsa_runtime().synthetic_write(Durability::LOW);\n+        host.raw_database_mut().salsa_runtime_mut().synthetic_write(Durability::LOW);\n         work(&host.analysis());\n         eprintln!(\"{:?}\", start.elapsed());\n     }\n@@ -111,7 +111,7 @@ fn do_work<F: Fn(&Analysis) -> T, T>(host: &mut AnalysisHost, file_id: FileId, w\n     {\n         let start = Instant::now();\n         eprint!(\"const change:   \");\n-        host.raw_database().salsa_runtime().synthetic_write(Durability::HIGH);\n+        host.raw_database_mut().salsa_runtime_mut().synthetic_write(Durability::HIGH);\n         let res = work(&host.analysis());\n         eprintln!(\"{:?}\", start.elapsed());\n         res"}, {"sha": "9b1802a5fc8b337092cfc8a35732740788b2bd19", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -6,7 +6,7 @@ use ra_db::SourceDatabaseExt;\n use ra_hir::{AssocItem, Crate, HasSource, HirDisplay, ModuleDef, Ty, TypeWalk};\n use ra_syntax::AstNode;\n \n-use crate::{Result, Verbosity};\n+use crate::{progress_report::ProgressReport, Result, Verbosity};\n \n pub fn run(\n     verbosity: Verbosity,\n@@ -75,17 +75,11 @@ pub fn run(\n     println!(\"Item Collection: {:?}, {}\", analysis_time.elapsed(), ra_prof::memory_usage());\n \n     let inference_time = Instant::now();\n-    let bar = match verbosity {\n-        Verbosity::Verbose | Verbosity::Normal => indicatif::ProgressBar::with_draw_target(\n-            funcs.len() as u64,\n-            indicatif::ProgressDrawTarget::stderr_nohz(),\n-        ),\n-        Verbosity::Quiet => indicatif::ProgressBar::hidden(),\n+    let mut bar = match verbosity {\n+        Verbosity::Verbose | Verbosity::Normal => ProgressReport::new(funcs.len() as u64),\n+        Verbosity::Quiet => ProgressReport::hidden(),\n     };\n \n-    bar.set_style(\n-        indicatif::ProgressStyle::default_bar().template(\"{wide_bar} {pos}/{len}\\n{msg}\"),\n-    );\n     bar.tick();\n     let mut num_exprs = 0;\n     let mut num_exprs_unknown = 0;"}, {"sha": "fe847e611290f5f831b3a19b955383e7accfd05a", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -3,12 +3,13 @@\n mod analysis_stats;\n mod analysis_bench;\n mod help;\n+mod progress_report;\n \n use std::{error::Error, fmt::Write, io::Read};\n \n use flexi_logger::Logger;\n use pico_args::Arguments;\n-use ra_ide_api::{file_structure, Analysis};\n+use ra_ide::{file_structure, Analysis};\n use ra_prof::profile;\n use ra_syntax::{AstNode, SourceFile};\n "}, {"sha": "31867a1e973e3f29fa00f120619fba8bf1366900", "filename": "crates/ra_cli/src/progress_report.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_cli%2Fsrc%2Fprogress_report.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_cli%2Fsrc%2Fprogress_report.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fprogress_report.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -0,0 +1,120 @@\n+//! A simple progress bar\n+//!\n+//! A single thread non-optimized progress bar\n+use std::io::Write;\n+\n+/// A Simple ASCII Progress Bar\n+pub struct ProgressReport {\n+    curr: f32,\n+    text: String,\n+    hidden: bool,\n+\n+    len: u64,\n+    pos: u64,\n+    msg: String,\n+}\n+\n+impl ProgressReport {\n+    pub fn new(len: u64) -> ProgressReport {\n+        ProgressReport {\n+            curr: 0.0,\n+            text: String::new(),\n+            hidden: false,\n+            len,\n+            pos: 0,\n+            msg: String::new(),\n+        }\n+    }\n+\n+    pub fn hidden() -> ProgressReport {\n+        ProgressReport {\n+            curr: 0.0,\n+            text: String::new(),\n+            hidden: true,\n+            len: 0,\n+            pos: 0,\n+            msg: String::new(),\n+        }\n+    }\n+\n+    pub fn set_message(&mut self, msg: &str) {\n+        self.msg = msg.to_string();\n+        self.tick();\n+    }\n+\n+    pub fn println<I: Into<String>>(&mut self, msg: I) {\n+        self.clear();\n+        println!(\"{}\", msg.into());\n+        self.tick();\n+    }\n+\n+    pub fn inc(&mut self, delta: u64) {\n+        self.pos += delta;\n+        if self.len == 0 {\n+            self.set_value(0.0)\n+        } else {\n+            self.set_value((self.pos as f32) / (self.len as f32))\n+        }\n+        self.tick();\n+    }\n+\n+    pub fn finish_and_clear(&mut self) {\n+        self.clear();\n+    }\n+\n+    pub fn tick(&mut self) {\n+        if self.hidden {\n+            return;\n+        }\n+        let percent = (self.curr * 100.0) as u32;\n+        let text = format!(\"{}/{} {:3>}% {}\", self.pos, self.len, percent, self.msg);\n+        self.update_text(&text);\n+    }\n+\n+    fn update_text(&mut self, text: &str) {\n+        // Get length of common portion\n+        let mut common_prefix_length = 0;\n+        let common_length = usize::min(self.text.len(), text.len());\n+\n+        while common_prefix_length < common_length\n+            && text.chars().nth(common_prefix_length).unwrap()\n+                == self.text.chars().nth(common_prefix_length).unwrap()\n+        {\n+            common_prefix_length += 1;\n+        }\n+\n+        // Backtrack to the first differing character\n+        let mut output = String::new();\n+        output += &'\\x08'.to_string().repeat(self.text.len() - common_prefix_length);\n+        // Output new suffix\n+        output += &text[common_prefix_length..text.len()];\n+\n+        // If the new text is shorter than the old one: delete overlapping characters\n+        if let Some(overlap_count) = self.text.len().checked_sub(text.len()) {\n+            if overlap_count > 0 {\n+                output += &\" \".repeat(overlap_count);\n+                output += &\"\\x08\".repeat(overlap_count);\n+            }\n+        }\n+\n+        let _ = std::io::stdout().write(output.as_bytes());\n+        let _ = std::io::stdout().flush();\n+        self.text = text.to_string();\n+    }\n+\n+    fn set_value(&mut self, value: f32) {\n+        self.curr = f32::max(0.0, f32::min(1.0, value));\n+    }\n+\n+    fn clear(&mut self) {\n+        if self.hidden {\n+            return;\n+        }\n+\n+        // Fill all last text to space and return the cursor\n+        let spaces = \" \".repeat(self.text.len());\n+        let backspaces = \"\\x08\".repeat(self.text.len());\n+        print!(\"{}{}{}\", backspaces, spaces, backspaces);\n+        self.text = String::new();\n+    }\n+}"}, {"sha": "7afa5d8fc91152c69144ed7878081582e516fe9f", "filename": "crates/ra_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2FCargo.toml?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -8,7 +8,7 @@ authors = [\"rust-analyzer developers\"]\n doctest = false\n \n [dependencies]\n-salsa = \"0.13.0\"\n+salsa = \"0.14.1\"\n relative-path = \"1.0.0\"\n rustc-hash = \"1.0\"\n "}, {"sha": "21341b7697d6d0e2bb5e8b48449f39b09588cfec", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,4 +1,4 @@\n-//! ra_db defines basic database traits. The concrete DB is defined by ra_ide_api.\n+//! ra_db defines basic database traits. The concrete DB is defined by ra_ide.\n mod cancellation;\n mod input;\n pub mod fixture;"}, {"sha": "e79361e7cc93f404bba7c78d7c4582b66f55ed64", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -8,28 +8,11 @@ authors = [\"rust-analyzer developers\"]\n doctest = false\n \n [dependencies]\n-arrayvec = \"0.5.1\"\n log = \"0.4.5\"\n rustc-hash = \"1.0\"\n-parking_lot = \"0.9.0\"\n-ena = \"0.13\"\n-once_cell = \"1.0.1\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n-ra_arena = { path = \"../ra_arena\" }\n-ra_cfg = { path = \"../ra_cfg\" }\n ra_db = { path = \"../ra_db\" }\n-mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n-tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n-test_utils = { path = \"../test_utils\" }\n-ra_prof = { path = \"../ra_prof\" }\n-\n-chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\" }\n-chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\" }\n-lalrpop-intern = \"0.15.1\"\n-\n-[dev-dependencies]\n-insta = \"0.12.0\"\n+hir_ty = { path = \"../ra_hir_ty\", package = \"ra_hir_ty\" }"}, {"sha": "38d66c2a7c2bbb2e05bd25b6e65426182e6ea1ba", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 298, "deletions": 151, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -6,28 +6,31 @@ use std::sync::Arc;\n \n use hir_def::{\n     adt::VariantData,\n+    body::{Body, BodySourceMap},\n     builtin_type::BuiltinType,\n     docs::Documentation,\n+    expr::{BindingAnnotation, Pat, PatId},\n     per_ns::PerNs,\n-    resolver::{HasResolver, TypeNs},\n-    type_ref::TypeRef,\n-    AstItemDef, ConstId, ContainerId, EnumId, FunctionId, HasModule, ImplId, LocalEnumVariantId,\n-    LocalImportId, LocalModuleId, LocalStructFieldId, Lookup, ModuleId, StaticId, StructId,\n-    TraitId, TypeAliasId, UnionId,\n+    resolver::HasResolver,\n+    type_ref::{Mutability, TypeRef},\n+    AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, FunctionId, GenericDefId,\n+    HasModule, ImplId, LocalEnumVariantId, LocalImportId, LocalModuleId, LocalStructFieldId,\n+    Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n     name::{self, AsName},\n     AstId, MacroDefId,\n };\n+use hir_ty::expr::ExprValidator;\n use ra_db::{CrateId, Edition, FileId, FilePosition};\n use ra_syntax::{ast, AstNode, SyntaxNode};\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n-    expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n-    ty::{InferenceResult, Namespace, TraitRef},\n-    Either, Name, Source, Ty,\n+    ty::display::HirFormatter,\n+    ty::{self, InEnvironment, InferenceResult, TraitEnvironment, Ty, TyDefId, TypeCtor, TypeWalk},\n+    CallableDef, Either, HirDisplay, Name, Source,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -168,15 +171,15 @@ pub use hir_def::attr::Attrs;\n \n impl Module {\n     pub(crate) fn new(krate: Crate, crate_module_id: LocalModuleId) -> Module {\n-        Module { id: ModuleId { krate: krate.crate_id, module_id: crate_module_id } }\n+        Module { id: ModuleId { krate: krate.crate_id, local_id: crate_module_id } }\n     }\n \n     /// Name of this module.\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        let parent = def_map[self.id.module_id].parent?;\n+        let parent = def_map[self.id.local_id].parent?;\n         def_map[parent].children.iter().find_map(|(name, module_id)| {\n-            if *module_id == self.id.module_id {\n+            if *module_id == self.id.local_id {\n                 Some(name.clone())\n             } else {\n                 None\n@@ -200,14 +203,14 @@ impl Module {\n     /// Finds a child module with the specified name.\n     pub fn child(self, db: &impl DefDatabase, name: &Name) -> Option<Module> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        let child_id = def_map[self.id.module_id].children.get(name)?;\n+        let child_id = def_map[self.id.local_id].children.get(name)?;\n         Some(self.with_module_id(*child_id))\n     }\n \n     /// Iterates over all child modules.\n     pub fn children(self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        let children = def_map[self.id.module_id]\n+        let children = def_map[self.id.local_id]\n             .children\n             .iter()\n             .map(|(_, module_id)| self.with_module_id(*module_id))\n@@ -218,7 +221,7 @@ impl Module {\n     /// Finds a parent module.\n     pub fn parent(self, db: &impl DefDatabase) -> Option<Module> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        let parent_id = def_map[self.id.module_id].parent?;\n+        let parent_id = def_map[self.id.local_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n \n@@ -234,7 +237,7 @@ impl Module {\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub fn scope(self, db: &impl HirDatabase) -> Vec<(Name, ScopeDef, Option<Import>)> {\n-        db.crate_def_map(self.id.krate)[self.id.module_id]\n+        db.crate_def_map(self.id.krate)[self.id.local_id]\n             .scope\n             .entries()\n             .map(|(name, res)| {\n@@ -244,7 +247,7 @@ impl Module {\n     }\n \n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n-        db.crate_def_map(self.id.krate).add_diagnostics(db, self.id.module_id, sink);\n+        db.crate_def_map(self.id.krate).add_diagnostics(db, self.id.local_id, sink);\n         for decl in self.declarations(db) {\n             match decl {\n                 crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n@@ -269,12 +272,12 @@ impl Module {\n \n     pub fn declarations(self, db: &impl DefDatabase) -> Vec<ModuleDef> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        def_map[self.id.module_id].scope.declarations().map(ModuleDef::from).collect()\n+        def_map[self.id.local_id].scope.declarations().map(ModuleDef::from).collect()\n     }\n \n     pub fn impl_blocks(self, db: &impl DefDatabase) -> Vec<ImplBlock> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        def_map[self.id.module_id].impls.iter().copied().map(ImplBlock::from).collect()\n+        def_map[self.id.local_id].impls.iter().copied().map(ImplBlock::from).collect()\n     }\n \n     fn with_module_id(self, module_id: LocalModuleId) -> Module {\n@@ -320,14 +323,14 @@ pub struct Struct {\n \n impl Struct {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.0.module(db) }\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n+    pub fn name(self, db: &impl DefDatabase) -> Name {\n         db.struct_data(self.id.into()).name.clone()\n     }\n \n@@ -349,12 +352,12 @@ impl Struct {\n             .map(|(id, _)| StructField { parent: self.into(), id })\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        Type::from_def(db, self.id.module(db).krate, self.id)\n     }\n \n     pub fn constructor_ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Values)\n+        db.value_ty(self.id.into())\n     }\n \n     fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n@@ -368,16 +371,38 @@ pub struct Union {\n }\n \n impl Union {\n-    pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        db.struct_data(self.id.into()).name.clone()\n+    pub fn name(self, db: &impl DefDatabase) -> Name {\n+        db.union_data(self.id).name.clone()\n     }\n \n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.0.module(db) }\n+        Module { id: self.id.module(db) }\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        Type::from_def(db, self.id.module(db).krate, self.id)\n+    }\n+\n+    pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n+        db.union_data(self.id)\n+            .variant_data\n+            .fields()\n+            .iter()\n+            .map(|(id, _)| StructField { parent: self.into(), id })\n+            .collect()\n+    }\n+\n+    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n+        db.union_data(self.id)\n+            .variant_data\n+            .fields()\n+            .iter()\n+            .find(|(_id, data)| data.name == *name)\n+            .map(|(id, _)| StructField { parent: self.into(), id })\n+    }\n+\n+    fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n+        db.union_data(self.id).variant_data.clone()\n     }\n }\n \n@@ -395,7 +420,7 @@ impl Enum {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n+    pub fn name(self, db: &impl DefDatabase) -> Name {\n         db.enum_data(self.id).name.clone()\n     }\n \n@@ -408,15 +433,12 @@ impl Enum {\n     }\n \n     pub fn variant(self, db: &impl DefDatabase, name: &Name) -> Option<EnumVariant> {\n-        db.enum_data(self.id)\n-            .variants\n-            .iter()\n-            .find(|(_id, data)| data.name.as_ref() == Some(name))\n-            .map(|(id, _)| EnumVariant { parent: self, id })\n+        let id = db.enum_data(self.id).variant(name)?;\n+        Some(EnumVariant { parent: self, id })\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        Type::from_def(db, self.id.module(db).krate, self.id)\n     }\n }\n \n@@ -434,7 +456,7 @@ impl EnumVariant {\n         self.parent\n     }\n \n-    pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n+    pub fn name(self, db: &impl DefDatabase) -> Name {\n         db.enum_data(self.parent.id).variants[self.id].name.clone()\n     }\n \n@@ -469,12 +491,13 @@ pub enum Adt {\n impl_froms!(Adt: Struct, Union, Enum);\n \n impl Adt {\n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        match self {\n-            Adt::Struct(it) => it.ty(db),\n-            Adt::Union(it) => it.ty(db),\n-            Adt::Enum(it) => it.ty(db),\n-        }\n+    pub fn has_non_default_type_params(self, db: &impl HirDatabase) -> bool {\n+        let subst = db.generic_defaults(self.into());\n+        subst.iter().any(|ty| ty == &Ty::Unknown)\n+    }\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        let id = AdtId::from(self);\n+        Type::from_def(db, id.module(db).krate, id)\n     }\n \n     pub fn module(self, db: &impl DefDatabase) -> Module {\n@@ -493,35 +516,32 @@ impl Adt {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum VariantDef {\n     Struct(Struct),\n+    Union(Union),\n     EnumVariant(EnumVariant),\n }\n-impl_froms!(VariantDef: Struct, EnumVariant);\n+impl_froms!(VariantDef: Struct, Union, EnumVariant);\n \n impl VariantDef {\n     pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n         match self {\n             VariantDef::Struct(it) => it.fields(db),\n+            VariantDef::Union(it) => it.fields(db),\n             VariantDef::EnumVariant(it) => it.fields(db),\n         }\n     }\n \n-    pub(crate) fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        match self {\n-            VariantDef::Struct(it) => it.field(db, name),\n-            VariantDef::EnumVariant(it) => it.field(db, name),\n-        }\n-    }\n-\n     pub fn module(self, db: &impl HirDatabase) -> Module {\n         match self {\n             VariantDef::Struct(it) => it.module(db),\n+            VariantDef::Union(it) => it.module(db),\n             VariantDef::EnumVariant(it) => it.module(db),\n         }\n     }\n \n     pub(crate) fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n         match self {\n             VariantDef::Struct(it) => it.variant_data(db),\n+            VariantDef::Union(it) => it.variant_data(db),\n             VariantDef::EnumVariant(it) => it.variant_data(db),\n         }\n     }\n@@ -538,14 +558,6 @@ pub enum DefWithBody {\n impl_froms!(DefWithBody: Function, Const, Static);\n \n impl DefWithBody {\n-    pub(crate) fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n-        match self {\n-            DefWithBody::Const(c) => c.krate(db),\n-            DefWithBody::Function(f) => f.krate(db),\n-            DefWithBody::Static(s) => s.krate(db),\n-        }\n-    }\n-\n     pub fn module(self, db: &impl HirDatabase) -> Module {\n         match self {\n             DefWithBody::Const(c) => c.module(db),\n@@ -590,11 +602,11 @@ impl Function {\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Values)\n+        db.value_ty(self.id.into())\n     }\n \n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.into())\n+        db.infer(self.id.into())\n     }\n \n     /// The containing impl block, if this is a method.\n@@ -623,8 +635,8 @@ impl Function {\n \n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n         let infer = self.infer(db);\n-        infer.add_diagnostics(db, self, sink);\n-        let mut validator = ExprValidator::new(self, infer, sink);\n+        infer.add_diagnostics(db, self.id, sink);\n+        let mut validator = ExprValidator::new(self.id, infer, sink);\n         validator.validate_body(db);\n     }\n }\n@@ -648,7 +660,7 @@ impl Const {\n     }\n \n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.into())\n+        db.infer(self.id.into())\n     }\n \n     /// The containing impl block, if this is a type alias.\n@@ -691,7 +703,7 @@ impl Static {\n     }\n \n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.into())\n+        db.infer(self.id.into())\n     }\n }\n \n@@ -705,73 +717,12 @@ impl Trait {\n         Module { id: self.id.module(db) }\n     }\n \n-    pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n+    pub fn name(self, db: &impl DefDatabase) -> Name {\n         db.trait_data(self.id).name.clone()\n     }\n \n     pub fn items(self, db: &impl DefDatabase) -> Vec<AssocItem> {\n-        db.trait_data(self.id).items.iter().map(|it| (*it).into()).collect()\n-    }\n-\n-    fn direct_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n-        let resolver = self.id.resolver(db);\n-        // returning the iterator directly doesn't easily work because of\n-        // lifetime problems, but since there usually shouldn't be more than a\n-        // few direct traits this should be fine (we could even use some kind of\n-        // SmallVec if performance is a concern)\n-        db.generic_params(self.id.into())\n-            .where_predicates\n-            .iter()\n-            .filter_map(|pred| match &pred.type_ref {\n-                TypeRef::Path(p) if p.as_ident() == Some(&name::SELF_TYPE) => pred.bound.as_path(),\n-                _ => None,\n-            })\n-            .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {\n-                Some(TypeNs::TraitId(t)) => Some(t),\n-                _ => None,\n-            })\n-            .map(Trait::from)\n-            .collect()\n-    }\n-\n-    /// Returns an iterator over the whole super trait hierarchy (including the\n-    /// trait itself).\n-    pub fn all_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n-        // we need to take care a bit here to avoid infinite loops in case of cycles\n-        // (i.e. if we have `trait A: B; trait B: A;`)\n-        let mut result = vec![self];\n-        let mut i = 0;\n-        while i < result.len() {\n-            let t = result[i];\n-            // yeah this is quadratic, but trait hierarchies should be flat\n-            // enough that this doesn't matter\n-            for tt in t.direct_super_traits(db) {\n-                if !result.contains(&tt) {\n-                    result.push(tt);\n-                }\n-            }\n-            i += 1;\n-        }\n-        result\n-    }\n-\n-    pub fn associated_type_by_name(self, db: &impl DefDatabase, name: &Name) -> Option<TypeAlias> {\n-        let trait_data = db.trait_data(self.id);\n-        let res =\n-            trait_data.associated_types().map(TypeAlias::from).find(|t| &t.name(db) == name)?;\n-        Some(res)\n-    }\n-\n-    pub fn associated_type_by_name_including_super_traits(\n-        self,\n-        db: &impl HirDatabase,\n-        name: &Name,\n-    ) -> Option<TypeAlias> {\n-        self.all_super_traits(db).into_iter().find_map(|t| t.associated_type_by_name(db, name))\n-    }\n-\n-    pub fn trait_ref(self, db: &impl HirDatabase) -> TraitRef {\n-        TraitRef::for_trait(db, self)\n+        db.trait_data(self.id).items.iter().map(|(_name, it)| (*it).into()).collect()\n     }\n \n     pub fn is_auto(self, db: &impl DefDatabase) -> bool {\n@@ -785,6 +736,11 @@ pub struct TypeAlias {\n }\n \n impl TypeAlias {\n+    pub fn has_non_default_type_params(self, db: &impl HirDatabase) -> bool {\n+        let subst = db.generic_defaults(self.id.into());\n+        subst.iter().any(|ty| ty == &Ty::Unknown)\n+    }\n+\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         Module { id: self.id.lookup(db).module(db) }\n     }\n@@ -821,8 +777,8 @@ impl TypeAlias {\n         db.type_alias_data(self.id).type_ref.clone()\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.type_for_def(self.into(), Namespace::Types)\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        Type::from_def(db, self.id.lookup(db).module(db).krate, self.id)\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Name {\n@@ -897,16 +853,6 @@ impl_froms!(\n     Const\n );\n \n-impl From<AssocItem> for GenericDef {\n-    fn from(item: AssocItem) -> Self {\n-        match item {\n-            AssocItem::Function(f) => f.into(),\n-            AssocItem::Const(c) => c.into(),\n-            AssocItem::TypeAlias(t) => t.into(),\n-        }\n-    }\n-}\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Local {\n     pub(crate) parent: DefWithBody,\n@@ -945,9 +891,14 @@ impl Local {\n         self.parent.module(db)\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        let infer = db.infer(self.parent);\n-        infer[self.pat_id].clone()\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        let def = DefWithBodyId::from(self.parent);\n+        let infer = db.infer(def);\n+        let ty = infer[self.pat_id].clone();\n+        let resolver = def.resolver(db);\n+        let krate = def.module(db).krate;\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        Type { krate, ty: InEnvironment { value: ty, environment } }\n     }\n \n     pub fn source(self, db: &impl HirDatabase) -> Source<Either<ast::BindPat, ast::SelfParam>> {\n@@ -960,7 +911,7 @@ impl Local {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct GenericParam {\n-    pub(crate) parent: GenericDef,\n+    pub(crate) parent: GenericDefId,\n     pub(crate) idx: u32,\n }\n \n@@ -970,6 +921,15 @@ pub struct ImplBlock {\n }\n \n impl ImplBlock {\n+    pub fn all_in_crate(db: &impl HirDatabase, krate: Crate) -> Vec<ImplBlock> {\n+        let impls = db.impls_in_crate(krate.crate_id);\n+        impls.all_impls().map(Self::from).collect()\n+    }\n+    pub fn for_trait(db: &impl HirDatabase, krate: Crate, trait_: Trait) -> Vec<ImplBlock> {\n+        let impls = db.impls_in_crate(krate.crate_id);\n+        impls.lookup_impl_blocks_for_trait(trait_.id).map(Self::from).collect()\n+    }\n+\n     pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n         db.impl_data(self.id).target_trait.clone()\n     }\n@@ -978,13 +938,12 @@ impl ImplBlock {\n         db.impl_data(self.id).target_type.clone()\n     }\n \n-    pub fn target_ty(&self, db: &impl HirDatabase) -> Ty {\n-        Ty::from_hir(db, &self.id.resolver(db), &self.target_type(db))\n-    }\n-\n-    pub fn target_trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n-        let target_ty = self.target_ty(db);\n-        TraitRef::from_hir(db, &self.id.resolver(db), &self.target_trait(db)?, Some(target_ty))\n+    pub fn target_ty(&self, db: &impl HirDatabase) -> Type {\n+        let impl_data = db.impl_data(self.id);\n+        let resolver = self.id.resolver(db);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ty = Ty::from_hir(db, &resolver, &impl_data.target_type);\n+        Type { krate: self.id.module(db).krate, ty: InEnvironment { value: ty, environment } }\n     }\n \n     pub fn items(&self, db: &impl DefDatabase) -> Vec<AssocItem> {\n@@ -1004,6 +963,194 @@ impl ImplBlock {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct Type {\n+    pub(crate) krate: CrateId,\n+    pub(crate) ty: InEnvironment<Ty>,\n+}\n+\n+impl Type {\n+    fn from_def(\n+        db: &impl HirDatabase,\n+        krate: CrateId,\n+        def: impl HasResolver + Into<TyDefId>,\n+    ) -> Type {\n+        let resolver = def.resolver(db);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ty = db.ty(def.into());\n+        Type { krate, ty: InEnvironment { value: ty, environment } }\n+    }\n+\n+    pub fn is_bool(&self) -> bool {\n+        match &self.ty.value {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::Bool => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_mutable_reference(&self) -> bool {\n+        match &self.ty.value {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::Ref(Mutability::Mut) => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_unknown(&self) -> bool {\n+        match &self.ty.value {\n+            Ty::Unknown => true,\n+            _ => false,\n+        }\n+    }\n+\n+    // FIXME: this method is broken, as it doesn't take closures into account.\n+    pub fn as_callable(&self) -> Option<CallableDef> {\n+        Some(self.ty.value.as_callable()?.0)\n+    }\n+\n+    pub fn contains_unknown(&self) -> bool {\n+        return go(&self.ty.value);\n+\n+        fn go(ty: &Ty) -> bool {\n+            match ty {\n+                Ty::Unknown => true,\n+                Ty::Apply(a_ty) => a_ty.parameters.iter().any(go),\n+                _ => false,\n+            }\n+        }\n+    }\n+\n+    pub fn fields(&self, db: &impl HirDatabase) -> Vec<(StructField, Type)> {\n+        if let Ty::Apply(a_ty) = &self.ty.value {\n+            match a_ty.ctor {\n+                ty::TypeCtor::Adt(AdtId::StructId(s)) => {\n+                    let var_def = s.into();\n+                    return db\n+                        .field_types(var_def)\n+                        .iter()\n+                        .map(|(local_id, ty)| {\n+                            let def = StructField { parent: var_def.into(), id: local_id };\n+                            let ty = ty.clone().subst(&a_ty.parameters);\n+                            (def, self.derived(ty))\n+                        })\n+                        .collect();\n+                }\n+                _ => {}\n+            }\n+        };\n+        Vec::new()\n+    }\n+\n+    pub fn tuple_fields(&self, _db: &impl HirDatabase) -> Vec<Type> {\n+        let mut res = Vec::new();\n+        if let Ty::Apply(a_ty) = &self.ty.value {\n+            match a_ty.ctor {\n+                ty::TypeCtor::Tuple { .. } => {\n+                    for ty in a_ty.parameters.iter() {\n+                        let ty = ty.clone().subst(&a_ty.parameters);\n+                        res.push(self.derived(ty));\n+                    }\n+                }\n+                _ => {}\n+            }\n+        };\n+        res\n+    }\n+\n+    pub fn variant_fields(\n+        &self,\n+        db: &impl HirDatabase,\n+        def: VariantDef,\n+    ) -> Vec<(StructField, Type)> {\n+        // FIXME: check that ty and def match\n+        match &self.ty.value {\n+            Ty::Apply(a_ty) => def\n+                .fields(db)\n+                .into_iter()\n+                .map(|it| (it, self.derived(it.ty(db).subst(&a_ty.parameters))))\n+                .collect(),\n+            _ => Vec::new(),\n+        }\n+    }\n+\n+    pub fn autoderef<'a>(&'a self, db: &'a impl HirDatabase) -> impl Iterator<Item = Type> + 'a {\n+        // There should be no inference vars in types passed here\n+        // FIXME check that?\n+        let canonical = crate::ty::Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let environment = self.ty.environment.clone();\n+        let ty = InEnvironment { value: canonical, environment: environment.clone() };\n+        ty::autoderef(db, Some(self.krate), ty)\n+            .map(|canonical| canonical.value)\n+            .map(move |ty| self.derived(ty))\n+    }\n+\n+    // This would be nicer if it just returned an iterator, but that runs into\n+    // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n+    pub fn iterate_impl_items<T>(\n+        self,\n+        db: &impl HirDatabase,\n+        krate: Crate,\n+        mut callback: impl FnMut(AssocItem) -> Option<T>,\n+    ) -> Option<T> {\n+        for krate in self.ty.value.def_crates(db, krate.crate_id)? {\n+            let impls = db.impls_in_crate(krate);\n+\n+            for impl_block in impls.lookup_impl_blocks(&self.ty.value) {\n+                for &item in db.impl_data(impl_block).items.iter() {\n+                    if let Some(result) = callback(item.into()) {\n+                        return Some(result);\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    // FIXME: remove\n+    pub fn into_ty(self) -> Ty {\n+        self.ty.value\n+    }\n+\n+    pub fn as_adt(&self) -> Option<Adt> {\n+        let (adt, _subst) = self.ty.value.as_adt()?;\n+        Some(adt.into())\n+    }\n+\n+    // FIXME: provide required accessors such that it becomes implementable from outside.\n+    pub fn is_equal_for_find_impls(&self, other: &Type) -> bool {\n+        match (&self.ty.value, &other.ty.value) {\n+            (Ty::Apply(a_original_ty), Ty::Apply(ty::ApplicationTy { ctor, parameters })) => {\n+                match ctor {\n+                    TypeCtor::Ref(..) => match parameters.as_single() {\n+                        Ty::Apply(a_ty) => a_original_ty.ctor == a_ty.ctor,\n+                        _ => false,\n+                    },\n+                    _ => a_original_ty.ctor == *ctor,\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn derived(&self, ty: Ty) -> Type {\n+        Type {\n+            krate: self.krate,\n+            ty: InEnvironment { value: ty, environment: self.ty.environment.clone() },\n+        }\n+    }\n+}\n+\n+impl HirDisplay for Type {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> std::fmt::Result {\n+        self.ty.value.hir_fmt(f)\n+    }\n+}\n+\n /// For IDE only\n pub enum ScopeDef {\n     ModuleDef(ModuleDef),"}, {"sha": "bf3ee08341e64ccef45b7fe8ddbfc6f12b8795c5", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -22,7 +22,7 @@ impl Module {\n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n     pub fn definition_source(self, db: &impl DefDatabase) -> Source<ModuleSource> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        let src = def_map[self.id.module_id].definition_source(db);\n+        let src = def_map[self.id.local_id].definition_source(db);\n         src.map(|it| match it {\n             Either::A(it) => ModuleSource::SourceFile(it),\n             Either::B(it) => ModuleSource::Module(it),\n@@ -33,7 +33,7 @@ impl Module {\n     /// `None` for the crate root.\n     pub fn declaration_source(self, db: &impl DefDatabase) -> Option<Source<ast::Module>> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        def_map[self.id.module_id].declaration_source(db)\n+        def_map[self.id.local_id].declaration_source(db)\n     }\n }\n \n@@ -51,13 +51,13 @@ impl HasSource for StructField {\n impl HasSource for Struct {\n     type Ast = ast::StructDef;\n     fn source(self, db: &impl DefDatabase) -> Source<ast::StructDef> {\n-        self.id.0.source(db)\n+        self.id.source(db)\n     }\n }\n impl HasSource for Union {\n-    type Ast = ast::StructDef;\n-    fn source(self, db: &impl DefDatabase) -> Source<ast::StructDef> {\n-        self.id.0.source(db)\n+    type Ast = ast::UnionDef;\n+    fn source(self, db: &impl DefDatabase) -> Source<ast::UnionDef> {\n+        self.id.source(db)\n     }\n }\n impl HasSource for Enum {"}, {"sha": "bfae3660b41fa2e68c58ce20a2ce4aedb823417e", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 12, "deletions": 120, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,130 +1,22 @@\n //! FIXME: write short doc here\n \n-use std::sync::Arc;\n-\n-use ra_arena::map::ArenaMap;\n-use ra_db::salsa;\n-\n-use crate::{\n-    ty::{\n-        method_resolution::CrateImplBlocks,\n-        traits::{AssocTyValue, Impl},\n-        CallableDef, FnSig, GenericPredicate, InferenceResult, Namespace, Substs, Ty, TypableDef,\n-        TypeCtor,\n-    },\n-    Crate, DefWithBody, GenericDef, ImplBlock, Trait,\n-};\n-\n-pub use hir_def::{\n-    db::{\n-        BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQuery, CrateLangItemsQuery,\n-        DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery, ExprScopesQuery,\n-        FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternDatabase,\n-        InternDatabaseStorage, LangItemQuery, ModuleLangItemsQuery, RawItemsQuery,\n-        RawItemsWithSourceMapQuery, StaticDataQuery, StructDataQuery, TraitDataQuery,\n-        TypeAliasDataQuery,\n-    },\n-    LocalStructFieldId, VariantId,\n+pub use hir_def::db::{\n+    BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQuery, CrateLangItemsQuery,\n+    DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery, ExprScopesQuery,\n+    FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternDatabase, InternDatabaseStorage,\n+    LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, RawItemsWithSourceMapQuery,\n+    StaticDataQuery, StructDataQuery, TraitDataQuery, TypeAliasDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n     ParseMacroQuery,\n };\n-\n-#[salsa::query_group(HirDatabaseStorage)]\n-#[salsa::requires(salsa::Database)]\n-pub trait HirDatabase: DefDatabase {\n-    #[salsa::invoke(crate::ty::infer_query)]\n-    fn infer(&self, def: DefWithBody) -> Arc<InferenceResult>;\n-\n-    #[salsa::invoke(crate::ty::type_for_def)]\n-    fn type_for_def(&self, def: TypableDef, ns: Namespace) -> Ty;\n-\n-    #[salsa::invoke(crate::ty::field_types_query)]\n-    fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Ty>>;\n-\n-    #[salsa::invoke(crate::ty::callable_item_sig)]\n-    fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n-\n-    #[salsa::invoke(crate::ty::generic_predicates_for_param_query)]\n-    fn generic_predicates_for_param(\n-        &self,\n-        def: GenericDef,\n-        param_idx: u32,\n-    ) -> Arc<[GenericPredicate]>;\n-\n-    #[salsa::invoke(crate::ty::generic_predicates_query)]\n-    fn generic_predicates(&self, def: GenericDef) -> Arc<[GenericPredicate]>;\n-\n-    #[salsa::invoke(crate::ty::generic_defaults_query)]\n-    fn generic_defaults(&self, def: GenericDef) -> Substs;\n-\n-    #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n-    fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n-\n-    #[salsa::invoke(crate::ty::traits::impls_for_trait_query)]\n-    fn impls_for_trait(&self, krate: Crate, trait_: Trait) -> Arc<[ImplBlock]>;\n-\n-    /// This provides the Chalk trait solver instance. Because Chalk always\n-    /// works from a specific crate, this query is keyed on the crate; and\n-    /// because Chalk does its own internal caching, the solver is wrapped in a\n-    /// Mutex and the query does an untracked read internally, to make sure the\n-    /// cached state is thrown away when input facts change.\n-    #[salsa::invoke(crate::ty::traits::trait_solver_query)]\n-    fn trait_solver(&self, krate: Crate) -> crate::ty::traits::TraitSolver;\n-\n-    // Interned IDs for Chalk integration\n-    #[salsa::interned]\n-    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> crate::ty::TypeCtorId;\n-    #[salsa::interned]\n-    fn intern_chalk_impl(&self, impl_: Impl) -> crate::ty::traits::GlobalImplId;\n-    #[salsa::interned]\n-    fn intern_assoc_ty_value(\n-        &self,\n-        assoc_ty_value: AssocTyValue,\n-    ) -> crate::ty::traits::AssocTyValueId;\n-\n-    #[salsa::invoke(crate::ty::traits::chalk::associated_ty_data_query)]\n-    fn associated_ty_data(\n-        &self,\n-        id: chalk_ir::TypeId,\n-    ) -> Arc<chalk_rust_ir::AssociatedTyDatum<chalk_ir::family::ChalkIr>>;\n-\n-    #[salsa::invoke(crate::ty::traits::chalk::trait_datum_query)]\n-    fn trait_datum(\n-        &self,\n-        krate: Crate,\n-        trait_id: chalk_ir::TraitId,\n-    ) -> Arc<chalk_rust_ir::TraitDatum<chalk_ir::family::ChalkIr>>;\n-\n-    #[salsa::invoke(crate::ty::traits::chalk::struct_datum_query)]\n-    fn struct_datum(\n-        &self,\n-        krate: Crate,\n-        struct_id: chalk_ir::StructId,\n-    ) -> Arc<chalk_rust_ir::StructDatum<chalk_ir::family::ChalkIr>>;\n-\n-    #[salsa::invoke(crate::ty::traits::chalk::impl_datum_query)]\n-    fn impl_datum(\n-        &self,\n-        krate: Crate,\n-        impl_id: chalk_ir::ImplId,\n-    ) -> Arc<chalk_rust_ir::ImplDatum<chalk_ir::family::ChalkIr>>;\n-\n-    #[salsa::invoke(crate::ty::traits::chalk::associated_ty_value_query)]\n-    fn associated_ty_value(\n-        &self,\n-        krate: Crate,\n-        id: chalk_rust_ir::AssociatedTyValueId,\n-    ) -> Arc<chalk_rust_ir::AssociatedTyValue<chalk_ir::family::ChalkIr>>;\n-\n-    #[salsa::invoke(crate::ty::traits::trait_solve_query)]\n-    fn trait_solve(\n-        &self,\n-        krate: Crate,\n-        goal: crate::ty::Canonical<crate::ty::InEnvironment<crate::ty::Obligation>>,\n-    ) -> Option<crate::ty::traits::Solution>;\n-}\n+pub use hir_ty::db::{\n+    AssociatedTyDataQuery, CallableItemSignatureQuery, FieldTypesQuery, GenericDefaultsQuery,\n+    GenericPredicatesQuery, HirDatabase, HirDatabaseStorage, ImplDatumQuery, ImplsForTraitQuery,\n+    ImplsInCrateQuery, InferQuery, StructDatumQuery, TraitDatumQuery, TraitSolveQuery, TyQuery,\n+    ValueTyQuery,\n+};\n \n #[test]\n fn hir_database_is_object_safe() {"}, {"sha": "a9040ea3d566db18b8c45f311b58d1c9ca21c1ee", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 85, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,88 +1,4 @@\n //! FIXME: write short doc here\n-\n-use std::any::Any;\n-\n-use hir_expand::HirFileId;\n-use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n-\n-use crate::{db::AstDatabase, Name, Source};\n-\n pub use hir_def::diagnostics::UnresolvedModule;\n pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n-\n-#[derive(Debug)]\n-pub struct NoSuchField {\n-    pub file: HirFileId,\n-    pub field: AstPtr<ast::RecordField>,\n-}\n-\n-impl Diagnostic for NoSuchField {\n-    fn message(&self) -> String {\n-        \"no such field\".to_string()\n-    }\n-\n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, value: self.field.into() }\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct MissingFields {\n-    pub file: HirFileId,\n-    pub field_list: AstPtr<ast::RecordFieldList>,\n-    pub missed_fields: Vec<Name>,\n-}\n-\n-impl Diagnostic for MissingFields {\n-    fn message(&self) -> String {\n-        \"fill structure fields\".to_string()\n-    }\n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, value: self.field_list.into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-impl AstDiagnostic for MissingFields {\n-    type AST = ast::RecordFieldList;\n-\n-    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.source().file_id).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::RecordFieldList::cast(node).unwrap()\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct MissingOkInTailExpr {\n-    pub file: HirFileId,\n-    pub expr: AstPtr<ast::Expr>,\n-}\n-\n-impl Diagnostic for MissingOkInTailExpr {\n-    fn message(&self) -> String {\n-        \"wrap return expression in Ok\".to_string()\n-    }\n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, value: self.expr.into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-impl AstDiagnostic for MissingOkInTailExpr {\n-    type AST = ast::Expr;\n-\n-    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.file).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::Expr::cast(node).unwrap()\n-    }\n-}\n+pub use hir_ty::diagnostics::{MissingFields, MissingOkInTailExpr, NoSuchField};"}, {"sha": "e96a18d12ac0087745aa177b04866e583e2bc55b", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 26, "deletions": 78, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -4,14 +4,13 @@\n //! are splitting the hir.\n \n use hir_def::{\n-    AdtId, AssocItemId, AttrDefId, ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n-    GenericDefId, ModuleDefId, StaticId, StructFieldId, StructId, TypeAliasId, UnionId, VariantId,\n+    AdtId, AssocItemId, AttrDefId, DefWithBodyId, EnumVariantId, GenericDefId, ModuleDefId,\n+    StructFieldId, VariantId,\n };\n \n use crate::{\n-    ty::{CallableDef, TypableDef},\n-    Adt, AssocItem, AttrDef, Const, Crate, DefWithBody, EnumVariant, Function, GenericDef,\n-    ModuleDef, Static, StructField, TypeAlias, VariantDef,\n+    Adt, AssocItem, AttrDef, Crate, DefWithBody, EnumVariant, GenericDef, ModuleDef, StructField,\n+    VariantDef,\n };\n \n impl From<ra_db::CrateId> for Crate {\n@@ -138,72 +137,6 @@ impl From<GenericDef> for GenericDefId {\n     }\n }\n \n-impl From<GenericDefId> for GenericDef {\n-    fn from(def: GenericDefId) -> Self {\n-        match def {\n-            GenericDefId::FunctionId(it) => GenericDef::Function(it.into()),\n-            GenericDefId::AdtId(it) => GenericDef::Adt(it.into()),\n-            GenericDefId::TraitId(it) => GenericDef::Trait(it.into()),\n-            GenericDefId::TypeAliasId(it) => GenericDef::TypeAlias(it.into()),\n-            GenericDefId::ImplId(it) => GenericDef::ImplBlock(it.into()),\n-            GenericDefId::EnumVariantId(it) => GenericDef::EnumVariant(it.into()),\n-            GenericDefId::ConstId(it) => GenericDef::Const(it.into()),\n-        }\n-    }\n-}\n-\n-impl From<AdtId> for TypableDef {\n-    fn from(id: AdtId) -> Self {\n-        Adt::from(id).into()\n-    }\n-}\n-\n-impl From<StructId> for TypableDef {\n-    fn from(id: StructId) -> Self {\n-        AdtId::StructId(id).into()\n-    }\n-}\n-\n-impl From<UnionId> for TypableDef {\n-    fn from(id: UnionId) -> Self {\n-        AdtId::UnionId(id).into()\n-    }\n-}\n-\n-impl From<EnumId> for TypableDef {\n-    fn from(id: EnumId) -> Self {\n-        AdtId::EnumId(id).into()\n-    }\n-}\n-\n-impl From<EnumVariantId> for TypableDef {\n-    fn from(id: EnumVariantId) -> Self {\n-        EnumVariant::from(id).into()\n-    }\n-}\n-\n-impl From<TypeAliasId> for TypableDef {\n-    fn from(id: TypeAliasId) -> Self {\n-        TypeAlias::from(id).into()\n-    }\n-}\n-\n-impl From<FunctionId> for TypableDef {\n-    fn from(id: FunctionId) -> Self {\n-        Function::from(id).into()\n-    }\n-}\n-impl From<ConstId> for TypableDef {\n-    fn from(id: ConstId) -> Self {\n-        Const::from(id).into()\n-    }\n-}\n-impl From<StaticId> for TypableDef {\n-    fn from(id: StaticId) -> Self {\n-        Static::from(id).into()\n-    }\n-}\n-\n impl From<Adt> for GenericDefId {\n     fn from(id: Adt) -> Self {\n         match id {\n@@ -214,14 +147,12 @@ impl From<Adt> for GenericDefId {\n     }\n }\n \n-impl From<CallableDef> for GenericDefId {\n-    fn from(def: CallableDef) -> Self {\n+impl From<VariantId> for VariantDef {\n+    fn from(def: VariantId) -> Self {\n         match def {\n-            CallableDef::Function(it) => it.id.into(),\n-            CallableDef::Struct(it) => it.id.into(),\n-            CallableDef::EnumVariant(it) => {\n-                EnumVariantId { parent: it.parent.id, local_id: it.id }.into()\n-            }\n+            VariantId::StructId(it) => VariantDef::Struct(it.into()),\n+            VariantId::EnumVariantId(it) => VariantDef::EnumVariant(it.into()),\n+            VariantId::UnionId(it) => VariantDef::Union(it.into()),\n         }\n     }\n }\n@@ -231,6 +162,7 @@ impl From<VariantDef> for VariantId {\n         match def {\n             VariantDef::Struct(it) => VariantId::StructId(it.id),\n             VariantDef::EnumVariant(it) => VariantId::EnumVariantId(it.into()),\n+            VariantDef::Union(it) => VariantId::UnionId(it.id),\n         }\n     }\n }\n@@ -241,6 +173,12 @@ impl From<StructField> for StructFieldId {\n     }\n }\n \n+impl From<StructFieldId> for StructField {\n+    fn from(def: StructFieldId) -> Self {\n+        StructField { parent: def.parent.into(), id: def.local_id }\n+    }\n+}\n+\n impl From<AttrDef> for AttrDefId {\n     fn from(def: AttrDef) -> Self {\n         match def {\n@@ -257,3 +195,13 @@ impl From<AttrDef> for AttrDefId {\n         }\n     }\n }\n+\n+impl From<AssocItem> for GenericDefId {\n+    fn from(item: AssocItem) -> Self {\n+        match item {\n+            AssocItem::Function(f) => f.id.into(),\n+            AssocItem::Const(c) => c.id.into(),\n+            AssocItem::TypeAlias(t) => t.id.into(),\n+        }\n+    }\n+}"}, {"sha": "9f7c22b21182c892326f205a4ad9603e3fcabe7b", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir_def::{AstItemDef, LocationCtx, ModuleId, StructId, StructOrUnionId, UnionId};\n+use hir_def::{AstItemDef, LocationCtx, ModuleId};\n use hir_expand::{name::AsName, AstId, MacroDefId, MacroDefKind};\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n@@ -19,19 +19,18 @@ pub trait FromSource: Sized {\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self>;\n }\n \n-// FIXIME: these two impls are wrong, `ast::StructDef` might produce either a struct or a union\n impl FromSource for Struct {\n     type Ast = ast::StructDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id: StructOrUnionId = from_source(db, src)?;\n-        Some(Struct { id: StructId(id) })\n+        let id = from_source(db, src)?;\n+        Some(Struct { id })\n     }\n }\n impl FromSource for Union {\n-    type Ast = ast::StructDef;\n+    type Ast = ast::UnionDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id: StructOrUnionId = from_source(db, src)?;\n-        Some(Union { id: UnionId(id) })\n+        let id = from_source(db, src)?;\n+        Some(Union { id })\n     }\n }\n impl FromSource for Enum {\n@@ -263,13 +262,12 @@ impl Module {\n \n         let original_file = src.file_id.original_file(db);\n \n-        let (krate, module_id) =\n-            db.relevant_crates(original_file).iter().find_map(|&crate_id| {\n-                let crate_def_map = db.crate_def_map(crate_id);\n-                let local_module_id = crate_def_map.modules_for_file(original_file).next()?;\n-                Some((crate_id, local_module_id))\n-            })?;\n-        Some(Module { id: ModuleId { krate, module_id } })\n+        let (krate, local_id) = db.relevant_crates(original_file).iter().find_map(|&crate_id| {\n+            let crate_def_map = db.crate_def_map(crate_id);\n+            let local_id = crate_def_map.modules_for_file(original_file).next()?;\n+            Some((crate_id, local_id))\n+        })?;\n+        Some(Module { id: ModuleId { krate, local_id } })\n     }\n }\n "}, {"sha": "3c12c61f030afa4a7ad0309b60b0b764a9f479aa", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -32,28 +32,20 @@ pub mod db;\n pub mod source_binder;\n \n mod ty;\n-mod expr;\n pub mod diagnostics;\n-mod util;\n \n mod from_id;\n mod code_model;\n \n pub mod from_source;\n \n-#[cfg(test)]\n-mod test_db;\n-#[cfg(test)]\n-mod marks;\n-\n pub use crate::{\n     code_model::{\n         src::HasSource, Adt, AssocItem, AttrDef, Const, Container, Crate, CrateDependency,\n         DefWithBody, Docs, Enum, EnumVariant, FieldSource, Function, GenericDef, GenericParam,\n         HasAttrs, ImplBlock, Import, Local, MacroDef, Module, ModuleDef, ModuleSource, ScopeDef,\n-        Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n+        Static, Struct, StructField, Trait, Type, TypeAlias, Union, VariantDef,\n     },\n-    expr::ExprScopes,\n     from_source::FromSource,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     ty::{\n@@ -64,6 +56,7 @@ pub use crate::{\n };\n \n pub use hir_def::{\n+    body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     path::{Path, PathKind},"}, {"sha": "76c493f1a836acbaef7101f56217164c5348b09f", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 55, "deletions": 58, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -8,13 +8,17 @@\n use std::sync::Arc;\n \n use hir_def::{\n+    body::{\n+        scope::{ExprScopes, ScopeId},\n+        BodySourceMap,\n+    },\n     expr::{ExprId, PatId},\n     path::known,\n     resolver::{self, resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},\n-    DefWithBodyId,\n+    AssocItemId, DefWithBodyId,\n };\n use hir_expand::{\n-    name::AsName, AstId, HirFileId, MacroCallId, MacroCallLoc, MacroFileKind, Source,\n+    hygiene::Hygiene, name::AsName, AstId, HirFileId, MacroCallId, MacroFileKind, Source,\n };\n use ra_syntax::{\n     ast::{self, AstNode},\n@@ -25,10 +29,12 @@ use ra_syntax::{\n \n use crate::{\n     db::HirDatabase,\n-    expr::{BodySourceMap, ExprScopes, ScopeId},\n-    ty::method_resolution::{self, implements_trait},\n+    ty::{\n+        method_resolution::{self, implements_trait},\n+        InEnvironment, TraitEnvironment, Ty,\n+    },\n     Adt, AssocItem, Const, DefWithBody, Either, Enum, EnumVariant, FromSource, Function,\n-    GenericParam, Local, MacroDef, Name, Path, ScopeDef, Static, Struct, Trait, Ty, TypeAlias,\n+    GenericParam, Local, MacroDef, Name, Path, ScopeDef, Static, Struct, Trait, Type, TypeAlias,\n };\n \n fn try_get_resolver_for_node(db: &impl HirDatabase, node: Source<&SyntaxNode>) -> Option<Resolver> {\n@@ -88,7 +94,7 @@ pub struct SourceAnalyzer {\n     body_owner: Option<DefWithBody>,\n     body_source_map: Option<Arc<BodySourceMap>>,\n     infer: Option<Arc<crate::ty::InferenceResult>>,\n-    scopes: Option<Arc<crate::expr::ExprScopes>>,\n+    scopes: Option<Arc<ExprScopes>>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -165,7 +171,7 @@ impl SourceAnalyzer {\n                 resolver,\n                 body_owner: Some(def),\n                 body_source_map: Some(source_map),\n-                infer: Some(db.infer(def)),\n+                infer: Some(db.infer(def.into())),\n                 scopes: Some(scopes),\n                 file_id: node.file_id,\n             }\n@@ -195,48 +201,52 @@ impl SourceAnalyzer {\n         self.body_source_map.as_ref()?.node_pat(src)\n     }\n \n-    pub fn type_of(&self, _db: &impl HirDatabase, expr: &ast::Expr) -> Option<crate::Ty> {\n+    pub fn type_of(&self, db: &impl HirDatabase, expr: &ast::Expr) -> Option<Type> {\n         let expr_id = self.expr_id(expr)?;\n-        Some(self.infer.as_ref()?[expr_id].clone())\n+        let ty = self.infer.as_ref()?[expr_id].clone();\n+        let environment = TraitEnvironment::lower(db, &self.resolver);\n+        Some(Type { krate: self.resolver.krate()?, ty: InEnvironment { value: ty, environment } })\n     }\n \n-    pub fn type_of_pat(&self, _db: &impl HirDatabase, pat: &ast::Pat) -> Option<crate::Ty> {\n+    pub fn type_of_pat(&self, db: &impl HirDatabase, pat: &ast::Pat) -> Option<Type> {\n         let pat_id = self.pat_id(pat)?;\n-        Some(self.infer.as_ref()?[pat_id].clone())\n+        let ty = self.infer.as_ref()?[pat_id].clone();\n+        let environment = TraitEnvironment::lower(db, &self.resolver);\n+        Some(Type { krate: self.resolver.krate()?, ty: InEnvironment { value: ty, environment } })\n     }\n \n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n         let expr_id = self.expr_id(&call.clone().into())?;\n-        self.infer.as_ref()?.method_resolution(expr_id)\n+        self.infer.as_ref()?.method_resolution(expr_id).map(Function::from)\n     }\n \n     pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<crate::StructField> {\n         let expr_id = self.expr_id(&field.clone().into())?;\n-        self.infer.as_ref()?.field_resolution(expr_id)\n+        self.infer.as_ref()?.field_resolution(expr_id).map(|it| it.into())\n     }\n \n     pub fn resolve_record_field(&self, field: &ast::RecordField) -> Option<crate::StructField> {\n         let expr_id = self.expr_id(&field.expr()?)?;\n-        self.infer.as_ref()?.record_field_resolution(expr_id)\n+        self.infer.as_ref()?.record_field_resolution(expr_id).map(|it| it.into())\n     }\n \n     pub fn resolve_record_literal(&self, record_lit: &ast::RecordLit) -> Option<crate::VariantDef> {\n         let expr_id = self.expr_id(&record_lit.clone().into())?;\n-        self.infer.as_ref()?.variant_resolution_for_expr(expr_id)\n+        self.infer.as_ref()?.variant_resolution_for_expr(expr_id).map(|it| it.into())\n     }\n \n     pub fn resolve_record_pattern(&self, record_pat: &ast::RecordPat) -> Option<crate::VariantDef> {\n         let pat_id = self.pat_id(&record_pat.clone().into())?;\n-        self.infer.as_ref()?.variant_resolution_for_pat(pat_id)\n+        self.infer.as_ref()?.variant_resolution_for_pat(pat_id).map(|it| it.into())\n     }\n \n     pub fn resolve_macro_call(\n         &self,\n         db: &impl HirDatabase,\n-        macro_call: &ast::MacroCall,\n+        macro_call: Source<&ast::MacroCall>,\n     ) -> Option<MacroDef> {\n-        // This must be a normal source file rather than macro file.\n-        let path = macro_call.path().and_then(Path::from_ast)?;\n+        let hygiene = Hygiene::new(db, macro_call.file_id);\n+        let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &hygiene))?;\n         self.resolver.resolve_path_as_macro(db, &path).map(|it| it.into())\n     }\n \n@@ -248,7 +258,7 @@ impl SourceAnalyzer {\n         let types = self.resolver.resolve_path_in_type_ns_fully(db, &path).map(|ty| match ty {\n             TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n             TypeNs::GenericParam(idx) => PathResolution::GenericParam(GenericParam {\n-                parent: self.resolver.generic_def().unwrap().into(),\n+                parent: self.resolver.generic_def().unwrap(),\n                 idx,\n             }),\n             TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => {\n@@ -290,13 +300,13 @@ impl SourceAnalyzer {\n         if let Some(path_expr) = path.syntax().parent().and_then(ast::PathExpr::cast) {\n             let expr_id = self.expr_id(&path_expr.into())?;\n             if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_expr(expr_id) {\n-                return Some(PathResolution::AssocItem(assoc));\n+                return Some(PathResolution::AssocItem(assoc.into()));\n             }\n         }\n         if let Some(path_pat) = path.syntax().parent().and_then(ast::PathPat::cast) {\n             let pat_id = self.pat_id(&path_pat.into())?;\n             if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_pat(pat_id) {\n-                return Some(PathResolution::AssocItem(assoc));\n+                return Some(PathResolution::AssocItem(assoc.into()));\n             }\n         }\n         // This must be a normal source file rather than macro file.\n@@ -323,7 +333,7 @@ impl SourceAnalyzer {\n                 resolver::ScopeDef::ImplSelfType(it) => ScopeDef::ImplSelfType(it.into()),\n                 resolver::ScopeDef::AdtSelfType(it) => ScopeDef::AdtSelfType(it.into()),\n                 resolver::ScopeDef::GenericParam(idx) => {\n-                    let parent = self.resolver.generic_def().unwrap().into();\n+                    let parent = self.resolver.generic_def().unwrap();\n                     ScopeDef::GenericParam(GenericParam { parent, idx })\n                 }\n                 resolver::ScopeDef::Local(pat_id) => {\n@@ -358,22 +368,22 @@ impl SourceAnalyzer {\n     pub fn iterate_method_candidates<T>(\n         &self,\n         db: &impl HirDatabase,\n-        ty: Ty,\n+        ty: &Type,\n         name: Option<&Name>,\n         mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n     ) -> Option<T> {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        let canonical = crate::ty::Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n         method_resolution::iterate_method_candidates(\n             &canonical,\n             db,\n             &self.resolver,\n             name,\n             method_resolution::LookupMode::MethodCall,\n             |ty, it| match it {\n-                AssocItem::Function(f) => callback(ty, f),\n+                AssocItemId::FunctionId(f) => callback(ty, f.into()),\n                 _ => None,\n             },\n         )\n@@ -382,34 +392,37 @@ impl SourceAnalyzer {\n     pub fn iterate_path_candidates<T>(\n         &self,\n         db: &impl HirDatabase,\n-        ty: Ty,\n+        ty: &Type,\n         name: Option<&Name>,\n-        callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n+        mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        let canonical = crate::ty::Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n         method_resolution::iterate_method_candidates(\n             &canonical,\n             db,\n             &self.resolver,\n             name,\n             method_resolution::LookupMode::Path,\n-            callback,\n+            |ty, it| callback(ty, it.into()),\n         )\n     }\n \n-    pub fn autoderef<'a>(\n-        &'a self,\n-        db: &'a impl HirDatabase,\n-        ty: Ty,\n-    ) -> impl Iterator<Item = Ty> + 'a {\n-        // There should be no inference vars in types passed here\n-        // FIXME check that?\n-        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n-        crate::ty::autoderef(db, &self.resolver, canonical).map(|canonical| canonical.value)\n-    }\n+    // pub fn autoderef<'a>(\n+    //     &'a self,\n+    //     db: &'a impl HirDatabase,\n+    //     ty: Ty,\n+    // ) -> impl Iterator<Item = Ty> + 'a {\n+    //     // There should be no inference vars in types passed here\n+    //     // FIXME check that?\n+    //     let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+    //     let krate = self.resolver.krate();\n+    //     let environment = TraitEnvironment::lower(db, &self.resolver);\n+    //     let ty = crate::ty::InEnvironment { value: canonical, environment };\n+    //     crate::ty::autoderef(db, krate, ty).map(|canonical| canonical.value)\n+    // }\n \n     /// Checks that particular type `ty` implements `std::future::Future`.\n     /// This function is used in `.await` syntax completion.\n@@ -435,32 +448,16 @@ impl SourceAnalyzer {\n         db: &impl HirDatabase,\n         macro_call: Source<&ast::MacroCall>,\n     ) -> Option<Expansion> {\n-        let def = self.resolve_macro_call(db, macro_call.value)?.id;\n+        let def = self.resolve_macro_call(db, macro_call)?.id;\n         let ast_id = AstId::new(\n             macro_call.file_id,\n             db.ast_id_map(macro_call.file_id).ast_id(macro_call.value),\n         );\n-        let macro_call_loc = MacroCallLoc { def, ast_id };\n         Some(Expansion {\n-            macro_call_id: db.intern_macro(macro_call_loc),\n+            macro_call_id: def.as_call_id(db, ast_id),\n             macro_file_kind: to_macro_file_kind(macro_call.value),\n         })\n     }\n-\n-    #[cfg(test)]\n-    pub(crate) fn body_source_map(&self) -> Arc<BodySourceMap> {\n-        self.body_source_map.clone().unwrap()\n-    }\n-\n-    #[cfg(test)]\n-    pub(crate) fn inference_result(&self) -> Arc<crate::ty::InferenceResult> {\n-        self.infer.clone().unwrap()\n-    }\n-\n-    #[cfg(test)]\n-    pub(crate) fn analyzed_declaration(&self) -> Option<DefWithBody> {\n-        self.body_owner\n-    }\n }\n \n fn scope_for("}, {"sha": "4ed69c00dc4f8a951429b7d1f6071800a90762fb", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1091, "changes": 1092, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,1094 +1,4 @@\n //! The type system. We currently use this to infer types for completion, hover\n //! information and various assists.\n \n-mod autoderef;\n-pub(crate) mod primitive;\n-pub(crate) mod traits;\n-pub(crate) mod method_resolution;\n-mod op;\n-mod lower;\n-mod infer;\n-pub(crate) mod display;\n-\n-#[cfg(test)]\n-mod tests;\n-\n-use std::ops::Deref;\n-use std::sync::Arc;\n-use std::{fmt, iter, mem};\n-\n-use hir_def::{generics::GenericParams, AdtId};\n-use ra_db::{impl_intern_key, salsa};\n-\n-use crate::{\n-    db::HirDatabase, expr::ExprId, util::make_mut_slice, Adt, Crate, DefWithBody, FloatTy,\n-    GenericDef, IntTy, Mutability, Name, Trait, TypeAlias, Uncertain,\n-};\n-use display::{HirDisplay, HirFormatter};\n-\n-pub(crate) use autoderef::autoderef;\n-pub(crate) use infer::{infer_query, InferTy, InferenceResult};\n-pub use lower::CallableDef;\n-pub(crate) use lower::{\n-    callable_item_sig, field_types_query, generic_defaults_query,\n-    generic_predicates_for_param_query, generic_predicates_query, type_for_def, Namespace,\n-    TypableDef,\n-};\n-pub(crate) use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n-\n-/// A type constructor or type name: this might be something like the primitive\n-/// type `bool`, a struct like `Vec`, or things like function pointers or\n-/// tuples.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum TypeCtor {\n-    /// The primitive boolean type. Written as `bool`.\n-    Bool,\n-\n-    /// The primitive character type; holds a Unicode scalar value\n-    /// (a non-surrogate code point). Written as `char`.\n-    Char,\n-\n-    /// A primitive integer type. For example, `i32`.\n-    Int(Uncertain<IntTy>),\n-\n-    /// A primitive floating-point type. For example, `f64`.\n-    Float(Uncertain<FloatTy>),\n-\n-    /// Structures, enumerations and unions.\n-    Adt(Adt),\n-\n-    /// The pointee of a string slice. Written as `str`.\n-    Str,\n-\n-    /// The pointee of an array slice.  Written as `[T]`.\n-    Slice,\n-\n-    /// An array with the given length. Written as `[T; n]`.\n-    Array,\n-\n-    /// A raw pointer. Written as `*mut T` or `*const T`\n-    RawPtr(Mutability),\n-\n-    /// A reference; a pointer with an associated lifetime. Written as\n-    /// `&'a mut T` or `&'a T`.\n-    Ref(Mutability),\n-\n-    /// The anonymous type of a function declaration/definition. Each\n-    /// function has a unique type, which is output (for a function\n-    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n-    ///\n-    /// This includes tuple struct / enum variant constructors as well.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar = foo; // bar: fn() -> i32 {foo}\n-    /// ```\n-    FnDef(CallableDef),\n-\n-    /// A pointer to a function.  Written as `fn() -> i32`.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar: fn() -> i32 = foo;\n-    /// ```\n-    FnPtr { num_args: u16 },\n-\n-    /// The never type `!`.\n-    Never,\n-\n-    /// A tuple type.  For example, `(i32, bool)`.\n-    Tuple { cardinality: u16 },\n-\n-    /// Represents an associated item like `Iterator::Item`.  This is used\n-    /// when we have tried to normalize a projection like `T::Item` but\n-    /// couldn't find a better representation.  In that case, we generate\n-    /// an **application type** like `(Iterator::Item)<T>`.\n-    AssociatedType(TypeAlias),\n-\n-    /// The type of a specific closure.\n-    ///\n-    /// The closure signature is stored in a `FnPtr` type in the first type\n-    /// parameter.\n-    Closure { def: DefWithBody, expr: ExprId },\n-}\n-\n-/// This exists just for Chalk, because Chalk just has a single `StructId` where\n-/// we have different kinds of ADTs, primitive types and special type\n-/// constructors like tuples and function pointers.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TypeCtorId(salsa::InternId);\n-impl_intern_key!(TypeCtorId);\n-\n-impl TypeCtor {\n-    pub fn num_ty_params(self, db: &impl HirDatabase) -> usize {\n-        match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n-            | TypeCtor::Str\n-            | TypeCtor::Never => 0,\n-            TypeCtor::Slice\n-            | TypeCtor::Array\n-            | TypeCtor::RawPtr(_)\n-            | TypeCtor::Ref(_)\n-            | TypeCtor::Closure { .. } // 1 param representing the signature of the closure\n-            => 1,\n-            TypeCtor::Adt(adt) => {\n-                let generic_params = db.generic_params(AdtId::from(adt).into());\n-                generic_params.count_params_including_parent()\n-            }\n-            TypeCtor::FnDef(callable) => {\n-                let generic_params = db.generic_params(callable.into());\n-                generic_params.count_params_including_parent()\n-            }\n-            TypeCtor::AssociatedType(type_alias) => {\n-                let generic_params = db.generic_params(type_alias.id.into());\n-                generic_params.count_params_including_parent()\n-            }\n-            TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n-            TypeCtor::Tuple { cardinality } => cardinality as usize,\n-        }\n-    }\n-\n-    pub fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n-        match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n-            | TypeCtor::Str\n-            | TypeCtor::Never\n-            | TypeCtor::Slice\n-            | TypeCtor::Array\n-            | TypeCtor::RawPtr(_)\n-            | TypeCtor::Ref(_)\n-            | TypeCtor::FnPtr { .. }\n-            | TypeCtor::Tuple { .. } => None,\n-            TypeCtor::Closure { def, .. } => def.krate(db),\n-            TypeCtor::Adt(adt) => adt.krate(db),\n-            TypeCtor::FnDef(callable) => callable.krate(db),\n-            TypeCtor::AssociatedType(type_alias) => type_alias.krate(db),\n-        }\n-    }\n-\n-    pub fn as_generic_def(self) -> Option<crate::GenericDef> {\n-        match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n-            | TypeCtor::Str\n-            | TypeCtor::Never\n-            | TypeCtor::Slice\n-            | TypeCtor::Array\n-            | TypeCtor::RawPtr(_)\n-            | TypeCtor::Ref(_)\n-            | TypeCtor::FnPtr { .. }\n-            | TypeCtor::Tuple { .. }\n-            | TypeCtor::Closure { .. } => None,\n-            TypeCtor::Adt(adt) => Some(adt.into()),\n-            TypeCtor::FnDef(callable) => Some(callable.into()),\n-            TypeCtor::AssociatedType(type_alias) => Some(type_alias.into()),\n-        }\n-    }\n-}\n-\n-/// A nominal type with (maybe 0) type parameters. This might be a primitive\n-/// type like `bool`, a struct, tuple, function pointer, reference or\n-/// several other things.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct ApplicationTy {\n-    pub ctor: TypeCtor,\n-    pub parameters: Substs,\n-}\n-\n-/// A \"projection\" type corresponds to an (unnormalized)\n-/// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n-/// trait and all its parameters are fully known.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct ProjectionTy {\n-    pub associated_ty: TypeAlias,\n-    pub parameters: Substs,\n-}\n-\n-impl ProjectionTy {\n-    pub fn trait_ref(&self, db: &impl HirDatabase) -> TraitRef {\n-        TraitRef {\n-            trait_: self\n-                .associated_ty\n-                .parent_trait(db)\n-                .expect(\"projection ty without parent trait\"),\n-            substs: self.parameters.clone(),\n-        }\n-    }\n-}\n-\n-impl TypeWalk for ProjectionTy {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.parameters.walk(f);\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        self.parameters.walk_mut_binders(f, binders);\n-    }\n-}\n-\n-/// A type.\n-///\n-/// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n-/// the same thing (but in a different way).\n-///\n-/// This should be cheap to clone.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum Ty {\n-    /// A nominal type with (maybe 0) type parameters. This might be a primitive\n-    /// type like `bool`, a struct, tuple, function pointer, reference or\n-    /// several other things.\n-    Apply(ApplicationTy),\n-\n-    /// A \"projection\" type corresponds to an (unnormalized)\n-    /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n-    /// trait and all its parameters are fully known.\n-    Projection(ProjectionTy),\n-\n-    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n-    Param {\n-        /// The index of the parameter (starting with parameters from the\n-        /// surrounding impl, then the current function).\n-        idx: u32,\n-        /// The name of the parameter, for displaying.\n-        // FIXME get rid of this\n-        name: Name,\n-    },\n-\n-    /// A bound type variable. Used during trait resolution to represent Chalk\n-    /// variables, and in `Dyn` and `Opaque` bounds to represent the `Self` type.\n-    Bound(u32),\n-\n-    /// A type variable used during type checking. Not to be confused with a\n-    /// type parameter.\n-    Infer(InferTy),\n-\n-    /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n-    ///\n-    /// The predicates are quantified over the `Self` type, i.e. `Ty::Bound(0)`\n-    /// represents the `Self` type inside the bounds. This is currently\n-    /// implicit; Chalk has the `Binders` struct to make it explicit, but it\n-    /// didn't seem worth the overhead yet.\n-    Dyn(Arc<[GenericPredicate]>),\n-\n-    /// An opaque type (`impl Trait`).\n-    ///\n-    /// The predicates are quantified over the `Self` type; see `Ty::Dyn` for\n-    /// more.\n-    Opaque(Arc<[GenericPredicate]>),\n-\n-    /// A placeholder for a type which could not be computed; this is propagated\n-    /// to avoid useless error messages. Doubles as a placeholder where type\n-    /// variables are inserted before type checking, since we want to try to\n-    /// infer a better type here anyway -- for the IDE use case, we want to try\n-    /// to infer as much as possible even in the presence of type errors.\n-    Unknown,\n-}\n-\n-/// A list of substitutions for generic parameters.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Substs(Arc<[Ty]>);\n-\n-impl TypeWalk for Substs {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.0.iter() {\n-            t.walk(f);\n-        }\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        for t in make_mut_slice(&mut self.0) {\n-            t.walk_mut_binders(f, binders);\n-        }\n-    }\n-}\n-\n-impl Substs {\n-    pub fn empty() -> Substs {\n-        Substs(Arc::new([]))\n-    }\n-\n-    pub fn single(ty: Ty) -> Substs {\n-        Substs(Arc::new([ty]))\n-    }\n-\n-    pub fn prefix(&self, n: usize) -> Substs {\n-        Substs(self.0[..std::cmp::min(self.0.len(), n)].into())\n-    }\n-\n-    pub fn as_single(&self) -> &Ty {\n-        if self.0.len() != 1 {\n-            panic!(\"expected substs of len 1, got {:?}\", self);\n-        }\n-        &self.0[0]\n-    }\n-\n-    /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub fn identity(generic_params: &GenericParams) -> Substs {\n-        Substs(\n-            generic_params\n-                .params_including_parent()\n-                .into_iter()\n-                .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n-                .collect(),\n-        )\n-    }\n-\n-    /// Return Substs that replace each parameter by a bound variable.\n-    pub fn bound_vars(generic_params: &GenericParams) -> Substs {\n-        Substs(\n-            generic_params\n-                .params_including_parent()\n-                .into_iter()\n-                .map(|p| Ty::Bound(p.idx))\n-                .collect(),\n-        )\n-    }\n-\n-    pub fn build_for_def(db: &impl HirDatabase, def: impl Into<GenericDef>) -> SubstsBuilder {\n-        let def = def.into();\n-        let params = db.generic_params(def.into());\n-        let param_count = params.count_params_including_parent();\n-        Substs::builder(param_count)\n-    }\n-\n-    pub fn build_for_generics(generic_params: &GenericParams) -> SubstsBuilder {\n-        Substs::builder(generic_params.count_params_including_parent())\n-    }\n-\n-    pub fn build_for_type_ctor(db: &impl HirDatabase, type_ctor: TypeCtor) -> SubstsBuilder {\n-        Substs::builder(type_ctor.num_ty_params(db))\n-    }\n-\n-    fn builder(param_count: usize) -> SubstsBuilder {\n-        SubstsBuilder { vec: Vec::with_capacity(param_count), param_count }\n-    }\n-}\n-\n-#[derive(Debug, Clone)]\n-pub struct SubstsBuilder {\n-    vec: Vec<Ty>,\n-    param_count: usize,\n-}\n-\n-impl SubstsBuilder {\n-    pub fn build(self) -> Substs {\n-        assert_eq!(self.vec.len(), self.param_count);\n-        Substs(self.vec.into())\n-    }\n-\n-    pub fn push(mut self, ty: Ty) -> Self {\n-        self.vec.push(ty);\n-        self\n-    }\n-\n-    fn remaining(&self) -> usize {\n-        self.param_count - self.vec.len()\n-    }\n-\n-    pub fn fill_with_bound_vars(self, starting_from: u32) -> Self {\n-        self.fill((starting_from..).map(Ty::Bound))\n-    }\n-\n-    pub fn fill_with_params(self) -> Self {\n-        let start = self.vec.len() as u32;\n-        self.fill((start..).map(|idx| Ty::Param { idx, name: Name::missing() }))\n-    }\n-\n-    pub fn fill_with_unknown(self) -> Self {\n-        self.fill(iter::repeat(Ty::Unknown))\n-    }\n-\n-    pub fn fill(mut self, filler: impl Iterator<Item = Ty>) -> Self {\n-        self.vec.extend(filler.take(self.remaining()));\n-        assert_eq!(self.remaining(), 0);\n-        self\n-    }\n-\n-    pub fn use_parent_substs(mut self, parent_substs: &Substs) -> Self {\n-        assert!(self.vec.is_empty());\n-        assert!(parent_substs.len() <= self.param_count);\n-        self.vec.extend(parent_substs.iter().cloned());\n-        self\n-    }\n-}\n-\n-impl Deref for Substs {\n-    type Target = [Ty];\n-\n-    fn deref(&self) -> &[Ty] {\n-        &self.0\n-    }\n-}\n-\n-/// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n-/// Name to be bikeshedded: TraitBound? TraitImplements?\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct TraitRef {\n-    /// FIXME name?\n-    pub trait_: Trait,\n-    pub substs: Substs,\n-}\n-\n-impl TraitRef {\n-    pub fn self_ty(&self) -> &Ty {\n-        &self.substs[0]\n-    }\n-}\n-\n-impl TypeWalk for TraitRef {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.substs.walk(f);\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        self.substs.walk_mut_binders(f, binders);\n-    }\n-}\n-\n-/// Like `generics::WherePredicate`, but with resolved types: A condition on the\n-/// parameters of a generic item.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum GenericPredicate {\n-    /// The given trait needs to be implemented for its type parameters.\n-    Implemented(TraitRef),\n-    /// An associated type bindings like in `Iterator<Item = T>`.\n-    Projection(ProjectionPredicate),\n-    /// We couldn't resolve the trait reference. (If some type parameters can't\n-    /// be resolved, they will just be Unknown).\n-    Error,\n-}\n-\n-impl GenericPredicate {\n-    pub fn is_error(&self) -> bool {\n-        match self {\n-            GenericPredicate::Error => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_implemented(&self) -> bool {\n-        match self {\n-            GenericPredicate::Implemented(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n-        match self {\n-            GenericPredicate::Implemented(tr) => Some(tr.clone()),\n-            GenericPredicate::Projection(proj) => Some(proj.projection_ty.trait_ref(db)),\n-            GenericPredicate::Error => None,\n-        }\n-    }\n-}\n-\n-impl TypeWalk for GenericPredicate {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self {\n-            GenericPredicate::Implemented(trait_ref) => trait_ref.walk(f),\n-            GenericPredicate::Projection(projection_pred) => projection_pred.walk(f),\n-            GenericPredicate::Error => {}\n-        }\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        match self {\n-            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut_binders(f, binders),\n-            GenericPredicate::Projection(projection_pred) => {\n-                projection_pred.walk_mut_binders(f, binders)\n-            }\n-            GenericPredicate::Error => {}\n-        }\n-    }\n-}\n-\n-/// Basically a claim (currently not validated / checked) that the contained\n-/// type / trait ref contains no inference variables; any inference variables it\n-/// contained have been replaced by bound variables, and `num_vars` tells us how\n-/// many there are. This is used to erase irrelevant differences between types\n-/// before using them in queries.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Canonical<T> {\n-    pub value: T,\n-    pub num_vars: usize,\n-}\n-\n-/// A function signature as seen by type inference: Several parameter types and\n-/// one return type.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct FnSig {\n-    params_and_return: Arc<[Ty]>,\n-}\n-\n-impl FnSig {\n-    pub fn from_params_and_return(mut params: Vec<Ty>, ret: Ty) -> FnSig {\n-        params.push(ret);\n-        FnSig { params_and_return: params.into() }\n-    }\n-\n-    pub fn from_fn_ptr_substs(substs: &Substs) -> FnSig {\n-        FnSig { params_and_return: Arc::clone(&substs.0) }\n-    }\n-\n-    pub fn params(&self) -> &[Ty] {\n-        &self.params_and_return[0..self.params_and_return.len() - 1]\n-    }\n-\n-    pub fn ret(&self) -> &Ty {\n-        &self.params_and_return[self.params_and_return.len() - 1]\n-    }\n-}\n-\n-impl TypeWalk for FnSig {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.params_and_return.iter() {\n-            t.walk(f);\n-        }\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        for t in make_mut_slice(&mut self.params_and_return) {\n-            t.walk_mut_binders(f, binders);\n-        }\n-    }\n-}\n-\n-impl Ty {\n-    pub fn simple(ctor: TypeCtor) -> Ty {\n-        Ty::Apply(ApplicationTy { ctor, parameters: Substs::empty() })\n-    }\n-    pub fn apply_one(ctor: TypeCtor, param: Ty) -> Ty {\n-        Ty::Apply(ApplicationTy { ctor, parameters: Substs::single(param) })\n-    }\n-    pub fn apply(ctor: TypeCtor, parameters: Substs) -> Ty {\n-        Ty::Apply(ApplicationTy { ctor, parameters })\n-    }\n-    pub fn unit() -> Self {\n-        Ty::apply(TypeCtor::Tuple { cardinality: 0 }, Substs::empty())\n-    }\n-\n-    pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(mutability), parameters }) => {\n-                Some((parameters.as_single(), *mutability))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_adt(&self) -> Option<(Adt, &Substs)> {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(adt_def), parameters }) => {\n-                Some((*adt_def, parameters))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_tuple(&self) -> Option<&Substs> {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple { .. }, parameters }) => {\n-                Some(parameters)\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_callable(&self) -> Option<(CallableDef, &Substs)> {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::FnDef(callable_def), parameters }) => {\n-                Some((*callable_def, parameters))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    fn builtin_deref(&self) -> Option<Ty> {\n-        match self {\n-            Ty::Apply(a_ty) => match a_ty.ctor {\n-                TypeCtor::Ref(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n-                TypeCtor::RawPtr(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    fn callable_sig(&self, db: &impl HirDatabase) -> Option<FnSig> {\n-        match self {\n-            Ty::Apply(a_ty) => match a_ty.ctor {\n-                TypeCtor::FnPtr { .. } => Some(FnSig::from_fn_ptr_substs(&a_ty.parameters)),\n-                TypeCtor::FnDef(def) => {\n-                    let sig = db.callable_item_signature(def);\n-                    Some(sig.subst(&a_ty.parameters))\n-                }\n-                TypeCtor::Closure { .. } => {\n-                    let sig_param = &a_ty.parameters[0];\n-                    sig_param.callable_sig(db)\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    /// If this is a type with type parameters (an ADT or function), replaces\n-    /// the `Substs` for these type parameters with the given ones. (So e.g. if\n-    /// `self` is `Option<_>` and the substs contain `u32`, we'll have\n-    /// `Option<u32>` afterwards.)\n-    pub fn apply_substs(self, substs: Substs) -> Ty {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor, parameters: previous_substs }) => {\n-                assert_eq!(previous_substs.len(), substs.len());\n-                Ty::Apply(ApplicationTy { ctor, parameters: substs })\n-            }\n-            _ => self,\n-        }\n-    }\n-\n-    /// Returns the type parameters of this type if it has some (i.e. is an ADT\n-    /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n-    pub fn substs(&self) -> Option<Substs> {\n-        match self {\n-            Ty::Apply(ApplicationTy { parameters, .. }) => Some(parameters.clone()),\n-            _ => None,\n-        }\n-    }\n-\n-    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n-    pub fn inherent_trait(&self) -> Option<Trait> {\n-        match self {\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                predicates.iter().find_map(|pred| match pred {\n-                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n-                    _ => None,\n-                })\n-            }\n-            _ => None,\n-        }\n-    }\n-}\n-\n-/// This allows walking structures that contain types to do something with those\n-/// types, similar to Chalk's `Fold` trait.\n-pub trait TypeWalk {\n-    fn walk(&self, f: &mut impl FnMut(&Ty));\n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.walk_mut_binders(&mut |ty, _binders| f(ty), 0);\n-    }\n-    /// Walk the type, counting entered binders.\n-    ///\n-    /// `Ty::Bound` variables use DeBruijn indexing, which means that 0 refers\n-    /// to the innermost binder, 1 to the next, etc.. So when we want to\n-    /// substitute a certain bound variable, we can't just walk the whole type\n-    /// and blindly replace each instance of a certain index; when we 'enter'\n-    /// things that introduce new bound variables, we have to keep track of\n-    /// that. Currently, the only thing that introduces bound variables on our\n-    /// side are `Ty::Dyn` and `Ty::Opaque`, which each introduce a bound\n-    /// variable for the self type.\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize);\n-\n-    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.walk_mut(&mut |ty_mut| {\n-            let ty = mem::replace(ty_mut, Ty::Unknown);\n-            *ty_mut = f(ty);\n-        });\n-        self\n-    }\n-\n-    /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n-    /// if `self` is `&[T]`, where type parameter T has index 0, and the\n-    /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)\n-    fn subst(self, substs: &Substs) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.fold(&mut |ty| match ty {\n-            Ty::Param { idx, name } => {\n-                substs.get(idx as usize).cloned().unwrap_or(Ty::Param { idx, name })\n-            }\n-            ty => ty,\n-        })\n-    }\n-\n-    /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n-    fn subst_bound_vars(mut self, substs: &Substs) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.walk_mut_binders(\n-            &mut |ty, binders| match ty {\n-                &mut Ty::Bound(idx) => {\n-                    if idx as usize >= binders && (idx as usize - binders) < substs.len() {\n-                        *ty = substs.0[idx as usize - binders].clone();\n-                    }\n-                }\n-                _ => {}\n-            },\n-            0,\n-        );\n-        self\n-    }\n-\n-    /// Shifts up `Ty::Bound` vars by `n`.\n-    fn shift_bound_vars(self, n: i32) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.fold(&mut |ty| match ty {\n-            Ty::Bound(idx) => {\n-                assert!(idx as i32 >= -n);\n-                Ty::Bound((idx as i32 + n) as u32)\n-            }\n-            ty => ty,\n-        })\n-    }\n-}\n-\n-impl TypeWalk for Ty {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self {\n-            Ty::Apply(a_ty) => {\n-                for t in a_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::Projection(p_ty) => {\n-                for t in p_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                for p in predicates.iter() {\n-                    p.walk(f);\n-                }\n-            }\n-            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n-        }\n-        f(self);\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        match self {\n-            Ty::Apply(a_ty) => {\n-                a_ty.parameters.walk_mut_binders(f, binders);\n-            }\n-            Ty::Projection(p_ty) => {\n-                p_ty.parameters.walk_mut_binders(f, binders);\n-            }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                for p in make_mut_slice(predicates) {\n-                    p.walk_mut_binders(f, binders + 1);\n-                }\n-            }\n-            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n-        }\n-        f(self, binders);\n-    }\n-}\n-\n-impl HirDisplay for &Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        HirDisplay::hir_fmt(*self, f)\n-    }\n-}\n-\n-impl HirDisplay for ApplicationTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"\u2026\");\n-        }\n-\n-        match self.ctor {\n-            TypeCtor::Bool => write!(f, \"bool\")?,\n-            TypeCtor::Char => write!(f, \"char\")?,\n-            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Str => write!(f, \"str\")?,\n-            TypeCtor::Slice => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"[{}]\", t.display(f.db))?;\n-            }\n-            TypeCtor::Array => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"[{};_]\", t.display(f.db))?;\n-            }\n-            TypeCtor::RawPtr(m) => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n-            }\n-            TypeCtor::Ref(m) => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"&{}{}\", m.as_keyword_for_ref(), t.display(f.db))?;\n-            }\n-            TypeCtor::Never => write!(f, \"!\")?,\n-            TypeCtor::Tuple { .. } => {\n-                let ts = &self.parameters;\n-                if ts.len() == 1 {\n-                    write!(f, \"({},)\", ts[0].display(f.db))?;\n-                } else {\n-                    write!(f, \"(\")?;\n-                    f.write_joined(&*ts.0, \", \")?;\n-                    write!(f, \")\")?;\n-                }\n-            }\n-            TypeCtor::FnPtr { .. } => {\n-                let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n-                write!(f, \"fn(\")?;\n-                f.write_joined(sig.params(), \", \")?;\n-                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n-            }\n-            TypeCtor::FnDef(def) => {\n-                let sig = f.db.callable_item_signature(def);\n-                let name = match def {\n-                    CallableDef::Function(ff) => ff.name(f.db),\n-                    CallableDef::Struct(s) => s.name(f.db).unwrap_or_else(Name::missing),\n-                    CallableDef::EnumVariant(e) => e.name(f.db).unwrap_or_else(Name::missing),\n-                };\n-                match def {\n-                    CallableDef::Function(_) => write!(f, \"fn {}\", name)?,\n-                    CallableDef::Struct(_) | CallableDef::EnumVariant(_) => write!(f, \"{}\", name)?,\n-                }\n-                if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n-                    write!(f, \">\")?;\n-                }\n-                write!(f, \"(\")?;\n-                f.write_joined(sig.params(), \", \")?;\n-                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n-            }\n-            TypeCtor::Adt(def_id) => {\n-                let name = match def_id {\n-                    Adt::Struct(s) => s.name(f.db),\n-                    Adt::Union(u) => u.name(f.db),\n-                    Adt::Enum(e) => e.name(f.db),\n-                }\n-                .unwrap_or_else(Name::missing);\n-                write!(f, \"{}\", name)?;\n-                if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n-                    write!(f, \">\")?;\n-                }\n-            }\n-            TypeCtor::AssociatedType(type_alias) => {\n-                let trait_name = type_alias\n-                    .parent_trait(f.db)\n-                    .and_then(|t| t.name(f.db))\n-                    .unwrap_or_else(Name::missing);\n-                let name = type_alias.name(f.db);\n-                write!(f, \"{}::{}\", trait_name, name)?;\n-                if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n-                    write!(f, \">\")?;\n-                }\n-            }\n-            TypeCtor::Closure { .. } => {\n-                let sig = self.parameters[0]\n-                    .callable_sig(f.db)\n-                    .expect(\"first closure parameter should contain signature\");\n-                write!(f, \"|\")?;\n-                f.write_joined(sig.params(), \", \")?;\n-                write!(f, \"| -> {}\", sig.ret().display(f.db))?;\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for ProjectionTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"\u2026\");\n-        }\n-\n-        let trait_name = self\n-            .associated_ty\n-            .parent_trait(f.db)\n-            .and_then(|t| t.name(f.db))\n-            .unwrap_or_else(Name::missing);\n-        write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_name,)?;\n-        if self.parameters.len() > 1 {\n-            write!(f, \"<\")?;\n-            f.write_joined(&self.parameters[1..], \", \")?;\n-            write!(f, \">\")?;\n-        }\n-        write!(f, \">::{}\", self.associated_ty.name(f.db))?;\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"\u2026\");\n-        }\n-\n-        match self {\n-            Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n-            Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n-            Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n-            Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                match self {\n-                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n-                    Ty::Opaque(_) => write!(f, \"impl \")?,\n-                    _ => unreachable!(),\n-                };\n-                // Note: This code is written to produce nice results (i.e.\n-                // corresponding to surface Rust) for types that can occur in\n-                // actual Rust. It will have weird results if the predicates\n-                // aren't as expected (i.e. self types = $0, projection\n-                // predicates for a certain trait come after the Implemented\n-                // predicate for that trait).\n-                let mut first = true;\n-                let mut angle_open = false;\n-                for p in predicates.iter() {\n-                    match p {\n-                        GenericPredicate::Implemented(trait_ref) => {\n-                            if angle_open {\n-                                write!(f, \">\")?;\n-                            }\n-                            if !first {\n-                                write!(f, \" + \")?;\n-                            }\n-                            // We assume that the self type is $0 (i.e. the\n-                            // existential) here, which is the only thing that's\n-                            // possible in actual Rust, and hence don't print it\n-                            write!(\n-                                f,\n-                                \"{}\",\n-                                trait_ref.trait_.name(f.db).unwrap_or_else(Name::missing)\n-                            )?;\n-                            if trait_ref.substs.len() > 1 {\n-                                write!(f, \"<\")?;\n-                                f.write_joined(&trait_ref.substs[1..], \", \")?;\n-                                // there might be assoc type bindings, so we leave the angle brackets open\n-                                angle_open = true;\n-                            }\n-                        }\n-                        GenericPredicate::Projection(projection_pred) => {\n-                            // in types in actual Rust, these will always come\n-                            // after the corresponding Implemented predicate\n-                            if angle_open {\n-                                write!(f, \", \")?;\n-                            } else {\n-                                write!(f, \"<\")?;\n-                                angle_open = true;\n-                            }\n-                            let name = projection_pred.projection_ty.associated_ty.name(f.db);\n-                            write!(f, \"{} = \", name)?;\n-                            projection_pred.ty.hir_fmt(f)?;\n-                        }\n-                        GenericPredicate::Error => {\n-                            if angle_open {\n-                                // impl Trait<X, {error}>\n-                                write!(f, \", \")?;\n-                            } else if !first {\n-                                // impl Trait + {error}\n-                                write!(f, \" + \")?;\n-                            }\n-                            p.hir_fmt(f)?;\n-                        }\n-                    }\n-                    first = false;\n-                }\n-                if angle_open {\n-                    write!(f, \">\")?;\n-                }\n-            }\n-            Ty::Unknown => write!(f, \"{{unknown}}\")?,\n-            Ty::Infer(..) => write!(f, \"_\")?,\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl TraitRef {\n-    fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"\u2026\");\n-        }\n-\n-        self.substs[0].hir_fmt(f)?;\n-        if use_as {\n-            write!(f, \" as \")?;\n-        } else {\n-            write!(f, \": \")?;\n-        }\n-        write!(f, \"{}\", self.trait_.name(f.db).unwrap_or_else(Name::missing))?;\n-        if self.substs.len() > 1 {\n-            write!(f, \"<\")?;\n-            f.write_joined(&self.substs[1..], \", \")?;\n-            write!(f, \">\")?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        self.hir_fmt_ext(f, false)\n-    }\n-}\n-\n-impl HirDisplay for &GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        HirDisplay::hir_fmt(*self, f)\n-    }\n-}\n-\n-impl HirDisplay for GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"\u2026\");\n-        }\n-\n-        match self {\n-            GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n-            GenericPredicate::Projection(projection_pred) => {\n-                write!(f, \"<\")?;\n-                projection_pred.projection_ty.trait_ref(f.db).hir_fmt_ext(f, true)?;\n-                write!(\n-                    f,\n-                    \">::{} = {}\",\n-                    projection_pred.projection_ty.associated_ty.name(f.db),\n-                    projection_pred.ty.display(f.db)\n-                )?;\n-            }\n-            GenericPredicate::Error => write!(f, \"{{error}}\")?,\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for Obligation {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        match self {\n-            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n-            Obligation::Projection(proj) => write!(\n-                f,\n-                \"Normalize({} => {})\",\n-                proj.projection_ty.display(f.db),\n-                proj.ty.display(f.db)\n-            ),\n-        }\n-    }\n-}\n+pub use hir_ty::*;"}, {"sha": "0095ee45d3c60fddf8a2db5f7892a4c219cc7e2e", "filename": "crates/ra_hir/src/util.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7394b44c870f585eacfeb3036a33471aff49ff8/crates%2Fra_hir%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7394b44c870f585eacfeb3036a33471aff49ff8/crates%2Fra_hir%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Futil.rs?ref=a7394b44c870f585eacfeb3036a33471aff49ff8", "patch": "@@ -1,12 +0,0 @@\n-//! Internal utility functions.\n-\n-use std::sync::Arc;\n-\n-/// Helper for mutating `Arc<[T]>` (i.e. `Arc::make_mut` for Arc slices).\n-/// The underlying values are cloned if there are other strong references.\n-pub(crate) fn make_mut_slice<T: Clone>(a: &mut Arc<[T]>) -> &mut [T] {\n-    if Arc::get_mut(a).is_none() {\n-        *a = a.iter().cloned().collect();\n-    }\n-    Arc::get_mut(a).unwrap()\n-}"}, {"sha": "3666529b0cbca54d2e03b56bb55a442cf670c05f", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -12,25 +12,25 @@ use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n     db::DefDatabase, trace::Trace, type_ref::TypeRef, AstItemDef, EnumId, HasChildSource,\n-    LocalEnumVariantId, LocalStructFieldId, StructOrUnionId, VariantId,\n+    LocalEnumVariantId, LocalStructFieldId, StructId, UnionId, VariantId,\n };\n \n /// Note that we use `StructData` for unions as well!\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StructData {\n-    pub name: Option<Name>,\n+    pub name: Name,\n     pub variant_data: Arc<VariantData>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n-    pub name: Option<Name>,\n+    pub name: Name,\n     pub variants: Arena<LocalEnumVariantId, EnumVariantData>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumVariantData {\n-    pub name: Option<Name>,\n+    pub name: Name,\n     pub variant_data: Arc<VariantData>,\n }\n \n@@ -49,26 +49,38 @@ pub struct StructFieldData {\n }\n \n impl StructData {\n-    pub(crate) fn struct_data_query(db: &impl DefDatabase, id: StructOrUnionId) -> Arc<StructData> {\n+    pub(crate) fn struct_data_query(db: &impl DefDatabase, id: StructId) -> Arc<StructData> {\n         let src = id.source(db);\n-        let name = src.value.name().map(|n| n.as_name());\n+        let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let variant_data = VariantData::new(src.value.kind());\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n     }\n+    pub(crate) fn union_data_query(db: &impl DefDatabase, id: UnionId) -> Arc<StructData> {\n+        let src = id.source(db);\n+        let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n+        let variant_data = VariantData::new(\n+            src.value\n+                .record_field_def_list()\n+                .map(ast::StructKind::Record)\n+                .unwrap_or(ast::StructKind::Unit),\n+        );\n+        let variant_data = Arc::new(variant_data);\n+        Arc::new(StructData { name, variant_data })\n+    }\n }\n \n impl EnumData {\n     pub(crate) fn enum_data_query(db: &impl DefDatabase, e: EnumId) -> Arc<EnumData> {\n         let src = e.source(db);\n-        let name = src.value.name().map(|n| n.as_name());\n+        let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let mut trace = Trace::new_for_arena();\n         lower_enum(&mut trace, &src.value);\n         Arc::new(EnumData { name, variants: trace.into_arena() })\n     }\n \n-    pub(crate) fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n-        let (id, _) = self.variants.iter().find(|(_id, data)| data.name.as_ref() == Some(name))?;\n+    pub fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n+        let (id, _) = self.variants.iter().find(|(_id, data)| &data.name == name)?;\n         Some(id)\n     }\n }\n@@ -92,7 +104,7 @@ fn lower_enum(\n         trace.alloc(\n             || var.clone(),\n             || EnumVariantData {\n-                name: var.name().map(|it| it.as_name()),\n+                name: var.name().map_or_else(Name::missing, |it| it.as_name()),\n                 variant_data: Arc::new(VariantData::new(var.kind())),\n             },\n         );\n@@ -117,6 +129,10 @@ impl VariantData {\n         }\n     }\n \n+    pub fn field(&self, name: &Name) -> Option<LocalStructFieldId> {\n+        self.fields().iter().find_map(|(id, data)| if &data.name == name { Some(id) } else { None })\n+    }\n+\n     pub fn is_unit(&self) -> bool {\n         match self {\n             VariantData::Unit => true,\n@@ -137,7 +153,12 @@ impl HasChildSource for VariantId {\n                 let src = it.parent.child_source(db);\n                 src.map(|map| map[it.local_id].kind())\n             }\n-            VariantId::StructId(it) => it.0.source(db).map(|it| it.kind()),\n+            VariantId::StructId(it) => it.source(db).map(|it| it.kind()),\n+            VariantId::UnionId(it) => it.source(db).map(|it| {\n+                it.record_field_def_list()\n+                    .map(ast::StructKind::Record)\n+                    .unwrap_or(ast::StructKind::Unit)\n+            }),\n         };\n         let mut trace = Trace::new_for_map();\n         lower_struct(&mut trace, &src.value);"}, {"sha": "fffb22201d6353b72172cd4ee659b5bdd0681a13", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -35,7 +35,7 @@ impl Attrs {\n         match def {\n             AttrDefId::ModuleId(module) => {\n                 let def_map = db.crate_def_map(module.krate);\n-                let src = match def_map[module.module_id].declaration_source(db) {\n+                let src = match def_map[module.local_id].declaration_source(db) {\n                     Some(it) => it,\n                     None => return Attrs::default(),\n                 };\n@@ -54,9 +54,9 @@ impl Attrs {\n                 Attrs::from_attrs_owner(db, src.map(|it| it as &dyn AttrsOwner))\n             }\n             AttrDefId::AdtId(it) => match it {\n-                AdtId::StructId(it) => attrs_from_ast(it.0.lookup_intern(db).ast_id, db),\n+                AdtId::StructId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n                 AdtId::EnumId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n-                AdtId::UnionId(it) => attrs_from_ast(it.0.lookup_intern(db).ast_id, db),\n+                AdtId::UnionId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n             },\n             AttrDefId::TraitId(it) => attrs_from_ast(it.lookup_intern(db).ast_id, db),\n             AttrDefId::MacroDefId(it) => attrs_from_ast(it.ast_id, db),"}, {"sha": "a57a0176d4764d1a2e988f2cd94325e477431fb9", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -6,8 +6,7 @@ pub mod scope;\n use std::{ops::Index, sync::Arc};\n \n use hir_expand::{\n-    either::Either, hygiene::Hygiene, AstId, HirFileId, MacroCallLoc, MacroDefId, MacroFileKind,\n-    Source,\n+    either::Either, hygiene::Hygiene, AstId, HirFileId, MacroDefId, MacroFileKind, Source,\n };\n use ra_arena::{map::ArenaMap, Arena};\n use ra_syntax::{ast, AstNode, AstPtr};\n@@ -47,7 +46,7 @@ impl Expander {\n \n         if let Some(path) = macro_call.path().and_then(|path| self.parse_path(path)) {\n             if let Some(def) = self.resolve_path_as_macro(db, &path) {\n-                let call_id = db.intern_macro(MacroCallLoc { def, ast_id });\n+                let call_id = def.as_call_id(db, ast_id);\n                 let file_id = call_id.as_file(MacroFileKind::Expr);\n                 if let Some(node) = db.parse_or_expand(file_id) {\n                     if let Some(expr) = ast::Expr::cast(node) {\n@@ -83,7 +82,7 @@ impl Expander {\n     }\n \n     fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &Path) -> Option<MacroDefId> {\n-        self.crate_def_map.resolve_path(db, self.module.module_id, path).0.take_macros()\n+        self.crate_def_map.resolve_path(db, self.module.local_id, path).0.take_macros()\n     }\n }\n "}, {"sha": "fee10b2375b784f1e770902f026baade40a39089", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -86,39 +86,53 @@ impl TypeAliasData {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct TraitData {\n-    pub name: Option<Name>,\n-    pub items: Vec<AssocItemId>,\n+    pub name: Name,\n+    pub items: Vec<(Name, AssocItemId)>,\n     pub auto: bool,\n }\n \n impl TraitData {\n     pub(crate) fn trait_data_query(db: &impl DefDatabase, tr: TraitId) -> Arc<TraitData> {\n         let src = tr.source(db);\n-        let name = src.value.name().map(|n| n.as_name());\n+        let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let auto = src.value.is_auto();\n         let ast_id_map = db.ast_id_map(src.file_id);\n+\n+        let container = ContainerId::TraitId(tr);\n         let items = if let Some(item_list) = src.value.item_list() {\n             item_list\n                 .impl_items()\n                 .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => FunctionLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    ast::ImplItem::FnDef(it) => {\n+                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n+                        let def = FunctionLoc {\n+                            container,\n+                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                        }\n+                        .intern(db)\n+                        .into();\n+                        (name, def)\n                     }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::ConstDef(it) => ConstLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    ast::ImplItem::ConstDef(it) => {\n+                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n+                        let def = ConstLoc {\n+                            container,\n+                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                        }\n+                        .intern(db)\n+                        .into();\n+                        (name, def)\n                     }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::TypeAliasDef(it) => TypeAliasLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    ast::ImplItem::TypeAliasDef(it) => {\n+                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n+                        let def = TypeAliasLoc {\n+                            container,\n+                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                        }\n+                        .intern(db)\n+                        .into();\n+                        (name, def)\n                     }\n-                    .intern(db)\n-                    .into(),\n                 })\n                 .collect()\n         } else {\n@@ -128,11 +142,18 @@ impl TraitData {\n     }\n \n     pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n-        self.items.iter().filter_map(|item| match item {\n+        self.items.iter().filter_map(|(_name, item)| match item {\n             AssocItemId::TypeAliasId(t) => Some(*t),\n             _ => None,\n         })\n     }\n+\n+    pub fn associated_type_by_name(&self, name: &Name) -> Option<TypeAliasId> {\n+        self.items.iter().find_map(|(item_name, item)| match item {\n+            AssocItemId::TypeAliasId(t) if item_name == name => Some(*t),\n+            _ => None,\n+        })\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -193,6 +214,7 @@ impl ImplData {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ConstData {\n+    /// const _: () = ();\n     pub name: Option<Name>,\n     pub type_ref: TypeRef,\n }"}, {"sha": "ef5611ffc0da75b467e079ac5e58cbe31a95d941", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -18,16 +18,18 @@ use crate::{\n         CrateDefMap,\n     },\n     AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, FunctionId, FunctionLoc, GenericDefId,\n-    ImplId, ItemLoc, ModuleId, StaticId, StaticLoc, StructOrUnionId, TraitId, TypeAliasId,\n-    TypeAliasLoc,\n+    ImplId, ItemLoc, ModuleId, StaticId, StaticLoc, StructId, TraitId, TypeAliasId, TypeAliasLoc,\n+    UnionId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n     fn intern_function(&self, loc: FunctionLoc) -> FunctionId;\n     #[salsa::interned]\n-    fn intern_struct_or_union(&self, loc: ItemLoc<ast::StructDef>) -> StructOrUnionId;\n+    fn intern_struct(&self, loc: ItemLoc<ast::StructDef>) -> StructId;\n+    #[salsa::interned]\n+    fn intern_union(&self, loc: ItemLoc<ast::UnionDef>) -> UnionId;\n     #[salsa::interned]\n     fn intern_enum(&self, loc: ItemLoc<ast::EnumDef>) -> EnumId;\n     #[salsa::interned]\n@@ -57,7 +59,9 @@ pub trait DefDatabase: InternDatabase + AstDatabase {\n     fn crate_def_map(&self, krate: CrateId) -> Arc<CrateDefMap>;\n \n     #[salsa::invoke(StructData::struct_data_query)]\n-    fn struct_data(&self, id: StructOrUnionId) -> Arc<StructData>;\n+    fn struct_data(&self, id: StructId) -> Arc<StructData>;\n+    #[salsa::invoke(StructData::union_data_query)]\n+    fn union_data(&self, id: UnionId) -> Arc<StructData>;\n \n     #[salsa::invoke(EnumData::enum_data_query)]\n     fn enum_data(&self, e: EnumId) -> Arc<EnumData>;"}, {"sha": "34ed9b7a5eeecca7c7114b375d163c7fac35c604", "filename": "crates/ra_hir_def/src/docs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -36,7 +36,7 @@ impl Documentation {\n         match def {\n             AttrDefId::ModuleId(module) => {\n                 let def_map = db.crate_def_map(module.krate);\n-                let src = def_map[module.module_id].declaration_source(db)?;\n+                let src = def_map[module.local_id].declaration_source(db)?;\n                 docs_from_ast(&src.value)\n             }\n             AttrDefId::StructFieldId(it) => {\n@@ -47,9 +47,9 @@ impl Documentation {\n                 }\n             }\n             AttrDefId::AdtId(it) => match it {\n-                AdtId::StructId(it) => docs_from_ast(&it.0.source(db).value),\n+                AdtId::StructId(it) => docs_from_ast(&it.source(db).value),\n                 AdtId::EnumId(it) => docs_from_ast(&it.source(db).value),\n-                AdtId::UnionId(it) => docs_from_ast(&it.0.source(db).value),\n+                AdtId::UnionId(it) => docs_from_ast(&it.source(db).value),\n             },\n             AttrDefId::EnumVariantId(it) => {\n                 let src = it.parent.child_source(db);"}, {"sha": "3f94e40e4f4bedc2dd0e76084ffc4eaba9e3e812", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -60,10 +60,8 @@ impl GenericParams {\n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n         match def {\n             GenericDefId::FunctionId(it) => generics.fill(&it.lookup(db).source(db).value, start),\n-            GenericDefId::AdtId(AdtId::StructId(it)) => {\n-                generics.fill(&it.0.source(db).value, start)\n-            }\n-            GenericDefId::AdtId(AdtId::UnionId(it)) => generics.fill(&it.0.source(db).value, start),\n+            GenericDefId::AdtId(AdtId::StructId(it)) => generics.fill(&it.source(db).value, start),\n+            GenericDefId::AdtId(AdtId::UnionId(it)) => generics.fill(&it.source(db).value, start),\n             GenericDefId::AdtId(AdtId::EnumId(it)) => generics.fill(&it.source(db).value, start),\n             GenericDefId::TraitId(it) => {\n                 // traits get the Self type as an implicit first type parameter"}, {"sha": "f4fdbdcfc7482c6b5de614300b73dad201160d4d", "filename": "crates/ra_hir_def/src/lang_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -41,7 +41,7 @@ impl LangItems {\n         crate_def_map\n             .modules\n             .iter()\n-            .filter_map(|(module_id, _)| db.module_lang_items(ModuleId { krate, module_id }))\n+            .filter_map(|(local_id, _)| db.module_lang_items(ModuleId { krate, local_id }))\n             .for_each(|it| lang_items.items.extend(it.items.iter().map(|(k, v)| (k.clone(), *v))));\n \n         Arc::new(lang_items)\n@@ -80,7 +80,7 @@ impl LangItems {\n     fn collect_lang_items(&mut self, db: &impl DefDatabase, module: ModuleId) {\n         // Look for impl targets\n         let def_map = db.crate_def_map(module.krate);\n-        let module_data = &def_map[module.module_id];\n+        let module_data = &def_map[module.local_id];\n         for &impl_block in module_data.impls.iter() {\n             self.collect_lang_item(db, impl_block, LangItemTarget::ImplBlockId)\n         }"}, {"sha": "bc553089694a5f191a8050bcd84ecab0dee5417f", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -27,7 +27,7 @@ pub mod body;\n pub mod resolver;\n \n mod trace;\n-mod nameres;\n+pub mod nameres;\n \n #[cfg(test)]\n mod test_db;\n@@ -50,7 +50,7 @@ impl_arena_id!(LocalImportId);\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {\n     pub krate: CrateId,\n-    pub module_id: LocalModuleId,\n+    pub local_id: LocalModuleId,\n }\n \n /// An ID of a module, **local** to a specific crate\n@@ -141,30 +141,26 @@ impl Lookup for FunctionId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StructOrUnionId(salsa::InternId);\n-impl_intern_key!(StructOrUnionId);\n-impl AstItemDef<ast::StructDef> for StructOrUnionId {\n+pub struct StructId(salsa::InternId);\n+impl_intern_key!(StructId);\n+impl AstItemDef<ast::StructDef> for StructId {\n     fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StructDef>) -> Self {\n-        db.intern_struct_or_union(loc)\n+        db.intern_struct(loc)\n     }\n     fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StructDef> {\n-        db.lookup_intern_struct_or_union(self)\n+        db.lookup_intern_struct(self)\n     }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StructId(pub StructOrUnionId);\n-impl From<StructId> for StructOrUnionId {\n-    fn from(id: StructId) -> StructOrUnionId {\n-        id.0\n+pub struct UnionId(salsa::InternId);\n+impl_intern_key!(UnionId);\n+impl AstItemDef<ast::UnionDef> for UnionId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::UnionDef>) -> Self {\n+        db.intern_union(loc)\n     }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct UnionId(pub StructOrUnionId);\n-impl From<UnionId> for StructOrUnionId {\n-    fn from(id: UnionId) -> StructOrUnionId {\n-        id.0\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::UnionDef> {\n+        db.lookup_intern_union(self)\n     }\n }\n \n@@ -402,6 +398,16 @@ impl_froms!(\n     ConstId\n );\n \n+impl From<AssocItemId> for GenericDefId {\n+    fn from(item: AssocItemId) -> Self {\n+        match item {\n+            AssocItemId::FunctionId(f) => f.into(),\n+            AssocItemId::ConstId(c) => c.into(),\n+            AssocItemId::TypeAliasId(t) => t.into(),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum AttrDefId {\n     ModuleId(ModuleId),\n@@ -435,6 +441,7 @@ impl_froms!(\n pub enum VariantId {\n     EnumVariantId(EnumVariantId),\n     StructId(StructId),\n+    UnionId(UnionId),\n }\n impl_froms!(VariantId: EnumVariantId, StructId);\n \n@@ -485,13 +492,23 @@ impl HasModule for ConstLoc {\n impl HasModule for AdtId {\n     fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n         match self {\n-            AdtId::StructId(it) => it.0.module(db),\n-            AdtId::UnionId(it) => it.0.module(db),\n+            AdtId::StructId(it) => it.module(db),\n+            AdtId::UnionId(it) => it.module(db),\n             AdtId::EnumId(it) => it.module(db),\n         }\n     }\n }\n \n+impl HasModule for DefWithBodyId {\n+    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+        match self {\n+            DefWithBodyId::FunctionId(it) => it.lookup(db).module(db),\n+            DefWithBodyId::StaticId(it) => it.lookup(db).module(db),\n+            DefWithBodyId::ConstId(it) => it.lookup(db).module(db),\n+        }\n+    }\n+}\n+\n impl HasModule for StaticLoc {\n     fn module(&self, _db: &impl db::DefDatabase) -> ModuleId {\n         self.container"}, {"sha": "fd82451131b7ae3c69fa310377507fb673ba94fc", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -6,7 +6,7 @@\n use hir_expand::{\n     builtin_macro::find_builtin_macro,\n     name::{self, AsName, Name},\n-    HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind, MacroFileKind,\n+    HirFileId, MacroCallId, MacroDefId, MacroDefKind, MacroFileKind,\n };\n use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId};\n@@ -25,7 +25,7 @@ use crate::{\n     per_ns::PerNs,\n     AdtId, AstId, AstItemDef, ConstLoc, ContainerId, EnumId, EnumVariantId, FunctionLoc, ImplId,\n     Intern, LocalImportId, LocalModuleId, LocationCtx, ModuleDefId, ModuleId, StaticLoc, StructId,\n-    StructOrUnionId, TraitId, TypeAliasLoc, UnionId,\n+    TraitId, TypeAliasLoc, UnionId,\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -37,7 +37,7 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         log::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.crate_id);\n         def_map.extern_prelude.insert(\n             dep.as_name(),\n-            ModuleId { krate: dep.crate_id, module_id: dep_def_map.root }.into(),\n+            ModuleId { krate: dep.crate_id, local_id: dep_def_map.root }.into(),\n         );\n \n         // look for the prelude\n@@ -323,7 +323,7 @@ where\n                         tested_by!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n                         let item_map = self.db.crate_def_map(m.krate);\n-                        let scope = &item_map[m.module_id].scope;\n+                        let scope = &item_map[m.local_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -337,7 +337,7 @@ where\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n                         // additions\n-                        let scope = &self.def_map[m.module_id].scope;\n+                        let scope = &self.def_map[m.local_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -349,7 +349,7 @@ where\n                         self.update(module_id, Some(import_id), &items);\n                         // record the glob import in case we add further items\n                         self.glob_imports\n-                            .entry(m.module_id)\n+                            .entry(m.local_id)\n                             .or_default()\n                             .push((module_id, import_id));\n                     }\n@@ -362,7 +362,7 @@ where\n                         .variants\n                         .iter()\n                         .filter_map(|(local_id, variant_data)| {\n-                            let name = variant_data.name.clone()?;\n+                            let name = variant_data.name.clone();\n                             let variant = EnumVariantId { parent: e, local_id };\n                             let res = Resolution {\n                                 def: PerNs::both(variant.into(), variant.into()),\n@@ -480,7 +480,7 @@ where\n             );\n \n             if let Some(def) = resolved_res.resolved_def.take_macros() {\n-                let call_id = self.db.intern_macro(MacroCallLoc { def, ast_id: *ast_id });\n+                let call_id = def.as_call_id(self.db, *ast_id);\n                 resolved.push((*module_id, call_id, def));\n                 res = ReachedFixedPoint::No;\n                 return false;\n@@ -590,7 +590,7 @@ where\n                     raw::RawItemKind::Impl(imp) => {\n                         let module = ModuleId {\n                             krate: self.def_collector.def_map.krate,\n-                            module_id: self.module_id,\n+                            local_id: self.module_id,\n                         };\n                         let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n                         let imp_id = ImplId::from_ast_id(ctx, self.raw_items[imp].ast_id);\n@@ -673,7 +673,7 @@ where\n         modules[self.module_id].children.insert(name.clone(), res);\n         let resolution = Resolution {\n             def: PerNs::types(\n-                ModuleId { krate: self.def_collector.def_map.krate, module_id: res }.into(),\n+                ModuleId { krate: self.def_collector.def_map.krate, local_id: res }.into(),\n             ),\n             import: None,\n         };\n@@ -682,8 +682,7 @@ where\n     }\n \n     fn define_def(&mut self, def: &raw::DefData) {\n-        let module =\n-            ModuleId { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n+        let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n         let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n \n         let name = def.name.clone();\n@@ -698,14 +697,12 @@ where\n                 PerNs::values(def.into())\n             }\n             raw::DefKind::Struct(ast_id) => {\n-                let id = StructOrUnionId::from_ast_id(ctx, ast_id).into();\n-                let s = StructId(id).into();\n-                PerNs::both(s, s)\n+                let id = StructId::from_ast_id(ctx, ast_id).into();\n+                PerNs::both(id, id)\n             }\n             raw::DefKind::Union(ast_id) => {\n-                let id = StructOrUnionId::from_ast_id(ctx, ast_id).into();\n-                let u = UnionId(id).into();\n-                PerNs::both(u, u)\n+                let id = UnionId::from_ast_id(ctx, ast_id).into();\n+                PerNs::both(id, id)\n             }\n             raw::DefKind::Enum(ast_id) => PerNs::types(EnumId::from_ast_id(ctx, ast_id).into()),\n             raw::DefKind::Const(ast_id) => {\n@@ -775,8 +772,7 @@ where\n         if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n             self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n         }) {\n-            let macro_call_id =\n-                self.def_collector.db.intern_macro(MacroCallLoc { def: macro_def, ast_id });\n+            let macro_call_id = macro_def.as_call_id(self.def_collector.db, ast_id);\n \n             self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_def);\n             return;"}, {"sha": "b72c55bd10e8aa3f76b93b1d26c2310679998cdc", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -74,19 +74,19 @@ impl CrateDefMap {\n             PathKind::DollarCrate(krate) => {\n                 if krate == self.krate {\n                     tested_by!(macro_dollar_crate_self);\n-                    PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n+                    PerNs::types(ModuleId { krate: self.krate, local_id: self.root }.into())\n                 } else {\n                     let def_map = db.crate_def_map(krate);\n-                    let module = ModuleId { krate, module_id: def_map.root };\n+                    let module = ModuleId { krate, local_id: def_map.root };\n                     tested_by!(macro_dollar_crate_other);\n                     PerNs::types(module.into())\n                 }\n             }\n             PathKind::Crate => {\n-                PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n+                PerNs::types(ModuleId { krate: self.krate, local_id: self.root }.into())\n             }\n             PathKind::Self_ => {\n-                PerNs::types(ModuleId { krate: self.krate, module_id: original_module }.into())\n+                PerNs::types(ModuleId { krate: self.krate, local_id: original_module }.into())\n             }\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n@@ -113,7 +113,7 @@ impl CrateDefMap {\n             }\n             PathKind::Super => {\n                 if let Some(p) = self.modules[original_module].parent {\n-                    PerNs::types(ModuleId { krate: self.krate, module_id: p }.into())\n+                    PerNs::types(ModuleId { krate: self.krate, local_id: p }.into())\n                 } else {\n                     log::debug!(\"super path in root module\");\n                     return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n@@ -160,7 +160,7 @@ impl CrateDefMap {\n                             Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n                         let defp_map = db.crate_def_map(module.krate);\n-                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n+                        let (def, s) = defp_map.resolve_path(db, module.local_id, &path);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n@@ -169,7 +169,7 @@ impl CrateDefMap {\n                     }\n \n                     // Since it is a qualified path here, it should not contains legacy macros\n-                    match self[module.module_id].scope.get(&segment.name) {\n+                    match self[module.local_id].scope.get(&segment.name) {\n                         Some(res) => res.def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n@@ -254,7 +254,7 @@ impl CrateDefMap {\n                 keep = db.crate_def_map(prelude.krate);\n                 &keep\n             };\n-            def_map[prelude.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n+            def_map[prelude.local_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n         } else {\n             PerNs::none()\n         }"}, {"sha": "6eb106094cf4ed239d5be7bdb6088a6d4a8fc0e7", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -176,7 +176,7 @@ pub(super) struct DefData {\n pub(super) enum DefKind {\n     Function(FileAstId<ast::FnDef>),\n     Struct(FileAstId<ast::StructDef>),\n-    Union(FileAstId<ast::StructDef>),\n+    Union(FileAstId<ast::UnionDef>),\n     Enum(FileAstId<ast::EnumDef>),\n     Const(FileAstId<ast::ConstDef>),\n     Static(FileAstId<ast::StaticDef>),\n@@ -246,11 +246,12 @@ impl RawItemsCollector {\n             ast::ModuleItem::StructDef(it) => {\n                 let id = self.source_ast_id_map.ast_id(&it);\n                 let name = it.name();\n-                if it.is_union() {\n-                    (DefKind::Union(id), name)\n-                } else {\n-                    (DefKind::Struct(id), name)\n-                }\n+                (DefKind::Struct(id), name)\n+            }\n+            ast::ModuleItem::UnionDef(it) => {\n+                let id = self.source_ast_id_map.ast_id(&it);\n+                let name = it.name();\n+                (DefKind::Union(id), name)\n             }\n             ast::ModuleItem::EnumDef(it) => {\n                 (DefKind::Enum(self.source_ast_id_map.ast_id(&it)), it.name())"}, {"sha": "87fcd617c523a9daa9d00bd40419bfefc0dee384", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -82,6 +82,12 @@ fn crate_def_map_smoke_test() {\n \n         //- /foo/bar.rs\n         pub struct Baz;\n+\n+        union U {\n+            to_be: bool,\n+            not_to_be: u8,\n+        }\n+\n         enum E { V }\n         \",\n     );\n@@ -99,6 +105,7 @@ fn crate_def_map_smoke_test() {\n         \u22eecrate::foo::bar\n         \u22eeBaz: t v\n         \u22eeE: t\n+        \u22eeU: t v\n     \"###)\n }\n "}, {"sha": "6810a26dbbd1336b0968667d198ca6b470fb6659", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -97,7 +97,7 @@ impl Path {\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// It correctly handles `$crate` based path from macro call.\n-    pub(crate) fn from_src(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n+    pub fn from_src(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {"}, {"sha": "0847f6dcf45d0b81e62415856ec091ae84c19723", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -61,6 +61,8 @@ pub enum TypeNs {\n     GenericParam(u32),\n     AdtId(AdtId),\n     AdtSelfType(AdtId),\n+    // Yup, enum variants are added to the types ns, but any usage of variant as\n+    // type is an error.\n     EnumVariantId(EnumVariantId),\n     TypeAliasId(TypeAliasId),\n     BuiltinType(BuiltinType),\n@@ -323,7 +325,7 @@ impl Resolver {\n             if let Scope::ModuleScope(m) = scope {\n                 if let Some(prelude) = m.crate_def_map.prelude {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    traits.extend(prelude_def_map[prelude.module_id].scope.traits());\n+                    traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n                 }\n                 traits.extend(m.crate_def_map[m.module_id].scope.traits());\n             }\n@@ -400,7 +402,7 @@ impl Scope {\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    prelude_def_map[prelude.module_id].scope.entries().for_each(|(name, res)| {\n+                    prelude_def_map[prelude.local_id].scope.entries().for_each(|(name, res)| {\n                         f(name.clone(), ScopeDef::PerNs(res.def));\n                     });\n                 }\n@@ -482,15 +484,15 @@ impl Resolver {\n     }\n }\n \n-pub trait HasResolver {\n+pub trait HasResolver: Copy {\n     /// Builds a resolver for type references inside this def.\n     fn resolver(self, db: &impl DefDatabase) -> Resolver;\n }\n \n impl HasResolver for ModuleId {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         let def_map = db.crate_def_map(self.krate);\n-        Resolver::default().push_module_scope(def_map, self.module_id)\n+        Resolver::default().push_module_scope(def_map, self.local_id)\n     }\n }\n \n@@ -500,7 +502,7 @@ impl HasResolver for TraitId {\n     }\n }\n \n-impl<T: Into<AdtId>> HasResolver for T {\n+impl<T: Into<AdtId> + Copy> HasResolver for T {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         let def = self.into();\n         def.module(db)"}, {"sha": "54e3a84bdfbb87f8ab7f137653a0d906995b858d", "filename": "crates/ra_hir_def/src/test_db.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -24,7 +24,9 @@ impl salsa::Database for TestDB {\n     fn salsa_runtime(&self) -> &salsa::Runtime<Self> {\n         &self.runtime\n     }\n-\n+    fn salsa_runtime_mut(&mut self) -> &mut salsa::Runtime<Self> {\n+        &mut self.runtime\n+    }\n     fn salsa_event(&self, event: impl Fn() -> salsa::Event<TestDB>) {\n         let mut events = self.events.lock().unwrap();\n         if let Some(events) = &mut *events {"}, {"sha": "b6a739cda53bdb258104d8fcaff909780a14ea28", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -135,6 +135,16 @@ pub struct MacroDefId {\n     pub kind: MacroDefKind,\n }\n \n+impl MacroDefId {\n+    pub fn as_call_id(\n+        self,\n+        db: &dyn db::AstDatabase,\n+        ast_id: AstId<ast::MacroCall>,\n+    ) -> MacroCallId {\n+        db.intern_macro(MacroCallLoc { def: self, ast_id })\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum MacroDefKind {\n     Declarative,\n@@ -143,8 +153,8 @@ pub enum MacroDefKind {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n-    pub def: MacroDefId,\n-    pub ast_id: AstId<ast::MacroCall>,\n+    pub(crate) def: MacroDefId,\n+    pub(crate) ast_id: AstId<ast::MacroCall>,\n }\n \n impl MacroCallId {"}, {"sha": "918736e2a155a0415debe67a9309a65d4bc3dc7d", "filename": "crates/ra_hir_expand/src/test_db.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -23,6 +23,10 @@ impl salsa::Database for TestDB {\n         &self.runtime\n     }\n \n+    fn salsa_runtime_mut(&mut self) -> &mut salsa::Runtime<Self> {\n+        &mut self.runtime\n+    }\n+\n     fn salsa_event(&self, event: impl Fn() -> salsa::Event<TestDB>) {\n         let mut events = self.events.lock().unwrap();\n         if let Some(events) = &mut *events {"}, {"sha": "429242870f9eff45ff261f4ad5d62a8dd553803f", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -0,0 +1,32 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_hir_ty\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+arrayvec = \"0.5.1\"\n+ena = \"0.13\"\n+log = \"0.4.5\"\n+rustc-hash = \"1.0\"\n+\n+hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n+hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n+ra_arena = { path = \"../ra_arena\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_prof = { path = \"../ra_prof\" }\n+ra_syntax = { path = \"../ra_syntax\" }\n+test_utils = { path = \"../test_utils\" }\n+\n+# https://github.com/rust-lang/chalk/pull/294\n+chalk-solve =   { git = \"https://github.com/jackh726/chalk.git\", rev = \"095cd38a4f16337913bba487f2055b9ca0179f30\" }\n+chalk-rust-ir = { git = \"https://github.com/jackh726/chalk.git\", rev = \"095cd38a4f16337913bba487f2055b9ca0179f30\" }\n+chalk-ir =      { git = \"https://github.com/jackh726/chalk.git\", rev = \"095cd38a4f16337913bba487f2055b9ca0179f30\" }\n+\n+lalrpop-intern = \"0.15.1\"\n+\n+[dev-dependencies]\n+insta = \"0.12.0\""}, {"sha": "9d1d4e48c6e69edbf848e88134327d8003f6bf3c", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "renamed", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -5,49 +5,56 @@\n \n use std::iter::successors;\n \n-use hir_def::{lang_item::LangItemTarget, resolver::Resolver};\n+use hir_def::lang_item::LangItemTarget;\n use hir_expand::name;\n use log::{info, warn};\n+use ra_db::CrateId;\n \n-use crate::{db::HirDatabase, Trait};\n+use crate::db::HirDatabase;\n \n-use super::{traits::Solution, Canonical, Substs, Ty, TypeWalk};\n+use super::{\n+    traits::{InEnvironment, Solution},\n+    Canonical, Substs, Ty, TypeWalk,\n+};\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n \n-pub(crate) fn autoderef<'a>(\n+pub fn autoderef<'a>(\n     db: &'a impl HirDatabase,\n-    resolver: &'a Resolver,\n-    ty: Canonical<Ty>,\n+    krate: Option<CrateId>,\n+    ty: InEnvironment<Canonical<Ty>>,\n ) -> impl Iterator<Item = Canonical<Ty>> + 'a {\n-    successors(Some(ty), move |ty| deref(db, resolver, ty)).take(AUTODEREF_RECURSION_LIMIT)\n+    let InEnvironment { value: ty, environment } = ty;\n+    successors(Some(ty), move |ty| {\n+        deref(db, krate?, InEnvironment { value: ty, environment: environment.clone() })\n+    })\n+    .take(AUTODEREF_RECURSION_LIMIT)\n }\n \n pub(crate) fn deref(\n     db: &impl HirDatabase,\n-    resolver: &Resolver,\n-    ty: &Canonical<Ty>,\n+    krate: CrateId,\n+    ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n-    if let Some(derefed) = ty.value.builtin_deref() {\n-        Some(Canonical { value: derefed, num_vars: ty.num_vars })\n+    if let Some(derefed) = ty.value.value.builtin_deref() {\n+        Some(Canonical { value: derefed, num_vars: ty.value.num_vars })\n     } else {\n-        deref_by_trait(db, resolver, ty)\n+        deref_by_trait(db, krate, ty)\n     }\n }\n \n fn deref_by_trait(\n     db: &impl HirDatabase,\n-    resolver: &Resolver,\n-    ty: &Canonical<Ty>,\n+    krate: CrateId,\n+    ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n-    let krate = resolver.krate()?;\n     let deref_trait = match db.lang_item(krate.into(), \"deref\".into())? {\n-        LangItemTarget::TraitId(t) => Trait::from(t),\n+        LangItemTarget::TraitId(it) => it,\n         _ => return None,\n     };\n-    let target = deref_trait.associated_type_by_name(db, &name::TARGET_TYPE)?;\n+    let target = db.trait_data(deref_trait).associated_type_by_name(&name::TARGET_TYPE)?;\n \n-    let generic_params = db.generic_params(target.id.into());\n+    let generic_params = db.generic_params(target.into());\n     if generic_params.count_params_including_parent() != 1 {\n         // the Target type + Deref trait should only have one generic parameter,\n         // namely Deref's Self type\n@@ -56,10 +63,8 @@ fn deref_by_trait(\n \n     // FIXME make the Canonical handling nicer\n \n-    let env = super::lower::trait_env(db, resolver);\n-\n     let parameters = Substs::build_for_generics(&generic_params)\n-        .push(ty.value.clone().shift_bound_vars(1))\n+        .push(ty.value.value.clone().shift_bound_vars(1))\n         .build();\n \n     let projection = super::traits::ProjectionPredicate {\n@@ -69,9 +74,9 @@ fn deref_by_trait(\n \n     let obligation = super::Obligation::Projection(projection);\n \n-    let in_env = super::traits::InEnvironment { value: obligation, environment: env };\n+    let in_env = InEnvironment { value: obligation, environment: ty.environment };\n \n-    let canonical = super::Canonical { num_vars: 1 + ty.num_vars, value: in_env };\n+    let canonical = super::Canonical { num_vars: 1 + ty.value.num_vars, value: in_env };\n \n     let solution = db.trait_solve(krate.into(), canonical)?;\n \n@@ -89,14 +94,14 @@ fn deref_by_trait(\n             // the case.\n             for i in 1..vars.0.num_vars {\n                 if vars.0.value[i] != Ty::Bound((i - 1) as u32) {\n-                    warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty, solution);\n+                    warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.value, solution);\n                     return None;\n                 }\n             }\n             Some(Canonical { value: vars.0.value[0].clone(), num_vars: vars.0.num_vars })\n         }\n         Solution::Ambig(_) => {\n-            info!(\"Ambiguous solution for derefing {:?}: {:?}\", ty, solution);\n+            info!(\"Ambiguous solution for derefing {:?}: {:?}\", ty.value, solution);\n             None\n         }\n     }", "previous_filename": "crates/ra_hir/src/ty/autoderef.rs"}, {"sha": "9ce154593980737874d4248022690e07a4b79757", "filename": "crates/ra_hir_ty/src/db.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -0,0 +1,119 @@\n+//! FIXME: write short doc here\n+\n+use std::sync::Arc;\n+\n+use hir_def::{\n+    db::DefDatabase, DefWithBodyId, GenericDefId, ImplId, LocalStructFieldId, TraitId, VariantId,\n+};\n+use ra_arena::map::ArenaMap;\n+use ra_db::{salsa, CrateId};\n+\n+use crate::{\n+    method_resolution::CrateImplBlocks,\n+    traits::{AssocTyValue, Impl},\n+    CallableDef, FnSig, GenericPredicate, ImplTy, InferenceResult, Substs, Ty, TyDefId, TypeCtor,\n+    ValueTyDefId,\n+};\n+\n+#[salsa::query_group(HirDatabaseStorage)]\n+#[salsa::requires(salsa::Database)]\n+pub trait HirDatabase: DefDatabase {\n+    #[salsa::invoke(crate::infer_query)]\n+    fn infer(&self, def: DefWithBodyId) -> Arc<InferenceResult>;\n+\n+    #[salsa::invoke(crate::lower::ty_query)]\n+    fn ty(&self, def: TyDefId) -> Ty;\n+\n+    #[salsa::invoke(crate::lower::value_ty_query)]\n+    fn value_ty(&self, def: ValueTyDefId) -> Ty;\n+\n+    #[salsa::invoke(crate::lower::impl_ty_query)]\n+    fn impl_ty(&self, def: ImplId) -> ImplTy;\n+\n+    #[salsa::invoke(crate::lower::field_types_query)]\n+    fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Ty>>;\n+\n+    #[salsa::invoke(crate::callable_item_sig)]\n+    fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n+\n+    #[salsa::invoke(crate::lower::generic_predicates_for_param_query)]\n+    fn generic_predicates_for_param(\n+        &self,\n+        def: GenericDefId,\n+        param_idx: u32,\n+    ) -> Arc<[GenericPredicate]>;\n+\n+    #[salsa::invoke(crate::lower::generic_predicates_query)]\n+    fn generic_predicates(&self, def: GenericDefId) -> Arc<[GenericPredicate]>;\n+\n+    #[salsa::invoke(crate::lower::generic_defaults_query)]\n+    fn generic_defaults(&self, def: GenericDefId) -> Substs;\n+\n+    #[salsa::invoke(crate::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n+    fn impls_in_crate(&self, krate: CrateId) -> Arc<CrateImplBlocks>;\n+\n+    #[salsa::invoke(crate::traits::impls_for_trait_query)]\n+    fn impls_for_trait(&self, krate: CrateId, trait_: TraitId) -> Arc<[ImplId]>;\n+\n+    /// This provides the Chalk trait solver instance. Because Chalk always\n+    /// works from a specific crate, this query is keyed on the crate; and\n+    /// because Chalk does its own internal caching, the solver is wrapped in a\n+    /// Mutex and the query does an untracked read internally, to make sure the\n+    /// cached state is thrown away when input facts change.\n+    #[salsa::invoke(crate::traits::trait_solver_query)]\n+    fn trait_solver(&self, krate: CrateId) -> crate::traits::TraitSolver;\n+\n+    // Interned IDs for Chalk integration\n+    #[salsa::interned]\n+    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> crate::TypeCtorId;\n+    #[salsa::interned]\n+    fn intern_chalk_impl(&self, impl_: Impl) -> crate::traits::GlobalImplId;\n+    #[salsa::interned]\n+    fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> crate::traits::AssocTyValueId;\n+\n+    #[salsa::invoke(crate::traits::chalk::associated_ty_data_query)]\n+    fn associated_ty_data(\n+        &self,\n+        id: chalk_ir::TypeId,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyDatum<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::traits::chalk::trait_datum_query)]\n+    fn trait_datum(\n+        &self,\n+        krate: CrateId,\n+        trait_id: chalk_ir::TraitId,\n+    ) -> Arc<chalk_rust_ir::TraitDatum<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::traits::chalk::struct_datum_query)]\n+    fn struct_datum(\n+        &self,\n+        krate: CrateId,\n+        struct_id: chalk_ir::StructId,\n+    ) -> Arc<chalk_rust_ir::StructDatum<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::traits::chalk::impl_datum_query)]\n+    fn impl_datum(\n+        &self,\n+        krate: CrateId,\n+        impl_id: chalk_ir::ImplId,\n+    ) -> Arc<chalk_rust_ir::ImplDatum<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::traits::chalk::associated_ty_value_query)]\n+    fn associated_ty_value(\n+        &self,\n+        krate: CrateId,\n+        id: chalk_rust_ir::AssociatedTyValueId,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyValue<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::traits::trait_solve_query)]\n+    fn trait_solve(\n+        &self,\n+        krate: CrateId,\n+        goal: crate::Canonical<crate::InEnvironment<crate::Obligation>>,\n+    ) -> Option<crate::traits::Solution>;\n+}\n+\n+#[test]\n+fn hir_database_is_object_safe() {\n+    fn _assert_object_safe(_: &dyn HirDatabase) {}\n+}"}, {"sha": "4a13fac239a98c20ea497cade350b2d029f03aa4", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -0,0 +1,91 @@\n+//! FIXME: write short doc here\n+\n+use std::any::Any;\n+\n+use hir_expand::{db::AstDatabase, name::Name, HirFileId, Source};\n+use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n+\n+pub use hir_def::diagnostics::UnresolvedModule;\n+pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n+\n+#[derive(Debug)]\n+pub struct NoSuchField {\n+    pub file: HirFileId,\n+    pub field: AstPtr<ast::RecordField>,\n+}\n+\n+impl Diagnostic for NoSuchField {\n+    fn message(&self) -> String {\n+        \"no such field\".to_string()\n+    }\n+\n+    fn source(&self) -> Source<SyntaxNodePtr> {\n+        Source { file_id: self.file, value: self.field.into() }\n+    }\n+\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct MissingFields {\n+    pub file: HirFileId,\n+    pub field_list: AstPtr<ast::RecordFieldList>,\n+    pub missed_fields: Vec<Name>,\n+}\n+\n+impl Diagnostic for MissingFields {\n+    fn message(&self) -> String {\n+        use std::fmt::Write;\n+        let mut message = String::from(\"Missing structure fields:\\n\");\n+        for field in &self.missed_fields {\n+            write!(message, \"- {}\\n\", field).unwrap();\n+        }\n+        message\n+    }\n+    fn source(&self) -> Source<SyntaxNodePtr> {\n+        Source { file_id: self.file, value: self.field_list.into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+impl AstDiagnostic for MissingFields {\n+    type AST = ast::RecordFieldList;\n+\n+    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+        let root = db.parse_or_expand(self.source().file_id).unwrap();\n+        let node = self.source().value.to_node(&root);\n+        ast::RecordFieldList::cast(node).unwrap()\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct MissingOkInTailExpr {\n+    pub file: HirFileId,\n+    pub expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for MissingOkInTailExpr {\n+    fn message(&self) -> String {\n+        \"wrap return expression in Ok\".to_string()\n+    }\n+    fn source(&self) -> Source<SyntaxNodePtr> {\n+        Source { file_id: self.file, value: self.expr.into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+impl AstDiagnostic for MissingOkInTailExpr {\n+    type AST = ast::Expr;\n+\n+    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+        let root = db.parse_or_expand(self.file).unwrap();\n+        let node = self.source().value.to_node(&root);\n+        ast::Expr::cast(node).unwrap()\n+    }\n+}"}, {"sha": "9bb3ece6c8db60e301a885d568e7323ca3ae6d49", "filename": "crates/ra_hir_ty/src/display.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_hir/src/ty/display.rs"}, {"sha": "5c65f9370799f85842dd807fdf9c69c1ae6e02c4", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "renamed", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -2,17 +2,20 @@\n \n use std::sync::Arc;\n \n-use hir_def::{path::known, resolver::HasResolver};\n-use hir_expand::diagnostics::DiagnosticSink;\n+use hir_def::{\n+    path::{known, Path},\n+    resolver::HasResolver,\n+    AdtId, FunctionId,\n+};\n+use hir_expand::{diagnostics::DiagnosticSink, name::Name};\n use ra_syntax::ast;\n use ra_syntax::AstPtr;\n use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n     diagnostics::{MissingFields, MissingOkInTailExpr},\n-    ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n-    Adt, Function, Name, Path,\n+    ApplicationTy, InferenceResult, Ty, TypeCtor,\n };\n \n pub use hir_def::{\n@@ -26,23 +29,23 @@ pub use hir_def::{\n     },\n };\n \n-pub(crate) struct ExprValidator<'a, 'b: 'a> {\n-    func: Function,\n+pub struct ExprValidator<'a, 'b: 'a> {\n+    func: FunctionId,\n     infer: Arc<InferenceResult>,\n     sink: &'a mut DiagnosticSink<'b>,\n }\n \n impl<'a, 'b> ExprValidator<'a, 'b> {\n-    pub(crate) fn new(\n-        func: Function,\n+    pub fn new(\n+        func: FunctionId,\n         infer: Arc<InferenceResult>,\n         sink: &'a mut DiagnosticSink<'b>,\n     ) -> ExprValidator<'a, 'b> {\n         ExprValidator { func, infer, sink }\n     }\n \n-    pub(crate) fn validate_body(&mut self, db: &impl HirDatabase) {\n-        let body = self.func.body(db);\n+    pub fn validate_body(&mut self, db: &impl HirDatabase) {\n+        let body = db.body(self.func.into());\n \n         for e in body.exprs.iter() {\n             if let (id, Expr::RecordLit { path, fields, spread }) = e {\n@@ -69,16 +72,18 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n \n         let struct_def = match self.infer[id].as_adt() {\n-            Some((Adt::Struct(s), _)) => s,\n+            Some((AdtId::StructId(s), _)) => s,\n             _ => return,\n         };\n+        let struct_data = db.struct_data(struct_def);\n \n         let lit_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n-        let missed_fields: Vec<Name> = struct_def\n-            .fields(db)\n+        let missed_fields: Vec<Name> = struct_data\n+            .variant_data\n+            .fields()\n             .iter()\n-            .filter_map(|f| {\n-                let name = f.name(db);\n+            .filter_map(|(_f, d)| {\n+                let name = d.name.clone();\n                 if lit_fields.contains(&name) {\n                     None\n                 } else {\n@@ -89,7 +94,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         if missed_fields.is_empty() {\n             return;\n         }\n-        let source_map = self.func.body_source_map(db);\n+        let (_, source_map) = db.body_with_source_map(self.func.into());\n \n         if let Some(source_ptr) = source_map.expr_syntax(id) {\n             if let Some(expr) = source_ptr.value.a() {\n@@ -121,20 +126,20 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         let std_result_path = known::std_result_result();\n \n-        let resolver = self.func.id.resolver(db);\n+        let resolver = self.func.resolver(db);\n         let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {\n             Some(it) => it,\n             _ => return,\n         };\n \n-        let std_result_ctor = TypeCtor::Adt(Adt::Enum(std_result_enum.into()));\n+        let std_result_ctor = TypeCtor::Adt(AdtId::EnumId(std_result_enum));\n         let params = match &mismatch.expected {\n             Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &std_result_ctor => parameters,\n             _ => return,\n         };\n \n         if params.len() == 2 && &params[0] == &mismatch.actual {\n-            let source_map = self.func.body_source_map(db);\n+            let (_, source_map) = db.body_with_source_map(self.func.into());\n \n             if let Some(source_ptr) = source_map.expr_syntax(id) {\n                 if let Some(expr) = source_ptr.value.a() {", "previous_filename": "crates/ra_hir/src/expr.rs"}, {"sha": "1e9f4b208d46220e202fce24e4a9162709d2ab1c", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "renamed", "additions": 68, "deletions": 93, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -22,34 +22,30 @@ use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use rustc_hash::FxHashMap;\n \n use hir_def::{\n+    body::Body,\n     data::{ConstData, FunctionData},\n-    path::known,\n+    expr::{BindingAnnotation, ExprId, PatId},\n+    path::{known, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n-    AdtId, DefWithBodyId,\n+    AdtId, AssocItemId, DefWithBodyId, FunctionId, StructFieldId, TypeAliasId, VariantId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n use test_utils::tested_by;\n \n use super::{\n-    lower,\n+    primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypableDef,\n-    TypeCtor, TypeWalk, Uncertain,\n-};\n-use crate::{\n-    code_model::TypeAlias,\n-    db::HirDatabase,\n-    expr::{BindingAnnotation, Body, ExprId, PatId},\n-    ty::infer::diagnostics::InferenceDiagnostic,\n-    Adt, AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, Trait, VariantDef,\n+    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    TypeWalk, Uncertain,\n };\n+use crate::{db::HirDatabase, infer::diagnostics::InferenceDiagnostic};\n \n macro_rules! ty_app {\n     ($ctor:pat, $param:pat) => {\n-        crate::ty::Ty::Apply(crate::ty::ApplicationTy { ctor: $ctor, parameters: $param })\n+        crate::Ty::Apply(crate::ApplicationTy { ctor: $ctor, parameters: $param })\n     };\n     ($ctor:pat) => {\n         ty_app!($ctor, _)\n@@ -63,15 +59,15 @@ mod pat;\n mod coerce;\n \n /// The entry point of type inference.\n-pub fn infer_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n+pub fn infer_query(db: &impl HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n     let _p = profile(\"infer_query\");\n-    let resolver = DefWithBodyId::from(def).resolver(db);\n+    let resolver = def.resolver(db);\n     let mut ctx = InferenceContext::new(db, def, resolver);\n \n-    match &def {\n-        DefWithBody::Const(c) => ctx.collect_const(&db.const_data(c.id)),\n-        DefWithBody::Function(f) => ctx.collect_fn(&db.function_data(f.id)),\n-        DefWithBody::Static(s) => ctx.collect_const(&db.static_data(s.id)),\n+    match def {\n+        DefWithBodyId::ConstId(c) => ctx.collect_const(&db.const_data(c)),\n+        DefWithBodyId::FunctionId(f) => ctx.collect_fn(&db.function_data(f)),\n+        DefWithBodyId::StaticId(s) => ctx.collect_const(&db.static_data(s)),\n     }\n \n     ctx.infer_body();\n@@ -122,50 +118,50 @@ pub struct TypeMismatch {\n #[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct InferenceResult {\n     /// For each method call expr, records the function it resolves to.\n-    method_resolutions: FxHashMap<ExprId, Function>,\n+    method_resolutions: FxHashMap<ExprId, FunctionId>,\n     /// For each field access expr, records the field it resolves to.\n-    field_resolutions: FxHashMap<ExprId, StructField>,\n+    field_resolutions: FxHashMap<ExprId, StructFieldId>,\n     /// For each field in record literal, records the field it resolves to.\n-    record_field_resolutions: FxHashMap<ExprId, StructField>,\n+    record_field_resolutions: FxHashMap<ExprId, StructFieldId>,\n     /// For each struct literal, records the variant it resolves to.\n-    variant_resolutions: FxHashMap<ExprOrPatId, VariantDef>,\n+    variant_resolutions: FxHashMap<ExprOrPatId, VariantId>,\n     /// For each associated item record what it resolves to\n-    assoc_resolutions: FxHashMap<ExprOrPatId, AssocItem>,\n+    assoc_resolutions: FxHashMap<ExprOrPatId, AssocItemId>,\n     diagnostics: Vec<InferenceDiagnostic>,\n-    pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n-    pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n+    pub type_of_expr: ArenaMap<ExprId, Ty>,\n+    pub type_of_pat: ArenaMap<PatId, Ty>,\n     pub(super) type_mismatches: ArenaMap<ExprId, TypeMismatch>,\n }\n \n impl InferenceResult {\n-    pub fn method_resolution(&self, expr: ExprId) -> Option<Function> {\n+    pub fn method_resolution(&self, expr: ExprId) -> Option<FunctionId> {\n         self.method_resolutions.get(&expr).copied()\n     }\n-    pub fn field_resolution(&self, expr: ExprId) -> Option<StructField> {\n+    pub fn field_resolution(&self, expr: ExprId) -> Option<StructFieldId> {\n         self.field_resolutions.get(&expr).copied()\n     }\n-    pub fn record_field_resolution(&self, expr: ExprId) -> Option<StructField> {\n+    pub fn record_field_resolution(&self, expr: ExprId) -> Option<StructFieldId> {\n         self.record_field_resolutions.get(&expr).copied()\n     }\n-    pub fn variant_resolution_for_expr(&self, id: ExprId) -> Option<VariantDef> {\n+    pub fn variant_resolution_for_expr(&self, id: ExprId) -> Option<VariantId> {\n         self.variant_resolutions.get(&id.into()).copied()\n     }\n-    pub fn variant_resolution_for_pat(&self, id: PatId) -> Option<VariantDef> {\n+    pub fn variant_resolution_for_pat(&self, id: PatId) -> Option<VariantId> {\n         self.variant_resolutions.get(&id.into()).copied()\n     }\n-    pub fn assoc_resolutions_for_expr(&self, id: ExprId) -> Option<AssocItem> {\n+    pub fn assoc_resolutions_for_expr(&self, id: ExprId) -> Option<AssocItemId> {\n         self.assoc_resolutions.get(&id.into()).copied()\n     }\n-    pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<AssocItem> {\n+    pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<AssocItemId> {\n         self.assoc_resolutions.get(&id.into()).copied()\n     }\n     pub fn type_mismatch_for_expr(&self, expr: ExprId) -> Option<&TypeMismatch> {\n         self.type_mismatches.get(expr)\n     }\n-    pub(crate) fn add_diagnostics(\n+    pub fn add_diagnostics(\n         &self,\n         db: &impl HirDatabase,\n-        owner: Function,\n+        owner: FunctionId,\n         sink: &mut DiagnosticSink,\n     ) {\n         self.diagnostics.iter().for_each(|it| it.add_to(db, owner, sink))\n@@ -192,7 +188,7 @@ impl Index<PatId> for InferenceResult {\n #[derive(Clone, Debug)]\n struct InferenceContext<'a, D: HirDatabase> {\n     db: &'a D,\n-    owner: DefWithBody,\n+    owner: DefWithBodyId,\n     body: Arc<Body>,\n     resolver: Resolver,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n@@ -210,13 +206,13 @@ struct InferenceContext<'a, D: HirDatabase> {\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n-    fn new(db: &'a D, owner: DefWithBody, resolver: Resolver) -> Self {\n+    fn new(db: &'a D, owner: DefWithBodyId, resolver: Resolver) -> Self {\n         InferenceContext {\n             result: InferenceResult::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n             obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n-            trait_env: lower::trait_env(db, &resolver),\n+            trait_env: TraitEnvironment::lower(db, &resolver),\n             coerce_unsized_map: Self::init_coerce_unsized_map(db, &resolver),\n             db,\n             owner,\n@@ -244,20 +240,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.result.type_of_expr.insert(expr, ty);\n     }\n \n-    fn write_method_resolution(&mut self, expr: ExprId, func: Function) {\n+    fn write_method_resolution(&mut self, expr: ExprId, func: FunctionId) {\n         self.result.method_resolutions.insert(expr, func);\n     }\n \n-    fn write_field_resolution(&mut self, expr: ExprId, field: StructField) {\n+    fn write_field_resolution(&mut self, expr: ExprId, field: StructFieldId) {\n         self.result.field_resolutions.insert(expr, field);\n     }\n \n-    fn write_variant_resolution(&mut self, id: ExprOrPatId, variant: VariantDef) {\n+    fn write_variant_resolution(&mut self, id: ExprOrPatId, variant: VariantId) {\n         self.result.variant_resolutions.insert(id, variant);\n     }\n \n-    fn write_assoc_resolution(&mut self, id: ExprOrPatId, item: AssocItem) {\n-        self.result.assoc_resolutions.insert(id, item);\n+    fn write_assoc_resolution(&mut self, id: ExprOrPatId, item: AssocItemId) {\n+        self.result.assoc_resolutions.insert(id, item.into());\n     }\n \n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n@@ -515,51 +511,28 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantDef>) {\n+    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantId>) {\n         let path = match path {\n             Some(path) => path,\n             None => return (Ty::Unknown, None),\n         };\n         let resolver = &self.resolver;\n-        let def: TypableDef =\n-            // FIXME: this should resolve assoc items as well, see this example:\n-            // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n-            match resolver.resolve_path_in_type_ns_fully(self.db, &path) {\n-                Some(TypeNs::AdtId(AdtId::StructId(it))) => it.into(),\n-                Some(TypeNs::AdtId(AdtId::UnionId(it))) => it.into(),\n-                Some(TypeNs::AdtSelfType(adt)) => adt.into(),\n-                Some(TypeNs::EnumVariantId(it)) => it.into(),\n-                Some(TypeNs::TypeAliasId(it)) => it.into(),\n-\n-                Some(TypeNs::SelfType(_)) |\n-                Some(TypeNs::GenericParam(_)) |\n-                Some(TypeNs::BuiltinType(_)) |\n-                Some(TypeNs::TraitId(_)) |\n-                Some(TypeNs::AdtId(AdtId::EnumId(_))) |\n-                None => {\n-                    return (Ty::Unknown, None)\n-                }\n-            };\n-        // FIXME remove the duplication between here and `Ty::from_path`?\n-        let substs = Ty::substs_from_path(self.db, resolver, path, def);\n-        match def {\n-            TypableDef::Adt(Adt::Struct(s)) => {\n-                let ty = s.ty(self.db);\n+        // FIXME: this should resolve assoc items as well, see this example:\n+        // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n+        match resolver.resolve_path_in_type_ns_fully(self.db, &path) {\n+            Some(TypeNs::AdtId(AdtId::StructId(strukt))) => {\n+                let substs = Ty::substs_from_path(self.db, resolver, path, strukt.into());\n+                let ty = self.db.ty(strukt.into());\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(s.into()))\n+                (ty, Some(strukt.into()))\n             }\n-            TypableDef::EnumVariant(var) => {\n-                let ty = var.parent_enum(self.db).ty(self.db);\n+            Some(TypeNs::EnumVariantId(var)) => {\n+                let substs = Ty::substs_from_path(self.db, resolver, path, var.into());\n+                let ty = self.db.ty(var.parent.into());\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n                 (ty, Some(var.into()))\n             }\n-            TypableDef::Adt(Adt::Enum(_))\n-            | TypableDef::Adt(Adt::Union(_))\n-            | TypableDef::TypeAlias(_)\n-            | TypableDef::Function(_)\n-            | TypableDef::Const(_)\n-            | TypableDef::Static(_)\n-            | TypableDef::BuiltinType(_) => (Ty::Unknown, None),\n+            Some(_) | None => (Ty::Unknown, None),\n         }\n     }\n \n@@ -581,28 +554,28 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.infer_expr(self.body.body_expr, &Expectation::has_type(self.return_ty.clone()));\n     }\n \n-    fn resolve_into_iter_item(&self) -> Option<TypeAlias> {\n+    fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n         let path = known::std_iter_into_iterator();\n-        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n-        trait_.associated_type_by_name(self.db, &name::ITEM_TYPE)\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name::ITEM_TYPE)\n     }\n \n-    fn resolve_ops_try_ok(&self) -> Option<TypeAlias> {\n+    fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n         let path = known::std_ops_try();\n-        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n-        trait_.associated_type_by_name(self.db, &name::OK_TYPE)\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OK_TYPE)\n     }\n \n-    fn resolve_future_future_output(&self) -> Option<TypeAlias> {\n+    fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n         let path = known::std_future_future();\n-        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n-        trait_.associated_type_by_name(self.db, &name::OUTPUT_TYPE)\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE)\n     }\n \n-    fn resolve_boxed_box(&self) -> Option<Adt> {\n+    fn resolve_boxed_box(&self) -> Option<AdtId> {\n         let path = known::std_boxed_box();\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n-        Some(Adt::Struct(struct_.into()))\n+        Some(struct_.into())\n     }\n }\n \n@@ -720,9 +693,10 @@ impl Expectation {\n }\n \n mod diagnostics {\n+    use hir_def::{expr::ExprId, FunctionId, HasSource, Lookup};\n     use hir_expand::diagnostics::DiagnosticSink;\n \n-    use crate::{db::HirDatabase, diagnostics::NoSuchField, expr::ExprId, Function, HasSource};\n+    use crate::{db::HirDatabase, diagnostics::NoSuchField};\n \n     #[derive(Debug, PartialEq, Eq, Clone)]\n     pub(super) enum InferenceDiagnostic {\n@@ -733,13 +707,14 @@ mod diagnostics {\n         pub(super) fn add_to(\n             &self,\n             db: &impl HirDatabase,\n-            owner: Function,\n+            owner: FunctionId,\n             sink: &mut DiagnosticSink,\n         ) {\n             match self {\n                 InferenceDiagnostic::NoSuchField { expr, field } => {\n-                    let file = owner.source(db).file_id;\n-                    let field = owner.body_source_map(db).field_syntax(*expr, *field);\n+                    let file = owner.lookup(db).source(db).file_id;\n+                    let (_, source_map) = db.body_with_source_map(owner.into());\n+                    let field = source_map.field_syntax(*expr, *field);\n                     sink.push(NoSuchField { file, field })\n                 }\n             }", "previous_filename": "crates/ra_hir/src/ty/infer.rs"}, {"sha": "719a0f395753735f3b62eda1795e4de91d618380", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "renamed", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -4,17 +4,13 @@\n //!\n //! See: https://doc.rust-lang.org/nomicon/coercions.html\n \n-use hir_def::{lang_item::LangItemTarget, resolver::Resolver};\n+use hir_def::{lang_item::LangItemTarget, resolver::Resolver, type_ref::Mutability, AdtId};\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n-use crate::{\n-    db::HirDatabase,\n-    ty::{autoderef, Substs, Ty, TypeCtor, TypeWalk},\n-    Adt, Mutability,\n-};\n+use crate::{autoderef, db::HirDatabase, ImplTy, Substs, Ty, TypeCtor, TypeWalk};\n \n-use super::{InferTy, InferenceContext, TypeVarValue};\n+use super::{InEnvironment, InferTy, InferenceContext, TypeVarValue};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// Unify two types, but may coerce the first one to the second one\n@@ -57,9 +53,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         impls\n             .iter()\n-            .filter_map(|impl_block| {\n+            .filter_map(|&impl_id| {\n+                let trait_ref = match db.impl_ty(impl_id) {\n+                    ImplTy::TraitRef(it) => it,\n+                    ImplTy::Inherent(_) => return None,\n+                };\n+\n                 // `CoerseUnsized` has one generic parameter for the target type.\n-                let trait_ref = impl_block.target_trait_ref(db)?;\n                 let cur_from_ty = trait_ref.substs.0.get(0)?;\n                 let cur_to_ty = trait_ref.substs.0.get(1)?;\n \n@@ -242,11 +242,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             // - T is not part of the type of any other fields\n             // - Bar<T>: Unsize<Bar<U>>, if the last field of Foo has type Bar<T>\n             (\n-                ty_app!(TypeCtor::Adt(Adt::Struct(struct1)), st1),\n-                ty_app!(TypeCtor::Adt(Adt::Struct(struct2)), st2),\n+                ty_app!(TypeCtor::Adt(AdtId::StructId(struct1)), st1),\n+                ty_app!(TypeCtor::Adt(AdtId::StructId(struct2)), st2),\n             ) if struct1 == struct2 => {\n-                let field_tys = self.db.field_types(struct1.id.into());\n-                let struct_data = self.db.struct_data(struct1.id.0);\n+                let field_tys = self.db.field_types((*struct1).into());\n+                let struct_data = self.db.struct_data(*struct1);\n \n                 let mut fields = struct_data.variant_data.fields().iter();\n                 let (last_field_id, _data) = fields.next_back()?;\n@@ -320,9 +320,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let canonicalized = self.canonicalizer().canonicalize_ty(from_ty.clone());\n         let to_ty = self.resolve_ty_shallow(&to_ty);\n         // FIXME: Auto DerefMut\n-        for derefed_ty in\n-            autoderef::autoderef(self.db, &self.resolver.clone(), canonicalized.value.clone())\n-        {\n+        for derefed_ty in autoderef::autoderef(\n+            self.db,\n+            self.resolver.krate(),\n+            InEnvironment {\n+                value: canonicalized.value.clone(),\n+                environment: self.trait_env.clone(),\n+            },\n+        ) {\n             let derefed_ty = canonicalized.decanonicalize_ty(derefed_ty.value);\n             match (&*self.resolve_ty_shallow(&derefed_ty), &*to_ty) {\n                 // Stop when constructor matches.", "previous_filename": "crates/ra_hir/src/ty/infer/coerce.rs"}, {"sha": "2f9ca4bbbfd87a44449ea1b394b10f0149eefa21", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "renamed", "additions": 68, "deletions": 49, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -5,21 +5,18 @@ use std::sync::Arc;\n \n use hir_def::{\n     builtin_type::Signedness,\n+    expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     generics::GenericParams,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n+    AdtId, ContainerId, Lookup, StructFieldId,\n };\n-use hir_expand::name;\n+use hir_expand::name::{self, Name};\n \n use crate::{\n-    db::HirDatabase,\n-    expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n-    ty::{\n-        autoderef, method_resolution, op, CallableDef, InferTy, IntTy, Mutability, Namespace,\n-        Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n-        Uncertain,\n-    },\n-    Adt, Name,\n+    autoderef, db::HirDatabase, method_resolution, op, traits::InEnvironment, utils::variant_data,\n+    CallableDef, InferTy, IntTy, Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs,\n+    TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n };\n \n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n@@ -136,8 +133,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n                     Substs(sig_tys.into()),\n                 );\n-                let closure_ty =\n-                    Ty::apply_one(TypeCtor::Closure { def: self.owner, expr: tgt_expr }, sig_ty);\n+                let closure_ty = Ty::apply_one(\n+                    TypeCtor::Closure { def: self.owner.into(), expr: tgt_expr },\n+                    sig_ty,\n+                );\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n@@ -216,22 +215,26 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let substs = ty.substs().unwrap_or_else(Substs::empty);\n                 let field_types =\n                     def_id.map(|it| self.db.field_types(it.into())).unwrap_or_default();\n+                let variant_data = def_id.map(|it| variant_data(self.db, it));\n                 for (field_idx, field) in fields.iter().enumerate() {\n-                    let field_def = def_id.and_then(|it| match it.field(self.db, &field.name) {\n-                        Some(field) => Some(field),\n-                        None => {\n-                            self.push_diagnostic(InferenceDiagnostic::NoSuchField {\n-                                expr: tgt_expr,\n-                                field: field_idx,\n-                            });\n-                            None\n-                        }\n-                    });\n+                    let field_def =\n+                        variant_data.as_ref().and_then(|it| match it.field(&field.name) {\n+                            Some(local_id) => {\n+                                Some(StructFieldId { parent: def_id.unwrap(), local_id })\n+                            }\n+                            None => {\n+                                self.push_diagnostic(InferenceDiagnostic::NoSuchField {\n+                                    expr: tgt_expr,\n+                                    field: field_idx,\n+                                });\n+                                None\n+                            }\n+                        });\n                     if let Some(field_def) = field_def {\n                         self.result.record_field_resolutions.insert(field.expr, field_def);\n                     }\n                     let field_ty = field_def\n-                        .map_or(Ty::Unknown, |it| field_types[it.id].clone())\n+                        .map_or(Ty::Unknown, |it| field_types[it.local_id].clone())\n                         .subst(&substs);\n                     self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n                 }\n@@ -245,20 +248,28 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let canonicalized = self.canonicalizer().canonicalize_ty(receiver_ty);\n                 let ty = autoderef::autoderef(\n                     self.db,\n-                    &self.resolver.clone(),\n-                    canonicalized.value.clone(),\n+                    self.resolver.krate(),\n+                    InEnvironment {\n+                        value: canonicalized.value.clone(),\n+                        environment: self.trait_env.clone(),\n+                    },\n                 )\n                 .find_map(|derefed_ty| match canonicalized.decanonicalize_ty(derefed_ty.value) {\n                     Ty::Apply(a_ty) => match a_ty.ctor {\n                         TypeCtor::Tuple { .. } => name\n                             .as_tuple_index()\n                             .and_then(|idx| a_ty.parameters.0.get(idx).cloned()),\n-                        TypeCtor::Adt(Adt::Struct(s)) => s.field(self.db, name).map(|field| {\n-                            self.write_field_resolution(tgt_expr, field);\n-                            self.db.field_types(s.id.into())[field.id]\n-                                .clone()\n-                                .subst(&a_ty.parameters)\n-                        }),\n+                        TypeCtor::Adt(AdtId::StructId(s)) => {\n+                            self.db.struct_data(s).variant_data.field(name).map(|local_id| {\n+                                let field = StructFieldId { parent: s.into(), local_id }.into();\n+                                self.write_field_resolution(tgt_expr, field);\n+                                self.db.field_types(s.into())[field.local_id]\n+                                    .clone()\n+                                    .subst(&a_ty.parameters)\n+                            })\n+                        }\n+                        // FIXME:\n+                        TypeCtor::Adt(AdtId::UnionId(_)) => None,\n                         _ => None,\n                     },\n                     _ => None,\n@@ -337,16 +348,25 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::UnaryOp { expr, op } => {\n                 let inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 match op {\n-                    UnaryOp::Deref => {\n-                        let canonicalized = self.canonicalizer().canonicalize_ty(inner_ty);\n-                        if let Some(derefed_ty) =\n-                            autoderef::deref(self.db, &self.resolver, &canonicalized.value)\n-                        {\n-                            canonicalized.decanonicalize_ty(derefed_ty.value)\n-                        } else {\n-                            Ty::Unknown\n+                    UnaryOp::Deref => match self.resolver.krate() {\n+                        Some(krate) => {\n+                            let canonicalized = self.canonicalizer().canonicalize_ty(inner_ty);\n+                            match autoderef::deref(\n+                                self.db,\n+                                krate,\n+                                InEnvironment {\n+                                    value: &canonicalized.value,\n+                                    environment: self.trait_env.clone(),\n+                                },\n+                            ) {\n+                                Some(derefed_ty) => {\n+                                    canonicalized.decanonicalize_ty(derefed_ty.value)\n+                                }\n+                                None => Ty::Unknown,\n+                            }\n                         }\n-                    }\n+                        None => Ty::Unknown,\n+                    },\n                     UnaryOp::Neg => {\n                         match &inner_ty {\n                             Ty::Apply(a_ty) => match a_ty.ctor {\n@@ -538,11 +558,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some((ty, func)) => {\n                 let ty = canonicalized_receiver.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n-                (\n-                    ty,\n-                    self.db.type_for_def(func.into(), Namespace::Values),\n-                    Some(self.db.generic_params(func.id.into())),\n-                )\n+                (ty, self.db.value_ty(func.into()), Some(self.db.generic_params(func.into())))\n             }\n             None => (receiver_ty, Ty::Unknown, None),\n         };\n@@ -648,18 +664,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n                 // add obligation for trait implementation, if this is a trait method\n                 match def {\n-                    CallableDef::Function(f) => {\n-                        if let Some(trait_) = f.parent_trait(self.db) {\n+                    CallableDef::FunctionId(f) => {\n+                        if let ContainerId::TraitId(trait_) = f.lookup(self.db).container {\n                             // construct a TraitDef\n                             let substs = a_ty.parameters.prefix(\n                                 self.db\n-                                    .generic_params(trait_.id.into())\n+                                    .generic_params(trait_.into())\n                                     .count_params_including_parent(),\n                             );\n-                            self.obligations.push(Obligation::Trait(TraitRef { trait_, substs }));\n+                            self.obligations.push(Obligation::Trait(TraitRef {\n+                                trait_: trait_.into(),\n+                                substs,\n+                            }));\n                         }\n                     }\n-                    CallableDef::Struct(_) | CallableDef::EnumVariant(_) => {}\n+                    CallableDef::StructId(_) | CallableDef::EnumVariantId(_) => {}\n                 }\n             }\n         }", "previous_filename": "crates/ra_hir/src/ty/infer/expr.rs"}, {"sha": "1ebb362399a9d9cdac14a01b4fc50f388f19d9cb", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "renamed", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -3,15 +3,16 @@\n use std::iter::repeat;\n use std::sync::Arc;\n \n+use hir_def::{\n+    expr::{BindingAnnotation, Pat, PatId, RecordFieldPat},\n+    path::Path,\n+    type_ref::Mutability,\n+};\n+use hir_expand::name::Name;\n use test_utils::tested_by;\n \n use super::{BindingMode, InferenceContext};\n-use crate::{\n-    db::HirDatabase,\n-    expr::{BindingAnnotation, Pat, PatId, RecordFieldPat},\n-    ty::{Mutability, Substs, Ty, TypeCtor, TypeWalk},\n-    Name, Path,\n-};\n+use crate::{db::HirDatabase, utils::variant_data, Substs, Ty, TypeCtor, TypeWalk};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn infer_tuple_struct_pat(\n@@ -22,16 +23,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         default_bm: BindingMode,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n-\n+        let var_data = def.map(|it| variant_data(self.db, it));\n         self.unify(&ty, expected);\n \n         let substs = ty.substs().unwrap_or_else(Substs::empty);\n \n         let field_tys = def.map(|it| self.db.field_types(it.into())).unwrap_or_default();\n+\n         for (i, &subpat) in subpats.iter().enumerate() {\n-            let expected_ty = def\n-                .and_then(|d| d.field(self.db, &Name::new_tuple_field(i)))\n-                .map_or(Ty::Unknown, |field| field_tys[field.id].clone())\n+            let expected_ty = var_data\n+                .as_ref()\n+                .and_then(|d| d.field(&Name::new_tuple_field(i)))\n+                .map_or(Ty::Unknown, |field| field_tys[field].clone())\n                 .subst(&substs);\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat, &expected_ty, default_bm);\n@@ -49,6 +52,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         id: PatId,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n+        let var_data = def.map(|it| variant_data(self.db, it));\n         if let Some(variant) = def {\n             self.write_variant_resolution(id.into(), variant);\n         }\n@@ -59,10 +63,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         let field_tys = def.map(|it| self.db.field_types(it.into())).unwrap_or_default();\n         for subpat in subpats {\n-            let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n-            let expected_ty = matching_field\n-                .map_or(Ty::Unknown, |field| field_tys[field.id].clone())\n-                .subst(&substs);\n+            let matching_field = var_data.as_ref().and_then(|it| it.field(&subpat.name));\n+            let expected_ty =\n+                matching_field.map_or(Ty::Unknown, |field| field_tys[field].clone()).subst(&substs);\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }", "previous_filename": "crates/ra_hir/src/ty/infer/pat.rs"}, {"sha": "14be668365038719ee37d1109d76ceb4a5412b38", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "renamed", "additions": 54, "deletions": 44, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,15 +1,13 @@\n //! Path expression resolution.\n \n use hir_def::{\n-    path::PathSegment,\n+    path::{Path, PathKind, PathSegment},\n     resolver::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n+    AssocItemId, ContainerId, Lookup,\n };\n+use hir_expand::name::Name;\n \n-use crate::{\n-    db::HirDatabase,\n-    ty::{method_resolution, Namespace, Substs, Ty, TypableDef, TypeWalk},\n-    AssocItem, Container, Function, Name, Path,\n-};\n+use crate::{db::HirDatabase, method_resolution, Substs, Ty, TypeWalk, ValueTyDefId};\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n@@ -32,7 +30,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         path: &Path,\n         id: ExprOrPatId,\n     ) -> Option<Ty> {\n-        let (value, self_subst) = if let crate::PathKind::Type(type_ref) = &path.kind {\n+        let (value, self_subst) = if let PathKind::Type(type_ref) = &path.kind {\n             if path.segments.is_empty() {\n                 // This can't actually happen syntax-wise\n                 return None;\n@@ -56,7 +54,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n         };\n \n-        let typable: TypableDef = match value {\n+        let typable: ValueTyDefId = match value {\n             ValueNs::LocalBinding(pat) => {\n                 let ty = self.result.type_of_pat.get(pat)?.clone();\n                 let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n@@ -69,11 +67,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ValueNs::EnumVariantId(it) => it.into(),\n         };\n \n-        let mut ty = self.db.type_for_def(typable, Namespace::Values);\n+        let mut ty = self.db.value_ty(typable);\n         if let Some(self_subst) = self_subst {\n             ty = ty.subst(&self_subst);\n         }\n-\n         let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n         let ty = ty.subst(&substs);\n         Some(ty)\n@@ -143,28 +140,35 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         let trait_ = trait_ref.trait_;\n-        let item = trait_.items(self.db).iter().copied().find_map(|item| match item {\n-            AssocItem::Function(func) => {\n-                if segment.name == func.name(self.db) {\n-                    Some(AssocItem::Function(func))\n-                } else {\n-                    None\n+        let item = self\n+            .db\n+            .trait_data(trait_)\n+            .items\n+            .iter()\n+            .map(|(_name, id)| (*id).into())\n+            .find_map(|item| match item {\n+                AssocItemId::FunctionId(func) => {\n+                    if segment.name == self.db.function_data(func).name {\n+                        Some(AssocItemId::FunctionId(func))\n+                    } else {\n+                        None\n+                    }\n                 }\n-            }\n \n-            AssocItem::Const(konst) => {\n-                if konst.name(self.db).map_or(false, |n| n == segment.name) {\n-                    Some(AssocItem::Const(konst))\n-                } else {\n-                    None\n+                AssocItemId::ConstId(konst) => {\n+                    if self.db.const_data(konst).name.as_ref().map_or(false, |n| n == &segment.name)\n+                    {\n+                        Some(AssocItemId::ConstId(konst))\n+                    } else {\n+                        None\n+                    }\n                 }\n-            }\n-            AssocItem::TypeAlias(_) => None,\n-        })?;\n+                AssocItemId::TypeAliasId(_) => None,\n+            })?;\n         let def = match item {\n-            AssocItem::Function(f) => ValueNs::FunctionId(f.id),\n-            AssocItem::Const(c) => ValueNs::ConstId(c.id),\n-            AssocItem::TypeAlias(_) => unreachable!(),\n+            AssocItemId::FunctionId(f) => ValueNs::FunctionId(f),\n+            AssocItemId::ConstId(c) => ValueNs::ConstId(c),\n+            AssocItemId::TypeAliasId(_) => unreachable!(),\n         };\n         let substs = Substs::build_for_def(self.db, item)\n             .use_parent_substs(&trait_ref.substs)\n@@ -194,16 +198,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some(name),\n             method_resolution::LookupMode::Path,\n             move |_ty, item| {\n-                let def = match item {\n-                    AssocItem::Function(f) => ValueNs::FunctionId(f.id),\n-                    AssocItem::Const(c) => ValueNs::ConstId(c.id),\n-                    AssocItem::TypeAlias(_) => unreachable!(),\n+                let (def, container) = match item {\n+                    AssocItemId::FunctionId(f) => {\n+                        (ValueNs::FunctionId(f), f.lookup(self.db).container)\n+                    }\n+                    AssocItemId::ConstId(c) => (ValueNs::ConstId(c), c.lookup(self.db).container),\n+                    AssocItemId::TypeAliasId(_) => unreachable!(),\n                 };\n-                let substs = match item.container(self.db) {\n-                    Container::ImplBlock(_) => self.find_self_types(&def, ty.clone()),\n-                    Container::Trait(t) => {\n+                let substs = match container {\n+                    ContainerId::ImplId(_) => self.find_self_types(&def, ty.clone()),\n+                    ContainerId::TraitId(trait_) => {\n                         // we're picking this method\n-                        let trait_substs = Substs::build_for_def(self.db, t)\n+                        let trait_substs = Substs::build_for_def(self.db, trait_)\n                             .push(ty.clone())\n                             .fill(std::iter::repeat_with(|| self.new_type_var()))\n                             .build();\n@@ -212,37 +218,41 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             .fill_with_params()\n                             .build();\n                         self.obligations.push(super::Obligation::Trait(TraitRef {\n-                            trait_: t,\n+                            trait_,\n                             substs: trait_substs,\n                         }));\n                         Some(substs)\n                     }\n+                    ContainerId::ModuleId(_) => None,\n                 };\n \n-                self.write_assoc_resolution(id, item);\n+                self.write_assoc_resolution(id, item.into());\n                 Some((def, substs))\n             },\n         )\n     }\n \n     fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {\n-        if let ValueNs::FunctionId(func) = def {\n-            let func = Function::from(*func);\n+        if let ValueNs::FunctionId(func) = *def {\n             // We only do the infer if parent has generic params\n-            let gen = self.db.generic_params(func.id.into());\n+            let gen = self.db.generic_params(func.into());\n             if gen.count_parent_params() == 0 {\n                 return None;\n             }\n \n-            let impl_block = func.impl_block(self.db)?.target_ty(self.db);\n-            let impl_block_substs = impl_block.substs()?;\n+            let impl_id = match func.lookup(self.db).container {\n+                ContainerId::ImplId(it) => it,\n+                _ => return None,\n+            };\n+            let self_ty = self.db.impl_ty(impl_id).self_type().clone();\n+            let self_ty_substs = self_ty.substs()?;\n             let actual_substs = actual_def_ty.substs()?;\n \n             let mut new_substs = vec![Ty::Unknown; gen.count_parent_params()];\n \n             // The following code *link up* the function actual parma type\n             // and impl_block type param index\n-            impl_block_substs.iter().zip(actual_substs.iter()).for_each(|(param, pty)| {\n+            self_ty_substs.iter().zip(actual_substs.iter()).for_each(|(param, pty)| {\n                 if let Ty::Param { idx, .. } = param {\n                     if let Some(s) = new_substs.get_mut(*idx as usize) {\n                         *s = pty.clone();", "previous_filename": "crates/ra_hir/src/ty/infer/path.rs"}, {"sha": "f3a8756785d852fe87b64970eed8247c90df68e3", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,12 +1,10 @@\n //! Unification and canonicalization logic.\n \n use super::{InferenceContext, Obligation};\n-use crate::db::HirDatabase;\n-use crate::ty::{\n-    Canonical, InEnvironment, InferTy, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty,\n-    TypeWalk,\n+use crate::{\n+    db::HirDatabase, utils::make_mut_slice, Canonical, InEnvironment, InferTy, ProjectionPredicate,\n+    ProjectionTy, Substs, TraitRef, Ty, TypeWalk,\n };\n-use crate::util::make_mut_slice;\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b, D>", "previous_filename": "crates/ra_hir/src/ty/infer/unify.rs"}, {"sha": "b45c8f82f4106bca0126e00f0800583322cf891f", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "added", "additions": 1138, "deletions": 0, "changes": 1138, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -0,0 +1,1138 @@\n+//! The type system. We currently use this to infer types for completion, hover\n+//! information and various assists.\n+\n+macro_rules! impl_froms {\n+    ($e:ident: $($v:ident $(($($sv:ident),*))?),*) => {\n+        $(\n+            impl From<$v> for $e {\n+                fn from(it: $v) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+            $($(\n+                impl From<$sv> for $e {\n+                    fn from(it: $sv) -> $e {\n+                        $e::$v($v::$sv(it))\n+                    }\n+                }\n+            )*)?\n+        )*\n+    }\n+}\n+\n+mod autoderef;\n+pub mod primitive;\n+pub mod traits;\n+pub mod method_resolution;\n+mod op;\n+mod lower;\n+mod infer;\n+pub mod display;\n+pub(crate) mod utils;\n+pub mod db;\n+pub mod diagnostics;\n+pub mod expr;\n+\n+#[cfg(test)]\n+mod tests;\n+#[cfg(test)]\n+mod test_db;\n+mod marks;\n+\n+use std::ops::Deref;\n+use std::sync::Arc;\n+use std::{fmt, iter, mem};\n+\n+use hir_def::{\n+    expr::ExprId, generics::GenericParams, type_ref::Mutability, AdtId, ContainerId, DefWithBodyId,\n+    GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n+};\n+use hir_expand::name::Name;\n+use ra_db::{impl_intern_key, salsa, CrateId};\n+\n+use crate::{\n+    db::HirDatabase,\n+    primitive::{FloatTy, IntTy, Uncertain},\n+    utils::make_mut_slice,\n+};\n+use display::{HirDisplay, HirFormatter};\n+\n+pub use autoderef::autoderef;\n+pub use infer::{infer_query, InferTy, InferenceResult};\n+pub use lower::CallableDef;\n+pub use lower::{callable_item_sig, TyDefId, ValueTyDefId};\n+pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n+\n+/// A type constructor or type name: this might be something like the primitive\n+/// type `bool`, a struct like `Vec`, or things like function pointers or\n+/// tuples.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum TypeCtor {\n+    /// The primitive boolean type. Written as `bool`.\n+    Bool,\n+\n+    /// The primitive character type; holds a Unicode scalar value\n+    /// (a non-surrogate code point). Written as `char`.\n+    Char,\n+\n+    /// A primitive integer type. For example, `i32`.\n+    Int(Uncertain<IntTy>),\n+\n+    /// A primitive floating-point type. For example, `f64`.\n+    Float(Uncertain<FloatTy>),\n+\n+    /// Structures, enumerations and unions.\n+    Adt(AdtId),\n+\n+    /// The pointee of a string slice. Written as `str`.\n+    Str,\n+\n+    /// The pointee of an array slice.  Written as `[T]`.\n+    Slice,\n+\n+    /// An array with the given length. Written as `[T; n]`.\n+    Array,\n+\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    RawPtr(Mutability),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&'a mut T` or `&'a T`.\n+    Ref(Mutability),\n+\n+    /// The anonymous type of a function declaration/definition. Each\n+    /// function has a unique type, which is output (for a function\n+    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n+    ///\n+    /// This includes tuple struct / enum variant constructors as well.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar = foo; // bar: fn() -> i32 {foo}\n+    /// ```\n+    FnDef(CallableDef),\n+\n+    /// A pointer to a function.  Written as `fn() -> i32`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar: fn() -> i32 = foo;\n+    /// ```\n+    FnPtr { num_args: u16 },\n+\n+    /// The never type `!`.\n+    Never,\n+\n+    /// A tuple type.  For example, `(i32, bool)`.\n+    Tuple { cardinality: u16 },\n+\n+    /// Represents an associated item like `Iterator::Item`.  This is used\n+    /// when we have tried to normalize a projection like `T::Item` but\n+    /// couldn't find a better representation.  In that case, we generate\n+    /// an **application type** like `(Iterator::Item)<T>`.\n+    AssociatedType(TypeAliasId),\n+\n+    /// The type of a specific closure.\n+    ///\n+    /// The closure signature is stored in a `FnPtr` type in the first type\n+    /// parameter.\n+    Closure { def: DefWithBodyId, expr: ExprId },\n+}\n+\n+/// This exists just for Chalk, because Chalk just has a single `StructId` where\n+/// we have different kinds of ADTs, primitive types and special type\n+/// constructors like tuples and function pointers.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TypeCtorId(salsa::InternId);\n+impl_intern_key!(TypeCtorId);\n+\n+impl TypeCtor {\n+    pub fn num_ty_params(self, db: &impl HirDatabase) -> usize {\n+        match self {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Str\n+            | TypeCtor::Never => 0,\n+            TypeCtor::Slice\n+            | TypeCtor::Array\n+            | TypeCtor::RawPtr(_)\n+            | TypeCtor::Ref(_)\n+            | TypeCtor::Closure { .. } // 1 param representing the signature of the closure\n+            => 1,\n+            TypeCtor::Adt(adt) => {\n+                let generic_params = db.generic_params(AdtId::from(adt).into());\n+                generic_params.count_params_including_parent()\n+            }\n+            TypeCtor::FnDef(callable) => {\n+                let generic_params = db.generic_params(callable.into());\n+                generic_params.count_params_including_parent()\n+            }\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let generic_params = db.generic_params(type_alias.into());\n+                generic_params.count_params_including_parent()\n+            }\n+            TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n+            TypeCtor::Tuple { cardinality } => cardinality as usize,\n+        }\n+    }\n+\n+    pub fn krate(self, db: &impl HirDatabase) -> Option<CrateId> {\n+        match self {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Str\n+            | TypeCtor::Never\n+            | TypeCtor::Slice\n+            | TypeCtor::Array\n+            | TypeCtor::RawPtr(_)\n+            | TypeCtor::Ref(_)\n+            | TypeCtor::FnPtr { .. }\n+            | TypeCtor::Tuple { .. } => None,\n+            // Closure's krate is irrelevant for coherence I would think?\n+            TypeCtor::Closure { .. } => None,\n+            TypeCtor::Adt(adt) => Some(adt.module(db).krate),\n+            TypeCtor::FnDef(callable) => Some(callable.krate(db)),\n+            TypeCtor::AssociatedType(type_alias) => Some(type_alias.lookup(db).module(db).krate),\n+        }\n+    }\n+\n+    pub fn as_generic_def(self) -> Option<GenericDefId> {\n+        match self {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Str\n+            | TypeCtor::Never\n+            | TypeCtor::Slice\n+            | TypeCtor::Array\n+            | TypeCtor::RawPtr(_)\n+            | TypeCtor::Ref(_)\n+            | TypeCtor::FnPtr { .. }\n+            | TypeCtor::Tuple { .. }\n+            | TypeCtor::Closure { .. } => None,\n+            TypeCtor::Adt(adt) => Some(adt.into()),\n+            TypeCtor::FnDef(callable) => Some(callable.into()),\n+            TypeCtor::AssociatedType(type_alias) => Some(type_alias.into()),\n+        }\n+    }\n+}\n+\n+/// A nominal type with (maybe 0) type parameters. This might be a primitive\n+/// type like `bool`, a struct, tuple, function pointer, reference or\n+/// several other things.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct ApplicationTy {\n+    pub ctor: TypeCtor,\n+    pub parameters: Substs,\n+}\n+\n+/// A \"projection\" type corresponds to an (unnormalized)\n+/// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n+/// trait and all its parameters are fully known.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct ProjectionTy {\n+    pub associated_ty: TypeAliasId,\n+    pub parameters: Substs,\n+}\n+\n+impl ProjectionTy {\n+    pub fn trait_ref(&self, db: &impl HirDatabase) -> TraitRef {\n+        TraitRef { trait_: self.trait_(db).into(), substs: self.parameters.clone() }\n+    }\n+\n+    fn trait_(&self, db: &impl HirDatabase) -> TraitId {\n+        match self.associated_ty.lookup(db).container {\n+            ContainerId::TraitId(it) => it,\n+            _ => panic!(\"projection ty without parent trait\"),\n+        }\n+    }\n+}\n+\n+impl TypeWalk for ProjectionTy {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.parameters.walk(f);\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.parameters.walk_mut_binders(f, binders);\n+    }\n+}\n+\n+/// A type.\n+///\n+/// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n+/// the same thing (but in a different way).\n+///\n+/// This should be cheap to clone.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum Ty {\n+    /// A nominal type with (maybe 0) type parameters. This might be a primitive\n+    /// type like `bool`, a struct, tuple, function pointer, reference or\n+    /// several other things.\n+    Apply(ApplicationTy),\n+\n+    /// A \"projection\" type corresponds to an (unnormalized)\n+    /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n+    /// trait and all its parameters are fully known.\n+    Projection(ProjectionTy),\n+\n+    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n+    Param {\n+        /// The index of the parameter (starting with parameters from the\n+        /// surrounding impl, then the current function).\n+        idx: u32,\n+        /// The name of the parameter, for displaying.\n+        // FIXME get rid of this\n+        name: Name,\n+    },\n+\n+    /// A bound type variable. Used during trait resolution to represent Chalk\n+    /// variables, and in `Dyn` and `Opaque` bounds to represent the `Self` type.\n+    Bound(u32),\n+\n+    /// A type variable used during type checking. Not to be confused with a\n+    /// type parameter.\n+    Infer(InferTy),\n+\n+    /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n+    ///\n+    /// The predicates are quantified over the `Self` type, i.e. `Ty::Bound(0)`\n+    /// represents the `Self` type inside the bounds. This is currently\n+    /// implicit; Chalk has the `Binders` struct to make it explicit, but it\n+    /// didn't seem worth the overhead yet.\n+    Dyn(Arc<[GenericPredicate]>),\n+\n+    /// An opaque type (`impl Trait`).\n+    ///\n+    /// The predicates are quantified over the `Self` type; see `Ty::Dyn` for\n+    /// more.\n+    Opaque(Arc<[GenericPredicate]>),\n+\n+    /// A placeholder for a type which could not be computed; this is propagated\n+    /// to avoid useless error messages. Doubles as a placeholder where type\n+    /// variables are inserted before type checking, since we want to try to\n+    /// infer a better type here anyway -- for the IDE use case, we want to try\n+    /// to infer as much as possible even in the presence of type errors.\n+    Unknown,\n+}\n+\n+/// A list of substitutions for generic parameters.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct Substs(Arc<[Ty]>);\n+\n+impl TypeWalk for Substs {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.0.iter() {\n+            t.walk(f);\n+        }\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        for t in make_mut_slice(&mut self.0) {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n+impl Substs {\n+    pub fn empty() -> Substs {\n+        Substs(Arc::new([]))\n+    }\n+\n+    pub fn single(ty: Ty) -> Substs {\n+        Substs(Arc::new([ty]))\n+    }\n+\n+    pub fn prefix(&self, n: usize) -> Substs {\n+        Substs(self.0[..std::cmp::min(self.0.len(), n)].into())\n+    }\n+\n+    pub fn as_single(&self) -> &Ty {\n+        if self.0.len() != 1 {\n+            panic!(\"expected substs of len 1, got {:?}\", self);\n+        }\n+        &self.0[0]\n+    }\n+\n+    /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n+    pub fn identity(generic_params: &GenericParams) -> Substs {\n+        Substs(\n+            generic_params\n+                .params_including_parent()\n+                .into_iter()\n+                .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Return Substs that replace each parameter by a bound variable.\n+    pub fn bound_vars(generic_params: &GenericParams) -> Substs {\n+        Substs(\n+            generic_params\n+                .params_including_parent()\n+                .into_iter()\n+                .map(|p| Ty::Bound(p.idx))\n+                .collect(),\n+        )\n+    }\n+\n+    pub fn build_for_def(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n+        let def = def.into();\n+        let params = db.generic_params(def);\n+        let param_count = params.count_params_including_parent();\n+        Substs::builder(param_count)\n+    }\n+\n+    pub fn build_for_generics(generic_params: &GenericParams) -> SubstsBuilder {\n+        Substs::builder(generic_params.count_params_including_parent())\n+    }\n+\n+    pub fn build_for_type_ctor(db: &impl HirDatabase, type_ctor: TypeCtor) -> SubstsBuilder {\n+        Substs::builder(type_ctor.num_ty_params(db))\n+    }\n+\n+    fn builder(param_count: usize) -> SubstsBuilder {\n+        SubstsBuilder { vec: Vec::with_capacity(param_count), param_count }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct SubstsBuilder {\n+    vec: Vec<Ty>,\n+    param_count: usize,\n+}\n+\n+impl SubstsBuilder {\n+    pub fn build(self) -> Substs {\n+        assert_eq!(self.vec.len(), self.param_count);\n+        Substs(self.vec.into())\n+    }\n+\n+    pub fn push(mut self, ty: Ty) -> Self {\n+        self.vec.push(ty);\n+        self\n+    }\n+\n+    fn remaining(&self) -> usize {\n+        self.param_count - self.vec.len()\n+    }\n+\n+    pub fn fill_with_bound_vars(self, starting_from: u32) -> Self {\n+        self.fill((starting_from..).map(Ty::Bound))\n+    }\n+\n+    pub fn fill_with_params(self) -> Self {\n+        let start = self.vec.len() as u32;\n+        self.fill((start..).map(|idx| Ty::Param { idx, name: Name::missing() }))\n+    }\n+\n+    pub fn fill_with_unknown(self) -> Self {\n+        self.fill(iter::repeat(Ty::Unknown))\n+    }\n+\n+    pub fn fill(mut self, filler: impl Iterator<Item = Ty>) -> Self {\n+        self.vec.extend(filler.take(self.remaining()));\n+        assert_eq!(self.remaining(), 0);\n+        self\n+    }\n+\n+    pub fn use_parent_substs(mut self, parent_substs: &Substs) -> Self {\n+        assert!(self.vec.is_empty());\n+        assert!(parent_substs.len() <= self.param_count);\n+        self.vec.extend(parent_substs.iter().cloned());\n+        self\n+    }\n+}\n+\n+impl Deref for Substs {\n+    type Target = [Ty];\n+\n+    fn deref(&self) -> &[Ty] {\n+        &self.0\n+    }\n+}\n+\n+/// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n+/// Name to be bikeshedded: TraitBound? TraitImplements?\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TraitRef {\n+    /// FIXME name?\n+    pub trait_: TraitId,\n+    pub substs: Substs,\n+}\n+\n+impl TraitRef {\n+    pub fn self_ty(&self) -> &Ty {\n+        &self.substs[0]\n+    }\n+}\n+\n+impl TypeWalk for TraitRef {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.substs.walk(f);\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.substs.walk_mut_binders(f, binders);\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum ImplTy {\n+    Inherent(Ty),\n+    TraitRef(TraitRef),\n+}\n+\n+impl ImplTy {\n+    pub(crate) fn self_type(&self) -> &Ty {\n+        match self {\n+            ImplTy::Inherent(it) => it,\n+            ImplTy::TraitRef(tr) => &tr.substs[0],\n+        }\n+    }\n+}\n+\n+/// Like `generics::WherePredicate`, but with resolved types: A condition on the\n+/// parameters of a generic item.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum GenericPredicate {\n+    /// The given trait needs to be implemented for its type parameters.\n+    Implemented(TraitRef),\n+    /// An associated type bindings like in `Iterator<Item = T>`.\n+    Projection(ProjectionPredicate),\n+    /// We couldn't resolve the trait reference. (If some type parameters can't\n+    /// be resolved, they will just be Unknown).\n+    Error,\n+}\n+\n+impl GenericPredicate {\n+    pub fn is_error(&self) -> bool {\n+        match self {\n+            GenericPredicate::Error => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_implemented(&self) -> bool {\n+        match self {\n+            GenericPredicate::Implemented(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n+        match self {\n+            GenericPredicate::Implemented(tr) => Some(tr.clone()),\n+            GenericPredicate::Projection(proj) => Some(proj.projection_ty.trait_ref(db)),\n+            GenericPredicate::Error => None,\n+        }\n+    }\n+}\n+\n+impl TypeWalk for GenericPredicate {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.walk(f),\n+            GenericPredicate::Projection(projection_pred) => projection_pred.walk(f),\n+            GenericPredicate::Error => {}\n+        }\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut_binders(f, binders),\n+            GenericPredicate::Projection(projection_pred) => {\n+                projection_pred.walk_mut_binders(f, binders)\n+            }\n+            GenericPredicate::Error => {}\n+        }\n+    }\n+}\n+\n+/// Basically a claim (currently not validated / checked) that the contained\n+/// type / trait ref contains no inference variables; any inference variables it\n+/// contained have been replaced by bound variables, and `num_vars` tells us how\n+/// many there are. This is used to erase irrelevant differences between types\n+/// before using them in queries.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Canonical<T> {\n+    pub value: T,\n+    pub num_vars: usize,\n+}\n+\n+/// A function signature as seen by type inference: Several parameter types and\n+/// one return type.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct FnSig {\n+    params_and_return: Arc<[Ty]>,\n+}\n+\n+impl FnSig {\n+    pub fn from_params_and_return(mut params: Vec<Ty>, ret: Ty) -> FnSig {\n+        params.push(ret);\n+        FnSig { params_and_return: params.into() }\n+    }\n+\n+    pub fn from_fn_ptr_substs(substs: &Substs) -> FnSig {\n+        FnSig { params_and_return: Arc::clone(&substs.0) }\n+    }\n+\n+    pub fn params(&self) -> &[Ty] {\n+        &self.params_and_return[0..self.params_and_return.len() - 1]\n+    }\n+\n+    pub fn ret(&self) -> &Ty {\n+        &self.params_and_return[self.params_and_return.len() - 1]\n+    }\n+}\n+\n+impl TypeWalk for FnSig {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.params_and_return.iter() {\n+            t.walk(f);\n+        }\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        for t in make_mut_slice(&mut self.params_and_return) {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n+impl Ty {\n+    pub fn simple(ctor: TypeCtor) -> Ty {\n+        Ty::Apply(ApplicationTy { ctor, parameters: Substs::empty() })\n+    }\n+    pub fn apply_one(ctor: TypeCtor, param: Ty) -> Ty {\n+        Ty::Apply(ApplicationTy { ctor, parameters: Substs::single(param) })\n+    }\n+    pub fn apply(ctor: TypeCtor, parameters: Substs) -> Ty {\n+        Ty::Apply(ApplicationTy { ctor, parameters })\n+    }\n+    pub fn unit() -> Self {\n+        Ty::apply(TypeCtor::Tuple { cardinality: 0 }, Substs::empty())\n+    }\n+\n+    pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(mutability), parameters }) => {\n+                Some((parameters.as_single(), *mutability))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_adt(&self) -> Option<(AdtId, &Substs)> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(adt_def), parameters }) => {\n+                Some((*adt_def, parameters))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_tuple(&self) -> Option<&Substs> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple { .. }, parameters }) => {\n+                Some(parameters)\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_callable(&self) -> Option<(CallableDef, &Substs)> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::FnDef(callable_def), parameters }) => {\n+                Some((*callable_def, parameters))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn builtin_deref(&self) -> Option<Ty> {\n+        match self {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::Ref(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n+                TypeCtor::RawPtr(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn callable_sig(&self, db: &impl HirDatabase) -> Option<FnSig> {\n+        match self {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::FnPtr { .. } => Some(FnSig::from_fn_ptr_substs(&a_ty.parameters)),\n+                TypeCtor::FnDef(def) => {\n+                    let sig = db.callable_item_signature(def);\n+                    Some(sig.subst(&a_ty.parameters))\n+                }\n+                TypeCtor::Closure { .. } => {\n+                    let sig_param = &a_ty.parameters[0];\n+                    sig_param.callable_sig(db)\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    /// If this is a type with type parameters (an ADT or function), replaces\n+    /// the `Substs` for these type parameters with the given ones. (So e.g. if\n+    /// `self` is `Option<_>` and the substs contain `u32`, we'll have\n+    /// `Option<u32>` afterwards.)\n+    pub fn apply_substs(self, substs: Substs) -> Ty {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor, parameters: previous_substs }) => {\n+                assert_eq!(previous_substs.len(), substs.len());\n+                Ty::Apply(ApplicationTy { ctor, parameters: substs })\n+            }\n+            _ => self,\n+        }\n+    }\n+\n+    /// Returns the type parameters of this type if it has some (i.e. is an ADT\n+    /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n+    pub fn substs(&self) -> Option<Substs> {\n+        match self {\n+            Ty::Apply(ApplicationTy { parameters, .. }) => Some(parameters.clone()),\n+            _ => None,\n+        }\n+    }\n+\n+    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n+    pub fn inherent_trait(&self) -> Option<TraitId> {\n+        match self {\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                predicates.iter().find_map(|pred| match pred {\n+                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n+                    _ => None,\n+                })\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// This allows walking structures that contain types to do something with those\n+/// types, similar to Chalk's `Fold` trait.\n+pub trait TypeWalk {\n+    fn walk(&self, f: &mut impl FnMut(&Ty));\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.walk_mut_binders(&mut |ty, _binders| f(ty), 0);\n+    }\n+    /// Walk the type, counting entered binders.\n+    ///\n+    /// `Ty::Bound` variables use DeBruijn indexing, which means that 0 refers\n+    /// to the innermost binder, 1 to the next, etc.. So when we want to\n+    /// substitute a certain bound variable, we can't just walk the whole type\n+    /// and blindly replace each instance of a certain index; when we 'enter'\n+    /// things that introduce new bound variables, we have to keep track of\n+    /// that. Currently, the only thing that introduces bound variables on our\n+    /// side are `Ty::Dyn` and `Ty::Opaque`, which each introduce a bound\n+    /// variable for the self type.\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize);\n+\n+    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.walk_mut(&mut |ty_mut| {\n+            let ty = mem::replace(ty_mut, Ty::Unknown);\n+            *ty_mut = f(ty);\n+        });\n+        self\n+    }\n+\n+    /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n+    /// if `self` is `&[T]`, where type parameter T has index 0, and the\n+    /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)\n+    fn subst(self, substs: &Substs) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.fold(&mut |ty| match ty {\n+            Ty::Param { idx, name } => {\n+                substs.get(idx as usize).cloned().unwrap_or(Ty::Param { idx, name })\n+            }\n+            ty => ty,\n+        })\n+    }\n+\n+    /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n+    fn subst_bound_vars(mut self, substs: &Substs) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.walk_mut_binders(\n+            &mut |ty, binders| match ty {\n+                &mut Ty::Bound(idx) => {\n+                    if idx as usize >= binders && (idx as usize - binders) < substs.len() {\n+                        *ty = substs.0[idx as usize - binders].clone();\n+                    }\n+                }\n+                _ => {}\n+            },\n+            0,\n+        );\n+        self\n+    }\n+\n+    /// Shifts up `Ty::Bound` vars by `n`.\n+    fn shift_bound_vars(self, n: i32) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.fold(&mut |ty| match ty {\n+            Ty::Bound(idx) => {\n+                assert!(idx as i32 >= -n);\n+                Ty::Bound((idx as i32 + n) as u32)\n+            }\n+            ty => ty,\n+        })\n+    }\n+}\n+\n+impl TypeWalk for Ty {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match self {\n+            Ty::Apply(a_ty) => {\n+                for t in a_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::Projection(p_ty) => {\n+                for t in p_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                for p in predicates.iter() {\n+                    p.walk(f);\n+                }\n+            }\n+            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n+        }\n+        f(self);\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        match self {\n+            Ty::Apply(a_ty) => {\n+                a_ty.parameters.walk_mut_binders(f, binders);\n+            }\n+            Ty::Projection(p_ty) => {\n+                p_ty.parameters.walk_mut_binders(f, binders);\n+            }\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                for p in make_mut_slice(predicates) {\n+                    p.walk_mut_binders(f, binders + 1);\n+                }\n+            }\n+            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n+        }\n+        f(self, binders);\n+    }\n+}\n+\n+impl HirDisplay for &Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        HirDisplay::hir_fmt(*self, f)\n+    }\n+}\n+\n+impl HirDisplay for ApplicationTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n+        match self.ctor {\n+            TypeCtor::Bool => write!(f, \"bool\")?,\n+            TypeCtor::Char => write!(f, \"char\")?,\n+            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Str => write!(f, \"str\")?,\n+            TypeCtor::Slice => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"[{}]\", t.display(f.db))?;\n+            }\n+            TypeCtor::Array => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"[{};_]\", t.display(f.db))?;\n+            }\n+            TypeCtor::RawPtr(m) => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n+            }\n+            TypeCtor::Ref(m) => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"&{}{}\", m.as_keyword_for_ref(), t.display(f.db))?;\n+            }\n+            TypeCtor::Never => write!(f, \"!\")?,\n+            TypeCtor::Tuple { .. } => {\n+                let ts = &self.parameters;\n+                if ts.len() == 1 {\n+                    write!(f, \"({},)\", ts[0].display(f.db))?;\n+                } else {\n+                    write!(f, \"(\")?;\n+                    f.write_joined(&*ts.0, \", \")?;\n+                    write!(f, \")\")?;\n+                }\n+            }\n+            TypeCtor::FnPtr { .. } => {\n+                let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n+                write!(f, \"fn(\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n+            }\n+            TypeCtor::FnDef(def) => {\n+                let sig = f.db.callable_item_signature(def);\n+                let name = match def {\n+                    CallableDef::FunctionId(ff) => f.db.function_data(ff).name.clone(),\n+                    CallableDef::StructId(s) => f.db.struct_data(s).name.clone(),\n+                    CallableDef::EnumVariantId(e) => {\n+                        let enum_data = f.db.enum_data(e.parent);\n+                        enum_data.variants[e.local_id].name.clone()\n+                    }\n+                };\n+                match def {\n+                    CallableDef::FunctionId(_) => write!(f, \"fn {}\", name)?,\n+                    CallableDef::StructId(_) | CallableDef::EnumVariantId(_) => {\n+                        write!(f, \"{}\", name)?\n+                    }\n+                }\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+                write!(f, \"(\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n+            }\n+            TypeCtor::Adt(def_id) => {\n+                let name = match def_id {\n+                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n+                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n+                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n+                };\n+                write!(f, \"{}\", name)?;\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+            }\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let trait_ = match type_alias.lookup(f.db).container {\n+                    ContainerId::TraitId(it) => it,\n+                    _ => panic!(\"not an associated type\"),\n+                };\n+                let trait_name = f.db.trait_data(trait_).name.clone();\n+                let name = f.db.type_alias_data(type_alias).name.clone();\n+                write!(f, \"{}::{}\", trait_name, name)?;\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+            }\n+            TypeCtor::Closure { .. } => {\n+                let sig = self.parameters[0]\n+                    .callable_sig(f.db)\n+                    .expect(\"first closure parameter should contain signature\");\n+                write!(f, \"|\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \"| -> {}\", sig.ret().display(f.db))?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for ProjectionTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n+        let trait_name = f.db.trait_data(self.trait_(f.db)).name.clone();\n+        write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_name,)?;\n+        if self.parameters.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.parameters[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        write!(f, \">::{}\", f.db.type_alias_data(self.associated_ty).name)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n+        match self {\n+            Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n+            Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n+            Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n+            Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                match self {\n+                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n+                    Ty::Opaque(_) => write!(f, \"impl \")?,\n+                    _ => unreachable!(),\n+                };\n+                // Note: This code is written to produce nice results (i.e.\n+                // corresponding to surface Rust) for types that can occur in\n+                // actual Rust. It will have weird results if the predicates\n+                // aren't as expected (i.e. self types = $0, projection\n+                // predicates for a certain trait come after the Implemented\n+                // predicate for that trait).\n+                let mut first = true;\n+                let mut angle_open = false;\n+                for p in predicates.iter() {\n+                    match p {\n+                        GenericPredicate::Implemented(trait_ref) => {\n+                            if angle_open {\n+                                write!(f, \">\")?;\n+                            }\n+                            if !first {\n+                                write!(f, \" + \")?;\n+                            }\n+                            // We assume that the self type is $0 (i.e. the\n+                            // existential) here, which is the only thing that's\n+                            // possible in actual Rust, and hence don't print it\n+                            write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name.clone())?;\n+                            if trait_ref.substs.len() > 1 {\n+                                write!(f, \"<\")?;\n+                                f.write_joined(&trait_ref.substs[1..], \", \")?;\n+                                // there might be assoc type bindings, so we leave the angle brackets open\n+                                angle_open = true;\n+                            }\n+                        }\n+                        GenericPredicate::Projection(projection_pred) => {\n+                            // in types in actual Rust, these will always come\n+                            // after the corresponding Implemented predicate\n+                            if angle_open {\n+                                write!(f, \", \")?;\n+                            } else {\n+                                write!(f, \"<\")?;\n+                                angle_open = true;\n+                            }\n+                            let name =\n+                                f.db.type_alias_data(projection_pred.projection_ty.associated_ty)\n+                                    .name\n+                                    .clone();\n+                            write!(f, \"{} = \", name)?;\n+                            projection_pred.ty.hir_fmt(f)?;\n+                        }\n+                        GenericPredicate::Error => {\n+                            if angle_open {\n+                                // impl Trait<X, {error}>\n+                                write!(f, \", \")?;\n+                            } else if !first {\n+                                // impl Trait + {error}\n+                                write!(f, \" + \")?;\n+                            }\n+                            p.hir_fmt(f)?;\n+                        }\n+                    }\n+                    first = false;\n+                }\n+                if angle_open {\n+                    write!(f, \">\")?;\n+                }\n+            }\n+            Ty::Unknown => write!(f, \"{{unknown}}\")?,\n+            Ty::Infer(..) => write!(f, \"_\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl TraitRef {\n+    fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n+        self.substs[0].hir_fmt(f)?;\n+        if use_as {\n+            write!(f, \" as \")?;\n+        } else {\n+            write!(f, \": \")?;\n+        }\n+        write!(f, \"{}\", f.db.trait_data(self.trait_).name.clone())?;\n+        if self.substs.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.substs[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for TraitRef {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        self.hir_fmt_ext(f, false)\n+    }\n+}\n+\n+impl HirDisplay for &GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        HirDisplay::hir_fmt(*self, f)\n+    }\n+}\n+\n+impl HirDisplay for GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n+            GenericPredicate::Projection(projection_pred) => {\n+                write!(f, \"<\")?;\n+                projection_pred.projection_ty.trait_ref(f.db).hir_fmt_ext(f, true)?;\n+                write!(\n+                    f,\n+                    \">::{} = {}\",\n+                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name,\n+                    projection_pred.ty.display(f.db)\n+                )?;\n+            }\n+            GenericPredicate::Error => write!(f, \"{{error}}\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Obligation {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        match self {\n+            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n+            Obligation::Projection(proj) => write!(\n+                f,\n+                \"Normalize({} => {})\",\n+                proj.projection_ty.display(f.db),\n+                proj.ty.display(f.db)\n+            ),\n+        }\n+    }\n+}"}, {"sha": "091c60f4fef783f310a9bfc890c65f1ec827b5a5", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "renamed", "additions": 186, "deletions": 258, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -9,43 +9,30 @@ use std::iter;\n use std::sync::Arc;\n \n use hir_def::{\n-    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType},\n+    builtin_type::BuiltinType,\n     generics::WherePredicate,\n-    path::{GenericArg, PathSegment},\n+    path::{GenericArg, Path, PathKind, PathSegment},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, GenericDefId, LocalStructFieldId, VariantId,\n+    AdtId, AstItemDef, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId,\n+    LocalStructFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n+use ra_db::CrateId;\n \n-use super::{\n-    FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n-    TypeWalk,\n-};\n use crate::{\n     db::HirDatabase,\n-    ty::{\n-        primitive::{FloatTy, IntTy, Uncertain},\n-        Adt,\n+    primitive::{FloatTy, IntTy},\n+    utils::{\n+        all_super_traits, associated_type_by_name_including_super_traits, make_mut_slice,\n+        variant_data,\n     },\n-    util::make_mut_slice,\n-    Const, Enum, EnumVariant, Function, GenericDef, ImplBlock, ModuleDef, Path, Static, Struct,\n-    Trait, TypeAlias, Union,\n+    FnSig, GenericPredicate, ImplTy, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment,\n+    TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n-// FIXME: this is only really used in `type_for_def`, which contains a bunch of\n-// impossible cases. Perhaps we should recombine `TypeableDef` and `Namespace`\n-// into a `AsTypeDef`, `AsValueDef` enums?\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub enum Namespace {\n-    Types,\n-    Values,\n-    // Note that only type inference uses this enum, and it doesn't care about macros.\n-    // Macro,\n-}\n-\n impl Ty {\n-    pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n+    pub fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n         match type_ref {\n             TypeRef::Never => Ty::simple(TypeCtor::Never),\n             TypeRef::Tuple(inner) => {\n@@ -114,7 +101,7 @@ impl Ty {\n             TypeRef::Path(path) => path,\n             _ => return None,\n         };\n-        if let crate::PathKind::Type(_) = &path.kind {\n+        if let PathKind::Type(_) = &path.kind {\n             return None;\n         }\n         if path.segments.len() > 1 {\n@@ -158,19 +145,16 @@ impl Ty {\n     ) -> Ty {\n         let ty = match resolution {\n             TypeNs::TraitId(trait_) => {\n-                let trait_ref = TraitRef::from_resolved_path(\n-                    db,\n-                    resolver,\n-                    trait_.into(),\n-                    resolved_segment,\n-                    None,\n-                );\n+                let trait_ref =\n+                    TraitRef::from_resolved_path(db, resolver, trait_, resolved_segment, None);\n                 return if remaining_segments.len() == 1 {\n                     let segment = &remaining_segments[0];\n-                    match trait_ref\n-                        .trait_\n-                        .associated_type_by_name_including_super_traits(db, &segment.name)\n-                    {\n+                    let associated_ty = associated_type_by_name_including_super_traits(\n+                        db,\n+                        trait_ref.trait_,\n+                        &segment.name,\n+                    );\n+                    match associated_ty {\n                         Some(associated_ty) => {\n                             // FIXME handle type parameters on the segment\n                             Ty::Projection(ProjectionTy {\n@@ -195,8 +179,8 @@ impl Ty {\n                 let name = resolved_segment.name.clone();\n                 Ty::Param { idx, name }\n             }\n-            TypeNs::SelfType(impl_block) => ImplBlock::from(impl_block).target_ty(db),\n-            TypeNs::AdtSelfType(adt) => Adt::from(adt).ty(db),\n+            TypeNs::SelfType(impl_id) => db.impl_ty(impl_id).self_type().clone(),\n+            TypeNs::AdtSelfType(adt) => db.ty(adt.into()),\n \n             TypeNs::AdtId(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n             TypeNs::BuiltinType(it) => {\n@@ -214,7 +198,7 @@ impl Ty {\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n         // Resolve the path (in type namespace)\n-        if let crate::PathKind::Type(type_ref) = &path.kind {\n+        if let PathKind::Type(type_ref) = &path.kind {\n             let ty = Ty::from_hir(db, resolver, &type_ref);\n             let remaining_segments = &path.segments[..];\n             return Ty::from_type_relative_path(db, resolver, ty, remaining_segments);\n@@ -258,9 +242,9 @@ impl Ty {\n             GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n             _ => None,\n         });\n-        let traits = traits_from_env.flat_map(|t| t.all_super_traits(db));\n+        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t));\n         for t in traits {\n-            if let Some(associated_ty) = t.associated_type_by_name(db, &segment.name) {\n+            if let Some(associated_ty) = db.trait_data(t).associated_type_by_name(&segment.name) {\n                 let substs =\n                     Substs::build_for_def(db, t).push(self_ty.clone()).fill_with_unknown().build();\n                 // FIXME handle type parameters on the segment\n@@ -274,27 +258,15 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         segment: &PathSegment,\n-        typable: TypableDef,\n+        typable: TyDefId,\n     ) -> Ty {\n-        let ty = db.type_for_def(typable, Namespace::Types);\n-        let substs = Ty::substs_from_path_segment(db, resolver, segment, typable);\n-        ty.subst(&substs)\n-    }\n-\n-    pub(super) fn substs_from_path_segment(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        segment: &PathSegment,\n-        resolved: TypableDef,\n-    ) -> Substs {\n-        let def_generic: Option<GenericDef> = match resolved {\n-            TypableDef::Function(func) => Some(func.into()),\n-            TypableDef::Adt(adt) => Some(adt.into()),\n-            TypableDef::EnumVariant(var) => Some(var.parent_enum(db).into()),\n-            TypableDef::TypeAlias(t) => Some(t.into()),\n-            TypableDef::Const(_) | TypableDef::Static(_) | TypableDef::BuiltinType(_) => None,\n+        let generic_def = match typable {\n+            TyDefId::BuiltinType(_) => None,\n+            TyDefId::AdtId(it) => Some(it.into()),\n+            TyDefId::TypeAliasId(it) => Some(it.into()),\n         };\n-        substs_from_path_segment(db, resolver, segment, def_generic, false)\n+        let substs = substs_from_path_segment(db, resolver, segment, generic_def, false);\n+        db.ty(typable).subst(&substs)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n@@ -303,17 +275,18 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         path: &Path,\n-        resolved: TypableDef,\n+        // Note that we don't call `db.value_type(resolved)` here,\n+        // `ValueTyDefId` is just a convenient way to pass generics and\n+        // special-case enum variants\n+        resolved: ValueTyDefId,\n     ) -> Substs {\n         let last = path.segments.last().expect(\"path should have at least one segment\");\n-        let segment = match resolved {\n-            TypableDef::Function(_)\n-            | TypableDef::Adt(_)\n-            | TypableDef::Const(_)\n-            | TypableDef::Static(_)\n-            | TypableDef::TypeAlias(_)\n-            | TypableDef::BuiltinType(_) => last,\n-            TypableDef::EnumVariant(_) => {\n+        let (segment, generic_def) = match resolved {\n+            ValueTyDefId::FunctionId(it) => (last, Some(it.into())),\n+            ValueTyDefId::StructId(it) => (last, Some(it.into())),\n+            ValueTyDefId::ConstId(it) => (last, Some(it.into())),\n+            ValueTyDefId::StaticId(_) => (last, None),\n+            ValueTyDefId::EnumVariantId(var) => {\n                 // the generic args for an enum variant may be either specified\n                 // on the segment referring to the enum, or on the segment\n                 // referring to the variant. So `Option::<T>::None` and\n@@ -327,18 +300,18 @@ impl Ty {\n                     // Option::None::<T>\n                     last\n                 };\n-                segment\n+                (segment, Some(var.parent.into()))\n             }\n         };\n-        Ty::substs_from_path_segment(db, resolver, segment, resolved)\n+        substs_from_path_segment(db, resolver, segment, generic_def, false)\n     }\n }\n \n pub(super) fn substs_from_path_segment(\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     segment: &PathSegment,\n-    def_generic: Option<GenericDef>,\n+    def_generic: Option<GenericDefId>,\n     add_self_param: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n@@ -376,7 +349,7 @@ pub(super) fn substs_from_path_segment(\n \n     // handle defaults\n     if let Some(def_generic) = def_generic {\n-        let default_substs = db.generic_defaults(def_generic);\n+        let default_substs = db.generic_defaults(def_generic.into());\n         assert_eq!(substs.len(), default_substs.len());\n \n         for (i, default_ty) in default_substs.iter().enumerate() {\n@@ -390,7 +363,7 @@ pub(super) fn substs_from_path_segment(\n }\n \n impl TraitRef {\n-    pub(crate) fn from_path(\n+    fn from_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         path: &Path,\n@@ -404,10 +377,10 @@ impl TraitRef {\n         Some(TraitRef::from_resolved_path(db, resolver, resolved.into(), segment, explicit_self_ty))\n     }\n \n-    pub(super) fn from_resolved_path(\n+    pub(crate) fn from_resolved_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        resolved: Trait,\n+        resolved: TraitId,\n         segment: &PathSegment,\n         explicit_self_ty: Option<Ty>,\n     ) -> Self {\n@@ -418,7 +391,7 @@ impl TraitRef {\n         TraitRef { trait_: resolved, substs }\n     }\n \n-    pub(crate) fn from_hir(\n+    fn from_hir(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         type_ref: &TypeRef,\n@@ -435,18 +408,13 @@ impl TraitRef {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         segment: &PathSegment,\n-        resolved: Trait,\n+        resolved: TraitId,\n     ) -> Substs {\n         let has_self_param =\n             segment.args_and_bindings.as_ref().map(|a| a.has_self_type).unwrap_or(false);\n         substs_from_path_segment(db, resolver, segment, Some(resolved.into()), !has_self_param)\n     }\n \n-    pub(crate) fn for_trait(db: &impl HirDatabase, trait_: Trait) -> TraitRef {\n-        let substs = Substs::identity(&db.generic_params(trait_.id.into()));\n-        TraitRef { trait_, substs }\n-    }\n-\n     pub(crate) fn from_type_bound(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n@@ -502,10 +470,11 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n         .map(move |(name, type_ref)| {\n             let associated_ty =\n-                match trait_ref.trait_.associated_type_by_name_including_super_traits(db, &name) {\n-                    None => return GenericPredicate::Error,\n-                    Some(t) => t,\n-                };\n+                associated_type_by_name_including_super_traits(db, trait_ref.trait_, &name);\n+            let associated_ty = match associated_ty {\n+                None => return GenericPredicate::Error,\n+                Some(t) => t,\n+            };\n             let projection_ty =\n                 ProjectionTy { associated_ty, parameters: trait_ref.substs.clone() };\n             let ty = Ty::from_hir(db, resolver, type_ref);\n@@ -514,39 +483,12 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         })\n }\n \n-/// Build the declared type of an item. This depends on the namespace; e.g. for\n-/// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n-/// the constructor function `(usize) -> Foo` which lives in the values\n-/// namespace.\n-pub(crate) fn type_for_def(db: &impl HirDatabase, def: TypableDef, ns: Namespace) -> Ty {\n-    match (def, ns) {\n-        (TypableDef::Function(f), Namespace::Values) => type_for_fn(db, f),\n-        (TypableDef::Adt(Adt::Struct(s)), Namespace::Values) => type_for_struct_constructor(db, s),\n-        (TypableDef::Adt(adt), Namespace::Types) => type_for_adt(db, adt),\n-        (TypableDef::EnumVariant(v), Namespace::Values) => type_for_enum_variant_constructor(db, v),\n-        (TypableDef::TypeAlias(t), Namespace::Types) => type_for_type_alias(db, t),\n-        (TypableDef::Const(c), Namespace::Values) => type_for_const(db, c),\n-        (TypableDef::Static(c), Namespace::Values) => type_for_static(db, c),\n-        (TypableDef::BuiltinType(t), Namespace::Types) => type_for_builtin(t),\n-\n-        // 'error' cases:\n-        (TypableDef::Function(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::Adt(Adt::Union(_)), Namespace::Values) => Ty::Unknown,\n-        (TypableDef::Adt(Adt::Enum(_)), Namespace::Values) => Ty::Unknown,\n-        (TypableDef::EnumVariant(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::TypeAlias(_), Namespace::Values) => Ty::Unknown,\n-        (TypableDef::Const(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::Static(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::BuiltinType(_), Namespace::Values) => Ty::Unknown,\n-    }\n-}\n-\n /// Build the signature of a callable item (function, struct or enum variant).\n-pub(crate) fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSig {\n+pub fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSig {\n     match def {\n-        CallableDef::Function(f) => fn_sig_for_fn(db, f),\n-        CallableDef::Struct(s) => fn_sig_for_struct_constructor(db, s),\n-        CallableDef::EnumVariant(e) => fn_sig_for_enum_variant_constructor(db, e),\n+        CallableDef::FunctionId(f) => fn_sig_for_fn(db, f),\n+        CallableDef::StructId(s) => fn_sig_for_struct_constructor(db, s),\n+        CallableDef::EnumVariantId(e) => fn_sig_for_enum_variant_constructor(db, e),\n     }\n }\n \n@@ -555,12 +497,11 @@ pub(crate) fn field_types_query(\n     db: &impl HirDatabase,\n     variant_id: VariantId,\n ) -> Arc<ArenaMap<LocalStructFieldId, Ty>> {\n-    let (resolver, var_data) = match variant_id {\n-        VariantId::StructId(it) => (it.resolver(db), db.struct_data(it.0).variant_data.clone()),\n-        VariantId::EnumVariantId(it) => (\n-            it.parent.resolver(db),\n-            db.enum_data(it.parent).variants[it.local_id].variant_data.clone(),\n-        ),\n+    let var_data = variant_data(db, variant_id);\n+    let resolver = match variant_id {\n+        VariantId::StructId(it) => it.resolver(db),\n+        VariantId::UnionId(it) => it.resolver(db),\n+        VariantId::EnumVariantId(it) => it.parent.resolver(db),\n     };\n     let mut res = ArenaMap::default();\n     for (field_id, field_data) in var_data.fields().iter() {\n@@ -579,10 +520,10 @@ pub(crate) fn field_types_query(\n /// these are fine: `T: Foo<U::Item>, U: Foo<()>`.\n pub(crate) fn generic_predicates_for_param_query(\n     db: &impl HirDatabase,\n-    def: GenericDef,\n+    def: GenericDefId,\n     param_idx: u32,\n ) -> Arc<[GenericPredicate]> {\n-    let resolver = GenericDefId::from(def).resolver(db);\n+    let resolver = def.resolver(db);\n     resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n@@ -591,33 +532,32 @@ pub(crate) fn generic_predicates_for_param_query(\n         .collect()\n }\n \n-pub(crate) fn trait_env(\n-    db: &impl HirDatabase,\n-    resolver: &Resolver,\n-) -> Arc<super::TraitEnvironment> {\n-    let predicates = resolver\n-        .where_predicates_in_scope()\n-        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n-        .collect::<Vec<_>>();\n+impl TraitEnvironment {\n+    pub fn lower(db: &impl HirDatabase, resolver: &Resolver) -> Arc<TraitEnvironment> {\n+        let predicates = resolver\n+            .where_predicates_in_scope()\n+            .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+            .collect::<Vec<_>>();\n \n-    Arc::new(super::TraitEnvironment { predicates })\n+        Arc::new(TraitEnvironment { predicates })\n+    }\n }\n \n /// Resolve the where clause(s) of an item with generics.\n pub(crate) fn generic_predicates_query(\n     db: &impl HirDatabase,\n-    def: GenericDef,\n+    def: GenericDefId,\n ) -> Arc<[GenericPredicate]> {\n-    let resolver = GenericDefId::from(def).resolver(db);\n+    let resolver = def.resolver(db);\n     resolver\n         .where_predicates_in_scope()\n         .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n         .collect()\n }\n \n /// Resolve the default type params from generics\n-pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDef) -> Substs {\n-    let resolver = GenericDefId::from(def).resolver(db);\n+pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDefId) -> Substs {\n+    let resolver = def.resolver(db);\n     let generic_params = db.generic_params(def.into());\n \n     let defaults = generic_params\n@@ -629,34 +569,34 @@ pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDef) ->\n     Substs(defaults)\n }\n \n-fn fn_sig_for_fn(db: &impl HirDatabase, def: Function) -> FnSig {\n-    let data = db.function_data(def.id);\n-    let resolver = def.id.resolver(db);\n+fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> FnSig {\n+    let data = db.function_data(def);\n+    let resolver = def.resolver(db);\n     let params = data.params.iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n     let ret = Ty::from_hir(db, &resolver, &data.ret_type);\n     FnSig::from_params_and_return(params, ret)\n }\n \n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n-fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n-    let generics = db.generic_params(def.id.into());\n+fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Ty {\n+    let generics = db.generic_params(def.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n /// Build the declared type of a const.\n-fn type_for_const(db: &impl HirDatabase, def: Const) -> Ty {\n-    let data = db.const_data(def.id);\n-    let resolver = def.id.resolver(db);\n+fn type_for_const(db: &impl HirDatabase, def: ConstId) -> Ty {\n+    let data = db.const_data(def);\n+    let resolver = def.resolver(db);\n \n     Ty::from_hir(db, &resolver, &data.type_ref)\n }\n \n /// Build the declared type of a static.\n-fn type_for_static(db: &impl HirDatabase, def: Static) -> Ty {\n-    let data = db.static_data(def.id);\n-    let resolver = def.id.resolver(db);\n+fn type_for_static(db: &impl HirDatabase, def: StaticId) -> Ty {\n+    let data = db.static_data(def);\n+    let resolver = def.resolver(db);\n \n     Ty::from_hir(db, &resolver, &data.type_ref)\n }\n@@ -672,160 +612,148 @@ fn type_for_builtin(def: BuiltinType) -> Ty {\n     })\n }\n \n-impl From<BuiltinInt> for IntTy {\n-    fn from(t: BuiltinInt) -> Self {\n-        IntTy { signedness: t.signedness, bitness: t.bitness }\n-    }\n-}\n-\n-impl From<BuiltinFloat> for FloatTy {\n-    fn from(t: BuiltinFloat) -> Self {\n-        FloatTy { bitness: t.bitness }\n-    }\n-}\n-\n-impl From<Option<BuiltinInt>> for Uncertain<IntTy> {\n-    fn from(t: Option<BuiltinInt>) -> Self {\n-        match t {\n-            None => Uncertain::Unknown,\n-            Some(t) => Uncertain::Known(t.into()),\n-        }\n-    }\n-}\n-\n-impl From<Option<BuiltinFloat>> for Uncertain<FloatTy> {\n-    fn from(t: Option<BuiltinFloat>) -> Self {\n-        match t {\n-            None => Uncertain::Unknown,\n-            Some(t) => Uncertain::Known(t.into()),\n-        }\n-    }\n-}\n-\n-fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> FnSig {\n-    let struct_data = db.struct_data(def.id.into());\n+fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> FnSig {\n+    let struct_data = db.struct_data(def.into());\n     let fields = struct_data.variant_data.fields();\n-    let resolver = def.id.resolver(db);\n+    let resolver = def.resolver(db);\n     let params = fields\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n-    let ret = type_for_adt(db, def);\n+    let ret = type_for_adt(db, def.into());\n     FnSig::from_params_and_return(params, ret)\n }\n \n /// Build the type of a tuple struct constructor.\n-fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n-    let struct_data = db.struct_data(def.id.into());\n+fn type_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> Ty {\n+    let struct_data = db.struct_data(def.into());\n     if struct_data.variant_data.is_unit() {\n-        return type_for_adt(db, def); // Unit struct\n+        return type_for_adt(db, def.into()); // Unit struct\n     }\n-    let generics = db.generic_params(def.id.into());\n+    let generics = db.generic_params(def.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n \n-fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) -> FnSig {\n-    let var_data = def.variant_data(db);\n-    let fields = var_data.fields();\n-    let resolver = def.parent.id.resolver(db);\n+fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> FnSig {\n+    let enum_data = db.enum_data(def.parent);\n+    let var_data = &enum_data.variants[def.local_id];\n+    let fields = var_data.variant_data.fields();\n+    let resolver = def.parent.resolver(db);\n     let params = fields\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n-    let generics = db.generic_params(def.parent_enum(db).id.into());\n+    let generics = db.generic_params(def.parent.into());\n     let substs = Substs::identity(&generics);\n-    let ret = type_for_adt(db, def.parent_enum(db)).subst(&substs);\n+    let ret = type_for_adt(db, def.parent.into()).subst(&substs);\n     FnSig::from_params_and_return(params, ret)\n }\n \n /// Build the type of a tuple enum variant constructor.\n-fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) -> Ty {\n-    let var_data = def.variant_data(db);\n+fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> Ty {\n+    let enum_data = db.enum_data(def.parent);\n+    let var_data = &enum_data.variants[def.local_id].variant_data;\n     if var_data.is_unit() {\n-        return type_for_adt(db, def.parent_enum(db)); // Unit variant\n+        return type_for_adt(db, def.parent.into()); // Unit variant\n     }\n-    let generics = db.generic_params(def.parent_enum(db).id.into());\n+    let generics = db.generic_params(def.parent.into());\n     let substs = Substs::identity(&generics);\n-    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n+    Ty::apply(TypeCtor::FnDef(EnumVariantId::from(def).into()), substs)\n }\n \n-fn type_for_adt(db: &impl HirDatabase, adt: impl Into<Adt>) -> Ty {\n-    let adt = adt.into();\n-    let adt_id: AdtId = adt.into();\n-    let generics = db.generic_params(adt_id.into());\n+fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Ty {\n+    let generics = db.generic_params(adt.into());\n     Ty::apply(TypeCtor::Adt(adt), Substs::identity(&generics))\n }\n \n-fn type_for_type_alias(db: &impl HirDatabase, t: TypeAlias) -> Ty {\n-    let generics = db.generic_params(t.id.into());\n-    let resolver = t.id.resolver(db);\n-    let type_ref = t.type_ref(db);\n+fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Ty {\n+    let generics = db.generic_params(t.into());\n+    let resolver = t.resolver(db);\n+    let type_ref = &db.type_alias_data(t).type_ref;\n     let substs = Substs::identity(&generics);\n-    let inner = Ty::from_hir(db, &resolver, &type_ref.unwrap_or(TypeRef::Error));\n+    let inner = Ty::from_hir(db, &resolver, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n     inner.subst(&substs)\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum TypableDef {\n-    Function(Function),\n-    Adt(Adt),\n-    EnumVariant(EnumVariant),\n-    TypeAlias(TypeAlias),\n-    Const(Const),\n-    Static(Static),\n-    BuiltinType(BuiltinType),\n-}\n-impl_froms!(\n-    TypableDef: Function,\n-    Adt(Struct, Enum, Union),\n-    EnumVariant,\n-    TypeAlias,\n-    Const,\n-    Static,\n-    BuiltinType\n-);\n-\n-impl From<ModuleDef> for Option<TypableDef> {\n-    fn from(def: ModuleDef) -> Option<TypableDef> {\n-        let res = match def {\n-            ModuleDef::Function(f) => f.into(),\n-            ModuleDef::Adt(adt) => adt.into(),\n-            ModuleDef::EnumVariant(v) => v.into(),\n-            ModuleDef::TypeAlias(t) => t.into(),\n-            ModuleDef::Const(v) => v.into(),\n-            ModuleDef::Static(v) => v.into(),\n-            ModuleDef::BuiltinType(t) => t.into(),\n-            ModuleDef::Module(_) | ModuleDef::Trait(_) => return None,\n-        };\n-        Some(res)\n-    }\n-}\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum CallableDef {\n-    Function(Function),\n-    Struct(Struct),\n-    EnumVariant(EnumVariant),\n+    FunctionId(FunctionId),\n+    StructId(StructId),\n+    EnumVariantId(EnumVariantId),\n }\n-impl_froms!(CallableDef: Function, Struct, EnumVariant);\n+impl_froms!(CallableDef: FunctionId, StructId, EnumVariantId);\n \n impl CallableDef {\n-    pub fn krate(self, db: &impl HirDatabase) -> Option<crate::Crate> {\n+    pub fn krate(self, db: &impl HirDatabase) -> CrateId {\n         match self {\n-            CallableDef::Function(f) => f.krate(db),\n-            CallableDef::Struct(s) => s.krate(db),\n-            CallableDef::EnumVariant(e) => e.parent_enum(db).krate(db),\n+            CallableDef::FunctionId(f) => f.lookup(db).module(db).krate,\n+            CallableDef::StructId(s) => s.module(db).krate,\n+            CallableDef::EnumVariantId(e) => e.parent.module(db).krate,\n         }\n     }\n }\n \n-impl From<CallableDef> for GenericDef {\n-    fn from(def: CallableDef) -> GenericDef {\n+impl From<CallableDef> for GenericDefId {\n+    fn from(def: CallableDef) -> GenericDefId {\n         match def {\n-            CallableDef::Function(f) => f.into(),\n-            CallableDef::Struct(s) => s.into(),\n-            CallableDef::EnumVariant(e) => e.into(),\n+            CallableDef::FunctionId(f) => f.into(),\n+            CallableDef::StructId(s) => s.into(),\n+            CallableDef::EnumVariantId(e) => e.into(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum TyDefId {\n+    BuiltinType(BuiltinType),\n+    AdtId(AdtId),\n+    TypeAliasId(TypeAliasId),\n+}\n+impl_froms!(TyDefId: BuiltinType, AdtId(StructId, EnumId, UnionId), TypeAliasId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum ValueTyDefId {\n+    FunctionId(FunctionId),\n+    StructId(StructId),\n+    EnumVariantId(EnumVariantId),\n+    ConstId(ConstId),\n+    StaticId(StaticId),\n+}\n+impl_froms!(ValueTyDefId: FunctionId, StructId, EnumVariantId, ConstId, StaticId);\n+\n+/// Build the declared type of an item. This depends on the namespace; e.g. for\n+/// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n+/// the constructor function `(usize) -> Foo` which lives in the values\n+/// namespace.\n+pub(crate) fn ty_query(db: &impl HirDatabase, def: TyDefId) -> Ty {\n+    match def {\n+        TyDefId::BuiltinType(it) => type_for_builtin(it),\n+        TyDefId::AdtId(it) => type_for_adt(db, it),\n+        TyDefId::TypeAliasId(it) => type_for_type_alias(db, it),\n+    }\n+}\n+pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Ty {\n+    match def {\n+        ValueTyDefId::FunctionId(it) => type_for_fn(db, it),\n+        ValueTyDefId::StructId(it) => type_for_struct_constructor(db, it),\n+        ValueTyDefId::EnumVariantId(it) => type_for_enum_variant_constructor(db, it),\n+        ValueTyDefId::ConstId(it) => type_for_const(db, it),\n+        ValueTyDefId::StaticId(it) => type_for_static(db, it),\n+    }\n+}\n+\n+pub(crate) fn impl_ty_query(db: &impl HirDatabase, impl_id: ImplId) -> ImplTy {\n+    let impl_data = db.impl_data(impl_id);\n+    let resolver = impl_id.resolver(db);\n+    let self_ty = Ty::from_hir(db, &resolver, &impl_data.target_type);\n+    match impl_data.target_trait.as_ref() {\n+        Some(trait_ref) => {\n+            match TraitRef::from_hir(db, &resolver, trait_ref, Some(self_ty.clone())) {\n+                Some(it) => ImplTy::TraitRef(it),\n+                None => ImplTy::Inherent(self_ty),\n+            }\n         }\n+        None => ImplTy::Inherent(self_ty),\n     }\n }", "previous_filename": "crates/ra_hir/src/ty/lower.rs"}, {"sha": "0f754eb9c75515c3ed8767723127102802a6da16", "filename": "crates/ra_hir_ty/src/marks.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_hir/src/marks.rs"}, {"sha": "ee1936b0e5410d8e02c217b269eabe42cfaaaebd", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "renamed", "additions": 112, "deletions": 134, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -5,18 +5,23 @@\n use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n-use hir_def::{lang_item::LangItemTarget, resolver::Resolver, AstItemDef};\n+use hir_def::{\n+    lang_item::LangItemTarget, resolver::Resolver, type_ref::Mutability, AssocItemId, AstItemDef,\n+    FunctionId, HasModule, ImplId, TraitId,\n+};\n+use hir_expand::name::Name;\n+use ra_db::CrateId;\n+use ra_prof::profile;\n use rustc_hash::FxHashMap;\n \n use crate::{\n+    autoderef,\n     db::HirDatabase,\n-    ty::primitive::{FloatBitness, Uncertain},\n-    ty::{Ty, TypeCtor},\n-    AssocItem, Crate, Function, ImplBlock, Module, Mutability, Name, Trait,\n+    primitive::{FloatBitness, Uncertain},\n+    utils::all_super_traits,\n+    Canonical, ImplTy, InEnvironment, TraitEnvironment, TraitRef, Ty, TypeCtor,\n };\n \n-use super::{autoderef, lower, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n-\n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum TyFingerprint {\n@@ -37,110 +42,112 @@ impl TyFingerprint {\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct CrateImplBlocks {\n-    impls: FxHashMap<TyFingerprint, Vec<ImplBlock>>,\n-    impls_by_trait: FxHashMap<Trait, Vec<ImplBlock>>,\n+    impls: FxHashMap<TyFingerprint, Vec<ImplId>>,\n+    impls_by_trait: FxHashMap<TraitId, Vec<ImplId>>,\n }\n \n impl CrateImplBlocks {\n     pub(crate) fn impls_in_crate_query(\n         db: &impl HirDatabase,\n-        krate: Crate,\n+        krate: CrateId,\n     ) -> Arc<CrateImplBlocks> {\n-        let mut crate_impl_blocks =\n+        let _p = profile(\"impls_in_crate_query\");\n+        let mut res =\n             CrateImplBlocks { impls: FxHashMap::default(), impls_by_trait: FxHashMap::default() };\n-        if let Some(module) = krate.root_module(db) {\n-            crate_impl_blocks.collect_recursive(db, module);\n+\n+        let crate_def_map = db.crate_def_map(krate);\n+        for (_module_id, module_data) in crate_def_map.modules.iter() {\n+            for &impl_id in module_data.impls.iter() {\n+                match db.impl_ty(impl_id) {\n+                    ImplTy::TraitRef(tr) => {\n+                        res.impls_by_trait.entry(tr.trait_).or_default().push(impl_id);\n+                    }\n+                    ImplTy::Inherent(self_ty) => {\n+                        if let Some(self_ty_fp) = TyFingerprint::for_impl(&self_ty) {\n+                            res.impls.entry(self_ty_fp).or_default().push(impl_id);\n+                        }\n+                    }\n+                }\n+            }\n         }\n-        Arc::new(crate_impl_blocks)\n+\n+        Arc::new(res)\n     }\n-    pub fn lookup_impl_blocks(&self, ty: &Ty) -> impl Iterator<Item = ImplBlock> + '_ {\n+    pub fn lookup_impl_blocks(&self, ty: &Ty) -> impl Iterator<Item = ImplId> + '_ {\n         let fingerprint = TyFingerprint::for_impl(ty);\n         fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flatten().copied()\n     }\n \n-    pub fn lookup_impl_blocks_for_trait(&self, tr: Trait) -> impl Iterator<Item = ImplBlock> + '_ {\n+    pub fn lookup_impl_blocks_for_trait(&self, tr: TraitId) -> impl Iterator<Item = ImplId> + '_ {\n         self.impls_by_trait.get(&tr).into_iter().flatten().copied()\n     }\n \n-    pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplBlock> + 'a {\n+    pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplId> + 'a {\n         self.impls.values().chain(self.impls_by_trait.values()).flatten().copied()\n     }\n-\n-    fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) {\n-        for impl_block in module.impl_blocks(db) {\n-            let target_ty = impl_block.target_ty(db);\n-\n-            if impl_block.target_trait(db).is_some() {\n-                if let Some(tr) = impl_block.target_trait_ref(db) {\n-                    self.impls_by_trait.entry(tr.trait_).or_default().push(impl_block);\n-                }\n-            } else {\n-                if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n-                    self.impls.entry(target_ty_fp).or_default().push(impl_block);\n-                }\n-            }\n-        }\n-\n-        for child in module.children(db) {\n-            self.collect_recursive(db, child);\n-        }\n-    }\n }\n \n-fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayVec<[Crate; 2]>> {\n-    // Types like slice can have inherent impls in several crates, (core and alloc).\n-    // The corresponding impls are marked with lang items, so we can use them to find the required crates.\n-    macro_rules! lang_item_crate {\n+impl Ty {\n+    pub fn def_crates(\n+        &self,\n+        db: &impl HirDatabase,\n+        cur_crate: CrateId,\n+    ) -> Option<ArrayVec<[CrateId; 2]>> {\n+        // Types like slice can have inherent impls in several crates, (core and alloc).\n+        // The corresponding impls are marked with lang items, so we can use them to find the required crates.\n+        macro_rules! lang_item_crate {\n         ($($name:expr),+ $(,)?) => {{\n             let mut v = ArrayVec::<[LangItemTarget; 2]>::new();\n             $(\n-                v.extend(db.lang_item(cur_crate.crate_id, $name.into()));\n+                v.extend(db.lang_item(cur_crate, $name.into()));\n             )+\n             v\n         }};\n     }\n \n-    let lang_item_targets = match ty {\n-        Ty::Apply(a_ty) => match a_ty.ctor {\n-            TypeCtor::Adt(def_id) => return Some(std::iter::once(def_id.krate(db)?).collect()),\n-            TypeCtor::Bool => lang_item_crate!(\"bool\"),\n-            TypeCtor::Char => lang_item_crate!(\"char\"),\n-            TypeCtor::Float(Uncertain::Known(f)) => match f.bitness {\n-                // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n-                FloatBitness::X32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n-                FloatBitness::X64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n+        let lang_item_targets = match self {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::Adt(def_id) => {\n+                    return Some(std::iter::once(def_id.module(db).krate).collect())\n+                }\n+                TypeCtor::Bool => lang_item_crate!(\"bool\"),\n+                TypeCtor::Char => lang_item_crate!(\"char\"),\n+                TypeCtor::Float(Uncertain::Known(f)) => match f.bitness {\n+                    // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n+                    FloatBitness::X32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n+                    FloatBitness::X64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n+                },\n+                TypeCtor::Int(Uncertain::Known(i)) => lang_item_crate!(i.ty_to_string()),\n+                TypeCtor::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n+                TypeCtor::Slice => lang_item_crate!(\"slice_alloc\", \"slice\"),\n+                TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(\"const_ptr\"),\n+                TypeCtor::RawPtr(Mutability::Mut) => lang_item_crate!(\"mut_ptr\"),\n+                _ => return None,\n             },\n-            TypeCtor::Int(Uncertain::Known(i)) => lang_item_crate!(i.ty_to_string()),\n-            TypeCtor::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n-            TypeCtor::Slice => lang_item_crate!(\"slice_alloc\", \"slice\"),\n-            TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(\"const_ptr\"),\n-            TypeCtor::RawPtr(Mutability::Mut) => lang_item_crate!(\"mut_ptr\"),\n             _ => return None,\n-        },\n-        _ => return None,\n-    };\n-    let res = lang_item_targets\n-        .into_iter()\n-        .filter_map(|it| match it {\n-            LangItemTarget::ImplBlockId(it) => Some(it),\n-            _ => None,\n-        })\n-        .map(|it| it.module(db).krate.into())\n-        .collect();\n-    Some(res)\n+        };\n+        let res = lang_item_targets\n+            .into_iter()\n+            .filter_map(|it| match it {\n+                LangItemTarget::ImplBlockId(it) => Some(it),\n+                _ => None,\n+            })\n+            .map(|it| it.module(db).krate)\n+            .collect();\n+        Some(res)\n+    }\n }\n-\n /// Look up the method with the given name, returning the actual autoderefed\n /// receiver type (but without autoref applied yet).\n pub(crate) fn lookup_method(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     name: &Name,\n     resolver: &Resolver,\n-) -> Option<(Ty, Function)> {\n+) -> Option<(Ty, FunctionId)> {\n     iterate_method_candidates(ty, db, resolver, Some(name), LookupMode::MethodCall, |ty, f| match f\n     {\n-        AssocItem::Function(f) => Some((ty.clone(), f)),\n+        AssocItemId::FunctionId(f) => Some((ty.clone(), f)),\n         _ => None,\n     })\n }\n@@ -160,13 +167,13 @@ pub enum LookupMode {\n // This would be nicer if it just returned an iterator, but that runs into\n // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n // FIXME add a context type here?\n-pub(crate) fn iterate_method_candidates<T>(\n+pub fn iterate_method_candidates<T>(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n     let krate = resolver.krate()?;\n     match mode {\n@@ -179,16 +186,12 @@ pub(crate) fn iterate_method_candidates<T>(\n             // Also note that when we've got a receiver like &S, even if the method we\n             // find in the end takes &self, we still do the autoderef step (just as\n             // rustc does an autoderef and then autoref again).\n-\n-            for derefed_ty in autoderef::autoderef(db, resolver, ty.clone()) {\n-                if let Some(result) = iterate_inherent_methods(\n-                    &derefed_ty,\n-                    db,\n-                    name,\n-                    mode,\n-                    krate.into(),\n-                    &mut callback,\n-                ) {\n+            let environment = TraitEnvironment::lower(db, resolver);\n+            let ty = InEnvironment { value: ty.clone(), environment };\n+            for derefed_ty in autoderef::autoderef(db, resolver.krate(), ty) {\n+                if let Some(result) =\n+                    iterate_inherent_methods(&derefed_ty, db, name, mode, krate, &mut callback)\n+                {\n                     return Some(result);\n                 }\n                 if let Some(result) = iterate_trait_method_candidates(\n@@ -226,30 +229,29 @@ fn iterate_trait_method_candidates<T>(\n     resolver: &Resolver,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n     let krate = resolver.krate()?;\n     // FIXME: maybe put the trait_env behind a query (need to figure out good input parameters for that)\n-    let env = lower::trait_env(db, resolver);\n+    let env = TraitEnvironment::lower(db, resolver);\n     // if ty is `impl Trait` or `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait = ty.value.inherent_trait().into_iter();\n     // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n     let traits_from_env = env\n         .trait_predicates_for_self_ty(&ty.value)\n         .map(|tr| tr.trait_)\n-        .flat_map(|t| t.all_super_traits(db));\n-    let traits = inherent_trait\n-        .chain(traits_from_env)\n-        .chain(resolver.traits_in_scope(db).into_iter().map(Trait::from));\n+        .flat_map(|t| all_super_traits(db, t));\n+    let traits =\n+        inherent_trait.chain(traits_from_env).chain(resolver.traits_in_scope(db).into_iter());\n     'traits: for t in traits {\n-        let data = db.trait_data(t.id);\n+        let data = db.trait_data(t);\n \n         // we'll be lazy about checking whether the type implements the\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n         let mut known_implemented = false;\n-        for &item in data.items.iter() {\n-            if !is_valid_candidate(db, name, mode, item.into()) {\n+        for (_name, item) in data.items.iter() {\n+            if !is_valid_candidate(db, name, mode, (*item).into()) {\n                 continue;\n             }\n             if !known_implemented {\n@@ -259,7 +261,7 @@ fn iterate_trait_method_candidates<T>(\n                 }\n             }\n             known_implemented = true;\n-            if let Some(result) = callback(&ty.value, item.into()) {\n+            if let Some(result) = callback(&ty.value, (*item).into()) {\n                 return Some(result);\n             }\n         }\n@@ -272,18 +274,18 @@ fn iterate_inherent_methods<T>(\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    krate: Crate,\n-    mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n+    krate: CrateId,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    for krate in def_crates(db, krate, &ty.value)? {\n+    for krate in ty.value.def_crates(db, krate)? {\n         let impls = db.impls_in_crate(krate);\n \n         for impl_block in impls.lookup_impl_blocks(&ty.value) {\n-            for item in impl_block.items(db) {\n+            for &item in db.impl_data(impl_block).items.iter() {\n                 if !is_valid_candidate(db, name, mode, item) {\n                     continue;\n                 }\n-                if let Some(result) = callback(&ty.value, item) {\n+                if let Some(result) = callback(&ty.value, item.into()) {\n                     return Some(result);\n                 }\n             }\n@@ -296,71 +298,47 @@ fn is_valid_candidate(\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    item: AssocItem,\n+    item: AssocItemId,\n ) -> bool {\n     match item {\n-        AssocItem::Function(m) => {\n-            let data = db.function_data(m.id);\n-            name.map_or(true, |name| data.name == *name)\n+        AssocItemId::FunctionId(m) => {\n+            let data = db.function_data(m);\n+            name.map_or(true, |name| &data.name == name)\n                 && (data.has_self_param || mode == LookupMode::Path)\n         }\n-        AssocItem::Const(c) => {\n-            name.map_or(true, |name| Some(name) == c.name(db).as_ref())\n-                && (mode == LookupMode::Path)\n+        AssocItemId::ConstId(c) => {\n+            let data = db.const_data(c);\n+            name.map_or(true, |name| data.name.as_ref() == Some(name)) && (mode == LookupMode::Path)\n         }\n         _ => false,\n     }\n }\n \n-pub(crate) fn implements_trait(\n+pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n-    krate: Crate,\n-    trait_: Trait,\n+    krate: CrateId,\n+    trait_: TraitId,\n ) -> bool {\n     if ty.value.inherent_trait() == Some(trait_) {\n         // FIXME this is a bit of a hack, since Chalk should say the same thing\n         // anyway, but currently Chalk doesn't implement `dyn/impl Trait` yet\n         return true;\n     }\n-    let env = lower::trait_env(db, resolver);\n+    let env = TraitEnvironment::lower(db, resolver);\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n-    let solution = db.trait_solve(krate, goal);\n+    let solution = db.trait_solve(krate.into(), goal);\n \n     solution.is_some()\n }\n \n-impl Ty {\n-    // This would be nicer if it just returned an iterator, but that runs into\n-    // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n-    pub fn iterate_impl_items<T>(\n-        self,\n-        db: &impl HirDatabase,\n-        krate: Crate,\n-        mut callback: impl FnMut(AssocItem) -> Option<T>,\n-    ) -> Option<T> {\n-        for krate in def_crates(db, krate, &self)? {\n-            let impls = db.impls_in_crate(krate);\n-\n-            for impl_block in impls.lookup_impl_blocks(&self) {\n-                for item in impl_block.items(db) {\n-                    if let Some(result) = callback(item) {\n-                        return Some(result);\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-}\n-\n /// This creates Substs for a trait with the given Self type and type variables\n /// for all other parameters, to query Chalk with it.\n fn generic_implements_goal(\n     db: &impl HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    trait_: Trait,\n+    trait_: TraitId,\n     self_ty: Canonical<Ty>,\n ) -> Canonical<InEnvironment<super::Obligation>> {\n     let num_vars = self_ty.num_vars;", "previous_filename": "crates/ra_hir/src/ty/method_resolution.rs"}, {"sha": "09c47a76d0cc1d5c6213714816579c50a2a10805", "filename": "crates/ra_hir_ty/src/op.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fop.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,10 +1,8 @@\n //! FIXME: write short doc here\n+use hir_def::expr::{BinaryOp, CmpOp};\n \n use super::{InferTy, Ty, TypeCtor};\n-use crate::{\n-    expr::{BinaryOp, CmpOp},\n-    ty::ApplicationTy,\n-};\n+use crate::ApplicationTy;\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n     match op {", "previous_filename": "crates/ra_hir/src/ty/op.rs"}, {"sha": "02a8179d94db858f0d1e9ed141fcfc0e6d3cb8b6", "filename": "crates/ra_hir_ty/src/primitive.rs", "status": "renamed", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fprimitive.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,8 +1,11 @@\n-//! FIXME: write short doc here\n+//! Defines primitive types, which have a couple of peculiarities:\n+//!\n+//! * during type inference, they can be uncertain (ie, `let x = 92;`)\n+//! * they don't belong to any particular crate.\n \n use std::fmt;\n \n-pub use hir_def::builtin_type::{FloatBitness, IntBitness, Signedness};\n+pub use hir_def::builtin_type::{BuiltinFloat, BuiltinInt, FloatBitness, IntBitness, Signedness};\n \n #[derive(Clone, Copy, Eq, PartialEq, Hash, Debug)]\n pub enum Uncertain<T> {\n@@ -107,7 +110,7 @@ impl IntTy {\n         IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X128 }\n     }\n \n-    pub(crate) fn ty_to_string(self) -> &'static str {\n+    pub fn ty_to_string(self) -> &'static str {\n         match (self.signedness, self.bitness) {\n             (Signedness::Signed, IntBitness::Xsize) => \"isize\",\n             (Signedness::Signed, IntBitness::X8) => \"i8\",\n@@ -151,10 +154,40 @@ impl FloatTy {\n         FloatTy { bitness: FloatBitness::X64 }\n     }\n \n-    pub(crate) fn ty_to_string(self) -> &'static str {\n+    pub fn ty_to_string(self) -> &'static str {\n         match self.bitness {\n             FloatBitness::X32 => \"f32\",\n             FloatBitness::X64 => \"f64\",\n         }\n     }\n }\n+\n+impl From<BuiltinInt> for IntTy {\n+    fn from(t: BuiltinInt) -> Self {\n+        IntTy { signedness: t.signedness, bitness: t.bitness }\n+    }\n+}\n+\n+impl From<BuiltinFloat> for FloatTy {\n+    fn from(t: BuiltinFloat) -> Self {\n+        FloatTy { bitness: t.bitness }\n+    }\n+}\n+\n+impl From<Option<BuiltinInt>> for Uncertain<IntTy> {\n+    fn from(t: Option<BuiltinInt>) -> Self {\n+        match t {\n+            None => Uncertain::Unknown,\n+            Some(t) => Uncertain::Known(t.into()),\n+        }\n+    }\n+}\n+\n+impl From<Option<BuiltinFloat>> for Uncertain<FloatTy> {\n+    fn from(t: Option<BuiltinFloat>) -> Self {\n+        match t {\n+            None => Uncertain::Unknown,\n+            Some(t) => Uncertain::Known(t.into()),\n+        }\n+    }\n+}", "previous_filename": "crates/ra_hir/src/ty/primitive.rs"}, {"sha": "1dc9793f950a0287256d17742e1c25175568cafd", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "renamed", "additions": 56, "deletions": 29, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,21 +1,23 @@\n //! Database used for testing `hir`.\n \n-use std::{panic, sync::Arc};\n+use std::{\n+    panic,\n+    sync::{Arc, Mutex},\n+};\n \n-use hir_def::{db::DefDatabase, ModuleId};\n+use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId, ModuleId};\n use hir_expand::diagnostics::DiagnosticSink;\n-use parking_lot::Mutex;\n use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath, SourceDatabase};\n \n-use crate::{db, debug::HirDebugHelper};\n+use crate::{db::HirDatabase, expr::ExprValidator};\n \n #[salsa::database(\n     ra_db::SourceDatabaseExtStorage,\n     ra_db::SourceDatabaseStorage,\n-    db::InternDatabaseStorage,\n-    db::AstDatabaseStorage,\n-    db::DefDatabaseStorage,\n-    db::HirDatabaseStorage\n+    hir_expand::db::AstDatabaseStorage,\n+    hir_def::db::InternDatabaseStorage,\n+    hir_def::db::DefDatabaseStorage,\n+    crate::db::HirDatabaseStorage\n )]\n #[derive(Debug, Default)]\n pub struct TestDB {\n@@ -28,8 +30,12 @@ impl salsa::Database for TestDB {\n         &self.runtime\n     }\n \n+    fn salsa_runtime_mut(&mut self) -> &mut salsa::Runtime<Self> {\n+        &mut self.runtime\n+    }\n+\n     fn salsa_event(&self, event: impl Fn() -> salsa::Event<TestDB>) {\n-        let mut events = self.events.lock();\n+        let mut events = self.events.lock().unwrap();\n         if let Some(events) = &mut *events {\n             events.push(event());\n         }\n@@ -63,32 +69,53 @@ impl FileLoader for TestDB {\n     }\n }\n \n-// FIXME: improve `WithFixture` to bring useful hir debugging back\n-impl HirDebugHelper for TestDB {\n-    fn crate_name(&self, _krate: CrateId) -> Option<String> {\n-        None\n+impl TestDB {\n+    pub fn module_for_file(&self, file_id: FileId) -> ModuleId {\n+        for &krate in self.relevant_crates(file_id).iter() {\n+            let crate_def_map = self.crate_def_map(krate);\n+            for (local_id, data) in crate_def_map.modules.iter() {\n+                if data.definition == Some(file_id) {\n+                    return ModuleId { krate, local_id };\n+                }\n+            }\n+        }\n+        panic!(\"Can't find module for file\")\n     }\n \n-    fn file_path(&self, _file_id: FileId) -> Option<String> {\n-        None\n-    }\n-}\n-\n-impl TestDB {\n+    // FIXME: don't duplicate this\n     pub fn diagnostics(&self) -> String {\n         let mut buf = String::new();\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter().next() {\n             let crate_def_map = self.crate_def_map(krate);\n+\n+            let mut fns = Vec::new();\n             for (module_id, _) in crate_def_map.modules.iter() {\n-                let module_id = ModuleId { krate, module_id };\n-                let module = crate::Module::from(module_id);\n-                module.diagnostics(\n-                    self,\n-                    &mut DiagnosticSink::new(|d| {\n-                        buf += &format!(\"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n-                    }),\n-                )\n+                for decl in crate_def_map[module_id].scope.declarations() {\n+                    match decl {\n+                        ModuleDefId::FunctionId(f) => fns.push(f),\n+                        _ => (),\n+                    }\n+                }\n+\n+                for &impl_id in crate_def_map[module_id].impls.iter() {\n+                    let impl_data = self.impl_data(impl_id);\n+                    for item in impl_data.items.iter() {\n+                        if let AssocItemId::FunctionId(f) = item {\n+                            fns.push(*f)\n+                        }\n+                    }\n+                }\n+            }\n+\n+            for f in fns {\n+                let infer = self.infer(f.into());\n+                let mut sink = DiagnosticSink::new(|d| {\n+                    buf += &format!(\"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+                });\n+                infer.add_diagnostics(self, f, &mut sink);\n+                let mut validator = ExprValidator::new(f, infer, &mut sink);\n+                validator.validate_body(self);\n             }\n         }\n         buf\n@@ -97,9 +124,9 @@ impl TestDB {\n \n impl TestDB {\n     pub fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<TestDB>> {\n-        *self.events.lock() = Some(Vec::new());\n+        *self.events.lock().unwrap() = Some(Vec::new());\n         f();\n-        self.events.lock().take().unwrap()\n+        self.events.lock().unwrap().take().unwrap()\n     }\n \n     pub fn log_executed(&self, f: impl FnOnce()) -> Vec<String> {", "previous_filename": "crates/ra_hir/src/test_db.rs"}, {"sha": "c8461b447add1b2073d5e8a9fa6e4de3ce17797e", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "renamed", "additions": 88, "deletions": 25, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -4,20 +4,20 @@ mod coercion;\n use std::fmt::Write;\n use std::sync::Arc;\n \n+use hir_def::{\n+    body::BodySourceMap, db::DefDatabase, nameres::CrateDefMap, AssocItemId, DefWithBodyId,\n+    LocalModuleId, Lookup, ModuleDefId,\n+};\n+use hir_expand::Source;\n use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, salsa::Database, FilePosition, SourceDatabase};\n use ra_syntax::{\n     algo,\n     ast::{self, AstNode},\n-    SyntaxKind::*,\n };\n-use rustc_hash::FxHashSet;\n use test_utils::covers;\n \n-use crate::{\n-    expr::BodySourceMap, test_db::TestDB, ty::display::HirDisplay, ty::InferenceResult, Source,\n-    SourceAnalyzer,\n-};\n+use crate::{db::HirDatabase, display::HirDisplay, test_db::TestDB, InferenceResult};\n \n // These tests compare the inference results for all expressions in a file\n // against snapshots of the expected results using insta. Use cargo-insta to\n@@ -4674,10 +4674,20 @@ fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n-    let analyzer =\n-        SourceAnalyzer::new(db, Source::new(pos.file_id.into(), expr.syntax()), Some(pos.offset));\n-    let ty = analyzer.type_of(db, &expr).unwrap();\n-    ty.display(db).to_string()\n+\n+    let module = db.module_for_file(pos.file_id);\n+    let crate_def_map = db.crate_def_map(module.krate);\n+    for decl in crate_def_map[module.local_id].scope.declarations() {\n+        if let ModuleDefId::FunctionId(func) = decl {\n+            let (_body, source_map) = db.body_with_source_map(func.into());\n+            if let Some(expr_id) = source_map.node_expr(Source::new(pos.file_id.into(), &expr)) {\n+                let infer = db.infer(func.into());\n+                let ty = &infer[expr_id];\n+                return ty.display(db).to_string();\n+            }\n+        }\n+    }\n+    panic!(\"Can't find expression\")\n }\n \n fn type_at(content: &str) -> String {\n@@ -4687,7 +4697,6 @@ fn type_at(content: &str) -> String {\n \n fn infer(content: &str) -> String {\n     let (db, file_id) = TestDB::with_single_file(content);\n-    let source_file = db.parse(file_id).ok().unwrap();\n \n     let mut acc = String::new();\n \n@@ -4740,20 +4749,69 @@ fn infer(content: &str) -> String {\n         }\n     };\n \n-    let mut analyzed = FxHashSet::default();\n-    for node in source_file.syntax().descendants() {\n-        if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n-            let analyzer = SourceAnalyzer::new(&db, Source::new(file_id.into(), &node), None);\n-            if analyzed.insert(analyzer.analyzed_declaration()) {\n-                infer_def(analyzer.inference_result(), analyzer.body_source_map());\n-            }\n+    let module = db.module_for_file(file_id);\n+    let crate_def_map = db.crate_def_map(module.krate);\n+\n+    let mut defs: Vec<DefWithBodyId> = Vec::new();\n+    visit_module(&db, &crate_def_map, module.local_id, &mut |it| defs.push(it));\n+    defs.sort_by_key(|def| match def {\n+        DefWithBodyId::FunctionId(it) => {\n+            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n+        }\n+        DefWithBodyId::ConstId(it) => {\n+            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n+        }\n+        DefWithBodyId::StaticId(it) => {\n+            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n         }\n+    });\n+    for def in defs {\n+        let (_body, source_map) = db.body_with_source_map(def);\n+        let infer = db.infer(def);\n+        infer_def(infer, source_map);\n     }\n \n     acc.truncate(acc.trim_end().len());\n     acc\n }\n \n+fn visit_module(\n+    db: &TestDB,\n+    crate_def_map: &CrateDefMap,\n+    module_id: LocalModuleId,\n+    cb: &mut dyn FnMut(DefWithBodyId),\n+) {\n+    for decl in crate_def_map[module_id].scope.declarations() {\n+        match decl {\n+            ModuleDefId::FunctionId(it) => cb(it.into()),\n+            ModuleDefId::ConstId(it) => cb(it.into()),\n+            ModuleDefId::StaticId(it) => cb(it.into()),\n+            ModuleDefId::TraitId(it) => {\n+                let trait_data = db.trait_data(it);\n+                for &(_, item) in trait_data.items.iter() {\n+                    match item {\n+                        AssocItemId::FunctionId(it) => cb(it.into()),\n+                        AssocItemId::ConstId(it) => cb(it.into()),\n+                        AssocItemId::TypeAliasId(_) => (),\n+                    }\n+                }\n+            }\n+            ModuleDefId::ModuleId(it) => visit_module(db, crate_def_map, it.local_id, cb),\n+            _ => (),\n+        }\n+    }\n+    for &impl_id in crate_def_map[module_id].impls.iter() {\n+        let impl_data = db.impl_data(impl_id);\n+        for &item in impl_data.items.iter() {\n+            match item {\n+                AssocItemId::FunctionId(it) => cb(it.into()),\n+                AssocItemId::ConstId(it) => cb(it.into()),\n+                AssocItemId::TypeAliasId(_) => (),\n+            }\n+        }\n+    }\n+}\n+\n fn ellipsize(mut text: String, max_len: usize) -> String {\n     if text.len() <= max_len {\n         return text;\n@@ -4783,10 +4841,12 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n     \",\n     );\n     {\n-        let file = db.parse(pos.file_id).ok().unwrap();\n-        let node = file.syntax().token_at_offset(pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            SourceAnalyzer::new(&db, Source::new(pos.file_id.into(), &node), None);\n+            let module = db.module_for_file(pos.file_id);\n+            let crate_def_map = db.crate_def_map(module.krate);\n+            visit_module(&db, &crate_def_map, module.local_id, &mut |def| {\n+                db.infer(def);\n+            });\n         });\n         assert!(format!(\"{:?}\", events).contains(\"infer\"))\n     }\n@@ -4803,10 +4863,12 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n     db.query_mut(ra_db::FileTextQuery).set(pos.file_id, Arc::new(new_text));\n \n     {\n-        let file = db.parse(pos.file_id).ok().unwrap();\n-        let node = file.syntax().token_at_offset(pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            SourceAnalyzer::new(&db, Source::new(pos.file_id.into(), &node), None);\n+            let module = db.module_for_file(pos.file_id);\n+            let crate_def_map = db.crate_def_map(module.krate);\n+            visit_module(&db, &crate_def_map, module.local_id, &mut |def| {\n+                db.infer(def);\n+            });\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }\n@@ -4832,7 +4894,8 @@ fn no_such_field_diagnostics() {\n \n     assert_snapshot!(diagnostics, @r###\"\n     \"baz: 62\": no such field\n-    \"{\\n            foo: 92,\\n            baz: 62,\\n        }\": fill structure fields\n+    \"{\\n            foo: 92,\\n            baz: 62,\\n        }\": Missing structure fields:\n+    - bar\n     \"###\n     );\n }", "previous_filename": "crates/ra_hir/src/ty/tests.rs"}, {"sha": "1530fcc6378a55e895dae1793df0edf6bf933b25", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_hir/src/ty/tests/coercion.rs"}, {"sha": "c202f545a3799852f93f47dbc1be8872a08b796c", "filename": "crates/ra_hir_ty/src/tests/never_type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_hir/src/ty/tests/never_type.rs"}, {"sha": "76189a60b14e1e4381f5500681ebd978d7aa5820", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "renamed", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -2,21 +2,23 @@\n use std::sync::{Arc, Mutex};\n \n use chalk_ir::{cast::Cast, family::ChalkIr};\n+use hir_def::{expr::ExprId, DefWithBodyId, ImplId, TraitId, TypeAliasId};\n use log::debug;\n-use ra_db::{impl_intern_key, salsa};\n+use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n+use crate::db::HirDatabase;\n+\n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n-use crate::{db::HirDatabase, expr::ExprId, Crate, DefWithBody, ImplBlock, Trait, TypeAlias};\n \n use self::chalk::{from_chalk, ToChalk};\n \n pub(crate) mod chalk;\n \n #[derive(Debug, Clone)]\n pub struct TraitSolver {\n-    krate: Crate,\n+    krate: CrateId,\n     inner: Arc<Mutex<chalk_solve::Solver<ChalkIr>>>,\n }\n \n@@ -58,12 +60,12 @@ const CHALK_SOLVER_MAX_SIZE: usize = 4;\n #[derive(Debug, Copy, Clone)]\n struct ChalkContext<'a, DB> {\n     db: &'a DB,\n-    krate: Crate,\n+    krate: CrateId,\n }\n \n pub(crate) fn trait_solver_query(\n     db: &(impl HirDatabase + salsa::Database),\n-    krate: Crate,\n+    krate: CrateId,\n ) -> TraitSolver {\n     db.salsa_runtime().report_untracked_read();\n     // krate parameter is just so we cache a unique solver per crate\n@@ -75,17 +77,17 @@ pub(crate) fn trait_solver_query(\n /// Collects impls for the given trait in the whole dependency tree of `krate`.\n pub(crate) fn impls_for_trait_query(\n     db: &impl HirDatabase,\n-    krate: Crate,\n-    trait_: Trait,\n-) -> Arc<[ImplBlock]> {\n+    krate: CrateId,\n+    trait_: TraitId,\n+) -> Arc<[ImplId]> {\n     let mut impls = FxHashSet::default();\n     // We call the query recursively here. On the one hand, this means we can\n     // reuse results from queries for different crates; on the other hand, this\n     // will only ever get called for a few crates near the root of the tree (the\n     // ones the user is editing), so this may actually be a waste of memory. I'm\n     // doing it like this mainly for simplicity for now.\n-    for dep in krate.dependencies(db) {\n-        impls.extend(db.impls_for_trait(dep.krate, trait_).iter());\n+    for dep in db.crate_graph().dependencies(krate) {\n+        impls.extend(db.impls_for_trait(dep.crate_id, trait_).iter());\n     }\n     let crate_impl_blocks = db.impls_in_crate(krate);\n     impls.extend(crate_impl_blocks.lookup_impl_blocks_for_trait(trait_));\n@@ -174,7 +176,7 @@ impl TypeWalk for ProjectionPredicate {\n /// Solve a trait goal using Chalk.\n pub(crate) fn trait_solve_query(\n     db: &impl HirDatabase,\n-    krate: Crate,\n+    krate: CrateId,\n     goal: Canonical<InEnvironment<Obligation>>,\n ) -> Option<Solution> {\n     let _p = profile(\"trait_solve_query\");\n@@ -290,7 +292,7 @@ impl FnTrait {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ClosureFnTraitImplData {\n-    def: DefWithBody,\n+    def: DefWithBodyId,\n     expr: ExprId,\n     fn_trait: FnTrait,\n }\n@@ -300,7 +302,7 @@ pub struct ClosureFnTraitImplData {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Impl {\n     /// A normal impl from an impl block.\n-    ImplBlock(ImplBlock),\n+    ImplBlock(ImplId),\n     /// Closure types implement the Fn traits synthetically.\n     ClosureFnTraitImpl(ClosureFnTraitImplData),\n }\n@@ -315,7 +317,7 @@ impl_intern_key!(GlobalImplId);\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AssocTyValue {\n     /// A normal assoc type value from an impl block.\n-    TypeAlias(TypeAlias),\n+    TypeAlias(TypeAliasId),\n     /// The output type of the Fn trait implementation.\n     ClosureFnTraitImplOutput(ClosureFnTraitImplData),\n }", "previous_filename": "crates/ra_hir/src/ty/traits.rs"}, {"sha": "35de37e6b625688226d3a9799e5d45541c579b39", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "renamed", "additions": 109, "deletions": 93, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -4,22 +4,24 @@ use std::sync::Arc;\n use log::debug;\n \n use chalk_ir::{\n-    cast::Cast, family::ChalkIr, Identifier, ImplId, Parameter, PlaceholderIndex, TypeId,\n-    TypeKindId, TypeName, UniverseIndex,\n+    cast::Cast, family::ChalkIr, Identifier, Parameter, PlaceholderIndex, TypeId, TypeKindId,\n+    TypeName, UniverseIndex,\n };\n use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n+use ra_db::CrateId;\n \n-use hir_def::lang_item::LangItemTarget;\n+use hir_def::{\n+    expr::Expr, lang_item::LangItemTarget, AssocItemId, AstItemDef, ContainerId, GenericDefId,\n+    ImplId, Lookup, TraitId, TypeAliasId,\n+};\n use hir_expand::name;\n \n use ra_db::salsa::{InternId, InternKey};\n \n use super::{AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n-    db::HirDatabase,\n-    ty::display::HirDisplay,\n-    ty::{ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n-    Crate, GenericDef, ImplBlock, Trait, TypeAlias,\n+    db::HirDatabase, display::HirDisplay, ApplicationTy, GenericPredicate, ImplTy, ProjectionTy,\n+    Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -167,15 +169,15 @@ impl ToChalk for TraitRef {\n     }\n }\n \n-impl ToChalk for Trait {\n+impl ToChalk for TraitId {\n     type Chalk = chalk_ir::TraitId;\n \n     fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TraitId {\n-        chalk_ir::TraitId(id_to_chalk(self.id))\n+        chalk_ir::TraitId(id_to_chalk(self))\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, trait_id: chalk_ir::TraitId) -> Trait {\n-        Trait { id: id_from_chalk(trait_id.0) }\n+    fn from_chalk(_db: &impl HirDatabase, trait_id: chalk_ir::TraitId) -> TraitId {\n+        id_from_chalk(trait_id.0)\n     }\n }\n \n@@ -203,15 +205,15 @@ impl ToChalk for Impl {\n     }\n }\n \n-impl ToChalk for TypeAlias {\n+impl ToChalk for TypeAliasId {\n     type Chalk = chalk_ir::TypeId;\n \n     fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TypeId {\n-        chalk_ir::TypeId(id_to_chalk(self.id))\n+        chalk_ir::TypeId(id_to_chalk(self))\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, type_alias_id: chalk_ir::TypeId) -> TypeAlias {\n-        TypeAlias { id: id_from_chalk(type_alias_id.0) }\n+    fn from_chalk(_db: &impl HirDatabase, type_alias_id: chalk_ir::TypeId) -> TypeAliasId {\n+        id_from_chalk(type_alias_id.0)\n     }\n }\n \n@@ -402,7 +404,7 @@ fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n \n fn convert_where_clauses(\n     db: &impl HirDatabase,\n-    def: GenericDef,\n+    def: GenericDefId,\n     substs: &Substs,\n ) -> Vec<chalk_ir::QuantifiedWhereClause<ChalkIr>> {\n     let generic_predicates = db.generic_predicates(def);\n@@ -431,25 +433,25 @@ where\n     fn struct_datum(&self, struct_id: chalk_ir::StructId) -> Arc<StructDatum<ChalkIr>> {\n         self.db.struct_datum(self.krate, struct_id)\n     }\n-    fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum<ChalkIr>> {\n+    fn impl_datum(&self, impl_id: chalk_ir::ImplId) -> Arc<ImplDatum<ChalkIr>> {\n         self.db.impl_datum(self.krate, impl_id)\n     }\n     fn impls_for_trait(\n         &self,\n         trait_id: chalk_ir::TraitId,\n         parameters: &[Parameter<ChalkIr>],\n-    ) -> Vec<ImplId> {\n+    ) -> Vec<chalk_ir::ImplId> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n         if trait_id == UNKNOWN_TRAIT {\n             return Vec::new();\n         }\n-        let trait_: Trait = from_chalk(self.db, trait_id);\n+        let trait_: TraitId = from_chalk(self.db, trait_id);\n         let mut result: Vec<_> = self\n             .db\n-            .impls_for_trait(self.krate, trait_)\n+            .impls_for_trait(self.krate, trait_.into())\n             .iter()\n             .copied()\n-            .map(Impl::ImplBlock)\n+            .map(|it| Impl::ImplBlock(it.into()))\n             .map(|impl_| impl_.to_chalk(self.db))\n             .collect();\n \n@@ -485,7 +487,7 @@ where\n         &self,\n         id: chalk_rust_ir::AssociatedTyValueId,\n     ) -> Arc<AssociatedTyValue<ChalkIr>> {\n-        self.db.associated_ty_value(self.krate, id)\n+        self.db.associated_ty_value(self.krate.into(), id)\n     }\n     fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<ChalkIr>> {\n         vec![]\n@@ -504,12 +506,12 @@ pub(crate) fn associated_ty_data_query(\n     id: TypeId,\n ) -> Arc<AssociatedTyDatum<ChalkIr>> {\n     debug!(\"associated_ty_data {:?}\", id);\n-    let type_alias: TypeAlias = from_chalk(db, id);\n-    let trait_ = match type_alias.container(db) {\n-        Some(crate::Container::Trait(t)) => t,\n+    let type_alias: TypeAliasId = from_chalk(db, id);\n+    let trait_ = match type_alias.lookup(db).container {\n+        ContainerId::TraitId(t) => t,\n         _ => panic!(\"associated type not in trait\"),\n     };\n-    let generic_params = db.generic_params(type_alias.id.into());\n+    let generic_params = db.generic_params(type_alias.into());\n     let bound_data = chalk_rust_ir::AssociatedTyDatumBound {\n         // FIXME add bounds and where clauses\n         bounds: vec![],\n@@ -518,15 +520,15 @@ pub(crate) fn associated_ty_data_query(\n     let datum = AssociatedTyDatum {\n         trait_id: trait_.to_chalk(db),\n         id,\n-        name: lalrpop_intern::intern(&type_alias.name(db).to_string()),\n+        name: lalrpop_intern::intern(&db.type_alias_data(type_alias).name.to_string()),\n         binders: make_binders(bound_data, generic_params.count_params_including_parent()),\n     };\n     Arc::new(datum)\n }\n \n pub(crate) fn trait_datum_query(\n     db: &impl HirDatabase,\n-    krate: Crate,\n+    krate: CrateId,\n     trait_id: chalk_ir::TraitId,\n ) -> Arc<TraitDatum<ChalkIr>> {\n     debug!(\"trait_datum {:?}\", trait_id);\n@@ -548,29 +550,23 @@ pub(crate) fn trait_datum_query(\n             associated_ty_ids: vec![],\n         });\n     }\n-    let trait_: Trait = from_chalk(db, trait_id);\n-    debug!(\"trait {:?} = {:?}\", trait_id, trait_.name(db));\n-    let generic_params = db.generic_params(trait_.id.into());\n+    let trait_: TraitId = from_chalk(db, trait_id);\n+    let trait_data = db.trait_data(trait_);\n+    debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n+    let generic_params = db.generic_params(trait_.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let flags = chalk_rust_ir::TraitFlags {\n-        auto: trait_.is_auto(db),\n-        upstream: trait_.module(db).krate() != krate,\n+        auto: trait_data.auto,\n+        upstream: trait_.module(db).krate != krate,\n         non_enumerable: true,\n         coinductive: false, // only relevant for Chalk testing\n         // FIXME set these flags correctly\n         marker: false,\n         fundamental: false,\n     };\n     let where_clauses = convert_where_clauses(db, trait_.into(), &bound_vars);\n-    let associated_ty_ids = trait_\n-        .items(db)\n-        .into_iter()\n-        .filter_map(|trait_item| match trait_item {\n-            crate::AssocItem::TypeAlias(type_alias) => Some(type_alias),\n-            _ => None,\n-        })\n-        .map(|type_alias| type_alias.to_chalk(db))\n-        .collect();\n+    let associated_ty_ids =\n+        trait_data.associated_types().map(|type_alias| type_alias.to_chalk(db)).collect();\n     let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses };\n     let trait_datum = TraitDatum {\n         id: trait_id,\n@@ -583,7 +579,7 @@ pub(crate) fn trait_datum_query(\n \n pub(crate) fn struct_datum_query(\n     db: &impl HirDatabase,\n-    krate: Crate,\n+    krate: CrateId,\n     struct_id: chalk_ir::StructId,\n ) -> Arc<StructDatum<ChalkIr>> {\n     debug!(\"struct_datum {:?}\", struct_id);\n@@ -615,8 +611,8 @@ pub(crate) fn struct_datum_query(\n \n pub(crate) fn impl_datum_query(\n     db: &impl HirDatabase,\n-    krate: Crate,\n-    impl_id: ImplId,\n+    krate: CrateId,\n+    impl_id: chalk_ir::ImplId,\n ) -> Arc<ImplDatum<ChalkIr>> {\n     let _p = ra_prof::profile(\"impl_datum\");\n     debug!(\"impl_datum {:?}\", impl_id);\n@@ -630,24 +626,30 @@ pub(crate) fn impl_datum_query(\n \n fn impl_block_datum(\n     db: &impl HirDatabase,\n-    krate: Crate,\n+    krate: CrateId,\n+    chalk_id: chalk_ir::ImplId,\n     impl_id: ImplId,\n-    impl_block: ImplBlock,\n ) -> Option<Arc<ImplDatum<ChalkIr>>> {\n-    let generic_params = db.generic_params(impl_block.id.into());\n+    let trait_ref = match db.impl_ty(impl_id) {\n+        ImplTy::TraitRef(it) => it,\n+        ImplTy::Inherent(_) => return None,\n+    };\n+    let impl_data = db.impl_data(impl_id);\n+\n+    let generic_params = db.generic_params(impl_id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let trait_ref = impl_block.target_trait_ref(db)?.subst(&bound_vars);\n+    let trait_ref = trait_ref.subst(&bound_vars);\n     let trait_ = trait_ref.trait_;\n-    let impl_type = if impl_block.krate(db) == krate {\n+    let impl_type = if impl_id.module(db).krate == krate {\n         chalk_rust_ir::ImplType::Local\n     } else {\n         chalk_rust_ir::ImplType::External\n     };\n-    let where_clauses = convert_where_clauses(db, impl_block.into(), &bound_vars);\n-    let negative = impl_block.is_negative(db);\n+    let where_clauses = convert_where_clauses(db, impl_id.into(), &bound_vars);\n+    let negative = impl_data.is_negative;\n     debug!(\n         \"impl {:?}: {}{} where {:?}\",\n-        impl_id,\n+        chalk_id,\n         if negative { \"!\" } else { \"\" },\n         trait_ref.display(db),\n         where_clauses\n@@ -661,16 +663,18 @@ fn impl_block_datum(\n     };\n \n     let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses };\n-    let associated_ty_value_ids = impl_block\n-        .items(db)\n-        .into_iter()\n+    let trait_data = db.trait_data(trait_);\n+    let associated_ty_value_ids = impl_data\n+        .items\n+        .iter()\n         .filter_map(|item| match item {\n-            crate::AssocItem::TypeAlias(type_alias) => Some(type_alias),\n+            AssocItemId::TypeAliasId(type_alias) => Some(*type_alias),\n             _ => None,\n         })\n-        .filter(|type_alias| {\n+        .filter(|&type_alias| {\n             // don't include associated types that don't exist in the trait\n-            trait_.associated_type_by_name(db, &type_alias.name(db)).is_some()\n+            let name = &db.type_alias_data(type_alias).name;\n+            trait_data.associated_type_by_name(name).is_some()\n         })\n         .map(|type_alias| AssocTyValue::TypeAlias(type_alias).to_chalk(db))\n         .collect();\n@@ -701,7 +705,7 @@ fn invalid_impl_datum() -> Arc<ImplDatum<ChalkIr>> {\n \n fn closure_fn_trait_impl_datum(\n     db: &impl HirDatabase,\n-    krate: Crate,\n+    krate: CrateId,\n     data: super::ClosureFnTraitImplData,\n ) -> Option<Arc<ImplDatum<ChalkIr>>> {\n     // for some closure |X, Y| -> Z:\n@@ -713,10 +717,10 @@ fn closure_fn_trait_impl_datum(\n     // and don't want to return a valid value only to find out later that FnOnce\n     // is broken\n     let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n-    fn_once_trait.associated_type_by_name(db, &name::OUTPUT_TYPE)?;\n+    let _output = db.trait_data(fn_once_trait).associated_type_by_name(&name::OUTPUT_TYPE)?;\n \n     let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n-        crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n+        Expr::Lambda { args, .. } => args.len() as u16,\n         _ => {\n             log::warn!(\"closure for closure type {:?} not found\", data);\n             0\n@@ -735,7 +739,7 @@ fn closure_fn_trait_impl_datum(\n     let self_ty = Ty::apply_one(TypeCtor::Closure { def: data.def, expr: data.expr }, sig_ty);\n \n     let trait_ref = TraitRef {\n-        trait_,\n+        trait_: trait_.into(),\n         substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n     };\n \n@@ -758,7 +762,7 @@ fn closure_fn_trait_impl_datum(\n \n pub(crate) fn associated_ty_value_query(\n     db: &impl HirDatabase,\n-    krate: Crate,\n+    krate: CrateId,\n     id: chalk_rust_ir::AssociatedTyValueId,\n ) -> Arc<chalk_rust_ir::AssociatedTyValue<ChalkIr>> {\n     let data: AssocTyValue = from_chalk(db, id);\n@@ -774,24 +778,31 @@ pub(crate) fn associated_ty_value_query(\n \n fn type_alias_associated_ty_value(\n     db: &impl HirDatabase,\n-    _krate: Crate,\n-    type_alias: TypeAlias,\n+    _krate: CrateId,\n+    type_alias: TypeAliasId,\n ) -> Arc<AssociatedTyValue<ChalkIr>> {\n-    let impl_block = type_alias.impl_block(db).expect(\"assoc ty value should be in impl\");\n-    let impl_id = Impl::ImplBlock(impl_block).to_chalk(db);\n-    let trait_ = impl_block\n-        .target_trait_ref(db)\n-        .expect(\"assoc ty value should not exist\") // we don't return any assoc ty values if the impl'd trait can't be resolved\n-        .trait_;\n-    let assoc_ty = trait_\n-        .associated_type_by_name(db, &type_alias.name(db))\n+    let type_alias_data = db.type_alias_data(type_alias);\n+    let impl_id = match type_alias.lookup(db).container {\n+        ContainerId::ImplId(it) => it,\n+        _ => panic!(\"assoc ty value should be in impl\"),\n+    };\n+\n+    let trait_ref = match db.impl_ty(impl_id) {\n+        ImplTy::TraitRef(it) => it,\n+        // we don't return any assoc ty values if the impl'd trait can't be resolved\n+        ImplTy::Inherent(_) => panic!(\"assoc ty value should not exist\"),\n+    };\n+\n+    let assoc_ty = db\n+        .trait_data(trait_ref.trait_)\n+        .associated_type_by_name(&type_alias_data.name)\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n-    let generic_params = db.generic_params(impl_block.id.into());\n+    let generic_params = db.generic_params(impl_id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let ty = db.type_for_def(type_alias.into(), crate::ty::Namespace::Types).subst(&bound_vars);\n+    let ty = db.ty(type_alias.into()).subst(&bound_vars);\n     let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n     let value = chalk_rust_ir::AssociatedTyValue {\n-        impl_id,\n+        impl_id: Impl::ImplBlock(impl_id.into()).to_chalk(db),\n         associated_ty_id: assoc_ty.to_chalk(db),\n         value: make_binders(value_bound, bound_vars.len()),\n     };\n@@ -800,13 +811,13 @@ fn type_alias_associated_ty_value(\n \n fn closure_fn_trait_output_assoc_ty_value(\n     db: &impl HirDatabase,\n-    krate: Crate,\n+    krate: CrateId,\n     data: super::ClosureFnTraitImplData,\n ) -> Arc<AssociatedTyValue<ChalkIr>> {\n     let impl_id = Impl::ClosureFnTraitImpl(data.clone()).to_chalk(db);\n \n     let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n-        crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n+        Expr::Lambda { args, .. } => args.len() as u16,\n         _ => {\n             log::warn!(\"closure for closure type {:?} not found\", data);\n             0\n@@ -818,8 +829,9 @@ fn closure_fn_trait_output_assoc_ty_value(\n     let fn_once_trait =\n         get_fn_trait(db, krate, super::FnTrait::FnOnce).expect(\"assoc ty value should not exist\");\n \n-    let output_ty_id = fn_once_trait\n-        .associated_type_by_name(db, &name::OUTPUT_TYPE)\n+    let output_ty_id = db\n+        .trait_data(fn_once_trait)\n+        .associated_type_by_name(&name::OUTPUT_TYPE)\n         .expect(\"assoc ty value should not exist\");\n \n     let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) };\n@@ -832,10 +844,14 @@ fn closure_fn_trait_output_assoc_ty_value(\n     Arc::new(value)\n }\n \n-fn get_fn_trait(db: &impl HirDatabase, krate: Crate, fn_trait: super::FnTrait) -> Option<Trait> {\n-    let target = db.lang_item(krate.crate_id, fn_trait.lang_item_name().into())?;\n+fn get_fn_trait(\n+    db: &impl HirDatabase,\n+    krate: CrateId,\n+    fn_trait: super::FnTrait,\n+) -> Option<TraitId> {\n+    let target = db.lang_item(krate, fn_trait.lang_item_name().into())?;\n     match target {\n-        LangItemTarget::TraitId(t) => Some(t.into()),\n+        LangItemTarget::TraitId(t) => Some(t),\n         _ => None,\n     }\n }\n@@ -847,38 +863,38 @@ fn id_to_chalk<T: InternKey>(salsa_id: T) -> chalk_ir::RawId {\n     chalk_ir::RawId { index: salsa_id.as_intern_id().as_u32() }\n }\n \n-impl From<chalk_ir::StructId> for crate::ty::TypeCtorId {\n+impl From<chalk_ir::StructId> for crate::TypeCtorId {\n     fn from(struct_id: chalk_ir::StructId) -> Self {\n         id_from_chalk(struct_id.0)\n     }\n }\n \n-impl From<crate::ty::TypeCtorId> for chalk_ir::StructId {\n-    fn from(type_ctor_id: crate::ty::TypeCtorId) -> Self {\n+impl From<crate::TypeCtorId> for chalk_ir::StructId {\n+    fn from(type_ctor_id: crate::TypeCtorId) -> Self {\n         chalk_ir::StructId(id_to_chalk(type_ctor_id))\n     }\n }\n \n-impl From<chalk_ir::ImplId> for crate::ty::traits::GlobalImplId {\n+impl From<chalk_ir::ImplId> for crate::traits::GlobalImplId {\n     fn from(impl_id: chalk_ir::ImplId) -> Self {\n         id_from_chalk(impl_id.0)\n     }\n }\n \n-impl From<crate::ty::traits::GlobalImplId> for chalk_ir::ImplId {\n-    fn from(impl_id: crate::ty::traits::GlobalImplId) -> Self {\n+impl From<crate::traits::GlobalImplId> for chalk_ir::ImplId {\n+    fn from(impl_id: crate::traits::GlobalImplId) -> Self {\n         chalk_ir::ImplId(id_to_chalk(impl_id))\n     }\n }\n \n-impl From<chalk_rust_ir::AssociatedTyValueId> for crate::ty::traits::AssocTyValueId {\n+impl From<chalk_rust_ir::AssociatedTyValueId> for crate::traits::AssocTyValueId {\n     fn from(id: chalk_rust_ir::AssociatedTyValueId) -> Self {\n         id_from_chalk(id.0)\n     }\n }\n \n-impl From<crate::ty::traits::AssocTyValueId> for chalk_rust_ir::AssociatedTyValueId {\n-    fn from(assoc_ty_value_id: crate::ty::traits::AssocTyValueId) -> Self {\n+impl From<crate::traits::AssocTyValueId> for chalk_rust_ir::AssociatedTyValueId {\n+    fn from(assoc_ty_value_id: crate::traits::AssocTyValueId) -> Self {\n         chalk_rust_ir::AssociatedTyValueId(id_to_chalk(assoc_ty_value_id))\n     }\n }", "previous_filename": "crates/ra_hir/src/ty/traits/chalk.rs"}, {"sha": "e4ba890efa16f0a8245315645df043244de3ab53", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -0,0 +1,84 @@\n+//! Helper functions for working with def, which don't need to be a separate\n+//! query, but can't be computed directly from `*Data` (ie, which need a `db`).\n+use std::sync::Arc;\n+\n+use hir_def::{\n+    adt::VariantData,\n+    db::DefDatabase,\n+    resolver::{HasResolver, TypeNs},\n+    type_ref::TypeRef,\n+    TraitId, TypeAliasId, VariantId,\n+};\n+use hir_expand::name::{self, Name};\n+\n+// FIXME: this is wrong, b/c it can't express `trait T: PartialEq<()>`.\n+// We should return a `TraitREf` here.\n+fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n+    let resolver = trait_.resolver(db);\n+    // returning the iterator directly doesn't easily work because of\n+    // lifetime problems, but since there usually shouldn't be more than a\n+    // few direct traits this should be fine (we could even use some kind of\n+    // SmallVec if performance is a concern)\n+    db.generic_params(trait_.into())\n+        .where_predicates\n+        .iter()\n+        .filter_map(|pred| match &pred.type_ref {\n+            TypeRef::Path(p) if p.as_ident() == Some(&name::SELF_TYPE) => pred.bound.as_path(),\n+            _ => None,\n+        })\n+        .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {\n+            Some(TypeNs::TraitId(t)) => Some(t),\n+            _ => None,\n+        })\n+        .collect()\n+}\n+\n+/// Returns an iterator over the whole super trait hierarchy (including the\n+/// trait itself).\n+pub(super) fn all_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n+    // we need to take care a bit here to avoid infinite loops in case of cycles\n+    // (i.e. if we have `trait A: B; trait B: A;`)\n+    let mut result = vec![trait_];\n+    let mut i = 0;\n+    while i < result.len() {\n+        let t = result[i];\n+        // yeah this is quadratic, but trait hierarchies should be flat\n+        // enough that this doesn't matter\n+        for tt in direct_super_traits(db, t) {\n+            if !result.contains(&tt) {\n+                result.push(tt);\n+            }\n+        }\n+        i += 1;\n+    }\n+    result\n+}\n+\n+pub(super) fn associated_type_by_name_including_super_traits(\n+    db: &impl DefDatabase,\n+    trait_: TraitId,\n+    name: &Name,\n+) -> Option<TypeAliasId> {\n+    all_super_traits(db, trait_)\n+        .into_iter()\n+        .find_map(|t| db.trait_data(t).associated_type_by_name(name))\n+}\n+\n+pub(super) fn variant_data(db: &impl DefDatabase, var: VariantId) -> Arc<VariantData> {\n+    match var {\n+        VariantId::StructId(it) => db.struct_data(it).variant_data.clone(),\n+        VariantId::UnionId(it) => db.union_data(it).variant_data.clone(),\n+        VariantId::EnumVariantId(it) => {\n+            db.enum_data(it.parent).variants[it.local_id].variant_data.clone()\n+        }\n+    }\n+}\n+\n+/// Helper for mutating `Arc<[T]>` (i.e. `Arc::make_mut` for Arc slices).\n+/// The underlying values are cloned if there are other strong references.\n+pub(crate) fn make_mut_slice<T: Clone>(a: &mut Arc<[T]>) -> &mut [T] {\n+    if Arc::get_mut(a).is_none() {\n+        *a = a.iter().cloned().collect();\n+    }\n+    Arc::get_mut(a).unwrap()\n+}"}, {"sha": "e6383dd35284d0c1f9bb8e019345f4ded37d163a", "filename": "crates/ra_ide/Cargo.toml", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,6 +1,6 @@\n [package]\n edition = \"2018\"\n-name = \"ra_ide_api\"\n+name = \"ra_ide\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n@@ -32,7 +32,7 @@ ra_prof = { path = \"../ra_prof\" }\n test_utils = { path = \"../test_utils\" }\n ra_assists = { path = \"../ra_assists\" }\n \n-# ra_ide_api should depend only on the top-level `hir` package. if you need\n+# ra_ide should depend only on the top-level `hir` package. if you need\n # something from some `hir_xxx` subpackage, reexport the API via `hir`.\n hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n ", "previous_filename": "crates/ra_ide_api/Cargo.toml"}, {"sha": "e00589733b7a6c96173b03cabe26452523ac9442", "filename": "crates/ra_ide/src/assists.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fassists.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/assists.rs"}, {"sha": "d559dc4d0e9632dcf9e2af9d8b38d52d1742da0e", "filename": "crates/ra_ide/src/call_info.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -18,30 +18,30 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     // Find the calling expression and it's NameRef\n     let calling_node = FnCallNode::with_node(&syntax, position.offset)?;\n     let name_ref = calling_node.name_ref()?;\n+    let name_ref = hir::Source::new(position.file_id.into(), name_ref.syntax());\n \n-    let analyzer = hir::SourceAnalyzer::new(\n-        db,\n-        hir::Source::new(position.file_id.into(), name_ref.syntax()),\n-        None,\n-    );\n+    let analyzer = hir::SourceAnalyzer::new(db, name_ref, None);\n     let (mut call_info, has_self) = match &calling_node {\n         FnCallNode::CallExpr(expr) => {\n-            //FIXME: apply subst\n-            let (callable_def, _subst) = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n+            //FIXME: Type::as_callable is broken\n+            let callable_def = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n-                hir::CallableDef::Function(it) => {\n-                    (CallInfo::with_fn(db, it), it.has_self_param(db))\n+                hir::CallableDef::FunctionId(it) => {\n+                    let fn_def = it.into();\n+                    (CallInfo::with_fn(db, fn_def), fn_def.has_self_param(db))\n+                }\n+                hir::CallableDef::StructId(it) => (CallInfo::with_struct(db, it.into())?, false),\n+                hir::CallableDef::EnumVariantId(it) => {\n+                    (CallInfo::with_enum_variant(db, it.into())?, false)\n                 }\n-                hir::CallableDef::Struct(it) => (CallInfo::with_struct(db, it)?, false),\n-                hir::CallableDef::EnumVariant(it) => (CallInfo::with_enum_variant(db, it)?, false),\n             }\n         }\n         FnCallNode::MethodCallExpr(expr) => {\n             let function = analyzer.resolve_method_call(&expr)?;\n             (CallInfo::with_fn(db, function), function.has_self_param(db))\n         }\n         FnCallNode::MacroCallExpr(expr) => {\n-            let macro_def = analyzer.resolve_macro_call(db, &expr)?;\n+            let macro_def = analyzer.resolve_macro_call(db, name_ref.with_value(&expr))?;\n             (CallInfo::with_macro(db, macro_def)?, false)\n         }\n     };", "previous_filename": "crates/ra_ide_api/src/call_info.rs"}, {"sha": "4a76d1dd83ce996d5e00b50752f4e554d6e44ccb", "filename": "crates/ra_ide/src/change.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fchange.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -171,7 +171,7 @@ impl RootDatabase {\n         log::info!(\"apply_change {:?}\", change);\n         {\n             let _p = profile(\"RootDatabase::apply_change/cancellation\");\n-            self.salsa_runtime().synthetic_write(Durability::LOW);\n+            self.salsa_runtime_mut().synthetic_write(Durability::LOW);\n         }\n         if !change.new_roots.is_empty() {\n             let mut local_roots = Vec::clone(&self.local_roots());\n@@ -323,7 +323,8 @@ impl RootDatabase {\n             hir::db::DocumentationQuery\n             hir::db::ExprScopesQuery\n             hir::db::InferQuery\n-            hir::db::TypeForDefQuery\n+            hir::db::TyQuery\n+            hir::db::ValueTyQuery\n             hir::db::FieldTypesQuery\n             hir::db::CallableItemSignatureQuery\n             hir::db::GenericPredicatesQuery", "previous_filename": "crates/ra_ide_api/src/change.rs"}, {"sha": "abe1f36cec9b833e2bb80552fd63f1ff261d36eb", "filename": "crates/ra_ide/src/completion.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/completion.rs"}, {"sha": "b6fe486270169cfcd7c68540158cfb535df44760", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "renamed", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{Adt, Ty, TypeCtor};\n+use hir::Type;\n \n use crate::completion::completion_item::CompletionKind;\n use crate::{\n@@ -22,41 +22,31 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     };\n \n     if !ctx.is_call {\n-        complete_fields(acc, ctx, receiver_ty.clone());\n+        complete_fields(acc, ctx, &receiver_ty);\n     }\n-    complete_methods(acc, ctx, receiver_ty.clone());\n+    complete_methods(acc, ctx, &receiver_ty);\n \n     // Suggest .await syntax for types that implement Future trait\n-    if ctx.analyzer.impls_future(ctx.db, receiver_ty) {\n+    if ctx.analyzer.impls_future(ctx.db, receiver_ty.into_ty()) {\n         CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), \"await\")\n             .detail(\"expr.await\")\n             .insert_text(\"await\")\n             .add_to(acc);\n     }\n }\n \n-fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n-    for receiver in ctx.analyzer.autoderef(ctx.db, receiver) {\n-        if let Ty::Apply(a_ty) = receiver {\n-            match a_ty.ctor {\n-                TypeCtor::Adt(Adt::Struct(s)) => {\n-                    for field in s.fields(ctx.db) {\n-                        acc.add_field(ctx, field, &a_ty.parameters);\n-                    }\n-                }\n-                // FIXME unions\n-                TypeCtor::Tuple { .. } => {\n-                    for (i, ty) in a_ty.parameters.iter().enumerate() {\n-                        acc.add_tuple_field(ctx, i, ty);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        };\n+fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n+    for receiver in receiver.autoderef(ctx.db) {\n+        for (field, ty) in receiver.fields(ctx.db) {\n+            acc.add_field(ctx, field, &ty);\n+        }\n+        for (i, ty) in receiver.tuple_fields(ctx.db).into_iter().enumerate() {\n+            acc.add_tuple_field(ctx, i, &ty);\n+        }\n     }\n }\n \n-fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n+fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n     let mut seen_methods = FxHashSet::default();\n     ctx.analyzer.iterate_method_candidates(ctx.db, receiver, None, |_ty, func| {\n         if func.has_self_param(ctx.db) && seen_methods.insert(func.name(ctx.db)) {", "previous_filename": "crates/ra_ide_api/src/completion/complete_dot.rs"}, {"sha": "50245870658563bcda0caf8154d77e21dc7dda67", "filename": "crates/ra_ide/src/completion/complete_fn_param.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/completion/complete_fn_param.rs"}, {"sha": "eb7cd9ac209a1e45c45194356457f618fcf583b4", "filename": "crates/ra_ide/src/completion/complete_keyword.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/completion/complete_keyword.rs"}, {"sha": "faadd1e3f4e4d0e52ea6811e1498cb6a64b2fe64", "filename": "crates/ra_ide/src/completion/complete_macro_in_item_position.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/completion/complete_macro_in_item_position.rs"}, {"sha": "89e0009a17a6ec918b55ec495d293707790c53ab", "filename": "crates/ra_ide/src/completion/complete_path.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -50,7 +50,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 hir::ModuleDef::TypeAlias(a) => a.ty(ctx.db),\n                 _ => unreachable!(),\n             };\n-            ctx.analyzer.iterate_path_candidates(ctx.db, ty.clone(), None, |_ty, item| {\n+            ctx.analyzer.iterate_path_candidates(ctx.db, &ty, None, |_ty, item| {\n                 match item {\n                     hir::AssocItem::Function(func) => {\n                         if !func.has_self_param(ctx.db) {", "previous_filename": "crates/ra_ide_api/src/completion/complete_path.rs"}, {"sha": "fd03b1c40586ad07fa4f83d00accddbbdd79b724", "filename": "crates/ra_ide/src/completion/complete_pattern.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/completion/complete_pattern.rs"}, {"sha": "646a30c76efa0004dfe06221c7c32d748db25c4d", "filename": "crates/ra_ide/src/completion/complete_postfix.rs", "status": "renamed", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,6 +1,5 @@\n //! FIXME: write short doc here\n \n-use hir::{Ty, TypeCtor};\n use ra_syntax::{ast::AstNode, TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n \n@@ -30,9 +29,12 @@ pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         dot_receiver.syntax().text().to_string()\n     };\n \n-    let receiver_ty = ctx.analyzer.type_of(ctx.db, &dot_receiver);\n+    let receiver_ty = match ctx.analyzer.type_of(ctx.db, &dot_receiver) {\n+        Some(it) => it,\n+        None => return,\n+    };\n \n-    if is_bool_or_unknown(receiver_ty) {\n+    if receiver_ty.is_bool() || receiver_ty.is_unknown() {\n         postfix_snippet(ctx, \"if\", \"if expr {}\", &format!(\"if {} {{$0}}\", receiver_text))\n             .add_to(acc);\n         postfix_snippet(\n@@ -75,14 +77,6 @@ fn postfix_snippet(ctx: &CompletionContext, label: &str, detail: &str, snippet:\n         .snippet_edit(edit)\n }\n \n-fn is_bool_or_unknown(ty: Option<Ty>) -> bool {\n-    match &ty {\n-        Some(Ty::Apply(app)) if app.ctor == TypeCtor::Bool => true,\n-        Some(Ty::Unknown) | None => true,\n-        Some(_) => false,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;", "previous_filename": "crates/ra_ide_api/src/completion/complete_postfix.rs"}, {"sha": "577c394d22e645de841b00904e2ca58864a8e2ea", "filename": "crates/ra_ide/src/completion/complete_record_literal.rs", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,7 +1,5 @@\n //! FIXME: write short doc here\n \n-use hir::Substs;\n-\n use crate::completion::{CompletionContext, Completions};\n \n /// Complete fields in fields literals.\n@@ -15,10 +13,9 @@ pub(super) fn complete_record_literal(acc: &mut Completions, ctx: &CompletionCon\n         Some(it) => it,\n         _ => return,\n     };\n-    let substs = &ty.substs().unwrap_or_else(Substs::empty);\n \n-    for field in variant.fields(ctx.db) {\n-        acc.add_field(ctx, field, substs);\n+    for (field, field_ty) in ty.variant_fields(ctx.db, variant) {\n+        acc.add_field(ctx, field, &field_ty);\n     }\n }\n ", "previous_filename": "crates/ra_ide_api/src/completion/complete_record_literal.rs"}, {"sha": "a56c7e3a1fca7b2c7bc08822bf78d16aafb6c955", "filename": "crates/ra_ide/src/completion/complete_record_pattern.rs", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,7 +1,5 @@\n //! FIXME: write short doc here\n \n-use hir::Substs;\n-\n use crate::completion::{CompletionContext, Completions};\n \n pub(super) fn complete_record_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -14,10 +12,9 @@ pub(super) fn complete_record_pattern(acc: &mut Completions, ctx: &CompletionCon\n         Some(it) => it,\n         _ => return,\n     };\n-    let substs = &ty.substs().unwrap_or_else(Substs::empty);\n \n-    for field in variant.fields(ctx.db) {\n-        acc.add_field(ctx, field, substs);\n+    for (field, field_ty) in ty.variant_fields(ctx.db, variant) {\n+        acc.add_field(ctx, field, &field_ty);\n     }\n }\n ", "previous_filename": "crates/ra_ide_api/src/completion/complete_record_pattern.rs"}, {"sha": "d5739b58a6d759741360c196397b18821c332fc5", "filename": "crates/ra_ide/src/completion/complete_scope.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/completion/complete_scope.rs"}, {"sha": "1f2988b36bfce62290beedc4e3851941d28040f7", "filename": "crates/ra_ide/src/completion/complete_snippet.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/completion/complete_snippet.rs"}, {"sha": "b8345c91d521b7d45cbbacf96fcd6caae4b37b88", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/completion/completion_context.rs"}, {"sha": "93f336370915a11db85079b13285655faacbbefa", "filename": "crates/ra_ide/src/completion/completion_item.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/completion/completion_item.rs"}, {"sha": "97475fc0bbe8f2c77082aa3370c53b0f07df9d68", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "renamed", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,12 +1,12 @@\n //! This modules takes care of rendering various definitions as completion items.\n \n-use hir::{db::HirDatabase, Docs, HasAttrs, HasSource, HirDisplay, ScopeDef, Ty, TypeWalk};\n+use hir::{db::HirDatabase, Docs, HasAttrs, HasSource, HirDisplay, ScopeDef, Type};\n use join_to_string::join;\n use ra_syntax::ast::NameOwner;\n use test_utils::tested_by;\n \n use crate::completion::{\n-    db, CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n+    CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n };\n \n use crate::display::{const_label, function_label, macro_label, type_label};\n@@ -16,7 +16,7 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext,\n         field: hir::StructField,\n-        substs: &hir::Substs,\n+        ty: &Type,\n     ) {\n         let is_deprecated = is_deprecated(field, ctx.db);\n         CompletionItem::new(\n@@ -25,13 +25,13 @@ impl Completions {\n             field.name(ctx.db).to_string(),\n         )\n         .kind(CompletionItemKind::Field)\n-        .detail(field.ty(ctx.db).subst(substs).display(ctx.db).to_string())\n+        .detail(ty.display(ctx.db).to_string())\n         .set_documentation(field.docs(ctx.db))\n         .set_deprecated(is_deprecated)\n         .add_to(self);\n     }\n \n-    pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext, field: usize, ty: &hir::Ty) {\n+    pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext, field: usize, ty: &Type) {\n         CompletionItem::new(CompletionKind::Reference, ctx.source_range(), field.to_string())\n             .kind(CompletionItemKind::Field)\n             .detail(ty.display(ctx.db).to_string())\n@@ -98,7 +98,7 @@ impl Completions {\n             CompletionItem::new(completion_kind, ctx.source_range(), local_name.clone());\n         if let ScopeDef::Local(local) = resolution {\n             let ty = local.ty(ctx.db);\n-            if ty != Ty::Unknown {\n+            if !ty.is_unknown() {\n                 completion_item = completion_item.detail(ty.display(ctx.db).to_string());\n             }\n         };\n@@ -108,19 +108,17 @@ impl Completions {\n             && !ctx.has_type_args\n             && ctx.db.feature_flags.get(\"completion.insertion.add-call-parenthesis\")\n         {\n-            let generic_def: Option<hir::GenericDef> = match resolution {\n-                ScopeDef::ModuleDef(Adt(it)) => Some((*it).into()),\n-                ScopeDef::ModuleDef(TypeAlias(it)) => Some((*it).into()),\n-                _ => None,\n+            let has_non_default_type_params = match resolution {\n+                ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(ctx.db),\n+                ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(ctx.db),\n+                _ => false,\n             };\n-            if let Some(def) = generic_def {\n-                if has_non_default_type_params(def, ctx.db) {\n-                    tested_by!(inserts_angle_brackets_for_generics);\n-                    completion_item = completion_item\n-                        .lookup_by(local_name.clone())\n-                        .label(format!(\"{}<\u2026>\", local_name))\n-                        .insert_snippet(format!(\"{}<$0>\", local_name));\n-                }\n+            if has_non_default_type_params {\n+                tested_by!(inserts_angle_brackets_for_generics);\n+                completion_item = completion_item\n+                    .lookup_by(local_name.clone())\n+                    .label(format!(\"{}<\u2026>\", local_name))\n+                    .insert_snippet(format!(\"{}<$0>\", local_name));\n             }\n         }\n \n@@ -269,10 +267,7 @@ impl Completions {\n \n     pub(crate) fn add_enum_variant(&mut self, ctx: &CompletionContext, variant: hir::EnumVariant) {\n         let is_deprecated = is_deprecated(variant, ctx.db);\n-        let name = match variant.name(ctx.db) {\n-            Some(it) => it,\n-            None => return,\n-        };\n+        let name = variant.name(ctx.db);\n         let detail_types = variant.fields(ctx.db).into_iter().map(|field| field.ty(ctx.db));\n         let detail = join(detail_types.map(|t| t.display(ctx.db).to_string()))\n             .separator(\", \")\n@@ -291,11 +286,6 @@ fn is_deprecated(node: impl HasAttrs, db: &impl HirDatabase) -> bool {\n     node.attrs(db).by_key(\"deprecated\").exists()\n }\n \n-fn has_non_default_type_params(def: hir::GenericDef, db: &db::RootDatabase) -> bool {\n-    let subst = db.generic_defaults(def);\n-    subst.iter().any(|ty| ty == &Ty::Unknown)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;", "previous_filename": "crates/ra_ide_api/src/completion/presentation.rs"}, {"sha": "f739ebecd3b6541a0b28a94000b1f89c0ccb3b22", "filename": "crates/ra_ide/src/db.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdb.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -65,6 +65,9 @@ impl salsa::Database for RootDatabase {\n     fn salsa_runtime(&self) -> &salsa::Runtime<RootDatabase> {\n         &self.runtime\n     }\n+    fn salsa_runtime_mut(&mut self) -> &mut salsa::Runtime<Self> {\n+        &mut self.runtime\n+    }\n     fn on_propagated_panic(&self) -> ! {\n         Canceled::throw()\n     }", "previous_filename": "crates/ra_ide_api/src/db.rs"}, {"sha": "cc1ccab4b5fa39325f02117ef83130eee3783f63", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/diagnostics.rs"}, {"sha": "30617412a6dfa459ea3af8b85383761ccf37577c", "filename": "crates/ra_ide/src/display.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/display.rs"}, {"sha": "324ad95526d655c51c467ceae58ae97faa2dfefc", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -93,12 +93,9 @@ impl FunctionSignature {\n             _ => (),\n         };\n \n-        let parent_name = match variant.parent_enum(db).name(db) {\n-            Some(name) => name.to_string(),\n-            None => \"missing\".into(),\n-        };\n+        let parent_name = variant.parent_enum(db).name(db).to_string();\n \n-        let name = format!(\"{}::{}\", parent_name, variant.name(db).unwrap());\n+        let name = format!(\"{}::{}\", parent_name, variant.name(db));\n \n         let params = variant\n             .fields(db)", "previous_filename": "crates/ra_ide_api/src/display/function_signature.rs"}, {"sha": "6ac60722b9a00a37afa32776b8515e3052091426", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/display/navigation_target.rs"}, {"sha": "9ffc9b980140d586e1bb4f3547bc77165d6e8447", "filename": "crates/ra_ide/src/display/short_label.rs", "status": "renamed", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -19,6 +19,12 @@ impl ShortLabel for ast::StructDef {\n     }\n }\n \n+impl ShortLabel for ast::UnionDef {\n+    fn short_label(&self) -> Option<String> {\n+        short_label_from_node(self, \"union \")\n+    }\n+}\n+\n impl ShortLabel for ast::EnumDef {\n     fn short_label(&self) -> Option<String> {\n         short_label_from_node(self, \"enum \")", "previous_filename": "crates/ra_ide_api/src/display/short_label.rs"}, {"sha": "a80d65ac714f180b518e86ba1459d7e91d6bca98", "filename": "crates/ra_ide/src/display/structure.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/display/structure.rs"}, {"sha": "2f1abf509a00549b1359cef237341023a30ec8b9", "filename": "crates/ra_ide/src/expand.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/expand.rs"}, {"sha": "abc602244cab961785eafc592590da1ad064e64a", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "renamed", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -269,4 +269,27 @@ fn some_thing() -> u32 {\n         assert_eq!(res.name, \"foo\");\n         assert_snapshot!(res.expansion, @r###\"bar!()\"###);\n     }\n+\n+    #[test]\n+    fn macro_expand_with_dollar_crate() {\n+        let res = check_expand_macro(\n+            r#\"\n+        //- /lib.rs\n+        #[macro_export]\n+        macro_rules! bar {\n+            () => {0};\n+        }\n+        macro_rules! foo {\n+            () => {$crate::bar!()};\n+        }        \n+\n+        fn main() {        \n+            let res = fo<|>o!();\n+        }\n+        \"#,\n+        );\n+\n+        assert_eq!(res.name, \"foo\");\n+        assert_snapshot!(res.expansion, @r###\"0\"###);\n+    }\n }", "previous_filename": "crates/ra_ide_api/src/expand_macro.rs"}, {"sha": "4b7bfc0b11e8a3b8838547a4f159f7cc9c9145a4", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/extend_selection.rs"}, {"sha": "de4ae513d134029153d9735fb01c4baff05a321b", "filename": "crates/ra_ide/src/feature_flags.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Ffeature_flags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Ffeature_flags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ffeature_flags.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/feature_flags.rs"}, {"sha": "4eeb76d1437f4f1f25ce9759d4df105a6a20bd76", "filename": "crates/ra_ide/src/folding_ranges.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/folding_ranges.rs"}, {"sha": "c10a6c8448dd18555a87227ed9a5f158354960bc", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "renamed", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -71,10 +71,11 @@ pub(crate) fn reference_definition(\n             Some(nav) => return Exact(nav),\n             None => return Approximate(vec![]),\n         },\n-        Some(SelfType(ty)) => {\n-            if let Some((adt, _)) = ty.as_adt() {\n-                return Exact(adt.to_nav(db));\n-            }\n+        Some(SelfType(imp)) => {\n+            // FIXME: ideally, this should point to the type in the impl, and\n+            // not at the whole impl. And goto **type** definition should bring\n+            // us to the actual type\n+            return Exact(imp.to_nav(db));\n         }\n         Some(Local(local)) => return Exact(local.to_nav(db)),\n         Some(GenericParam(_)) => {\n@@ -503,7 +504,7 @@ mod tests {\n                 }\n             }\n             \",\n-            \"Foo STRUCT_DEF FileId(1) [0; 11) [7; 10)\",\n+            \"impl IMPL_BLOCK FileId(1) [12; 73)\",\n         );\n \n         check_goto(\n@@ -516,7 +517,7 @@ mod tests {\n                 }\n             }\n             \",\n-            \"Foo STRUCT_DEF FileId(1) [0; 11) [7; 10)\",\n+            \"impl IMPL_BLOCK FileId(1) [12; 73)\",\n         );\n \n         check_goto(\n@@ -529,7 +530,7 @@ mod tests {\n                 }\n             }\n             \",\n-            \"Foo ENUM_DEF FileId(1) [0; 14) [5; 8)\",\n+            \"impl IMPL_BLOCK FileId(1) [15; 75)\",\n         );\n \n         check_goto(\n@@ -541,7 +542,7 @@ mod tests {\n                 }\n             }\n             \",\n-            \"Foo ENUM_DEF FileId(1) [0; 14) [5; 8)\",\n+            \"impl IMPL_BLOCK FileId(1) [15; 62)\",\n         );\n     }\n \n@@ -560,7 +561,7 @@ mod tests {\n                 }\n             }\n             \",\n-            \"Foo STRUCT_DEF FileId(1) [0; 11) [7; 10)\",\n+            \"impl IMPL_BLOCK FileId(1) [49; 115)\",\n         );\n \n         check_goto(\n@@ -572,11 +573,11 @@ mod tests {\n             }\n             impl Make for Foo {\n                 fn new() -> Self<|> {\n-                    Self{}\n+                    Self {}\n                 }\n             }\n             \",\n-            \"Foo STRUCT_DEF FileId(1) [0; 11) [7; 10)\",\n+            \"impl IMPL_BLOCK FileId(1) [49; 115)\",\n         );\n     }\n ", "previous_filename": "crates/ra_ide_api/src/goto_definition.rs"}, {"sha": "992a088090126c07364348ba6b76a28f8c7e2dc9", "filename": "crates/ra_ide/src/goto_type_definition.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -24,7 +24,7 @@ pub(crate) fn goto_type_definition(\n \n     let analyzer = hir::SourceAnalyzer::new(db, token.with_value(&node), None);\n \n-    let ty: hir::Ty = if let Some(ty) =\n+    let ty: hir::Type = if let Some(ty) =\n         ast::Expr::cast(node.clone()).and_then(|e| analyzer.type_of(db, &e))\n     {\n         ty\n@@ -35,7 +35,7 @@ pub(crate) fn goto_type_definition(\n         return None;\n     };\n \n-    let adt_def = analyzer.autoderef(db, ty).find_map(|ty| ty.as_adt().map(|adt| adt.0))?;\n+    let adt_def = ty.autoderef(db).find_map(|ty| ty.as_adt())?;\n \n     let nav = adt_def.to_nav(db);\n     Some(RangeInfo::new(node.text_range(), vec![nav]))", "previous_filename": "crates/ra_ide_api/src/goto_type_definition.rs"}, {"sha": "260a7b86947888b9df1241413f93418218201b64", "filename": "crates/ra_ide/src/hover.rs", "status": "renamed", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -133,20 +133,12 @@ fn hover_text_from_name_kind(\n             hir::ModuleDef::TypeAlias(it) => from_def_source(db, it),\n             hir::ModuleDef::BuiltinType(it) => Some(it.to_string()),\n         },\n-        SelfType(ty) => match ty.as_adt() {\n-            Some((adt_def, _)) => match adt_def {\n-                hir::Adt::Struct(it) => from_def_source(db, it),\n-                hir::Adt::Union(it) => from_def_source(db, it),\n-                hir::Adt::Enum(it) => from_def_source(db, it),\n-            },\n-            _ => None,\n-        },\n         Local(_) => {\n             // Hover for these shows type names\n             *no_fallback = true;\n             None\n         }\n-        GenericParam(_) => {\n+        GenericParam(_) | SelfType(_) => {\n             // FIXME: Hover for generic param\n             None\n         }\n@@ -622,49 +614,52 @@ fn func(foo: i32) { if true { <|>foo; }; }\n         \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"struct Thing\"));\n-        assert_eq!(hover.info.is_exact(), true);\n-\n-        let (analysis, position) = single_file_with_position(\n-            \"\n-            struct Thing { x: u32 }\n-            impl Thing {\n-                fn new() -> Self<|> {\n-                    Self { x: 0 }\n-                }\n-            }\n-            \",\n-        );\n-        let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"struct Thing\"));\n-        assert_eq!(hover.info.is_exact(), true);\n-\n-        let (analysis, position) = single_file_with_position(\n-            \"\n-            enum Thing { A }\n-            impl Thing {\n-                pub fn new() -> Self<|> {\n-                    Thing::A\n-                }\n-            }\n-            \",\n-        );\n-        let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"enum Thing\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"Thing\"));\n         assert_eq!(hover.info.is_exact(), true);\n \n-        let (analysis, position) = single_file_with_position(\n-            \"\n-            enum Thing { A }\n-            impl Thing {\n-                pub fn thing(a: Self<|>) {\n-                }\n-            }\n-            \",\n-        );\n-        let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"enum Thing\"));\n-        assert_eq!(hover.info.is_exact(), true);\n+        /* FIXME: revive these tests\n+                let (analysis, position) = single_file_with_position(\n+                    \"\n+                    struct Thing { x: u32 }\n+                    impl Thing {\n+                        fn new() -> Self<|> {\n+                            Self { x: 0 }\n+                        }\n+                    }\n+                    \",\n+                );\n+\n+                let hover = analysis.hover(position).unwrap().unwrap();\n+                assert_eq!(trim_markup_opt(hover.info.first()), Some(\"Thing\"));\n+                assert_eq!(hover.info.is_exact(), true);\n+\n+                let (analysis, position) = single_file_with_position(\n+                    \"\n+                    enum Thing { A }\n+                    impl Thing {\n+                        pub fn new() -> Self<|> {\n+                            Thing::A\n+                        }\n+                    }\n+                    \",\n+                );\n+                let hover = analysis.hover(position).unwrap().unwrap();\n+                assert_eq!(trim_markup_opt(hover.info.first()), Some(\"enum Thing\"));\n+                assert_eq!(hover.info.is_exact(), true);\n+\n+                let (analysis, position) = single_file_with_position(\n+                    \"\n+                    enum Thing { A }\n+                    impl Thing {\n+                        pub fn thing(a: Self<|>) {\n+                        }\n+                    }\n+                    \",\n+                );\n+                let hover = analysis.hover(position).unwrap().unwrap();\n+                assert_eq!(trim_markup_opt(hover.info.first()), Some(\"enum Thing\"));\n+                assert_eq!(hover.info.is_exact(), true);\n+        */\n     }\n \n     #[test]", "previous_filename": "crates/ra_ide_api/src/hover.rs"}, {"sha": "aa480e399b2fbdec548dc8840c3e7a5bd308aa58", "filename": "crates/ra_ide/src/impls.rs", "status": "renamed", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fimpls.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{db::HirDatabase, ApplicationTy, FromSource, Ty, TypeCtor};\n+use hir::{FromSource, ImplBlock};\n use ra_db::SourceDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n \n@@ -49,15 +49,19 @@ fn impls_for_def(\n             let src = hir::Source { file_id: position.file_id.into(), value: def.clone() };\n             hir::Enum::from_source(db, src)?.ty(db)\n         }\n+        ast::NominalDef::UnionDef(def) => {\n+            let src = hir::Source { file_id: position.file_id.into(), value: def.clone() };\n+            hir::Union::from_source(db, src)?.ty(db)\n+        }\n     };\n \n     let krate = module.krate();\n-    let impls = db.impls_in_crate(krate);\n+    let impls = ImplBlock::all_in_crate(db, krate);\n \n     Some(\n         impls\n-            .all_impls()\n-            .filter(|impl_block| is_equal_for_find_impls(&ty, &impl_block.target_ty(db)))\n+            .into_iter()\n+            .filter(|impl_block| ty.is_equal_for_find_impls(&impl_block.target_ty(db)))\n             .map(|imp| imp.to_nav(db))\n             .collect(),\n     )\n@@ -73,22 +77,9 @@ fn impls_for_trait(\n     let tr = hir::Trait::from_source(db, src)?;\n \n     let krate = module.krate();\n-    let impls = db.impls_in_crate(krate);\n+    let impls = ImplBlock::for_trait(db, krate, tr);\n \n-    Some(impls.lookup_impl_blocks_for_trait(tr).map(|imp| imp.to_nav(db)).collect())\n-}\n-\n-fn is_equal_for_find_impls(original_ty: &Ty, impl_ty: &Ty) -> bool {\n-    match (original_ty, impl_ty) {\n-        (Ty::Apply(a_original_ty), Ty::Apply(ApplicationTy { ctor, parameters })) => match ctor {\n-            TypeCtor::Ref(..) => match parameters.as_single() {\n-                Ty::Apply(a_ty) => a_original_ty.ctor == a_ty.ctor,\n-                _ => false,\n-            },\n-            _ => a_original_ty.ctor == *ctor,\n-        },\n-        _ => false,\n-    }\n+    Some(impls.into_iter().map(|imp| imp.to_nav(db)).collect())\n }\n \n #[cfg(test)]", "previous_filename": "crates/ra_ide_api/src/impls.rs"}, {"sha": "45149bf0cc10537cdab6ebe7177b8c938fb1f219", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "renamed", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n use crate::{db::RootDatabase, FileId};\n-use hir::{HirDisplay, SourceAnalyzer, Ty};\n+use hir::{HirDisplay, SourceAnalyzer};\n use ra_syntax::{\n     ast::{self, AstNode, TypeAscriptionOwner},\n     match_ast, SmolStr, SourceFile, SyntaxKind, SyntaxNode, TextRange,\n@@ -100,8 +100,11 @@ fn get_pat_type_hints(\n         .into_iter()\n         .filter(|pat| !skip_root_pat_hint || pat != original_pat)\n         .filter_map(|pat| {\n-            get_node_displayable_type(db, &analyzer, &pat)\n-                .map(|pat_type| (pat.syntax().text_range(), pat_type))\n+            let ty = analyzer.type_of_pat(db, &pat)?;\n+            if ty.is_unknown() {\n+                return None;\n+            }\n+            Some((pat.syntax().text_range(), ty))\n         })\n         .map(|(range, pat_type)| InlayHint {\n             range,\n@@ -158,20 +161,6 @@ fn get_leaf_pats(root_pat: ast::Pat) -> Vec<ast::Pat> {\n     leaf_pats\n }\n \n-fn get_node_displayable_type(\n-    db: &RootDatabase,\n-    analyzer: &SourceAnalyzer,\n-    node_pat: &ast::Pat,\n-) -> Option<Ty> {\n-    analyzer.type_of_pat(db, node_pat).and_then(|resolved_type| {\n-        if let Ty::Apply(_) = resolved_type {\n-            Some(resolved_type)\n-        } else {\n-            None\n-        }\n-    })\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::mock_analysis::single_file;", "previous_filename": "crates/ra_ide_api/src/inlay_hints.rs"}, {"sha": "7deeb34947aceea7eb5a0fca825560d7f1d368d6", "filename": "crates/ra_ide/src/join_lines.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/join_lines.rs"}, {"sha": "d1bff4a761eb8be29bdc95c526cda036578b14b9", "filename": "crates/ra_ide/src/lib.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,4 +1,4 @@\n-//! ra_ide_api crate provides \"ide-centric\" APIs for the rust-analyzer. That is,\n+//! ra_ide crate provides \"ide-centric\" APIs for the rust-analyzer. That is,\n //! it generally operates with files and text ranges, and returns results as\n //! Strings, suitable for displaying to the human.\n //!", "previous_filename": "crates/ra_ide_api/src/lib.rs"}, {"sha": "710890d27dcf585aa8461b342ecf76a2fd6b49e2", "filename": "crates/ra_ide/src/line_index.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fline_index.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/line_index.rs"}, {"sha": "bd1e08feba435f0d0de24336587dc7b8cb9659fb", "filename": "crates/ra_ide/src/line_index_utils.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fline_index_utils.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/line_index_utils.rs"}, {"sha": "848ae4dc743e81a23bfd7b40267a32dee52afbc1", "filename": "crates/ra_ide/src/marks.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarks.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/marks.rs"}, {"sha": "d1204fac018bc191784b6db880a70596f72d563a", "filename": "crates/ra_ide/src/matching_brace.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/matching_brace.rs"}, {"sha": "bf8a5493242d1605d211925846f1baa4a14cbeff", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/mock_analysis.rs"}, {"sha": "6027e7d54d143741d79d525f9a4ef287aeb694b7", "filename": "crates/ra_ide/src/parent_module.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fparent_module.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/parent_module.rs"}, {"sha": "21a1ea69ebbd48796c4e49f3b8bc55e7b68f09b0", "filename": "crates/ra_ide/src/references.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -83,10 +83,7 @@ pub(crate) fn find_all_refs(\n         NameKind::Field(field) => field.to_nav(db),\n         NameKind::AssocItem(assoc) => assoc.to_nav(db),\n         NameKind::Def(def) => NavigationTarget::from_def(db, def)?,\n-        NameKind::SelfType(ref ty) => match ty.as_adt() {\n-            Some((adt, _)) => adt.to_nav(db),\n-            None => return None,\n-        },\n+        NameKind::SelfType(imp) => imp.to_nav(db),\n         NameKind::Local(local) => local.to_nav(db),\n         NameKind::GenericParam(_) => return None,\n     };", "previous_filename": "crates/ra_ide_api/src/references.rs"}, {"sha": "5cea805ec92af66180f8b300f72f60cbc8d0c0a5", "filename": "crates/ra_ide/src/references/classify.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -152,7 +152,7 @@ pub(crate) fn classify_name_ref(\n \n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n         tested_by!(goto_definition_works_for_macros);\n-        if let Some(macro_def) = analyzer.resolve_macro_call(db, &macro_call) {\n+        if let Some(macro_def) = analyzer.resolve_macro_call(db, name_ref.with_value(&macro_call)) {\n             let kind = NameKind::Macro(macro_def);\n             return Some(NameDefinition { kind, container, visibility });\n         }\n@@ -178,8 +178,7 @@ pub(crate) fn classify_name_ref(\n             Some(NameDefinition { kind, container, visibility })\n         }\n         PathResolution::SelfType(impl_block) => {\n-            let ty = impl_block.target_ty(db);\n-            let kind = NameKind::SelfType(ty);\n+            let kind = NameKind::SelfType(impl_block);\n             let container = impl_block.module(db);\n             Some(NameDefinition { kind, container, visibility })\n         }", "previous_filename": "crates/ra_ide_api/src/references/classify.rs"}, {"sha": "10d3a2364c1a2e6ffc52a31844bce36b28b561df", "filename": "crates/ra_ide/src/references/name_definition.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -4,8 +4,8 @@\n //! Note that the reference search is possible for not all of the classified items.\n \n use hir::{\n-    Adt, AssocItem, GenericParam, HasSource, Local, MacroDef, Module, ModuleDef, StructField, Ty,\n-    VariantDef,\n+    Adt, AssocItem, GenericParam, HasSource, ImplBlock, Local, MacroDef, Module, ModuleDef,\n+    StructField, VariantDef,\n };\n use ra_syntax::{ast, ast::VisibilityOwner};\n \n@@ -17,7 +17,7 @@ pub enum NameKind {\n     Field(StructField),\n     AssocItem(AssocItem),\n     Def(ModuleDef),\n-    SelfType(Ty),\n+    SelfType(ImplBlock),\n     Local(Local),\n     GenericParam(GenericParam),\n }\n@@ -46,6 +46,7 @@ pub(super) fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDe\n     let container = parent.module(db);\n     let visibility = match parent {\n         VariantDef::Struct(s) => s.source(db).value.visibility(),\n+        VariantDef::Union(e) => e.source(db).value.visibility(),\n         VariantDef::EnumVariant(e) => e.source(db).value.parent_enum().visibility(),\n     };\n     NameDefinition { kind, container, visibility }", "previous_filename": "crates/ra_ide_api/src/references/name_definition.rs"}, {"sha": "d58496049e21a9125d479f5ff72e73df9da18f1d", "filename": "crates/ra_ide/src/references/rename.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/references/rename.rs"}, {"sha": "f5c9589f4d17257f17c34caa4c7bc45c51aea20c", "filename": "crates/ra_ide/src/references/search_scope.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/references/search_scope.rs"}, {"sha": "8039a5164ebf9eb5b5af82819cd0234c0edbe8f5", "filename": "crates/ra_ide/src/runnables.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/runnables.rs"}, {"sha": "b39c4d3717a7ad89efab4c42c15f5199bf8d6c82", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/snapshots/highlighting.html"}, {"sha": "79f11ea80ccfa4bfaa0589506df43f9653e81f26", "filename": "crates/ra_ide/src/snapshots/rainbow_highlighting.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/snapshots/rainbow_highlighting.html"}, {"sha": "f5f7f8807c4425c1661c323f207854e71241bf8d", "filename": "crates/ra_ide/src/source_change.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsource_change.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/source_change.rs"}, {"sha": "1bb27eb8512345760ce173f3ae44c3fba35833ac", "filename": "crates/ra_ide/src/status.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fstatus.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/status.rs"}, {"sha": "5729eb5b3dc1209049143163251bbbe5cd8f0b9b", "filename": "crates/ra_ide/src/symbol_index.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsymbol_index.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/symbol_index.rs"}, {"sha": "9a3e4c82f65a4438f5e466b6c8899bac327fbda9", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "renamed", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_hash::{FxHashMap, FxHashSet};\n \n-use hir::{Mutability, Name, Source};\n+use hir::{Name, Source};\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxKind::*, TextRange, T};\n@@ -230,11 +230,10 @@ fn highlight_name(db: &RootDatabase, name_kind: NameKind) -> &'static str {\n         Local(local) => {\n             if local.is_mut(db) {\n                 \"variable.mut\"\n+            } else if local.ty(db).is_mutable_reference() {\n+                \"variable.mut\"\n             } else {\n-                match local.ty(db).as_reference() {\n-                    Some((_, Mutability::Mut)) => \"variable.mut\",\n-                    _ => \"variable\",\n-                }\n+                \"variable\"\n             }\n         }\n     }\n@@ -307,7 +306,7 @@ fn main() {\n \"#\n             .trim(),\n         );\n-        let dst_file = project_dir().join(\"crates/ra_ide_api/src/snapshots/highlighting.html\");\n+        let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/highlighting.html\");\n         let actual_html = &analysis.highlight_as_html(file_id, false).unwrap();\n         let expected_html = &read_text(&dst_file);\n         std::fs::write(dst_file, &actual_html).unwrap();\n@@ -333,8 +332,7 @@ fn bar() {\n \"#\n             .trim(),\n         );\n-        let dst_file =\n-            project_dir().join(\"crates/ra_ide_api/src/snapshots/rainbow_highlighting.html\");\n+        let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/rainbow_highlighting.html\");\n         let actual_html = &analysis.highlight_as_html(file_id, true).unwrap();\n         let expected_html = &read_text(&dst_file);\n         std::fs::write(dst_file, &actual_html).unwrap();", "previous_filename": "crates/ra_ide_api/src/syntax_highlighting.rs"}, {"sha": "4d0f0fc47d02846a64e64aed09dbc9241954b701", "filename": "crates/ra_ide/src/syntax_tree.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/syntax_tree.rs"}, {"sha": "8adb214d4cc1c2dbe473f30436d2f2d9657136ec", "filename": "crates/ra_ide/src/test_utils.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftest_utils.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/test_utils.rs"}, {"sha": "21e5be9b3838ede54aff686e9cb4516cc8303881", "filename": "crates/ra_ide/src/typing.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/typing.rs"}, {"sha": "088cc9be40f10639d744a60c43438365aec15d71", "filename": "crates/ra_ide/src/wasm_shims.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fwasm_shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_ide%2Fsrc%2Fwasm_shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fwasm_shims.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "previous_filename": "crates/ra_ide_api/src/wasm_shims.rs"}, {"sha": "21aef842ce61cc3626a77bf47f1654a7388f42c8", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -17,12 +17,12 @@ flexi_logger = \"0.14.0\"\n log = \"0.4.3\"\n lsp-types = { version = \"0.61.0\", features = [\"proposed\"] }\n rustc-hash = \"1.0\"\n-parking_lot = \"0.9.0\"\n+parking_lot = \"0.10.0\"\n jod-thread = \"0.1.0\"\n ra_vfs = \"0.5.0\"\n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n-ra_ide_api = { path = \"../ra_ide_api\" }\n+ra_ide = { path = \"../ra_ide\" }\n lsp-server = \"0.3.0\"\n ra_project_model = { path = \"../ra_project_model\" }\n ra_prof = { path = \"../ra_prof\" }"}, {"sha": "c4a9e71018f30eb4842484c657149079cab0d10c", "filename": "crates/ra_lsp_server/src/cargo_target_spec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_ide_api::{FileId, RunnableKind};\n+use ra_ide::{FileId, RunnableKind};\n use ra_project_model::{self, ProjectWorkspace, TargetKind};\n \n use crate::{world::WorldSnapshot, Result};"}, {"sha": "b13093cfe65d9d664ef5dbc3d4653364ec7077c9", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -6,7 +6,7 @@ use lsp_types::{\n     SymbolKind, TextDocumentEdit, TextDocumentIdentifier, TextDocumentItem,\n     TextDocumentPositionParams, Url, VersionedTextDocumentIdentifier, WorkspaceEdit,\n };\n-use ra_ide_api::{\n+use ra_ide::{\n     translate_offset_with_edit, CompletionItem, CompletionItemKind, FileId, FilePosition,\n     FileRange, FileSystemEdit, Fold, FoldKind, InsertTextFormat, LineCol, LineIndex,\n     NavigationTarget, RangeInfo, Severity, SourceChange, SourceFileEdit,\n@@ -173,7 +173,7 @@ impl ConvWith<&LineIndex> for Range {\n     }\n }\n \n-impl Conv for ra_ide_api::Documentation {\n+impl Conv for ra_ide::Documentation {\n     type Output = lsp_types::Documentation;\n     fn conv(self) -> Documentation {\n         Documentation::MarkupContent(MarkupContent {\n@@ -183,7 +183,7 @@ impl Conv for ra_ide_api::Documentation {\n     }\n }\n \n-impl Conv for ra_ide_api::FunctionSignature {\n+impl Conv for ra_ide::FunctionSignature {\n     type Output = lsp_types::SignatureInformation;\n     fn conv(self) -> Self::Output {\n         use lsp_types::{ParameterInformation, ParameterLabel, SignatureInformation};"}, {"sha": "2ca149fd56b82738216a6eaf665869a97740f785", "filename": "crates/ra_lsp_server/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Flib.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,6 +1,6 @@\n //! Implementation of the LSP for rust-analyzer.\n //!\n-//! This crate takes Rust-specific analysis results from ra_ide_api and\n+//! This crate takes Rust-specific analysis results from ra_ide and\n //! translates into LSP types.\n //!\n //! It also is the root of all state. `world` module defines the bulk of the"}, {"sha": "83845f1e006e5dda0b03120b0e866e1a3e8b4fa7", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -9,7 +9,7 @@ use std::{error::Error, fmt, panic, path::PathBuf, sync::Arc, time::Instant};\n use crossbeam_channel::{select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{ClientCapabilities, NumberOrString};\n-use ra_ide_api::{Canceled, FeatureFlags, FileId, LibraryData, SourceRootId};\n+use ra_ide::{Canceled, FeatureFlags, FileId, LibraryData, SourceRootId};\n use ra_prof::profile;\n use ra_vfs::{VfsTask, Watch};\n use relative_path::RelativePathBuf;"}, {"sha": "c81fa7f679c1675d7fce4abc1498f38f1d2d71de", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -9,7 +9,7 @@ use lsp_types::{\n     Hover, HoverContents, Location, MarkupContent, MarkupKind, Position, PrepareRenameResponse,\n     Range, RenameParams, SymbolInformation, TextDocumentIdentifier, TextEdit, WorkspaceEdit,\n };\n-use ra_ide_api::{\n+use ra_ide::{\n     AssistId, FileId, FilePosition, FileRange, Query, Runnable, RunnableKind, SearchScope,\n };\n use ra_prof::profile;\n@@ -162,7 +162,7 @@ pub fn handle_on_type_formatting(\n     let line_index = world.analysis().file_line_index(position.file_id)?;\n     let line_endings = world.file_line_endings(position.file_id);\n \n-    // in `ra_ide_api`, the `on_type` invariant is that\n+    // in `ra_ide`, the `on_type` invariant is that\n     // `text.char_at(position) == typed_char`.\n     position.offset = position.offset - TextUnit::of_char('.');\n     let char_typed = params.ch.chars().next().unwrap_or('\\0');\n@@ -894,7 +894,7 @@ pub fn handle_inlay_hints(\n             label: api_type.label.to_string(),\n             range: api_type.range.conv_with(&line_index),\n             kind: match api_type.kind {\n-                ra_ide_api::InlayKind::TypeHint => InlayKind::TypeHint,\n+                ra_ide::InlayKind::TypeHint => InlayKind::TypeHint,\n             },\n         })\n         .collect())"}, {"sha": "609b2adcc9904e29c50a89b19d66f1313870a2d3", "filename": "crates/ra_lsp_server/src/main_loop/subscriptions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_ide_api::FileId;\n+use ra_ide::FileId;\n use rustc_hash::FxHashSet;\n \n #[derive(Default, Debug)]"}, {"sha": "927449b45da7ed543338c3122306aaf5c09af572", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -9,7 +9,7 @@ use crossbeam_channel::{unbounded, Receiver};\n use lsp_server::ErrorCode;\n use lsp_types::Url;\n use parking_lot::RwLock;\n-use ra_ide_api::{\n+use ra_ide::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FeatureFlags, FileId, LibraryData,\n     SourceRootId,\n };"}, {"sha": "370990e21fd357b0c5b767cb08a30069f77114e2", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,13 +1,13 @@\n //! FIXME: write short doc here\n \n mod consts;\n-mod nominal;\n+mod adt;\n mod traits;\n mod use_item;\n \n pub(crate) use self::{\n+    adt::{enum_variant_list, record_field_def_list},\n     expressions::{match_arm_list, record_field_list},\n-    nominal::{enum_variant_list, record_field_def_list},\n     traits::{impl_item_list, trait_item_list},\n     use_item::use_tree_list,\n };\n@@ -247,7 +247,7 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n             //     a: i32,\n             //     b: f32,\n             // }\n-            nominal::struct_def(p, m, T![struct]);\n+            adt::struct_def(p, m);\n         }\n         IDENT if p.at_contextual_kw(\"union\") && p.nth(1) == IDENT => {\n             // test union_items\n@@ -256,9 +256,9 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n             //     a: i32,\n             //     b: f32,\n             // }\n-            nominal::struct_def(p, m, T![union]);\n+            adt::union_def(p, m);\n         }\n-        T![enum] => nominal::enum_def(p, m),\n+        T![enum] => adt::enum_def(p, m),\n         T![use] => use_item::use_item(p, m),\n         T![const] if (la == IDENT || la == T![_] || la == T![mut]) => consts::const_def(p, m),\n         T![static] => consts::static_def(p, m),"}, {"sha": "c777bc9d0042ae790283001abc6518a2172ed353", "filename": "crates/ra_parser/src/grammar/items/adt.rs", "status": "renamed", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -2,10 +2,19 @@\n \n use super::*;\n \n-pub(super) fn struct_def(p: &mut Parser, m: Marker, kind: SyntaxKind) {\n-    assert!(p.at(T![struct]) || p.at_contextual_kw(\"union\"));\n-    p.bump_remap(kind);\n+pub(super) fn struct_def(p: &mut Parser, m: Marker) {\n+    assert!(p.at(T![struct]));\n+    p.bump(T![struct]);\n+    struct_or_union(p, m, T![struct], STRUCT_DEF);\n+}\n+\n+pub(super) fn union_def(p: &mut Parser, m: Marker) {\n+    assert!(p.at_contextual_kw(\"union\"));\n+    p.bump_remap(T![union]);\n+    struct_or_union(p, m, T![union], UNION_DEF);\n+}\n \n+fn struct_or_union(p: &mut Parser, m: Marker, kw: SyntaxKind, def: SyntaxKind) {\n     name_r(p, ITEM_RECOVERY_SET);\n     type_params::opt_type_param_list(p);\n     match p.current() {\n@@ -22,26 +31,26 @@ pub(super) fn struct_def(p: &mut Parser, m: Marker, kind: SyntaxKind) {\n                 }\n             }\n         }\n-        T![;] if kind == T![struct] => {\n+        T![;] if kw == T![struct] => {\n             p.bump(T![;]);\n         }\n         T!['{'] => record_field_def_list(p),\n-        T!['('] if kind == T![struct] => {\n+        T!['('] if kw == T![struct] => {\n             tuple_field_def_list(p);\n             // test tuple_struct_where\n             // struct Test<T>(T) where T: Clone;\n             // struct Test<T>(T);\n             type_params::opt_where_clause(p);\n             p.expect(T![;]);\n         }\n-        _ if kind == T![struct] => {\n+        _ if kw == T![struct] => {\n             p.error(\"expected `;`, `{`, or `(`\");\n         }\n         _ => {\n             p.error(\"expected `{`\");\n         }\n     }\n-    m.complete(p, STRUCT_DEF);\n+    m.complete(p, def);\n }\n \n pub(super) fn enum_def(p: &mut Parser, m: Marker) {", "previous_filename": "crates/ra_parser/src/grammar/items/nominal.rs"}, {"sha": "fe0fcdb33f269cd75e8cc2430385adb562b2dbce", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -122,6 +122,7 @@ pub enum SyntaxKind {\n     R_DOLLAR,\n     SOURCE_FILE,\n     STRUCT_DEF,\n+    UNION_DEF,\n     ENUM_DEF,\n     FN_DEF,\n     RET_TYPE,"}, {"sha": "a8f6251762921f95970f1297cb50ee3f071aa19d", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -196,17 +196,6 @@ impl StructKind {\n }\n \n impl ast::StructDef {\n-    pub fn is_union(&self) -> bool {\n-        for child in self.syntax().children_with_tokens() {\n-            match child.kind() {\n-                T![struct] => return false,\n-                T![union] => return true,\n-                _ => (),\n-            }\n-        }\n-        false\n-    }\n-\n     pub fn kind(&self) -> StructKind {\n         StructKind::from_node(self)\n     }"}, {"sha": "c06076e3d7acbef3ae28ea7a35d4ce8bb4903095", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1856,6 +1856,7 @@ impl Module {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ModuleItem {\n     StructDef(StructDef),\n+    UnionDef(UnionDef),\n     EnumDef(EnumDef),\n     FnDef(FnDef),\n     TraitDef(TraitDef),\n@@ -1872,6 +1873,11 @@ impl From<StructDef> for ModuleItem {\n         ModuleItem::StructDef(node)\n     }\n }\n+impl From<UnionDef> for ModuleItem {\n+    fn from(node: UnionDef) -> ModuleItem {\n+        ModuleItem::UnionDef(node)\n+    }\n+}\n impl From<EnumDef> for ModuleItem {\n     fn from(node: EnumDef) -> ModuleItem {\n         ModuleItem::EnumDef(node)\n@@ -1925,14 +1931,15 @@ impl From<Module> for ModuleItem {\n impl AstNode for ModuleItem {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            STRUCT_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | TYPE_ALIAS_DEF | IMPL_BLOCK | USE_ITEM\n-            | EXTERN_CRATE_ITEM | CONST_DEF | STATIC_DEF | MODULE => true,\n+            STRUCT_DEF | UNION_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | TYPE_ALIAS_DEF\n+            | IMPL_BLOCK | USE_ITEM | EXTERN_CRATE_ITEM | CONST_DEF | STATIC_DEF | MODULE => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n             STRUCT_DEF => ModuleItem::StructDef(StructDef { syntax }),\n+            UNION_DEF => ModuleItem::UnionDef(UnionDef { syntax }),\n             ENUM_DEF => ModuleItem::EnumDef(EnumDef { syntax }),\n             FN_DEF => ModuleItem::FnDef(FnDef { syntax }),\n             TRAIT_DEF => ModuleItem::TraitDef(TraitDef { syntax }),\n@@ -1950,6 +1957,7 @@ impl AstNode for ModuleItem {\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n             ModuleItem::StructDef(it) => &it.syntax,\n+            ModuleItem::UnionDef(it) => &it.syntax,\n             ModuleItem::EnumDef(it) => &it.syntax,\n             ModuleItem::FnDef(it) => &it.syntax,\n             ModuleItem::TraitDef(it) => &it.syntax,\n@@ -2038,6 +2046,7 @@ impl NeverType {}\n pub enum NominalDef {\n     StructDef(StructDef),\n     EnumDef(EnumDef),\n+    UnionDef(UnionDef),\n }\n impl From<StructDef> for NominalDef {\n     fn from(node: StructDef) -> NominalDef {\n@@ -2049,17 +2058,23 @@ impl From<EnumDef> for NominalDef {\n         NominalDef::EnumDef(node)\n     }\n }\n+impl From<UnionDef> for NominalDef {\n+    fn from(node: UnionDef) -> NominalDef {\n+        NominalDef::UnionDef(node)\n+    }\n+}\n impl AstNode for NominalDef {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            STRUCT_DEF | ENUM_DEF => true,\n+            STRUCT_DEF | ENUM_DEF | UNION_DEF => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n             STRUCT_DEF => NominalDef::StructDef(StructDef { syntax }),\n             ENUM_DEF => NominalDef::EnumDef(EnumDef { syntax }),\n+            UNION_DEF => NominalDef::UnionDef(UnionDef { syntax }),\n             _ => return None,\n         };\n         Some(res)\n@@ -2068,6 +2083,7 @@ impl AstNode for NominalDef {\n         match self {\n             NominalDef::StructDef(it) => &it.syntax,\n             NominalDef::EnumDef(it) => &it.syntax,\n+            NominalDef::UnionDef(it) => &it.syntax,\n         }\n     }\n }\n@@ -3789,6 +3805,38 @@ impl AstNode for TypeRef {\n }\n impl TypeRef {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct UnionDef {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl AstNode for UnionDef {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            UNION_DEF => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        &self.syntax\n+    }\n+}\n+impl ast::VisibilityOwner for UnionDef {}\n+impl ast::NameOwner for UnionDef {}\n+impl ast::TypeParamsOwner for UnionDef {}\n+impl ast::AttrsOwner for UnionDef {}\n+impl ast::DocCommentsOwner for UnionDef {}\n+impl UnionDef {\n+    pub fn record_field_def_list(&self) -> Option<RecordFieldDefList> {\n+        AstChildren::new(&self.syntax).next()\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseItem {\n     pub(crate) syntax: SyntaxNode,\n }"}, {"sha": "d1be40abeb9690a54d8f90a3f50765cd9dfeccdf", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -126,6 +126,7 @@ Grammar(\n         \"SOURCE_FILE\",\n \n         \"STRUCT_DEF\",\n+        \"UNION_DEF\",\n         \"ENUM_DEF\",\n         \"FN_DEF\",\n         \"RET_TYPE\",\n@@ -285,6 +286,16 @@ Grammar(\n                 \"DocCommentsOwner\"\n             ]\n         ),\n+        \"UnionDef\": (\n+            traits: [\n+                \"VisibilityOwner\",\n+                \"NameOwner\",\n+                \"TypeParamsOwner\",\n+                \"AttrsOwner\",\n+                \"DocCommentsOwner\"\n+            ],\n+            options: [\"RecordFieldDefList\"],\n+        ),\n         \"RecordFieldDefList\": (collections: [(\"fields\", \"RecordFieldDef\")]),\n         \"RecordFieldDef\": (\n             traits: [\n@@ -388,17 +399,17 @@ Grammar(\n         ]),\n \n         \"NominalDef\": (\n-            enum: [\"StructDef\", \"EnumDef\"],\n+            enum: [\"StructDef\", \"EnumDef\", \"UnionDef\"],\n             traits: [\n                 \"NameOwner\",\n                 \"TypeParamsOwner\",\n                 \"AttrsOwner\"\n             ],\n         ),\n         \"ModuleItem\": (\n-            enum: [\"StructDef\", \"EnumDef\", \"FnDef\", \"TraitDef\", \"TypeAliasDef\", \"ImplBlock\",\n+            enum: [\"StructDef\", \"UnionDef\", \"EnumDef\", \"FnDef\", \"TraitDef\", \"TypeAliasDef\", \"ImplBlock\",\n                    \"UseItem\", \"ExternCrateItem\", \"ConstDef\", \"StaticDef\", \"Module\" ],\n-            traits: [\"AttrsOwner\"]\n+            traits: [\"AttrsOwner\"],\n         ),\n         \"ImplItem\": (\n             enum: [\"FnDef\", \"TypeAliasDef\", \"ConstDef\"],"}, {"sha": "9d798268463d1d959cb93f520225865380b5e917", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0068_union_items.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0068_union_items.txt", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0068_union_items.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0068_union_items.txt?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1,5 +1,5 @@\n SOURCE_FILE@[0; 51)\n-  STRUCT_DEF@[0; 12)\n+  UNION_DEF@[0; 12)\n     UNION_KW@[0; 5) \"union\"\n     WHITESPACE@[5; 6) \" \"\n     NAME@[6; 9)\n@@ -9,7 +9,7 @@ SOURCE_FILE@[0; 51)\n       L_CURLY@[10; 11) \"{\"\n       R_CURLY@[11; 12) \"}\"\n   WHITESPACE@[12; 13) \"\\n\"\n-  STRUCT_DEF@[13; 50)\n+  UNION_DEF@[13; 50)\n     UNION_KW@[13; 18) \"union\"\n     WHITESPACE@[18; 19) \" \"\n     NAME@[19; 22)"}, {"sha": "90538b90daa858ae86308759ea677f57308553fe", "filename": "crates/ra_syntax/test_data/parser/ok/0035_weird_exprs.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0035_weird_exprs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0035_weird_exprs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0035_weird_exprs.txt?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -1592,7 +1592,7 @@ SOURCE_FILE@[0; 3813)\n       BLOCK@[2845; 2906)\n         L_CURLY@[2845; 2846) \"{\"\n         WHITESPACE@[2846; 2851) \"\\n    \"\n-        STRUCT_DEF@[2851; 2904)\n+        UNION_DEF@[2851; 2904)\n           UNION_KW@[2851; 2856) \"union\"\n           WHITESPACE@[2856; 2857) \" \"\n           NAME@[2857; 2862)"}, {"sha": "0f64d7e5f8c74576c0525f9a8d74efad3cfe2dac", "filename": "docs/dev/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -14,7 +14,7 @@ To learn more about how rust-analyzer works, see\n \n We also publish rustdoc docs to pages:\n \n-https://rust-analyzer.github.io/rust-analyzer/ra_ide_api/\n+https://rust-analyzer.github.io/rust-analyzer/ra_ide/\n \n Various organizational and process issues are discussed in this document.\n "}, {"sha": "629645757a1f9433feedadef9af229d0cca735fa", "filename": "docs/dev/architecture.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/docs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/docs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Farchitecture.md?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -106,7 +106,7 @@ guessing a HIR for a particular source position.\n \n Underneath, HIR works on top of salsa, using a `HirDatabase` trait.\n \n-### `crates/ra_ide_api`\n+### `crates/ra_ide`\n \n A stateful library for analyzing many Rust files as they change. `AnalysisHost`\n is a mutable entity (clojure's atom) which holds the current state, incorporates\n@@ -124,11 +124,11 @@ offsets and strings as output. This works on top of rich code model powered by\n \n ### `crates/ra_lsp_server`\n \n-An LSP implementation which wraps `ra_ide_api` into a language server protocol.\n+An LSP implementation which wraps `ra_ide` into a language server protocol.\n \n ### `ra_vfs`\n \n-Although `hir` and `ra_ide_api` don't do any IO, we need to be able to read\n+Although `hir` and `ra_ide` don't do any IO, we need to be able to read\n files from disk at the end of the day. This is what `ra_vfs` does. It also\n manages overlays: \"dirty\" files in the editor, whose \"true\" contents is\n different from data on disk. This is more or less the single really\n@@ -162,13 +162,13 @@ disk. For this reason, we try to avoid writing too many tests on this boundary:\n in a statically typed language, it's hard to make an error in the protocol\n itself if messages are themselves typed.\n \n-The middle, and most important, boundary is `ra_ide_api`. Unlike\n-`ra_lsp_server`, which exposes API, `ide_api` uses Rust API and is intended to\n+The middle, and most important, boundary is `ra_ide`. Unlike\n+`ra_lsp_server`, which exposes API, `ide` uses Rust API and is intended to\n use by various tools. Typical test creates an `AnalysisHost`, calls some\n `Analysis` functions and compares the results against expectation.\n \n The innermost and most elaborate boundary is `hir`. It has a much richer\n-vocabulary of types than `ide_api`, but the basic testing setup is the same: we\n+vocabulary of types than `ide`, but the basic testing setup is the same: we\n create a database, run some queries, assert result.\n \n For comparisons, we use [insta](https://github.com/mitsuhiko/insta/) library for"}, {"sha": "c163a74b31d0c32ce5e4283ee9c0aa070457819b", "filename": "docs/dev/guide.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/docs%2Fdev%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/docs%2Fdev%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fguide.md?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -40,8 +40,8 @@ terms of files and offsets, and **not** in terms of Rust concepts like structs,\n traits, etc. The \"typed\" API with Rust specific types is slightly lower in the\n stack, we'll talk about it later.\n \n-[`AnalysisHost`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L265-L284\n-[`Analysis`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L291-L478\n+[`AnalysisHost`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/lib.rs#L265-L284\n+[`Analysis`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/lib.rs#L291-L478\n \n The reason for this separation of `Analysis` and `AnalysisHost` is that we want to apply\n changes \"uniquely\", but we might also want to fork an `Analysis` and send it to\n@@ -69,7 +69,7 @@ the `AnalysisHost::apply_change` method, which accepts a single argument, a\n \"transaction\", so it suffices to study its methods to understand all of the\n input data.\n \n-[`AnalysisChange`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L119-L167\n+[`AnalysisChange`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/lib.rs#L119-L167\n \n The `(add|change|remove)_file` methods control the set of the input files, where\n each file has an integer id (`FileId`, picked by the client), text (`String`)\n@@ -253,7 +253,7 @@ All analyzer information is stored in a salsa database. `Analysis` and\n `AnalysisHost` types are newtype wrappers for [`RootDatabase`] -- a salsa\n database.\n \n-[`RootDatabase`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/db.rs#L88-L134\n+[`RootDatabase`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/db.rs#L88-L134\n \n Salsa input queries are defined in [`FilesDatabase`] (which is a part of\n `RootDatabase`). They closely mirror the familiar `AnalysisChange` structure:\n@@ -565,11 +565,11 @@ the type to completion.\n [schedule it on the threadpool]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L428\n [catch]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L436-L442\n [the handler]: https://salsa.zulipchat.com/#narrow/stream/181542-rfcs.2Fsalsa-query-group/topic/design.20next.20steps\n-[ask analysis for completion]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L439-L444\n-[completion implementation]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion.rs#L46-L62\n-[`CompletionContext`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L14-L37\n-[\"IntelliJ Trick\"]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L72-L75\n-[find an ancestor `fn` node]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L116-L120\n-[semantic model]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L123\n-[series of independent completion routines]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion.rs#L52-L59\n-[`complete_dot`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/complete_dot.rs#L6-L22\n+[ask analysis for completion]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/lib.rs#L439-L444\n+[completion implementation]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/completion.rs#L46-L62\n+[`CompletionContext`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/completion/completion_context.rs#L14-L37\n+[\"IntelliJ Trick\"]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/completion/completion_context.rs#L72-L75\n+[find an ancestor `fn` node]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/completion/completion_context.rs#L116-L120\n+[semantic model]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/completion/completion_context.rs#L123\n+[series of independent completion routines]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/completion.rs#L52-L59\n+[`complete_dot`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide/src/completion/complete_dot.rs#L6-L22"}, {"sha": null, "filename": "editors/code/src/utils/terminateProcess.sh", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/editors%2Fcode%2Fsrc%2Futils%2FterminateProcess.sh", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/editors%2Fcode%2Fsrc%2Futils%2FterminateProcess.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futils%2FterminateProcess.sh?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef"}, {"sha": "8a005d6c4dc1d52bc323224b5ab38421a2f598cf", "filename": "xtask/tests/tidy-tests/docs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a0937585b836ec5ed054b9ae48e0156ab6d9ef/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs?ref=18a0937585b836ec5ed054b9ae48e0156ab6d9ef", "patch": "@@ -74,7 +74,7 @@ fn no_docs_comments() {\n         \"ra_db\",\n         \"ra_hir\",\n         \"ra_hir_expand\",\n-        \"ra_ide_api\",\n+        \"ra_ide\",\n         \"ra_lsp_server\",\n         \"ra_mbe\",\n         \"ra_parser\",\n@@ -83,6 +83,7 @@ fn no_docs_comments() {\n         \"ra_syntax\",\n         \"ra_text_edit\",\n         \"ra_tt\",\n+        \"ra_hir_ty\",\n     ];\n \n     let mut has_fixmes = whitelist.iter().map(|it| (*it, false)).collect::<HashMap<&str, bool>>();"}]}