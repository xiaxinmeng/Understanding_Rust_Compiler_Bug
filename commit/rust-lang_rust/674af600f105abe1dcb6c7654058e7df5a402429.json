{"sha": "674af600f105abe1dcb6c7654058e7df5a402429", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NGFmNjAwZjEwNWFiZTFkY2I2Yzc2NTQwNThlN2RmNWE0MDI0Mjk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-08-14T10:06:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-14T10:06:03Z"}, "message": "Merge #5756\n\n5756: Sophisticate Windows path encoding r=matklad a=pragmatrix\n\nAs discussed in #5475, path encoding should be agnostic of the drive letter casing on Windows.\r\n\r\nCompared to the problem it solves, the code added seems a lot and may introduce other problems. But I've not found a simpler way basing this on the public API surface that Rust offers.\r\n\r\nFixes #5484.\r\n\r\ncc @Emilgardis \n\nCo-authored-by: Armin Sander <armin@replicator.org>", "tree": {"sha": "b1c9f3e698780720aa2c92dbfb9c2e3ae07a4bdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1c9f3e698780720aa2c92dbfb9c2e3ae07a4bdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/674af600f105abe1dcb6c7654058e7df5a402429", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfNmILCRBK7hj4Ov3rIwAAdHIIAIQNl5SUG9Dmj3KPtWfVfX17\nYoGb4BVGRFBLN2gF94+XdxqZ7g32Yq1iPCz9G+00DqgQxq5h/d8LCzR+4wh8qf3c\nvXptd3s+2MOPfc4hOdqWkSbOcPLdkO9/9nOsPfc/xw0drpLs583/q1nYgKMAIYR/\nqFykT7sPPGp23qIaBQnXF747DuICITR+2v47exppr+aIbnzJ5nyz3qtRRG7kN/PU\nvnXOYtpvATX3TqS7oRdLWwclhnwdGMYlZu+VmvEKKX14SpT77fazHL5hsfSG2Ock\ncFKK7zGIWsh7mjCJHqCJaD17sJEZCFS+SKAR65og2GcXW6UYDwKn/xn4YaL1Zvw=\n=1jst\n-----END PGP SIGNATURE-----\n", "payload": "tree b1c9f3e698780720aa2c92dbfb9c2e3ae07a4bdd\nparent f1f73649a686dc6e6449afc35e0fa6fed00e225d\nparent 8fc254597f7351e06b19052933aa01a044583b71\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1597399563 +0000\ncommitter GitHub <noreply@github.com> 1597399563 +0000\n\nMerge #5756\n\n5756: Sophisticate Windows path encoding r=matklad a=pragmatrix\n\nAs discussed in #5475, path encoding should be agnostic of the drive letter casing on Windows.\r\n\r\nCompared to the problem it solves, the code added seems a lot and may introduce other problems. But I've not found a simpler way basing this on the public API surface that Rust offers.\r\n\r\nFixes #5484.\r\n\r\ncc @Emilgardis \n\nCo-authored-by: Armin Sander <armin@replicator.org>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/674af600f105abe1dcb6c7654058e7df5a402429", "html_url": "https://github.com/rust-lang/rust/commit/674af600f105abe1dcb6c7654058e7df5a402429", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/674af600f105abe1dcb6c7654058e7df5a402429/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f73649a686dc6e6449afc35e0fa6fed00e225d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f73649a686dc6e6449afc35e0fa6fed00e225d", "html_url": "https://github.com/rust-lang/rust/commit/f1f73649a686dc6e6449afc35e0fa6fed00e225d"}, {"sha": "8fc254597f7351e06b19052933aa01a044583b71", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc254597f7351e06b19052933aa01a044583b71", "html_url": "https://github.com/rust-lang/rust/commit/8fc254597f7351e06b19052933aa01a044583b71"}], "stats": {"total": 139, "additions": 132, "deletions": 7}, "files": [{"sha": "944a702df0fcd073b9df4356a13d0bbadd77afeb", "filename": "crates/vfs/src/vfs_path.rs", "status": "modified", "additions": 132, "deletions": 7, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/674af600f105abe1dcb6c7654058e7df5a402429/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674af600f105abe1dcb6c7654058e7df5a402429/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=674af600f105abe1dcb6c7654058e7df5a402429", "patch": "@@ -57,30 +57,155 @@ impl VfsPath {\n         };\n         buf.push(tag);\n         match &self.0 {\n-            VfsPathRepr::PathBuf(it) => {\n-                let path: &std::ffi::OsStr = it.as_os_str();\n+            VfsPathRepr::PathBuf(path) => {\n                 #[cfg(windows)]\n                 {\n-                    use std::os::windows::ffi::OsStrExt;\n-                    for wchar in path.encode_wide() {\n-                        buf.extend(wchar.to_le_bytes().iter().copied());\n+                    use windows_paths::Encode;\n+                    let components = path.components();\n+                    let mut add_sep = false;\n+                    for component in components {\n+                        if add_sep {\n+                            windows_paths::SEP.encode(buf);\n+                        }\n+                        let len_before = buf.len();\n+                        match component {\n+                            std::path::Component::Prefix(prefix) => {\n+                                // kind() returns a normalized and comparable path prefix.\n+                                prefix.kind().encode(buf);\n+                            }\n+                            std::path::Component::RootDir => {\n+                                if !add_sep {\n+                                    component.as_os_str().encode(buf);\n+                                }\n+                            }\n+                            _ => component.as_os_str().encode(buf),\n+                        }\n+\n+                        // some components may be encoded empty\n+                        add_sep = len_before != buf.len();\n                     }\n                 }\n                 #[cfg(unix)]\n                 {\n                     use std::os::unix::ffi::OsStrExt;\n-                    buf.extend(path.as_bytes());\n+                    buf.extend(path.as_os_str().as_bytes());\n                 }\n                 #[cfg(not(any(windows, unix)))]\n                 {\n-                    buf.extend(path.to_string_lossy().as_bytes());\n+                    buf.extend(path.as_os_str().to_string_lossy().as_bytes());\n                 }\n             }\n             VfsPathRepr::VirtualPath(VirtualPath(s)) => buf.extend(s.as_bytes()),\n         }\n     }\n }\n \n+#[cfg(windows)]\n+mod windows_paths {\n+    pub trait Encode {\n+        fn encode(&self, buf: &mut Vec<u8>);\n+    }\n+\n+    impl Encode for std::ffi::OsStr {\n+        fn encode(&self, buf: &mut Vec<u8>) {\n+            use std::os::windows::ffi::OsStrExt;\n+            for wchar in self.encode_wide() {\n+                buf.extend(wchar.to_le_bytes().iter().copied());\n+            }\n+        }\n+    }\n+\n+    impl Encode for u8 {\n+        fn encode(&self, buf: &mut Vec<u8>) {\n+            let wide = *self as u16;\n+            buf.extend(wide.to_le_bytes().iter().copied())\n+        }\n+    }\n+\n+    impl Encode for &str {\n+        fn encode(&self, buf: &mut Vec<u8>) {\n+            debug_assert!(self.is_ascii());\n+            for b in self.as_bytes() {\n+                b.encode(buf)\n+            }\n+        }\n+    }\n+\n+    pub const SEP: &str = \"\\\\\";\n+    const VERBATIM: &str = \"\\\\\\\\?\\\\\";\n+    const UNC: &str = \"UNC\";\n+    const DEVICE: &str = \"\\\\\\\\.\\\\\";\n+    const COLON: &str = \":\";\n+\n+    impl Encode for std::path::Prefix<'_> {\n+        fn encode(&self, buf: &mut Vec<u8>) {\n+            match self {\n+                std::path::Prefix::Verbatim(c) => {\n+                    VERBATIM.encode(buf);\n+                    c.encode(buf);\n+                }\n+                std::path::Prefix::VerbatimUNC(server, share) => {\n+                    VERBATIM.encode(buf);\n+                    UNC.encode(buf);\n+                    SEP.encode(buf);\n+                    server.encode(buf);\n+                    SEP.encode(buf);\n+                    share.encode(buf);\n+                }\n+                std::path::Prefix::VerbatimDisk(d) => {\n+                    VERBATIM.encode(buf);\n+                    d.encode(buf);\n+                    COLON.encode(buf);\n+                }\n+                std::path::Prefix::DeviceNS(device) => {\n+                    DEVICE.encode(buf);\n+                    device.encode(buf);\n+                }\n+                std::path::Prefix::UNC(server, share) => {\n+                    SEP.encode(buf);\n+                    SEP.encode(buf);\n+                    server.encode(buf);\n+                    SEP.encode(buf);\n+                    share.encode(buf);\n+                }\n+                std::path::Prefix::Disk(d) => {\n+                    d.encode(buf);\n+                    COLON.encode(buf);\n+                }\n+            }\n+        }\n+    }\n+    #[test]\n+    fn paths_encoding() {\n+        // drive letter casing agnostic\n+        test_eq(\"C:/x.rs\", \"c:/x.rs\");\n+        // separator agnostic\n+        test_eq(\"C:/x/y.rs\", \"C:\\\\x\\\\y.rs\");\n+\n+        fn test_eq(a: &str, b: &str) {\n+            let mut b1 = Vec::new();\n+            let mut b2 = Vec::new();\n+            vfs(a).encode(&mut b1);\n+            vfs(b).encode(&mut b2);\n+            assert_eq!(b1, b2);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_sep_root_dir_encoding() {\n+        let mut buf = Vec::new();\n+        vfs(\"C:/x/y\").encode(&mut buf);\n+        assert_eq!(&buf, &[0, 67, 0, 58, 0, 92, 0, 120, 0, 92, 0, 121, 0])\n+    }\n+\n+    #[cfg(test)]\n+    fn vfs(str: &str) -> super::VfsPath {\n+        use super::{AbsPathBuf, VfsPath};\n+        use std::convert::TryFrom;\n+        VfsPath::from(AbsPathBuf::try_from(str).unwrap())\n+    }\n+}\n+\n #[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n enum VfsPathRepr {\n     PathBuf(AbsPathBuf),"}]}