{"sha": "5a2b50b33df6015e5bae97c5224e3180885dcc66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMmI1MGIzM2RmNjAxNWU1YmFlOTdjNTIyNGUzMTgwODg1ZGNjNjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-13T02:28:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-13T02:28:23Z"}, "message": "Auto merge of #38325 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 7 pull requests\n\n- Successful merges: #37052, #37941, #38067, #38164, #38202, #38264, #38299\n- Failed merges:", "tree": {"sha": "162ebfb123a41b6ef2322f7207fd98c66c200b3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/162ebfb123a41b6ef2322f7207fd98c66c200b3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a2b50b33df6015e5bae97c5224e3180885dcc66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a2b50b33df6015e5bae97c5224e3180885dcc66", "html_url": "https://github.com/rust-lang/rust/commit/5a2b50b33df6015e5bae97c5224e3180885dcc66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a2b50b33df6015e5bae97c5224e3180885dcc66/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1336742a1a6c16be4c3af88b2e3d69b762154c19", "url": "https://api.github.com/repos/rust-lang/rust/commits/1336742a1a6c16be4c3af88b2e3d69b762154c19", "html_url": "https://github.com/rust-lang/rust/commit/1336742a1a6c16be4c3af88b2e3d69b762154c19"}, {"sha": "cba1304313f3c9b82bfdc4585cf480a4585a91b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba1304313f3c9b82bfdc4585cf480a4585a91b4", "html_url": "https://github.com/rust-lang/rust/commit/cba1304313f3c9b82bfdc4585cf480a4585a91b4"}], "stats": {"total": 1588, "additions": 1255, "deletions": 333}, "files": [{"sha": "664bc0fdab0025c0e5111f448cb7f0c8ba7aa2ac", "filename": "src/doc/rust.css", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -44,7 +44,9 @@\n     font-family: 'Source Code Pro';\n     font-style: normal;\n     font-weight: 400;\n-    src: local('Source Code Pro'), url(\"SourceCodePro-Regular.woff\") format('woff');\n+    /* Avoid using locally installed font because bad versions are in circulation:\n+     * see https://github.com/rust-lang/rust/issues/24355 */\n+    src: url(\"SourceCodePro-Regular.woff\") format('woff');\n }\n \n *:not(body) {"}, {"sha": "b355c8f2c4c6f57be318a2143a50e7cb61c31220", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -26,47 +26,52 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n             extent: cx.tcx.region_maps.node_extent(self.id),\n             span: self.span,\n             stmts: stmts,\n-            expr: self.expr.to_ref()\n+            expr: self.expr.to_ref(),\n         }\n     }\n }\n \n fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 block_id: ast::NodeId,\n                                 stmts: &'tcx [hir::Stmt])\n-                                -> Vec<StmtRef<'tcx>>\n-{\n+                                -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n         match stmt.node {\n-            hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) =>\n+            hir::StmtExpr(ref expr, id) |\n+            hir::StmtSemi(ref expr, id) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     span: stmt.span,\n                     kind: StmtKind::Expr {\n                         scope: cx.tcx.region_maps.node_extent(id),\n-                        expr: expr.to_ref()\n+                        expr: expr.to_ref(),\n+                    },\n+                })))\n+            }\n+            hir::StmtDecl(ref decl, id) => {\n+                match decl.node {\n+                    hir::DeclItem(..) => {\n+                        // ignore for purposes of the MIR\n                     }\n-                }))),\n-            hir::StmtDecl(ref decl, id) => match decl.node {\n-                hir::DeclItem(..) => { /* ignore for purposes of the MIR */ }\n-                hir::DeclLocal(ref local) => {\n-                    let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n-                        block: block_id,\n-                        first_statement_index: index as u32,\n-                    });\n-                    let remainder_extent =\n-                        cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n+                    hir::DeclLocal(ref local) => {\n+                        let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n+                            block: block_id,\n+                            first_statement_index: index as u32,\n+                        });\n+                        let remainder_extent =\n+                            cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n \n-                    let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n-                    result.push(StmtRef::Mirror(Box::new(Stmt {\n-                        span: stmt.span,\n-                        kind: StmtKind::Let {\n-                            remainder_scope: remainder_extent,\n-                            init_scope: cx.tcx.region_maps.node_extent(id),\n-                            pattern: pattern,\n-                            initializer: local.init.to_ref(),\n-                        },\n-                    })));\n+                        let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n+                        result.push(StmtRef::Mirror(Box::new(Stmt {\n+                            span: stmt.span,\n+                            kind: StmtKind::Let {\n+                                remainder_scope: remainder_extent,\n+                                init_scope: cx.tcx.region_maps.node_extent(id),\n+                                pattern: pattern,\n+                                initializer: local.init.to_ref(),\n+                            },\n+                        })));\n+                    }\n                 }\n             }\n         }"}, {"sha": "d579cdb042fb3f3b7d4075beacff0eef321d121b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 307, "deletions": 258, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -36,7 +36,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         let adj = cx.tcx.tables().adjustments.get(&self.id).cloned();\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n-               expr, adj);\n+               expr,\n+               adj);\n \n         // Now apply adjustments, if any.\n         match adj.map(|adj| (adj.kind, adj.target)) {\n@@ -78,41 +79,44 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 for i in 0..autoderefs {\n                     let i = i as u32;\n                     let adjusted_ty =\n-                        expr.ty.adjust_for_autoderef(\n-                            cx.tcx,\n-                            self.id,\n-                            self.span,\n-                            i,\n-                            |mc| cx.tcx.tables().method_map.get(&mc).map(|m| m.ty));\n-                    debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\", i, adjusted_ty);\n+                        expr.ty.adjust_for_autoderef(cx.tcx, self.id, self.span, i, |mc| {\n+                            cx.tcx.tables().method_map.get(&mc).map(|m| m.ty)\n+                        });\n+                    debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\",\n+                           i,\n+                           adjusted_ty);\n                     let method_key = ty::MethodCall::autoderef(self.id, i);\n-                    let meth_ty =\n-                        cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n+                    let meth_ty = cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n                     let kind = if let Some(meth_ty) = meth_ty {\n                         debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n \n                         let ref_ty = cx.tcx.no_late_bound_regions(&meth_ty.fn_ret());\n                         let (region, mutbl) = match ref_ty {\n-                            Some(&ty::TyS {\n-                                sty: ty::TyRef(region, mt), ..\n-                            }) => (region, mt.mutbl),\n-                            _ => span_bug!(expr.span, \"autoderef returned bad type\")\n+                            Some(&ty::TyS { sty: ty::TyRef(region, mt), .. }) => (region, mt.mutbl),\n+                            _ => span_bug!(expr.span, \"autoderef returned bad type\"),\n                         };\n \n                         expr = Expr {\n                             temp_lifetime: temp_lifetime,\n-                            ty: cx.tcx.mk_ref(\n-                                region, ty::TypeAndMut { ty: expr.ty, mutbl: mutbl }),\n+                            ty: cx.tcx.mk_ref(region,\n+                                              ty::TypeAndMut {\n+                                                  ty: expr.ty,\n+                                                  mutbl: mutbl,\n+                                              }),\n                             span: expr.span,\n                             kind: ExprKind::Borrow {\n                                 region: region,\n                                 borrow_kind: to_borrow_kind(mutbl),\n-                                arg: expr.to_ref()\n-                            }\n+                                arg: expr.to_ref(),\n+                            },\n                         };\n \n-                        overloaded_lvalue(cx, self, method_key,\n-                                          PassArgs::ByRef, expr.to_ref(), vec![])\n+                        overloaded_lvalue(cx,\n+                                          self,\n+                                          method_key,\n+                                          PassArgs::ByRef,\n+                                          expr.to_ref(),\n+                                          vec![])\n                     } else {\n                         debug!(\"make_mirror: built-in autoderef\");\n                         ExprKind::Deref { arg: expr.to_ref() }\n@@ -148,7 +152,11 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                             let region = cx.tcx.mk_region(region);\n                             expr = Expr {\n                                 temp_lifetime: temp_lifetime,\n-                                ty: cx.tcx.mk_ref(region, ty::TypeAndMut { ty: expr.ty, mutbl: m }),\n+                                ty: cx.tcx.mk_ref(region,\n+                                                  ty::TypeAndMut {\n+                                                      ty: expr.ty,\n+                                                      mutbl: m,\n+                                                  }),\n                                 span: self.span,\n                                 kind: ExprKind::Borrow {\n                                     region: region,\n@@ -240,57 +248,62 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n                 let sig = match method.ty.sty {\n                     ty::TyFnDef(.., fn_ty) => &fn_ty.sig,\n-                    _ => span_bug!(expr.span, \"type of method is not an fn\")\n+                    _ => span_bug!(expr.span, \"type of method is not an fn\"),\n                 };\n \n-                let sig = cx.tcx.no_late_bound_regions(sig).unwrap_or_else(|| {\n-                    span_bug!(expr.span, \"method call has late-bound regions\")\n-                });\n+                let sig = cx.tcx\n+                    .no_late_bound_regions(sig)\n+                    .unwrap_or_else(|| span_bug!(expr.span, \"method call has late-bound regions\"));\n \n                 assert_eq!(sig.inputs().len(), 2);\n \n                 let tupled_args = Expr {\n                     ty: sig.inputs()[1],\n                     temp_lifetime: temp_lifetime,\n                     span: expr.span,\n-                    kind: ExprKind::Tuple {\n-                        fields: args.iter().map(ToRef::to_ref).collect()\n-                    }\n+                    kind: ExprKind::Tuple { fields: args.iter().map(ToRef::to_ref).collect() },\n                 };\n \n                 ExprKind::Call {\n                     ty: method.ty,\n                     fun: method.to_ref(),\n-                    args: vec![fun.to_ref(), tupled_args.to_ref()]\n+                    args: vec![fun.to_ref(), tupled_args.to_ref()],\n                 }\n             } else {\n                 let adt_data = if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = fun.node {\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n-                    expr_ty.ty_adt_def().and_then(|adt_def|{\n+                    expr_ty.ty_adt_def().and_then(|adt_def| {\n                         match path.def {\n                             Def::VariantCtor(variant_id, CtorKind::Fn) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n-                            },\n-                            Def::StructCtor(_, CtorKind::Fn) => {\n-                                Some((adt_def, 0))\n-                            },\n-                            _ => None\n+                            }\n+                            Def::StructCtor(_, CtorKind::Fn) => Some((adt_def, 0)),\n+                            _ => None,\n                         }\n                     })\n-                } else { None };\n+                } else {\n+                    None\n+                };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx.tables().node_id_item_substs(fun.id)\n+                    let substs = cx.tcx\n+                        .tables()\n+                        .node_id_item_substs(fun.id)\n                         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n-                    let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n-                        name: Field::new(idx),\n-                        expr: e.to_ref()\n-                    }).collect();\n+                    let field_refs = args.iter()\n+                        .enumerate()\n+                        .map(|(idx, e)| {\n+                            FieldExprRef {\n+                                name: Field::new(idx),\n+                                expr: e.to_ref(),\n+                            }\n+                        })\n+                        .collect();\n                     ExprKind::Adt {\n                         adt_def: adt_def,\n                         substs: substs,\n                         variant_index: index,\n                         fields: field_refs,\n-                        base: None\n+                        base: None,\n                     }\n                 } else {\n                     ExprKind::Call {\n@@ -314,9 +327,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprBlock(ref blk) => {\n-            ExprKind::Block { body: &blk }\n-        }\n+        hir::ExprBlock(ref blk) => ExprKind::Block { body: &blk },\n \n         hir::ExprAssign(ref lhs, ref rhs) => {\n             ExprKind::Assign {\n@@ -332,8 +343,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 } else {\n                     PassArgs::ByRef\n                 };\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    pass_args, lhs.to_ref(), vec![rhs])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    pass_args,\n+                                    lhs.to_ref(),\n+                                    vec![rhs])\n             } else {\n                 ExprKind::AssignOp {\n                     op: bin_op(op.node),\n@@ -343,9 +358,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprLit(..) => ExprKind::Literal {\n-            literal: cx.const_eval_literal(expr)\n-        },\n+        hir::ExprLit(..) => ExprKind::Literal { literal: cx.const_eval_literal(expr) },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n@@ -354,8 +367,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 } else {\n                     PassArgs::ByRef\n                 };\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    pass_args, lhs.to_ref(), vec![rhs])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    pass_args,\n+                                    lhs.to_ref(),\n+                                    vec![rhs])\n             } else {\n                 // FIXME overflow\n                 match (op.node, cx.constness) {\n@@ -405,8 +422,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprIndex(ref lhs, ref index) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n-                                  PassArgs::ByValue, lhs.to_ref(), vec![index])\n+                overloaded_lvalue(cx,\n+                                  expr,\n+                                  ty::MethodCall::expr(expr.id),\n+                                  PassArgs::ByValue,\n+                                  lhs.to_ref(),\n+                                  vec![index])\n             } else {\n                 ExprKind::Index {\n                     lhs: lhs.to_ref(),\n@@ -417,17 +438,25 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n-                                  PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_lvalue(cx,\n+                                  expr,\n+                                  ty::MethodCall::expr(expr.id),\n+                                  PassArgs::ByValue,\n+                                  arg.to_ref(),\n+                                  vec![])\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    PassArgs::ByValue,\n+                                    arg.to_ref(),\n+                                    vec![])\n             } else {\n                 ExprKind::Unary {\n                     op: UnOp::Not,\n@@ -438,14 +467,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    PassArgs::ByValue,\n+                                    arg.to_ref(),\n+                                    vec![])\n             } else {\n                 // FIXME runtime-overflow\n                 if let hir::ExprLit(_) = arg.node {\n-                    ExprKind::Literal {\n-                        literal: cx.const_eval_literal(expr),\n-                    }\n+                    ExprKind::Literal { literal: cx.const_eval_literal(expr) }\n                 } else {\n                     ExprKind::Unary {\n                         op: UnOp::Neg,\n@@ -457,56 +488,54 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprStruct(ref qpath, ref fields, ref base) => {\n             match expr_ty.sty {\n-                ty::TyAdt(adt, substs) => match adt.adt_kind() {\n-                    AdtKind::Struct | AdtKind::Union => {\n-                        let field_refs = field_refs(&adt.variants[0], fields);\n-                        ExprKind::Adt {\n-                            adt_def: adt,\n-                            variant_index: 0,\n-                            substs: substs,\n-                            fields: field_refs,\n-                            base: base.as_ref().map(|base| {\n-                                FruInfo {\n-                                    base: base.to_ref(),\n-                                    field_types:\n-                                        cx.tcx.tables().fru_field_types[&expr.id].clone()\n-                                }\n-                            })\n+                ty::TyAdt(adt, substs) => {\n+                    match adt.adt_kind() {\n+                        AdtKind::Struct | AdtKind::Union => {\n+                            let field_refs = field_refs(&adt.variants[0], fields);\n+                            ExprKind::Adt {\n+                                adt_def: adt,\n+                                variant_index: 0,\n+                                substs: substs,\n+                                fields: field_refs,\n+                                base: base.as_ref().map(|base| {\n+                                    FruInfo {\n+                                        base: base.to_ref(),\n+                                        field_types: cx.tcx.tables().fru_field_types[&expr.id]\n+                                            .clone(),\n+                                    }\n+                                }),\n+                            }\n                         }\n-                    }\n-                    AdtKind::Enum => {\n-                        let def = match *qpath {\n-                            hir::QPath::Resolved(_, ref path) => path.def,\n-                            hir::QPath::TypeRelative(..) => Def::Err\n-                        };\n-                        match def {\n-                            Def::Variant(variant_id) => {\n-                                assert!(base.is_none());\n-\n-                                let index = adt.variant_index_with_id(variant_id);\n-                                let field_refs = field_refs(&adt.variants[index], fields);\n-                                ExprKind::Adt {\n-                                    adt_def: adt,\n-                                    variant_index: index,\n-                                    substs: substs,\n-                                    fields: field_refs,\n-                                    base: None\n+                        AdtKind::Enum => {\n+                            let def = match *qpath {\n+                                hir::QPath::Resolved(_, ref path) => path.def,\n+                                hir::QPath::TypeRelative(..) => Def::Err,\n+                            };\n+                            match def {\n+                                Def::Variant(variant_id) => {\n+                                    assert!(base.is_none());\n+\n+                                    let index = adt.variant_index_with_id(variant_id);\n+                                    let field_refs = field_refs(&adt.variants[index], fields);\n+                                    ExprKind::Adt {\n+                                        adt_def: adt,\n+                                        variant_index: index,\n+                                        substs: substs,\n+                                        fields: field_refs,\n+                                        base: None,\n+                                    }\n+                                }\n+                                _ => {\n+                                    span_bug!(expr.span, \"unexpected def: {:?}\", def);\n                                 }\n-                            }\n-                            _ => {\n-                                span_bug!(\n-                                    expr.span,\n-                                    \"unexpected def: {:?}\",\n-                                    def);\n                             }\n                         }\n                     }\n-                },\n+                }\n                 _ => {\n-                    span_bug!(\n-                        expr.span,\n-                        \"unexpected type for struct literal: {:?}\",\n-                        expr_ty);\n+                    span_bug!(expr.span,\n+                              \"unexpected type for struct literal: {:?}\",\n+                              expr_ty);\n                 }\n             }\n         }\n@@ -516,9 +545,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let (def_id, substs) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n-                    span_bug!(expr.span,\n-                              \"closure expr w/o closure type: {:?}\",\n-                              closure_ty);\n+                    span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n             let upvars = cx.tcx.with_freevars(expr.id, |freevars| {\n@@ -543,69 +570,81 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::InlineAsm {\n                 asm: asm,\n                 outputs: outputs.to_ref(),\n-                inputs: inputs.to_ref()\n+                inputs: inputs.to_ref(),\n             }\n         }\n \n         // Now comes the rote stuff:\n-\n-        hir::ExprRepeat(ref v, ref c) => ExprKind::Repeat {\n-            value: v.to_ref(),\n-            count: TypedConstVal {\n-                ty: cx.tcx.tables().expr_ty(c),\n-                span: c.span,\n-                value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n-                    ConstVal::Integral(ConstInt::Usize(u)) => u,\n-                    other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+        hir::ExprRepeat(ref v, ref c) => {\n+            ExprKind::Repeat {\n+                value: v.to_ref(),\n+                count: TypedConstVal {\n+                    ty: cx.tcx.tables().expr_ty(c),\n+                    span: c.span,\n+                    value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n+                        ConstVal::Integral(ConstInt::Usize(u)) => u,\n+                        other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+                    },\n                 },\n             }\n-        },\n-        hir::ExprRet(ref v) =>\n-            ExprKind::Return { value: v.to_ref() },\n-        hir::ExprBreak(label, ref value) =>\n+        }\n+        hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n+        hir::ExprBreak(label, ref value) => {\n             ExprKind::Break {\n-                label: label.map(|label| {\n-                    cx.tcx.region_maps.node_extent(label.loop_id)\n-                }),\n-                value: value.to_ref()\n-            },\n-        hir::ExprAgain(label) =>\n+                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+                value: value.to_ref(),\n+            }\n+        }\n+        hir::ExprAgain(label) => {\n             ExprKind::Continue {\n-                label: label.map(|label| {\n-                    cx.tcx.region_maps.node_extent(label.loop_id)\n-                })\n-            },\n-        hir::ExprMatch(ref discr, ref arms, _) =>\n-            ExprKind::Match { discriminant: discr.to_ref(),\n-                              arms: arms.iter().map(|a| convert_arm(cx, a)).collect() },\n-        hir::ExprIf(ref cond, ref then, ref otherwise) =>\n-            ExprKind::If { condition: cond.to_ref(),\n-                           then: block::to_expr_ref(cx, then),\n-                           otherwise: otherwise.to_ref() },\n-        hir::ExprWhile(ref cond, ref body, _) =>\n-            ExprKind::Loop { condition: Some(cond.to_ref()),\n-                             body: block::to_expr_ref(cx, body) },\n-        hir::ExprLoop(ref body, _, _) =>\n-            ExprKind::Loop { condition: None,\n-                             body: block::to_expr_ref(cx, body) },\n+                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+            }\n+        }\n+        hir::ExprMatch(ref discr, ref arms, _) => {\n+            ExprKind::Match {\n+                discriminant: discr.to_ref(),\n+                arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n+            }\n+        }\n+        hir::ExprIf(ref cond, ref then, ref otherwise) => {\n+            ExprKind::If {\n+                condition: cond.to_ref(),\n+                then: block::to_expr_ref(cx, then),\n+                otherwise: otherwise.to_ref(),\n+            }\n+        }\n+        hir::ExprWhile(ref cond, ref body, _) => {\n+            ExprKind::Loop {\n+                condition: Some(cond.to_ref()),\n+                body: block::to_expr_ref(cx, body),\n+            }\n+        }\n+        hir::ExprLoop(ref body, _, _) => {\n+            ExprKind::Loop {\n+                condition: None,\n+                body: block::to_expr_ref(cx, body),\n+            }\n+        }\n         hir::ExprField(ref source, name) => {\n             let index = match cx.tcx.tables().expr_ty_adjusted(source).sty {\n-                ty::TyAdt(adt_def, _) =>\n-                    adt_def.variants[0].index_of_field_named(name.node),\n-                ref ty =>\n-                    span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n+                ty::TyAdt(adt_def, _) => adt_def.variants[0].index_of_field_named(name.node),\n+                ref ty => span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n             };\n-            let index = index.unwrap_or_else(|| {\n-                span_bug!(\n-                    expr.span,\n-                    \"no index found for field `{}`\",\n-                    name.node)\n-            });\n-            ExprKind::Field { lhs: source.to_ref(), name: Field::new(index) }\n+            let index =\n+                index.unwrap_or_else(|| {\n+                    span_bug!(expr.span, \"no index found for field `{}`\", name.node)\n+                });\n+            ExprKind::Field {\n+                lhs: source.to_ref(),\n+                name: Field::new(index),\n+            }\n+        }\n+        hir::ExprTupField(ref source, index) => {\n+            ExprKind::Field {\n+                lhs: source.to_ref(),\n+                name: Field::new(index.node as usize),\n+            }\n         }\n-        hir::ExprTupField(ref source, index) =>\n-            ExprKind::Field { lhs: source.to_ref(),\n-                              name: Field::new(index.node as usize) },\n         hir::ExprCast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n@@ -616,17 +655,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ExprKind::Cast { source: source.to_ref() }\n             }\n         }\n-        hir::ExprType(ref source, _) =>\n-            return source.make_mirror(cx),\n-        hir::ExprBox(ref value) =>\n+        hir::ExprType(ref source, _) => return source.make_mirror(cx),\n+        hir::ExprBox(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n-                value_extents: cx.tcx.region_maps.node_extent(value.id)\n-            },\n-        hir::ExprArray(ref fields) =>\n-            ExprKind::Vec { fields: fields.to_ref() },\n-        hir::ExprTup(ref fields) =>\n-            ExprKind::Tuple { fields: fields.to_ref() },\n+                value_extents: cx.tcx.region_maps.node_extent(value.id),\n+            }\n+        }\n+        hir::ExprArray(ref fields) => ExprKind::Vec { fields: fields.to_ref() },\n+        hir::ExprTup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n     };\n \n     Expr {\n@@ -663,8 +700,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                               arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n         patterns: arm.pats.iter().map(|p| Pattern::from_hir(cx.tcx, p)).collect(),\n         guard: arm.guard.to_ref(),\n@@ -676,41 +712,48 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tcx.tables().node_id_item_substs(expr.id)\n+    let substs = cx.tcx\n+        .tables()\n+        .node_id_item_substs(expr.id)\n         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n-        Def::Fn(def_id) | Def::Method(def_id) |\n+        Def::Fn(def_id) |\n+        Def::Method(def_id) |\n         Def::StructCtor(def_id, CtorKind::Fn) |\n         Def::VariantCtor(def_id, CtorKind::Fn) |\n-        Def::Const(def_id) | Def::AssociatedConst(def_id) => def_id,\n+        Def::Const(def_id) |\n+        Def::AssociatedConst(def_id) => def_id,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n             match cx.tcx.tables().node_id_to_type(expr.id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n-                ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n-                    adt_def: adt_def,\n-                    variant_index: adt_def.variant_index_with_id(def_id),\n-                    substs: substs,\n-                    fields: vec![],\n-                    base: None,\n-                },\n-                ref sty => bug!(\"unexpected sty: {:?}\", sty)\n+                ty::TyAdt(adt_def, substs) => {\n+                    return ExprKind::Adt {\n+                        adt_def: adt_def,\n+                        variant_index: adt_def.variant_index_with_id(def_id),\n+                        substs: substs,\n+                        fields: vec![],\n+                        base: None,\n+                    }\n+                }\n+                ref sty => bug!(\"unexpected sty: {:?}\", sty),\n             }\n         }\n \n-        Def::Static(node_id, _) => return ExprKind::StaticRef {\n-            id: node_id,\n-        },\n+        Def::Static(node_id, _) => return ExprKind::StaticRef { id: node_id },\n \n         Def::Local(..) | Def::Upvar(..) => return convert_var(cx, expr, def),\n \n         _ => span_bug!(expr.span, \"def `{:?}` not yet implemented\", def),\n     };\n     ExprKind::Literal {\n-        literal: Literal::Item { def_id: def_id, substs: substs }\n+        literal: Literal::Item {\n+            def_id: def_id,\n+            substs: substs,\n+        },\n     }\n }\n \n@@ -723,14 +766,15 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     match def {\n         Def::Local(def_id) => {\n             let node_id = cx.tcx.map.as_local_node_id(def_id).unwrap();\n-            ExprKind::VarRef {\n-                id: node_id,\n-            }\n+            ExprKind::VarRef { id: node_id }\n         }\n \n         Def::Upvar(def_id, index, closure_expr_id) => {\n             let id_var = cx.tcx.map.as_local_node_id(def_id).unwrap();\n-            debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n+            debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n+                   id_var,\n+                   index,\n+                   closure_expr_id);\n             let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n \n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n@@ -761,41 +805,45 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n             let self_expr = match cx.tcx.closure_kind(cx.tcx.map.local_def_id(closure_expr_id)) {\n                 ty::ClosureKind::Fn => {\n-                    let ref_closure_ty =\n-                        cx.tcx.mk_ref(region,\n-                                   ty::TypeAndMut { ty: closure_ty,\n-                                                    mutbl: hir::MutImmutable });\n+                    let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                       ty::TypeAndMut {\n+                                                           ty: closure_ty,\n+                                                           mutbl: hir::MutImmutable,\n+                                                       });\n                     Expr {\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n                         span: expr.span,\n                         kind: ExprKind::Deref {\n                             arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime: temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef\n-                            }.to_ref()\n-                        }\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime: temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }\n+                                .to_ref(),\n+                        },\n                     }\n                 }\n                 ty::ClosureKind::FnMut => {\n-                    let ref_closure_ty =\n-                        cx.tcx.mk_ref(region,\n-                                   ty::TypeAndMut { ty: closure_ty,\n-                                                    mutbl: hir::MutMutable });\n+                    let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                       ty::TypeAndMut {\n+                                                           ty: closure_ty,\n+                                                           mutbl: hir::MutMutable,\n+                                                       });\n                     Expr {\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n                         span: expr.span,\n                         kind: ExprKind::Deref {\n                             arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime: temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef\n-                            }.to_ref()\n-                        }\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime: temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }\n+                                .to_ref(),\n+                        },\n                     }\n                 }\n                 ty::ClosureKind::FnOnce => {\n@@ -823,26 +871,24 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let upvar_capture = match cx.tcx.tables().upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n-                    span_bug!(\n-                        expr.span,\n-                        \"no upvar_capture for {:?}\",\n-                        upvar_id);\n+                    span_bug!(expr.span, \"no upvar_capture for {:?}\", upvar_id);\n                 }\n             };\n             match upvar_capture {\n                 ty::UpvarCapture::ByValue => field_kind,\n                 ty::UpvarCapture::ByRef(borrow) => {\n                     ExprKind::Deref {\n                         arg: Expr {\n-                            temp_lifetime: temp_lifetime,\n-                            ty: cx.tcx.mk_ref(borrow.region,\n-                                ty::TypeAndMut {\n-                                    ty: var_ty,\n-                                    mutbl: borrow.kind.to_mutbl_lossy()\n-                                }),\n-                            span: expr.span,\n-                            kind: field_kind,\n-                        }.to_ref()\n+                                temp_lifetime: temp_lifetime,\n+                                ty: cx.tcx.mk_ref(borrow.region,\n+                                                  ty::TypeAndMut {\n+                                                      ty: var_ty,\n+                                                      mutbl: borrow.kind.to_mutbl_lossy(),\n+                                                  }),\n+                                span: expr.span,\n+                                kind: field_kind,\n+                            }\n+                            .to_ref(),\n                     }\n                 }\n             }\n@@ -894,30 +940,31 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // the arguments, unfortunately, do not, so if this is a ByRef\n     // operator, we have to gin up the autorefs (but by value is easy)\n     match pass_args {\n-        PassArgs::ByValue => {\n-            argrefs.extend(args.iter().map(|arg| arg.to_ref()))\n-        }\n+        PassArgs::ByValue => argrefs.extend(args.iter().map(|arg| arg.to_ref())),\n \n         PassArgs::ByRef => {\n             let region = cx.tcx.node_scope_region(expr.id);\n             let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n-            argrefs.extend(\n-                args.iter()\n-                    .map(|arg| {\n-                        let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n-                        let adjusted_ty =\n-                            cx.tcx.mk_ref(region,\n-                                       ty::TypeAndMut { ty: arg_ty,\n-                                                        mutbl: hir::MutImmutable });\n-                        Expr {\n+            argrefs.extend(args.iter()\n+                .map(|arg| {\n+                    let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n+                    let adjusted_ty = cx.tcx.mk_ref(region,\n+                                                    ty::TypeAndMut {\n+                                                        ty: arg_ty,\n+                                                        mutbl: hir::MutImmutable,\n+                                                    });\n+                    Expr {\n                             temp_lifetime: temp_lifetime,\n                             ty: adjusted_ty,\n                             span: expr.span,\n-                            kind: ExprKind::Borrow { region: region,\n-                                                     borrow_kind: BorrowKind::Shared,\n-                                                     arg: arg.to_ref() }\n-                        }.to_ref()\n-                    }))\n+                            kind: ExprKind::Borrow {\n+                                region: region,\n+                                borrow_kind: BorrowKind::Shared,\n+                                arg: arg.to_ref(),\n+                            },\n+                        }\n+                        .to_ref()\n+                }))\n         }\n     }\n \n@@ -981,36 +1028,38 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         kind: convert_var(cx, closure_expr, freevar.def),\n     };\n     match upvar_capture {\n-        ty::UpvarCapture::ByValue => {\n-            captured_var.to_ref()\n-        }\n+        ty::UpvarCapture::ByValue => captured_var.to_ref(),\n         ty::UpvarCapture::ByRef(upvar_borrow) => {\n             let borrow_kind = match upvar_borrow.kind {\n                 ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n                 ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n                 ty::BorrowKind::MutBorrow => BorrowKind::Mut,\n             };\n             Expr {\n-                temp_lifetime: temp_lifetime,\n-                ty: freevar_ty,\n-                span: closure_expr.span,\n-                kind: ExprKind::Borrow { region: upvar_borrow.region,\n-                                         borrow_kind: borrow_kind,\n-                                         arg: captured_var.to_ref() }\n-            }.to_ref()\n+                    temp_lifetime: temp_lifetime,\n+                    ty: freevar_ty,\n+                    span: closure_expr.span,\n+                    kind: ExprKind::Borrow {\n+                        region: upvar_borrow.region,\n+                        borrow_kind: borrow_kind,\n+                        arg: captured_var.to_ref(),\n+                    },\n+                }\n+                .to_ref()\n         }\n     }\n }\n \n /// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n fn field_refs<'tcx>(variant: &'tcx VariantDef,\n                     fields: &'tcx [hir::Field])\n-                    -> Vec<FieldExprRef<'tcx>>\n-{\n+                    -> Vec<FieldExprRef<'tcx>> {\n     fields.iter()\n-          .map(|field| FieldExprRef {\n-              name: Field::new(variant.index_of_field_named(field.name.node).unwrap()),\n-              expr: field.expr.to_ref(),\n-          })\n-          .collect()\n+        .map(|field| {\n+            FieldExprRef {\n+                name: Field::new(variant.index_of_field_named(field.name.node).unwrap()),\n+                expr: field.expr.to_ref(),\n+            }\n+        })\n+        .collect()\n }"}, {"sha": "7d111fccd0056c5801671605153d863ed33918d7", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * This module contains the code to convert from the wacky tcx data\n- * structures into the hair. The `builder` is generally ignorant of\n- * the tcx etc, and instead goes through the `Cx` for most of its\n- * work.\n- */\n+//! This module contains the code to convert from the wacky tcx data\n+//! structures into the hair. The `builder` is generally ignorant of\n+//! the tcx etc, and instead goes through the `Cx` for most of its\n+//! work.\n+//!\n \n use hair::*;\n use rustc::mir::transform::MirSource;\n@@ -32,27 +31,25 @@ use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n \n #[derive(Copy, Clone)]\n-pub struct Cx<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     constness: hir::Constness,\n \n     /// True if this constant/function needs overflow checks.\n-    check_overflow: bool\n+    check_overflow: bool,\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               src: MirSource)\n-               -> Cx<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, src: MirSource) -> Cx<'a, 'gcx, 'tcx> {\n         let constness = match src {\n             MirSource::Const(_) |\n             MirSource::Static(..) => hir::Constness::Const,\n             MirSource::Fn(id) => {\n                 let fn_like = FnLikeNode::from_node(infcx.tcx.map.get(id));\n                 fn_like.map_or(hir::Constness::NotConst, |f| f.constness())\n             }\n-            MirSource::Promoted(..) => bug!()\n+            MirSource::Promoted(..) => bug!(),\n         };\n \n         let src_node_id = src.item_id();\n@@ -70,13 +67,16 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are translated in.\n-        let mut check_overflow = attrs.iter().any(|item| {\n-            item.check_name(\"rustc_inherit_overflow_checks\")\n-        });\n+        let mut check_overflow = attrs.iter()\n+            .any(|item| item.check_name(\"rustc_inherit_overflow_checks\"));\n \n         // Respect -Z force-overflow-checks=on and -C debug-assertions.\n-        check_overflow |= infcx.tcx.sess.opts.debugging_opts.force_overflow_checks\n-               .unwrap_or(infcx.tcx.sess.opts.debug_assertions);\n+        check_overflow |= infcx.tcx\n+            .sess\n+            .opts\n+            .debugging_opts\n+            .force_overflow_checks\n+            .unwrap_or(infcx.tcx.sess.opts.debug_assertions);\n \n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n@@ -85,7 +85,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             tcx: infcx.tcx,\n             infcx: infcx,\n             constness: constness,\n-            check_overflow: check_overflow\n+            check_overflow: check_overflow,\n         }\n     }\n }\n@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n         match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n-            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val))},\n+            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val)) },\n             Err(_) => bug!(\"usize literal out of range for target\"),\n         }\n     }\n@@ -128,9 +128,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n-        Literal::Value {\n-            value: const_eval::eval_const_expr(self.tcx.global_tcx(), e)\n-        }\n+        Literal::Value { value: const_eval::eval_const_expr(self.tcx.global_tcx(), e) }\n     }\n \n     pub fn trait_method(&mut self,\n@@ -145,10 +143,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n                 let method_ty = self.tcx.item_type(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n-                return (method_ty, Literal::Item {\n-                    def_id: item.def_id,\n-                    substs: substs,\n-                });\n+                return (method_ty,\n+                        Literal::Item {\n+                            def_id: item.def_id,\n+                            substs: substs,\n+                        });\n             }\n         }\n \n@@ -168,7 +167,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty = self.tcx.lift_to_global(&ty).unwrap_or_else(|| {\n             bug!(\"MIR: Cx::needs_drop({}) got \\\n-                  type with inference types/regions\", ty);\n+                  type with inference types/regions\",\n+                 ty);\n         });\n         self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n     }"}, {"sha": "6930a959d6515ce2365e26e1a47574e15794b857", "filename": "src/librustc_mir/hair/cx/to_ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -18,32 +18,32 @@ pub trait ToRef {\n     fn to_ref(self) -> Self::Output;\n }\n \n-impl<'a,'tcx:'a> ToRef for &'tcx hir::Expr {\n+impl<'a, 'tcx: 'a> ToRef for &'tcx hir::Expr {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(self)\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef for &'tcx P<hir::Expr> {\n+impl<'a, 'tcx: 'a> ToRef for &'tcx P<hir::Expr> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(&**self)\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef for Expr<'tcx> {\n+impl<'a, 'tcx: 'a> ToRef for Expr<'tcx> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Mirror(Box::new(self))\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Option<T>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Option<U>;\n \n@@ -52,8 +52,8 @@ impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx Vec<T>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Vec<T>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Vec<U>;\n \n@@ -62,8 +62,8 @@ impl<'a,'tcx:'a,T,U> ToRef for &'tcx Vec<T>\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx P<[T]>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx P<[T]>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Vec<U>;\n "}, {"sha": "ac336fe45e54a2621a46ef8b2044b845c3369a4f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -1468,6 +1468,13 @@ impl<'a> Item<'a> {\n                 return None;\n             }\n         } else {\n+            // Macros from other libraries get special filenames which we can\n+            // safely ignore.\n+            if self.item.source.filename.starts_with(\"<\") &&\n+               self.item.source.filename.ends_with(\"macros>\") {\n+                return None;\n+            }\n+\n             let (krate, src_root) = match cache.extern_locations.get(&self.item.def_id.krate) {\n                 Some(&(ref name, ref src, Local)) => (name, src),\n                 Some(&(ref name, ref src, Remote(ref s))) => {"}, {"sha": "15912b41d59c061d9db61318a0ad1e486ec7c50c", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -52,13 +52,15 @@\n \tfont-family: 'Source Code Pro';\n \tfont-style: normal;\n \tfont-weight: 400;\n-\tsrc: local('Source Code Pro'), url(\"SourceCodePro-Regular.woff\") format('woff');\n+\t/* Avoid using locally installed font because bad versions are in circulation:\n+\t * see https://github.com/rust-lang/rust/issues/24355 */\n+\tsrc: url(\"SourceCodePro-Regular.woff\") format('woff');\n }\n @font-face {\n \tfont-family: 'Source Code Pro';\n \tfont-style: normal;\n \tfont-weight: 600;\n-\tsrc: local('Source Code Pro Semibold'), url(\"SourceCodePro-Semibold.woff\") format('woff');\n+\tsrc: url(\"SourceCodePro-Semibold.woff\") format('woff');\n }\n \n * {"}, {"sha": "f8a5ec0b3791e87ab377330077d7c5fb9d11bad8", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -499,6 +499,19 @@ impl UdpSocket {\n     /// This will retrieve the stored error in the underlying socket, clearing\n     /// the field in the process. This can be useful for checking errors between\n     /// calls.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// match socket.take_error() {\n+    ///     Ok(Some(error)) => println!(\"UdpSocket error: {:?}\", error),\n+    ///     Ok(None) => println!(\"No error\"),\n+    ///     Err(error) => println!(\"UdpSocket.take_error failed: {:?}\", error),\n+    /// }\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -507,15 +520,36 @@ impl UdpSocket {\n     /// Connects this UDP socket to a remote address, allowing the `send` and\n     /// `recv` syscalls to be used to send data and also applies filters to only\n     /// receive data from the specified address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n         super::each_addr(addr, |addr| self.0.connect(addr))\n     }\n \n     /// Sends data on the socket to the remote address to which it is connected.\n     ///\n-    /// The `connect` method will connect this socket to a remote address. This\n+    /// The [`connect()`] method will connect this socket to a remote address. This\n     /// method will fail if the socket is not connected.\n+    ///\n+    /// [`connect()`]: #method.connect\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n+    /// socket.send(&[0, 1, 2]).expect(\"couldn't send message\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.send(buf)\n@@ -526,6 +560,20 @@ impl UdpSocket {\n     ///\n     /// The `connect` method will connect this socket to a remote address. This\n     /// method will fail if the socket is not connected.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n+    /// let mut buf = [0; 10];\n+    /// match socket.recv(&mut buf) {\n+    ///     Ok(received) => println!(\"received {} bytes\", received),\n+    ///     Err(e) => println!(\"recv function failed: {:?}\", e),\n+    /// }\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.recv(buf)\n@@ -535,6 +583,15 @@ impl UdpSocket {\n     ///\n     /// On Unix this corresponds to calling fcntl, and on Windows this\n     /// corresponds to calling ioctlsocket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_nonblocking(true).expect(\"set_nonblocking call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)"}, {"sha": "9f51d3e87f3f74fc8a44a2ec3ba363645db6f5b6", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -454,10 +454,16 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n }\n \n /// Creates a new asynchronous channel, returning the sender/receiver halves.\n-///\n /// All data sent on the sender will become available on the receiver, and no\n /// send will block the calling thread (this channel has an \"infinite buffer\").\n ///\n+/// If the [`Receiver`] is disconnected while trying to [`send()`] with the\n+/// [`Sender`], the [`send()`] method will return an error.\n+///\n+/// [`send()`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+/// [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+/// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -487,18 +493,23 @@ pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n \n /// Creates a new synchronous, bounded channel.\n ///\n-/// Like asynchronous channels, the `Receiver` will block until a message\n+/// Like asynchronous channels, the [`Receiver`] will block until a message\n /// becomes available. These channels differ greatly in the semantics of the\n /// sender from asynchronous channels, however.\n ///\n-/// This channel has an internal buffer on which messages will be queued. `bound`\n-/// specifies the buffer size. When the internal buffer becomes full, future sends\n-/// will *block* waiting for the buffer to open up. Note that a buffer size of 0\n-/// is valid, in which case this becomes  \"rendezvous channel\" where each send will\n-/// not return until a recv is paired with it.\n+/// This channel has an internal buffer on which messages will be queued.\n+/// `bound` specifies the buffer size. When the internal buffer becomes full,\n+/// future sends will *block* waiting for the buffer to open up. Note that a\n+/// buffer size of 0 is valid, in which case this becomes \"rendezvous channel\"\n+/// where each [`send()`] will not return until a recv is paired with it.\n+///\n+/// Like asynchronous channels, if the [`Receiver`] is disconnected while\n+/// trying to [`send()`] with the [`SyncSender`], the [`send()`] method will\n+/// return an error.\n ///\n-/// As with asynchronous channels, all senders will panic in `send` if the\n-/// `Receiver` has been destroyed.\n+/// [`send()`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n+/// [`SyncSender`]: ../../../std/sync/mpsc/struct.SyncSender.html\n+/// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n ///\n /// # Examples\n ///"}, {"sha": "38fe5cdffebd0a7f2bc0c15aa6ca8768c9dae688", "filename": "src/test/incremental/hashes/closure_expressions.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -0,0 +1,144 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for closure expression.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change closure body ---------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_closure_body() {\n+    let _ = || 1u32;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_closure_body() {\n+    let _ = || 3u32;\n+}\n+\n+\n+\n+// Add parameter ---------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_parameter() {\n+    let x = 0u32;\n+    let _ = || x + 1;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_parameter() {\n+    let x = 0u32;\n+    let _ = |x: u32| x + 1;\n+}\n+\n+\n+\n+// Change parameter pattern ----------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_parameter_pattern() {\n+    let _ = |x: &u32| x;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_parameter_pattern() {\n+    let _ = |&x: &u32| x;\n+}\n+\n+\n+\n+// Add `move` to closure -------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_move() {\n+    let _ = || 1;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_move() {\n+    let _ = move || 1;\n+}\n+\n+\n+\n+// Add type ascription to parameter --------------------------------------------\n+#[cfg(cfail1)]\n+fn add_type_ascription_to_parameter() {\n+    let closure = |x| x + 1u32;\n+    let _: u32 = closure(1);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_type_ascription_to_parameter() {\n+    let closure = |x: u32| x + 1u32;\n+    let _: u32 = closure(1);\n+}\n+\n+\n+\n+// Change parameter type -------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_parameter_type() {\n+    let closure = |x: u32| (x as u64) + 1;\n+    let _ = closure(1);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_parameter_type() {\n+    let closure = |x: u16| (x as u64) + 1;\n+    let _ = closure(1);\n+}"}, {"sha": "7f991b30fc4924d98f91b1de001333d5834c8c5f", "filename": "src/test/incremental/hashes/enum_constructors.rs", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -0,0 +1,387 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for struct constructor expressions.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+enum Enum {\n+    Struct {\n+        x: i32,\n+        y: i64,\n+        z: i16,\n+    },\n+    Tuple(i32, i64, i16)\n+}\n+\n+// Change field value (struct-like) -----------------------------------------\n+#[cfg(cfail1)]\n+fn change_field_value_struct_like() -> Enum {\n+    Enum::Struct {\n+        x: 0,\n+        y: 1,\n+        z: 2,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_field_value_struct_like() -> Enum {\n+    Enum::Struct {\n+        x: 0,\n+        y: 2,\n+        z: 2,\n+    }\n+}\n+\n+\n+\n+// Change field order (struct-like) -----------------------------------------\n+#[cfg(cfail1)]\n+fn change_field_order_struct_like() -> Enum {\n+    Enum::Struct {\n+        x: 3,\n+        y: 4,\n+        z: 5,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_field_order_struct_like() -> Enum {\n+    Enum::Struct {\n+        y: 4,\n+        x: 3,\n+        z: 5,\n+    }\n+}\n+\n+\n+enum Enum2 {\n+    Struct {\n+        x: i8,\n+        y: i8,\n+        z: i8,\n+    },\n+    Struct2 {\n+        x: i8,\n+        y: i8,\n+        z: i8,\n+    },\n+    Tuple(u16, u16, u16),\n+    Tuple2(u64, u64, u64),\n+}\n+\n+// Change constructor path (struct-like) ------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_path_struct_like() {\n+    let _ = Enum::Struct {\n+        x: 0,\n+        y: 1,\n+        z: 2,\n+    };\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_path_struct_like() {\n+    let _ = Enum2::Struct {\n+        x: 0,\n+        y: 1,\n+        z: 2,\n+    };\n+}\n+\n+\n+\n+// Change variant (regular struct) ------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_variant_struct_like() {\n+    let _ = Enum2::Struct {\n+        x: 0,\n+        y: 1,\n+        z: 2,\n+    };\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_variant_struct_like() {\n+    let _ = Enum2::Struct2 {\n+        x: 0,\n+        y: 1,\n+        z: 2,\n+    };\n+}\n+\n+\n+// Change constructor path indirectly (struct-like) -------------------------\n+mod change_constructor_path_indirectly_struct_like {\n+    #[cfg(cfail1)]\n+    use super::Enum as TheEnum;\n+    #[cfg(not(cfail1))]\n+    use super::Enum2 as TheEnum;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> TheEnum {\n+        TheEnum::Struct {\n+            x: 0,\n+            y: 1,\n+            z: 2,\n+        }\n+    }\n+}\n+\n+\n+// Change constructor variant indirectly (struct-like) ---------------------------\n+mod change_constructor_variant_indirectly_struct_like {\n+    use super::Enum2;\n+    #[cfg(cfail1)]\n+    use super::Enum2::Struct as Variant;\n+    #[cfg(not(cfail1))]\n+    use super::Enum2::Struct2 as Variant;\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> Enum2 {\n+        Variant {\n+            x: 0,\n+            y: 1,\n+            z: 2,\n+        }\n+    }\n+}\n+\n+\n+// Change field value (tuple-like) -------------------------------------------\n+#[cfg(cfail1)]\n+fn change_field_value_tuple_like() -> Enum {\n+    Enum::Tuple(0, 1, 2)\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_field_value_tuple_like() -> Enum {\n+    Enum::Tuple(0, 1, 3)\n+}\n+\n+\n+\n+// Change constructor path (tuple-like) --------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_path_tuple_like() {\n+    let _ = Enum::Tuple(0, 1, 2);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_path_tuple_like() {\n+    let _ = Enum2::Tuple(0, 1, 2);\n+}\n+\n+\n+\n+// Change constructor variant (tuple-like) --------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_variant_tuple_like() {\n+    let _ = Enum2::Tuple(0, 1, 2);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_variant_tuple_like() {\n+    let _ = Enum2::Tuple2(0, 1, 2);\n+}\n+\n+\n+// Change constructor path indirectly (tuple-like) ---------------------------\n+mod change_constructor_path_indirectly_tuple_like {\n+    #[cfg(cfail1)]\n+    use super::Enum as TheEnum;\n+    #[cfg(not(cfail1))]\n+    use super::Enum2 as TheEnum;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> TheEnum {\n+        TheEnum::Tuple(0, 1, 2)\n+    }\n+}\n+\n+\n+\n+// Change constructor variant indirectly (tuple-like) ---------------------------\n+mod change_constructor_variant_indirectly_tuple_like {\n+    use super::Enum2;\n+    #[cfg(cfail1)]\n+    use super::Enum2::Tuple as Variant;\n+    #[cfg(not(cfail1))]\n+    use super::Enum2::Tuple2 as Variant;\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> Enum2 {\n+        Variant(0, 1, 2)\n+    }\n+}\n+\n+\n+enum Clike {\n+    A,\n+    B,\n+    C\n+}\n+\n+enum Clike2 {\n+    B,\n+    C,\n+    D\n+}\n+\n+// Change constructor path (C-like) --------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_path_c_like() {\n+    let _ = Clike::B;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_path_c_like() {\n+    let _ = Clike2::B;\n+}\n+\n+\n+\n+// Change constructor variant (C-like) --------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_variant_c_like() {\n+    let _ = Clike::A;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_variant_c_like() {\n+    let _ = Clike::C;\n+}\n+\n+\n+// Change constructor path indirectly (C-like) ---------------------------\n+mod change_constructor_path_indirectly_c_like {\n+    #[cfg(cfail1)]\n+    use super::Clike as TheEnum;\n+    #[cfg(not(cfail1))]\n+    use super::Clike2 as TheEnum;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> TheEnum {\n+        TheEnum::B\n+    }\n+}\n+\n+\n+\n+// Change constructor variant indirectly (C-like) ---------------------------\n+mod change_constructor_variant_indirectly_c_like {\n+    use super::Clike;\n+    #[cfg(cfail1)]\n+    use super::Clike::A as Variant;\n+    #[cfg(not(cfail1))]\n+    use super::Clike::B as Variant;\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> Clike {\n+        Variant\n+    }\n+}"}, {"sha": "082badacc6ccd6143429d77a7164afe9c21b8479", "filename": "src/test/incremental/hashes/exported_vs_not.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -0,0 +1,86 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+// Case 1: The function body is not exported to metadata. If the body changes,\n+//         the hash of the HirBody node should change, but not the hash of\n+//         either the Hir or the Metadata node.\n+\n+#[cfg(cfail1)]\n+pub fn body_not_exported_to_metadata() -> u32 {\n+    1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn body_not_exported_to_metadata() -> u32 {\n+    2\n+}\n+\n+\n+\n+// Case 2: The function body *is* exported to metadata because the function is\n+//         marked as #[inline]. Only the hash of the Hir depnode should be\n+//         unaffected by a change to the body.\n+\n+#[cfg(cfail1)]\n+#[inline]\n+pub fn body_exported_to_metadata_because_of_inline() -> u32 {\n+    1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[inline]\n+pub fn body_exported_to_metadata_because_of_inline() -> u32 {\n+    2\n+}\n+\n+\n+\n+// Case 2: The function body *is* exported to metadata because the function is\n+//         generic. Only the hash of the Hir depnode should be\n+//         unaffected by a change to the body.\n+\n+#[cfg(cfail1)]\n+#[inline]\n+pub fn body_exported_to_metadata_because_of_generic() -> u32 {\n+    1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[inline]\n+pub fn body_exported_to_metadata_because_of_generic() -> u32 {\n+    2\n+}\n+"}, {"sha": "bb31982d93f2139f5c5fc608452d02a50f290690", "filename": "src/test/incremental/hashes/indexing_expressions.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for closure expression.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+#![feature(inclusive_range_syntax)]\n+\n+// Change simple index ---------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_simple_index(slice: &[u32]) -> u32 {\n+    slice[3]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_simple_index(slice: &[u32]) -> u32 {\n+    slice[4]\n+}\n+\n+\n+\n+// Change lower bound ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_lower_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..5]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_lower_bound(slice: &[u32]) -> &[u32] {\n+    &slice[2..5]\n+}\n+\n+\n+\n+// Change upper bound ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_upper_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..5]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_upper_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..7]\n+}\n+\n+\n+\n+// Add lower bound -------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_lower_bound(slice: &[u32]) -> &[u32] {\n+    &slice[..4]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_lower_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..4]\n+}\n+\n+\n+\n+// Add upper bound -------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_upper_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_upper_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..7]\n+}\n+\n+\n+\n+// Change mutability -----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_mutability(slice: &mut [u32]) -> u32 {\n+    (&mut slice[3..5])[0]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_mutability(slice: &mut [u32]) -> u32 {\n+    (&slice[3..5])[0]\n+}\n+\n+\n+\n+// Exclusive to inclusive range ------------------------------------------------\n+#[cfg(cfail1)]\n+fn exclusive_to_inclusive_range(slice: &[u32]) -> &[u32] {\n+    &slice[3..7]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn exclusive_to_inclusive_range(slice: &[u32]) -> &[u32] {\n+    &slice[3...7]\n+}"}, {"sha": "0e23d953baf2de48d86e6dbca9d8eb4dfd9544a1", "filename": "src/test/incremental/hashes/struct_constructors.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -202,6 +202,12 @@ mod change_constructor_path_indirectly_regular_struct {\n     #[cfg(not(cfail1))]\n     use super::RegularStruct2 as Struct;\n \n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> Struct {\n         Struct {\n             x: 0,\n@@ -262,6 +268,12 @@ mod change_constructor_path_indirectly_tuple_struct {\n     #[cfg(not(cfail1))]\n     use super::TupleStruct2 as Struct;\n \n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> Struct {\n         Struct(0, 1, 2)\n     }"}, {"sha": "d281a6abc93e37ef7321bf83110ec54846e3df5a", "filename": "x.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b50b33df6015e5bae97c5224e3180885dcc66/x.py", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b50b33df6015e5bae97c5224e3180885dcc66/x.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/x.py?ref=5a2b50b33df6015e5bae97c5224e3180885dcc66", "patch": "@@ -16,4 +16,7 @@\n \n import bootstrap\n \n-bootstrap.main()\n+try:\n+    bootstrap.main()\n+except KeyboardInterrupt:\n+    sys.exit()"}]}