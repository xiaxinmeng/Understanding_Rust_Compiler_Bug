{"sha": "c8642daf93f725685309fc12f9d0908fec54b63a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NjQyZGFmOTNmNzI1Njg1MzA5ZmMxMmY5ZDA5MDhmZWM1NGI2M2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-03T16:25:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-03T16:25:46Z"}, "message": "Auto merge of #44191 - arielb1:on-unimplemented-label, r=nikomatsakis\n\nMore general `on_unimplemented`, with uses in `Try`\n\nAllow `on_unimplemented` directives to specify both the label and the primary message of the trait error, and allow them to be controlled by flags - currently only to be desugaring-sensitive.\n\ne.g.\n```Rust\n#[rustc_on_unimplemented(\n    on(all(direct, from_desugaring=\"?\"),\n        message=\"the `?` operator can only be used in a \\\n        function that returns `Result` \\\n        (or another type that implements `{Try}`)\",\n        label=\"cannot use the `?` operator in a function that returns `{Self}`\"),\n)]\n```\n\nr? @nikomatsakis", "tree": {"sha": "36cdc2201fae2bc78a1c9a765c1c1534cf41b201", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36cdc2201fae2bc78a1c9a765c1c1534cf41b201"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8642daf93f725685309fc12f9d0908fec54b63a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8642daf93f725685309fc12f9d0908fec54b63a", "html_url": "https://github.com/rust-lang/rust/commit/c8642daf93f725685309fc12f9d0908fec54b63a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8642daf93f725685309fc12f9d0908fec54b63a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f2b8b34c2a1e585117714f99b3858da5f1b92b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2b8b34c2a1e585117714f99b3858da5f1b92b5", "html_url": "https://github.com/rust-lang/rust/commit/2f2b8b34c2a1e585117714f99b3858da5f1b92b5"}, {"sha": "291b4eddcefd1d6da1010f8a1f02f05338a44050", "url": "https://api.github.com/repos/rust-lang/rust/commits/291b4eddcefd1d6da1010f8a1f02f05338a44050", "html_url": "https://github.com/rust-lang/rust/commit/291b4eddcefd1d6da1010f8a1f02f05338a44050"}], "stats": {"total": 927, "additions": 652, "deletions": 275}, "files": [{"sha": "e788b66a1ec82f35b037299f7ee1ad3b3c565f1f", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -15,8 +15,24 @@\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n-#[rustc_on_unimplemented = \"the `?` operator can only be used in a function that returns `Result` \\\n-                            (or another type that implements `{Try}`)\"]\n+#[cfg_attr(stage0,\n+           rustc_on_unimplemented = \"the `?` operator can only be used in a \\\n+                                     function that returns `Result` \\\n+                                     (or another type that implements `{Try}`)\")]\n+#[cfg_attr(not(stage0),\n+           rustc_on_unimplemented(\n+               on(all(\n+                   any(from_method=\"from_error\", from_method=\"from_ok\"),\n+                   from_desugaring=\"?\"),\n+                  message=\"the `?` operator can only be used in a \\\n+                           function that returns `Result` \\\n+                           (or another type that implements `{Try}`)\",\n+                  label=\"cannot use the `?` operator in a function that returns `{Self}`\"),\n+               on(all(from_method=\"into_result\", from_desugaring=\"?\"),\n+                  message=\"the `?` operator can only be applied to values \\\n+                           that implement `{Try}`\",\n+                  label=\"the `?` operator cannot be applied to type `{Self}`\")\n+))]\n pub trait Try {\n     /// The type of this value when viewed as successful.\n     #[unstable(feature = \"try_trait\", issue = \"42327\")]"}, {"sha": "be7bb4d8114132d042132107c6de1e5da71a3ef1", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 92, "deletions": 88, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -688,8 +688,8 @@ See also https://doc.rust-lang.org/book/first-edition/no-stdlib.html\n \"##,\n \n E0214: r##\"\n-A generic type was described using parentheses rather than angle brackets. For\n-example:\n+A generic type was described using parentheses rather than angle brackets.\n+For example:\n \n ```compile_fail,E0214\n fn main() {\n@@ -702,6 +702,93 @@ Parentheses are currently only used with generic types when defining parameters\n for `Fn`-family traits.\n \"##,\n \n+E0230: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(on_unimplemented)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+There will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n+\n+This error appears when the curly braces contain an identifier which doesn't\n+match with any of the type parameters or the string `Self`. This might happen\n+if you misspelled a type parameter, or if you intended to use literal curly\n+braces. If it is the latter, escape the curly braces with a second curly brace\n+of the same type; e.g. a literal `{` is `{{`.\n+\"##,\n+\n+E0231: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(on_unimplemented)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n+\n+This error appears when the curly braces do not contain an identifier. Please\n+add one of the same name as a type parameter. If you intended to use literal\n+braces, use `{{` and `}}` to escape them.\n+\"##,\n+\n+E0232: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(on_unimplemented)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+For this to work, some note must be specified. An empty attribute will not do\n+anything, please remove the attribute or add some helpful note for users of the\n+trait.\n+\"##,\n+\n E0261: r##\"\n When using a lifetime like `'a` in a type, it must be declared before being\n used.\n@@ -917,92 +1004,6 @@ for v in &vs {\n ```\n \"##,\n \n-E0272: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(on_unimplemented)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-There will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-As you can see, you can specify type parameters in curly braces for\n-substitution with the actual types (using the regular format string syntax) in\n-a given situation. Furthermore, `{Self}` will substitute to the type (in this\n-case, `bool`) that we tried to use.\n-\n-This error appears when the curly braces contain an identifier which doesn't\n-match with any of the type parameters or the string `Self`. This might happen\n-if you misspelled a type parameter, or if you intended to use literal curly\n-braces. If it is the latter, escape the curly braces with a second curly brace\n-of the same type; e.g. a literal `{` is `{{`.\n-\"##,\n-\n-E0273: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(on_unimplemented)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-there will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-As you can see, you can specify type parameters in curly braces for\n-substitution with the actual types (using the regular format string syntax) in\n-a given situation. Furthermore, `{Self}` will substitute to the type (in this\n-case, `bool`) that we tried to use.\n-\n-This error appears when the curly braces do not contain an identifier. Please\n-add one of the same name as a type parameter. If you intended to use literal\n-braces, use `{{` and `}}` to escape them.\n-\"##,\n-\n-E0274: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(on_unimplemented)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-there will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-For this to work, some note must be specified. An empty attribute will not do\n-anything, please remove the attribute or add some helpful note for users of the\n-trait.\n-\"##,\n \n E0275: r##\"\n This error occurs when there was a recursive trait requirement that overflowed\n@@ -2011,6 +2012,9 @@ register_diagnostics! {\n //  E0102, // replaced with E0282\n //  E0134,\n //  E0135,\n+//  E0272, // on_unimplemented #0\n+//  E0273, // on_unimplemented #1\n+//  E0274, // on_unimplemented #2\n     E0278, // requirement is not satisfied\n     E0279, // requirement is not satisfied\n     E0280, // requirement is not satisfied"}, {"sha": "ce6da55fec36b850277896f6f2d1f7828bd7af5a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 60, "deletions": 74, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -15,6 +15,8 @@ use super::{\n     Obligation,\n     ObligationCause,\n     ObligationCauseCode,\n+    OnUnimplementedDirective,\n+    OnUnimplementedNote,\n     OutputTypeParameterMismatch,\n     TraitNotObjectSafe,\n     PredicateObligation,\n@@ -25,7 +27,6 @@ use super::{\n };\n \n use errors::DiagnosticBuilder;\n-use fmt_macros::{Parser, Piece, Position};\n use hir;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n@@ -316,77 +317,56 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn on_unimplemented_note(&self,\n-                             trait_ref: ty::PolyTraitRef<'tcx>,\n-                             obligation: &PredicateObligation<'tcx>) -> Option<String> {\n+    fn on_unimplemented_note(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>) ->\n+        OnUnimplementedNote\n+    {\n         let def_id = self.impl_similar_to(trait_ref, obligation)\n             .unwrap_or(trait_ref.def_id());\n-        let trait_ref = trait_ref.skip_binder();\n+        let trait_ref = *trait_ref.skip_binder();\n+\n+        let desugaring;\n+        let method;\n+        let mut flags = vec![];\n+        let direct = match obligation.cause.code {\n+            ObligationCauseCode::BuiltinDerivedObligation(..) |\n+            ObligationCauseCode::ImplDerivedObligation(..) => false,\n+            _ => true\n+        };\n+        if direct {\n+            // this is a \"direct\", user-specified, rather than derived,\n+            // obligation.\n+            flags.push((\"direct\", None));\n+        }\n \n-        let span = obligation.cause.span;\n-        let mut report = None;\n-        if let Some(item) = self.tcx\n-            .get_attrs(def_id)\n-            .into_iter()\n-            .filter(|a| a.check_name(\"rustc_on_unimplemented\"))\n-            .next()\n-        {\n-            let name = self.tcx.item_name(def_id).as_str();\n-            let err_sp = item.span.substitute_dummy(span);\n-            let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n-            if let Some(istring) = item.value_str() {\n-                let istring = &*istring.as_str();\n-                let generics = self.tcx.generics_of(trait_ref.def_id);\n-                let generic_map = generics.types.iter().map(|param| {\n-                    (param.name.as_str().to_string(),\n-                        trait_ref.substs.type_for_def(param).to_string())\n-                }).collect::<FxHashMap<String, String>>();\n-                let parser = Parser::new(istring);\n-                let mut errored = false;\n-                let err: String = parser.filter_map(|p| {\n-                    match p {\n-                        Piece::String(s) => Some(s),\n-                        Piece::NextArgument(a) => match a.position {\n-                            Position::ArgumentNamed(s) => match generic_map.get(s) {\n-                                Some(val) => Some(val),\n-                                None if s == name => {\n-                                    Some(&trait_str)\n-                                }\n-                                None => {\n-                                    span_err!(self.tcx.sess, err_sp, E0272,\n-                                              \"the #[rustc_on_unimplemented] attribute on trait \\\n-                                               definition for {} refers to non-existent type \\\n-                                               parameter {}\",\n-                                              trait_str, s);\n-                                    errored = true;\n-                                    None\n-                                }\n-                            },\n-                            _ => {\n-                                span_err!(self.tcx.sess, err_sp, E0273,\n-                                          \"the #[rustc_on_unimplemented] attribute on trait \\\n-                                           definition for {} must have named format arguments, eg \\\n-                                           `#[rustc_on_unimplemented = \\\"foo {{T}}\\\"]`\",\n-                                          trait_str);\n-                                errored = true;\n-                                None\n-                            }\n-                        }\n-                    }\n-                }).collect();\n-                // Report only if the format string checks out\n-                if !errored {\n-                    report = Some(err);\n-                }\n-            } else {\n-                span_err!(self.tcx.sess, err_sp, E0274,\n-                                        \"the #[rustc_on_unimplemented] attribute on \\\n-                                                    trait definition for {} must have a value, \\\n-                                                    eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n-                                                    trait_str);\n+        if let ObligationCauseCode::ItemObligation(item) = obligation.cause.code {\n+            // FIXME: maybe also have some way of handling methods\n+            // from other traits? That would require name resolution,\n+            // which we might want to be some sort of hygienic.\n+            //\n+            // Currently I'm leaving it for what I need for `try`.\n+            if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n+                method = self.tcx.item_name(item).as_str();\n+                flags.push((\"from_method\", None));\n+                flags.push((\"from_method\", Some(&*method)));\n             }\n         }\n-        report\n+\n+        if let Some(k) = obligation.cause.span.compiler_desugaring_kind() {\n+            desugaring = k.as_symbol().as_str();\n+            flags.push((\"from_desugaring\", None));\n+            flags.push((\"from_desugaring\", Some(&*desugaring)));\n+        }\n+\n+        if let Ok(Some(command)) = OnUnimplementedDirective::of_item(\n+            self.tcx, trait_ref.def_id, def_id\n+        ) {\n+            command.evaluate(self.tcx, trait_ref, &flags)\n+        } else {\n+            OnUnimplementedNote::empty()\n+        }\n     }\n \n     fn find_similar_impl_candidates(&self,\n@@ -577,17 +557,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         let (post_message, pre_message) =\n                             self.get_parent_trait_ref(&obligation.cause.code)\n                                 .map(|t| (format!(\" in `{}`\", t), format!(\"within `{}`, \", t)))\n-                                .unwrap_or((String::new(), String::new()));\n+                            .unwrap_or((String::new(), String::new()));\n+\n+                        let OnUnimplementedNote { message, label }\n+                            = self.on_unimplemented_note(trait_ref, obligation);\n+                        let have_alt_message = message.is_some() || label.is_some();\n+\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             span,\n                             E0277,\n-                            \"the trait bound `{}` is not satisfied{}\",\n-                            trait_ref.to_predicate(),\n-                            post_message);\n+                            \"{}\",\n+                            message.unwrap_or_else(|| {\n+                                format!(\"the trait bound `{}` is not satisfied{}\",\n+                                         trait_ref.to_predicate(), post_message)\n+                            }));\n \n-                        let unimplemented_note = self.on_unimplemented_note(trait_ref, obligation);\n-                        if let Some(ref s) = unimplemented_note {\n+                        if let Some(ref s) = label {\n                             // If it has a custom \"#[rustc_on_unimplemented]\"\n                             // error message, let's display it as the label!\n                             err.span_label(span, s.as_str());\n@@ -615,7 +601,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // which is somewhat confusing.\n                             err.help(&format!(\"consider adding a `where {}` bound\",\n                                                 trait_ref.to_predicate()));\n-                        } else if unimplemented_note.is_none() {\n+                        } else if !have_alt_message {\n                             // Can't show anything else useful, try to find similar impls.\n                             let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n                             self.report_similar_impl_candidates(impl_candidates, &mut err);"}, {"sha": "33dcf3c76e6cfcb885af7ffc6c35f2490d5dd113", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -37,6 +37,7 @@ pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n+pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};\n@@ -52,6 +53,7 @@ mod error_reporting;\n mod fulfill;\n mod project;\n mod object_safety;\n+mod on_unimplemented;\n mod select;\n mod specialize;\n mod structural_impls;"}, {"sha": "7dd3fc70b1e3fbf18852932d0c58fe5426eb4df5", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -0,0 +1,307 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt_macros::{Parser, Piece, Position};\n+\n+use hir::def_id::DefId;\n+use ty::{self, TyCtxt};\n+use util::common::ErrorReported;\n+use util::nodemap::FxHashMap;\n+\n+use syntax::ast::{MetaItem, NestedMetaItem};\n+use syntax::attr;\n+use syntax_pos::Span;\n+use syntax_pos::symbol::InternedString;\n+\n+#[derive(Clone, Debug)]\n+pub struct OnUnimplementedFormatString(InternedString);\n+\n+#[derive(Debug)]\n+pub struct OnUnimplementedDirective {\n+    pub condition: Option<MetaItem>,\n+    pub subcommands: Vec<OnUnimplementedDirective>,\n+    pub message: Option<OnUnimplementedFormatString>,\n+    pub label: Option<OnUnimplementedFormatString>,\n+}\n+\n+pub struct OnUnimplementedNote {\n+    pub message: Option<String>,\n+    pub label: Option<String>,\n+}\n+\n+impl OnUnimplementedNote {\n+    pub fn empty() -> Self {\n+        OnUnimplementedNote { message: None, label: None }\n+    }\n+}\n+\n+fn parse_error(tcx: TyCtxt, span: Span,\n+               message: &str,\n+               label: &str,\n+               note: Option<&str>)\n+               -> ErrorReported\n+{\n+    let mut diag = struct_span_err!(\n+        tcx.sess, span, E0232, \"{}\", message);\n+    diag.span_label(span, label);\n+    if let Some(note) = note {\n+        diag.note(note);\n+    }\n+    diag.emit();\n+    ErrorReported\n+}\n+\n+impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n+    pub fn parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                 trait_def_id: DefId,\n+                 items: &[NestedMetaItem],\n+                 span: Span,\n+                 is_root: bool)\n+                 -> Result<Self, ErrorReported>\n+    {\n+        let mut errored = false;\n+        let mut item_iter = items.iter();\n+\n+        let condition = if is_root {\n+            None\n+        } else {\n+            let cond = item_iter.next().ok_or_else(|| {\n+                parse_error(tcx, span,\n+                            \"empty `on`-clause in `#[rustc_on_unimplemented]`\",\n+                            \"empty on-clause here\",\n+                            None)\n+            })?.meta_item().ok_or_else(|| {\n+                parse_error(tcx, span,\n+                            \"invalid `on`-clause in `#[rustc_on_unimplemented]`\",\n+                            \"invalid on-clause here\",\n+                            None)\n+            })?;\n+            attr::eval_condition(cond, &tcx.sess.parse_sess, &mut |_| true);\n+            Some(cond.clone())\n+        };\n+\n+        let mut message = None;\n+        let mut label = None;\n+        let mut subcommands = vec![];\n+        for item in item_iter {\n+            if item.check_name(\"message\") && message.is_none() {\n+                if let Some(message_) = item.value_str() {\n+                    message = Some(OnUnimplementedFormatString::try_parse(\n+                        tcx, trait_def_id, message_.as_str(), span)?);\n+                    continue;\n+                }\n+            } else if item.check_name(\"label\") && label.is_none() {\n+                if let Some(label_) = item.value_str() {\n+                    label = Some(OnUnimplementedFormatString::try_parse(\n+                        tcx, trait_def_id, label_.as_str(), span)?);\n+                    continue;\n+                }\n+            } else if item.check_name(\"on\") && is_root &&\n+                message.is_none() && label.is_none()\n+            {\n+                if let Some(items) = item.meta_item_list() {\n+                    if let Ok(subcommand) =\n+                        Self::parse(tcx, trait_def_id, &items, item.span, false)\n+                    {\n+                        subcommands.push(subcommand);\n+                    } else {\n+                        errored = true;\n+                    }\n+                    continue\n+                }\n+            }\n+\n+            // nothing found\n+            parse_error(tcx, item.span,\n+                        \"this attribute must have a valid value\",\n+                        \"expected value here\",\n+                        Some(r#\"eg `#[rustc_on_unimplemented = \"foo\"]`\"#));\n+        }\n+\n+        if errored {\n+            Err(ErrorReported)\n+        } else {\n+            Ok(OnUnimplementedDirective { condition, message, label, subcommands })\n+        }\n+    }\n+\n+\n+    pub fn of_item(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                   trait_def_id: DefId,\n+                   impl_def_id: DefId)\n+                   -> Result<Option<Self>, ErrorReported>\n+    {\n+        let attrs = tcx.get_attrs(impl_def_id);\n+\n+        let attr = if let Some(item) =\n+            attrs.into_iter().find(|a| a.check_name(\"rustc_on_unimplemented\"))\n+        {\n+            item\n+        } else {\n+            return Ok(None);\n+        };\n+\n+        let result = if let Some(items) = attr.meta_item_list() {\n+            Self::parse(tcx, trait_def_id, &items, attr.span, true).map(Some)\n+        } else if let Some(value) = attr.value_str() {\n+            Ok(Some(OnUnimplementedDirective {\n+                condition: None,\n+                message: None,\n+                subcommands: vec![],\n+                label: Some(OnUnimplementedFormatString::try_parse(\n+                    tcx, trait_def_id, value.as_str(), attr.span)?)\n+            }))\n+        } else {\n+            return Err(parse_error(tcx, attr.span,\n+                                   \"`#[rustc_on_unimplemented]` requires a value\",\n+                                   \"value required here\",\n+                                   Some(r#\"eg `#[rustc_on_unimplemented = \"foo\"]`\"#)));\n+        };\n+        debug!(\"of_item({:?}/{:?}) = {:?}\", trait_def_id, impl_def_id, result);\n+        result\n+    }\n+\n+    pub fn evaluate(&self,\n+                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    trait_ref: ty::TraitRef<'tcx>,\n+                    options: &[(&str, Option<&str>)])\n+                    -> OnUnimplementedNote\n+    {\n+        let mut message = None;\n+        let mut label = None;\n+        info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\",\n+              self, trait_ref, options);\n+\n+        for command in self.subcommands.iter().chain(Some(self)).rev() {\n+            if let Some(ref condition) = command.condition {\n+                if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n+                    options.contains(&(&c.name().as_str(),\n+                                      match c.value_str().map(|s| s.as_str()) {\n+                                          Some(ref s) => Some(s),\n+                                          None => None\n+                                      }))\n+                }) {\n+                    debug!(\"evaluate: skipping {:?} due to condition\", command);\n+                    continue\n+                }\n+            }\n+            debug!(\"evaluate: {:?} succeeded\", command);\n+            if let Some(ref message_) = command.message {\n+                message = Some(message_.clone());\n+            }\n+\n+            if let Some(ref label_) = command.label {\n+                label = Some(label_.clone());\n+            }\n+        }\n+\n+        OnUnimplementedNote {\n+            label: label.map(|l| l.format(tcx, trait_ref)),\n+            message: message.map(|m| m.format(tcx, trait_ref))\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n+    pub fn try_parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                     trait_def_id: DefId,\n+                     from: InternedString,\n+                     err_sp: Span)\n+                     -> Result<Self, ErrorReported>\n+    {\n+        let result = OnUnimplementedFormatString(from);\n+        result.verify(tcx, trait_def_id, err_sp)?;\n+        Ok(result)\n+    }\n+\n+    fn verify(&self,\n+              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+              trait_def_id: DefId,\n+              span: Span)\n+              -> Result<(), ErrorReported>\n+    {\n+        let name = tcx.item_name(trait_def_id).as_str();\n+        let generics = tcx.generics_of(trait_def_id);\n+        let parser = Parser::new(&self.0);\n+        let types = &generics.types;\n+        let mut result = Ok(());\n+        for token in parser {\n+            match token {\n+                Piece::String(_) => (), // Normal string, no need to check it\n+                Piece::NextArgument(a) => match a.position {\n+                    // `{Self}` is allowed\n+                    Position::ArgumentNamed(s) if s == \"Self\" => (),\n+                    // `{ThisTraitsName}` is allowed\n+                    Position::ArgumentNamed(s) if s == name => (),\n+                    // So is `{A}` if A is a type parameter\n+                    Position::ArgumentNamed(s) => match types.iter().find(|t| {\n+                        t.name == s\n+                    }) {\n+                        Some(_) => (),\n+                        None => {\n+                            span_err!(tcx.sess, span, E0230,\n+                                      \"there is no type parameter \\\n+                                       {} on trait {}\",\n+                                      s, name);\n+                            result = Err(ErrorReported);\n+                        }\n+                    },\n+                    // `{:1}` and `{}` are not to be used\n+                    Position::ArgumentIs(_) => {\n+                        span_err!(tcx.sess, span, E0231,\n+                                  \"only named substitution \\\n+                                   parameters are allowed\");\n+                        result = Err(ErrorReported);\n+                    }\n+                }\n+            }\n+        }\n+\n+        result\n+    }\n+\n+    pub fn format(&self,\n+                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                  trait_ref: ty::TraitRef<'tcx>)\n+                  -> String\n+    {\n+        let name = tcx.item_name(trait_ref.def_id).as_str();\n+        let trait_str = tcx.item_path_str(trait_ref.def_id);\n+        let generics = tcx.generics_of(trait_ref.def_id);\n+        let generic_map = generics.types.iter().map(|param| {\n+            (param.name.as_str().to_string(),\n+             trait_ref.substs.type_for_def(param).to_string())\n+        }).collect::<FxHashMap<String, String>>();\n+\n+        let parser = Parser::new(&self.0);\n+        parser.map(|p| {\n+            match p {\n+                Piece::String(s) => s,\n+                Piece::NextArgument(a) => match a.position {\n+                    Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                        Some(val) => val,\n+                        None if s == name => {\n+                            &trait_str\n+                        }\n+                        None => {\n+                            bug!(\"broken on_unimplemented {:?} for {:?}: \\\n+                                  no argument matching {:?}\",\n+                                 self.0, trait_ref, s)\n+                        }\n+                    },\n+                    _ => {\n+                        bug!(\"broken on_unimplemented {:?} - bad \\\n+                              format arg\", self.0)\n+                    }\n+                }\n+            }\n+        }).collect()\n+    }\n+}"}, {"sha": "3f210ea1737b736300ccddf5abbe723137bdd0bc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 49, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -85,7 +85,6 @@ use self::method::MethodCallee;\n use self::TupleArgumentsFlag::*;\n \n use astconv::AstConv;\n-use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_back::slice::ref_slice;\n@@ -1215,55 +1214,11 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n }\n \n fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    def_id: DefId,\n+                                    trait_def_id: DefId,\n                                     item: &hir::Item) {\n-    let generics = tcx.generics_of(def_id);\n-    if let Some(ref attr) = item.attrs.iter().find(|a| {\n-        a.check_name(\"rustc_on_unimplemented\")\n-    }) {\n-        if let Some(istring) = attr.value_str() {\n-            let istring = istring.as_str();\n-            let name = tcx.item_name(def_id).as_str();\n-            let parser = Parser::new(&istring);\n-            let types = &generics.types;\n-            for token in parser {\n-                match token {\n-                    Piece::String(_) => (), // Normal string, no need to check it\n-                    Piece::NextArgument(a) => match a.position {\n-                        // `{Self}` is allowed\n-                        Position::ArgumentNamed(s) if s == \"Self\" => (),\n-                        // `{ThisTraitsName}` is allowed\n-                        Position::ArgumentNamed(s) if s == name => (),\n-                        // So is `{A}` if A is a type parameter\n-                        Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                            t.name == s\n-                        }) {\n-                            Some(_) => (),\n-                            None => {\n-                                span_err!(tcx.sess, attr.span, E0230,\n-                                                 \"there is no type parameter \\\n-                                                          {} on trait {}\",\n-                                                           s, name);\n-                            }\n-                        },\n-                        // `{:1}` and `{}` are not to be used\n-                        Position::ArgumentIs(_) => {\n-                            span_err!(tcx.sess, attr.span, E0231,\n-                                                  \"only named substitution \\\n-                                                   parameters are allowed\");\n-                        }\n-                    }\n-                }\n-            }\n-        } else {\n-            struct_span_err!(\n-                tcx.sess, attr.span, E0232,\n-                \"this attribute must have a value\")\n-                .span_label(attr.span, \"attribute requires a value\")\n-                .note(&format!(\"eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\"))\n-                .emit();\n-        }\n-    }\n+    let item_def_id = tcx.hir.local_def_id(item.id);\n+    // an error would be reported if this fails.\n+    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id);\n }\n \n fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "6bbe2233ff1fa40360beb0d62f6d6a01902c7455", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -2505,50 +2505,6 @@ fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\n ```\n \"##,\n \n-E0230: r##\"\n-The trait has more type parameters specified than appear in its definition.\n-\n-Erroneous example code:\n-\n-```compile_fail,E0230\n-#![feature(on_unimplemented)]\n-#[rustc_on_unimplemented = \"Trait error on `{Self}` with `<{A},{B},{C}>`\"]\n-// error: there is no type parameter C on trait TraitWithThreeParams\n-trait TraitWithThreeParams<A,B>\n-{}\n-```\n-\n-Include the correct number of type parameters and the compilation should\n-proceed:\n-\n-```\n-#![feature(on_unimplemented)]\n-#[rustc_on_unimplemented = \"Trait error on `{Self}` with `<{A},{B},{C}>`\"]\n-trait TraitWithThreeParams<A,B,C> // ok!\n-{}\n-```\n-\"##,\n-\n-E0232: r##\"\n-The attribute must have a value. Erroneous code example:\n-\n-```compile_fail,E0232\n-#![feature(on_unimplemented)]\n-\n-#[rustc_on_unimplemented] // error: this attribute must have a value\n-trait Bar {}\n-```\n-\n-Please supply the missing value of the attribute. Example:\n-\n-```\n-#![feature(on_unimplemented)]\n-\n-#[rustc_on_unimplemented = \"foo\"] // ok!\n-trait Bar {}\n-```\n-\"##,\n-\n E0243: r##\"\n This error indicates that not enough type parameters were found in a type or\n trait.\n@@ -4690,7 +4646,6 @@ register_diagnostics! {\n     E0224, // at least one non-builtin train is required for an object type\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required\n     E0228, // explicit lifetime bound required\n-    E0231, // only named substitution parameters are allowed\n //  E0233,\n //  E0234,\n //  E0235, // structure constructor specifies a structure of type but"}, {"sha": "7a6ee73b9b9e9f1c14d6a8ac0f7028afa843d819", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -84,7 +84,6 @@ This API is completely unstable and subject to change.\n extern crate syntax_pos;\n \n extern crate arena;\n-extern crate fmt_macros;\n #[macro_use] extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_back;"}, {"sha": "adbbc1b0ac5885b6f7aaaa9a3923ac4a97be47a7", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -585,6 +585,20 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n \n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n+    eval_condition(cfg, sess, &mut |cfg| {\n+        if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n+            gated_cfg.check_and_emit(sess, feats);\n+        }\n+        sess.config.contains(&(cfg.name(), cfg.value_str()))\n+    })\n+}\n+\n+/// Evaluate a cfg-like condition (with `any` and `all`), using `eval` to\n+/// evaluate individual items.\n+pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n+                         -> bool\n+    where F: FnMut(&ast::MetaItem) -> bool\n+{\n     match cfg.node {\n         ast::MetaItemKind::List(ref mis) => {\n             for mi in mis.iter() {\n@@ -598,18 +612,18 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n             // that they won't fail with the loop above.\n             match &*cfg.name.as_str() {\n                 \"any\" => mis.iter().any(|mi| {\n-                    cfg_matches(mi.meta_item().unwrap(), sess, features)\n+                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n                 \"all\" => mis.iter().all(|mi| {\n-                    cfg_matches(mi.meta_item().unwrap(), sess, features)\n+                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n                 \"not\" => {\n                     if mis.len() != 1 {\n                         span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n                         return false;\n                     }\n \n-                    !cfg_matches(mis[0].meta_item().unwrap(), sess, features)\n+                    !eval_condition(mis[0].meta_item().unwrap(), sess, eval)\n                 },\n                 p => {\n                     span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n@@ -618,10 +632,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n             }\n         },\n         ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => {\n-            if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n-                gated_cfg.check_and_emit(sess, feats);\n-            }\n-            sess.config.contains(&(cfg.name(), cfg.value_str()))\n+            eval(cfg)\n         }\n     }\n }"}, {"sha": "cba5c812b07ce94b46dc8aa9b21fb8781b94680f", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -205,6 +205,18 @@ impl Span {\n         }\n     }\n \n+    /// Return the compiler desugaring that created this span, or None\n+    /// if this span is not from a desugaring.\n+    pub fn compiler_desugaring_kind(&self) -> Option<CompilerDesugaringKind> {\n+        match self.ctxt().outer().expn_info() {\n+            Some(info) => match info.callee.format {\n+                ExpnFormat::CompilerDesugaring(k) => Some(k),\n+                _ => None\n+            },\n+            None => None\n+        }\n+    }\n+\n     /// Check if a span is \"internal\" to a macro in which `unsafe`\n     /// can be used without triggering the `unsafe_code` lint\n     //  (that is, a macro marked with `#[allow_internal_unsafe]`)."}, {"sha": "a33120bbebd2321d47093e20daddb732ca31bea2", "filename": "src/test/compile-fail/E0232.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Ftest%2Fcompile-fail%2FE0232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Ftest%2Fcompile-fail%2FE0232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0232.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -12,7 +12,7 @@\n \n #[rustc_on_unimplemented]\n //~^ ERROR E0232\n-//~| NOTE attribute requires a value\n+//~| NOTE value required here\n //~| NOTE eg `#[rustc_on_unimplemented = \"foo\"]`\n trait Bar {}\n "}, {"sha": "54d3b3e087653f2ec63505526c71bd018c8c95fb", "filename": "src/test/ui/on-unimplemented/bad-annotation.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -37,5 +37,29 @@ trait BadAnnotation2<A,B>\n trait BadAnnotation3<A,B>\n {}\n \n+#[rustc_on_unimplemented(lorem=\"\")]\n+trait BadAnnotation4 {}\n+\n+#[rustc_on_unimplemented(lorem(ipsum(dolor)))]\n+trait BadAnnotation5 {}\n+\n+#[rustc_on_unimplemented(message=\"x\", message=\"y\")]\n+trait BadAnnotation6 {}\n+\n+#[rustc_on_unimplemented(message=\"x\", on(desugared, message=\"y\"))]\n+trait BadAnnotation7 {}\n+\n+#[rustc_on_unimplemented(on(), message=\"y\")]\n+trait BadAnnotation8 {}\n+\n+#[rustc_on_unimplemented(on=\"x\", message=\"y\")]\n+trait BadAnnotation9 {}\n+\n+#[rustc_on_unimplemented(on(x=\"y\"), message=\"y\")]\n+trait BadAnnotation10 {}\n+\n+#[rustc_on_unimplemented(on(desugared, on(desugared, message=\"x\")), message=\"y\")]\n+trait BadAnnotation11 {}\n+\n pub fn main() {\n }"}, {"sha": "73834f4422d388e4be10d190944cb06a35f639bf", "filename": "src/test/ui/on-unimplemented/bad-annotation.stderr", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.stderr?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -1,8 +1,8 @@\n-error[E0232]: this attribute must have a value\n+error[E0232]: `#[rustc_on_unimplemented]` requires a value\n   --> $DIR/bad-annotation.rs:26:1\n    |\n 26 | #[rustc_on_unimplemented] //~ ERROR this attribute must have a value\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^ attribute requires a value\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ value required here\n    |\n    = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n \n@@ -18,5 +18,59 @@ error[E0231]: only named substitution parameters are allowed\n 35 | #[rustc_on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{}>`\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:40:26\n+   |\n+40 | #[rustc_on_unimplemented(lorem=\"\")]\n+   |                          ^^^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:43:26\n+   |\n+43 | #[rustc_on_unimplemented(lorem(ipsum(dolor)))]\n+   |                          ^^^^^^^^^^^^^^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:46:39\n+   |\n+46 | #[rustc_on_unimplemented(message=\"x\", message=\"y\")]\n+   |                                       ^^^^^^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:49:39\n+   |\n+49 | #[rustc_on_unimplemented(message=\"x\", on(desugared, message=\"y\"))]\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error[E0232]: empty `on`-clause in `#[rustc_on_unimplemented]`\n+  --> $DIR/bad-annotation.rs:52:26\n+   |\n+52 | #[rustc_on_unimplemented(on(), message=\"y\")]\n+   |                          ^^^^ empty on-clause here\n+\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:55:26\n+   |\n+55 | #[rustc_on_unimplemented(on=\"x\", message=\"y\")]\n+   |                          ^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error[E0232]: this attribute must have a valid value\n+  --> $DIR/bad-annotation.rs:61:40\n+   |\n+61 | #[rustc_on_unimplemented(on(desugared, on(desugared, message=\"x\")), message=\"y\")]\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected value here\n+   |\n+   = note: eg `#[rustc_on_unimplemented = \"foo\"]`\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "eadd12924df6603a6e12334fd2f08179922b9c94", "filename": "src/test/ui/suggestions/try-operator-on-main.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Ftest%2Fui%2Fsuggestions%2Ftry-operator-on-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Ftest%2Fui%2Fsuggestions%2Ftry-operator-on-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftry-operator-on-main.rs?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -8,6 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(try_trait)]\n+\n+use std::ops::Try;\n+\n fn main() {\n+    // error for a `Try` type on a non-`Try` fn\n     std::fs::File::open(\"foo\")?;\n+\n+    // a non-`Try` type on a non-`Try` fn\n+    ()?;\n+\n+    // an unrelated use of `Try`\n+    try_trait_generic::<()>();\n+}\n+\n+\n+\n+fn try_trait_generic<T: Try>() -> T {\n+    // and a non-`Try` object on a `Try` fn.\n+    ()?;\n+\n+    loop {}\n }"}, {"sha": "e83bf2abc1504fd1bfd8dbe1891a45af7f8b9277", "filename": "src/test/ui/suggestions/try-operator-on-main.stderr", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Ftest%2Fui%2Fsuggestions%2Ftry-operator-on-main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8642daf93f725685309fc12f9d0908fec54b63a/src%2Ftest%2Fui%2Fsuggestions%2Ftry-operator-on-main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftry-operator-on-main.stderr?ref=c8642daf93f725685309fc12f9d0908fec54b63a", "patch": "@@ -1,14 +1,46 @@\n-error[E0277]: the trait bound `(): std::ops::Try` is not satisfied\n-  --> $DIR/try-operator-on-main.rs:12:5\n+error[E0277]: the `?` operator can only be used in a function that returns `Result` (or another type that implements `std::ops::Try`)\n+  --> $DIR/try-operator-on-main.rs:17:5\n    |\n-12 |     std::fs::File::open(\"foo\")?;\n+17 |     std::fs::File::open(\"foo\")?;\n    |     ---------------------------\n    |     |\n-   |     the `?` operator can only be used in a function that returns `Result` (or another type that implements `std::ops::Try`)\n+   |     cannot use the `?` operator in a function that returns `()`\n    |     in this macro invocation\n    |\n    = help: the trait `std::ops::Try` is not implemented for `()`\n    = note: required by `std::ops::Try::from_error`\n \n-error: aborting due to previous error\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/try-operator-on-main.rs:20:5\n+   |\n+20 |     ()?;\n+   |     ---\n+   |     |\n+   |     the `?` operator cannot be applied to type `()`\n+   |     in this macro invocation\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `()`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error[E0277]: the trait bound `(): std::ops::Try` is not satisfied\n+  --> $DIR/try-operator-on-main.rs:23:5\n+   |\n+23 |     try_trait_generic::<()>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::ops::Try` is not implemented for `()`\n+   |\n+   = note: required by `try_trait_generic`\n+\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/try-operator-on-main.rs:30:5\n+   |\n+30 |     ()?;\n+   |     ---\n+   |     |\n+   |     the `?` operator cannot be applied to type `()`\n+   |     in this macro invocation\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `()`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error: aborting due to 4 previous errors\n "}]}