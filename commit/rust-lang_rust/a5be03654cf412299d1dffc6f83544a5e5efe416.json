{"sha": "a5be03654cf412299d1dffc6f83544a5e5efe416", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YmUwMzY1NGNmNDEyMjk5ZDFkZmZjNmY4MzU0NGE1ZTVlZmU0MTY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-07T09:22:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-07T09:22:50Z"}, "message": "invalid_value lint: fix help text", "tree": {"sha": "3af098dd757da8661815e95676546b9f9c93d7c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3af098dd757da8661815e95676546b9f9c93d7c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5be03654cf412299d1dffc6f83544a5e5efe416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5be03654cf412299d1dffc6f83544a5e5efe416", "html_url": "https://github.com/rust-lang/rust/commit/a5be03654cf412299d1dffc6f83544a5e5efe416", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5be03654cf412299d1dffc6f83544a5e5efe416/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a76fe76f756895b8cda1e10398f2268656a2e0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a76fe76f756895b8cda1e10398f2268656a2e0f", "html_url": "https://github.com/rust-lang/rust/commit/7a76fe76f756895b8cda1e10398f2268656a2e0f"}], "stats": {"total": 73, "additions": 37, "deletions": 36}, "files": [{"sha": "c6fd1256a8e6491a4dd8733b760de52430602367", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5be03654cf412299d1dffc6f83544a5e5efe416/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5be03654cf412299d1dffc6f83544a5e5efe416/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a5be03654cf412299d1dffc6f83544a5e5efe416", "patch": "@@ -2052,7 +2052,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                 );\n                 err.span_label(expr.span,\n                     \"this code causes undefined behavior when executed\");\n-                err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n+                err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead, \\\n+                    and only call `assume_init` after initialization is done\");\n                 if let Some(span) = span {\n                     err.span_note(span, &msg);\n                 } else {"}, {"sha": "bdb5959953f508ac312686a4da0c27b9e6f96338", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a5be03654cf412299d1dffc6f83544a5e5efe416/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5be03654cf412299d1dffc6f83544a5e5efe416/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=a5be03654cf412299d1dffc6f83544a5e5efe416", "patch": "@@ -5,7 +5,7 @@ LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: lint level defined here\n   --> $DIR/uninitialized-zeroed.rs:7:9\n@@ -21,7 +21,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: References must be non-null\n \n@@ -32,7 +32,7 @@ LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n    |                                      |\n    |                                      this code causes undefined behavior when executed\n-   |                                      help: use `MaybeUninit<T>` instead\n+   |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:18:18\n@@ -47,7 +47,7 @@ LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n    |                                      |\n    |                                      this code causes undefined behavior when executed\n-   |                                      help: use `MaybeUninit<T>` instead\n+   |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:18:18\n@@ -62,7 +62,7 @@ LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n    |                       |\n    |                       this code causes undefined behavior when executed\n-   |                       help: use `MaybeUninit<T>` instead\n+   |                       help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The never type (`!`) has no valid value\n \n@@ -73,7 +73,7 @@ LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n    |                       |\n    |                       this code causes undefined behavior when executed\n-   |                       help: use `MaybeUninit<T>` instead\n+   |                       help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The never type (`!`) has no valid value\n \n@@ -84,7 +84,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n    |                              |\n    |                              this code causes undefined behavior when executed\n-   |                              help: use `MaybeUninit<T>` instead\n+   |                              help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The never type (`!`) has no valid value\n \n@@ -95,7 +95,7 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n    |                              |\n    |                              this code causes undefined behavior when executed\n-   |                              help: use `MaybeUninit<T>` instead\n+   |                              help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The never type (`!`) has no valid value\n \n@@ -106,7 +106,7 @@ LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: 0-variant enums have no valid value\n \n@@ -117,7 +117,7 @@ LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: 0-variant enums have no valid value\n \n@@ -128,7 +128,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: References must be non-null\n \n@@ -139,7 +139,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: References must be non-null\n \n@@ -150,7 +150,7 @@ LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n    |                         |\n    |                         this code causes undefined behavior when executed\n-   |                         help: use `MaybeUninit<T>` instead\n+   |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:15:12\n@@ -165,7 +165,7 @@ LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n    |                         |\n    |                         this code causes undefined behavior when executed\n-   |                         help: use `MaybeUninit<T>` instead\n+   |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:15:12\n@@ -180,7 +180,7 @@ LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: Function pointers must be non-null\n \n@@ -191,7 +191,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: Function pointers must be non-null\n \n@@ -202,7 +202,7 @@ LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: Function pointers must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:18:18\n@@ -217,7 +217,7 @@ LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: Function pointers must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:18:18\n@@ -232,7 +232,7 @@ LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n-   |                                    help: use `MaybeUninit<T>` instead\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: Function pointers must be non-null (in this enum field)\n   --> $DIR/uninitialized-zeroed.rs:19:28\n@@ -247,7 +247,7 @@ LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n-   |                                    help: use `MaybeUninit<T>` instead\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: Function pointers must be non-null (in this enum field)\n   --> $DIR/uninitialized-zeroed.rs:19:28\n@@ -262,7 +262,7 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n    |                                          |\n    |                                          this code causes undefined behavior when executed\n-   |                                          help: use `MaybeUninit<T>` instead\n+   |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:16:16\n@@ -277,7 +277,7 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n    |                                          |\n    |                                          this code causes undefined behavior when executed\n-   |                                          help: use `MaybeUninit<T>` instead\n+   |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:16:16\n@@ -292,7 +292,7 @@ LL |         let _val: NonNull<i32> = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: std::ptr::NonNull<i32> must be non-null\n \n@@ -303,7 +303,7 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: std::ptr::NonNull<i32> must be non-null\n \n@@ -314,7 +314,7 @@ LL |         let _val: *const dyn Send = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n    |                                     |\n    |                                     this code causes undefined behavior when executed\n-   |                                     help: use `MaybeUninit<T>` instead\n+   |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The vtable of a wide raw pointer must be non-null\n \n@@ -325,7 +325,7 @@ LL |         let _val: *const dyn Send = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n    |                                     |\n    |                                     this code causes undefined behavior when executed\n-   |                                     help: use `MaybeUninit<T>` instead\n+   |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The vtable of a wide raw pointer must be non-null\n \n@@ -336,7 +336,7 @@ LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: Booleans must be `true` or `false`\n \n@@ -347,7 +347,7 @@ LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: Characters must be a valid unicode codepoint (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:18:18\n@@ -362,7 +362,7 @@ LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |                            |\n    |                            this code causes undefined behavior when executed\n-   |                            help: use `MaybeUninit<T>` instead\n+   |                            help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: NonBig must be initialized inside its custom valid range\n \n@@ -373,7 +373,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: References must be non-null\n \n@@ -384,7 +384,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n-   |                                    help: use `MaybeUninit<T>` instead\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: References must be non-null\n \n@@ -395,7 +395,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: std::num::NonZeroU32 must be non-null\n \n@@ -406,7 +406,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: std::ptr::NonNull<i32> must be non-null\n \n@@ -417,7 +417,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: std::ptr::NonNull<i32> must be non-null\n \n@@ -428,7 +428,7 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: Booleans must be `true` or `false`\n "}]}