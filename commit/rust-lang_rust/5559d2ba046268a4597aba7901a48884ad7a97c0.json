{"sha": "5559d2ba046268a4597aba7901a48884ad7a97c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NTlkMmJhMDQ2MjY4YTQ1OTdhYmE3OTAxYTQ4ODg0YWQ3YTk3YzA=", "commit": {"author": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2015-07-12T00:48:42Z"}, "committer": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2015-07-12T02:43:45Z"}, "message": "Add explanation for E0210 and revise E0117.", "tree": {"sha": "05fab64c4a6b7cab26740ea3660c689eff265975", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05fab64c4a6b7cab26740ea3660c689eff265975"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5559d2ba046268a4597aba7901a48884ad7a97c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5559d2ba046268a4597aba7901a48884ad7a97c0", "html_url": "https://github.com/rust-lang/rust/commit/5559d2ba046268a4597aba7901a48884ad7a97c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5559d2ba046268a4597aba7901a48884ad7a97c0/comments", "author": null, "committer": null, "parents": [{"sha": "1b28ffa5216c845d1cef6b0cb3e5ac7db12025d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b28ffa5216c845d1cef6b0cb3e5ac7db12025d0", "html_url": "https://github.com/rust-lang/rust/commit/1b28ffa5216c845d1cef6b0cb3e5ac7db12025d0"}], "stats": {"total": 106, "additions": 92, "deletions": 14}, "files": [{"sha": "57a637da9502d68c8c71ace84b45d60b2be1f619", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 92, "deletions": 14, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5559d2ba046268a4597aba7901a48884ad7a97c0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5559d2ba046268a4597aba7901a48884ad7a97c0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5559d2ba046268a4597aba7901a48884ad7a97c0", "patch": "@@ -1245,16 +1245,22 @@ impl Bytes { ... } // error, same as above\n \"##,\n \n E0117: r##\"\n-You got this error because because you tried to implement a foreign\n-trait for a foreign type (with maybe a foreign type parameter). Erroneous\n-code example:\n+This error indicates a violation of one of Rust's orphan rules for trait\n+implementations. The rule prohibits any implementation of a foreign trait (a\n+trait defined in another crate) where\n+\n+ - the type that is implementing the trait is foreign\n+ - all of the parameters being passed to the trait (if there are any) are also\n+   foreign.\n+\n+Here's one example of this error:\n \n ```\n impl Drop for u32 {}\n ```\n \n-The type, trait or the type parameter (or all of them) has to be defined\n-in your crate. Example:\n+To avoid this error, ensure that at least one local type is referenced by\n+the `impl`:\n \n ```\n pub struct Foo; // you define your type in your crate\n@@ -1263,21 +1269,29 @@ impl Drop for Foo { // and you can implement the trait on it!\n     // code of trait implementation here\n }\n \n-trait Bar { // or define your trait in your crate\n-    fn get(&self) -> usize;\n-}\n-\n-impl Bar for u32 { // and then you implement it on a foreign type\n-    fn get(&self) -> usize { 0 }\n-}\n-\n impl From<Foo> for i32 { // or you use a type from your crate as\n                          // a type parameter\n     fn from(i: Foo) -> i32 {\n         0\n     }\n }\n ```\n+\n+Alternatively, define a trait locally and implement that instead:\n+\n+```\n+trait Bar {\n+    fn get(&self) -> usize;\n+}\n+\n+impl Bar for u32 {\n+    fn get(&self) -> usize { 0 }\n+}\n+```\n+\n+For information on the design of the orphan rules, see [RFC 1023].\n+\n+[RFC 1023]: https://github.com/rust-lang/rfcs/pull/1023\n \"##,\n \n E0119: r##\"\n@@ -1833,6 +1847,71 @@ impl MyTrait for Foo {\n ```\n \"##,\n \n+E0210: r##\"\n+This error indicates a violation of one of Rust's orphan rules for trait\n+implementations. The rule concerns the use of type parameters in an\n+implementation of a foreign trait (a trait defined in another crate), and\n+states that type parameters must be \"covered\" by a local type. To understand\n+what this means, it is perhaps easiest to consider a few examples.\n+\n+If `ForeignTrait` is a trait defined in some external crate `foo`, then the\n+following trait `impl` is an error:\n+\n+```\n+extern crate foo;\n+use foo::ForeignTrait;\n+\n+impl<T> ForeignTrait for T { ... } // error\n+```\n+\n+To work around this, it can be covered with a local type, `MyType`:\n+\n+```\n+struct MyType<T>(T);\n+impl<T> ForeignTrait for MyType<T> { ... } // Ok\n+```\n+\n+For another example of an error, suppose there's another trait defined in `foo`\n+named `ForeignTrait2` that takes two type parameters. Then this `impl` results\n+in the same rule violation:\n+\n+```\n+struct MyType2;\n+impl<T> ForeignTrait2<T, MyType<T>> for MyType2 { ... } // error\n+```\n+\n+The reason for this is that there are two appearances of type parameter `T` in\n+the `impl` header, both as parameters for `ForeignTrait2`. The first appearance\n+is uncovered, and so runs afoul of the orphan rule.\n+\n+Consider one more example:\n+\n+```\n+impl<T> ForeignTrait2<MyType<T>, T> for MyType2 { ... } // Ok\n+```\n+\n+This only differs from the previous `impl` in that the parameters `T` and\n+`MyType<T>` for `ForeignTrait2` have been swapped. This example does *not*\n+violate the orphan rule; it is permitted.\n+\n+To see why that last example was allowed, you need to understand the general\n+rule. Unfortunately this rule is a bit tricky to state. Consider an `impl`:\n+\n+```\n+impl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n+```\n+\n+where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\n+are types. One of the types `T0, ..., Tn` must be a local type (this is another\n+orphan rule, see the explanation for E0117). Let `i` be the smallest integer\n+such that `Ti` is a local type. Then no type parameter can appear in any of the\n+`Tj` for `j < i`.\n+\n+For information on the design of the orphan rules, see [RFC 1023].\n+\n+[RFC 1023]: https://github.com/rust-lang/rfcs/pull/1023\n+\"##,\n+\n E0211: r##\"\n You used an intrinsic function which doesn't correspond to its\n definition. Erroneous code example:\n@@ -2148,7 +2227,6 @@ register_diagnostics! {\n            // and only one is supported\n     E0208,\n     E0209, // builtin traits can only be implemented on structs or enums\n-    E0210, // type parameter is not constrained by any local type\n     E0212, // cannot extract an associated type from a higher-ranked trait bound\n     E0213, // associated types are not accepted in this context\n     E0214, // parenthesized parameters may only be used with a trait"}]}