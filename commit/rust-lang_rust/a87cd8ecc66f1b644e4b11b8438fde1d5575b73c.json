{"sha": "a87cd8ecc66f1b644e4b11b8438fde1d5575b73c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4N2NkOGVjYzY2ZjFiNjQ0ZTRiMTFiODQzOGZkZTFkNTU3NWI3M2M=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-03T09:16:08Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-03T09:20:01Z"}, "message": "Rename WorldState -> GlobalState", "tree": {"sha": "82df1e44ba8eaf4c42b9a76b1c5c700c328005b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82df1e44ba8eaf4c42b9a76b1c5c700c328005b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c", "html_url": "https://github.com/rust-lang/rust/commit/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5100f7707356046228eb4e0cde1f9db0d674bdd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5100f7707356046228eb4e0cde1f9db0d674bdd9", "html_url": "https://github.com/rust-lang/rust/commit/5100f7707356046228eb4e0cde1f9db0d674bdd9"}], "stats": {"total": 564, "additions": 291, "deletions": 273}, "files": [{"sha": "44f856f6b457d2de9af1a1f85fd376eb32383538", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=a87cd8ecc66f1b644e4b11b8438fde1d5575b73c", "patch": "@@ -4,7 +4,7 @@ use ra_cfg::CfgExpr;\n use ra_ide::{FileId, RunnableKind, TestId};\n use ra_project_model::{self, ProjectWorkspace, TargetKind};\n \n-use crate::{world::WorldSnapshot, Result};\n+use crate::{global_state::GlobalStateSnapshot, Result};\n \n /// Abstract representation of Cargo target.\n ///\n@@ -89,7 +89,7 @@ impl CargoTargetSpec {\n     }\n \n     pub(crate) fn for_file(\n-        world: &WorldSnapshot,\n+        world: &GlobalStateSnapshot,\n         file_id: FileId,\n     ) -> Result<Option<CargoTargetSpec>> {\n         let &crate_id = match world.analysis().crate_for(file_id)?.first() {"}, {"sha": "206673829c489b5fc9ac2da597c934d7e81cb0db", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=a87cd8ecc66f1b644e4b11b8438fde1d5575b73c", "patch": "@@ -3,7 +3,7 @@ use ra_db::{FileId, FilePosition, FileRange};\n use ra_ide::{LineCol, LineIndex};\n use ra_syntax::{TextRange, TextSize};\n \n-use crate::{world::WorldSnapshot, Result};\n+use crate::{global_state::GlobalStateSnapshot, Result};\n \n pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> TextSize {\n     let line_col = LineCol { line: position.line as u32, col_utf16: position.character as u32 };\n@@ -16,12 +16,12 @@ pub(crate) fn text_range(line_index: &LineIndex, range: lsp_types::Range) -> Tex\n     TextRange::new(start, end)\n }\n \n-pub(crate) fn file_id(world: &WorldSnapshot, url: &lsp_types::Url) -> Result<FileId> {\n+pub(crate) fn file_id(world: &GlobalStateSnapshot, url: &lsp_types::Url) -> Result<FileId> {\n     world.uri_to_file_id(url)\n }\n \n pub(crate) fn file_position(\n-    world: &WorldSnapshot,\n+    world: &GlobalStateSnapshot,\n     tdpp: lsp_types::TextDocumentPositionParams,\n ) -> Result<FilePosition> {\n     let file_id = file_id(world, &tdpp.text_document.uri)?;\n@@ -31,7 +31,7 @@ pub(crate) fn file_position(\n }\n \n pub(crate) fn file_range(\n-    world: &WorldSnapshot,\n+    world: &GlobalStateSnapshot,\n     text_document_identifier: lsp_types::TextDocumentIdentifier,\n     range: lsp_types::Range,\n ) -> Result<FileRange> {"}, {"sha": "0bebb5bf615a74912bed884b49bb8446ec4ac3a6", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=a87cd8ecc66f1b644e4b11b8438fde1d5575b73c", "patch": "@@ -50,13 +50,13 @@ fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) ->\n         })\n }\n \n-/// `WorldState` is the primary mutable state of the language server\n+/// `GlobalState` is the primary mutable state of the language server\n ///\n /// The most interesting components are `vfs`, which stores a consistent\n /// snapshot of the file systems, and `analysis_host`, which stores our\n /// incremental salsa database.\n #[derive(Debug)]\n-pub struct WorldState {\n+pub struct GlobalState {\n     pub config: Config,\n     pub local_roots: Vec<PathBuf>,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n@@ -70,7 +70,7 @@ pub struct WorldState {\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n-pub struct WorldSnapshot {\n+pub struct GlobalStateSnapshot {\n     pub config: Config,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis: Analysis,\n@@ -79,14 +79,14 @@ pub struct WorldSnapshot {\n     vfs: Arc<RwLock<Vfs>>,\n }\n \n-impl WorldState {\n+impl GlobalState {\n     pub fn new(\n         workspaces: Vec<ProjectWorkspace>,\n         lru_capacity: Option<usize>,\n         exclude_globs: &[Glob],\n         watch: Watch,\n         config: Config,\n-    ) -> WorldState {\n+    ) -> GlobalState {\n         let mut change = AnalysisChange::new();\n \n         let extern_dirs: FxHashSet<_> =\n@@ -180,7 +180,7 @@ impl WorldState {\n \n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n-        WorldState {\n+        GlobalState {\n             config,\n             local_roots,\n             workspaces: Arc::new(workspaces),\n@@ -255,8 +255,8 @@ impl WorldState {\n         self.analysis_host.apply_change(change);\n     }\n \n-    pub fn snapshot(&self) -> WorldSnapshot {\n-        WorldSnapshot {\n+    pub fn snapshot(&self) -> GlobalStateSnapshot {\n+        GlobalStateSnapshot {\n             config: self.config.clone(),\n             workspaces: Arc::clone(&self.workspaces),\n             analysis: self.analysis_host.analysis(),\n@@ -279,7 +279,7 @@ impl WorldState {\n     }\n }\n \n-impl WorldSnapshot {\n+impl GlobalStateSnapshot {\n     pub fn analysis(&self) -> &Analysis {\n         &self.analysis\n     }", "previous_filename": "crates/rust-analyzer/src/world.rs"}, {"sha": "609cb69d3bff6174a15502db7dfd1f19900bb034", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=a87cd8ecc66f1b644e4b11b8438fde1d5575b73c", "patch": "@@ -26,7 +26,7 @@ mod main_loop;\n mod markdown;\n pub mod lsp_ext;\n pub mod config;\n-mod world;\n+mod global_state;\n mod diagnostics;\n mod semantic_tokens;\n "}, {"sha": "35f2d7001e1cc11766750d3a16b9a2520ed2c10d", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=a87cd8ecc66f1b644e4b11b8438fde1d5575b73c", "patch": "@@ -38,12 +38,13 @@ use threadpool::ThreadPool;\n use crate::{\n     config::{Config, FilesWatcher},\n     diagnostics::{to_proto::url_from_path_with_drive_lowercasing, DiagnosticTask},\n-    from_proto, lsp_ext,\n+    from_proto,\n+    global_state::{GlobalState, GlobalStateSnapshot},\n+    lsp_ext,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n     },\n-    world::{WorldSnapshot, WorldState},\n     Result,\n };\n \n@@ -92,7 +93,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n     }\n \n     let mut loop_state = LoopState::default();\n-    let mut world_state = {\n+    let mut global_state = {\n         let workspaces = {\n             // FIXME: support dynamic workspace loading.\n             let project_roots: FxHashSet<_> = ws_roots\n@@ -163,7 +164,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n             connection.sender.send(request.into()).unwrap();\n         }\n \n-        WorldState::new(\n+        GlobalState::new(\n             workspaces,\n             config.lru_capacity,\n             &globs,\n@@ -172,7 +173,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n         )\n     };\n \n-    loop_state.roots_total = world_state.vfs.read().n_roots();\n+    loop_state.roots_total = global_state.vfs.read().n_roots();\n \n     let pool = ThreadPool::default();\n     let (task_sender, task_receiver) = unbounded::<Task>();\n@@ -190,12 +191,12 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n                     Err(RecvError) => return Err(\"client exited without shutdown\".into()),\n                 },\n                 recv(task_receiver) -> task => Event::Task(task.unwrap()),\n-                recv(world_state.task_receiver) -> task => match task {\n+                recv(global_state.task_receiver) -> task => match task {\n                     Ok(task) => Event::Vfs(task),\n                     Err(RecvError) => return Err(\"vfs died\".into()),\n                 },\n                 recv(libdata_receiver) -> data => Event::Lib(data.unwrap()),\n-                recv(world_state.flycheck.as_ref().map_or(&never(), |it| &it.task_recv)) -> task => match task {\n+                recv(global_state.flycheck.as_ref().map_or(&never(), |it| &it.task_recv)) -> task => match task {\n                     Ok(task) => Event::CheckWatcher(task),\n                     Err(RecvError) => return Err(\"check watcher died\".into()),\n                 }\n@@ -210,16 +211,16 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n                 &task_sender,\n                 &libdata_sender,\n                 &connection,\n-                &mut world_state,\n+                &mut global_state,\n                 &mut loop_state,\n                 event,\n             )?;\n         }\n     }\n-    world_state.analysis_host.request_cancellation();\n+    global_state.analysis_host.request_cancellation();\n     log::info!(\"waiting for tasks to finish...\");\n     task_receiver.into_iter().for_each(|task| {\n-        on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut world_state)\n+        on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut global_state)\n     });\n     libdata_receiver.into_iter().for_each(drop);\n     log::info!(\"...tasks have finished\");\n@@ -228,7 +229,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n     drop(pool);\n     log::info!(\"...threadpool has finished\");\n \n-    let vfs = Arc::try_unwrap(world_state.vfs).expect(\"all snapshots should be dead\");\n+    let vfs = Arc::try_unwrap(global_state.vfs).expect(\"all snapshots should be dead\");\n     drop(vfs);\n \n     Ok(())\n@@ -319,7 +320,7 @@ fn loop_turn(\n     task_sender: &Sender<Task>,\n     libdata_sender: &Sender<LibraryData>,\n     connection: &Connection,\n-    world_state: &mut WorldState,\n+    global_state: &mut GlobalState,\n     loop_state: &mut LoopState,\n     event: Event,\n ) -> Result<()> {\n@@ -335,22 +336,22 @@ fn loop_turn(\n \n     match event {\n         Event::Task(task) => {\n-            on_task(task, &connection.sender, &mut loop_state.pending_requests, world_state);\n-            world_state.maybe_collect_garbage();\n+            on_task(task, &connection.sender, &mut loop_state.pending_requests, global_state);\n+            global_state.maybe_collect_garbage();\n         }\n         Event::Vfs(task) => {\n-            world_state.vfs.write().handle_task(task);\n+            global_state.vfs.write().handle_task(task);\n         }\n         Event::Lib(lib) => {\n-            world_state.add_lib(lib);\n-            world_state.maybe_collect_garbage();\n+            global_state.add_lib(lib);\n+            global_state.maybe_collect_garbage();\n             loop_state.in_flight_libraries -= 1;\n             loop_state.roots_scanned += 1;\n         }\n-        Event::CheckWatcher(task) => on_check_task(task, world_state, task_sender)?,\n+        Event::CheckWatcher(task) => on_check_task(task, global_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n-                world_state,\n+                global_state,\n                 &mut loop_state.pending_requests,\n                 pool,\n                 task_sender,\n@@ -359,7 +360,7 @@ fn loop_turn(\n                 req,\n             )?,\n             Message::Notification(not) => {\n-                on_notification(&connection.sender, world_state, loop_state, not)?;\n+                on_notification(&connection.sender, global_state, loop_state, not)?;\n             }\n             Message::Response(resp) => {\n                 let removed = loop_state.pending_responses.remove(&resp.id);\n@@ -378,9 +379,9 @@ fn loop_turn(\n                         }\n                         (None, Some(configs)) => {\n                             if let Some(new_config) = configs.get(0) {\n-                                let mut config = world_state.config.clone();\n+                                let mut config = global_state.config.clone();\n                                 config.update(&new_config);\n-                                world_state.update_configuration(config);\n+                                global_state.update_configuration(config);\n                             }\n                         }\n                         (None, None) => {\n@@ -393,7 +394,7 @@ fn loop_turn(\n     };\n \n     let mut state_changed = false;\n-    if let Some(changes) = world_state.process_changes(&mut loop_state.roots_scanned) {\n+    if let Some(changes) = global_state.process_changes(&mut loop_state.roots_scanned) {\n         state_changed = true;\n         loop_state.pending_libraries.extend(changes);\n     }\n@@ -415,7 +416,7 @@ fn loop_turn(\n     }\n \n     let show_progress =\n-        !loop_state.workspace_loaded && world_state.config.client_caps.work_done_progress;\n+        !loop_state.workspace_loaded && global_state.config.client_caps.work_done_progress;\n \n     if !loop_state.workspace_loaded\n         && loop_state.roots_scanned == loop_state.roots_total\n@@ -424,7 +425,7 @@ fn loop_turn(\n     {\n         state_changed = true;\n         loop_state.workspace_loaded = true;\n-        if let Some(flycheck) = &world_state.flycheck {\n+        if let Some(flycheck) = &global_state.flycheck {\n             flycheck.update();\n         }\n     }\n@@ -436,13 +437,13 @@ fn loop_turn(\n     if state_changed && loop_state.workspace_loaded {\n         update_file_notifications_on_threadpool(\n             pool,\n-            world_state.snapshot(),\n+            global_state.snapshot(),\n             task_sender.clone(),\n             loop_state.subscriptions.subscriptions(),\n         );\n         pool.execute({\n             let subs = loop_state.subscriptions.subscriptions();\n-            let snap = world_state.snapshot();\n+            let snap = global_state.snapshot();\n             move || snap.analysis().prime_caches(subs).unwrap_or_else(|_: Canceled| ())\n         });\n     }\n@@ -466,7 +467,7 @@ fn on_task(\n     task: Task,\n     msg_sender: &Sender<Message>,\n     pending_requests: &mut PendingRequests,\n-    state: &mut WorldState,\n+    state: &mut GlobalState,\n ) {\n     match task {\n         Task::Respond(response) => {\n@@ -484,7 +485,7 @@ fn on_task(\n }\n \n fn on_request(\n-    world: &mut WorldState,\n+    global_state: &mut GlobalState,\n     pending_requests: &mut PendingRequests,\n     pool: &ThreadPool,\n     task_sender: &Sender<Task>,\n@@ -495,7 +496,7 @@ fn on_request(\n     let mut pool_dispatcher = PoolDispatcher {\n         req: Some(req),\n         pool,\n-        world,\n+        global_state,\n         task_sender,\n         msg_sender,\n         pending_requests,\n@@ -551,7 +552,7 @@ fn on_request(\n \n fn on_notification(\n     msg_sender: &Sender<Message>,\n-    state: &mut WorldState,\n+    state: &mut GlobalState,\n     loop_state: &mut LoopState,\n     not: Notification,\n ) -> Result<()> {\n@@ -725,7 +726,7 @@ fn apply_document_changes(\n \n fn on_check_task(\n     task: CheckTask,\n-    world_state: &mut WorldState,\n+    global_state: &mut GlobalState,\n     task_sender: &Sender<Task>,\n ) -> Result<()> {\n     match task {\n@@ -744,7 +745,7 @@ fn on_check_task(\n                     .uri\n                     .to_file_path()\n                     .map_err(|()| format!(\"invalid uri: {}\", diag.location.uri))?;\n-                let file_id = match world_state.vfs.read().path2file(&path) {\n+                let file_id = match global_state.vfs.read().path2file(&path) {\n                     Some(file) => FileId(file.0),\n                     None => {\n                         log::error!(\n@@ -764,7 +765,7 @@ fn on_check_task(\n         }\n \n         CheckTask::Status(status) => {\n-            if world_state.config.client_caps.work_done_progress {\n+            if global_state.config.client_caps.work_done_progress {\n                 let progress = match status {\n                     Status::Being => {\n                         lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n@@ -803,7 +804,7 @@ fn on_check_task(\n     Ok(())\n }\n \n-fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state: &mut WorldState) {\n+fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state: &mut GlobalState) {\n     let subscriptions = state.diagnostics.handle_task(task);\n \n     for file_id in subscriptions {\n@@ -878,7 +879,7 @@ fn send_startup_progress(sender: &Sender<Message>, loop_state: &mut LoopState) {\n struct PoolDispatcher<'a> {\n     req: Option<Request>,\n     pool: &'a ThreadPool,\n-    world: &'a mut WorldState,\n+    global_state: &'a mut GlobalState,\n     pending_requests: &'a mut PendingRequests,\n     msg_sender: &'a Sender<Message>,\n     task_sender: &'a Sender<Task>,\n@@ -889,7 +890,7 @@ impl<'a> PoolDispatcher<'a> {\n     /// Dispatches the request onto the current thread\n     fn on_sync<R>(\n         &mut self,\n-        f: fn(&mut WorldState, R::Params) -> Result<R::Result>,\n+        f: fn(&mut GlobalState, R::Params) -> Result<R::Result>,\n     ) -> Result<&mut Self>\n     where\n         R: lsp_types::request::Request + 'static,\n@@ -902,18 +903,21 @@ impl<'a> PoolDispatcher<'a> {\n                 return Ok(self);\n             }\n         };\n-        let world = panic::AssertUnwindSafe(&mut *self.world);\n+        let world = panic::AssertUnwindSafe(&mut *self.global_state);\n         let task = panic::catch_unwind(move || {\n             let result = f(world.0, params);\n             result_to_task::<R>(id, result)\n         })\n         .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n-        on_task(task, self.msg_sender, self.pending_requests, self.world);\n+        on_task(task, self.msg_sender, self.pending_requests, self.global_state);\n         Ok(self)\n     }\n \n     /// Dispatches the request onto thread pool\n-    fn on<R>(&mut self, f: fn(WorldSnapshot, R::Params) -> Result<R::Result>) -> Result<&mut Self>\n+    fn on<R>(\n+        &mut self,\n+        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n+    ) -> Result<&mut Self>\n     where\n         R: lsp_types::request::Request + 'static,\n         R::Params: DeserializeOwned + Send + 'static,\n@@ -927,7 +931,7 @@ impl<'a> PoolDispatcher<'a> {\n         };\n \n         self.pool.execute({\n-            let world = self.world.snapshot();\n+            let world = self.global_state.snapshot();\n             let sender = self.task_sender.clone();\n             move || {\n                 let result = f(world, params);\n@@ -1011,7 +1015,7 @@ where\n \n fn update_file_notifications_on_threadpool(\n     pool: &ThreadPool,\n-    world: WorldSnapshot,\n+    world: GlobalStateSnapshot,\n     task_sender: Sender<Task>,\n     subscriptions: Vec<FileId>,\n ) {"}, {"sha": "1bb8e44735f5f6f8cda8eb50b31eed4048068d35", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 182, "deletions": 175, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=a87cd8ecc66f1b644e4b11b8438fde1d5575b73c", "patch": "@@ -32,17 +32,16 @@ use crate::{\n     config::RustfmtConfig,\n     diagnostics::DiagnosticTask,\n     from_json, from_proto,\n+    global_state::GlobalStateSnapshot,\n     lsp_ext::{self, InlayHint, InlayHintsParams},\n-    to_proto,\n-    world::WorldSnapshot,\n-    LspError, Result,\n+    to_proto, LspError, Result,\n };\n \n-pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n+pub fn handle_analyzer_status(snap: GlobalStateSnapshot, _: ()) -> Result<String> {\n     let _p = profile(\"handle_analyzer_status\");\n-    let mut buf = world.status();\n+    let mut buf = snap.status();\n     format_to!(buf, \"\\n\\nrequests:\\n\");\n-    let requests = world.latest_requests.read();\n+    let requests = snap.latest_requests.read();\n     for (is_last, r) in requests.iter() {\n         let mark = if is_last { \"*\" } else { \" \" };\n         format_to!(buf, \"{}{:4} {:<36}{}ms\\n\", mark, r.id, r.method, r.duration.as_millis());\n@@ -51,37 +50,37 @@ pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n }\n \n pub fn handle_syntax_tree(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::SyntaxTreeParams,\n ) -> Result<String> {\n     let _p = profile(\"handle_syntax_tree\");\n-    let id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(id)?;\n+    let id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(id)?;\n     let text_range = params.range.map(|r| from_proto::text_range(&line_index, r));\n-    let res = world.analysis().syntax_tree(id, text_range)?;\n+    let res = snap.analysis().syntax_tree(id, text_range)?;\n     Ok(res)\n }\n \n pub fn handle_expand_macro(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::ExpandMacroParams,\n ) -> Result<Option<lsp_ext::ExpandedMacro>> {\n     let _p = profile(\"handle_expand_macro\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let offset = from_proto::offset(&line_index, params.position);\n \n-    let res = world.analysis().expand_macro(FilePosition { file_id, offset })?;\n+    let res = snap.analysis().expand_macro(FilePosition { file_id, offset })?;\n     Ok(res.map(|it| lsp_ext::ExpandedMacro { name: it.name, expansion: it.expansion }))\n }\n \n pub fn handle_selection_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::SelectionRangeParams,\n ) -> Result<Option<Vec<lsp_types::SelectionRange>>> {\n     let _p = profile(\"handle_selection_range\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let res: Result<Vec<lsp_types::SelectionRange>> = params\n         .positions\n         .into_iter()\n@@ -93,7 +92,7 @@ pub fn handle_selection_range(\n                 loop {\n                     ranges.push(range);\n                     let frange = FileRange { file_id, range };\n-                    let next = world.analysis().extend_selection(frange)?;\n+                    let next = snap.analysis().extend_selection(frange)?;\n                     if next == range {\n                         break;\n                     } else {\n@@ -119,18 +118,18 @@ pub fn handle_selection_range(\n }\n \n pub fn handle_matching_brace(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::MatchingBraceParams,\n ) -> Result<Vec<Position>> {\n     let _p = profile(\"handle_matching_brace\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let res = params\n         .positions\n         .into_iter()\n         .map(|position| {\n             let offset = from_proto::offset(&line_index, position);\n-            let offset = match world.analysis().matching_brace(FilePosition { file_id, offset }) {\n+            let offset = match snap.analysis().matching_brace(FilePosition { file_id, offset }) {\n                 Ok(Some(matching_brace_offset)) => matching_brace_offset,\n                 Err(_) | Ok(None) => offset,\n             };\n@@ -141,17 +140,17 @@ pub fn handle_matching_brace(\n }\n \n pub fn handle_join_lines(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::JoinLinesParams,\n ) -> Result<Vec<lsp_types::TextEdit>> {\n     let _p = profile(\"handle_join_lines\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let line_endings = world.file_line_endings(file_id);\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_endings = snap.file_line_endings(file_id);\n     let mut res = TextEdit::default();\n     for range in params.ranges {\n         let range = from_proto::text_range(&line_index, range);\n-        let edit = world.analysis().join_lines(FileRange { file_id, range })?;\n+        let edit = snap.analysis().join_lines(FileRange { file_id, range })?;\n         match res.union(edit) {\n             Ok(()) => (),\n             Err(_edit) => {\n@@ -164,37 +163,37 @@ pub fn handle_join_lines(\n }\n \n pub fn handle_on_enter(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {\n     let _p = profile(\"handle_on_enter\");\n-    let position = from_proto::file_position(&world, params)?;\n-    let edit = match world.analysis().on_enter(position)? {\n+    let position = from_proto::file_position(&snap, params)?;\n+    let edit = match snap.analysis().on_enter(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n-    let line_endings = world.file_line_endings(position.file_id);\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n     let edit = to_proto::snippet_text_edit_vec(&line_index, line_endings, true, edit);\n     Ok(Some(edit))\n }\n \n // Don't forget to add new trigger characters to `ServerCapabilities` in `caps.rs`.\n pub fn handle_on_type_formatting(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentOnTypeFormattingParams,\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile(\"handle_on_type_formatting\");\n-    let mut position = from_proto::file_position(&world, params.text_document_position)?;\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n-    let line_endings = world.file_line_endings(position.file_id);\n+    let mut position = from_proto::file_position(&snap, params.text_document_position)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n \n     // in `ra_ide`, the `on_type` invariant is that\n     // `text.char_at(position) == typed_char`.\n     position.offset -= TextSize::of('.');\n     let char_typed = params.ch.chars().next().unwrap_or('\\0');\n     assert!({\n-        let text = world.analysis().file_text(position.file_id)?;\n+        let text = snap.analysis().file_text(position.file_id)?;\n         text[usize::from(position.offset)..].starts_with(char_typed)\n     });\n \n@@ -206,7 +205,7 @@ pub fn handle_on_type_formatting(\n         return Ok(None);\n     }\n \n-    let edit = world.analysis().on_char_typed(position, char_typed)?;\n+    let edit = snap.analysis().on_char_typed(position, char_typed)?;\n     let mut edit = match edit {\n         Some(it) => it,\n         None => return Ok(None),\n@@ -220,16 +219,16 @@ pub fn handle_on_type_formatting(\n }\n \n pub fn handle_document_symbol(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentSymbolParams,\n ) -> Result<Option<lsp_types::DocumentSymbolResponse>> {\n     let _p = profile(\"handle_document_symbol\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n \n     let mut parents: Vec<(DocumentSymbol, Option<usize>)> = Vec::new();\n \n-    for symbol in world.analysis().file_structure(file_id)? {\n+    for symbol in snap.analysis().file_structure(file_id)? {\n         let doc_symbol = DocumentSymbol {\n             name: symbol.label,\n             detail: symbol.detail,\n@@ -255,10 +254,10 @@ pub fn handle_document_symbol(\n         }\n     }\n \n-    let res = if world.config.client_caps.hierarchical_symbols {\n+    let res = if snap.config.client_caps.hierarchical_symbols {\n         document_symbols.into()\n     } else {\n-        let url = to_proto::url(&world, file_id)?;\n+        let url = to_proto::url(&snap, file_id)?;\n         let mut symbol_information = Vec::<SymbolInformation>::new();\n         for symbol in document_symbols {\n             flatten_document_symbol(&symbol, None, &url, &mut symbol_information);\n@@ -288,7 +287,7 @@ pub fn handle_document_symbol(\n }\n \n pub fn handle_workspace_symbol(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::WorkspaceSymbolParams,\n ) -> Result<Option<Vec<SymbolInformation>>> {\n     let _p = profile(\"handle_workspace_symbol\");\n@@ -306,22 +305,22 @@ pub fn handle_workspace_symbol(\n         q.limit(128);\n         q\n     };\n-    let mut res = exec_query(&world, query)?;\n+    let mut res = exec_query(&snap, query)?;\n     if res.is_empty() && !all_symbols {\n         let mut query = Query::new(params.query);\n         query.limit(128);\n-        res = exec_query(&world, query)?;\n+        res = exec_query(&snap, query)?;\n     }\n \n     return Ok(Some(res));\n \n-    fn exec_query(world: &WorldSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n+    fn exec_query(snap: &GlobalStateSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n         let mut res = Vec::new();\n-        for nav in world.analysis().symbol_search(query)? {\n+        for nav in snap.analysis().symbol_search(query)? {\n             let info = SymbolInformation {\n                 name: nav.name().to_string(),\n                 kind: to_proto::symbol_kind(nav.kind()),\n-                location: to_proto::location(world, nav.file_range())?,\n+                location: to_proto::location(snap, nav.file_range())?,\n                 container_name: nav.container_name().map(|v| v.to_string()),\n                 deprecated: None,\n             };\n@@ -332,73 +331,73 @@ pub fn handle_workspace_symbol(\n }\n \n pub fn handle_goto_definition(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::GotoDefinitionParams,\n ) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_goto_definition\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_definition(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n     let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&world, Some(src), nav_info.info)?;\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_goto_implementation(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::request::GotoImplementationParams,\n ) -> Result<Option<lsp_types::request::GotoImplementationResponse>> {\n     let _p = profile(\"handle_goto_implementation\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_implementation(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_implementation(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n     let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&world, Some(src), nav_info.info)?;\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_goto_type_definition(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::request::GotoTypeDefinitionParams,\n ) -> Result<Option<lsp_types::request::GotoTypeDefinitionResponse>> {\n     let _p = profile(\"handle_goto_type_definition\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_type_definition(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_type_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n     let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&world, Some(src), nav_info.info)?;\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_parent_module(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_parent_module\");\n-    let position = from_proto::file_position(&world, params)?;\n-    let navs = world.analysis().parent_module(position)?;\n-    let res = to_proto::goto_definition_response(&world, None, navs)?;\n+    let position = from_proto::file_position(&snap, params)?;\n+    let navs = snap.analysis().parent_module(position)?;\n+    let res = to_proto::goto_definition_response(&snap, None, navs)?;\n     Ok(Some(res))\n }\n \n pub fn handle_runnables(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::RunnablesParams,\n ) -> Result<Vec<lsp_ext::Runnable>> {\n     let _p = profile(\"handle_runnables\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let offset = params.position.map(|it| from_proto::offset(&line_index, it));\n     let mut res = Vec::new();\n-    let workspace_root = world.workspace_root_for(file_id);\n-    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n-    for runnable in world.analysis().runnables(file_id)? {\n+    let workspace_root = snap.workspace_root_for(file_id);\n+    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n+    for runnable in snap.analysis().runnables(file_id)? {\n         if let Some(offset) = offset {\n             if !runnable.nav.full_range().contains_inclusive(offset) {\n                 continue;\n@@ -413,7 +412,7 @@ pub fn handle_runnables(\n                 }\n             }\n         }\n-        res.push(to_proto::runnable(&world, file_id, runnable)?);\n+        res.push(to_proto::runnable(&snap, file_id, runnable)?);\n     }\n \n     // Add `cargo check` and `cargo test` for the whole package\n@@ -453,16 +452,16 @@ pub fn handle_runnables(\n }\n \n pub fn handle_completion(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CompletionParams,\n ) -> Result<Option<lsp_types::CompletionResponse>> {\n     let _p = profile(\"handle_completion\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n     let completion_triggered_after_single_colon = {\n         let mut res = false;\n         if let Some(ctx) = params.context {\n             if ctx.trigger_character.unwrap_or_default() == \":\" {\n-                let source_file = world.analysis().parse(position.file_id)?;\n+                let source_file = snap.analysis().parse(position.file_id)?;\n                 let syntax = source_file.syntax();\n                 let text = syntax.text();\n                 if let Some(next_char) = text.char_at(position.offset) {\n@@ -480,12 +479,12 @@ pub fn handle_completion(\n         return Ok(None);\n     }\n \n-    let items = match world.analysis().completions(&world.config.completion, position)? {\n+    let items = match snap.analysis().completions(&snap.config.completion, position)? {\n         None => return Ok(None),\n         Some(items) => items,\n     };\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n-    let line_endings = world.file_line_endings(position.file_id);\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n     let items: Vec<CompletionItem> = items\n         .into_iter()\n         .map(|item| to_proto::completion_item(&line_index, line_endings, item))\n@@ -495,15 +494,15 @@ pub fn handle_completion(\n }\n \n pub fn handle_folding_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: FoldingRangeParams,\n ) -> Result<Option<Vec<FoldingRange>>> {\n     let _p = profile(\"handle_folding_range\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let folds = world.analysis().folding_ranges(file_id)?;\n-    let text = world.analysis().file_text(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let line_folding_only = world.config.client_caps.line_folding_only;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let folds = snap.analysis().folding_ranges(file_id)?;\n+    let text = snap.analysis().file_text(file_id)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_folding_only = snap.config.client_caps.line_folding_only;\n     let res = folds\n         .into_iter()\n         .map(|it| to_proto::folding_range(&*text, &line_index, line_folding_only, it))\n@@ -512,16 +511,16 @@ pub fn handle_folding_range(\n }\n \n pub fn handle_signature_help(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::SignatureHelpParams,\n ) -> Result<Option<lsp_types::SignatureHelp>> {\n     let _p = profile(\"handle_signature_help\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let call_info = match world.analysis().call_info(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let call_info = match snap.analysis().call_info(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let concise = !world.config.call_info_full;\n+    let concise = !snap.config.call_info_full;\n     let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n     if concise && call_info.signature.has_self_param {\n         active_parameter = active_parameter.map(|it| it.saturating_sub(1));\n@@ -535,14 +534,17 @@ pub fn handle_signature_help(\n     }))\n }\n \n-pub fn handle_hover(world: WorldSnapshot, params: lsp_types::HoverParams) -> Result<Option<Hover>> {\n+pub fn handle_hover(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::HoverParams,\n+) -> Result<Option<Hover>> {\n     let _p = profile(\"handle_hover\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let info = match world.analysis().hover(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let info = match snap.analysis().hover(position)? {\n         None => return Ok(None),\n         Some(info) => info,\n     };\n-    let line_index = world.analysis.file_line_index(position.file_id)?;\n+    let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, info.range);\n     let res = Hover {\n         contents: HoverContents::Markup(MarkupContent {\n@@ -555,26 +557,29 @@ pub fn handle_hover(world: WorldSnapshot, params: lsp_types::HoverParams) -> Res\n }\n \n pub fn handle_prepare_rename(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Option<PrepareRenameResponse>> {\n     let _p = profile(\"handle_prepare_rename\");\n-    let position = from_proto::file_position(&world, params)?;\n+    let position = from_proto::file_position(&snap, params)?;\n \n-    let optional_change = world.analysis().rename(position, \"dummy\")?;\n+    let optional_change = snap.analysis().rename(position, \"dummy\")?;\n     let range = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.range,\n     };\n \n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, range);\n     Ok(Some(PrepareRenameResponse::Range(range)))\n }\n \n-pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Option<WorkspaceEdit>> {\n+pub fn handle_rename(\n+    snap: GlobalStateSnapshot,\n+    params: RenameParams,\n+) -> Result<Option<WorkspaceEdit>> {\n     let _p = profile(\"handle_rename\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n \n     if params.new_name.is_empty() {\n         return Err(LspError::new(\n@@ -584,61 +589,61 @@ pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Optio\n         .into());\n     }\n \n-    let optional_change = world.analysis().rename(position, &*params.new_name)?;\n+    let optional_change = snap.analysis().rename(position, &*params.new_name)?;\n     let source_change = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.info,\n     };\n-    let workspace_edit = to_proto::workspace_edit(&world, source_change)?;\n+    let workspace_edit = to_proto::workspace_edit(&snap, source_change)?;\n     Ok(Some(workspace_edit))\n }\n \n pub fn handle_references(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::ReferenceParams,\n ) -> Result<Option<Vec<Location>>> {\n     let _p = profile(\"handle_references\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n \n-    let refs = match world.analysis().find_all_refs(position, None)? {\n+    let refs = match snap.analysis().find_all_refs(position, None)? {\n         None => return Ok(None),\n         Some(refs) => refs,\n     };\n \n     let locations = if params.context.include_declaration {\n         refs.into_iter()\n-            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n+            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n             .collect()\n     } else {\n         // Only iterate over the references if include_declaration was false\n         refs.references()\n             .iter()\n-            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n+            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n             .collect()\n     };\n \n     Ok(Some(locations))\n }\n \n pub fn handle_formatting(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: DocumentFormattingParams,\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile(\"handle_formatting\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let file = world.analysis().file_text(file_id)?;\n-    let crate_ids = world.analysis().crate_for(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let file = snap.analysis().file_text(file_id)?;\n+    let crate_ids = snap.analysis().crate_for(file_id)?;\n \n-    let file_line_index = world.analysis().file_line_index(file_id)?;\n+    let file_line_index = snap.analysis().file_line_index(file_id)?;\n     let end_position = to_proto::position(&file_line_index, TextSize::of(file.as_str()));\n \n-    let mut rustfmt = match &world.config.rustfmt {\n+    let mut rustfmt = match &snap.config.rustfmt {\n         RustfmtConfig::Rustfmt { extra_args } => {\n             let mut cmd = process::Command::new(\"rustfmt\");\n             cmd.args(extra_args);\n             if let Some(&crate_id) = crate_ids.first() {\n                 // Assume all crates are in the same edition\n-                let edition = world.analysis().crate_edition(crate_id)?;\n+                let edition = snap.analysis().crate_edition(crate_id)?;\n                 cmd.arg(\"--edition\");\n                 cmd.arg(edition.to_string());\n             }\n@@ -697,23 +702,23 @@ pub fn handle_formatting(\n }\n \n pub fn handle_code_action(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CodeActionParams,\n ) -> Result<Option<Vec<lsp_ext::CodeAction>>> {\n     let _p = profile(\"handle_code_action\");\n     // We intentionally don't support command-based actions, as those either\n     // requires custom client-code anyway, or requires server-initiated edits.\n     // Server initiated edits break causality, so we avoid those as well.\n-    if !world.config.client_caps.code_action_literals {\n+    if !snap.config.client_caps.code_action_literals {\n         return Ok(None);\n     }\n \n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.range);\n     let frange = FileRange { file_id, range };\n \n-    let diagnostics = world.analysis().diagnostics(file_id)?;\n+    let diagnostics = snap.analysis().diagnostics(file_id)?;\n     let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n \n     let fixes_from_diagnostics = diagnostics\n@@ -724,45 +729,45 @@ pub fn handle_code_action(\n \n     for fix in fixes_from_diagnostics {\n         let title = fix.label;\n-        let edit = to_proto::snippet_workspace_edit(&world, fix.source_change)?;\n+        let edit = to_proto::snippet_workspace_edit(&snap, fix.source_change)?;\n         let action =\n             lsp_ext::CodeAction { title, group: None, kind: None, edit: Some(edit), command: None };\n         res.push(action);\n     }\n \n-    for fix in world.check_fixes.get(&file_id).into_iter().flatten() {\n+    for fix in snap.check_fixes.get(&file_id).into_iter().flatten() {\n         let fix_range = from_proto::text_range(&line_index, fix.range);\n         if fix_range.intersect(range).is_none() {\n             continue;\n         }\n         res.push(fix.action.clone());\n     }\n \n-    for assist in world.analysis().assists(&world.config.assist, frange)?.into_iter() {\n-        res.push(to_proto::code_action(&world, assist)?.into());\n+    for assist in snap.analysis().assists(&snap.config.assist, frange)?.into_iter() {\n+        res.push(to_proto::code_action(&snap, assist)?.into());\n     }\n     Ok(Some(res))\n }\n \n pub fn handle_code_lens(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CodeLensParams,\n ) -> Result<Option<Vec<CodeLens>>> {\n     let _p = profile(\"handle_code_lens\");\n     let mut lenses: Vec<CodeLens> = Default::default();\n \n-    if world.config.lens.none() {\n+    if snap.config.lens.none() {\n         // early return before any db query!\n         return Ok(Some(lenses));\n     }\n \n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n \n-    if world.config.lens.runnable() {\n+    if snap.config.lens.runnable() {\n         // Gather runnables\n-        for runnable in world.analysis().runnables(file_id)? {\n+        for runnable in snap.analysis().runnables(file_id)? {\n             let (run_title, debugee) = match &runnable.kind {\n                 RunnableKind::Test { .. } | RunnableKind::TestMod { .. } => {\n                     (\"\u25b6\\u{fe0e} Run Test\", true)\n@@ -788,8 +793,8 @@ pub fn handle_code_lens(\n             };\n \n             let range = to_proto::range(&line_index, runnable.nav.range());\n-            let r = to_proto::runnable(&world, file_id, runnable)?;\n-            if world.config.lens.run {\n+            let r = to_proto::runnable(&snap, file_id, runnable)?;\n+            if snap.config.lens.run {\n                 let lens = CodeLens {\n                     range,\n                     command: Some(Command {\n@@ -802,7 +807,7 @@ pub fn handle_code_lens(\n                 lenses.push(lens);\n             }\n \n-            if debugee && world.config.lens.debug {\n+            if debugee && snap.config.lens.debug {\n                 let debug_lens = CodeLens {\n                     range,\n                     command: Some(Command {\n@@ -817,11 +822,10 @@ pub fn handle_code_lens(\n         }\n     }\n \n-    if world.config.lens.impementations {\n+    if snap.config.lens.impementations {\n         // Handle impls\n         lenses.extend(\n-            world\n-                .analysis()\n+            snap.analysis()\n                 .file_structure(file_id)?\n                 .into_iter()\n                 .filter(|it| match it.kind {\n@@ -856,14 +860,17 @@ enum CodeLensResolveData {\n     Impls(lsp_types::request::GotoImplementationParams),\n }\n \n-pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Result<CodeLens> {\n+pub fn handle_code_lens_resolve(\n+    snap: GlobalStateSnapshot,\n+    code_lens: CodeLens,\n+) -> Result<CodeLens> {\n     let _p = profile(\"handle_code_lens_resolve\");\n     let data = code_lens.data.unwrap();\n     let resolve = from_json::<Option<CodeLensResolveData>>(\"CodeLensResolveData\", data)?;\n     match resolve {\n         Some(CodeLensResolveData::Impls(lens_params)) => {\n             let locations: Vec<Location> =\n-                match handle_goto_implementation(world, lens_params.clone())? {\n+                match handle_goto_implementation(snap, lens_params.clone())? {\n                     Some(lsp_types::GotoDefinitionResponse::Scalar(loc)) => vec![loc],\n                     Some(lsp_types::GotoDefinitionResponse::Array(locs)) => locs,\n                     Some(lsp_types::GotoDefinitionResponse::Link(links)) => links\n@@ -902,14 +909,14 @@ pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Re\n }\n \n pub fn handle_document_highlight(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentHighlightParams,\n ) -> Result<Option<Vec<DocumentHighlight>>> {\n     let _p = profile(\"handle_document_highlight\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n \n-    let refs = match world\n+    let refs = match snap\n         .analysis()\n         .find_all_refs(position, Some(SearchScope::single_file(position.file_id)))?\n     {\n@@ -929,19 +936,19 @@ pub fn handle_document_highlight(\n }\n \n pub fn handle_ssr(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::SsrParams,\n ) -> Result<lsp_types::WorkspaceEdit> {\n     let _p = profile(\"handle_ssr\");\n     let source_change =\n-        world.analysis().structural_search_replace(&params.query, params.parse_only)??;\n-    to_proto::workspace_edit(&world, source_change)\n+        snap.analysis().structural_search_replace(&params.query, params.parse_only)??;\n+    to_proto::workspace_edit(&snap, source_change)\n }\n \n-pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n+pub fn publish_diagnostics(snap: &GlobalStateSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n     let _p = profile(\"publish_diagnostics\");\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let diagnostics: Vec<Diagnostic> = world\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let diagnostics: Vec<Diagnostic> = snap\n         .analysis()\n         .diagnostics(file_id)?\n         .into_iter()\n@@ -959,28 +966,28 @@ pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<Dia\n }\n \n pub fn handle_inlay_hints(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: InlayHintsParams,\n ) -> Result<Vec<InlayHint>> {\n     let _p = profile(\"handle_inlay_hints\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let analysis = world.analysis();\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let analysis = snap.analysis();\n     let line_index = analysis.file_line_index(file_id)?;\n     Ok(analysis\n-        .inlay_hints(file_id, &world.config.inlay_hints)?\n+        .inlay_hints(file_id, &snap.config.inlay_hints)?\n         .into_iter()\n         .map(|it| to_proto::inlay_int(&line_index, it))\n         .collect())\n }\n \n pub fn handle_call_hierarchy_prepare(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyPrepareParams,\n ) -> Result<Option<Vec<CallHierarchyItem>>> {\n     let _p = profile(\"handle_call_hierarchy_prepare\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n \n-    let nav_info = match world.analysis().call_hierarchy(position)? {\n+    let nav_info = match snap.analysis().call_hierarchy(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -989,24 +996,24 @@ pub fn handle_call_hierarchy_prepare(\n     let res = navs\n         .into_iter()\n         .filter(|it| it.kind() == SyntaxKind::FN_DEF)\n-        .map(|it| to_proto::call_hierarchy_item(&world, it))\n+        .map(|it| to_proto::call_hierarchy_item(&snap, it))\n         .collect::<Result<Vec<_>>>()?;\n \n     Ok(Some(res))\n }\n \n pub fn handle_call_hierarchy_incoming(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyIncomingCallsParams,\n ) -> Result<Option<Vec<CallHierarchyIncomingCall>>> {\n     let _p = profile(\"handle_call_hierarchy_incoming\");\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange = from_proto::file_range(&world, doc, item.range)?;\n+    let frange = from_proto::file_range(&snap, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n-    let call_items = match world.analysis().incoming_calls(fpos)? {\n+    let call_items = match snap.analysis().incoming_calls(fpos)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1015,8 +1022,8 @@ pub fn handle_call_hierarchy_incoming(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n+        let line_index = snap.analysis().file_line_index(file_id)?;\n+        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyIncomingCall {\n             from: item,\n             from_ranges: call_item\n@@ -1031,17 +1038,17 @@ pub fn handle_call_hierarchy_incoming(\n }\n \n pub fn handle_call_hierarchy_outgoing(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyOutgoingCallsParams,\n ) -> Result<Option<Vec<CallHierarchyOutgoingCall>>> {\n     let _p = profile(\"handle_call_hierarchy_outgoing\");\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange = from_proto::file_range(&world, doc, item.range)?;\n+    let frange = from_proto::file_range(&snap, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n-    let call_items = match world.analysis().outgoing_calls(fpos)? {\n+    let call_items = match snap.analysis().outgoing_calls(fpos)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1050,8 +1057,8 @@ pub fn handle_call_hierarchy_outgoing(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n+        let line_index = snap.analysis().file_line_index(file_id)?;\n+        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyOutgoingCall {\n             to: item,\n             from_ranges: call_item\n@@ -1066,31 +1073,31 @@ pub fn handle_call_hierarchy_outgoing(\n }\n \n pub fn handle_semantic_tokens(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: SemanticTokensParams,\n ) -> Result<Option<SemanticTokensResult>> {\n     let _p = profile(\"handle_semantic_tokens\");\n \n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let text = world.analysis().file_text(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let text = snap.analysis().file_text(file_id)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n \n-    let highlights = world.analysis().highlight(file_id)?;\n+    let highlights = snap.analysis().highlight(file_id)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n \n pub fn handle_semantic_tokens_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: SemanticTokensRangeParams,\n ) -> Result<Option<SemanticTokensRangeResult>> {\n     let _p = profile(\"handle_semantic_tokens_range\");\n \n-    let frange = from_proto::file_range(&world, params.text_document, params.range)?;\n-    let text = world.analysis().file_text(frange.file_id)?;\n-    let line_index = world.analysis().file_line_index(frange.file_id)?;\n+    let frange = from_proto::file_range(&snap, params.text_document, params.range)?;\n+    let text = snap.analysis().file_text(frange.file_id)?;\n+    let line_index = snap.analysis().file_line_index(frange.file_id)?;\n \n-    let highlights = world.analysis().highlight_range(frange)?;\n+    let highlights = snap.analysis().highlight_range(frange)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }"}, {"sha": "0915a7fcb786c5bcc26d760f85032bd4c6f09c80", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87cd8ecc66f1b644e4b11b8438fde1d5575b73c/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=a87cd8ecc66f1b644e4b11b8438fde1d5575b73c", "patch": "@@ -10,7 +10,8 @@ use ra_syntax::{SyntaxKind, TextRange, TextSize};\n use ra_vfs::LineEndings;\n \n use crate::{\n-    cargo_target_spec::CargoTargetSpec, lsp_ext, semantic_tokens, world::WorldSnapshot, Result,\n+    cargo_target_spec::CargoTargetSpec, global_state::GlobalStateSnapshot, lsp_ext,\n+    semantic_tokens, Result,\n };\n \n pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n@@ -384,41 +385,44 @@ pub(crate) fn folding_range(\n     }\n }\n \n-pub(crate) fn url(world: &WorldSnapshot, file_id: FileId) -> Result<lsp_types::Url> {\n-    world.file_id_to_uri(file_id)\n+pub(crate) fn url(snap: &GlobalStateSnapshot, file_id: FileId) -> Result<lsp_types::Url> {\n+    snap.file_id_to_uri(file_id)\n }\n \n pub(crate) fn versioned_text_document_identifier(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     file_id: FileId,\n     version: Option<i64>,\n ) -> Result<lsp_types::VersionedTextDocumentIdentifier> {\n-    let res = lsp_types::VersionedTextDocumentIdentifier { uri: url(world, file_id)?, version };\n+    let res = lsp_types::VersionedTextDocumentIdentifier { uri: url(snap, file_id)?, version };\n     Ok(res)\n }\n \n-pub(crate) fn location(world: &WorldSnapshot, frange: FileRange) -> Result<lsp_types::Location> {\n-    let url = url(world, frange.file_id)?;\n-    let line_index = world.analysis().file_line_index(frange.file_id)?;\n+pub(crate) fn location(\n+    snap: &GlobalStateSnapshot,\n+    frange: FileRange,\n+) -> Result<lsp_types::Location> {\n+    let url = url(snap, frange.file_id)?;\n+    let line_index = snap.analysis().file_line_index(frange.file_id)?;\n     let range = range(&line_index, frange.range);\n     let loc = lsp_types::Location::new(url, range);\n     Ok(loc)\n }\n \n pub(crate) fn location_link(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     src: Option<FileRange>,\n     target: NavigationTarget,\n ) -> Result<lsp_types::LocationLink> {\n     let origin_selection_range = match src {\n         Some(src) => {\n-            let line_index = world.analysis().file_line_index(src.file_id)?;\n+            let line_index = snap.analysis().file_line_index(src.file_id)?;\n             let range = range(&line_index, src.range);\n             Some(range)\n         }\n         None => None,\n     };\n-    let (target_uri, target_range, target_selection_range) = location_info(world, target)?;\n+    let (target_uri, target_range, target_selection_range) = location_info(snap, target)?;\n     let res = lsp_types::LocationLink {\n         origin_selection_range,\n         target_uri,\n@@ -429,35 +433,35 @@ pub(crate) fn location_link(\n }\n \n fn location_info(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n ) -> Result<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n-    let line_index = world.analysis().file_line_index(target.file_id())?;\n+    let line_index = snap.analysis().file_line_index(target.file_id())?;\n \n-    let target_uri = url(world, target.file_id())?;\n+    let target_uri = url(snap, target.file_id())?;\n     let target_range = range(&line_index, target.full_range());\n     let target_selection_range =\n         target.focus_range().map(|it| range(&line_index, it)).unwrap_or(target_range);\n     Ok((target_uri, target_range, target_selection_range))\n }\n \n pub(crate) fn goto_definition_response(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     src: Option<FileRange>,\n     targets: Vec<NavigationTarget>,\n ) -> Result<lsp_types::GotoDefinitionResponse> {\n-    if world.config.client_caps.location_link {\n+    if snap.config.client_caps.location_link {\n         let links = targets\n             .into_iter()\n-            .map(|nav| location_link(world, src, nav))\n+            .map(|nav| location_link(snap, src, nav))\n             .collect::<Result<Vec<_>>>()?;\n         Ok(links.into())\n     } else {\n         let locations = targets\n             .into_iter()\n             .map(|nav| {\n                 location(\n-                    world,\n+                    snap,\n                     FileRange {\n                         file_id: nav.file_id(),\n                         range: nav.focus_range().unwrap_or(nav.range()),\n@@ -470,13 +474,13 @@ pub(crate) fn goto_definition_response(\n }\n \n pub(crate) fn snippet_text_document_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     is_snippet: bool,\n     source_file_edit: SourceFileEdit,\n ) -> Result<lsp_ext::SnippetTextDocumentEdit> {\n-    let text_document = versioned_text_document_identifier(world, source_file_edit.file_id, None)?;\n-    let line_index = world.analysis().file_line_index(source_file_edit.file_id)?;\n-    let line_endings = world.file_line_endings(source_file_edit.file_id);\n+    let text_document = versioned_text_document_identifier(snap, source_file_edit.file_id, None)?;\n+    let line_index = snap.analysis().file_line_index(source_file_edit.file_id)?;\n+    let line_endings = snap.file_line_endings(source_file_edit.file_id);\n     let edits = source_file_edit\n         .edit\n         .into_iter()\n@@ -486,34 +490,34 @@ pub(crate) fn snippet_text_document_edit(\n }\n \n pub(crate) fn resource_op(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     file_system_edit: FileSystemEdit,\n ) -> Result<lsp_types::ResourceOp> {\n     let res = match file_system_edit {\n         FileSystemEdit::CreateFile { source_root, path } => {\n-            let uri = world.path_to_uri(source_root, &path)?;\n+            let uri = snap.path_to_uri(source_root, &path)?;\n             lsp_types::ResourceOp::Create(lsp_types::CreateFile { uri, options: None })\n         }\n         FileSystemEdit::MoveFile { src, dst_source_root, dst_path } => {\n-            let old_uri = world.file_id_to_uri(src)?;\n-            let new_uri = world.path_to_uri(dst_source_root, &dst_path)?;\n+            let old_uri = snap.file_id_to_uri(src)?;\n+            let new_uri = snap.path_to_uri(dst_source_root, &dst_path)?;\n             lsp_types::ResourceOp::Rename(lsp_types::RenameFile { old_uri, new_uri, options: None })\n         }\n     };\n     Ok(res)\n }\n \n pub(crate) fn snippet_workspace_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n ) -> Result<lsp_ext::SnippetWorkspaceEdit> {\n     let mut document_changes: Vec<lsp_ext::SnippetDocumentChangeOperation> = Vec::new();\n     for op in source_change.file_system_edits {\n-        let op = resource_op(&world, op)?;\n+        let op = resource_op(&snap, op)?;\n         document_changes.push(lsp_ext::SnippetDocumentChangeOperation::Op(op));\n     }\n     for edit in source_change.source_file_edits {\n-        let edit = snippet_text_document_edit(&world, source_change.is_snippet, edit)?;\n+        let edit = snippet_text_document_edit(&snap, source_change.is_snippet, edit)?;\n         document_changes.push(lsp_ext::SnippetDocumentChangeOperation::Edit(edit));\n     }\n     let workspace_edit =\n@@ -522,11 +526,11 @@ pub(crate) fn snippet_workspace_edit(\n }\n \n pub(crate) fn workspace_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n ) -> Result<lsp_types::WorkspaceEdit> {\n     assert!(!source_change.is_snippet);\n-    snippet_workspace_edit(world, source_change).map(|it| it.into())\n+    snippet_workspace_edit(snap, source_change).map(|it| it.into())\n }\n \n impl From<lsp_ext::SnippetWorkspaceEdit> for lsp_types::WorkspaceEdit {\n@@ -565,13 +569,13 @@ impl From<lsp_ext::SnippetWorkspaceEdit> for lsp_types::WorkspaceEdit {\n }\n \n pub fn call_hierarchy_item(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n ) -> Result<lsp_types::CallHierarchyItem> {\n     let name = target.name().to_string();\n     let detail = target.description().map(|it| it.to_string());\n     let kind = symbol_kind(target.kind());\n-    let (uri, range, selection_range) = location_info(world, target)?;\n+    let (uri, range, selection_range) = location_info(snap, target)?;\n     Ok(lsp_types::CallHierarchyItem { name, kind, tags: None, detail, uri, range, selection_range })\n }\n \n@@ -619,23 +623,26 @@ fn main() <fold>{\n     }\n }\n \n-pub(crate) fn code_action(world: &WorldSnapshot, assist: Assist) -> Result<lsp_ext::CodeAction> {\n+pub(crate) fn code_action(\n+    snap: &GlobalStateSnapshot,\n+    assist: Assist,\n+) -> Result<lsp_ext::CodeAction> {\n     let res = lsp_ext::CodeAction {\n         title: assist.label,\n-        group: if world.config.client_caps.code_action_group { assist.group_label } else { None },\n+        group: if snap.config.client_caps.code_action_group { assist.group_label } else { None },\n         kind: Some(String::new()),\n-        edit: Some(snippet_workspace_edit(world, assist.source_change)?),\n+        edit: Some(snippet_workspace_edit(snap, assist.source_change)?),\n         command: None,\n     };\n     Ok(res)\n }\n \n pub(crate) fn runnable(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     file_id: FileId,\n     runnable: Runnable,\n ) -> Result<lsp_ext::Runnable> {\n-    let spec = CargoTargetSpec::for_file(world, file_id)?;\n+    let spec = CargoTargetSpec::for_file(snap, file_id)?;\n     let target = spec.as_ref().map(|s| s.target.clone());\n     let (cargo_args, executable_args) =\n         CargoTargetSpec::runnable_args(spec, &runnable.kind, &runnable.cfg_exprs)?;\n@@ -648,14 +655,14 @@ pub(crate) fn runnable(\n             target.map_or_else(|| \"run binary\".to_string(), |t| format!(\"run {}\", t))\n         }\n     };\n-    let location = location_link(world, None, runnable.nav)?;\n+    let location = location_link(snap, None, runnable.nav)?;\n \n     Ok(lsp_ext::Runnable {\n         label,\n         location: Some(location),\n         kind: lsp_ext::RunnableKind::Cargo,\n         args: lsp_ext::CargoRunnable {\n-            workspace_root: world.workspace_root_for(file_id).map(|root| root.to_owned()),\n+            workspace_root: snap.workspace_root_for(file_id).map(|root| root.to_owned()),\n             cargo_args,\n             executable_args,\n         },"}]}