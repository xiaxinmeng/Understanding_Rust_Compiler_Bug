{"sha": "89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YjA2NWRiZDJiOTUzZWEzYWUxNWViZmI2N2E3OTllOGIwYTNlY2M=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-01-15T12:51:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-15T12:51:43Z"}, "message": "Rollup merge of #67914 - Aaron1011:fix/const-prop-impossible, r=matthewjasper,oli-obk\n\nDon't run const propagation on items with inconsistent bounds\n\nFixes #67696\n\nUsing `#![feature(trivial_bounds)]`, it's possible to write functions\nwith unsatisfiable 'where' clauses, making them uncallable. However, the\nuser can act as if these 'where' clauses are true inside the body of the\nfunction, leading to code that would normally be impossible to write.\n\nSince const propgation can run even without any user-written calls to a\nfunction, we need to explcitly check for these uncallable functions.", "tree": {"sha": "b64b104fcd7356a07d2e43c431389c559d1921d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b64b104fcd7356a07d2e43c431389c559d1921d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeHwrfCRBK7hj4Ov3rIwAAdHIIAAy4V3RWK3rwrfMPLOR/oXKn\nq6OIuD066qXa3Bi7SwtD/F2vq903oZi9tyvBCB8FdWr8HDW53np141YvCsTS5WPX\nMWsjnfiwOw24+3CAFfbqLsKfsG59GEIm4zwlsIZTnG7tZFG1+ek6Eb8hxTPspTV3\nL1O6ZKCmTSYbgpnHS2GQLsyhjs85fSm4x72/JRXGHzL9Aj7xwRFyk1IKa/AEI9gV\nzuUh0aN6NlMMvs+b5AZ6LBo2zbdTLpqbLqzT4CeLwP8efYrijmD3HcQcsS9iyqnN\nUCc/Ppf3YuXMDVk0jJgtHQO4J14jBzor7FNb05l9eZezSHa0MFtaxYMEkjNiz0I=\n=H/j/\n-----END PGP SIGNATURE-----\n", "payload": "tree b64b104fcd7356a07d2e43c431389c559d1921d8\nparent e800fe199cbfbbaa46dfa519e46b594512c068be\nparent e390b91e5717a338db20360a1ddffa23ba66701d\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1579092703 +0900\ncommitter GitHub <noreply@github.com> 1579092703 +0900\n\nRollup merge of #67914 - Aaron1011:fix/const-prop-impossible, r=matthewjasper,oli-obk\n\nDon't run const propagation on items with inconsistent bounds\n\nFixes #67696\n\nUsing `#![feature(trivial_bounds)]`, it's possible to write functions\nwith unsatisfiable 'where' clauses, making them uncallable. However, the\nuser can act as if these 'where' clauses are true inside the body of the\nfunction, leading to code that would normally be impossible to write.\n\nSince const propgation can run even without any user-written calls to a\nfunction, we need to explcitly check for these uncallable functions.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "html_url": "https://github.com/rust-lang/rust/commit/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e800fe199cbfbbaa46dfa519e46b594512c068be", "url": "https://api.github.com/repos/rust-lang/rust/commits/e800fe199cbfbbaa46dfa519e46b594512c068be", "html_url": "https://github.com/rust-lang/rust/commit/e800fe199cbfbbaa46dfa519e46b594512c068be"}, {"sha": "e390b91e5717a338db20360a1ddffa23ba66701d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e390b91e5717a338db20360a1ddffa23ba66701d", "html_url": "https://github.com/rust-lang/rust/commit/e390b91e5717a338db20360a1ddffa23ba66701d"}], "stats": {"total": 129, "additions": 115, "deletions": 14}, "files": [{"sha": "e7a4c5b5921052aa9ba41d3c713e3db873d63b05", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "patch": "@@ -1,6 +1,7 @@\n use crate::dep_graph::{DepConstructor, DepNode, WorkProduct, WorkProductId};\n use crate::ich::{Fingerprint, NodeIdHashingMode, StableHashingContext};\n use crate::session::config::OptLevel;\n+use crate::traits::TraitQueryMode;\n use crate::ty::print::obsolete::DefPathBasedNames;\n use crate::ty::{subst::InternalSubsts, Instance, InstanceDef, SymbolName, TyCtxt};\n use rustc_data_structures::base_n;\n@@ -167,7 +168,9 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::GlobalAsm(..) => return true,\n         };\n \n-        tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n+        // We shouldn't encounter any overflow here, so we use TraitQueryMode::Standard\\\n+        // to report an error if overflow somehow occurs.\n+        tcx.substitute_normalize_and_test_predicates((def_id, &substs, TraitQueryMode::Standard))\n     }\n \n     pub fn to_string(&self, tcx: TyCtxt<'tcx>, debug: bool) -> String {"}, {"sha": "a20e011b91a7543697bdb006784a82e205397ace", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "patch": "@@ -1148,11 +1148,11 @@ rustc_queries! {\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n-        query substitute_normalize_and_test_predicates(key: (DefId, SubstsRef<'tcx>)) -> bool {\n+        query substitute_normalize_and_test_predicates(key: (DefId, SubstsRef<'tcx>, traits::TraitQueryMode)) -> bool {\n             no_force\n             desc { |tcx|\n-                \"testing substituted normalized predicates:`{}`\",\n-                tcx.def_path_str(key.0)\n+                \"testing substituted normalized predicates in mode {:?}:`{}`\",\n+                key.2, tcx.def_path_str(key.0)\n             }\n         }\n "}, {"sha": "9e5abc80822c7cf5d5653355bfc25acc4e7b289f", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "patch": "@@ -16,6 +16,7 @@ use super::CodeSelectionError;\n use super::{ConstEvalFailure, Unimplemented};\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation};\n+use crate::traits::TraitQueryMode;\n \n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     type Predicate = ty::Predicate<'tcx>;\n@@ -62,6 +63,9 @@ pub struct FulfillmentContext<'tcx> {\n     // a snapshot (they don't *straddle* a snapshot, so there\n     // is no trouble there).\n     usable_in_snapshot: bool,\n+\n+    // The `TraitQueryMode` used when constructing a `SelectionContext`\n+    query_mode: TraitQueryMode,\n }\n \n #[derive(Clone, Debug)]\n@@ -75,12 +79,26 @@ pub struct PendingPredicateObligation<'tcx> {\n static_assert_size!(PendingPredicateObligation<'_>, 136);\n \n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n-    /// Creates a new fulfillment context.\n+    /// Creates a new fulfillment context with `TraitQueryMode::Standard`\n+    /// You almost always want to use this instead of `with_query_mode`\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             register_region_obligations: true,\n             usable_in_snapshot: false,\n+            query_mode: TraitQueryMode::Standard,\n+        }\n+    }\n+\n+    /// Creates a new fulfillment context with the specified query mode.\n+    /// This should only be used when you want to ignore overflow,\n+    /// rather than reporting it as an error.\n+    pub fn with_query_mode(query_mode: TraitQueryMode) -> FulfillmentContext<'tcx> {\n+        FulfillmentContext {\n+            predicates: ObligationForest::new(),\n+            register_region_obligations: true,\n+            usable_in_snapshot: false,\n+            query_mode,\n         }\n     }\n \n@@ -89,6 +107,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n             predicates: ObligationForest::new(),\n             register_region_obligations: true,\n             usable_in_snapshot: true,\n+            query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n@@ -97,6 +116,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n             predicates: ObligationForest::new(),\n             register_region_obligations: false,\n             usable_in_snapshot: false,\n+            query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n@@ -217,7 +237,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n-        let mut selcx = SelectionContext::new(infcx);\n+        let mut selcx = SelectionContext::with_query_mode(infcx, self.query_mode);\n         self.select(&mut selcx)\n     }\n "}, {"sha": "31de5409fc8be9389b6b3cfc953cc34f3661d1bb", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "patch": "@@ -95,7 +95,7 @@ pub enum IntercrateMode {\n }\n \n /// The mode that trait queries run in.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, HashStable)]\n pub enum TraitQueryMode {\n     // Standard/un-canonicalized queries get accurate\n     // spans etc. passed in and hence can do reasonable\n@@ -1017,13 +1017,14 @@ where\n fn normalize_and_test_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: Vec<ty::Predicate<'tcx>>,\n+    mode: TraitQueryMode,\n ) -> bool {\n-    debug!(\"normalize_and_test_predicates(predicates={:?})\", predicates);\n+    debug!(\"normalize_and_test_predicates(predicates={:?}, mode={:?})\", predicates, mode);\n \n     let result = tcx.infer_ctxt().enter(|infcx| {\n         let param_env = ty::ParamEnv::reveal_all();\n-        let mut selcx = SelectionContext::new(&infcx);\n-        let mut fulfill_cx = FulfillmentContext::new();\n+        let mut selcx = SelectionContext::with_query_mode(&infcx, mode);\n+        let mut fulfill_cx = FulfillmentContext::with_query_mode(mode);\n         let cause = ObligationCause::dummy();\n         let Normalized { value: predicates, obligations } =\n             normalize(&mut selcx, param_env, cause.clone(), &predicates);\n@@ -1043,12 +1044,12 @@ fn normalize_and_test_predicates<'tcx>(\n \n fn substitute_normalize_and_test_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    key: (DefId, SubstsRef<'tcx>),\n+    key: (DefId, SubstsRef<'tcx>, TraitQueryMode),\n ) -> bool {\n     debug!(\"substitute_normalize_and_test_predicates(key={:?})\", key);\n \n     let predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n-    let result = normalize_and_test_predicates(tcx, predicates);\n+    let result = normalize_and_test_predicates(tcx, predicates, key.2);\n \n     debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\", key, result);\n     result\n@@ -1101,7 +1102,10 @@ fn vtable_methods<'tcx>(\n             // Note that this method could then never be called, so we\n             // do not want to try and codegen it, in that case (see #23435).\n             let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n+            // We don't expect overflow here, so report an error if it somehow ends\n+            // up happening.\n+            if !normalize_and_test_predicates(tcx, predicates.predicates, TraitQueryMode::Standard)\n+            {\n                 debug!(\"vtable_methods: predicates do not hold\");\n                 return None;\n             }"}, {"sha": "3fb3720a5638a1dc7d253425b4f57b13e357dd85", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "patch": "@@ -125,6 +125,15 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     }\n }\n \n+impl<'tcx> Key for (DefId, SubstsRef<'tcx>, traits::TraitQueryMode) {\n+    fn query_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n     fn query_crate(&self) -> CrateNum {\n         self.1.def_id().krate"}, {"sha": "90c97480c756221ebd7164a1696fde8f3d428c81", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "patch": "@@ -14,6 +14,7 @@ use rustc::mir::{\n     SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n     UnOp, RETURN_PLACE,\n };\n+use rustc::traits::TraitQueryMode;\n use rustc::ty::layout::{\n     HasDataLayout, HasTyCtxt, LayoutError, LayoutOf, Size, TargetDataLayout, TyLayout,\n };\n@@ -74,6 +75,46 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             return;\n         }\n \n+        // Check if it's even possible to satisfy the 'where' clauses\n+        // for this item.\n+        // This branch will never be taken for any normal function.\n+        // However, it's possible to `#!feature(trivial_bounds)]` to write\n+        // a function with impossible to satisfy clauses, e.g.:\n+        // `fn foo() where String: Copy {}`\n+        //\n+        // We don't usually need to worry about this kind of case,\n+        // since we would get a compilation error if the user tried\n+        // to call it. However, since we can do const propagation\n+        // even without any calls to the function, we need to make\n+        // sure that it even makes sense to try to evaluate the body.\n+        // If there are unsatisfiable where clauses, then all bets are\n+        // off, and we just give up.\n+        //\n+        // Note that we use TraitQueryMode::Canonical here, which causes\n+        // us to treat overflow like any other error. This is because we\n+        // are \"speculatively\" evaluating this item with the default substs.\n+        // While this usually succeeds, it may fail with tricky impls\n+        // (e.g. the typenum crate). Const-propagation is fundamentally\n+        // \"best-effort\", and does not affect correctness in any way.\n+        // Therefore, it's perfectly fine to just \"give up\" if we're\n+        // unable to check the bounds with the default substs.\n+        //\n+        // False negatives (failing to run const-prop on something when we actually\n+        // could) are fine. However, false positives (running const-prop on\n+        // an item with unsatisfiable bounds) can lead to us generating invalid\n+        // MIR.\n+        if !tcx.substitute_normalize_and_test_predicates((\n+            source.def_id(),\n+            InternalSubsts::identity_for_item(tcx, source.def_id()),\n+            TraitQueryMode::Canonical,\n+        )) {\n+            trace!(\n+                \"ConstProp skipped for item with unsatisfiable predicates: {:?}\",\n+                source.def_id()\n+            );\n+            return;\n+        }\n+\n         trace!(\"ConstProp starting for {:?}\", source.def_id());\n \n         let dummy_body = &Body::new("}, {"sha": "ad52608b3f46d27de9715ebeb5dc44f378f3d4cc", "filename": "src/test/ui/consts/issue-67696-const-prop-ice.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Ftest%2Fui%2Fconsts%2Fissue-67696-const-prop-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Ftest%2Fui%2Fconsts%2Fissue-67696-const-prop-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-67696-const-prop-ice.rs?ref=89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+// compile-flags: --emit=mir,link\n+// Checks that we don't ICE due to attempting to run const prop\n+// on a function with unsatisifable 'where' clauses\n+\n+#![allow(unused)]\n+\n+trait A {\n+    fn foo(&self) -> Self where Self: Copy;\n+}\n+\n+impl A for [fn(&())] {\n+    fn foo(&self) -> Self where Self: Copy { *(&[] as &[_]) }\n+}\n+\n+impl A for i32 {\n+    fn foo(&self) -> Self { 3 }\n+}\n+\n+fn main() {}"}, {"sha": "69eee66e64d89a1ed04b91cdf2a55b0bb3108bb8", "filename": "src/test/ui/trivial-bounds/trivial-bounds-inconsistent-associated-functions.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-associated-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-associated-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-associated-functions.rs?ref=89b065dbd2b953ea3ae15ebfb67a799e8b0a3ecc", "patch": "@@ -1,4 +1,8 @@\n-// run-pass\n+// check-pass\n+// compile-flags: --emit=mir,link\n+// Force mir to be emitted, to ensure that const\n+// propagation doesn't ICE on a function\n+// with an 'impossible' body. See issue #67696\n // Inconsistent bounds with trait implementations\n \n #![feature(trivial_bounds)]"}]}