{"sha": "b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxOGJkNzg1ZWM0ODljNWMwYWU5Zjg0ZTgxNDRhMzdlNDE0Y2RlZTU=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-31T19:07:44Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-01T14:54:22Z"}, "message": "std: Replace `for` with `do { .. }` expr where internal iterators are used", "tree": {"sha": "1437f63026b4caec9695845d973a139bcd44122f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1437f63026b4caec9695845d973a139bcd44122f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "html_url": "https://github.com/rust-lang/rust/commit/b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/comments", "author": null, "committer": null, "parents": [{"sha": "02bdf90cf6509f0f308ce133551a833c264b8960", "url": "https://api.github.com/repos/rust-lang/rust/commits/02bdf90cf6509f0f308ce133551a833c264b8960", "html_url": "https://github.com/rust-lang/rust/commit/02bdf90cf6509f0f308ce133551a833c264b8960"}], "stats": {"total": 174, "additions": 96, "deletions": 78}, "files": [{"sha": "95f3af006e8cc52d8211edba18a8bd91673fb93c", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "patch": "@@ -784,11 +784,12 @@ impl<\n     fn encode(&self, e: &mut E) {\n         do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n-            for self.each |key, val| {\n+            do self.each |key, val| {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n-            }\n+                true\n+            };\n         }\n     }\n }\n@@ -814,10 +815,11 @@ impl<S: Encoder> Encodable<S> for TrieSet {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            for self.each |e| {\n+            do self.each |e| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n-            }\n+                true\n+            };\n         }\n     }\n }"}, {"sha": "24ca6fc23091da83f47a262e3490a629029014eb", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "patch": "@@ -94,42 +94,45 @@ pub unsafe fn annihilate() {\n     //\n     // In this pass, nothing gets freed, so it does not matter whether\n     // we read the next field before or after the callback.\n-    for each_live_alloc(true) |box, uniq| {\n+    do each_live_alloc(true) |box, uniq| {\n         stats.n_total_boxes += 1;\n         if uniq {\n             stats.n_unique_boxes += 1;\n         } else {\n             (*box).ref_count = managed::RC_IMMORTAL;\n         }\n-    }\n+        true\n+    };\n \n     // Pass 2: Drop all boxes.\n     //\n     // In this pass, unique-managed boxes may get freed, but not\n     // managed boxes, so we must read the `next` field *after* the\n     // callback, as the original value may have been freed.\n-    for each_live_alloc(false) |box, uniq| {\n+    do each_live_alloc(false) |box, uniq| {\n         if !uniq {\n             let tydesc = (*box).type_desc;\n             let data = &(*box).data as *();\n             ((*tydesc).drop_glue)(data as *i8);\n         }\n-    }\n+        true\n+    };\n \n     // Pass 3: Free all boxes.\n     //\n     // In this pass, managed boxes may get freed (but not\n     // unique-managed boxes, though I think that none of those are\n     // left), so we must read the `next` field before, since it will\n     // not be valid after.\n-    for each_live_alloc(true) |box, uniq| {\n+    do each_live_alloc(true) |box, uniq| {\n         if !uniq {\n             stats.n_bytes_freed +=\n                 (*((*box).type_desc)).size\n                 + sys::size_of::<raw::Box<()>>();\n             local_free(box as *i8);\n         }\n-    }\n+        true\n+    };\n \n     if debug_mem() {\n         // We do logging here w/o allocation."}, {"sha": "8c06f23b8c191a12f3eb0654df7dcbac312a25a8", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "patch": "@@ -130,33 +130,35 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                                 hash: uint,\n                                 k: &K)\n                              -> SearchResult {\n-        for self.bucket_sequence(hash) |i| {\n+        let mut ret = TableFull;\n+        do self.bucket_sequence(hash) |i| {\n             match self.buckets[i] {\n-                Some(ref bkt) => if bkt.hash == hash && *k == bkt.key {\n-                    return FoundEntry(i);\n+                Some(ref bkt) if bkt.hash == hash && *k == bkt.key => {\n+                    ret = FoundEntry(i); false\n                 },\n-                None => return FoundHole(i)\n+                None => { ret = FoundHole(i); false }\n+                _ => true,\n             }\n-        }\n-        TableFull\n+        };\n+        ret\n     }\n \n     #[inline]\n     fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n                                                   hash: uint,\n                                                   k: &Q)\n                                                -> SearchResult {\n-        for self.bucket_sequence(hash) |i| {\n+        let mut ret = TableFull;\n+        do self.bucket_sequence(hash) |i| {\n             match self.buckets[i] {\n-                Some(ref bkt) => {\n-                    if bkt.hash == hash && k.equiv(&bkt.key) {\n-                        return FoundEntry(i);\n-                    }\n+                Some(ref bkt) if bkt.hash == hash && k.equiv(&bkt.key) => {\n+                    ret = FoundEntry(i); false\n                 },\n-                None => return FoundHole(i)\n+                None => { ret = FoundHole(i); false }\n+                _ => true,\n             }\n-        }\n-        TableFull\n+        };\n+        ret\n     }\n \n     /// Expand the capacity of the array to the next power of two\n@@ -272,11 +274,6 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n \n         value\n     }\n-\n-    fn search(&self, hash: uint,\n-              op: &fn(x: &Option<Bucket<K, V>>) -> bool) {\n-        let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n-    }\n }\n \n impl<K:Hash + Eq,V> Container for HashMap<K, V> {"}, {"sha": "153286a311a9c42b02231fd337607ea0a2ce14b2", "filename": "src/libstd/io.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "patch": "@@ -770,9 +770,10 @@ impl<T:Reader> ReaderUtil for T {\n \n     fn read_lines(&self) -> ~[~str] {\n         do vec::build |push| {\n-            for self.each_line |line| {\n+            do self.each_line |line| {\n                 push(line.to_owned());\n-            }\n+                true\n+            };\n         }\n     }\n \n@@ -1880,16 +1881,16 @@ mod tests {\n \n         {\n             let file = io::file_reader(&path).unwrap();\n-            for file.each_byte() |_| {\n-                fail!(\"must be empty\");\n-            }\n+            do file.each_byte() |_| {\n+                fail!(\"must be empty\")\n+            };\n         }\n \n         {\n             let file = io::file_reader(&path).unwrap();\n-            for file.each_char() |_| {\n-                fail!(\"must be empty\");\n-            }\n+            do file.each_char() |_| {\n+                fail!(\"must be empty\")\n+            };\n         }\n     }\n "}, {"sha": "1bfae8c40e16f90aa00b0bd3c16d70fecfd8972e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "patch": "@@ -790,7 +790,7 @@ pub fn list_dir_path(p: &Path) -> ~[Path] {\n /// all its contents. Use carefully!\n pub fn remove_dir_recursive(p: &Path) -> bool {\n     let mut error_happened = false;\n-    for walk_dir(p) |inner| {\n+    do walk_dir(p) |inner| {\n         if !error_happened {\n             if path_is_dir(inner) {\n                 if !remove_dir_recursive(inner) {\n@@ -803,6 +803,7 @@ pub fn remove_dir_recursive(p: &Path) -> bool {\n                 }\n             }\n         }\n+        true\n     };\n     // Directory should now be empty\n     !error_happened && remove_dir(p)"}, {"sha": "4558f8e32c1e1ed8b3cc497b4ef579a8b47d6612", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "patch": "@@ -372,8 +372,9 @@ impl Drop for Taskgroup {\n                 // with our own taskgroup, so long as both happen before we die.\n                 // We remove ourself from every ancestor we can, so no cleanup; no\n                 // break.\n-                for each_ancestor(&mut this.ancestors, |_| {}) |ancestor_group| {\n+                do each_ancestor(&mut this.ancestors, |_| {}) |ancestor_group| {\n                     leave_taskgroup(ancestor_group, &me, false);\n+                    true\n                 };\n             }\n         }"}, {"sha": "f60093ce48c6c9ac3ddf03f645028bbd293c4070", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "patch": "@@ -459,11 +459,12 @@ mod test_map {\n         assert!(m.insert(1, 2));\n \n         let mut n = 0;\n-        for m.each |k, v| {\n+        do m.each |k, v| {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n += 1;\n-        }\n+            true\n+        };\n     }\n \n     #[test]\n@@ -475,14 +476,16 @@ mod test_map {\n         }\n \n         let mut n = uint::max_value - 10000;\n-        for m.each |k, v| {\n-            if n == uint::max_value - 5000 { break }\n-            assert!(n < uint::max_value - 5000);\n-\n-            assert_eq!(*k, n);\n-            assert_eq!(*v, n / 2);\n-            n += 1;\n-        }\n+        do m.each |k, v| {\n+            if n == uint::max_value - 5000 { false } else {\n+                assert!(n < uint::max_value - 5000);\n+\n+                assert_eq!(*k, n);\n+                assert_eq!(*v, n / 2);\n+                n += 1;\n+                true\n+            }\n+        };\n     }\n \n     #[test]\n@@ -496,11 +499,12 @@ mod test_map {\n         assert!(m.insert(1, 2));\n \n         let mut n = 4;\n-        for m.each_reverse |k, v| {\n+        do m.each_reverse |k, v| {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n -= 1;\n-        }\n+            true\n+        };\n     }\n \n     #[test]\n@@ -512,14 +516,16 @@ mod test_map {\n         }\n \n         let mut n = uint::max_value - 1;\n-        for m.each_reverse |k, v| {\n-            if n == uint::max_value - 5000 { break }\n-            assert!(n > uint::max_value - 5000);\n-\n-            assert_eq!(*k, n);\n-            assert_eq!(*v, n / 2);\n-            n -= 1;\n-        }\n+        do m.each_reverse |k, v| {\n+            if n == uint::max_value - 5000 { false } else {\n+                assert!(n > uint::max_value - 5000);\n+\n+                assert_eq!(*k, n);\n+                assert_eq!(*v, n / 2);\n+                n -= 1;\n+                true\n+            }\n+        };\n     }\n \n     #[test]\n@@ -572,10 +578,11 @@ mod test_set {\n \n         let mut i = 0;\n \n-        for trie.each |x| {\n+        do trie.each |x| {\n             assert_eq!(expected[i], *x);\n             i += 1;\n-        }\n+            true\n+        };\n     }\n \n     #[test]"}, {"sha": "6cff9ce84cf18643bb5a16b004a0afa47d5bd110", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "patch": "@@ -2767,19 +2767,19 @@ mod tests {\n         let mut results: ~[~[int]];\n \n         results = ~[];\n-        for each_permutation([]) |v| { results.push(v.to_owned()); }\n+        do each_permutation([]) |v| { results.push(v.to_owned()); true };\n         assert_eq!(results, ~[~[]]);\n \n         results = ~[];\n-        for each_permutation([7]) |v| { results.push(v.to_owned()); }\n+        do each_permutation([7]) |v| { results.push(v.to_owned()); true };\n         assert_eq!(results, ~[~[7]]);\n \n         results = ~[];\n-        for each_permutation([1,1]) |v| { results.push(v.to_owned()); }\n+        do each_permutation([1,1]) |v| { results.push(v.to_owned()); true };\n         assert_eq!(results, ~[~[1,1],~[1,1]]);\n \n         results = ~[];\n-        for each_permutation([5,2,0]) |v| { results.push(v.to_owned()); }\n+        do each_permutation([5,2,0]) |v| { results.push(v.to_owned()); true };\n         assert!(results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n     }\n@@ -3107,12 +3107,13 @@ mod tests {\n     fn test_permute_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        for each_permutation(v) |_elt| {\n+        do each_permutation(v) |_elt| {\n             if i == 2 {\n                 fail!()\n             }\n             i += 0;\n-        }\n+            true\n+        };\n     }\n \n     #[test]\n@@ -3425,39 +3426,43 @@ mod tests {\n     fn test_permutations0() {\n         let values = [];\n         let mut v : ~[~[int]] = ~[];\n-        for each_permutation(values) |p| {\n+        do each_permutation(values) |p| {\n             v.push(p.to_owned());\n-        }\n+            true\n+        };\n         assert_eq!(v, ~[~[]]);\n     }\n \n     #[test]\n     fn test_permutations1() {\n         let values = [1];\n         let mut v : ~[~[int]] = ~[];\n-        for each_permutation(values) |p| {\n+        do each_permutation(values) |p| {\n             v.push(p.to_owned());\n-        }\n+            true\n+        };\n         assert_eq!(v, ~[~[1]]);\n     }\n \n     #[test]\n     fn test_permutations2() {\n         let values = [1,2];\n         let mut v : ~[~[int]] = ~[];\n-        for each_permutation(values) |p| {\n+        do each_permutation(values) |p| {\n             v.push(p.to_owned());\n-        }\n+            true\n+        };\n         assert_eq!(v, ~[~[1,2],~[2,1]]);\n     }\n \n     #[test]\n     fn test_permutations3() {\n         let values = [1,2,3];\n         let mut v : ~[~[int]] = ~[];\n-        for each_permutation(values) |p| {\n+        do each_permutation(values) |p| {\n             v.push(p.to_owned());\n-        }\n+            true\n+        };\n         assert_eq!(v, ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]]);\n     }\n "}, {"sha": "b86ad6d56f826dbc5f92e6d1e521ec10d71917c9", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18bd785ec489c5c0ae9f84e8144a37e414cdee5/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=b18bd785ec489c5c0ae9f84e8144a37e414cdee5", "patch": "@@ -65,13 +65,14 @@ fn square_from_char(c: char) -> square {\n fn read_board_grid<rdr:'static + io::Reader>(input: rdr) -> ~[~[square]] {\n     let input = @input as @io::Reader;\n     let mut grid = ~[];\n-    for input.each_line |line| {\n+    do input.each_line |line| {\n         let mut row = ~[];\n         foreach c in line.iter() {\n             row.push(square_from_char(c))\n         }\n-        grid.push(row)\n-    }\n+        grid.push(row);\n+        true\n+    };\n     let width = grid[0].len();\n     foreach row in grid.iter() { assert!(row.len() == width) }\n     grid"}]}