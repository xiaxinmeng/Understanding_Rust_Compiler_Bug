{"sha": "6fcd38cc81bdcc9921da767872dfce65ee7d2d27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmY2QzOGNjODFiZGNjOTkyMWRhNzY3ODcyZGZjZTY1ZWU3ZDJkMjc=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-24T20:00:14Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-25T14:16:42Z"}, "message": "Infer result of struct literals, and recurse into their child expressions", "tree": {"sha": "5d5ae0f57cc25d0bf8b0613a5e05de1f773b42ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d5ae0f57cc25d0bf8b0613a5e05de1f773b42ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fcd38cc81bdcc9921da767872dfce65ee7d2d27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fcd38cc81bdcc9921da767872dfce65ee7d2d27", "html_url": "https://github.com/rust-lang/rust/commit/6fcd38cc81bdcc9921da767872dfce65ee7d2d27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ff161852016c6c15954d6f30bd637834a2b2b68", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff161852016c6c15954d6f30bd637834a2b2b68", "html_url": "https://github.com/rust-lang/rust/commit/4ff161852016c6c15954d6f30bd637834a2b2b68"}], "stats": {"total": 192, "additions": 143, "deletions": 49}, "files": [{"sha": "ee270ac459d7001443aa860af556804d6667314a", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=6fcd38cc81bdcc9921da767872dfce65ee7d2d27", "patch": "@@ -1,3 +1,5 @@\n+use std::sync::Arc;\n+\n use ra_syntax::{SmolStr, ast::{self, NameOwner}};\n \n use crate::{\n@@ -15,6 +17,14 @@ impl Struct {\n         Struct { def_id }\n     }\n \n+    pub fn def_id(&self) -> DefId {\n+        self.def_id\n+    }\n+\n+    pub fn struct_data(&self, db: &impl HirDatabase) -> Cancelable<Arc<StructData>> {\n+        Ok(db.struct_data(self.def_id)?)\n+    }\n+\n     pub fn name(&self, db: &impl HirDatabase) -> Cancelable<SmolStr> {\n         Ok(db.struct_data(self.def_id)?.name.clone())\n     }\n@@ -23,7 +33,7 @@ impl Struct {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StructData {\n     name: SmolStr,\n-    variant_data: VariantData,\n+    variant_data: Arc<VariantData>,\n }\n \n impl StructData {\n@@ -33,8 +43,17 @@ impl StructData {\n             .map(|n| n.text())\n             .unwrap_or(SmolStr::new(\"[error]\"));\n         let variant_data = VariantData::Unit; // TODO implement this\n+        let variant_data = Arc::new(variant_data);\n         StructData { name, variant_data }\n     }\n+\n+    pub fn name(&self) -> &SmolStr {\n+        &self.name\n+    }\n+\n+    pub fn variant_data(&self) -> &Arc<VariantData> {\n+        &self.variant_data\n+    }\n }\n \n pub struct Enum {\n@@ -46,6 +65,10 @@ impl Enum {\n         Enum { def_id }\n     }\n \n+    pub fn def_id(&self) -> DefId {\n+        self.def_id\n+    }\n+\n     pub fn name(&self, db: &impl HirDatabase) -> Cancelable<SmolStr> {\n         Ok(db.enum_data(self.def_id)?.name.clone())\n     }\n@@ -54,7 +77,7 @@ impl Enum {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n     name: SmolStr,\n-    variants: Vec<(SmolStr, VariantData)>,\n+    variants: Vec<(SmolStr, Arc<VariantData>)>,\n }\n \n impl EnumData {"}, {"sha": "386af8120abf074b63616622c0e88200d40e75f2", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 83, "deletions": 36, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=6fcd38cc81bdcc9921da767872dfce65ee7d2d27", "patch": "@@ -16,9 +16,9 @@ use ra_syntax::{\n };\n \n use crate::{\n-    Def, DefId, FnScopes, Module, Function,\n-    Path, db::HirDatabase,\n-    module::nameres::Namespace\n+    Def, DefId, FnScopes, Module, Function, Struct, Path,\n+    db::HirDatabase,\n+    adt::VariantData,\n };\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n@@ -125,6 +125,37 @@ pub struct FnSig {\n }\n \n impl Ty {\n+    pub(crate) fn new_from_ast_path(\n+        db: &impl HirDatabase,\n+        module: &Module,\n+        path: ast::Path,\n+    ) -> Cancelable<Self> {\n+        let path = if let Some(p) = Path::from_ast(path) {\n+            p\n+        } else {\n+            return Ok(Ty::Unknown);\n+        };\n+        if path.is_ident() {\n+            let name = &path.segments[0];\n+            if let Some(int_ty) = primitive::IntTy::from_string(&name) {\n+                return Ok(Ty::Int(int_ty));\n+            } else if let Some(uint_ty) = primitive::UintTy::from_string(&name) {\n+                return Ok(Ty::Uint(uint_ty));\n+            } else if let Some(float_ty) = primitive::FloatTy::from_string(&name) {\n+                return Ok(Ty::Float(float_ty));\n+            }\n+        }\n+\n+        // Resolve in module (in type namespace)\n+        let resolved = if let Some(r) = module.resolve_path(db, path)?.take_types() {\n+            r\n+        } else {\n+            return Ok(Ty::Unknown);\n+        };\n+        let ty = db.type_for_def(resolved)?;\n+        Ok(ty)\n+    }\n+\n     pub(crate) fn new(\n         db: &impl HirDatabase,\n         module: &Module,\n@@ -136,31 +167,11 @@ impl Ty {\n             TupleType(_inner) => Ty::Unknown, // TODO\n             NeverType(..) => Ty::Never,\n             PathType(inner) => {\n-                let path = if let Some(p) = inner.path().and_then(Path::from_ast) {\n-                    p\n+                if let Some(path) = inner.path() {\n+                    Ty::new_from_ast_path(db, module, path)?\n                 } else {\n-                    return Ok(Ty::Unknown);\n-                };\n-                if path.is_ident() {\n-                    let name = &path.segments[0];\n-                    if let Some(int_ty) = primitive::IntTy::from_string(&name) {\n-                        return Ok(Ty::Int(int_ty));\n-                    } else if let Some(uint_ty) = primitive::UintTy::from_string(&name) {\n-                        return Ok(Ty::Uint(uint_ty));\n-                    } else if let Some(float_ty) = primitive::FloatTy::from_string(&name) {\n-                        return Ok(Ty::Float(float_ty));\n-                    }\n+                    Ty::Unknown\n                 }\n-\n-                // Resolve in module (in type namespace)\n-                let resolved =\n-                    if let Some(r) = module.resolve_path(db, path)?.take(Namespace::Types) {\n-                        r\n-                    } else {\n-                        return Ok(Ty::Unknown);\n-                    };\n-                let ty = db.type_for_def(resolved)?;\n-                ty\n             }\n             PointerType(_inner) => Ty::Unknown,     // TODO\n             ArrayType(_inner) => Ty::Unknown,       // TODO\n@@ -236,6 +247,13 @@ pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n     Ok(Ty::FnPtr(Arc::new(sig)))\n }\n \n+pub fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Cancelable<Ty> {\n+    Ok(Ty::Adt {\n+        def_id: s.def_id(),\n+        name: s.name(db)?,\n+    })\n+}\n+\n // TODO this should probably be per namespace (i.e. types vs. values), since for\n // a tuple struct `struct Foo(Bar)`, Foo has function type as a value, but\n // defines the struct type Foo when used in the type namespace. rustc has a\n@@ -249,10 +267,7 @@ pub fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n             Ok(Ty::Unknown)\n         }\n         Def::Function(f) => type_for_fn(db, f),\n-        Def::Struct(s) => Ok(Ty::Adt {\n-            def_id,\n-            name: s.name(db)?,\n-        }),\n+        Def::Struct(s) => type_for_struct(db, s),\n         Def::Enum(e) => Ok(Ty::Adt {\n             def_id,\n             name: e.name(db)?,\n@@ -330,15 +345,36 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n \n         // resolve in module\n-        let resolved = ctry!(self\n-            .module\n-            .resolve_path(self.db, path)?\n-            .take(Namespace::Values));\n+        let resolved = ctry!(self.module.resolve_path(self.db, path)?.take_values());\n         let ty = self.db.type_for_def(resolved)?;\n         // TODO we will need to add type variables for type parameters etc. here\n         Ok(Some(ty))\n     }\n \n+    fn resolve_variant(\n+        &self,\n+        path: Option<ast::Path>,\n+    ) -> Cancelable<(Ty, Option<Arc<VariantData>>)> {\n+        let path = if let Some(path) = path.and_then(Path::from_ast) {\n+            path\n+        } else {\n+            return Ok((Ty::Unknown, None));\n+        };\n+        let def_id = if let Some(def_id) = self.module.resolve_path(self.db, path)?.take_types() {\n+            def_id\n+        } else {\n+            return Ok((Ty::Unknown, None));\n+        };\n+        Ok(match def_id.resolve(self.db)? {\n+            Def::Struct(s) => {\n+                let struct_data = self.db.struct_data(def_id)?;\n+                let ty = type_for_struct(self.db, s)?;\n+                (ty, Some(struct_data.variant_data().clone()))\n+            }\n+            _ => (Ty::Unknown, None),\n+        })\n+    }\n+\n     fn infer_expr(&mut self, expr: ast::Expr) -> Cancelable<Ty> {\n         let ty = match expr {\n             ast::Expr::IfExpr(e) => {\n@@ -488,7 +524,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ast::Expr::Label(_e) => Ty::Unknown,\n             ast::Expr::ReturnExpr(e) => {\n                 if let Some(e) = e.expr() {\n-                    // TODO unify with return type\n+                    // TODO unify with / expect return type\n                     self.infer_expr(e)?;\n                 };\n                 Ty::Never\n@@ -497,7 +533,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // Can this even occur outside of a match expression?\n                 Ty::Unknown\n             }\n-            ast::Expr::StructLit(_e) => Ty::Unknown,\n+            ast::Expr::StructLit(e) => {\n+                let (ty, variant_data) = self.resolve_variant(e.path())?;\n+                if let Some(nfl) = e.named_field_list() {\n+                    for field in nfl.fields() {\n+                        if let Some(e) = field.expr() {\n+                            // TODO unify with / expect field type\n+                            self.infer_expr(e)?;\n+                        }\n+                    }\n+                }\n+                ty\n+            }\n             ast::Expr::NamedFieldList(_) | ast::Expr::NamedField(_) => {\n                 // Can this even occur outside of a struct literal?\n                 Ty::Unknown"}, {"sha": "9bb58ec850a5d077508deeb701d9efd4e6da6eab", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=6fcd38cc81bdcc9921da767872dfce65ee7d2d27", "patch": "@@ -82,7 +82,7 @@ struct C(usize);\n fn test() {\n     let c = C(1);\n     B;\n-    let a: A = A { b: B, c: C() };\n+    let a: A = A { b: B, c: C(1) };\n     a.b;\n     a.c;\n }"}, {"sha": "41357749f27fa0aefa9582a673e3c7a1f484e716", "filename": "crates/ra_hir/src/ty/tests/data/0004_struct.txt", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt?ref=6fcd38cc81bdcc9921da767872dfce65ee7d2d27", "patch": "@@ -1,10 +1,14 @@\n [86; 90) 'C(1)': [unknown]\n-[72; 153) '{     ...a.c; }': ()\n+[121; 122) 'B': [unknown]\n [86; 87) 'C': [unknown]\n+[129; 130) '1': [unknown]\n [107; 108) 'a': A\n-[114; 132) 'A { b:... C() }': [unknown]\n-[138; 141) 'a.b': [unknown]\n-[147; 150) 'a.c': [unknown]\n+[127; 128) 'C': [unknown]\n+[139; 142) 'a.b': [unknown]\n+[114; 133) 'A { b:...C(1) }': A\n+[148; 151) 'a.c': [unknown]\n+[72; 154) '{     ...a.c; }': ()\n [96; 97) 'B': [unknown]\n [88; 89) '1': [unknown]\n [82; 83) 'c': [unknown]\n+[127; 131) 'C(1)': [unknown]"}, {"sha": "334da67ef038dcc34d3188be2b31eda648fe8914", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=6fcd38cc81bdcc9921da767872dfce65ee7d2d27", "patch": "@@ -2142,7 +2142,15 @@ impl<R: TreeRoot<RaTypes>> NamedFieldNode<R> {\n }\n \n \n-impl<'a> NamedField<'a> {}\n+impl<'a> NamedField<'a> {\n+    pub fn name_ref(self) -> Option<NameRef<'a>> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // NamedFieldDef\n #[derive(Debug, Clone, Copy,)]\n@@ -2218,7 +2226,11 @@ impl<R: TreeRoot<RaTypes>> NamedFieldListNode<R> {\n }\n \n \n-impl<'a> NamedFieldList<'a> {}\n+impl<'a> NamedFieldList<'a> {\n+    pub fn fields(self) -> impl Iterator<Item = NamedField<'a>> + 'a {\n+        super::children(self)\n+    }\n+}\n \n // NeverType\n #[derive(Debug, Clone, Copy,)]\n@@ -3467,7 +3479,15 @@ impl<R: TreeRoot<RaTypes>> StructLitNode<R> {\n }\n \n \n-impl<'a> StructLit<'a> {}\n+impl<'a> StructLit<'a> {\n+    pub fn path(self) -> Option<Path<'a>> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn named_field_list(self) -> Option<NamedFieldList<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // StructPat\n #[derive(Debug, Clone, Copy,)]"}, {"sha": "0da8b8183d98f514046dc508c16dd440974e5b9c", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/6fcd38cc81bdcc9921da767872dfce65ee7d2d27/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=6fcd38cc81bdcc9921da767872dfce65ee7d2d27", "patch": "@@ -392,9 +392,9 @@ Grammar(\n             collections: [ [ \"pats\", \"Pat\" ] ]\n         ),\n         \"MatchGuard\": (),\n-        \"StructLit\": (),\n-        \"NamedFieldList\": (),\n-        \"NamedField\": (),\n+        \"StructLit\": (options: [\"Path\", \"NamedFieldList\"]),\n+        \"NamedFieldList\": (collections: [ [\"fields\", \"NamedField\"] ]),\n+        \"NamedField\": (options: [\"NameRef\", \"Expr\"]),\n         \"CallExpr\": (\n             traits: [\"ArgListOwner\"],\n             options: [ \"Expr\" ],"}]}