{"sha": "dd1ab840d279c96adf5d7778670f14a6398b595a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMWFiODQwZDI3OWM5NmFkZjVkNzc3ODY3MGYxNGE2Mzk4YjU5NWE=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-01T05:07:08Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-22T22:12:57Z"}, "message": "rustc_query_system: use more space-efficient edges representation\n\nUse single vector of edges rather than per-node vector. There is a small\nhit to instruction counts (< 0.5%), but the memory savings make up for it.", "tree": {"sha": "de9c50cc2fb99a0c5feb5189026fd85f74beacdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de9c50cc2fb99a0c5feb5189026fd85f74beacdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd1ab840d279c96adf5d7778670f14a6398b595a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd1ab840d279c96adf5d7778670f14a6398b595a", "html_url": "https://github.com/rust-lang/rust/commit/dd1ab840d279c96adf5d7778670f14a6398b595a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd1ab840d279c96adf5d7778670f14a6398b595a/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea47269f5f50cd7804141ba00811b79be1e156c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea47269f5f50cd7804141ba00811b79be1e156c6", "html_url": "https://github.com/rust-lang/rust/commit/ea47269f5f50cd7804141ba00811b79be1e156c6"}], "stats": {"total": 155, "additions": 103, "deletions": 52}, "files": [{"sha": "076dcb4fed1fc96f58a5955ec2f926bc99a3f77f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 91, "deletions": 46, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/dd1ab840d279c96adf5d7778670f14a6398b595a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1ab840d279c96adf5d7778670f14a6398b595a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=dd1ab840d279c96adf5d7778670f14a6398b595a", "patch": "@@ -15,6 +15,7 @@ use std::env;\n use std::hash::Hash;\n use std::marker::PhantomData;\n use std::mem;\n+use std::ops::Range;\n use std::sync::atomic::Ordering::Relaxed;\n \n use super::debug::EdgeFilter;\n@@ -143,42 +144,48 @@ impl<K: DepKind> DepGraph<K> {\n         let node_count = data.hybrid_indices.len();\n \n         let mut nodes = Vec::with_capacity(node_count);\n-        let mut edges = Vec::with_capacity(edge_count);\n-\n-        for (index, &hybrid_index) in data.hybrid_indices.iter_enumerated() {\n-            let src = index.index();\n+        let mut edge_list_indices = Vec::with_capacity(node_count);\n+        let mut edge_list_data = Vec::with_capacity(edge_count);\n+        edge_list_data.extend(data.unshared_edges.iter().map(|i| i.index()));\n \n+        for &hybrid_index in data.hybrid_indices.iter() {\n             match hybrid_index.into() {\n                 HybridIndex::New(new_index) => {\n-                    let new = &data.new;\n-                    nodes.push(new.nodes[new_index]);\n-                    edges.extend(new.edges[new_index].iter().map(|dst| (src, dst.index())));\n+                    nodes.push(data.new.nodes[new_index]);\n+                    let edges = &data.new.edges[new_index];\n+                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n                 }\n                 HybridIndex::Red(red_index) => {\n-                    let red = &data.red;\n-                    nodes.push(previous.index_to_node(red.node_indices[red_index]));\n-                    edges.extend(red.edges[red_index].iter().map(|dst| (src, dst.index())));\n+                    nodes.push(previous.index_to_node(data.red.node_indices[red_index]));\n+                    let edges = &data.red.edges[red_index];\n+                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n                 }\n                 HybridIndex::LightGreen(lg_index) => {\n-                    let lg = &data.light_green;\n-                    nodes.push(previous.index_to_node(lg.node_indices[lg_index]));\n-                    edges.extend(lg.edges[lg_index].iter().map(|dst| (src, dst.index())));\n+                    nodes.push(previous.index_to_node(data.light_green.node_indices[lg_index]));\n+                    let edges = &data.light_green.edges[lg_index];\n+                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n                 }\n                 HybridIndex::DarkGreen(prev_index) => {\n                     nodes.push(previous.index_to_node(prev_index));\n+\n                     let edges_iter = previous\n                         .edge_targets_from(prev_index)\n                         .iter()\n-                        .map(|&dst| (src, prev_index_to_index[dst].unwrap().index()));\n-                    edges.extend(edges_iter);\n+                        .map(|&dst| prev_index_to_index[dst].unwrap().index());\n+\n+                    let start = edge_list_data.len();\n+                    edge_list_data.extend(edges_iter);\n+                    let end = edge_list_data.len();\n+                    edge_list_indices.push((start, end));\n                 }\n             }\n         }\n \n         debug_assert_eq!(nodes.len(), node_count);\n-        debug_assert_eq!(edges.len(), edge_count);\n+        debug_assert_eq!(edge_list_indices.len(), node_count);\n+        debug_assert_eq!(edge_list_data.len(), edge_count);\n \n-        DepGraphQuery::new(&nodes[..], &edges[..])\n+        DepGraphQuery::new(&nodes[..], &edge_list_indices[..], &edge_list_data[..])\n     }\n \n     pub fn assert_ignored(&self) {\n@@ -561,11 +568,7 @@ impl<K: DepKind> DepGraph<K> {\n         let previous = &data.previous;\n         let data = data.current.data.lock();\n \n-        // Linearly scanning each collection is a bit faster than scanning\n-        // `hybrid_indices` and bouncing around the different collections.\n-        let mut edge_count = data.new.edges.iter().map(|e| e.len()).sum::<usize>()\n-            + data.red.edges.iter().map(|e| e.len()).sum::<usize>()\n-            + data.light_green.edges.iter().map(|e| e.len()).sum::<usize>();\n+        let mut edge_count = data.unshared_edges.len();\n \n         for &hybrid_index in data.hybrid_indices.iter() {\n             if let HybridIndex::DarkGreen(prev_index) = hybrid_index.into() {\n@@ -591,46 +594,44 @@ impl<K: DepKind> DepGraph<K> {\n         let mut fingerprints = IndexVec::with_capacity(node_count);\n         let mut edge_list_indices = IndexVec::with_capacity(node_count);\n         let mut edge_list_data = Vec::with_capacity(edge_count);\n-\n-        fn add_edges<'a, I: Iterator<Item = &'a DepNodeIndex>>(\n-            edge_list_indices: &mut IndexVec<SerializedDepNodeIndex, (u32, u32)>,\n-            edge_list_data: &mut Vec<SerializedDepNodeIndex>,\n-            iter: I,\n-        ) {\n-            let start = edge_list_data.len() as u32;\n-            edge_list_data.extend(iter.map(|i| SDNI::new(i.index())));\n-            let end = edge_list_data.len() as u32;\n-            edge_list_indices.push((start, end));\n-        };\n+        edge_list_data.extend(data.unshared_edges.iter().map(|i| SDNI::new(i.index())));\n \n         for &hybrid_index in data.hybrid_indices.iter() {\n             match hybrid_index.into() {\n                 HybridIndex::New(i) => {\n                     let new = &data.new;\n                     nodes.push(new.nodes[i]);\n                     fingerprints.push(new.fingerprints[i]);\n-                    add_edges(&mut edge_list_indices, &mut edge_list_data, new.edges[i].iter());\n+                    let edges = &new.edges[i];\n+                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n                 }\n                 HybridIndex::Red(i) => {\n                     let red = &data.red;\n                     nodes.push(previous.index_to_node(red.node_indices[i]));\n                     fingerprints.push(red.fingerprints[i]);\n-                    add_edges(&mut edge_list_indices, &mut edge_list_data, red.edges[i].iter());\n+                    let edges = &red.edges[i];\n+                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n                 }\n                 HybridIndex::LightGreen(i) => {\n                     let lg = &data.light_green;\n                     nodes.push(previous.index_to_node(lg.node_indices[i]));\n                     fingerprints.push(previous.fingerprint_by_index(lg.node_indices[i]));\n-                    add_edges(&mut edge_list_indices, &mut edge_list_data, lg.edges[i].iter());\n+                    let edges = &lg.edges[i];\n+                    edge_list_indices.push((edges.start.as_u32(), edges.end.as_u32()));\n                 }\n                 HybridIndex::DarkGreen(prev_index) => {\n                     nodes.push(previous.index_to_node(prev_index));\n                     fingerprints.push(previous.fingerprint_by_index(prev_index));\n+\n                     let edges_iter = previous\n                         .edge_targets_from(prev_index)\n                         .iter()\n                         .map(|&dst| prev_index_to_index[dst].as_ref().unwrap());\n-                    add_edges(&mut edge_list_indices, &mut edge_list_data, edges_iter);\n+\n+                    let start = edge_list_data.len() as u32;\n+                    edge_list_data.extend(edges_iter.map(|i| SDNI::new(i.index())));\n+                    let end = edge_list_data.len() as u32;\n+                    edge_list_indices.push((start, end));\n                 }\n             }\n         }\n@@ -1125,6 +1126,11 @@ impl From<CompressedHybridIndex> for HybridIndex {\n     }\n }\n \n+// Index type for `DepNodeData`'s edges.\n+rustc_index::newtype_index! {\n+    struct EdgeIndex { .. }\n+}\n+\n /// Data for nodes in the current graph, divided into different collections\n /// based on their presence in the previous graph, and if present, their color.\n /// We divide nodes this way because different types of nodes are able to share\n@@ -1171,6 +1177,16 @@ struct DepNodeData<K> {\n     /// Data for nodes in previous graph that have been marked light green.\n     light_green: LightGreenDepNodeData,\n \n+    // Edges for all nodes other than dark-green ones. Edges for each node\n+    // occupy a contiguous region of this collection, which a node can reference\n+    // using two indices. Storing edges this way rather than using an `EdgesVec`\n+    // for each node reduces memory consumption by a not insignificant amount\n+    // when compiling large crates. The downside is that we have to copy into\n+    // this collection the edges from the `EdgesVec`s that are built up during\n+    // query execution. But this is mostly balanced out by the more efficient\n+    // implementation of `DepGraph::serialize` enabled by this representation.\n+    unshared_edges: IndexVec<EdgeIndex, DepNodeIndex>,\n+\n     /// Mapping from `DepNodeIndex` to an index into a collection above.\n     /// Indicates which of the above collections contains a node's data.\n     ///\n@@ -1186,7 +1202,7 @@ struct DepNodeData<K> {\n /// the previous graph, so we must store all of such a node's data here.\n struct NewDepNodeData<K> {\n     nodes: IndexVec<NewDepNodeIndex, DepNode<K>>,\n-    edges: IndexVec<NewDepNodeIndex, EdgesVec>,\n+    edges: IndexVec<NewDepNodeIndex, Range<EdgeIndex>>,\n     fingerprints: IndexVec<NewDepNodeIndex, Fingerprint>,\n }\n \n@@ -1195,7 +1211,7 @@ struct NewDepNodeData<K> {\n /// fingerprint is known to be different, so we store the latter two directly.\n struct RedDepNodeData {\n     node_indices: IndexVec<RedDepNodeIndex, SerializedDepNodeIndex>,\n-    edges: IndexVec<RedDepNodeIndex, EdgesVec>,\n+    edges: IndexVec<RedDepNodeIndex, Range<EdgeIndex>>,\n     fingerprints: IndexVec<RedDepNodeIndex, Fingerprint>,\n }\n \n@@ -1205,7 +1221,7 @@ struct RedDepNodeData {\n /// graph, but the edges may be different, so we store them directly.\n struct LightGreenDepNodeData {\n     node_indices: IndexVec<LightGreenDepNodeIndex, SerializedDepNodeIndex>,\n-    edges: IndexVec<LightGreenDepNodeIndex, EdgesVec>,\n+    edges: IndexVec<LightGreenDepNodeIndex, Range<EdgeIndex>>,\n }\n \n /// `CurrentDepGraph` stores the dependency graph for the current session. It\n@@ -1294,11 +1310,27 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         // not be enough. The allocation for red and green node data doesn't\n         // include a constant, as we don't want to allocate anything for these\n         // structures during full incremental builds, where they aren't used.\n+        //\n+        // These estimates are based on the distribution of node and edge counts\n+        // seen in rustc-perf benchmarks, adjusted somewhat to account for the\n+        // fact that these benchmarks aren't perfectly representative.\n+        //\n+        // FIXME Use a collection type that doesn't copy node and edge data and\n+        // grow multiplicatively on reallocation. Without such a collection or\n+        // solution having the same effect, there is a performance hazard here\n+        // in both time and space, as growing these collections means copying a\n+        // large amount of data and doubling already large buffer capacities. A\n+        // solution for this will also mean that it's less important to get\n+        // these estimates right.\n         let new_node_count_estimate = (prev_graph_node_count * 2) / 100 + 200;\n         let red_node_count_estimate = (prev_graph_node_count * 3) / 100;\n         let light_green_node_count_estimate = (prev_graph_node_count * 25) / 100;\n         let total_node_count_estimate = prev_graph_node_count + new_node_count_estimate;\n \n+        let average_edges_per_node_estimate = 6;\n+        let unshared_edge_count_estimate = average_edges_per_node_estimate\n+            * (new_node_count_estimate + red_node_count_estimate + light_green_node_count_estimate);\n+\n         // We store a large collection of these in `prev_index_to_index` during\n         // non-full incremental builds, and want to ensure that the element size\n         // doesn't inadvertently increase.\n@@ -1320,6 +1352,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                     node_indices: IndexVec::with_capacity(light_green_node_count_estimate),\n                     edges: IndexVec::with_capacity(light_green_node_count_estimate),\n                 },\n+                unshared_edges: IndexVec::with_capacity(unshared_edge_count_estimate),\n                 hybrid_indices: IndexVec::with_capacity(total_node_count_estimate),\n             }),\n             new_node_to_index: Sharded::new(|| {\n@@ -1352,9 +1385,9 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         match self.new_node_to_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n-                let mut data = self.data.lock();\n+                let data = &mut *self.data.lock();\n                 let new_index = data.new.nodes.push(dep_node);\n-                data.new.edges.push(edges);\n+                add_edges(&mut data.unshared_edges, &mut data.new.edges, edges);\n                 data.new.fingerprints.push(fingerprint);\n                 let dep_node_index = data.hybrid_indices.push(new_index.into());\n                 entry.insert(dep_node_index);\n@@ -1377,9 +1410,9 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         match prev_index_to_index[prev_index] {\n             Some(dep_node_index) => dep_node_index,\n             None => {\n-                let mut data = self.data.lock();\n+                let data = &mut *self.data.lock();\n                 let red_index = data.red.node_indices.push(prev_index);\n-                data.red.edges.push(edges);\n+                add_edges(&mut data.unshared_edges, &mut data.red.edges, edges);\n                 data.red.fingerprints.push(fingerprint);\n                 let dep_node_index = data.hybrid_indices.push(red_index.into());\n                 prev_index_to_index[prev_index] = Some(dep_node_index);\n@@ -1401,9 +1434,9 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         match prev_index_to_index[prev_index] {\n             Some(dep_node_index) => dep_node_index,\n             None => {\n-                let mut data = self.data.lock();\n+                let data = &mut *self.data.lock();\n                 let light_green_index = data.light_green.node_indices.push(prev_index);\n-                data.light_green.edges.push(edges);\n+                add_edges(&mut data.unshared_edges, &mut data.light_green.edges, edges);\n                 let dep_node_index = data.hybrid_indices.push(light_green_index.into());\n                 prev_index_to_index[prev_index] = Some(dep_node_index);\n                 dep_node_index\n@@ -1445,6 +1478,18 @@ impl<K: DepKind> CurrentDepGraph<K> {\n     }\n }\n \n+#[inline]\n+fn add_edges<I: Idx>(\n+    edges: &mut IndexVec<EdgeIndex, DepNodeIndex>,\n+    edge_indices: &mut IndexVec<I, Range<EdgeIndex>>,\n+    new_edges: EdgesVec,\n+) {\n+    let start = edges.next_index();\n+    edges.extend(new_edges);\n+    let end = edges.next_index();\n+    edge_indices.push(start..end);\n+}\n+\n /// The capacity of the `reads` field `SmallVec`\n const TASK_DEPS_READS_CAP: usize = 8;\n type EdgesVec = SmallVec<[DepNodeIndex; TASK_DEPS_READS_CAP]>;"}, {"sha": "cc25d08cb54f43797fe4f526ed772db7b3e8c833", "filename": "compiler/rustc_query_system/src/dep_graph/query.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dd1ab840d279c96adf5d7778670f14a6398b595a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1ab840d279c96adf5d7778670f14a6398b595a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs?ref=dd1ab840d279c96adf5d7778670f14a6398b595a", "patch": "@@ -9,17 +9,23 @@ pub struct DepGraphQuery<K> {\n }\n \n impl<K: DepKind> DepGraphQuery<K> {\n-    pub fn new(nodes: &[DepNode<K>], edges: &[(usize, usize)]) -> DepGraphQuery<K> {\n-        let mut graph = Graph::with_capacity(nodes.len(), edges.len());\n+    pub fn new(\n+        nodes: &[DepNode<K>],\n+        edge_list_indices: &[(usize, usize)],\n+        edge_list_data: &[usize],\n+    ) -> DepGraphQuery<K> {\n+        let mut graph = Graph::with_capacity(nodes.len(), edge_list_data.len());\n         let mut indices = FxHashMap::default();\n         for node in nodes {\n             indices.insert(*node, graph.add_node(*node));\n         }\n \n-        for &(source, target) in edges {\n-            let source = indices[&nodes[source]];\n-            let target = indices[&nodes[target]];\n-            graph.add_edge(source, target, ());\n+        for (source, &(start, end)) in edge_list_indices.iter().enumerate() {\n+            for &target in &edge_list_data[start..end] {\n+                let source = indices[&nodes[source]];\n+                let target = indices[&nodes[target]];\n+                graph.add_edge(source, target, ());\n+            }\n         }\n \n         DepGraphQuery { graph, indices }"}]}