{"sha": "c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ZGVkOWExNGYxNmE0YjVjZTNmYWNjM2JlZGZkOTU3ZGJlNDMzZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-11T19:42:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-11T19:42:19Z"}, "message": "Auto merge of #28306 - alexcrichton:less-rt, r=brson\n\nThis commit does some refactoring to make almost all of the `std::rt` private.\r\nSpecifically, the following items are no longer part of its API:\r\n\r\n* DEFAULT_ERROR_CODE\r\n* backtrace\r\n* unwind\r\n* args\r\n* at_exit\r\n* cleanup\r\n* heap (this is just alloc::heap)\r\n* min_stack\r\n* util\r\n\r\nThe module is now tagged as `#[doc(hidden)]` as the only purpose it's serve is\r\nan entry point for the `panic!` macro via the `begin_unwind` and\r\n`begin_unwind_fmt` reexports.", "tree": {"sha": "d610a1695c2d8b14fbecaf9010a7eed0580a2eda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d610a1695c2d8b14fbecaf9010a7eed0580a2eda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "html_url": "https://github.com/rust-lang/rust/commit/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eda85fede0ed55205545f0508b834994d86414ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/eda85fede0ed55205545f0508b834994d86414ea", "html_url": "https://github.com/rust-lang/rust/commit/eda85fede0ed55205545f0508b834994d86414ea"}, {"sha": "f4be2026dfb507e5db919cc5df8fd934e05fa0b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4be2026dfb507e5db919cc5df8fd934e05fa0b8", "html_url": "https://github.com/rust-lang/rust/commit/f4be2026dfb507e5db919cc5df8fd934e05fa0b8"}], "stats": {"total": 703, "additions": 272, "deletions": 431}, "files": [{"sha": "4492e2a92fae9e95aac56b0277e9b2a3626baa48", "filename": "src/doc/nomicon/destructors.md", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Fdoc%2Fnomicon%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Fdoc%2Fnomicon%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdestructors.md?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -26,13 +26,16 @@ this is totally fine.\n For instance, a custom implementation of `Box` might write `Drop` like this:\n \n ```rust\n-#![feature(heap_api, core_intrinsics, unique)]\n+#![feature(alloc, heap_api, core_intrinsics, unique)]\n+\n+extern crate alloc;\n \n-use std::rt::heap;\n use std::ptr::Unique;\n use std::intrinsics::drop_in_place;\n use std::mem;\n \n+use alloc::heap;\n+\n struct Box<T>{ ptr: Unique<T> }\n \n impl<T> Drop for Box<T> {\n@@ -45,6 +48,7 @@ impl<T> Drop for Box<T> {\n         }\n     }\n }\n+# fn main() {}\n ```\n \n and this works fine because when Rust goes to drop the `ptr` field it just sees\n@@ -54,13 +58,16 @@ use-after-free the `ptr` because when drop exits, it becomes inacessible.\n However this wouldn't work:\n \n ```rust\n-#![feature(heap_api, core_intrinsics, unique)]\n+#![feature(alloc, heap_api, core_intrinsics, unique)]\n+\n+extern crate alloc;\n \n-use std::rt::heap;\n use std::ptr::Unique;\n use std::intrinsics::drop_in_place;\n use std::mem;\n \n+use alloc::heap;\n+\n struct Box<T>{ ptr: Unique<T> }\n \n impl<T> Drop for Box<T> {\n@@ -87,6 +94,7 @@ impl<T> Drop for SuperBox<T> {\n         }\n     }\n }\n+# fn main() {}\n ```\n \n After we deallocate the `box`'s ptr in SuperBox's destructor, Rust will\n@@ -129,13 +137,16 @@ The classic safe solution to overriding recursive drop and allowing moving out\n of Self during `drop` is to use an Option:\n \n ```rust\n-#![feature(heap_api, core_intrinsics, unique)]\n+#![feature(alloc, heap_api, core_intrinsics, unique)]\n+\n+extern crate alloc;\n \n-use std::rt::heap;\n use std::ptr::Unique;\n use std::intrinsics::drop_in_place;\n use std::mem;\n \n+use alloc::heap;\n+\n struct Box<T>{ ptr: Unique<T> }\n \n impl<T> Drop for Box<T> {\n@@ -165,6 +176,7 @@ impl<T> Drop for SuperBox<T> {\n         }\n     }\n }\n+# fn main() {}\n ```\n \n However this has fairly odd semantics: you're saying that a field that *should*"}, {"sha": "c2ae1a4eb6d26ac1e8ad82de7e7e9aa2c0947e68", "filename": "src/doc/nomicon/vec-alloc.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Fdoc%2Fnomicon%2Fvec-alloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Fdoc%2Fnomicon%2Fvec-alloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fvec-alloc.md?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -9,7 +9,7 @@ This is perfectly fine because we already have `cap == 0` as our sentinel for no\n allocation. We don't even need to handle it specially in almost any code because\n we usually need to check if `cap > len` or `len > 0` anyway. The traditional\n Rust value to put here is `0x01`. The standard library actually exposes this\n-as `std::rt::heap::EMPTY`. There are quite a few places where we'll\n+as `alloc::heap::EMPTY`. There are quite a few places where we'll\n want to use `heap::EMPTY` because there's no real allocation to talk about but\n `null` would make the compiler do bad things.\n \n@@ -20,11 +20,12 @@ the `heap` API anyway, so let's just get that dependency over with.\n So:\n \n ```rust,ignore\n-#![feature(heap_api)]\n+#![feature(alloc, heap_api)]\n \n-use std::rt::heap::EMPTY;\n use std::mem;\n \n+use alloc::heap::EMPTY;\n+\n impl<T> Vec<T> {\n     fn new() -> Self {\n         assert!(mem::size_of::<T>() != 0, \"We're not ready to handle ZSTs\");"}, {"sha": "52c22f65076f9def84f83bc2e57955e1bf49ea19", "filename": "src/doc/nomicon/vec-final.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Fdoc%2Fnomicon%2Fvec-final.md", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Fdoc%2Fnomicon%2Fvec-final.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fvec-final.md?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -2,17 +2,16 @@\n \n ```rust\n #![feature(unique)]\n-#![feature(heap_api)]\n+#![feature(alloc, heap_api)]\n+\n+extern crate alloc;\n \n use std::ptr::{Unique, self};\n-use std::rt::heap;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n use std::marker::PhantomData;\n \n-\n-\n-\n+use alloc::heap;\n \n struct RawVec<T> {\n     ptr: Unique<T>,"}, {"sha": "57e82720e8beaf3fc0a4a9c645a2b79d1a9c47c5", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -49,7 +49,8 @@ use std::marker;\n use std::mem;\n use std::ptr;\n use std::rc::Rc;\n-use std::rt::heap::{allocate, deallocate};\n+\n+use alloc::heap::{allocate, deallocate};\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array"}, {"sha": "d59e40fb1493c89827ea8052d472288137068fbd", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -174,7 +174,6 @@\n #![feature(box_syntax)]\n #![feature(const_fn)]\n #![feature(iter_cmp)]\n-#![feature(rt)]\n #![feature(staged_api)]\n #![feature(static_mutex)]\n \n@@ -185,7 +184,6 @@ use std::io::prelude::*;\n use std::mem;\n use std::env;\n use std::ptr;\n-use std::rt;\n use std::slice;\n use std::sync::{Once, StaticMutex};\n \n@@ -292,7 +290,6 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n         let _g = LOCK.lock();\n         match FILTER as usize {\n             0 => {}\n-            1 => panic!(\"cannot log after main thread has exited\"),\n             n => {\n                 let filter = mem::transmute::<_, &String>(n);\n                 if !args.to_string().contains(filter) {\n@@ -385,9 +382,6 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     let _g = LOCK.lock();\n     unsafe {\n         assert!(DIRECTIVES as usize != 0);\n-        assert!(DIRECTIVES as usize != 1,\n-                \"cannot log after the main thread has exited\");\n-\n         enabled(level, module, (*DIRECTIVES).iter())\n     }\n }\n@@ -442,19 +436,6 @@ fn init() {\n \n         assert!(DIRECTIVES.is_null());\n         DIRECTIVES = Box::into_raw(box directives);\n-\n-        // Schedule the cleanup for the globals for when the runtime exits.\n-        let _ = rt::at_exit(move || {\n-            let _g = LOCK.lock();\n-            assert!(!DIRECTIVES.is_null());\n-            let _directives = Box::from_raw(DIRECTIVES);\n-            DIRECTIVES = 1 as *mut _;\n-\n-            if !FILTER.is_null() {\n-                let _filter = Box::from_raw(FILTER);\n-                FILTER = 1 as *mut _;\n-            }\n-        });\n     }\n }\n "}, {"sha": "f8bd791f6819c16cdc14f5e3ffce7e3a029c36f7", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -8,23 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::BucketState::*;\n+use alloc::heap::{allocate, deallocate, EMPTY};\n \n-use clone::Clone;\n use cmp;\n use hash::{Hash, Hasher};\n-use iter::{Iterator, ExactSizeIterator};\n-use marker::{Copy, Send, Sync, Sized, self};\n+use marker;\n use mem::{align_of, size_of};\n use mem;\n use num::wrapping::OverflowingOps;\n-use ops::{Deref, DerefMut, Drop};\n-use option::Option;\n-use option::Option::{Some, None};\n+use ops::{Deref, DerefMut};\n use ptr::{self, Unique};\n-use rt::heap::{allocate, deallocate, EMPTY};\n use collections::hash_state::HashState;\n \n+use self::BucketState::*;\n+\n const EMPTY_BUCKET: u64 = 0;\n \n /// The raw hashtable, providing safe-ish access to the unzipped and highly"}, {"sha": "65667f24dda6c0077ba0ee7ab6a9621a236aed12", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -12,8 +12,8 @@ use prelude::v1::*;\n \n use cell::Cell;\n use ptr;\n-use rt;\n use sync::{StaticMutex, Arc};\n+use sys_common;\n \n pub struct Lazy<T> {\n     lock: StaticMutex,\n@@ -51,7 +51,7 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n         // `Arc` allocation in our own internal box (it will get deallocated by\n         // the at exit handler). Otherwise we just return the freshly allocated\n         // `Arc`.\n-        let registered = rt::at_exit(move || {\n+        let registered = sys_common::at_exit(move || {\n             let g = self.lock.lock();\n             let ptr = self.ptr.get();\n             self.ptr.set(1 as *mut _);"}, {"sha": "9715939d644aa5b61ff258c9c8edf0623c9b82f2", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -13,9 +13,10 @@ use io::prelude::*;\n \n use any::Any;\n use cell::RefCell;\n-use rt::{backtrace, unwind};\n use sys::stdio::Stderr;\n+use sys_common::backtrace;\n use sys_common::thread_info;\n+use sys_common::unwind;\n \n thread_local! {\n     pub static LOCAL_STDERR: RefCell<Option<Box<Write + Send>>> = {"}, {"sha": "5f5d5a69003f29e1197dcf46f7953fd127dfe764", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -582,7 +582,7 @@ impl Child {\n /// to run.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn exit(code: i32) -> ! {\n-    ::rt::cleanup();\n+    ::sys_common::cleanup();\n     ::sys::os::exit(code)\n }\n "}, {"sha": "8be0c6f3b3d99e3d389eeeba3855193db0ea9614", "filename": "src/libstd/rt.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Runtime services\n+//!\n+//! The `rt` module provides a narrow set of runtime services,\n+//! including the global heap (exported in `heap`) and unwinding and\n+//! backtrace support. The APIs in this module are highly unstable,\n+//! and should be considered as private implementation details for the\n+//! time being.\n+\n+#![unstable(feature = \"rt\",\n+            reason = \"this public module should not exist and is highly likely \\\n+                      to disappear\",\n+            issue = \"0\")]\n+#![doc(hidden)]\n+\n+use borrow::ToOwned;\n+use mem;\n+use sys;\n+use sys_common::thread_info::{self, NewThread};\n+use sys_common;\n+use thread::{self, Thread};\n+\n+// Reexport some of our utilities which are expected by other crates.\n+pub use sys_common::unwind::{begin_unwind, begin_unwind_fmt};\n+\n+#[cfg(not(test))]\n+#[lang = \"start\"]\n+fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n+    sys::init();\n+\n+    let failed = unsafe {\n+        let main_guard = sys::thread::guard::init();\n+        sys::stack_overflow::init();\n+\n+        // Next, set up the current Thread with the guard information we just\n+        // created. Note that this isn't necessary in general for new threads,\n+        // but we just do this to name the main thread and to give it correct\n+        // info about the stack bounds.\n+        let thread: Thread = NewThread::new(Some(\"<main>\".to_owned()));\n+        thread_info::set(main_guard, thread);\n+\n+        // Store our args if necessary in a squirreled away location\n+        sys_common::args::init(argc, argv);\n+\n+        // Let's run some code!\n+        let res = thread::catch_panic(mem::transmute::<_, fn()>(main));\n+        sys_common::cleanup();\n+        res.is_err()\n+    };\n+\n+    if failed {\n+        101\n+    } else {\n+        0\n+    }\n+}"}, {"sha": "9e7ed89bae1b7d1c03439da5cc54305de4b24339", "filename": "src/libstd/rt/backtrace.rs", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/eda85fede0ed55205545f0508b834994d86414ea/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda85fede0ed55205545f0508b834994d86414ea/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=eda85fede0ed55205545f0508b834994d86414ea", "patch": "@@ -1,76 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Simple backtrace functionality (to print on panic)\n-\n-#![allow(non_camel_case_types)]\n-\n-use env;\n-use sync::atomic::{self, Ordering};\n-\n-pub use sys::backtrace::write;\n-\n-// For now logging is turned off by default, and this function checks to see\n-// whether the magical environment variable is present to see if it's turned on.\n-pub fn log_enabled() -> bool {\n-    static ENABLED: atomic::AtomicIsize = atomic::AtomicIsize::new(0);\n-    match ENABLED.load(Ordering::SeqCst) {\n-        1 => return false,\n-        2 => return true,\n-        _ => {}\n-    }\n-\n-    let val = match env::var_os(\"RUST_BACKTRACE\") {\n-        Some(..) => 2,\n-        None => 1,\n-    };\n-    ENABLED.store(val, Ordering::SeqCst);\n-    val == 2\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-    use sys_common;\n-    macro_rules! t { ($a:expr, $b:expr) => ({\n-        let mut m = Vec::new();\n-        sys_common::backtrace::demangle(&mut m, $a).unwrap();\n-        assert_eq!(String::from_utf8(m).unwrap(), $b);\n-    }) }\n-\n-    #[test]\n-    fn demangle() {\n-        t!(\"test\", \"test\");\n-        t!(\"_ZN4testE\", \"test\");\n-        t!(\"_ZN4test\", \"_ZN4test\");\n-        t!(\"_ZN4test1a2bcE\", \"test::a::bc\");\n-    }\n-\n-    #[test]\n-    fn demangle_dollars() {\n-        t!(\"_ZN4$RP$E\", \")\");\n-        t!(\"_ZN8$RF$testE\", \"&test\");\n-        t!(\"_ZN8$BP$test4foobE\", \"*test::foob\");\n-        t!(\"_ZN9$u20$test4foobE\", \" test::foob\");\n-    }\n-\n-    #[test]\n-    fn demangle_many_dollars() {\n-        t!(\"_ZN13test$u20$test4foobE\", \"test test::foob\");\n-        t!(\"_ZN12test$BP$test4foobE\", \"test*test::foob\");\n-    }\n-\n-    #[test]\n-    fn demangle_windows() {\n-        t!(\"ZN4testE\", \"test\");\n-        t!(\"ZN13test$u20$test4foobE\", \"test test::foob\");\n-        t!(\"ZN12test$RF$test4foobE\", \"test&test::foob\");\n-    }\n-}"}, {"sha": "414ccc911afebc4693220ca8c7d03b4ea1bd27ba", "filename": "src/libstd/rt/macros.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/eda85fede0ed55205545f0508b834994d86414ea/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda85fede0ed55205545f0508b834994d86414ea/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=eda85fede0ed55205545f0508b834994d86414ea", "patch": "@@ -1,51 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Macros used by the runtime.\n-//!\n-//! These macros call functions which are only accessible in the `rt` module, so\n-//! they aren't defined anywhere outside of the `rt` module.\n-\n-macro_rules! rterrln {\n-    ($fmt:expr) => ( {\n-        ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\")))\n-    } );\n-    ($fmt:expr, $($arg:expr),*) => ( {\n-        ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\"), $($arg),*))\n-    } )\n-}\n-\n-// Some basic logging. Enabled by passing `--cfg rtdebug` to the libstd build.\n-macro_rules! rtdebug {\n-    ($arg:expr) => ( {\n-        if cfg!(rtdebug) {\n-            rterrln!($arg)\n-        }\n-    } );\n-    ($str:expr, $($arg:expr),*) => ( {\n-        if cfg!(rtdebug) {\n-            rterrln!($str, $($arg),*)\n-        }\n-    })\n-}\n-\n-macro_rules! rtassert {\n-    ( $arg:expr ) => ( {\n-        if ::rt::util::ENFORCE_SANITY {\n-            if !$arg {\n-                rtabort!(\" assertion failed: {}\", stringify!($arg));\n-            }\n-        }\n-    } )\n-}\n-\n-macro_rules! rtabort {\n-    ($($arg:tt)*) => (::rt::util::abort(format_args!($($arg)*)))\n-}"}, {"sha": "95cba132201332dae0cebe76937b9f1da1b43aef", "filename": "src/libstd/rt/mod.rs", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/eda85fede0ed55205545f0508b834994d86414ea/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda85fede0ed55205545f0508b834994d86414ea/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=eda85fede0ed55205545f0508b834994d86414ea", "patch": "@@ -1,135 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Runtime services\n-//!\n-//! The `rt` module provides a narrow set of runtime services,\n-//! including the global heap (exported in `heap`) and unwinding and\n-//! backtrace support. The APIs in this module are highly unstable,\n-//! and should be considered as private implementation details for the\n-//! time being.\n-\n-#![unstable(feature = \"rt\",\n-            reason = \"this public module should not exist and is highly likely \\\n-                      to disappear\",\n-            issue = \"0\")]\n-#![allow(missing_docs)]\n-\n-use prelude::v1::*;\n-use sync::Once;\n-use sys;\n-use thread;\n-\n-// Reexport some of our utilities which are expected by other crates.\n-pub use self::util::min_stack;\n-pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n-\n-// Reexport some functionality from liballoc.\n-pub use alloc::heap;\n-\n-// Simple backtrace functionality (to print on panic)\n-pub mod backtrace;\n-\n-// Internals\n-#[macro_use]\n-mod macros;\n-\n-// These should be refactored/moved/made private over time\n-pub mod util;\n-pub mod unwind;\n-pub mod args;\n-\n-mod at_exit_imp;\n-mod libunwind;\n-\n-mod dwarf;\n-\n-/// The default error code of the rust runtime if the main thread panics instead\n-/// of exiting cleanly.\n-pub const DEFAULT_ERROR_CODE: isize = 101;\n-\n-#[cfg(not(test))]\n-#[lang = \"start\"]\n-fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n-    use prelude::v1::*;\n-\n-    use mem;\n-    use rt;\n-    use sys_common::thread_info::{self, NewThread};\n-    use thread::Thread;\n-\n-    let failed = unsafe {\n-        let main_guard = sys::thread::guard::init();\n-        sys::stack_overflow::init();\n-\n-        // Next, set up the current Thread with the guard information we just\n-        // created. Note that this isn't necessary in general for new threads,\n-        // but we just do this to name the main thread and to give it correct\n-        // info about the stack bounds.\n-        let thread: Thread = NewThread::new(Some(\"<main>\".to_owned()));\n-        thread_info::set(main_guard, thread);\n-\n-        // By default, some platforms will send a *signal* when a EPIPE error\n-        // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n-        // handler, causing it to kill the program, which isn't exactly what we\n-        // want!\n-        //\n-        // Hence, we set SIGPIPE to ignore when the program starts up in order\n-        // to prevent this problem.\n-        #[cfg(windows)] fn ignore_sigpipe() {}\n-        #[cfg(unix)] fn ignore_sigpipe() {\n-            use libc;\n-            use libc::funcs::posix01::signal::signal;\n-            unsafe {\n-                assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != !0);\n-            }\n-        }\n-        ignore_sigpipe();\n-\n-        // Store our args if necessary in a squirreled away location\n-        args::init(argc, argv);\n-\n-        // And finally, let's run some code!\n-        let res = thread::catch_panic(mem::transmute::<_, fn()>(main));\n-        cleanup();\n-        res.is_err()\n-    };\n-\n-    // If the exit code wasn't set, then the try block must have panicked.\n-    if failed {\n-        rt::DEFAULT_ERROR_CODE\n-    } else {\n-        0\n-    }\n-}\n-\n-/// Enqueues a procedure to run when the main thread exits.\n-///\n-/// Currently these closures are only run once the main *Rust* thread exits.\n-/// Once the `at_exit` handlers begin running, more may be enqueued, but not\n-/// infinitely so. Eventually a handler registration will be forced to fail.\n-///\n-/// Returns `Ok` if the handler was successfully registered, meaning that the\n-/// closure will be run once the main thread exits. Returns `Err` to indicate\n-/// that the closure could not be registered, meaning that it is not scheduled\n-/// to be run.\n-pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n-    if at_exit_imp::push(Box::new(f)) {Ok(())} else {Err(())}\n-}\n-\n-/// One-time runtime cleanup.\n-pub fn cleanup() {\n-    static CLEANUP: Once = Once::new();\n-    CLEANUP.call_once(|| unsafe {\n-        args::cleanup();\n-        sys::stack_overflow::cleanup();\n-        at_exit_imp::cleanup();\n-    });\n-}"}, {"sha": "4cfddb036e9c2e44b1094720d4f244aba361d646", "filename": "src/libstd/sys/common/args.rs", "status": "renamed", "additions": 12, "deletions": 73, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -19,6 +19,8 @@\n //!\n //! FIXME #7756: Would be nice for this to not exist.\n \n+#![allow(dead_code)] // different code on OSX/linux/etc\n+\n use vec::Vec;\n \n /// One-time global initialization.\n@@ -27,14 +29,6 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv)\n /// One-time global cleanup.\n pub unsafe fn cleanup() { imp::cleanup() }\n \n-/// Take the global arguments from global storage.\n-pub fn take() -> Option<Vec<Vec<u8>>> { imp::take() }\n-\n-/// Give the global arguments to global storage.\n-///\n-/// It is an error if the arguments already exist.\n-pub fn put(args: Vec<Vec<u8>>) { imp::put(args) }\n-\n /// Make a clone of the global arguments.\n pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n \n@@ -48,7 +42,7 @@ pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n mod imp {\n     use prelude::v1::*;\n \n-    use libc;\n+    use libc::c_char;\n     use mem;\n     use ffi::CStr;\n \n@@ -58,80 +52,33 @@ mod imp {\n     static LOCK: StaticMutex = StaticMutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-        let args = load_argc_and_argv(argc, argv);\n-        put(args);\n-    }\n+        let args = (0..argc).map(|i| {\n+            CStr::from_ptr(*argv.offset(i) as *const c_char).to_bytes().to_vec()\n+        }).collect();\n \n-    pub unsafe fn cleanup() {\n-        take();\n-    }\n-\n-    pub fn take() -> Option<Vec<Vec<u8>>> {\n         let _guard = LOCK.lock();\n-        unsafe {\n-            let ptr = get_global_ptr();\n-            let val = mem::replace(&mut *ptr, None);\n-            val.as_ref().map(|s: &Box<Vec<Vec<u8>>>| (**s).clone())\n-        }\n+        let ptr = get_global_ptr();\n+        assert!((*ptr).is_none());\n+        (*ptr) = Some(box args);\n     }\n \n-    pub fn put(args: Vec<Vec<u8>>) {\n+    pub unsafe fn cleanup() {\n         let _guard = LOCK.lock();\n-        unsafe {\n-            let ptr = get_global_ptr();\n-            rtassert!((*ptr).is_none());\n-            (*ptr) = Some(box args.clone());\n-        }\n+        *get_global_ptr() = None;\n     }\n \n     pub fn clone() -> Option<Vec<Vec<u8>>> {\n         let _guard = LOCK.lock();\n         unsafe {\n             let ptr = get_global_ptr();\n-            (*ptr).as_ref().map(|s: &Box<Vec<Vec<u8>>>| (**s).clone())\n+            (*ptr).as_ref().map(|s| (**s).clone())\n         }\n     }\n \n     fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n         unsafe { mem::transmute(&GLOBAL_ARGS_PTR) }\n     }\n \n-    unsafe fn load_argc_and_argv(argc: isize,\n-                                 argv: *const *const u8) -> Vec<Vec<u8>> {\n-        let argv = argv as *const *const libc::c_char;\n-        (0..argc).map(|i| {\n-            CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec()\n-        }).collect()\n-    }\n-\n-    #[cfg(test)]\n-    mod tests {\n-        use prelude::v1::*;\n-\n-        use super::*;\n-\n-        #[test]\n-        fn smoke_test() {\n-            // Preserve the actual global state.\n-            let saved_value = take();\n-\n-            let expected = vec![\n-                b\"happy\".to_vec(),\n-                b\"today?\".to_vec(),\n-            ];\n-\n-            put(expected.clone());\n-            assert!(clone() == Some(expected.clone()));\n-            assert!(take() == Some(expected.clone()));\n-            assert!(take() == None);\n-\n-            // Restore the actual global state.\n-            match saved_value {\n-                Some(ref args) => put(args.clone()),\n-                None => ()\n-            }\n-        }\n-    }\n }\n \n #[cfg(any(target_os = \"macos\",\n@@ -146,14 +93,6 @@ mod imp {\n     pub fn cleanup() {\n     }\n \n-    pub fn take() -> Option<Vec<Vec<u8>>> {\n-        panic!()\n-    }\n-\n-    pub fn put(_args: Vec<Vec<u8>>) {\n-        panic!()\n-    }\n-\n     pub fn clone() -> Option<Vec<Vec<u8>>> {\n         panic!()\n     }", "previous_filename": "src/libstd/rt/args.rs"}, {"sha": "b2683750d67e2d8c4481103e45ecc2e04bbf0449", "filename": "src/libstd/sys/common/at_exit_imp.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fat_exit_imp.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -54,7 +54,7 @@ pub fn cleanup() {\n             LOCK.unlock();\n \n             // make sure we're not recursively cleaning up\n-            rtassert!(queue as usize != 1);\n+            assert!(queue as usize != 1);\n \n             // If we never called init, not need to cleanup!\n             if queue as usize != 0 {", "previous_filename": "src/libstd/rt/at_exit_imp.rs"}, {"sha": "e7bda9a7ba2db161426144cf0517f25cc32d38dc", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -8,17 +8,38 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use io;\n+use env;\n use io::prelude::*;\n-use str;\n+use io;\n use libc;\n+use str;\n+use sync::atomic::{self, Ordering};\n+\n+pub use sys::backtrace::write;\n \n #[cfg(target_pointer_width = \"64\")]\n pub const HEX_WIDTH: usize = 18;\n \n #[cfg(target_pointer_width = \"32\")]\n pub const HEX_WIDTH: usize = 10;\n \n+// For now logging is turned off by default, and this function checks to see\n+// whether the magical environment variable is present to see if it's turned on.\n+pub fn log_enabled() -> bool {\n+    static ENABLED: atomic::AtomicIsize = atomic::AtomicIsize::new(0);\n+    match ENABLED.load(Ordering::SeqCst) {\n+        1 => return false,\n+        2 => return true,\n+        _ => {}\n+    }\n+\n+    let val = match env::var_os(\"RUST_BACKTRACE\") {\n+        Some(..) => 2,\n+        None => 1,\n+    };\n+    ENABLED.store(val, Ordering::SeqCst);\n+    val == 2\n+}\n \n // These output functions should now be used everywhere to ensure consistency.\n pub fn output(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n@@ -163,3 +184,43 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n \n     Ok(())\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use sys_common;\n+    macro_rules! t { ($a:expr, $b:expr) => ({\n+        let mut m = Vec::new();\n+        sys_common::backtrace::demangle(&mut m, $a).unwrap();\n+        assert_eq!(String::from_utf8(m).unwrap(), $b);\n+    }) }\n+\n+    #[test]\n+    fn demangle() {\n+        t!(\"test\", \"test\");\n+        t!(\"_ZN4testE\", \"test\");\n+        t!(\"_ZN4test\", \"_ZN4test\");\n+        t!(\"_ZN4test1a2bcE\", \"test::a::bc\");\n+    }\n+\n+    #[test]\n+    fn demangle_dollars() {\n+        t!(\"_ZN4$RP$E\", \")\");\n+        t!(\"_ZN8$RF$testE\", \"&test\");\n+        t!(\"_ZN8$BP$test4foobE\", \"*test::foob\");\n+        t!(\"_ZN9$u20$test4foobE\", \" test::foob\");\n+    }\n+\n+    #[test]\n+    fn demangle_many_dollars() {\n+        t!(\"_ZN13test$u20$test4foobE\", \"test test::foob\");\n+        t!(\"_ZN12test$BP$test4foobE\", \"test*test::foob\");\n+    }\n+\n+    #[test]\n+    fn demangle_windows() {\n+        t!(\"ZN4testE\", \"test\");\n+        t!(\"ZN13test$u20$test4foobE\", \"test test::foob\");\n+        t!(\"ZN12test$RF$test4foobE\", \"test&test::foob\");\n+    }\n+}"}, {"sha": "319be245bde98f6451f570388cbf6855e54704e0", "filename": "src/libstd/sys/common/dwarf/eh.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fdwarf%2Feh.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -22,7 +22,7 @@\n #![allow(unused)]\n \n use prelude::v1::*;\n-use rt::dwarf::DwarfReader;\n+use sys_common::dwarf::DwarfReader;\n use core::mem;\n \n pub const DW_EH_PE_omit     : u8 = 0xFF;", "previous_filename": "src/libstd/rt/dwarf/eh.rs"}, {"sha": "822826bcc837f08f67117d86cce4d8a77de0a63e", "filename": "src/libstd/sys/common/dwarf/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fdwarf%2Fmod.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "previous_filename": "src/libstd/rt/dwarf/mod.rs"}, {"sha": "fde612014e9921f3b3f32b807d172b76894ca12d", "filename": "src/libstd/sys/common/libunwind.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Flibunwind.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "previous_filename": "src/libstd/rt/libunwind.rs"}, {"sha": "44c55d1e2c45ffcdd019cb363853775889d7dc4a", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -10,17 +10,39 @@\n \n #![allow(missing_docs)]\n \n+use boxed::Box;\n+use sync::Once;\n+use sys;\n+\n+macro_rules! rtabort {\n+    ($($t:tt)*) => (::sys_common::util::abort(format_args!($($t)*)))\n+}\n+\n+macro_rules! rtassert {\n+    ($e:expr) => ({\n+        if !$e {\n+            rtabort!(concat!(\"assertion failed: \", stringify!($e)))\n+        }\n+    })\n+}\n+\n+pub mod args;\n+pub mod at_exit_imp;\n pub mod backtrace;\n pub mod condvar;\n+pub mod dwarf;\n+pub mod io;\n+pub mod libunwind;\n pub mod mutex;\n pub mod net;\n-pub mod io;\n pub mod poison;\n pub mod remutex;\n pub mod rwlock;\n pub mod thread;\n pub mod thread_info;\n pub mod thread_local;\n+pub mod unwind;\n+pub mod util;\n pub mod wtf8;\n \n #[cfg(any(all(unix, not(any(target_os = \"macos\", target_os = \"ios\"))),\n@@ -52,3 +74,27 @@ pub trait IntoInner<Inner> {\n pub trait FromInner<Inner> {\n     fn from_inner(inner: Inner) -> Self;\n }\n+\n+/// Enqueues a procedure to run when the main thread exits.\n+///\n+/// Currently these closures are only run once the main *Rust* thread exits.\n+/// Once the `at_exit` handlers begin running, more may be enqueued, but not\n+/// infinitely so. Eventually a handler registration will be forced to fail.\n+///\n+/// Returns `Ok` if the handler was successfully registered, meaning that the\n+/// closure will be run once the main thread exits. Returns `Err` to indicate\n+/// that the closure could not be registered, meaning that it is not scheduled\n+/// to be run.\n+pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n+    if at_exit_imp::push(Box::new(f)) {Ok(())} else {Err(())}\n+}\n+\n+/// One-time runtime cleanup.\n+pub fn cleanup() {\n+    static CLEANUP: Once = Once::new();\n+    CLEANUP.call_once(|| unsafe {\n+        args::cleanup();\n+        sys::stack_overflow::cleanup();\n+        at_exit_imp::cleanup();\n+    });\n+}"}, {"sha": "361cef08c11a55ec6e25bd2413810cc2686795ac", "filename": "src/libstd/sys/common/unwind/gcc.rs", "status": "renamed", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -13,7 +13,7 @@\n use prelude::v1::*;\n \n use any::Any;\n-use rt::libunwind as uw;\n+use sys_common::libunwind as uw;\n \n struct Exception {\n     uwe: uw::_Unwind_Exception,\n@@ -35,7 +35,6 @@ pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n \n     extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n                                 exception: *mut uw::_Unwind_Exception) {\n-        rtdebug!(\"exception_cleanup()\");\n         unsafe {\n             let _: Box<Exception> = Box::from_raw(exception as *mut Exception);\n         }\n@@ -44,7 +43,6 @@ pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n     let my_ep = ptr as *mut Exception;\n-    rtdebug!(\"caught {}\", (*my_ep).uwe.exception_class);\n     let cause = (*my_ep).cause.take();\n     uw::_Unwind_DeleteException(ptr as *mut _);\n     cause.unwrap()\n@@ -80,7 +78,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n           not(all(windows, target_arch = \"x86_64\")),\n           not(test)))]\n pub mod eabi {\n-    use rt::libunwind as uw;\n+    use sys_common::libunwind as uw;\n     use libc::c_int;\n \n     extern {\n@@ -136,7 +134,7 @@ pub mod eabi {\n \n #[cfg(all(target_os = \"ios\", target_arch = \"arm\", not(test)))]\n pub mod eabi {\n-    use rt::libunwind as uw;\n+    use sys_common::libunwind as uw;\n     use libc::c_int;\n \n     extern {\n@@ -191,7 +189,7 @@ pub mod eabi {\n // but otherwise works the same.\n #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(test)))]\n pub mod eabi {\n-    use rt::libunwind as uw;\n+    use sys_common::libunwind as uw;\n     use libc::c_int;\n \n     extern {", "previous_filename": "src/libstd/rt/unwind/gcc.rs"}, {"sha": "ff93d0526b7efaea749dfbd756adf3f69d7c8ab8", "filename": "src/libstd/sys/common/unwind/mod.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -184,7 +184,6 @@ pub fn panicking() -> bool {\n #[no_mangle]\n #[allow(private_no_mangle_fns)]\n fn rust_panic(cause: Box<Any + Send + 'static>) -> ! {\n-    rtdebug!(\"begin_unwind()\");\n     unsafe {\n         imp::panic(cause)\n     }\n@@ -288,7 +287,8 @@ fn begin_unwind_inner(msg: Box<Any + Send>,\n         // have limited options. Currently our preference is to\n         // just abort. In the future we may consider resuming\n         // unwinding or otherwise exiting the thread cleanly.\n-        rterrln!(\"thread panicked while panicking. aborting.\");\n+        super::util::dumb_print(format_args!(\"thread panicked while panicking. \\\n+                                              aborting.\"));\n         unsafe { intrinsics::abort() }\n     }\n     PANICKING.with(|s| s.set(true));", "previous_filename": "src/libstd/rt/unwind/mod.rs"}, {"sha": "a201e406a23ead19324a66bf5a6c6221a6035080", "filename": "src/libstd/sys/common/unwind/seh.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -135,10 +135,11 @@ fn rust_eh_personality() {\n // This function just takes a look at the current EXCEPTION_RECORD being thrown\n // to ensure that it's code is RUST_PANIC, which was set by the call to\n // `RaiseException` above in the `panic` function.\n-#[no_mangle]\n #[lang = \"msvc_try_filter\"]\n-pub extern fn __rust_try_filter(eh_ptrs: *mut EXCEPTION_POINTERS,\n-                                _rbp: *mut u8) -> i32 {\n+#[linkage = \"external\"]\n+#[allow(private_no_mangle_fns)]\n+extern fn __rust_try_filter(eh_ptrs: *mut EXCEPTION_POINTERS,\n+                            _rbp: *mut u8) -> i32 {\n     unsafe {\n         ((*(*eh_ptrs).ExceptionRecord).ExceptionCode == RUST_PANIC) as i32\n     }", "previous_filename": "src/libstd/rt/unwind/seh.rs"}, {"sha": "4d23794de244525ddb4b05bf969534858ad15f60", "filename": "src/libstd/sys/common/unwind/seh64_gnu.rs", "status": "renamed", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -18,7 +18,7 @@ use prelude::v1::*;\n \n use any::Any;\n use self::EXCEPTION_DISPOSITION::*;\n-use rt::dwarf::eh;\n+use sys_common::dwarf::eh;\n use core::mem;\n use core::ptr;\n use libc::{c_void, c_ulonglong, DWORD, LPVOID};\n@@ -114,7 +114,6 @@ struct PanicData {\n pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n     let panic_ctx = Box::new(PanicData { data: data });\n     let params = [Box::into_raw(panic_ctx) as ULONG_PTR];\n-    rtdebug!(\"panic: ctx={:X}\", params[0]);\n     RaiseException(RUST_PANIC,\n                    EXCEPTION_NONCONTINUABLE,\n                    params.len() as DWORD,\n@@ -123,7 +122,6 @@ pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n }\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n-    rtdebug!(\"cleanup: ctx={:X}\", ptr as usize);\n     let panic_ctx = Box::from_raw(ptr as *mut PanicData);\n     return panic_ctx.data;\n }\n@@ -174,15 +172,10 @@ unsafe extern fn rust_eh_personality(\n {\n     let er = &*exceptionRecord;\n     let dc = &*dispatcherContext;\n-    rtdebug!(\"rust_eh_personality: code={:X}, flags={:X}, frame={:X}, ip={:X}\",\n-        er.ExceptionCode, er.ExceptionFlags,\n-        establisherFrame as usize, dc.ControlPc as usize);\n \n     if er.ExceptionFlags & EXCEPTION_UNWIND == 0 { // we are in the dispatch phase\n         if er.ExceptionCode == RUST_PANIC {\n             if let Some(lpad) = find_landing_pad(dc) {\n-                rtdebug!(\"unwinding to landing pad {:X}\", lpad);\n-\n                 RtlUnwindEx(establisherFrame,\n                             lpad as LPVOID,\n                             exceptionRecord,\n@@ -206,7 +199,6 @@ unsafe extern fn rust_eh_personality(\n #[lang = \"eh_unwind_resume\"]\n #[cfg(not(test))]\n unsafe extern fn rust_eh_unwind_resume(panic_ctx: LPVOID) {\n-    rtdebug!(\"rust_eh_unwind_resume: ctx={:X}\", panic_ctx as usize);\n     let params = [panic_ctx as ULONG_PTR];\n     RaiseException(RUST_PANIC,\n                    EXCEPTION_NONCONTINUABLE,", "previous_filename": "src/libstd/rt/unwind/seh64_gnu.rs"}, {"sha": "979f1f486698358f25a6e902877e097c56f874f2", "filename": "src/libstd/sys/common/util.rs", "status": "renamed", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use io::prelude::*;\n-\n use env;\n use fmt;\n use intrinsics;\n+use io::prelude::*;\n use sync::atomic::{self, Ordering};\n use sys::stdio::Stderr;\n+use thread;\n \n pub fn min_stack() -> usize {\n     static MIN: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n@@ -30,24 +30,17 @@ pub fn min_stack() -> usize {\n     amt\n }\n \n-// Indicates whether we should perform expensive sanity checks, including rtassert!\n-//\n-// FIXME: Once the runtime matures remove the `true` below to turn off rtassert,\n-//        etc.\n-pub const ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n-                                  cfg!(rtassert);\n-\n pub fn dumb_print(args: fmt::Arguments) {\n     let _ = Stderr::new().map(|mut stderr| stderr.write_fmt(args));\n }\n \n pub fn abort(args: fmt::Arguments) -> ! {\n-    rterrln!(\"fatal runtime error: {}\", args);\n+    dumb_print(format_args!(\"fatal runtime error: {}\", args));\n     unsafe { intrinsics::abort(); }\n }\n \n+#[allow(dead_code)] // stack overflow detection not enabled on all platforms\n pub unsafe fn report_overflow() {\n-    use thread;\n-    rterrln!(\"\\nthread '{}' has overflowed its stack\",\n-             thread::current().name().unwrap_or(\"<unknown>\"));\n+    dumb_print(format_args!(\"\\nthread '{}' has overflowed its stack\",\n+                            thread::current().name().unwrap_or(\"<unknown>\")));\n }", "previous_filename": "src/libstd/rt/util.rs"}, {"sha": "964bc08ff4e10b3c835f8a9355923490fad74925", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -12,6 +12,7 @@\n #![allow(non_camel_case_types)]\n \n use io::{self, ErrorKind};\n+use libc::funcs::posix01::signal::signal;\n use libc;\n use num::One;\n use ops::Neg;\n@@ -47,6 +48,19 @@ pub mod thread_local;\n pub mod time;\n pub mod stdio;\n \n+pub fn init() {\n+    // By default, some platforms will send a *signal* when a EPIPE error\n+    // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n+    // handler, causing it to kill the program, which isn't exactly what we\n+    // want!\n+    //\n+    // Hence, we set SIGPIPE to ignore when the program starts up in order\n+    // to prevent this problem.\n+    unsafe {\n+        assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != !0);\n+    }\n+}\n+\n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno as libc::c_int {\n         libc::ECONNREFUSED => ErrorKind::ConnectionRefused,"}, {"sha": "94c4d04ea30bbe15192a34e088f1819855910711", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -358,8 +358,8 @@ pub fn args() -> Args {\n           target_os = \"netbsd\",\n           target_os = \"openbsd\"))]\n pub fn args() -> Args {\n-    use rt;\n-    let bytes = rt::args::clone().unwrap_or(Vec::new());\n+    use sys_common;\n+    let bytes = sys_common::args::clone().unwrap_or(Vec::new());\n     let v: Vec<OsString> = bytes.into_iter().map(|v| {\n         OsStringExt::from_vec(v)\n     }).collect();"}, {"sha": "441313bc639935dd8046b8510eaa217611e5cc92", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -38,7 +38,7 @@ impl Drop for Handler {\n           target_os = \"openbsd\"))]\n mod imp {\n     use super::Handler;\n-    use rt::util::report_overflow;\n+    use sys_common::util::report_overflow;\n     use mem;\n     use ptr;\n     use sys::c::{siginfo, sigaction, SIGBUS, SIG_DFL,"}, {"sha": "04bb5e5ea38331d99f614affc4b7f45cd31354fa", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -43,6 +43,8 @@ pub mod thread_local;\n pub mod time;\n pub mod stdio;\n \n+pub fn init() {}\n+\n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno as libc::c_int {\n         libc::ERROR_ACCESS_DENIED => ErrorKind::PermissionDenied,"}, {"sha": "998b4fcb1a12114ed2db5af969efa76748b37153", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -16,11 +16,10 @@ use net::SocketAddr;\n use num::One;\n use ops::Neg;\n use ptr;\n-use rt;\n use sync::Once;\n use sys;\n use sys::c;\n-use sys_common::{AsInner, FromInner, IntoInner};\n+use sys_common::{self, AsInner, FromInner, IntoInner};\n use sys_common::net::{setsockopt, getsockopt};\n use time::Duration;\n \n@@ -39,7 +38,7 @@ pub fn init() {\n                                 &mut data);\n         assert_eq!(ret, 0);\n \n-        let _ = rt::at_exit(|| { c::WSACleanup(); });\n+        let _ = sys_common::at_exit(|| { c::WSACleanup(); });\n     });\n }\n "}, {"sha": "d1c2144ef0d789152c1bc547a1442772d6520086", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use libc::{self, LONG};\n-use rt::util::report_overflow;\n+use sys_common::util::report_overflow;\n use sys::c;\n \n pub struct Handler;"}, {"sha": "c544eec7fce85d79b66e838f59a0a57df0dcfb32", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -13,7 +13,7 @@ use prelude::v1::*;\n use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n \n use ptr;\n-use rt;\n+use sys_common;\n use sys_common::mutex::Mutex;\n \n pub type Key = DWORD;\n@@ -133,7 +133,7 @@ unsafe fn init_dtors() {\n \n     let dtors = box Vec::<(Key, Dtor)>::new();\n \n-    let res = rt::at_exit(move|| {\n+    let res = sys_common::at_exit(move|| {\n         DTOR_LOCK.lock();\n         let dtors = DTORS;\n         DTORS = 1 as *mut _;"}, {"sha": "2b7a3deceb7c4edeea47cd5126cc8163ae2bdb62", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=c8ded9a14f16a4b5ce3facc3bedfd957dbe433fe", "patch": "@@ -167,10 +167,11 @@ use any::Any;\n use cell::UnsafeCell;\n use fmt;\n use io;\n-use rt::{self, unwind};\n use sync::{Mutex, Condvar, Arc};\n use sys::thread as imp;\n use sys_common::thread_info;\n+use sys_common::unwind;\n+use sys_common::util;\n use time::Duration;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -260,7 +261,7 @@ impl Builder {\n                                        -> io::Result<JoinInner<T>> {\n         let Builder { name, stack_size } = self;\n \n-        let stack_size = stack_size.unwrap_or(rt::min_stack());\n+        let stack_size = stack_size.unwrap_or(util::min_stack());\n \n         let my_thread = Thread::new(name);\n         let their_thread = my_thread.clone();\n@@ -383,7 +384,7 @@ pub fn catch_panic<F, R>(f: F) -> Result<R>\n     let mut result = None;\n     unsafe {\n         let result = &mut result;\n-        try!(::rt::unwind::try(move || *result = Some(f())))\n+        try!(unwind::try(move || *result = Some(f())))\n     }\n     Ok(result.unwrap())\n }"}]}