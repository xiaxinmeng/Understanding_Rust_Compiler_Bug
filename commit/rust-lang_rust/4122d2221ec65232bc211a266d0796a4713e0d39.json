{"sha": "4122d2221ec65232bc211a266d0796a4713e0d39", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMjJkMjIyMWVjNjUyMzJiYzIxMWEyNjZkMDc5NmE0NzEzZTBkMzk=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-03-29T02:08:31Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-04-02T19:02:17Z"}, "message": "Remove adt_def from PlaceTy and make it a struct", "tree": {"sha": "782b4697da01528e7641e17daa71966082cbe25d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/782b4697da01528e7641e17daa71966082cbe25d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4122d2221ec65232bc211a266d0796a4713e0d39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4122d2221ec65232bc211a266d0796a4713e0d39", "html_url": "https://github.com/rust-lang/rust/commit/4122d2221ec65232bc211a266d0796a4713e0d39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4122d2221ec65232bc211a266d0796a4713e0d39/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac29ca75e025a101000596f2c68318d86098cf92", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac29ca75e025a101000596f2c68318d86098cf92", "html_url": "https://github.com/rust-lang/rust/commit/ac29ca75e025a101000596f2c68318d86098cf92"}], "stats": {"total": 353, "additions": 157, "deletions": 196}, "files": [{"sha": "0eb37f0ac9e9604b6b71466ce1b2d95769bc13ba", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 42, "deletions": 74, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -4,21 +4,17 @@\n  */\n \n use crate::mir::*;\n-use crate::ty::subst::{Subst, SubstsRef};\n-use crate::ty::{self, AdtDef, Ty, TyCtxt};\n+use crate::ty::subst::Subst;\n+use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::layout::VariantIdx;\n use crate::hir;\n use crate::ty::util::IntTypeExt;\n \n #[derive(Copy, Clone, Debug)]\n-pub enum PlaceTy<'tcx> {\n-    /// Normal type.\n-    Ty { ty: Ty<'tcx> },\n-\n-    /// Downcast to a particular variant of an enum.\n-    Downcast { adt_def: &'tcx AdtDef,\n-               substs: SubstsRef<'tcx>,\n-               variant_index: VariantIdx },\n+pub struct PlaceTy<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    /// Downcast to a particular variant of an enum, if included.\n+    pub variant_index: Option<VariantIdx>,\n }\n \n static_assert!(PLACE_TY_IS_3_PTRS_LARGE:\n@@ -27,16 +23,7 @@ static_assert!(PLACE_TY_IS_3_PTRS_LARGE:\n \n impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn from_ty(ty: Ty<'tcx>) -> PlaceTy<'tcx> {\n-        PlaceTy::Ty { ty }\n-    }\n-\n-    pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        match *self {\n-            PlaceTy::Ty { ty } =>\n-                ty,\n-            PlaceTy::Downcast { adt_def, substs, variant_index: _ } =>\n-                tcx.mk_adt(adt_def, substs),\n-        }\n+        PlaceTy { ty, variant_index: None }\n     }\n \n     /// `place_ty.field_ty(tcx, f)` computes the type at a given field\n@@ -48,21 +35,20 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     /// Note that the resulting type has not been normalized.\n     pub fn field_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n     {\n-        // Pass `0` here so it can be used as a \"default\" variant_index in first arm below\n-        let answer = match (self, VariantIdx::new(0)) {\n-            (PlaceTy::Ty {\n-                ty: &ty::TyS { sty: ty::TyKind::Adt(adt_def, substs), .. } }, variant_index) |\n-            (PlaceTy::Downcast { adt_def, substs, variant_index }, _) => {\n-                let variant_def = &adt_def.variants[variant_index];\n+        let answer = match self.ty.sty {\n+            ty::TyKind::Adt(adt_def, substs) => {\n+                let variant_def = match self.variant_index {\n+                    None => adt_def.non_enum_variant(),\n+                    Some(variant_index) => {\n+                        assert!(adt_def.is_enum());\n+                        &adt_def.variants[variant_index]\n+                    }\n+                };\n                 let field_def = &variant_def.fields[f.index()];\n                 field_def.ty(tcx, substs)\n             }\n-            (PlaceTy::Ty { ty }, _) => {\n-                match ty.sty {\n-                    ty::Tuple(ref tys) => tys[f.index()],\n-                    _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n-                }\n-            }\n+            ty::Tuple(ref tys) => tys[f.index()],\n+            _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n         };\n         debug!(\"field_ty self: {:?} f: {:?} yields: {:?}\", self, f, answer);\n         answer\n@@ -94,61 +80,43 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     {\n         let answer = match *elem {\n             ProjectionElem::Deref => {\n-                let ty = self.to_ty(tcx)\n+                let ty = self.ty\n                              .builtin_deref(true)\n                              .unwrap_or_else(|| {\n                                  bug!(\"deref projection of non-dereferencable ty {:?}\", self)\n                              })\n                              .ty;\n-                PlaceTy::Ty {\n-                    ty,\n-                }\n+                PlaceTy::from_ty(ty)\n             }\n             ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } =>\n-                PlaceTy::Ty {\n-                    ty: self.to_ty(tcx).builtin_index().unwrap()\n-                },\n+                PlaceTy::from_ty(self.ty.builtin_index().unwrap()),\n             ProjectionElem::Subslice { from, to } => {\n-                let ty = self.to_ty(tcx);\n-                PlaceTy::Ty {\n-                    ty: match ty.sty {\n-                        ty::Array(inner, size) => {\n-                            let size = size.unwrap_usize(tcx);\n-                            let len = size - (from as u64) - (to as u64);\n-                            tcx.mk_array(inner, len)\n-                        }\n-                        ty::Slice(..) => ty,\n-                        _ => {\n-                            bug!(\"cannot subslice non-array type: `{:?}`\", self)\n-                        }\n-                    }\n-                }\n-            }\n-            ProjectionElem::Downcast(_name, index) =>\n-                match self.to_ty(tcx).sty {\n-                    ty::Adt(adt_def, substs) => {\n-                        assert!(adt_def.is_enum());\n-                        assert!(index.as_usize() < adt_def.variants.len());\n-                        PlaceTy::Downcast { adt_def,\n-                                            substs,\n-                                            variant_index: index }\n+                PlaceTy::from_ty(match self.ty.sty {\n+                    ty::Array(inner, size) => {\n+                        let size = size.unwrap_usize(tcx);\n+                        let len = size - (from as u64) - (to as u64);\n+                        tcx.mk_array(inner, len)\n                     }\n+                    ty::Slice(..) => self.ty,\n                     _ => {\n-                        bug!(\"cannot downcast non-ADT type: `{:?}`\", self)\n+                        bug!(\"cannot subslice non-array type: `{:?}`\", self)\n                     }\n-                },\n+                })\n+            }\n+            ProjectionElem::Downcast(_name, index) =>\n+                PlaceTy { ty: self.ty, variant_index: Some(index) },\n             ProjectionElem::Field(ref f, ref fty) =>\n-                PlaceTy::Ty { ty: handle_field(&self, f, fty) },\n+                PlaceTy::from_ty(handle_field(&self, f, fty)),\n         };\n         debug!(\"projection_ty self: {:?} elem: {:?} yields: {:?}\", self, elem, answer);\n         answer\n     }\n }\n \n-EnumTypeFoldableImpl! {\n+BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for PlaceTy<'tcx> {\n-        (PlaceTy::Ty) { ty },\n-        (PlaceTy::Downcast) { adt_def, substs, variant_index },\n+        ty,\n+        variant_index,\n     }\n }\n \n@@ -158,9 +126,9 @@ impl<'tcx> Place<'tcx> {\n     {\n         match *self {\n             Place::Base(PlaceBase::Local(index)) =>\n-                PlaceTy::Ty { ty: local_decls.local_decls()[index].ty },\n+                PlaceTy::from_ty(local_decls.local_decls()[index].ty),\n             Place::Base(PlaceBase::Static(ref data)) =>\n-                PlaceTy::Ty { ty: data.ty },\n+                PlaceTy::from_ty(data.ty),\n             Place::Projection(ref proj) =>\n                 proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),\n         }\n@@ -185,7 +153,7 @@ impl<'tcx> Place<'tcx> {\n         match place {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _ty) => {\n-                    let base_ty = proj.base.ty(mir, *tcx).to_ty(*tcx);\n+                    let base_ty = proj.base.ty(mir, *tcx).ty;\n \n                     if (base_ty.is_closure() || base_ty.is_generator()) &&\n                         (!by_ref || mir.upvar_decls[field.index()].by_ref)\n@@ -217,7 +185,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 tcx.mk_array(operand.ty(local_decls, tcx), count)\n             }\n             Rvalue::Ref(reg, bk, ref place) => {\n-                let place_ty = place.ty(local_decls, tcx).to_ty(tcx);\n+                let place_ty = place.ty(local_decls, tcx).ty;\n                 tcx.mk_ref(reg,\n                     ty::TypeAndMut {\n                         ty: place_ty,\n@@ -243,7 +211,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 operand.ty(local_decls, tcx)\n             }\n             Rvalue::Discriminant(ref place) => {\n-                let ty = place.ty(local_decls, tcx).to_ty(tcx);\n+                let ty = place.ty(local_decls, tcx).ty;\n                 if let ty::Adt(adt_def, _) = ty.sty {\n                     adt_def.repr.discr_type().to_ty(tcx)\n                 } else {\n@@ -292,7 +260,7 @@ impl<'tcx> Operand<'tcx> {\n     {\n         match self {\n             &Operand::Copy(ref l) |\n-            &Operand::Move(ref l) => l.ty(local_decls, tcx).to_ty(tcx),\n+            &Operand::Move(ref l) => l.ty(local_decls, tcx).ty,\n             &Operand::Constant(ref c) => c.ty,\n         }\n     }"}, {"sha": "8253a1672454d33cb688269101ab5e05259f3904", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -172,14 +172,14 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty\n                     .projection_ty(cx.tcx(), &proj.elem)\n-                    .to_ty(cx.tcx());\n+                    .ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n                 if cx.layout_of(elem_ty).is_zst() {\n                     return;\n                 }\n \n                 if let mir::ProjectionElem::Field(..) = proj.elem {\n-                    let layout = cx.layout_of(base_ty.to_ty(cx.tcx()));\n+                    let layout = cx.layout_of(base_ty.ty);\n                     if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n@@ -247,7 +247,7 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n                 let ty = mir::Place::Base(mir::PlaceBase::Local(local)).ty(self.fx.mir,\n                                                                            self.fx.cx.tcx());\n-                let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx()));\n+                let ty = self.fx.monomorphize(&ty.ty);\n \n                 // Only need the place if we're actually dropping it.\n                 if self.fx.cx.type_needs_drop(ty) {"}, {"sha": "4e6861b64bd5f70df57ee35558e4145a533d547f", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -301,7 +301,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(self.mir, bx.tcx()).to_ty(bx.tcx());\n+        let ty = location.ty(self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = monomorphize::resolve_drop_in_place(bx.tcx(), ty);\n "}, {"sha": "2b7b900475332422cd0f15bf1bf93690996db57f", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -494,8 +494,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = cg_base.project_index(bx,\n                             bx.cx().const_usize(from as u64));\n-                        let projected_ty = PlaceTy::Ty { ty: cg_base.layout.ty }\n-                            .projection_ty(tcx, &projection.elem).to_ty(tcx);\n+                        let projected_ty = PlaceTy::from_ty(cg_base.layout.ty)\n+                            .projection_ty(tcx, &projection.elem).ty;\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n@@ -523,6 +523,6 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn monomorphized_place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n         let place_ty = place.ty(self.mir, tcx);\n-        self.monomorphize(&place_ty.to_ty(tcx))\n+        self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "17a860a060b54ff501101f7aa5438652f0f81be4", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -202,7 +202,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            let ty = used_place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+            let ty = used_place.ty(self.mir, self.infcx.tcx).ty;\n             let needs_note = match ty.sty {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n@@ -217,7 +217,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let mpi = self.move_data.moves[move_out_indices[0]].path;\n                 let place = &self.move_data.move_paths[mpi].place;\n \n-                let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                let ty = place.ty(self.mir, self.infcx.tcx).ty;\n                 let opt_name = self.describe_place_with_options(place, IncludingDowncast(true));\n                 let note_msg = match opt_name {\n                     Some(ref name) => format!(\"`{}`\", name),\n@@ -601,8 +601,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n         let is_union = |place: &Place<'tcx>| -> bool {\n-            place.ty(self.mir, self.infcx.tcx)\n-                .to_ty(self.infcx.tcx)\n+            place.ty(self.mir, self.infcx.tcx).ty\n                 .ty_adt_def()\n                 .map(|adt| adt.is_union())\n                 .unwrap_or(false)\n@@ -651,7 +650,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                             // Also compute the name of the union type, eg. `Foo` so we\n                             // can add a helpful note with it.\n-                            let ty = base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                            let ty = base.ty(self.mir, self.infcx.tcx).ty;\n \n                             return Some((desc_base, desc_first, desc_second, ty.to_string()));\n                         },\n@@ -1777,7 +1776,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Deref => self.describe_field(&proj.base, field),\n                 ProjectionElem::Downcast(_, variant_index) => {\n-                    let base_ty = base.ty(self.mir, self.infcx.tcx).to_ty();\n+                    let base_ty = base.ty(self.mir, self.infcx.tcx).ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n@@ -1878,15 +1877,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                base.ty(self.mir, tcx).to_ty(tcx).is_box(),\n+                                base.ty(self.mir, tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+                        let base_ty = base.ty(self.mir, tcx).ty;\n                         match base_ty.sty {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor"}, {"sha": "5434e66a39445f04a6c006c410c8dc1890df6d78", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -616,8 +616,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 let drop_place_ty = drop_place.ty(self.mir, self.infcx.tcx);\n \n                 // Erase the regions.\n-                let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty)\n-                    .to_ty(self.infcx.tcx);\n+                let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n \n                 // \"Lift\" into the gcx -- once regions are erased, this type should be in the\n                 // global arenas; this \"lift\" operation basically just asserts that is true, but\n@@ -1641,7 +1640,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // assigning to `P.f` requires `P` itself\n                             // be already initialized\n                             let tcx = self.infcx.tcx;\n-                            match base.ty(self.mir, tcx).to_ty(tcx).sty {\n+                            match base.ty(self.mir, tcx).ty.sty {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     self.check_if_path_or_subpath_is_moved(\n                                         context, InitializationRequiringAction::Assignment,\n@@ -1746,7 +1745,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n-                if let ty::TyKind::Adt(def, _) = base.ty(this.mir, tcx).to_ty(tcx).sty {\n+                if let ty::TyKind::Adt(def, _) = base.ty(this.mir, tcx).ty.sty {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(\n@@ -2007,7 +2006,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        let base_ty = proj.base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let base_ty = proj.base.ty(self.mir, self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {"}, {"sha": "b6e7996586e4a496901ef2ce55054b064a69eccb", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -266,7 +266,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         // Inspect the type of the content behind the\n                         // borrow to provide feedback about why this\n                         // was a move rather than a copy.\n-                        let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let ty = place.ty(self.mir, self.infcx.tcx).ty;\n                         let is_upvar_field_projection =\n                             self.prefixes(&original_path, PrefixSet::All)\n                             .any(|p| p.is_upvar_field_projection(self.mir, &self.infcx.tcx)\n@@ -530,7 +530,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     // We're only interested in assignments (in particular, where the\n                     // assignment came from - was it an `Rc` or `Arc`?).\n                     if let StatementKind::Assign(_, box Rvalue::Ref(_, _, source)) = &stmt.kind {\n-                        let ty = source.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let ty = source.ty(self.mir, self.infcx.tcx).ty;\n                         let ty = match ty.sty {\n                             ty::TyKind::Ref(_, ty, _) => ty,\n                             _ => ty,\n@@ -555,7 +555,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             _ => continue,\n                         };\n \n-                        let ty = source.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let ty = source.ty(self.mir, self.infcx.tcx).ty;\n                         let ty = match ty.sty {\n                             ty::TyKind::Ref(_, ty, _) => ty,\n                             _ => ty,\n@@ -581,7 +581,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             base,\n             elem: ProjectionElem::Deref,\n         }) = place {\n-            if base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx).is_unsafe_ptr() {\n+            if base.ty(self.mir, self.infcx.tcx).ty.is_unsafe_ptr() {\n                 return BorrowedContentSource::DerefRawPointer;\n             }\n         }"}, {"sha": "8a55a59b15b17f728216ac16c45f68ac92858b6d", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n+                    base.ty(self.mir, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -85,7 +85,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n-                        the_place_err.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n+                        the_place_err.ty(self.mir, self.infcx.tcx).ty\n                     ));\n \n                     reason = if access_place.is_upvar_field_projection(self.mir,\n@@ -110,7 +110,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     reason = \", as it is immutable for the pattern guard\".to_string();\n                 } else {\n                     let pointer_type =\n-                        if base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx).is_region_ptr() {\n+                        if base.ty(self.mir, self.infcx.tcx).ty.is_region_ptr() {\n                             \"`&` reference\"\n                         } else {\n                             \"`*const` pointer\"\n@@ -232,7 +232,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx),\n+                    base.ty(self.mir, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -304,7 +304,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n+                    base.ty(self.mir, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));"}, {"sha": "9faed40e43b44c2dba0382d5fffb8ab96ee44f64", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 48, "deletions": 51, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -450,9 +450,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n         let place_ty = match place {\n-            Place::Base(PlaceBase::Local(index)) => PlaceTy::Ty {\n-                ty: self.mir.local_decls[*index].ty,\n-            },\n+            Place::Base(PlaceBase::Local(index)) =>\n+                PlaceTy::from_ty(self.mir.local_decls[*index].ty),\n             Place::Base(PlaceBase::Static(box Static { kind, ty: sty })) => {\n                 let sty = self.sanitize_type(place, sty);\n                 let check_err =\n@@ -493,7 +492,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         check_err(self, place, ty, sty);\n                     }\n                 }\n-                PlaceTy::Ty { ty: sty }\n+                PlaceTy::from_ty(sty)\n             }\n             Place::Projection(ref proj) => {\n                 let base_context = if context.is_mutating_use() {\n@@ -502,12 +501,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n                 };\n                 let base_ty = self.sanitize_place(&proj.base, location, base_context);\n-                if let PlaceTy::Ty { ty } = base_ty {\n-                    if ty.references_error() {\n+                if base_ty.variant_index.is_none() {\n+                    if base_ty.ty.references_error() {\n                         assert!(self.errors_reported);\n-                        return PlaceTy::Ty {\n-                            ty: self.tcx().types.err,\n-                        };\n+                        return PlaceTy::from_ty(self.tcx().types.err);\n                     }\n                 }\n                 self.sanitize_projection(base_ty, &proj.elem, place, location)\n@@ -517,7 +514,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             let tcx = self.tcx();\n             let trait_ref = ty::TraitRef {\n                 def_id: tcx.lang_items().copy_trait().unwrap(),\n-                substs: tcx.mk_substs_trait(place_ty.to_ty(tcx), &[]),\n+                substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n             };\n \n             // In order to have a Copy operand, the type T of the\n@@ -615,40 +612,40 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, place);\n         let tcx = self.tcx();\n-        let base_ty = base.to_ty(tcx);\n+        let base_ty = base.ty;\n         match *pi {\n             ProjectionElem::Deref => {\n                 let deref_ty = base_ty.builtin_deref(true);\n-                PlaceTy::Ty {\n-                    ty: deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n+                PlaceTy::from_ty(\n+                    deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n                         span_mirbug_and_err!(self, place, \"deref of non-pointer {:?}\", base_ty)\n-                    }),\n-                }\n+                    })\n+                )\n             }\n             ProjectionElem::Index(i) => {\n-                let index_ty = Place::Base(PlaceBase::Local(i)).ty(self.mir, tcx).to_ty(tcx);\n+                let index_ty = Place::Base(PlaceBase::Local(i)).ty(self.mir, tcx).ty;\n                 if index_ty != tcx.types.usize {\n-                    PlaceTy::Ty {\n-                        ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n-                    }\n+                    PlaceTy::from_ty(\n+                        span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n+                    )\n                 } else {\n-                    PlaceTy::Ty {\n-                        ty: base_ty.builtin_index().unwrap_or_else(|| {\n+                    PlaceTy::from_ty(\n+                        base_ty.builtin_index().unwrap_or_else(|| {\n                             span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n                         }),\n-                    }\n+                    )\n                 }\n             }\n             ProjectionElem::ConstantIndex { .. } => {\n                 // consider verifying in-bounds\n-                PlaceTy::Ty {\n-                    ty: base_ty.builtin_index().unwrap_or_else(|| {\n+                PlaceTy::from_ty(\n+                    base_ty.builtin_index().unwrap_or_else(|| {\n                         span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n                     }),\n-                }\n+                )\n             }\n-            ProjectionElem::Subslice { from, to } => PlaceTy::Ty {\n-                ty: match base_ty.sty {\n+            ProjectionElem::Subslice { from, to } => PlaceTy::from_ty(\n+                match base_ty.sty {\n                     ty::Array(inner, size) => {\n                         let size = size.unwrap_usize(tcx);\n                         let min_size = (from as u64) + (to as u64);\n@@ -666,24 +663,23 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     ty::Slice(..) => base_ty,\n                     _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n                 },\n-            },\n+            ),\n             ProjectionElem::Downcast(maybe_name, index) => match base_ty.sty {\n-                ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n+                ty::Adt(adt_def, _substs) if adt_def.is_enum() => {\n                     if index.as_usize() >= adt_def.variants.len() {\n-                        PlaceTy::Ty {\n-                            ty: span_mirbug_and_err!(\n+                        PlaceTy::from_ty(\n+                            span_mirbug_and_err!(\n                                 self,\n                                 place,\n                                 \"cast to variant #{:?} but enum only has {:?}\",\n                                 index,\n                                 adt_def.variants.len()\n                             ),\n-                        }\n+                        )\n                     } else {\n-                        PlaceTy::Downcast {\n-                            adt_def,\n-                            substs,\n-                            variant_index: index,\n+                        PlaceTy {\n+                            ty: base_ty,\n+                            variant_index: Some(index),\n                         }\n                     }\n                 }\n@@ -699,7 +695,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     } else {\n                         span_mirbug_and_err!(self, place, \"can't downcast {:?}\", base_ty)\n                     };\n-                    PlaceTy::Ty { ty }\n+                    PlaceTy::from_ty(ty)\n                 },\n             },\n             ProjectionElem::Field(field, fty) => {\n@@ -728,7 +724,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         field_count\n                     ),\n                 }\n-                PlaceTy::Ty { ty: fty }\n+                PlaceTy::from_ty(fty)\n             }\n         }\n     }\n@@ -748,12 +744,13 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n \n         let (variant, substs) = match base_ty {\n-            PlaceTy::Downcast {\n-                adt_def,\n-                substs,\n-                variant_index,\n-            } => (&adt_def.variants[variant_index], substs),\n-            PlaceTy::Ty { ty } => match ty.sty {\n+            PlaceTy { ty, variant_index: Some(variant_index) } => {\n+                match ty.sty {\n+                    ty::TyKind::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n+                    _ => bug!(\"can't have downcast of non-adt type\"),\n+                }\n+            }\n+            PlaceTy { ty, variant_index: None } => match ty.sty {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() =>\n                     (&adt_def.variants[VariantIdx::new(0)], substs),\n                 ty::Closure(def_id, substs) => {\n@@ -1190,7 +1187,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         debug!(\"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n                 user_ty.base, annotated_type, user_ty.projs, curr_projected_ty);\n \n-        let ty = curr_projected_ty.to_ty(tcx);\n+        let ty = curr_projected_ty.ty;\n         self.relate_types(a, v, ty, locations, category)?;\n \n         Ok(())\n@@ -1338,7 +1335,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     _ => ConstraintCategory::Assignment,\n                 };\n \n-                let place_ty = place.ty(mir, tcx).to_ty(tcx);\n+                let place_ty = place.ty(mir, tcx).ty;\n                 let rv_ty = rv.ty(mir, tcx);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n@@ -1390,7 +1387,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ref place,\n                 variant_index,\n             } => {\n-                let place_type = place.ty(mir, tcx).to_ty(tcx);\n+                let place_type = place.ty(mir, tcx).ty;\n                 let adt = match place_type.sty {\n                     TyKind::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -1412,7 +1409,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 };\n             }\n             StatementKind::AscribeUserType(ref place, variance, box ref projection) => {\n-                let place_ty = place.ty(mir, tcx).to_ty(tcx);\n+                let place_ty = place.ty(mir, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n@@ -1468,7 +1465,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 target: _,\n                 unwind: _,\n             } => {\n-                let place_ty = location.ty(mir, tcx).to_ty(tcx);\n+                let place_ty = location.ty(mir, tcx).ty;\n                 let rv_ty = value.ty(mir, tcx);\n \n                 let locations = term_location.to_locations();\n@@ -1616,7 +1613,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n         match *destination {\n             Some((ref dest, _target_block)) => {\n-                let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n+                let dest_ty = dest.ty(mir, tcx).ty;\n                 let category = match *dest {\n                     Place::Base(PlaceBase::Local(RETURN_PLACE)) => {\n                         if let Some(BorrowCheckContext {\n@@ -2375,7 +2372,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             match *elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = base.ty(mir, tcx).to_ty(tcx);\n+                    let base_ty = base.ty(mir, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {"}, {"sha": "8269b7b95f490ea4ac88e6e5118d3b74afe9d77c", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                     tcx, mir, locals_state_at_exit),\n \n                 ProjectionElem::Deref => {\n-                    let ty = proj.base.ty(mir, tcx).to_ty(tcx);\n+                    let ty = proj.base.ty(mir, tcx).ty;\n                     match ty.sty {\n                         // For both derefs of raw pointers and `&T`\n                         // references, the original path is `Copy` and"}, {"sha": "fbe8b8485dda5b9d886ee7b1d8a3834d4c4ab11e", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -191,7 +191,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                     Place::Projection(box Projection { base, elem }) => (base, elem),\n                     _ => bug!(\"place has no base?\"),\n                 };\n-                let base_ty = base.ty(mir, tcx).to_ty(tcx);\n+                let base_ty = base.ty(mir, tcx).ty;\n \n                 match (elem, &base_ty.sty, access) {\n                     (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n@@ -427,7 +427,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                         debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n                         Overlap::EqualOrDisjoint\n                     } else {\n-                        let ty = pi1.base.ty(mir, tcx).to_ty(tcx);\n+                        let ty = pi1.base.ty(mir, tcx).ty;\n                         match ty.sty {\n                             ty::Adt(def, _) if def.is_union() => {\n                                 // Different fields of a union, we are basically stuck."}, {"sha": "866f1cf994e69669508e953f4d0424263837d7c6", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -139,7 +139,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n             // derefs, except we stop at the deref of a shared\n             // reference.\n \n-            let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+            let ty = proj.base.ty(self.mir, self.tcx).ty;\n             match ty.sty {\n                 ty::RawPtr(_) |\n                 ty::Ref("}, {"sha": "7469aceee3a9ee959c7647fee82007ba20eaed77", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n         // of the block, which is stored into `destination`.\n         let tcx = this.hir.tcx();\n-        let destination_ty = destination.ty(&this.local_decls, tcx).to_ty(tcx);\n+        let destination_ty = destination.ty(&this.local_decls, tcx).ty;\n         if let Some(expr) = expr {\n             let tail_result_is_ignored = destination_ty.is_unit() ||\n                 this.block_context.currently_ignores_tail_results();"}, {"sha": "566f1790f8f7f488e8d63451684d31e91e9a4a90", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -374,7 +374,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let ty_source_info = self.source_info(user_ty_span);\n                 let user_ty = box pat_ascription_ty.user_ty(\n                     &mut self.canonical_user_type_annotations,\n-                    place.ty(&self.local_decls, self.hir.tcx()).to_ty(self.hir.tcx()),\n+                    place.ty(&self.local_decls, self.hir.tcx()).ty,\n                     ty_source_info.span,\n                 );\n                 self.cfg.push(\n@@ -1293,7 +1293,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n \n         all_fake_borrows.into_iter().map(|matched_place| {\n-            let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).to_ty(tcx);\n+            let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;\n             let fake_borrow_ty = tcx.mk_imm_ref(tcx.types.re_erased, fake_borrow_deref_ty);\n             let fake_borrow_temp = self.local_decls.push(\n                 LocalDecl::new_temp(fake_borrow_ty, temp_span)\n@@ -1587,7 +1587,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             let user_ty = box ascription.user_ty.clone().user_ty(\n                 &mut self.canonical_user_type_annotations,\n-                ascription.source.ty(&self.local_decls, self.hir.tcx()).to_ty(self.hir.tcx()),\n+                ascription.source.ty(&self.local_decls, self.hir.tcx()).ty,\n                 source_info.span\n             );\n             self.cfg.push("}, {"sha": "d71a13dec5a2f971340dd3acf5bd6589ec9da708", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     pub fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n         let tcx = self.hir.tcx();\n-        let ty = place.ty(&self.local_decls, tcx).to_ty(tcx);\n+        let ty = place.ty(&self.local_decls, tcx).ty;\n         if !self.hir.type_is_copy_modulo_regions(ty, DUMMY_SP) {\n             Operand::Move(place)\n         } else {"}, {"sha": "aae4590a387a7a7a2a33164c60f346ce24433dbc", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -49,7 +49,7 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                             mir: &Mir<'tcx>,\n                                                             place: &mir::Place<'tcx>) -> bool {\n-    let ty = place.ty(mir, tcx).to_ty(tcx);\n+    let ty = place.ty(mir, tcx).ty;\n     match ty.sty {\n         ty::Array(..) => {\n             debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\",\n@@ -141,7 +141,7 @@ pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n {\n     on_all_children_bits(tcx, mir, &ctxt.move_data, path, |child| {\n         let place = &ctxt.move_data.move_paths[path].place;\n-        let ty = place.ty(mir, tcx).to_ty(tcx);\n+        let ty = place.ty(mir, tcx).ty;\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, place, ty);\n \n         let gcx = tcx.global_tcx();"}, {"sha": "20a306a3ef7a631f98699943c1ddf9d9c46d1491", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -120,7 +120,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         let base = self.move_path_for(&proj.base)?;\n         let mir = self.builder.mir;\n         let tcx = self.builder.tcx;\n-        let place_ty = proj.base.ty(mir, tcx).to_ty(tcx);\n+        let place_ty = proj.base.ty(mir, tcx).ty;\n         match place_ty.sty {\n             ty::Ref(..) | ty::RawPtr(..) =>\n                 return Err(MoveError::cannot_move_out_of(\n@@ -424,7 +424,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             Place::Projection(box Projection {\n                 base,\n                 elem: ProjectionElem::Field(_, _),\n-            }) if match base.ty(self.builder.mir, self.builder.tcx).to_ty(self.builder.tcx).sty {\n+            }) if match base.ty(self.builder.mir, self.builder.tcx).ty.sty {\n                     ty::TyKind::Adt(def, _) if def.is_union() => true,\n                     _ => false,\n             } => base,"}, {"sha": "af875c2f9e8a183ea13bbb3a93797849421b3005", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -625,8 +625,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                let ty = location.ty(self.mir, self.tcx)\n-                    .to_ty(self.tcx);\n+                let ty = location.ty(self.mir, self.tcx).ty;\n                 let ty = tcx.subst_and_normalize_erasing_regions(\n                     self.param_substs,\n                     ty::ParamEnv::reveal_all(),"}, {"sha": "b6436ec70eef24ff64f77a32594b07671fbf0313", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -106,7 +106,7 @@ fn add_move_for_packed_drop<'a, 'tcx>(\n     };\n \n     let source_info = terminator.source_info;\n-    let ty = location.ty(mir, tcx).to_ty(tcx);\n+    let ty = location.ty(mir, tcx).ty;\n     let temp = patch.new_temp(ty, terminator.source_info.span);\n \n     let storage_dead_block = patch.new_block(BasicBlockData {"}, {"sha": "9b9e6594296bac191813550e1d44dc18cf7cce82", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -87,7 +87,7 @@ impl MirPass for AddRetag {\n         let needs_retag = |place: &Place<'tcx>| {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that.\n-            is_stable(place) && may_have_reference(place.ty(&*local_decls, tcx).to_ty(tcx), tcx)\n+            is_stable(place) && may_have_reference(place.ty(&*local_decls, tcx).ty, tcx)\n         };\n \n         // PART 1"}, {"sha": "93f3afe1aea6b85f6c94af606ae2489c075801bb", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 let is_borrow_of_interior_mut = context.is_borrow() && !base\n                     .ty(self.mir, self.tcx)\n-                    .to_ty(self.tcx)\n+                    .ty\n                     .is_freeze(self.tcx, self.param_env, self.source_info.span);\n                 // prevent\n                 // * `&mut x.field`\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         self.source_info = self.mir.local_decls[local].source_info;\n                     }\n                 }\n-                let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                let base_ty = base.ty(self.mir, self.tcx).ty;\n                 match base_ty.sty {\n                     ty::RawPtr(..) => {\n                         self.require_unsafe(\"dereference of raw pointer\",\n@@ -420,7 +420,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         }) = place {\n             match *elem {\n                 ProjectionElem::Field(..) => {\n-                    let ty = base.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n+                    let ty = base.ty(&self.mir.local_decls, self.tcx).ty;\n                     match ty.sty {\n                         ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n                             (Bound::Unbounded, Bound::Unbounded) => {},"}, {"sha": "a9d831f8462769387c6a39b50a5bc06ffa21c553", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -556,7 +556,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let StatementKind::Assign(ref place, ref rval) = statement.kind {\n             let place_ty: ty::Ty<'tcx> = place\n                 .ty(&self.mir.local_decls, self.tcx)\n-                .to_ty(self.tcx);\n+                .ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(value) = self.const_prop(rval, place_layout, statement.source_info) {\n                     if let Place::Base(PlaceBase::Local(local)) = *place {"}, {"sha": "027ae70b06a175e1aa6c1bd98778f7a2a2efde42", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -319,8 +319,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     work_list.push(target);\n                     // If the location doesn't actually need dropping, treat it like\n                     // a regular goto.\n-                    let ty = location.ty(callee_mir, tcx).subst(tcx, callsite.substs);\n-                    let ty = ty.to_ty(tcx);\n+                    let ty = location.ty(callee_mir, tcx).subst(tcx, callsite.substs).ty;\n                     if ty.needs_drop(tcx, param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n@@ -563,7 +562,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             assert!(args.next().is_none());\n \n             let tuple = Place::Base(PlaceBase::Local(tuple));\n-            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_mir, tcx).to_ty(tcx).sty {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_mir, tcx).ty.sty {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");"}, {"sha": "7e925f65ee2d733b5155c46afb0a3015b2fe241b", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -82,14 +82,14 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, Place::Projection(ref projection)) = *rvalue {\n             if let ProjectionElem::Deref = projection.elem {\n-                if projection.base.ty(self.mir, self.tcx).to_ty(self.tcx).is_region_ptr() {\n+                if projection.base.ty(self.mir, self.tcx).ty.is_region_ptr() {\n                     self.optimizations.and_stars.insert(location);\n                 }\n             }\n         }\n \n         if let Rvalue::Len(ref place) = *rvalue {\n-            let place_ty = place.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n+            let place_ty = place.ty(&self.mir.local_decls, self.tcx).ty;\n             if let TyKind::Array(_, len) = place_ty.sty {\n                 let span = self.mir.source_info(location).span;\n                 let ty = self.tcx.types.usize;"}, {"sha": "dda9457cc8ccf844f48e5656baca822ac1482ad2", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -135,7 +135,7 @@ fn check_lang_item_type<'a, 'tcx, D>(\n     let sig = poly_sig.no_bound_vars().unwrap();\n     let lhs_ty = lhs.ty(local_decls, tcx);\n     let rhs_ty = rhs.ty(local_decls, tcx);\n-    let place_ty = place.ty(local_decls, tcx).to_ty(tcx);\n+    let place_ty = place.ty(local_decls, tcx).ty;\n     let expected = [lhs_ty, rhs_ty, place_ty];\n     assert_eq!(sig.inputs_and_output[..], expected,\n         \"lang item `{}`\", tcx.def_path_str(did));"}, {"sha": "43723aaf568daadbd6a136ef845fa461d5e10cc5", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                                 place = &mut proj.base;\n                             };\n \n-                            let ty = place.ty(local_decls, self.tcx).to_ty(self.tcx);\n+                            let ty = place.ty(local_decls, self.tcx).ty;\n                             let span = statement.source_info.span;\n \n                             Operand::Move(mem::replace(place, promoted_place(ty, span)))"}, {"sha": "72696f827d3fc27e9d269492bbf9abe42c841969", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -168,7 +168,7 @@ trait Qualif {\n             cx,\n             proj.base.ty(cx.mir, cx.tcx)\n                 .projection_ty(cx.tcx, &proj.elem)\n-                .to_ty(cx.tcx),\n+                .ty,\n         );\n         match proj.elem {\n             ProjectionElem::Deref |\n@@ -245,7 +245,7 @@ trait Qualif {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let Place::Projection(ref proj) = *place {\n                     if let ProjectionElem::Deref = proj.elem {\n-                        let base_ty = proj.base.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                        let base_ty = proj.base.ty(cx.mir, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.sty {\n                             return Self::in_place(cx, &proj.base);\n                         }\n@@ -301,7 +301,7 @@ impl Qualif for HasMutInterior {\n             // allowed in constants (and the `Checker` will error), and/or it\n             // won't be promoted, due to `&mut ...` or interior mutability.\n             Rvalue::Ref(_, kind, ref place) => {\n-                let ty = place.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                let ty = place.ty(cx.mir, cx.tcx).ty;\n \n                 if let BorrowKind::Mut { .. } = kind {\n                     // In theory, any zero-sized value could be borrowed\n@@ -398,7 +398,7 @@ impl Qualif for IsNotConst {\n \n             ProjectionElem::Field(..) => {\n                 if cx.mode == Mode::Fn {\n-                    let base_ty = proj.base.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                    let base_ty = proj.base.ty(cx.mir, cx.tcx).ty;\n                     if let Some(def) = base_ty.ty_adt_def() {\n                         if def.is_union() {\n                             return true;\n@@ -985,7 +985,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                             // `not_const` errors out in const contexts\n                             self.not_const()\n                         }\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                         match self.mode {\n                             Mode::Fn => {},\n                             _ => {\n@@ -1009,7 +1009,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     ProjectionElem::Subslice {..} |\n                     ProjectionElem::Field(..) |\n                     ProjectionElem::Index(_) => {\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                         if let Some(def) = base_ty.ty_adt_def() {\n                             if def.is_union() {\n                                 match self.mode {\n@@ -1066,7 +1066,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             let mut is_reborrow = false;\n             if let Place::Projection(ref proj) = *place {\n                 if let ProjectionElem::Deref = proj.elem {\n-                    let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.sty {\n                         is_reborrow = true;\n                     }\n@@ -1190,7 +1190,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 self.assign(dest, ValueSource::Call {\n                     callee: func,\n                     args,\n-                    return_ty: dest.ty(self.mir, self.tcx).to_ty(self.tcx),\n+                    return_ty: dest.ty(self.mir, self.tcx).ty,\n                 }, location);\n             }\n \n@@ -1364,7 +1364,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n                 if let Some(span) = needs_drop {\n                     // Double-check the type being dropped, to minimize false positives.\n-                    let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    let ty = place.ty(self.mir, self.tcx).ty;\n                     if ty.needs_drop(self.tcx, self.param_env) {\n                         struct_span_err!(self.tcx.sess, span, E0493,\n                                          \"destructors cannot be evaluated at compile-time\")"}, {"sha": "616944dd7ef99ed87eb2361d783af84d15593554", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                                                      from_end: false} = proj.elem {\n                     // no need to transformation\n                 } else {\n-                    let place_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    let place_ty = proj.base.ty(self.mir, self.tcx).ty;\n                     if let ty::Array(item_ty, const_size) = place_ty.sty {\n                         if let Some(size) = const_size.assert_usize(self.tcx) {\n                             assert!(size <= u32::max_value() as u64,\n@@ -195,7 +195,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n \n                         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n                         let opt_size = opt_src_place.and_then(|src_place| {\n-                            let src_ty = src_place.ty(mir, tcx).to_ty(tcx);\n+                            let src_ty = src_place.ty(mir, tcx).ty;\n                             if let ty::Array(_, ref size_o) = src_ty.sty {\n                                 size_o.assert_usize(tcx)\n                             } else {"}, {"sha": "788b7fdaaf91257e9bca59e4b0e35ae4b8b6e356", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -17,7 +17,7 @@ pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return false\n     }\n \n-    let ty = place.ty(local_decls, tcx).to_ty(tcx);\n+    let ty = place.ty(local_decls, tcx).ty;\n     match tcx.layout_raw(param_env.and(ty)) {\n         Ok(layout) if layout.align.abi.bytes() == 1 => {\n             // if the alignment is 1, the type can't be further\n@@ -46,7 +46,7 @@ fn is_within_packed<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // encountered a Deref, which is ABI-aligned\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n-                let ty = base.ty(local_decls, tcx).to_ty(tcx);\n+                let ty = base.ty(local_decls, tcx).ty;\n                 match ty.sty {\n                     ty::Adt(def, _) if def.repr.packed() => {\n                         return true"}, {"sha": "2d275c9a13792df1501304a7948160da03feaf24", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4122d2221ec65232bc211a266d0796a4713e0d39/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=4122d2221ec65232bc211a266d0796a4713e0d39", "patch": "@@ -122,7 +122,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     where D: DropElaborator<'b, 'tcx>\n {\n     fn place_ty(&self, place: &Place<'tcx>) -> Ty<'tcx> {\n-        place.ty(self.elaborator.mir(), self.tcx()).to_ty(self.tcx())\n+        place.ty(self.elaborator.mir(), self.tcx()).ty\n     }\n \n     fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {"}]}