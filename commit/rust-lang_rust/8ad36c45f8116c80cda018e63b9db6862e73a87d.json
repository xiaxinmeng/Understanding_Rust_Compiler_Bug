{"sha": "8ad36c45f8116c80cda018e63b9db6862e73a87d", "node_id": "C_kwDOAAsO6NoAKDhhZDM2YzQ1ZjgxMTZjODBjZGEwMThlNjNiOWRiNjg2MmU3M2E4N2Q", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-23T16:27:18Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-23T16:27:18Z"}, "message": "Rewrite error index generator to greatly reduce the size of the pages", "tree": {"sha": "73f1d1dd225d856745f3c2b9b58303c47e42854c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73f1d1dd225d856745f3c2b9b58303c47e42854c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ad36c45f8116c80cda018e63b9db6862e73a87d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad36c45f8116c80cda018e63b9db6862e73a87d", "html_url": "https://github.com/rust-lang/rust/commit/8ad36c45f8116c80cda018e63b9db6862e73a87d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ad36c45f8116c80cda018e63b9db6862e73a87d/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9bb589cd678e034d194193fa892942315b10e2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9bb589cd678e034d194193fa892942315b10e2a", "html_url": "https://github.com/rust-lang/rust/commit/a9bb589cd678e034d194193fa892942315b10e2a"}], "stats": {"total": 328, "additions": 106, "deletions": 222}, "files": [{"sha": "70b00b36cf1757ec55fd048a6498b6781548fdcd", "filename": "src/tools/error_index_generator/build.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftools%2Ferror_index_generator%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb589cd678e034d194193fa892942315b10e2a/src%2Ftools%2Ferror_index_generator%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fbuild.rs?ref=a9bb589cd678e034d194193fa892942315b10e2a", "patch": "@@ -1,31 +0,0 @@\n-use std::path::PathBuf;\n-use std::{env, fs};\n-use walkdir::WalkDir;\n-\n-fn main() {\n-    // The src directory (we are in src/tools/error_index_generator)\n-    // Note that we could skip one of the .. but this ensures we at least loosely find the right\n-    // directory.\n-    let out_dir = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n-\n-    let error_codes_path = \"../../../compiler/rustc_error_codes/src/error_codes.rs\";\n-\n-    println!(\"cargo:rerun-if-changed={}\", error_codes_path);\n-    let file = fs::read_to_string(error_codes_path)\n-        .unwrap()\n-        .replace(\": include_str!(\\\"./error_codes/\", \": include_str!(\\\"./\");\n-    let contents = format!(\"(|| {{\\n{}\\n}})()\", file);\n-    fs::write(&out_dir.join(\"all_error_codes.rs\"), &contents).unwrap();\n-\n-    // We copy the md files as well to the target directory.\n-    for entry in WalkDir::new(\"../../../compiler/rustc_error_codes/src/error_codes\") {\n-        let entry = entry.unwrap();\n-        match entry.path().extension() {\n-            Some(s) if s == \"md\" => {}\n-            _ => continue,\n-        }\n-        println!(\"cargo:rerun-if-changed={}\", entry.path().to_str().unwrap());\n-        let md_content = fs::read_to_string(entry.path()).unwrap();\n-        fs::write(&out_dir.join(entry.file_name()), &md_content).unwrap();\n-    }\n-}"}, {"sha": "22243f9fc9d6ca9b26fd0067c12df0ac59d34672", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 106, "deletions": 191, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/8ad36c45f8116c80cda018e63b9db6862e73a87d/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ad36c45f8116c80cda018e63b9db6862e73a87d/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=8ad36c45f8116c80cda018e63b9db6862e73a87d", "patch": "@@ -3,11 +3,11 @@\n extern crate rustc_driver;\n extern crate rustc_span;\n \n-use std::cell::RefCell;\n-use std::collections::BTreeMap;\n+use crate::error_codes::error_codes;\n+\n use std::env;\n use std::error::Error;\n-use std::fs::File;\n+use std::fs::{create_dir_all, File};\n use std::io::Write;\n use std::path::Path;\n use std::path::PathBuf;\n@@ -16,49 +16,81 @@ use rustc_span::edition::DEFAULT_EDITION;\n \n use rustdoc::html::markdown::{ErrorCodes, HeadingOffset, IdMap, Markdown, Playground};\n \n-pub struct ErrorMetadata {\n-    pub description: Option<String>,\n+macro_rules! register_diagnostics {\n+    ($($error_code:ident: $message:expr,)+ ; $($undocumented:ident,)* ) => {\n+        pub fn error_codes() -> Vec<(&'static str, Option<&'static str>)> {\n+            let mut errors: Vec<(&str, Option<&str>)> = vec![\n+                $((stringify!($error_code), Some($message)),)+\n+                $((stringify!($undocumented), None),)+\n+            ];\n+            errors.sort();\n+            errors\n+        }\n+    }\n }\n \n-/// Mapping from error codes to metadata that can be (de)serialized.\n-pub type ErrorMetadataMap = BTreeMap<String, ErrorMetadata>;\n+#[path = \"../../../compiler/rustc_error_codes/src/error_codes.rs\"]\n+mod error_codes;\n \n enum OutputFormat {\n     HTML(HTMLFormatter),\n-    Markdown(MarkdownFormatter),\n+    Markdown,\n     Unknown(String),\n }\n \n impl OutputFormat {\n     fn from(format: &str, resource_suffix: &str) -> OutputFormat {\n         match &*format.to_lowercase() {\n-            \"html\" => OutputFormat::HTML(HTMLFormatter(\n-                RefCell::new(IdMap::new()),\n-                resource_suffix.to_owned(),\n-            )),\n-            \"markdown\" => OutputFormat::Markdown(MarkdownFormatter),\n+            \"html\" => OutputFormat::HTML(HTMLFormatter(resource_suffix.to_owned())),\n+            \"markdown\" => OutputFormat::Markdown,\n             s => OutputFormat::Unknown(s.to_owned()),\n         }\n     }\n }\n \n-trait Formatter {\n-    fn header(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>>;\n-    fn title(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>>;\n-    fn error_code_block(\n+struct HTMLFormatter(String);\n+\n+impl HTMLFormatter {\n+    fn create_error_code_file(\n         &self,\n-        output: &mut dyn Write,\n-        info: &ErrorMetadata,\n         err_code: &str,\n-    ) -> Result<(), Box<dyn Error>>;\n-    fn footer(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>>;\n-}\n+        explanation: &str,\n+        parent_dir: &Path,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let mut output_file = File::create(parent_dir.join(err_code).with_extension(\"html\"))?;\n \n-struct HTMLFormatter(RefCell<IdMap>, String);\n-struct MarkdownFormatter;\n+        self.header(&mut output_file, \"../\")?;\n+        self.title(&mut output_file, &format!(\"Error code {}\", err_code))?;\n \n-impl Formatter for HTMLFormatter {\n-    fn header(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n+        let mut id_map = IdMap::new();\n+        let playground =\n+            Playground { crate_name: None, url: String::from(\"https://play.rust-lang.org/\") };\n+        write!(\n+            output_file,\n+            \"{}\",\n+            Markdown {\n+                content: explanation,\n+                links: &[],\n+                ids: &mut id_map,\n+                error_codes: ErrorCodes::Yes,\n+                edition: DEFAULT_EDITION,\n+                playground: &Some(playground),\n+                heading_offset: HeadingOffset::H1,\n+            }\n+            .into_string()\n+        )?;\n+        write!(\n+            output_file,\n+            \"<p>\\\n+                <a style='text-align: center;display: block;width: 100%;' \\\n+                   href='../error-index.html'>Back to list of error codes</a>\\\n+             </p>\",\n+        )?;\n+\n+        self.footer(&mut output_file)\n+    }\n+\n+    fn header(&self, output: &mut dyn Write, extra: &str) -> Result<(), Box<dyn Error>> {\n         write!(\n             output,\n             r##\"<!DOCTYPE html>\n@@ -67,9 +99,9 @@ impl Formatter for HTMLFormatter {\n <title>Rust Compiler Error Index</title>\n <meta charset=\"utf-8\">\n <!-- Include rust.css after light.css so its rules take priority. -->\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"rustdoc{suffix}.css\"/>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"light{suffix}.css\"/>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"rust.css\"/>\n+<link rel=\"stylesheet\" type=\"text/css\" href=\"{extra}rustdoc{suffix}.css\"/>\n+<link rel=\"stylesheet\" type=\"text/css\" href=\"{extra}light{suffix}.css\"/>\n+<link rel=\"stylesheet\" type=\"text/css\" href=\"{extra}rust.css\"/>\n <style>\n .error-undescribed {{\n     display: none;\n@@ -78,177 +110,80 @@ impl Formatter for HTMLFormatter {\n </head>\n <body>\n \"##,\n-            suffix = self.1\n+            suffix = self.0,\n         )?;\n         Ok(())\n     }\n \n-    fn title(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n-        write!(output, \"<h1>Rust Compiler Error Index</h1>\\n\")?;\n-        Ok(())\n-    }\n-\n-    fn error_code_block(\n-        &self,\n-        output: &mut dyn Write,\n-        info: &ErrorMetadata,\n-        err_code: &str,\n-    ) -> Result<(), Box<dyn Error>> {\n-        // Enclose each error in a div so they can be shown/hidden en masse.\n-        let desc_desc = match info.description {\n-            Some(_) => \"error-described\",\n-            None => \"error-undescribed\",\n-        };\n-        write!(output, \"<div class=\\\"{}\\\">\", desc_desc)?;\n-\n-        // Error title (with self-link).\n-        write!(\n-            output,\n-            \"<h2 id=\\\"{0}\\\" class=\\\"section-header\\\"><a href=\\\"#{0}\\\">{0}</a></h2>\\n\",\n-            err_code\n-        )?;\n-\n-        // Description rendered as markdown.\n-        match info.description {\n-            Some(ref desc) => {\n-                let mut id_map = self.0.borrow_mut();\n-                let playground = Playground {\n-                    crate_name: None,\n-                    url: String::from(\"https://play.rust-lang.org/\"),\n-                };\n-                write!(\n-                    output,\n-                    \"{}\",\n-                    Markdown {\n-                        content: desc,\n-                        links: &[],\n-                        ids: &mut id_map,\n-                        error_codes: ErrorCodes::Yes,\n-                        edition: DEFAULT_EDITION,\n-                        playground: &Some(playground),\n-                        heading_offset: HeadingOffset::H1,\n-                    }\n-                    .into_string()\n-                )?\n-            }\n-            None => write!(output, \"<p>No description.</p>\\n\")?,\n-        }\n-\n-        write!(output, \"</div>\\n\")?;\n+    fn title(&self, output: &mut dyn Write, title: &str) -> Result<(), Box<dyn Error>> {\n+        write!(output, \"<h1>{}</h1>\\n\", title)?;\n         Ok(())\n     }\n \n     fn footer(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n-        write!(\n-            output,\n-            r##\"<script>\n-function onEach(arr, func) {{\n-    if (arr && arr.length > 0 && func) {{\n-        var length = arr.length;\n-        var i;\n-        for (i = 0; i < length; ++i) {{\n-            if (func(arr[i])) {{\n-                return true;\n-            }}\n-        }}\n-    }}\n-    return false;\n-}}\n-\n-function onEachLazy(lazyArray, func) {{\n-    return onEach(\n-        Array.prototype.slice.call(lazyArray),\n-        func);\n-}}\n-\n-function hasClass(elem, className) {{\n-    return elem && elem.classList && elem.classList.contains(className);\n-}}\n-\n-onEachLazy(document.getElementsByClassName('rust-example-rendered'), function(e) {{\n-    if (hasClass(e, 'compile_fail')) {{\n-        e.addEventListener(\"mouseover\", function(event) {{\n-            e.parentElement.previousElementSibling.childNodes[0].style.color = '#f00';\n-        }});\n-        e.addEventListener(\"mouseout\", function(event) {{\n-            e.parentElement.previousElementSibling.childNodes[0].style.color = '';\n-        }});\n-    }} else if (hasClass(e, 'ignore')) {{\n-        e.addEventListener(\"mouseover\", function(event) {{\n-            e.parentElement.previousElementSibling.childNodes[0].style.color = '#ff9200';\n-        }});\n-        e.addEventListener(\"mouseout\", function(event) {{\n-            e.parentElement.previousElementSibling.childNodes[0].style.color = '';\n-        }});\n-    }}\n-}});\n-</script>\n-</body>\n-</html>\"##\n-        )?;\n+        write!(output, \"</body></html>\")?;\n         Ok(())\n     }\n }\n \n-impl Formatter for MarkdownFormatter {\n-    #[allow(unused_variables)]\n-    fn header(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n-        Ok(())\n-    }\n+/// Output an HTML page for the errors in `err_map` to `output_path`.\n+fn render_markdown(output_path: &Path) -> Result<(), Box<dyn Error>> {\n+    let mut output_file = File::create(output_path)?;\n \n-    fn title(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n-        write!(output, \"# Rust Compiler Error Index\\n\")?;\n-        Ok(())\n-    }\n+    write!(output_file, \"# Rust Compiler Error Index\\n\")?;\n \n-    fn error_code_block(\n-        &self,\n-        output: &mut dyn Write,\n-        info: &ErrorMetadata,\n-        err_code: &str,\n-    ) -> Result<(), Box<dyn Error>> {\n-        Ok(match info.description {\n-            Some(ref desc) => write!(output, \"## {}\\n{}\\n\", err_code, desc)?,\n-            None => (),\n-        })\n+    for (err_code, description) in error_codes().iter() {\n+        match description {\n+            Some(ref desc) => write!(output_file, \"## {}\\n{}\\n\", err_code, desc)?,\n+            None => {}\n+        }\n     }\n \n-    #[allow(unused_variables)]\n-    fn footer(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>> {\n-        Ok(())\n-    }\n+    Ok(())\n }\n \n-/// Output an HTML page for the errors in `err_map` to `output_path`.\n-fn render_error_page<T: Formatter>(\n-    err_map: &ErrorMetadataMap,\n-    output_path: &Path,\n-    formatter: T,\n-) -> Result<(), Box<dyn Error>> {\n+fn render_html(output_path: &Path, formatter: HTMLFormatter) -> Result<(), Box<dyn Error>> {\n     let mut output_file = File::create(output_path)?;\n \n-    formatter.header(&mut output_file)?;\n-    formatter.title(&mut output_file)?;\n+    let error_codes_dir = \"error_codes\";\n+\n+    let parent = output_path.parent().expect(\"There should have a parent\").join(error_codes_dir);\n \n-    for (err_code, info) in err_map {\n-        formatter.error_code_block(&mut output_file, info, err_code)?;\n+    if !parent.exists() {\n+        create_dir_all(&parent)?;\n     }\n \n+    formatter.header(&mut output_file, \"\")?;\n+    formatter.title(&mut output_file, \"Rust Compiler Error Index\")?;\n+\n+    write!(\n+        output_file,\n+        \"<p>This page lists all the error codes emitted by the Rust compiler. If you want a full \\\n+            explanation on an error code, click on it.</p>\\\n+         <ul>\",\n+    )?;\n+    for (err_code, explanation) in error_codes().iter() {\n+        if let Some(explanation) = explanation {\n+            write!(\n+                output_file,\n+                \"<li><a href='./{0}/{1}.html'>{1}</a></li>\",\n+                error_codes_dir, err_code\n+            )?;\n+            formatter.create_error_code_file(err_code, explanation, &parent)?;\n+        } else {\n+            write!(output_file, \"<li>{}</li>\", err_code)?;\n+        }\n+    }\n+    write!(output_file, \"</ul>\")?;\n     formatter.footer(&mut output_file)\n }\n \n fn main_with_result(format: OutputFormat, dst: &Path) -> Result<(), Box<dyn Error>> {\n-    let long_codes = register_all();\n-    let mut err_map = BTreeMap::new();\n-    for (code, desc) in long_codes {\n-        err_map.insert(code.to_string(), ErrorMetadata { description: desc.map(String::from) });\n-    }\n     match format {\n         OutputFormat::Unknown(s) => panic!(\"Unknown output format: {}\", s),\n-        OutputFormat::HTML(h) => render_error_page(&err_map, dst, h)?,\n-        OutputFormat::Markdown(m) => render_error_page(&err_map, dst, m)?,\n+        OutputFormat::HTML(h) => render_html(dst, h),\n+        OutputFormat::Markdown => render_markdown(dst),\n     }\n-    Ok(())\n }\n \n fn parse_args() -> (OutputFormat, PathBuf) {\n@@ -261,7 +196,7 @@ fn parse_args() -> (OutputFormat, PathBuf) {\n         .unwrap_or(OutputFormat::from(\"html\", &resource_suffix));\n     let dst = dst.map(PathBuf::from).unwrap_or_else(|| match format {\n         OutputFormat::HTML(..) => PathBuf::from(\"doc/error-index.html\"),\n-        OutputFormat::Markdown(..) => PathBuf::from(\"doc/error-index.md\"),\n+        OutputFormat::Markdown => PathBuf::from(\"doc/error-index.md\"),\n         OutputFormat::Unknown(..) => PathBuf::from(\"<nul>\"),\n     });\n     (format, dst)\n@@ -276,23 +211,3 @@ fn main() {\n         panic!(\"{}\", e.to_string());\n     }\n }\n-\n-fn register_all() -> Vec<(&'static str, Option<&'static str>)> {\n-    let mut long_codes: Vec<(&'static str, Option<&'static str>)> = Vec::new();\n-    macro_rules! register_diagnostics {\n-        ($($ecode:ident: $message:expr,)* ; $($code:ident,)*) => (\n-            $(\n-                {long_codes.extend([\n-                    (stringify!($ecode), Some($message)),\n-                ].iter());}\n-            )*\n-            $(\n-                {long_codes.extend([\n-                    stringify!($code),\n-                ].iter().cloned().map(|s| (s, None)).collect::<Vec<_>>());}\n-            )*\n-        )\n-    }\n-    include!(concat!(env!(\"OUT_DIR\"), \"/all_error_codes.rs\"));\n-    long_codes\n-}"}]}