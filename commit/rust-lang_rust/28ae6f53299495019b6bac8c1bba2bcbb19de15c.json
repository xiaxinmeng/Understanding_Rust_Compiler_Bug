{"sha": "28ae6f53299495019b6bac8c1bba2bcbb19de15c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YWU2ZjUzMjk5NDk1MDE5YjZiYWM4YzFiYmEyYmNiYjE5ZGUxNWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-31T07:51:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-31T07:51:38Z"}, "message": "auto merge of #15385 : jroweboy/rust/master, r=brson\n\nThis enables the docs search function to be more forgiving for spelling mistakes. The algorithm works as a dynamic programming algorithm to detect the minimum number of changes required to the search parameter string in order to match any string in the search index. If the number of changes is less then a threshold (currently defined as 3), then the search parameter will be included as it is a possible misspelling of the word. Any results returned by the algorithm are sorted by distance and are ranked lower than results that are partial or exact matches (aka the matches returned by the original search algorithm). Additionally, the increment in the for loops in this file were using one of three different ways to increment (`i += 1` `i++` and `++i`) so I just standardized it to `++i`.\r\n\r\nAs an example, consider searching for the word `String` and accidentally typing in `Strnig`. The old system would return no results because it is a misspelling, but the Levenshtein distance between these two inputs is only two, which means that this will return `String` as a result. Additionally, it will return a few other results such as `strong`, and `StdRng` because these are also similar to `Strnig`. Because of the ranking system though, this change should be unobtrusive to anyone that spells the words correctly, as those are still ranked first before any Levenshtein results.", "tree": {"sha": "aabe9db990f3d8225ce56700b892bad2faf8d0cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aabe9db990f3d8225ce56700b892bad2faf8d0cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28ae6f53299495019b6bac8c1bba2bcbb19de15c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28ae6f53299495019b6bac8c1bba2bcbb19de15c", "html_url": "https://github.com/rust-lang/rust/commit/28ae6f53299495019b6bac8c1bba2bcbb19de15c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28ae6f53299495019b6bac8c1bba2bcbb19de15c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c28dd080ce4253d8b0126d6cf9bfc2ba0004cf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c28dd080ce4253d8b0126d6cf9bfc2ba0004cf8", "html_url": "https://github.com/rust-lang/rust/commit/7c28dd080ce4253d8b0126d6cf9bfc2ba0004cf8"}, {"sha": "c614510ddb0eca24ee102511feb69a159238a996", "url": "https://api.github.com/repos/rust-lang/rust/commits/c614510ddb0eca24ee102511feb69a159238a996", "html_url": "https://github.com/rust-lang/rust/commit/c614510ddb0eca24ee102511feb69a159238a996"}], "stats": {"total": 133, "additions": 89, "deletions": 44}, "files": [{"sha": "8688e031890b91315a2dad053da5f117836a986b", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 89, "deletions": 44, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/28ae6f53299495019b6bac8c1bba2bcbb19de15c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/28ae6f53299495019b6bac8c1bba2bcbb19de15c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=28ae6f53299495019b6bac8c1bba2bcbb19de15c", "patch": "@@ -61,7 +61,7 @@\n             }\n             $('#' + from)[0].scrollIntoView();\n             $('.line-numbers span').removeClass('line-highlighted');\n-            for (i = from; i <= to; i += 1) {\n+            for (i = from; i <= to; ++i) {\n                 $('#' + i).addClass('line-highlighted');\n             }\n         }\n@@ -102,7 +102,7 @@\n             stripped = '',\n             len = rootPath.match(/\\.\\.\\//g).length + 1;\n \n-        for (i = 0; i < len; i += 1) {\n+        for (i = 0; i < len; ++i) {\n             match = url.match(/\\/[^\\/]*$/);\n             if (i < len - 1) {\n                 stripped = match[0] + stripped;\n@@ -114,9 +114,47 @@\n \n         document.location.href = url;\n     });\n+    /**\n+     * A function to compute the Levenshtein distance between two strings\n+     * Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported\n+     * Full License can be found at http://creativecommons.org/licenses/by-sa/3.0/legalcode\n+     * This code is an unmodified version of the code written by Marco de Wit \n+     * and was found at http://stackoverflow.com/a/18514751/745719\n+     */\n+    var levenshtein = (function() {\n+        var row2 = [];\n+        return function(s1, s2) {\n+            if (s1 === s2) {\n+                return 0;\n+            } else {\n+                var s1_len = s1.length, s2_len = s2.length;\n+                if (s1_len && s2_len) {\n+                    var i1 = 0, i2 = 0, a, b, c, c2, row = row2;\n+                    while (i1 < s1_len)\n+                        row[i1] = ++i1;\n+                    while (i2 < s2_len) {\n+                        c2 = s2.charCodeAt(i2);\n+                        a = i2;\n+                        ++i2;\n+                        b = i2;\n+                        for (i1 = 0; i1 < s1_len; ++i1) {\n+                            c = a + (s1.charCodeAt(i1) !== c2 ? 1 : 0);\n+                            a = row[i1];\n+                            b = b < a ? (b < c ? b + 1 : c) : (a < c ? a + 1 : c);\n+                            row[i1] = b;\n+                        }\n+                    }\n+                    return b;\n+                } else {\n+                    return s1_len + s2_len;\n+                }\n+            }\n+        };\n+    })();\n \n     function initSearch(rawSearchIndex) {\n         var currentResults, index, searchIndex;\n+        var MAX_LEV_DISTANCE = 3;\n         var params = getQueryStringParams();\n \n         // Populate search bar with query string search term when provided,\n@@ -143,7 +181,7 @@\n                 split = valLower.split(\"::\");\n \n             //remove empty keywords\n-            for (var j = 0; j < split.length; j++) {\n+            for (var j = 0; j < split.length; ++j) {\n                 split[j].toLowerCase();\n                 if (split[j] === \"\") {\n                     split.splice(j, 1);\n@@ -156,7 +194,7 @@\n                 val.charAt(val.length - 1) === val.charAt(0))\n             {\n                 val = val.substr(1, val.length - 2);\n-                for (var i = 0; i < nSearchWords; i += 1) {\n+                for (var i = 0; i < nSearchWords; ++i) {\n                     if (searchWords[i] === val) {\n                         // filter type: ... queries\n                         if (typeFilter < 0 || typeFilter === searchIndex[i].ty) {\n@@ -170,15 +208,31 @@\n             } else {\n                 // gather matching search results up to a certain maximum\n                 val = val.replace(/\\_/g, \"\");\n-                for (var i = 0; i < split.length; i++) {\n-                    for (var j = 0; j < nSearchWords; j += 1) {\n+                for (var i = 0; i < split.length; ++i) {\n+                    for (var j = 0; j < nSearchWords; ++j) {\n+                        var lev_distance;\n                         if (searchWords[j].indexOf(split[i]) > -1 ||\n                             searchWords[j].indexOf(val) > -1 ||\n                             searchWords[j].replace(/_/g, \"\").indexOf(val) > -1)\n                         {\n                             // filter type: ... queries\n                             if (typeFilter < 0 || typeFilter === searchIndex[j].ty) {\n-                                results.push({id: j, index: searchWords[j].replace(/_/g, \"\").indexOf(val)});\n+                                results.push({\n+                                    id: j,\n+                                    index: searchWords[j].replace(/_/g, \"\").indexOf(val),\n+                                    lev: 0,\n+                                });\n+                            }\n+                        } else if (\n+                            (lev_distance = levenshtein(searchWords[j], val)) <= \n+                                MAX_LEV_DISTANCE) {\n+                            if (typeFilter < 0 || typeFilter === searchIndex[j].ty) {\n+                                results.push({\n+                                    id: j,\n+                                    index: 0,\n+                                    // we want lev results to go lower than others\n+                                    lev: lev_distance,\n+                                });\n                             }\n                         }\n                         if (results.length === max) {\n@@ -189,7 +243,7 @@\n             }\n \n             var nresults = results.length;\n-            for (var i = 0; i < nresults; i += 1) {\n+            for (var i = 0; i < nresults; ++i) {\n                 results[i].word = searchWords[results[i].id];\n                 results[i].item = searchIndex[results[i].id] || {};\n             }\n@@ -201,6 +255,12 @@\n             results.sort(function(aaa, bbb) {\n                 var a, b;\n \n+                // Sort by non levenshtein results and then levenshtein results by the distance\n+                // (less changes required to match means higher rankings)\n+                a = (aaa.lev);\n+                b = (bbb.lev);\n+                if (a !== b) return a - b;\n+\n                 // sort by crate (non-current crate goes later)\n                 a = (aaa.item.crate !== window.currentCrate);\n                 b = (bbb.item.crate !== window.currentCrate);\n@@ -258,7 +318,7 @@\n                     results[i].id = -1;\n                 }\n             }\n-            for (var i = 0; i < results.length; i++) {\n+            for (var i = 0; i < results.length; ++i) {\n                 var result = results[i],\n                     name = result.item.name.toLowerCase(),\n                     path = result.item.path.toLowerCase(),\n@@ -288,38 +348,23 @@\n          * @return {[boolean]}       [Whether the result is valid or not]\n          */\n         function validateResult(name, path, keys, parent) {\n-            //initially valid\n-            var validate = true;\n-            //if there is a parent, then validate against parent\n-            if (parent !== undefined) {\n-                for (var i = 0; i < keys.length; i++) {\n-                    // if previous keys are valid and current key is in the\n-                    // path, name or parent\n-                    if ((validate) &&\n-                        (name.toLowerCase().indexOf(keys[i]) > -1 ||\n-                         path.toLowerCase().indexOf(keys[i]) > -1 ||\n-                         parent.name.toLowerCase().indexOf(keys[i]) > -1))\n-                    {\n-                        validate = true;\n-                    } else {\n-                        validate = false;\n-                    }\n-                }\n-            } else {\n-                for (var i = 0; i < keys.length; i++) {\n-                    // if previous keys are valid and current key is in the\n-                    // path, name\n-                    if ((validate) &&\n-                        (name.toLowerCase().indexOf(keys[i]) > -1 ||\n-                         path.toLowerCase().indexOf(keys[i]) > -1))\n-                    {\n-                        validate = true;\n-                    } else {\n-                        validate = false;\n-                    }\n+            for (var i=0; i < keys.length; ++i) {\n+                // each check is for validation so we negate the conditions and invalidate\n+                if (!( \n+                    // check for an exact name match\n+                    name.toLowerCase().indexOf(keys[i]) > -1 ||\n+                    // then an exact path match\n+                    path.toLowerCase().indexOf(keys[i]) > -1 ||\n+                    // next if there is a parent, check for exact parent match\n+                    (parent !== undefined && \n+                        parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n+                    // lastly check to see if the name was a levenshtein match\n+                    levenshtein(name.toLowerCase(), keys[i]) <= \n+                        MAX_LEV_DISTANCE)) {\n+                    return false;\n                 }\n             }\n-            return validate;\n+            return true;\n         }\n \n         function getQuery() {\n@@ -499,7 +544,7 @@\n \n             resultIndex = execQuery(query, 20000, index);\n             len = resultIndex.length;\n-            for (i = 0; i < len; i += 1) {\n+            for (i = 0; i < len; ++i) {\n                 if (resultIndex[i].id > -1) {\n                     obj = searchIndex[resultIndex[i].id];\n                     filterdata.push([obj.name, obj.ty, obj.path, obj.desc]);\n@@ -571,7 +616,7 @@\n                 // faster analysis operations\n                 var len = items.length;\n                 var lastPath = \"\";\n-                for (var i = 0; i < len; i += 1) {\n+                for (var i = 0; i < len; ++i) {\n                     var rawRow = items[i];\n                     var row = {crate: crate, ty: rawRow[0], name: rawRow[1],\n                                path: rawRow[2] || lastPath, desc: rawRow[3],\n@@ -643,7 +688,7 @@\n                 crates.push(crate);\n             }\n             crates.sort();\n-            for (var i = 0; i < crates.length; i++) {\n+            for (var i = 0; i < crates.length; ++i) {\n                 var klass = 'crate';\n                 if (crates[i] == window.currentCrate) {\n                     klass += ' current';\n@@ -660,10 +705,10 @@\n     window.register_implementors = function(imp) {\n         var list = $('#implementors-list');\n         var libs = Object.getOwnPropertyNames(imp);\n-        for (var i = 0; i < libs.length; i++) {\n+        for (var i = 0; i < libs.length; ++i) {\n             if (libs[i] == currentCrate) continue;\n             var structs = imp[libs[i]];\n-            for (var j = 0; j < structs.length; j++) {\n+            for (var j = 0; j < structs.length; ++j) {\n                 var code = $('<code>').append(structs[j]);\n                 $.each(code.find('a'), function(idx, a) {\n                     var href = $(a).attr('href');"}]}