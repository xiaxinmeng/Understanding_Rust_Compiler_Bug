{"sha": "4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjM2U5NWU4NGIwOTI0ZjBiN2U0NWEyYmIxYzc0ZjNkN2JlYzQ2OTE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-11T09:10:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-11T09:10:44Z"}, "message": "Rollup merge of #67074 - ehuss:extern-options, r=petrochenkov\n\nAdd options to --extern flag.\n\nThis changes the `--extern` flag so that it can take a series of options that changes its behavior. The general syntax is `[opts ':'] name ['=' path]` where `opts` is a comma separated list of options. Two options are supported, `priv` which replaces `--extern-private` and `noprelude` which avoids adding the crate to the extern prelude.\n\n```text\n--extern priv:mylib=/path/to/libmylib.rlib\n--extern noprelude:alloc=/path/to/liballoc.rlib\n```\n\n`noprelude` is to be used by Cargo's build-std feature in order to use `--extern` to reference standard library crates.\n\nThis also includes a second commit which adds the `aux-crate` directive to compiletest. I can split this off into a separate PR if desired, but it helps with defining these kinds of tests. It is based on #54020, and can be used in the future to replace and simplify some of the Makefile tests.", "tree": {"sha": "f32ac318e97210fb64d874b9c4c2b4292074f333", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f32ac318e97210fb64d874b9c4c2b4292074f333"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd8LKUCRBK7hj4Ov3rIwAAdHIIABGMZwIG4eKkbHMghaXCv6Tf\n2ySeZlsddokg7l6hQRSs2MF3tavJ8A/Ss690g4eJxb9Ey6AK5BzkbPyG8+atnw4R\naWWN3d55XNQhfkU5Xl4fbDNPIJlaLWI9Yx9+J7f7O+MAiry4hFC+95iMdKvj7nog\np+jnOq4df4rx7T/9TLsyVb3EMrkZPRIjJ30eLjGwdKAcBrCRHdfPhNFwsxi7jwo/\ne76e2tTHC8EnE9VIYKVrnbWhQqe0+oY/oQdAbpcTBfJlhI6ac6XuIXtugk2MyIA7\nMF8s7vexts2QAoLgVG3sqe1COLJS4bBOq3uF8WD+NOsyQSS1z3yEUMtTkmxDlag=\n=jsWt\n-----END PGP SIGNATURE-----\n", "payload": "tree f32ac318e97210fb64d874b9c4c2b4292074f333\nparent 04e0512c7a94736e104e5d25a4705c37fa93a7e2\nparent 60d4e20ff07ac4546f47f09094c7c04b577f0966\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576055444 +0100\ncommitter GitHub <noreply@github.com> 1576055444 +0100\n\nRollup merge of #67074 - ehuss:extern-options, r=petrochenkov\n\nAdd options to --extern flag.\n\nThis changes the `--extern` flag so that it can take a series of options that changes its behavior. The general syntax is `[opts ':'] name ['=' path]` where `opts` is a comma separated list of options. Two options are supported, `priv` which replaces `--extern-private` and `noprelude` which avoids adding the crate to the extern prelude.\n\n```text\n--extern priv:mylib=/path/to/libmylib.rlib\n--extern noprelude:alloc=/path/to/liballoc.rlib\n```\n\n`noprelude` is to be used by Cargo's build-std feature in order to use `--extern` to reference standard library crates.\n\nThis also includes a second commit which adds the `aux-crate` directive to compiletest. I can split this off into a separate PR if desired, but it helps with defining these kinds of tests. It is based on #54020, and can be used in the future to replace and simplify some of the Makefile tests.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "html_url": "https://github.com/rust-lang/rust/commit/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04e0512c7a94736e104e5d25a4705c37fa93a7e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/04e0512c7a94736e104e5d25a4705c37fa93a7e2", "html_url": "https://github.com/rust-lang/rust/commit/04e0512c7a94736e104e5d25a4705c37fa93a7e2"}, {"sha": "60d4e20ff07ac4546f47f09094c7c04b577f0966", "url": "https://api.github.com/repos/rust-lang/rust/commits/60d4e20ff07ac4546f47f09094c7c04b577f0966", "html_url": "https://github.com/rust-lang/rust/commit/60d4e20ff07ac4546f47f09094c7c04b577f0966"}], "stats": {"total": 559, "additions": 363, "deletions": 196}, "files": [{"sha": "d4b5e833dfb23df34cf3304089b6df867c008b6a", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -7,7 +7,7 @@ use rustc::middle::cstore;\n use rustc::session::config::{build_configuration, build_session_options, to_crate_config};\n use rustc::session::config::{LtoCli, LinkerPluginLto, SwitchWithOptPath, ExternEntry};\n use rustc::session::config::{Externs, OutputType, OutputTypes, SymbolManglingVersion};\n-use rustc::session::config::{rustc_optgroups, Options, ErrorOutputType, Passes};\n+use rustc::session::config::{rustc_optgroups, Options, ErrorOutputType, Passes, ExternLocation};\n use rustc::session::{build_session, Session};\n use rustc::session::search_paths::SearchPath;\n use std::collections::{BTreeMap, BTreeSet};\n@@ -38,14 +38,15 @@ fn mk_session(matches: getopts::Matches) -> (Session, CfgSpecs) {\n fn new_public_extern_entry<S, I>(locations: I) -> ExternEntry\n where\n     S: Into<String>,\n-    I: IntoIterator<Item = Option<S>>,\n+    I: IntoIterator<Item = S>,\n {\n-    let locations: BTreeSet<_> = locations.into_iter().map(|o| o.map(|s| s.into()))\n+    let locations: BTreeSet<_> = locations.into_iter().map(|s| s.into())\n         .collect();\n \n     ExternEntry {\n-        locations,\n-        is_private_dep: false\n+        location: ExternLocation::ExactPaths(locations),\n+        is_private_dep: false,\n+        add_prelude: true,\n     }\n }\n \n@@ -160,33 +161,33 @@ fn test_externs_tracking_hash_different_construction_order() {\n     v1.externs = Externs::new(mk_map(vec![\n         (\n             String::from(\"a\"),\n-            new_public_extern_entry(vec![Some(\"b\"), Some(\"c\")])\n+            new_public_extern_entry(vec![\"b\", \"c\"])\n         ),\n         (\n             String::from(\"d\"),\n-            new_public_extern_entry(vec![Some(\"e\"), Some(\"f\")])\n+            new_public_extern_entry(vec![\"e\", \"f\"])\n         ),\n     ]));\n \n     v2.externs = Externs::new(mk_map(vec![\n         (\n             String::from(\"d\"),\n-            new_public_extern_entry(vec![Some(\"e\"), Some(\"f\")])\n+            new_public_extern_entry(vec![\"e\", \"f\"])\n         ),\n         (\n             String::from(\"a\"),\n-            new_public_extern_entry(vec![Some(\"b\"), Some(\"c\")])\n+            new_public_extern_entry(vec![\"b\", \"c\"])\n         ),\n     ]));\n \n     v3.externs = Externs::new(mk_map(vec![\n         (\n             String::from(\"a\"),\n-            new_public_extern_entry(vec![Some(\"b\"), Some(\"c\")])\n+            new_public_extern_entry(vec![\"b\", \"c\"])\n         ),\n         (\n             String::from(\"d\"),\n-            new_public_extern_entry(vec![Some(\"f\"), Some(\"e\")])\n+            new_public_extern_entry(vec![\"f\", \"e\"])\n         ),\n     ]));\n "}, {"sha": "0a0f2560b994fb5742f02fcee2a5b0d82e1dc4c5", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -218,13 +218,14 @@ impl<'a> CrateLoader<'a> {\n             let source = self.cstore.get_crate_data(cnum).source();\n             if let Some(entry) = self.sess.opts.externs.get(&name.as_str()) {\n                 // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n-                let found = entry.locations.iter().filter_map(|l| l.as_ref()).any(|l| {\n-                    let l = fs::canonicalize(l).ok();\n-                    source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n-                    source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n-                });\n-                if found {\n-                    ret = Some(cnum);\n+                if let Some(mut files) = entry.files() {\n+                    if files.any(|l| {\n+                        let l = fs::canonicalize(l).ok();\n+                        source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n+                        source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n+                    }) {\n+                        ret = Some(cnum);\n+                    }\n                 }\n                 return\n             }"}, {"sha": "8a1eeea02512e89f30693a62a075f4d79d1a6c25", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -328,8 +328,9 @@ impl<'a> CrateLocator<'a> {\n             crate_name,\n             exact_paths: if hash.is_none() {\n                 sess.opts.externs.get(&crate_name.as_str()).into_iter()\n-                    .flat_map(|entry| entry.locations.iter())\n-                    .filter_map(|location| location.clone().map(PathBuf::from)).collect()\n+                    .filter_map(|entry| entry.files())\n+                    .flatten()\n+                    .map(|location| PathBuf::from(location)).collect()\n             } else {\n                 // SVH being specified means this is a transitive dependency,\n                 // so `--extern` options do not apply."}, {"sha": "d3656248b1b09af8b0eb8da552d5b3965822499a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -1136,8 +1136,10 @@ impl<'a> Resolver<'a> {\n         definitions.create_root_def(crate_name, session.local_crate_disambiguator());\n \n         let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> =\n-            session.opts.externs.iter().map(|kv| (Ident::from_str(kv.0), Default::default()))\n-                                       .collect();\n+            session.opts.externs.iter()\n+                .filter(|(_, entry)| entry.add_prelude)\n+                .map(|(name, _)| (Ident::from_str(name), Default::default()))\n+                .collect();\n \n         if !attr::contains_name(&krate.attrs, sym::no_core) {\n             extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());"}, {"sha": "7f3bab8f23299b0041127dadd3fddcb0f7a57a6e", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 132, "deletions": 37, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -1,3 +1,5 @@\n+// ignore-tidy-filelength\n+\n //! Contains infrastructure for configuring the compiler, including parsing\n //! command-line options.\n \n@@ -31,7 +33,7 @@ use std::fmt;\n use std::str::{self, FromStr};\n use std::hash::Hasher;\n use std::collections::hash_map::DefaultHasher;\n-use std::iter::FromIterator;\n+use std::iter::{self, FromIterator};\n use std::path::{Path, PathBuf};\n \n pub struct Config {\n@@ -322,10 +324,35 @@ impl OutputTypes {\n #[derive(Clone)]\n pub struct Externs(BTreeMap<String, ExternEntry>);\n \n-#[derive(Clone, Debug, Default)]\n+#[derive(Clone, Debug)]\n pub struct ExternEntry {\n-    pub locations: BTreeSet<Option<String>>,\n-    pub is_private_dep: bool\n+    pub location: ExternLocation,\n+    /// Indicates this is a \"private\" dependency for the\n+    /// `exported_private_dependencies` lint.\n+    ///\n+    /// This can be set with the `priv` option like\n+    /// `--extern priv:name=foo.rlib`.\n+    pub is_private_dep: bool,\n+    /// Add the extern entry to the extern prelude.\n+    ///\n+    /// This can be disabled with the `noprelude` option like\n+    /// `--extern noprelude:name`.\n+    pub add_prelude: bool,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum ExternLocation {\n+    /// Indicates to look for the library in the search paths.\n+    ///\n+    /// Added via `--extern name`.\n+    FoundInLibrarySearchDirectories,\n+    /// The locations where this extern entry must be found.\n+    ///\n+    /// The `CrateLoader` is responsible for loading these and figuring out\n+    /// which one to use.\n+    ///\n+    /// Added via `--extern prelude_name=some_file.rlib`\n+    ExactPaths(BTreeSet<String>),\n }\n \n impl Externs {\n@@ -342,6 +369,18 @@ impl Externs {\n     }\n }\n \n+impl ExternEntry {\n+    fn new(location: ExternLocation) -> ExternEntry {\n+        ExternEntry { location, is_private_dep: false, add_prelude: false }\n+    }\n+\n+    pub fn files(&self) -> Option<impl Iterator<Item = &String>> {\n+        match &self.location {\n+            ExternLocation::ExactPaths(set) => Some(set.iter()),\n+            _ => None,\n+        }\n+    }\n+}\n \n macro_rules! hash_option {\n     ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [UNTRACKED]) => ({});\n@@ -1869,12 +1908,6 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n             \"Specify where an external rust library is located\",\n             \"NAME[=PATH]\",\n         ),\n-        opt::multi_s(\n-            \"\",\n-            \"extern-private\",\n-            \"Specify where an extern rust library is located, marking it as a private dependency\",\n-            \"NAME=PATH\",\n-        ),\n         opt::opt_s(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n         opt::multi(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n         opt::opt_s(\n@@ -2435,43 +2468,105 @@ fn parse_borrowck_mode(dopts: &DebuggingOptions, error_format: ErrorOutputType)\n     }\n }\n \n-fn parse_externs(\n+pub fn parse_externs(\n     matches: &getopts::Matches,\n     debugging_opts: &DebuggingOptions,\n     error_format: ErrorOutputType,\n ) -> Externs {\n-    if matches.opt_present(\"extern-private\") && !debugging_opts.unstable_options {\n-        early_error(\n-            ErrorOutputType::default(),\n-            \"'--extern-private' is unstable and only \\\n-            available for nightly builds of rustc.\"\n-        )\n-    }\n-\n-    // We start out with a `Vec<(Option<String>, bool)>>`,\n-    // and later convert it into a `BTreeSet<(Option<String>, bool)>`\n-    // This allows to modify entries in-place to set their correct\n-    // 'public' value.\n+    let is_unstable_enabled = debugging_opts.unstable_options;\n     let mut externs: BTreeMap<String, ExternEntry> = BTreeMap::new();\n-    for (arg, private) in matches.opt_strs(\"extern\").into_iter().map(|v| (v, false))\n-        .chain(matches.opt_strs(\"extern-private\").into_iter().map(|v| (v, true))) {\n-\n+    for arg in matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(2, '=');\n-        let name = parts.next().unwrap_or_else(||\n-            early_error(error_format, \"--extern value must not be empty\"));\n-        let location = parts.next().map(|s| s.to_string());\n+        let name = parts\n+            .next()\n+            .unwrap_or_else(|| early_error(error_format, \"--extern value must not be empty\"));\n+        let path = parts.next().map(|s| s.to_string());\n+\n+        let mut name_parts = name.splitn(2, ':');\n+        let first_part = name_parts.next();\n+        let second_part = name_parts.next();\n+        let (options, name) = match (first_part, second_part) {\n+            (Some(opts), Some(name)) => (Some(opts), name),\n+            (Some(name), None) => (None, name),\n+            (None, None) => early_error(error_format, \"--extern name must not be empty\"),\n+            _ => unreachable!(),\n+        };\n+\n+        let entry = externs.entry(name.to_owned());\n \n-        let entry = externs\n-            .entry(name.to_owned())\n-            .or_default();\n+        use std::collections::btree_map::Entry;\n \n+        let entry = if let Some(path) = path {\n+            // --extern prelude_name=some_file.rlib\n+            match entry {\n+                Entry::Vacant(vacant) => {\n+                    let files = BTreeSet::from_iter(iter::once(path));\n+                    vacant.insert(ExternEntry::new(ExternLocation::ExactPaths(files)))\n+                }\n+                Entry::Occupied(occupied) => {\n+                    let ext_ent = occupied.into_mut();\n+                    match ext_ent {\n+                        ExternEntry { location: ExternLocation::ExactPaths(files), .. } => {\n+                            files.insert(path);\n+                        }\n+                        ExternEntry {\n+                            location: location @ ExternLocation::FoundInLibrarySearchDirectories,\n+                            ..\n+                        } => {\n+                            // Exact paths take precedence over search directories.\n+                            let files = BTreeSet::from_iter(iter::once(path));\n+                            *location = ExternLocation::ExactPaths(files);\n+                        }\n+                    }\n+                    ext_ent\n+                }\n+            }\n+        } else {\n+            // --extern prelude_name\n+            match entry {\n+                Entry::Vacant(vacant) => {\n+                    vacant.insert(ExternEntry::new(ExternLocation::FoundInLibrarySearchDirectories))\n+                }\n+                Entry::Occupied(occupied) => {\n+                    // Ignore if already specified.\n+                    occupied.into_mut()\n+                }\n+            }\n+        };\n \n-        entry.locations.insert(location.clone());\n+        let mut is_private_dep = false;\n+        let mut add_prelude = true;\n+        if let Some(opts) = options {\n+            if !is_unstable_enabled {\n+                early_error(\n+                    error_format,\n+                    \"the `-Z unstable-options` flag must also be passed to \\\n+                     enable `--extern options\",\n+                );\n+            }\n+            for opt in opts.split(',') {\n+                match opt {\n+                    \"priv\" => is_private_dep = true,\n+                    \"noprelude\" => {\n+                        if let ExternLocation::ExactPaths(_) = &entry.location {\n+                            add_prelude = false;\n+                        } else {\n+                            early_error(\n+                                error_format,\n+                                \"the `noprelude` --extern option requires a file path\",\n+                            );\n+                        }\n+                    }\n+                    _ => early_error(error_format, &format!(\"unknown --extern option `{}`\", opt)),\n+                }\n+            }\n+        }\n \n-        // Crates start out being not private,\n-        // and go to being private if we see an '--extern-private'\n-        // flag\n-        entry.is_private_dep |= private;\n+        // Crates start out being not private, and go to being private `priv`\n+        // is specified.\n+        entry.is_private_dep |= is_private_dep;\n+        // If any flag is missing `noprelude`, then add to the prelude.\n+        entry.add_prelude |= add_prelude;\n     }\n     Externs(externs)\n }"}, {"sha": "0db3d28bf0e3782d989cd785b2b3c9994a331734", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -7,10 +7,10 @@ use errors;\n use getopts;\n use rustc::lint::Level;\n use rustc::session;\n-use rustc::session::config::{CrateType, parse_crate_types_from_list};\n+use rustc::session::config::{CrateType, parse_crate_types_from_list, parse_externs};\n use rustc::session::config::{CodegenOptions, DebuggingOptions, ErrorOutputType, Externs};\n use rustc::session::config::{nightly_options, build_codegen_options, build_debugging_options,\n-                             get_cmd_lint_options, host_triple, ExternEntry};\n+                             get_cmd_lint_options, host_triple};\n use rustc::session::search_paths::SearchPath;\n use rustc_driver;\n use rustc_target::spec::TargetTriple;\n@@ -320,13 +320,7 @@ impl Options {\n         let libs = matches.opt_strs(\"L\").iter()\n             .map(|s| SearchPath::from_cli_opt(s, error_format))\n             .collect();\n-        let externs = match parse_externs(&matches) {\n-            Ok(ex) => ex,\n-            Err(err) => {\n-                diag.struct_err(&err).emit();\n-                return Err(1);\n-            }\n-        };\n+        let externs = parse_externs(&matches, &debugging_options, error_format);\n         let extern_html_root_urls = match parse_extern_html_roots(&matches) {\n             Ok(ex) => ex,\n             Err(err) => {\n@@ -617,24 +611,3 @@ fn parse_extern_html_roots(\n \n     Ok(externs)\n }\n-\n-/// Extracts `--extern CRATE=PATH` arguments from `matches` and\n-/// returns a map mapping crate names to their paths or else an\n-/// error message.\n-/// Also handles `--extern-private` which for the purposes of rustdoc\n-/// we can treat as `--extern`\n-// FIXME(eddyb) This shouldn't be duplicated with `rustc::session`.\n-fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n-    let mut externs: BTreeMap<_, ExternEntry> = BTreeMap::new();\n-    for arg in matches.opt_strs(\"extern\").iter().chain(matches.opt_strs(\"extern-private\").iter()) {\n-        let mut parts = arg.splitn(2, '=');\n-        let name = parts.next().ok_or(\"--extern value must not be empty\".to_string())?;\n-        let location = parts.next().map(|s| s.to_string());\n-        let name = name.to_string();\n-        // For Rustdoc purposes, we can treat all externs as public\n-        externs.entry(name)\n-            .or_default()\n-            .locations.insert(location.clone());\n-    }\n-    Ok(Externs::new(externs))\n-}"}, {"sha": "a524801bea6bf27b47dabb96fe13097a52b33f79", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -248,7 +248,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         ..\n     } = options;\n \n-    let extern_names: Vec<String> = externs.iter().map(|(s,_)| s).cloned().collect();\n+    let extern_names: Vec<String> = externs.iter()\n+        .filter(|(_, entry)| entry.add_prelude)\n+        .map(|(name, _)| name).cloned().collect();\n \n     // Add the doc cfg into the doc build.\n     cfgs.push(\"doc\".to_string());"}, {"sha": "a4be3dee938ed307ec4d5241f03659eba52590ec", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -145,10 +145,6 @@ fn opts() -> Vec<RustcOptGroup> {\n         stable(\"extern\", |o| {\n             o.optmulti(\"\", \"extern\", \"pass an --extern to rustc\", \"NAME[=PATH]\")\n         }),\n-        unstable(\"extern-private\", |o| {\n-            o.optmulti(\"\", \"extern-private\",\n-                       \"pass an --extern to rustc (compatibility only)\", \"NAME=PATH\")\n-        }),\n         unstable(\"extern-html-root-url\", |o| {\n             o.optmulti(\"\", \"extern-html-root-url\",\n                        \"base URL to use for dependencies\", \"NAME=URL\")"}, {"sha": "003d079a470c0cc2756f75d6fde1c83991bf30da", "filename": "src/test/rustdoc/issue-66159.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Frustdoc%2Fissue-66159.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Frustdoc%2Fissue-66159.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-66159.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -1,6 +1,5 @@\n-// aux-build:issue-66159-1.rs\n+// aux-crate:priv:issue_66159_1=issue-66159-1.rs\n // compile-flags:-Z unstable-options\n-// extern-private:issue_66159_1\n \n // The issue was an ICE which meant that we never actually generated the docs\n // so if we have generated the docs, we're okay."}, {"sha": "dd2f373f849c65ce8d79232002a115d595962c7f", "filename": "src/test/ui/extern-flag/auxiliary/somedep.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fauxiliary%2Fsomedep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fauxiliary%2Fsomedep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-flag%2Fauxiliary%2Fsomedep.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -0,0 +1,3 @@\n+pub fn somefun() {}\n+\n+pub struct S;"}, {"sha": "3dc2f1d73f8e4b02219f5fcfc6be2284f435c6e8", "filename": "src/test/ui/extern-flag/multiple-opts.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fmultiple-opts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fmultiple-opts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-flag%2Fmultiple-opts.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -0,0 +1,20 @@\n+// aux-crate:priv,noprelude:somedep=somedep.rs\n+// compile-flags: -Zunstable-options\n+// edition:2018\n+\n+// Test for multiple options to --extern. Can't test for errors from both\n+// options at the same time, so this only checks that noprelude is honored.\n+\n+#![warn(exported_private_dependencies)]\n+\n+// Module to avoid adding to prelude.\n+pub mod m {\n+    extern crate somedep;\n+    pub struct PublicType {\n+        pub field: somedep::S,\n+    }\n+}\n+\n+fn main() {\n+    somedep::somefun();  //~ ERROR failed to resolve\n+}"}, {"sha": "3bf73d11cfd2201239ad75018907e698a7312b14", "filename": "src/test/ui/extern-flag/multiple-opts.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fmultiple-opts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fmultiple-opts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-flag%2Fmultiple-opts.stderr?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -0,0 +1,9 @@\n+error[E0433]: failed to resolve: use of undeclared type or module `somedep`\n+  --> $DIR/multiple-opts.rs:19:5\n+   |\n+LL |     somedep::somefun();\n+   |     ^^^^^^^ use of undeclared type or module `somedep`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "e6a150b9e8b9e55bd984b105196a101884cbd69a", "filename": "src/test/ui/extern-flag/noprelude-and-prelude.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude-and-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude-and-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude-and-prelude.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+// aux-crate:noprelude:somedep=somedep.rs\n+// compile-flags: -Zunstable-options --extern somedep\n+// edition:2018\n+\n+// Having a flag with `noprelude` and one without, will add to the prelude.\n+\n+fn main() {\n+    somedep::somefun();\n+}"}, {"sha": "f69f552b69d8aa8a45bc5e6444361ef95c2665c0", "filename": "src/test/ui/extern-flag/noprelude-resolves.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude-resolves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude-resolves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude-resolves.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// aux-crate:noprelude:somedep=somedep.rs\n+// compile-flags: -Zunstable-options\n+// edition:2018\n+\n+// `extern crate` can be used to add to prelude.\n+extern crate somedep;\n+\n+fn main() {\n+    somedep::somefun();\n+}"}, {"sha": "cdbf34091007ef8cec068d35bfc228be00bc969a", "filename": "src/test/ui/extern-flag/noprelude.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -0,0 +1,7 @@\n+// aux-crate:noprelude:somedep=somedep.rs\n+// compile-flags: -Zunstable-options\n+// edition:2018\n+\n+fn main() {\n+    somedep::somefun();  //~ ERROR failed to resolve\n+}"}, {"sha": "beb9200dddabc7eaec08406abf2ea163947664c5", "filename": "src/test/ui/extern-flag/noprelude.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-flag%2Fnoprelude.stderr?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -0,0 +1,9 @@\n+error[E0433]: failed to resolve: use of undeclared type or module `somedep`\n+  --> $DIR/noprelude.rs:6:5\n+   |\n+LL |     somedep::somefun();\n+   |     ^^^^^^^ use of undeclared type or module `somedep`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "a3a81cbf37223e6503abb4c0bd520bb40006eebb", "filename": "src/test/ui/extern-flag/public-and-private.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fpublic-and-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fpublic-and-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-flag%2Fpublic-and-private.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -0,0 +1,13 @@\n+// aux-crate:priv:somedep=somedep.rs\n+// compile-flags: -Zunstable-options --extern somedep\n+// edition:2018\n+\n+#![deny(exported_private_dependencies)]\n+\n+// Having a flag with `priv` and one without, will remain private (it is sticky).\n+\n+pub struct PublicType {\n+    pub field: somedep::S, //~ ERROR from private dependency\n+}\n+\n+fn main() {}"}, {"sha": "72f1bb2d26f1aefc081784a0d3c71127ea9d925c", "filename": "src/test/ui/extern-flag/public-and-private.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fpublic-and-private.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fextern-flag%2Fpublic-and-private.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-flag%2Fpublic-and-private.stderr?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -0,0 +1,14 @@\n+error: type `somedep::S` from private dependency 'somedep' in public interface\n+  --> $DIR/public-and-private.rs:10:5\n+   |\n+LL |     pub field: somedep::S,\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/public-and-private.rs:5:9\n+   |\n+LL | #![deny(exported_private_dependencies)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "feab72b3efa42607e764f6a3acbafee1ca709caa", "filename": "src/test/ui/privacy/pub-priv-dep/pub-priv1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -1,11 +1,10 @@\n- // aux-build:priv_dep.rs\n+ // aux-crate:priv:priv_dep=priv_dep.rs\n  // aux-build:pub_dep.rs\n- // extern-private:priv_dep\n #![deny(exported_private_dependencies)]\n \n // This crate is a private dependency\n extern crate priv_dep;\n-// This crate is a public dependenct\n+// This crate is a public dependency\n extern crate pub_dep;\n \n use priv_dep::{OtherType, OtherTrait};"}, {"sha": "f21b11f5b32f86ca50a463bbecce0a96e89153d0", "filename": "src/test/ui/privacy/pub-priv-dep/pub-priv1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.stderr?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -1,23 +1,23 @@\n error: type `priv_dep::OtherType` from private dependency 'priv_dep' in public interface\n-  --> $DIR/pub-priv1.rs:21:5\n+  --> $DIR/pub-priv1.rs:20:5\n    |\n LL |     pub field: OtherType,\n    |     ^^^^^^^^^^^^^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/pub-priv1.rs:4:9\n+  --> $DIR/pub-priv1.rs:3:9\n    |\n LL | #![deny(exported_private_dependencies)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: type `priv_dep::OtherType` from private dependency 'priv_dep' in public interface\n-  --> $DIR/pub-priv1.rs:28:5\n+  --> $DIR/pub-priv1.rs:27:5\n    |\n LL |     pub fn pub_fn(param: OtherType) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: trait `priv_dep::OtherTrait` from private dependency 'priv_dep' in public interface\n-  --> $DIR/pub-priv1.rs:34:1\n+  --> $DIR/pub-priv1.rs:33:1\n    |\n LL | / pub trait MyPubTrait {\n LL | |     type Foo: OtherTrait;"}, {"sha": "46cce6394e617e66ea5f367e00a626c7d583357c", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -71,6 +71,7 @@ pub struct EarlyProps {\n     pub ignore: Ignore,\n     pub should_fail: bool,\n     pub aux: Vec<String>,\n+    pub aux_crate: Vec<(String, String)>,\n     pub revisions: Vec<String>,\n }\n \n@@ -80,6 +81,7 @@ impl EarlyProps {\n             ignore: Ignore::Run,\n             should_fail: false,\n             aux: Vec::new(),\n+            aux_crate: Vec::new(),\n             revisions: vec![],\n         };\n \n@@ -157,6 +159,10 @@ impl EarlyProps {\n                 props.aux.push(s);\n             }\n \n+            if let Some(ac) = config.parse_aux_crate(ln) {\n+                props.aux_crate.push(ac);\n+            }\n+\n             if let Some(r) = config.parse_revisions(ln) {\n                 props.revisions.extend(r);\n             }\n@@ -311,10 +317,9 @@ pub struct TestProps {\n     // directory as the test, but for backwards compatibility reasons\n     // we also check the auxiliary directory)\n     pub aux_builds: Vec<String>,\n-    // A list of crates to pass '--extern-private name:PATH' flags for\n-    // This should be a subset of 'aux_build'\n-    // FIXME: Replace this with a better solution: https://github.com/rust-lang/rust/pull/54020\n-    pub extern_private: Vec<String>,\n+    // Similar to `aux_builds`, but a list of NAME=somelib.rs of dependencies\n+    // to build and pass with the `--extern` flag.\n+    pub aux_crates: Vec<(String, String)>,\n     // Environment settings to use for compiling\n     pub rustc_env: Vec<(String, String)>,\n     // Environment variables to unset prior to compiling.\n@@ -387,7 +392,7 @@ impl TestProps {\n             run_flags: None,\n             pp_exact: None,\n             aux_builds: vec![],\n-            extern_private: vec![],\n+            aux_crates: vec![],\n             revisions: vec![],\n             rustc_env: vec![],\n             unset_rustc_env: vec![],\n@@ -514,8 +519,8 @@ impl TestProps {\n                 self.aux_builds.push(ab);\n             }\n \n-            if let Some(ep) = config.parse_extern_private(ln) {\n-                self.extern_private.push(ep);\n+            if let Some(ac) = config.parse_aux_crate(ln) {\n+                self.aux_crates.push(ac);\n             }\n \n             if let Some(ee) = config.parse_env(ln, \"exec-env\") {\n@@ -713,8 +718,14 @@ impl Config {\n             .map(|r| r.trim().to_string())\n     }\n \n-    fn parse_extern_private(&self, line: &str) -> Option<String> {\n-        self.parse_name_value_directive(line, \"extern-private\")\n+    fn parse_aux_crate(&self, line: &str) -> Option<(String, String)> {\n+        self.parse_name_value_directive(line, \"aux-crate\").map(|r| {\n+            let mut parts = r.trim().splitn(2, '=');\n+            (\n+                parts.next().expect(\"aux-crate name\").to_string(),\n+                parts.next().expect(\"aux-crate value\").to_string(),\n+            )\n+        })\n     }\n \n     fn parse_compile_flags(&self, line: &str) -> Option<String> {"}, {"sha": "480868440b8dce9930f4f976d488fc5af9d278ef", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 75, "deletions": 84, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=4c3e95e84b0924f0b7e45a2bb1c74f3d7bec4691", "patch": "@@ -1776,93 +1776,16 @@ impl<'test> TestCx<'test> {\n             create_dir_all(&aux_dir).unwrap();\n         }\n \n-        // Use a Vec instead of a HashMap to preserve original order\n-        let mut extern_priv = self.props.extern_private.clone();\n-\n-        let mut add_extern_priv = |priv_dep: &str, dylib: bool| {\n-            let lib_name = get_lib_name(priv_dep, dylib);\n-            rustc\n-                .arg(\"--extern-private\")\n-                .arg(format!(\"{}={}\", priv_dep, aux_dir.join(lib_name).to_str().unwrap()));\n-        };\n-\n         for rel_ab in &self.props.aux_builds {\n-            let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n-            let aux_props =\n-                self.props\n-                    .from_aux_file(&aux_testpaths.file, self.revision, self.config);\n-            let aux_output = TargetLocation::ThisDirectory(self.aux_output_dir_name());\n-            let aux_cx = TestCx {\n-                config: self.config,\n-                props: &aux_props,\n-                testpaths: &aux_testpaths,\n-                revision: self.revision,\n-            };\n-            // Create the directory for the stdout/stderr files.\n-            create_dir_all(aux_cx.output_base_dir()).unwrap();\n-            let mut aux_rustc = aux_cx.make_compile_args(&aux_testpaths.file, aux_output);\n-\n-            let (dylib, crate_type) = if aux_props.no_prefer_dynamic {\n-                (true, None)\n-            } else if self.config.target.contains(\"cloudabi\")\n-                || self.config.target.contains(\"emscripten\")\n-                || (self.config.target.contains(\"musl\")\n-                    && !aux_props.force_host\n-                    && !self.config.host.contains(\"musl\"))\n-                || self.config.target.contains(\"wasm32\")\n-                || self.config.target.contains(\"nvptx\")\n-                || self.is_vxworks_pure_static()\n-            {\n-                // We primarily compile all auxiliary libraries as dynamic libraries\n-                // to avoid code size bloat and large binaries as much as possible\n-                // for the test suite (otherwise including libstd statically in all\n-                // executables takes up quite a bit of space).\n-                //\n-                // For targets like MUSL or Emscripten, however, there is no support for\n-                // dynamic libraries so we just go back to building a normal library. Note,\n-                // however, that for MUSL if the library is built with `force_host` then\n-                // it's ok to be a dylib as the host should always support dylibs.\n-                (false, Some(\"lib\"))\n-            } else {\n-                (true, Some(\"dylib\"))\n-            };\n-\n-            let trimmed = rel_ab.trim_end_matches(\".rs\").to_string();\n-\n-            // Normally, every 'extern-private' has a correspodning 'aux-build'\n-            // entry. If so, we remove it from our list of private crates,\n-            // and add an '--extern-private' flag to rustc\n-            if extern_priv.remove_item(&trimmed).is_some() {\n-                add_extern_priv(&trimmed, dylib);\n-            }\n-\n-            if let Some(crate_type) = crate_type {\n-                aux_rustc.args(&[\"--crate-type\", crate_type]);\n-            }\n-\n-            aux_rustc.arg(\"-L\").arg(&aux_dir);\n-\n-            let auxres = aux_cx.compose_and_run(\n-                aux_rustc,\n-                aux_cx.config.compile_lib_path.to_str().unwrap(),\n-                Some(aux_dir.to_str().unwrap()),\n-                None,\n-            );\n-            if !auxres.status.success() {\n-                self.fatal_proc_rec(\n-                    &format!(\n-                        \"auxiliary build of {:?} failed to compile: \",\n-                        aux_testpaths.file.display()\n-                    ),\n-                    &auxres,\n-                );\n-            }\n+            self.build_auxiliary(rel_ab, &aux_dir);\n         }\n \n-        // Add any '--extern-private' entries without a matching\n-        // 'aux-build'\n-        for private_lib in extern_priv {\n-            add_extern_priv(&private_lib, true);\n+        for (aux_name, aux_path) in &self.props.aux_crates {\n+            let is_dylib = self.build_auxiliary(&aux_path, &aux_dir);\n+            let lib_name = get_lib_name(&aux_path.trim_end_matches(\".rs\").replace('-', \"_\"),\n+                is_dylib);\n+            rustc.arg(\"--extern\")\n+                .arg(format!(\"{}={}/{}\", aux_name, aux_dir.display(), lib_name));\n         }\n \n         self.props.unset_rustc_env.clone()\n@@ -1877,6 +1800,74 @@ impl<'test> TestCx<'test> {\n         )\n     }\n \n+    /// Builds an aux dependency.\n+    ///\n+    /// Returns whether or not it is a dylib.\n+    fn build_auxiliary(&self, source_path: &str, aux_dir: &Path) -> bool {\n+        let aux_testpaths = self.compute_aux_test_paths(source_path);\n+        let aux_props =\n+            self.props\n+                .from_aux_file(&aux_testpaths.file, self.revision, self.config);\n+        let aux_output = TargetLocation::ThisDirectory(self.aux_output_dir_name());\n+        let aux_cx = TestCx {\n+            config: self.config,\n+            props: &aux_props,\n+            testpaths: &aux_testpaths,\n+            revision: self.revision,\n+        };\n+        // Create the directory for the stdout/stderr files.\n+        create_dir_all(aux_cx.output_base_dir()).unwrap();\n+        let mut aux_rustc = aux_cx.make_compile_args(&aux_testpaths.file, aux_output);\n+\n+        let (dylib, crate_type) = if aux_props.no_prefer_dynamic {\n+            (true, None)\n+        } else if self.config.target.contains(\"cloudabi\")\n+            || self.config.target.contains(\"emscripten\")\n+            || (self.config.target.contains(\"musl\")\n+                && !aux_props.force_host\n+                && !self.config.host.contains(\"musl\"))\n+            || self.config.target.contains(\"wasm32\")\n+            || self.config.target.contains(\"nvptx\")\n+            || self.is_vxworks_pure_static()\n+        {\n+            // We primarily compile all auxiliary libraries as dynamic libraries\n+            // to avoid code size bloat and large binaries as much as possible\n+            // for the test suite (otherwise including libstd statically in all\n+            // executables takes up quite a bit of space).\n+            //\n+            // For targets like MUSL or Emscripten, however, there is no support for\n+            // dynamic libraries so we just go back to building a normal library. Note,\n+            // however, that for MUSL if the library is built with `force_host` then\n+            // it's ok to be a dylib as the host should always support dylibs.\n+            (false, Some(\"lib\"))\n+        } else {\n+            (true, Some(\"dylib\"))\n+        };\n+\n+        if let Some(crate_type) = crate_type {\n+            aux_rustc.args(&[\"--crate-type\", crate_type]);\n+        }\n+\n+        aux_rustc.arg(\"-L\").arg(&aux_dir);\n+\n+        let auxres = aux_cx.compose_and_run(\n+            aux_rustc,\n+            aux_cx.config.compile_lib_path.to_str().unwrap(),\n+            Some(aux_dir.to_str().unwrap()),\n+            None,\n+        );\n+        if !auxres.status.success() {\n+            self.fatal_proc_rec(\n+                &format!(\n+                    \"auxiliary build of {:?} failed to compile: \",\n+                    aux_testpaths.file.display()\n+                ),\n+                &auxres,\n+            );\n+        }\n+        dylib\n+    }\n+\n     fn compose_and_run(\n         &self,\n         mut command: Command,"}]}