{"sha": "58a6a201c007c52ca585fb882e714a928b61b066", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4YTZhMjAxYzAwN2M1MmNhNTg1ZmI4ODJlNzE0YTkyOGI2MWIwNjY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-24T16:35:11Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-25T09:13:15Z"}, "message": "Split `match_expr` into smaller functions", "tree": {"sha": "b1ffdf25ddc5094526b02b8b0f1b88a3d60f9095", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1ffdf25ddc5094526b02b8b0f1b88a3d60f9095"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58a6a201c007c52ca585fb882e714a928b61b066", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58a6a201c007c52ca585fb882e714a928b61b066", "html_url": "https://github.com/rust-lang/rust/commit/58a6a201c007c52ca585fb882e714a928b61b066", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58a6a201c007c52ca585fb882e714a928b61b066/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18df72142ae7694c5661f0feb7d78ffc7b433e6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/18df72142ae7694c5661f0feb7d78ffc7b433e6b", "html_url": "https://github.com/rust-lang/rust/commit/18df72142ae7694c5661f0feb7d78ffc7b433e6b"}], "stats": {"total": 272, "additions": 164, "deletions": 108}, "files": [{"sha": "e18dc2960066769910d239111f70f6abb033e71f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 164, "deletions": 108, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/58a6a201c007c52ca585fb882e714a928b61b066/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a6a201c007c52ca585fb882e714a928b61b066/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=58a6a201c007c52ca585fb882e714a928b61b066", "patch": "@@ -65,32 +65,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// We generate MIR in the following steps:\n     ///\n-    /// 1. Evaluate the scrutinee and add the fake read of it.\n-    /// 2. Create the prebinding and otherwise blocks.\n-    /// 3. Create the decision tree and record the places that we bind or test.\n-    /// 4. Determine the fake borrows that are needed from the above places.\n-    ///    Create the required temporaries for them.\n-    /// 5. Create everything else: the guards and the arms.\n-    ///\n-    /// ## Fake Reads and borrows\n-    ///\n-    /// Match exhaustiveness checking is not able to handle the case where the\n-    /// place being matched on is mutated in the guards. There is an AST check\n-    /// that tries to stop this but it is buggy and overly restrictive. Instead\n-    /// we add \"fake borrows\" to the guards that prevent any mutation of the\n-    /// place being matched. There are a some subtleties:\n-    ///\n-    /// 1. Borrowing `*x` doesn't prevent assigning to `x`. If `x` is a shared\n-    ///    refence, the borrow isn't even tracked. As such we have to add fake\n-    ///    borrows of any prefixes of a place\n-    /// 2. We don't want `match x { _ => (), }` to conflict with mutable\n-    ///    borrows of `x`, so we only add fake borrows for places which are\n-    ///    bound or tested by the match.\n-    /// 3. We don't want the fake borrows to conflict with `ref mut` bindings,\n-    ///    so we use a special BorrowKind for them.\n-    /// 4. The fake borrows may be of places in inactive variants, so it would\n-    ///    be UB to generate code for them. They therefore have to be removed\n-    ///    by a MIR pass run after borrow checking.\n+    /// 1. Evaluate the scrutinee and add the fake read of it ([Builder::lower_scrutinee]).\n+    /// 2. Create the prebinding and otherwise blocks ([Builder::create_match_candidates]).\n+    /// 3. Create the decision tree ([Builder::lower_match_tree]).\n+    /// 4. Determine the fake borrows that are needed from the places that were\n+    ///    matched against and create the required temporaries for them\n+    ///    ([Builder::calculate_fake_borrows]).\n+    /// 5. Create everything else: the guards and the arms ([Builder::lower_match_arms]).\n     ///\n     /// ## False edges\n     ///\n@@ -108,11 +89,37 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         scrutinee: ExprRef<'tcx>,\n         arms: Vec<Arm<'tcx>>,\n     ) -> BlockAnd<()> {\n-        // Step 1. Evaluate the scrutinee and add the fake read of it.\n-\n         let scrutinee_span = scrutinee.span();\n-        let scrutinee_place = unpack!(block = self.as_place(block, scrutinee));\n+        let scrutinee_place =\n+            unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span,));\n+\n+        let mut arm_candidates = self.create_match_candidates(&scrutinee_place, &arms);\n+\n+        let match_has_guard = arms.iter().any(|arm| arm.guard.is_some());\n+        let candidates =\n+            arm_candidates.iter_mut().flat_map(|(_, candidates)| candidates).collect::<Vec<_>>();\n+\n+        let fake_borrow_temps =\n+            self.lower_match_tree(block, scrutinee_span, match_has_guard, candidates);\n+\n+        self.lower_match_arms(\n+            &destination,\n+            scrutinee_place,\n+            scrutinee_span,\n+            arm_candidates,\n+            self.source_info(span),\n+            fake_borrow_temps,\n+        )\n+    }\n \n+    /// Evaluate the scrutinee and add the fake read of it.\n+    fn lower_scrutinee(\n+        &mut self,\n+        mut block: BasicBlock,\n+        scrutinee: ExprRef<'tcx>,\n+        scrutinee_span: Span,\n+    ) -> BlockAnd<Place<'tcx>> {\n+        let scrutinee_place = unpack!(block = self.as_place(block, scrutinee));\n         // Matching on a `scrutinee_place` with an uninhabited type doesn't\n         // generate any memory reads by itself, and so if the place \"expression\"\n         // contains unsafe operations like raw pointer dereferences or union\n@@ -128,37 +135,38 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // uninhabited value. If we get never patterns, those will check that\n         // the place is initialized, and so this read would only be used to\n         // check safety.\n-\n-        let source_info = self.source_info(scrutinee_span);\n         let cause_matched_place = FakeReadCause::ForMatchedPlace;\n+        let source_info = self.source_info(scrutinee_span);\n         self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place.clone());\n \n-        // Step 2. Create the otherwise and prebinding blocks.\n+        block.and(scrutinee_place)\n+    }\n \n-        // create binding start block for link them by false edges\n+    /// Create the initial `Candidate`s for a `match` expression.\n+    fn create_match_candidates<'pat>(\n+        &mut self,\n+        scrutinee: &Place<'tcx>,\n+        arms: &'pat [Arm<'tcx>],\n+    ) -> Vec<(&'pat Arm<'tcx>, Vec<Candidate<'pat, 'tcx>>)> {\n         let candidate_count = arms.iter().map(|c| c.top_pats_hack().len()).sum::<usize>();\n         let pre_binding_blocks: Vec<_> =\n             (0..candidate_count).map(|_| self.cfg.start_new_block()).collect();\n \n-        let mut match_has_guard = false;\n-\n         let mut candidate_pre_binding_blocks = pre_binding_blocks.iter();\n         let mut next_candidate_pre_binding_blocks = pre_binding_blocks.iter().skip(1);\n \n         // Assemble a list of candidates: there is one candidate per pattern,\n         // which means there may be more than one candidate *per arm*.\n-        let mut arm_candidates: Vec<_> = arms\n-            .iter()\n+        arms.iter()\n             .map(|arm| {\n                 let arm_has_guard = arm.guard.is_some();\n-                match_has_guard |= arm_has_guard;\n                 let arm_candidates: Vec<_> = arm\n                     .top_pats_hack()\n                     .iter()\n                     .zip(candidate_pre_binding_blocks.by_ref())\n                     .map(|(pattern, pre_binding_block)| Candidate {\n                         span: pattern.span,\n-                        match_pairs: smallvec![MatchPair::new(scrutinee_place.clone(), pattern),],\n+                        match_pairs: smallvec![MatchPair::new(scrutinee.clone(), pattern)],\n                         bindings: vec![],\n                         ascriptions: vec![],\n                         otherwise_block: if arm_has_guard {\n@@ -174,50 +182,65 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     .collect();\n                 (arm, arm_candidates)\n             })\n-            .collect();\n-\n-        // Step 3. Create the decision tree and record the places that we bind or test.\n+            .collect()\n+    }\n \n+    /// Create the decision tree for the match expression, starting from `block`.\n+    ///\n+    /// Modifies `candidates` to store the bindings and type ascriptions for\n+    /// that candidate.\n+    ///\n+    /// Returns the places that need fake borrows because we bind or test them.\n+    fn lower_match_tree<'pat>(\n+        &mut self,\n+        block: BasicBlock,\n+        scrutinee_span: Span,\n+        match_has_guard: bool,\n+        mut candidates: Vec<&mut Candidate<'pat, 'tcx>>,\n+    ) -> Vec<(Place<'tcx>, Local)> {\n         // The set of places that we are creating fake borrows of. If there are\n         // no match guards then we don't need any fake borrows, so don't track\n         // them.\n         let mut fake_borrows = if match_has_guard { Some(FxHashSet::default()) } else { None };\n \n-        // These candidates are kept sorted such that the highest priority\n-        // candidate comes first in the list. (i.e., same order as in source)\n-        // As we gnerate the decision tree,\n-        let candidates = &mut arm_candidates\n-            .iter_mut()\n-            .flat_map(|(_, candidates)| candidates)\n-            .collect::<Vec<_>>();\n-\n-        let outer_source_info = self.source_info(span);\n-\n-        // this will generate code to test scrutinee_place and\n+        // This will generate code to test scrutinee_place and\n         // branch to the appropriate arm block\n         self.match_candidates(\n             scrutinee_span,\n             &mut Some(block),\n             None,\n-            candidates,\n+            &mut candidates,\n             &mut fake_borrows,\n         );\n \n-        // Step 4. Determine the fake borrows that are needed from the above\n-        // places. Create the required temporaries for them.\n-\n-        let fake_borrow_temps = if let Some(ref borrows) = fake_borrows {\n+        if let Some(ref borrows) = fake_borrows {\n             self.calculate_fake_borrows(borrows, scrutinee_span)\n         } else {\n             Vec::new()\n-        };\n+        }\n+    }\n \n-        // Step 5. Create everything else: the guards and the arms.\n+    /// Lower the bindings, guards and arm bodies of a `match` expression.\n+    ///\n+    /// The decision tree should have already been created (by lower_match_tree).\n+    ///\n+    /// `outer_source_info` is the SourceInfo for the whole match.\n+    fn lower_match_arms(\n+        &mut self,\n+        destination: &Place<'tcx>,\n+        scrutinee_place: Place<'tcx>,\n+        scrutinee_span: Span,\n+        arm_candidates: Vec<(&'_ Arm<'tcx>, Vec<Candidate<'_, 'tcx>>)>,\n+        outer_source_info: SourceInfo,\n+        fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n+    ) -> BlockAnd<()> {\n         let match_scope = self.scopes.topmost();\n \n         let arm_end_blocks: Vec<_> = arm_candidates\n             .into_iter()\n-            .map(|(arm, mut candidates)| {\n+            .map(|(arm, candidates)| {\n+                debug!(\"lowering arm {:?}\\ncanidates = {:?}\", arm, candidates);\n+\n                 let arm_source_info = self.source_info(arm.span);\n                 let arm_scope = (arm.scope, arm_source_info);\n                 self.in_scope(arm_scope, arm.lint_level, |this| {\n@@ -230,29 +253,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         Some((Some(&scrutinee_place), scrutinee_span)),\n                     );\n \n-                    let arm_block;\n-                    if candidates.len() == 1 {\n-                        arm_block = this.bind_and_guard_matched_candidate(\n-                            candidates.pop().unwrap(),\n-                            arm.guard.clone(),\n-                            &fake_borrow_temps,\n-                            scrutinee_span,\n-                            match_scope,\n-                        );\n-                    } else {\n-                        arm_block = this.cfg.start_new_block();\n-                        for candidate in candidates {\n-                            this.clear_top_scope(arm.scope);\n-                            let binding_end = this.bind_and_guard_matched_candidate(\n-                                candidate,\n-                                arm.guard.clone(),\n-                                &fake_borrow_temps,\n-                                scrutinee_span,\n-                                match_scope,\n-                            );\n-                            this.cfg.goto(binding_end, source_info, arm_block);\n-                        }\n-                    }\n+                    let arm_block = this.bind_pattern(\n+                        outer_source_info,\n+                        candidates,\n+                        arm.guard.as_ref().map(|g| (g, match_scope)),\n+                        &fake_borrow_temps,\n+                        scrutinee_span,\n+                        arm.scope,\n+                    );\n \n                     if let Some(source_scope) = scope {\n                         this.source_scope = source_scope;\n@@ -275,6 +283,44 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         end_block.unit()\n     }\n \n+    /// Binds the variables and ascribes types for a given `match` arm.\n+    ///\n+    /// Also check if the guard matches, if it's provided.\n+    fn bind_pattern(\n+        &mut self,\n+        outer_source_info: SourceInfo,\n+        mut candidates: Vec<Candidate<'_, 'tcx>>,\n+        guard: Option<(&Guard<'tcx>, region::Scope)>,\n+        fake_borrow_temps: &Vec<(Place<'tcx>, Local)>,\n+        scrutinee_span: Span,\n+        arm_scope: region::Scope,\n+    ) -> BasicBlock {\n+        if candidates.len() == 1 {\n+            // Avoid generating another `BasicBlock` when we only have one\n+            // candidate.\n+            self.bind_and_guard_matched_candidate(\n+                candidates.pop().unwrap(),\n+                guard,\n+                fake_borrow_temps,\n+                scrutinee_span,\n+            )\n+        } else {\n+            let arm_block = self.cfg.start_new_block();\n+            for candidate in candidates {\n+                // Avoid scheduling drops multiple times.\n+                self.clear_top_scope(arm_scope);\n+                let binding_end = self.bind_and_guard_matched_candidate(\n+                    candidate,\n+                    guard,\n+                    fake_borrow_temps,\n+                    scrutinee_span,\n+                );\n+                self.cfg.goto(binding_end, outer_source_info, arm_block);\n+            }\n+            arm_block\n+        }\n+    }\n+\n     pub(super) fn expr_into_pattern(\n         &mut self,\n         mut block: BasicBlock,\n@@ -1151,13 +1197,33 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.perform_test(block, &match_place, &test, make_target_blocks);\n     }\n \n-    // Determine the fake borrows that are needed to ensure that the place\n-    // will evaluate to the same thing until an arm has been chosen.\n+    /// Determine the fake borrows that are needed from a set of places that\n+    /// have to be stable across match guards.\n+    ///\n+    /// Returns a list of places that need a fake borrow and the temporary\n+    /// that's used to store the fake borrow.\n+    ///\n+    /// Match exhaustiveness checking is not able to handle the case where the\n+    /// place being matched on is mutated in the guards. We add \"fake borrows\"\n+    /// to the guards that prevent any mutation of the place being matched.\n+    /// There are a some subtleties:\n+    ///\n+    /// 1. Borrowing `*x` doesn't prevent assigning to `x`. If `x` is a shared\n+    ///    reference, the borrow isn't even tracked. As such we have to add fake\n+    ///    borrows of any prefixes of a place\n+    /// 2. We don't want `match x { _ => (), }` to conflict with mutable\n+    ///    borrows of `x`, so we only add fake borrows for places which are\n+    ///    bound or tested by the match.\n+    /// 3. We don't want the fake borrows to conflict with `ref mut` bindings,\n+    ///    so we use a special BorrowKind for them.\n+    /// 4. The fake borrows may be of places in inactive variants, so it would\n+    ///    be UB to generate code for them. They therefore have to be removed\n+    ///    by a MIR pass run after borrow checking.\n     fn calculate_fake_borrows<'b>(\n         &mut self,\n         fake_borrows: &'b FxHashSet<Place<'tcx>>,\n         temp_span: Span,\n-    ) -> Vec<(PlaceRef<'b, 'tcx>, Local)> {\n+    ) -> Vec<(Place<'tcx>, Local)> {\n         let tcx = self.hir.tcx();\n \n         debug!(\"add_fake_borrows fake_borrows = {:?}\", fake_borrows);\n@@ -1189,14 +1255,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         all_fake_borrows\n             .into_iter()\n-            .map(|matched_place| {\n-                let fake_borrow_deref_ty = Place::ty_from(\n-                    matched_place.base,\n-                    matched_place.projection,\n-                    &self.local_decls,\n-                    tcx,\n-                )\n-                .ty;\n+            .map(|matched_place_ref| {\n+                let matched_place = Place {\n+                    base: matched_place_ref.base.clone(),\n+                    projection: tcx.intern_place_elems(matched_place_ref.projection),\n+                };\n+                let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;\n                 let fake_borrow_ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, fake_borrow_deref_ty);\n                 let fake_borrow_temp =\n                     self.local_decls.push(LocalDecl::new_temp(fake_borrow_ty, temp_span));\n@@ -1222,10 +1286,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn bind_and_guard_matched_candidate<'pat>(\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n-        guard: Option<Guard<'tcx>>,\n-        fake_borrows: &Vec<(PlaceRef<'_, 'tcx>, Local)>,\n+        guard: Option<(&Guard<'tcx>, region::Scope)>,\n+        fake_borrows: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n-        region_scope: region::Scope,\n     ) -> BasicBlock {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n@@ -1335,7 +1398,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         //      the reference that we create for the arm.\n         //    * So we eagerly create the reference for the arm and then take a\n         //      reference to that.\n-        if let Some(guard) = guard {\n+        if let Some((guard, region_scope)) = guard {\n             let tcx = self.hir.tcx();\n \n             self.bind_matched_candidate_for_guard(block, &candidate.bindings);\n@@ -1352,21 +1415,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let re_erased = tcx.lifetimes.re_erased;\n             let scrutinee_source_info = self.source_info(scrutinee_span);\n             for (place, temp) in fake_borrows {\n-                let borrow = Rvalue::Ref(\n-                    re_erased,\n-                    BorrowKind::Shallow,\n-                    Place {\n-                        base: place.base.clone(),\n-                        projection: tcx.intern_place_elems(place.projection),\n-                    },\n-                );\n+                let borrow = Rvalue::Ref(re_erased, BorrowKind::Shallow, place.clone());\n                 self.cfg.push_assign(block, scrutinee_source_info, &Place::from(*temp), borrow);\n             }\n \n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n             let guard = match guard {\n-                Guard::If(e) => self.hir.mirror(e),\n+                Guard::If(e) => self.hir.mirror(e.clone()),\n             };\n             let source_info = self.source_info(guard.span);\n             let guard_end = self.source_info(tcx.sess.source_map().end_point(guard.span));"}]}