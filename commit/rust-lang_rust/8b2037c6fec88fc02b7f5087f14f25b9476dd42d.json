{"sha": "8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMjAzN2M2ZmVjODhmYzAyYjdmNTA4N2YxNGYyNWI5NDc2ZGQ0MmQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-02-23T01:13:54Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-02-23T01:13:54Z"}, "message": "Introduce UnpackedKind\n\nThis adds an `UnpackedKind` type as a typesafe counterpart to `Kind`. This should make future changes to kinds (such as const generics!) more resilient, as the type-checker should catch more potential issues.", "tree": {"sha": "32c576b6d30405ba2eba908edc779122ee3f11fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32c576b6d30405ba2eba908edc779122ee3f11fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "html_url": "https://github.com/rust-lang/rust/commit/8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1f8e6fb06d7362eeb2065347a7db94e76b1cb2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1f8e6fb06d7362eeb2065347a7db94e76b1cb2f", "html_url": "https://github.com/rust-lang/rust/commit/b1f8e6fb06d7362eeb2065347a7db94e76b1cb2f"}], "stats": {"total": 329, "additions": 175, "deletions": 154}, "files": [{"sha": "71a57dbf32fb180b8bac1c01e9e2f1a9a4cf9594", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -56,8 +56,19 @@ for ty::subst::Kind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        self.as_type().hash_stable(hcx, hasher);\n-        self.as_region().hash_stable(hcx, hasher);\n+        self.unpack().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+for ty::subst::UnpackedKind<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        match self {\n+            ty::subst::UnpackedKind::Lifetime(lt) => lt.hash_stable(hcx, hasher),\n+            ty::subst::UnpackedKind::Type(ty) => ty.hash_stable(hcx, hasher),\n+        }\n     }\n }\n "}, {"sha": "a749d0dddd7eeea31863271ecbce1de5f6297008", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -17,7 +17,7 @@ use traits::{self, PredicateObligation};\n use ty::{self, Ty};\n use ty::fold::{BottomUpFolder, TypeFoldable};\n use ty::outlives::Component;\n-use ty::subst::{Kind, Substs};\n+use ty::subst::{Kind, UnpackedKind, Substs};\n use util::nodemap::DefIdMap;\n \n pub type AnonTypeMap<'tcx> = DefIdMap<AnonTypeDecl<'tcx>>;\n@@ -321,7 +321,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let index = region_def.index as usize;\n \n             // Get the value supplied for this region from the substs.\n-            let subst_arg = anon_defn.substs[index].as_region().unwrap();\n+            let subst_arg = anon_defn.substs.region_at(index);\n \n             // Compute the least upper bound of it with the other regions.\n             debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n@@ -466,7 +466,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // All other regions, we map them appropriately to their adjusted\n                 // indices, erroring if we find any lifetimes that were not mapped\n                 // into the new set.\n-                _ => if let Some(r1) = map.get(&Kind::from(r)).and_then(|k| k.as_region()) {\n+                _ => if let Some(UnpackedKind::Lifetime(r1)) = map.get(&r.into())\n+                                                                  .map(|k| k.unpack()) {\n                     r1\n                 } else {\n                     // No mapping was found. This means that"}, {"sha": "6b0e3ce0539784fa6d0b1e219454baaf9d3c549f", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -584,7 +584,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     let trait_ref = &mut trait_pred.trait_ref;\n                     let unit_substs = trait_ref.substs;\n                     let mut never_substs = Vec::with_capacity(unit_substs.len());\n-                    never_substs.push(From::from(tcx.types.never));\n+                    never_substs.push(tcx.types.never.into());\n                     never_substs.extend(&unit_substs[1..]);\n                     trait_ref.substs = tcx.intern_substs(&never_substs);\n                 }\n@@ -2997,7 +2997,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // unsized parameters is equal to the target.\n                 let params = substs_a.iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n-                        Kind::from(substs_b.type_at(i))\n+                        substs_b.type_at(i).into()\n                     } else {\n                         k\n                     }"}, {"sha": "f4b5ffbb7dc4044780382598c62258d2e636d425", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -355,10 +355,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     let sig = substs.closure_sig(closure_did, tcx);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     assert_eq!(sig.inputs().len(), 1);\n-    let substs = tcx.mk_substs([\n-                               Kind::from(self_ty),\n-                               Kind::from(sig.inputs()[0]),\n-    ].iter().cloned());\n+    let substs = tcx.mk_substs([Kind::from(self_ty), sig.inputs()[0].into()].iter().cloned());\n \n     debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n     Instance { def, substs }"}, {"sha": "b9927c7eeb2fa491569db9a92557df892948e4fe", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -16,7 +16,7 @@\n use hir::def_id::DefId;\n use middle::const_val::ConstVal;\n use traits::Reveal;\n-use ty::subst::{Kind, Substs};\n+use ty::subst::{UnpackedKind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::{TypeVisitor, TypeFolder};\n use ty::error::{ExpectedFound, TypeError};\n@@ -142,12 +142,14 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n \n     let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-        if let (Some(a_ty), Some(b_ty)) = (a.as_type(), b.as_type()) {\n-            Ok(Kind::from(relation.relate_with_variance(variance, &a_ty, &b_ty)?))\n-        } else if let (Some(a_r), Some(b_r)) = (a.as_region(), b.as_region()) {\n-            Ok(Kind::from(relation.relate_with_variance(variance, &a_r, &b_r)?))\n-        } else {\n-            bug!()\n+        match (a.unpack(), b.unpack()) {\n+            (UnpackedKind::Lifetime(a_lt), UnpackedKind::Lifetime(b_lt)) => {\n+                Ok(relation.relate_with_variance(variance, &a_lt, &b_lt)?.into())\n+            }\n+            (UnpackedKind::Type(a_ty), UnpackedKind::Type(b_ty)) => {\n+                Ok(relation.relate_with_variance(variance, &a_ty, &b_ty)?.into())\n+            }\n+            (UnpackedKind::Lifetime(_), _) | (UnpackedKind::Type(_), _) => bug!()\n         }\n     });\n "}, {"sha": "4f8c9ecf080ebccda94adfb1c5b7c08a4f7ba67f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -15,10 +15,9 @@ use hir::def_id::DefId;\n use middle::const_val::ConstVal;\n use middle::region;\n use rustc_data_structures::indexed_vec::Idx;\n-use ty::subst::{Substs, Subst};\n+use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n-use ty::subst::Kind;\n \n use std::iter;\n use std::cmp::Ordering;\n@@ -297,8 +296,8 @@ impl<'tcx> ClosureSubsts<'tcx> {\n         let generics = tcx.generics_of(def_id);\n         let parent_len = generics.parent_count();\n         SplitClosureSubsts {\n-            closure_kind_ty: self.substs[parent_len].as_type().expect(\"CK should be a type\"),\n-            closure_sig_ty: self.substs[parent_len + 1].as_type().expect(\"CS should be a type\"),\n+            closure_kind_ty: self.substs.type_at(parent_len),\n+            closure_sig_ty: self.substs.type_at(parent_len + 1),\n             upvar_kinds: &self.substs[parent_len + 2..],\n         }\n     }\n@@ -308,7 +307,13 @@ impl<'tcx> ClosureSubsts<'tcx> {\n         impl Iterator<Item=Ty<'tcx>> + 'tcx\n     {\n         let SplitClosureSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n-        upvar_kinds.iter().map(|t| t.as_type().expect(\"upvar should be type\"))\n+        upvar_kinds.iter().map(|t| {\n+            if let UnpackedKind::Type(ty) = t.unpack() {\n+                ty\n+            } else {\n+                bug!(\"upvar should be type\")\n+            }\n+        })\n     }\n \n     /// Returns the closure kind for this closure; may return a type\n@@ -620,7 +625,7 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n         ty::TraitRef {\n             def_id: self.def_id,\n             substs: tcx.mk_substs(\n-                iter::once(Kind::from(self_ty)).chain(self.substs.iter().cloned()))\n+                iter::once(self_ty.into()).chain(self.substs.iter().cloned()))\n         }\n     }\n }\n@@ -1127,7 +1132,7 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n             projection_ty: ty::ProjectionTy {\n                 item_def_id: self.item_def_id,\n                 substs: tcx.mk_substs(\n-                iter::once(Kind::from(self_ty)).chain(self.substs.iter().cloned())),\n+                iter::once(self_ty.into()).chain(self.substs.iter().cloned())),\n             },\n             ty: self.ty,\n         }"}, {"sha": "3eb859679dae20d4f63f0df09c985df0be96661e", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 89, "deletions": 86, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -39,15 +39,29 @@ const TAG_MASK: usize = 0b11;\n const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n \n-impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n-    fn from(ty: Ty<'tcx>) -> Kind<'tcx> {\n-        // Ensure we can use the tag bits.\n-        assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n+pub enum UnpackedKind<'tcx> {\n+    Lifetime(ty::Region<'tcx>),\n+    Type(Ty<'tcx>),\n+}\n+\n+impl<'tcx> UnpackedKind<'tcx> {\n+    fn pack(self) -> Kind<'tcx> {\n+        let (tag, ptr) = match self {\n+            UnpackedKind::Lifetime(lt) => {\n+                // Ensure we can use the tag bits.\n+                assert_eq!(mem::align_of_val(lt) & TAG_MASK, 0);\n+                (REGION_TAG, lt as *const _ as usize)\n+            }\n+            UnpackedKind::Type(ty) => {\n+                // Ensure we can use the tag bits.\n+                assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n+                (TYPE_TAG, ty as *const _ as usize)\n+            }\n+        };\n \n-        let ptr = ty as *const _ as usize;\n         Kind {\n             ptr: unsafe {\n-                NonZero::new_unchecked(ptr | TYPE_TAG)\n+                NonZero::new_unchecked(ptr | tag)\n             },\n             marker: PhantomData\n         }\n@@ -56,105 +70,80 @@ impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n \n impl<'tcx> From<ty::Region<'tcx>> for Kind<'tcx> {\n     fn from(r: ty::Region<'tcx>) -> Kind<'tcx> {\n-        // Ensure we can use the tag bits.\n-        assert_eq!(mem::align_of_val(r) & TAG_MASK, 0);\n+        UnpackedKind::Lifetime(r).pack()\n+    }\n+}\n \n-        let ptr = r as *const _ as usize;\n-        Kind {\n-            ptr: unsafe {\n-                NonZero::new_unchecked(ptr | REGION_TAG)\n-            },\n-            marker: PhantomData\n-        }\n+impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n+    fn from(ty: Ty<'tcx>) -> Kind<'tcx> {\n+        UnpackedKind::Type(ty).pack()\n     }\n }\n \n impl<'tcx> Kind<'tcx> {\n     #[inline]\n-    unsafe fn downcast<T>(self, tag: usize) -> Option<&'tcx T> {\n+    pub fn unpack(self) -> UnpackedKind<'tcx> {\n         let ptr = self.ptr.get();\n-        if ptr & TAG_MASK == tag {\n-            Some(&*((ptr & !TAG_MASK) as *const _))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn as_type(self) -> Option<Ty<'tcx>> {\n-        unsafe {\n-            self.downcast(TYPE_TAG)\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn as_region(self) -> Option<ty::Region<'tcx>> {\n-        unsafe {\n-            self.downcast(REGION_TAG)\n+        match ptr & TAG_MASK {\n+            REGION_TAG => unsafe {\n+                UnpackedKind::Lifetime(&*((ptr & !TAG_MASK) as *const _))\n+            },\n+            TYPE_TAG => unsafe {\n+                UnpackedKind::Type(&*((ptr & !TAG_MASK) as *const _))\n+            },\n+            _ => bug!(\"packed kind has invalid tag\")\n         }\n     }\n }\n \n impl<'tcx> fmt::Debug for Kind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if let Some(ty) = self.as_type() {\n-            write!(f, \"{:?}\", ty)\n-        } else if let Some(r) = self.as_region() {\n-            write!(f, \"{:?}\", r)\n-        } else {\n-            write!(f, \"<unknown @ {:p}>\", self.ptr.get() as *const ())\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => write!(f, \"{:?}\", lt),\n+            UnpackedKind::Type(ty) => write!(f, \"{:?}\", ty),\n         }\n     }\n }\n \n impl<'tcx> fmt::Display for Kind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if let Some(ty) = self.as_type() {\n-            write!(f, \"{}\", ty)\n-        } else if let Some(r) = self.as_region() {\n-            write!(f, \"{}\", r)\n-        } else {\n-            // FIXME(RFC 2000): extend this if/else chain when we support const generic.\n-            unimplemented!();\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => write!(f, \"{}\", lt),\n+            UnpackedKind::Type(ty) => write!(f, \"{}\", ty),\n         }\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        if let Some(ty) = self.as_type() {\n-            Kind::from(ty.fold_with(folder))\n-        } else if let Some(r) = self.as_region() {\n-            Kind::from(r.fold_with(folder))\n-        } else {\n-            bug!()\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => lt.fold_with(folder).into(),\n+            UnpackedKind::Type(ty) => ty.fold_with(folder).into(),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        if let Some(ty) = self.as_type() {\n-            ty.visit_with(visitor)\n-        } else if let Some(r) = self.as_region() {\n-            r.visit_with(visitor)\n-        } else {\n-            bug!()\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => lt.visit_with(visitor),\n+            UnpackedKind::Type(ty) => ty.visit_with(visitor),\n         }\n     }\n }\n \n impl<'tcx> Encodable for Kind<'tcx> {\n     fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_enum(\"Kind\", |e| {\n-            if let Some(ty) = self.as_type() {\n-                e.emit_enum_variant(\"Ty\", TYPE_TAG, 1, |e| {\n-                    e.emit_enum_variant_arg(0, |e| ty.encode(e))\n-                })\n-            } else if let Some(r) = self.as_region() {\n-                e.emit_enum_variant(\"Region\", REGION_TAG, 1, |e| {\n-                    e.emit_enum_variant_arg(0, |e| r.encode(e))\n-                })\n-            } else {\n-                bug!()\n+            match self.unpack() {\n+                UnpackedKind::Lifetime(lt) => {\n+                    e.emit_enum_variant(\"Region\", REGION_TAG, 1, |e| {\n+                        e.emit_enum_variant_arg(0, |e| lt.encode(e))\n+                    })\n+                }\n+                UnpackedKind::Type(ty) => {\n+                    e.emit_enum_variant(\"Ty\", TYPE_TAG, 1, |e| {\n+                        e.emit_enum_variant_arg(0, |e| ty.encode(e))\n+                    })\n+                }\n             }\n         })\n     }\n@@ -247,7 +236,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n             let def = types.next().unwrap();\n             let ty = mk_type(def, substs);\n             assert_eq!(def.index as usize, substs.len());\n-            substs.push(Kind::from(ty));\n+            substs.push(ty.into());\n         }\n \n         for def in &defs.regions {\n@@ -269,26 +258,42 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n \n     #[inline]\n     pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n-        self.iter().filter_map(|k| k.as_type())\n+        self.iter().filter_map(|k| {\n+            if let UnpackedKind::Type(ty) = k.unpack() {\n+                Some(ty)\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     #[inline]\n     pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=ty::Region<'tcx>> + 'a {\n-        self.iter().filter_map(|k| k.as_region())\n+        self.iter().filter_map(|k| {\n+            if let UnpackedKind::Lifetime(lt) = k.unpack() {\n+                Some(lt)\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     #[inline]\n     pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n-        self[i].as_type().unwrap_or_else(|| {\n+        if let UnpackedKind::Type(ty) = self[i].unpack() {\n+            ty\n+        } else {\n             bug!(\"expected type for param #{} in {:?}\", i, self);\n-        })\n+        }\n     }\n \n     #[inline]\n     pub fn region_at(&self, i: usize) -> ty::Region<'tcx> {\n-        self[i].as_region().unwrap_or_else(|| {\n+        if let UnpackedKind::Lifetime(lt) = self[i].unpack() {\n+            lt\n+        } else {\n             bug!(\"expected region for param #{} in {:?}\", i, self);\n-        })\n+        }\n     }\n \n     #[inline]\n@@ -413,13 +418,12 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         // the specialized routine `ty::replace_late_regions()`.\n         match *r {\n             ty::ReEarlyBound(data) => {\n-                let r = self.substs.get(data.index as usize)\n-                            .and_then(|k| k.as_region());\n+                let r = self.substs.get(data.index as usize).map(|k| k.unpack());\n                 match r {\n-                    Some(r) => {\n-                        self.shift_region_through_binders(r)\n+                    Some(UnpackedKind::Lifetime(lt)) => {\n+                        self.shift_region_through_binders(lt)\n                     }\n-                    None => {\n+                    _ => {\n                         let span = self.span.unwrap_or(DUMMY_SP);\n                         span_bug!(\n                             span,\n@@ -470,11 +474,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.get(p.idx as usize)\n-                         .and_then(|k| k.as_type());\n+        let opt_ty = self.substs.get(p.idx as usize).map(|k| k.unpack());\n         let ty = match opt_ty {\n-            Some(t) => t,\n-            None => {\n+            Some(UnpackedKind::Type(ty)) => ty,\n+            _ => {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!(\n                     span,\n@@ -600,7 +603,7 @@ impl<'a, 'gcx, 'tcx> ty::PolyExistentialTraitRef<'tcx> {\n             ty::TraitRef {\n                 def_id: trait_ref.def_id,\n                 substs: tcx.mk_substs(\n-                    iter::once(Kind::from(self_ty)).chain(trait_ref.substs.iter().cloned()))\n+                    iter::once(self_ty.into()).chain(trait_ref.substs.iter().cloned()))\n             }\n         })\n     }"}, {"sha": "110808919e905fc65f725e4a8724be03c558f23f", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -19,7 +19,7 @@ use middle::const_val::ConstVal;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeVisitor;\n-use ty::subst::{Subst, Kind};\n+use ty::subst::{Subst, UnpackedKind};\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n use middle::lang_items;\n@@ -509,16 +509,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let result = item_substs.iter().zip(impl_substs.iter())\n             .filter(|&(_, &k)| {\n-                if let Some(&ty::RegionKind::ReEarlyBound(ref ebr)) = k.as_region() {\n-                    !impl_generics.region_param(ebr, self).pure_wrt_drop\n-                } else if let Some(&ty::TyS {\n-                    sty: ty::TypeVariants::TyParam(ref pt), ..\n-                }) = k.as_type() {\n-                    !impl_generics.type_param(pt, self).pure_wrt_drop\n-                } else {\n-                    // not a type or region param - this should be reported\n-                    // as an error.\n-                    false\n+                match k.unpack() {\n+                    UnpackedKind::Lifetime(&ty::RegionKind::ReEarlyBound(ref ebr)) => {\n+                        !impl_generics.region_param(ebr, self).pure_wrt_drop\n+                    }\n+                    UnpackedKind::Type(&ty::TyS {\n+                        sty: ty::TypeVariants::TyParam(ref pt), ..\n+                    }) => {\n+                        !impl_generics.type_param(pt, self).pure_wrt_drop\n+                    }\n+                    UnpackedKind::Lifetime(_) | UnpackedKind::Type(_) => {\n+                        // not a type or region param - this should be reported\n+                        // as an error.\n+                        false\n+                    }\n                 }\n             }).map(|(&item_param, _)| item_param).collect();\n         debug!(\"destructor_constraint({:?}) = {:?}\", def.did, result);\n@@ -596,7 +600,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // Objects must be alive in order for their destructor\n             // to be called.\n             ty::TyDynamic(..) => Ok(ty::DtorckConstraint {\n-                outlives: vec![Kind::from(ty)],\n+                outlives: vec![ty.into()],\n                 dtorck_types: vec![],\n             }),\n "}, {"sha": "54e3418d4f0178fb1ba1f93b860b8bb67c2fb4bd", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -878,7 +878,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n         ty::TyAdt(adt, substs) => {\n             if adt.is_box() {\n                 // Use T as the sub pattern type of Box<T>.\n-                vec![substs[0].as_type().unwrap()]\n+                vec![substs.type_at(0)]\n             } else {\n                 adt.variants[ctor.variant_index_for_adt(adt)].fields.iter().map(|field| {\n                     let is_visible = adt.is_enum()"}, {"sha": "35d2205cf33f3cea858e9e58c8dfd12ad4892be4", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -17,7 +17,7 @@ use driver;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n use rustc::middle::region;\n-use rustc::ty::subst::{Kind, Subst};\n+use rustc::ty::subst::Subst;\n use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::maps::OnDiskCache;\n@@ -468,7 +468,7 @@ fn subst_ty_renumber_bound() {\n             env.t_fn(&[t_param], env.t_nil())\n         };\n \n-        let substs = env.infcx.tcx.intern_substs(&[Kind::from(t_rptr_bound1)]);\n+        let substs = env.infcx.tcx.intern_substs(&[t_rptr_bound1.into()]);\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)\n@@ -503,7 +503,7 @@ fn subst_ty_renumber_some_bounds() {\n             env.t_pair(t_param, env.t_fn(&[t_param], env.t_nil()))\n         };\n \n-        let substs = env.infcx.tcx.intern_substs(&[Kind::from(t_rptr_bound1)]);\n+        let substs = env.infcx.tcx.intern_substs(&[t_rptr_bound1.into()]);\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = (&'a isize, fn(&'a isize))\n@@ -565,7 +565,7 @@ fn subst_region_renumber_region() {\n             env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n         };\n \n-        let substs = env.infcx.tcx.intern_substs(&[Kind::from(re_bound1)]);\n+        let substs = env.infcx.tcx.intern_substs(&[re_bound1.into()]);\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)"}, {"sha": "08c16fed5dd3fd074a0c75e42a2924128bb68681", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -7,7 +7,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout};\n-use rustc::ty::subst::{Subst, Substs, Kind};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::{self, DUMMY_SP};\n@@ -1663,6 +1663,6 @@ pub fn resolve_drop_in_place<'a, 'tcx>(\n     ty: Ty<'tcx>,\n ) -> ty::Instance<'tcx> {\n     let def_id = tcx.require_lang_item(::rustc::middle::lang_items::DropInPlaceFnLangItem);\n-    let substs = tcx.intern_substs(&[Kind::from(ty)]);\n+    let substs = tcx.intern_substs(&[ty.into()]);\n     ty::Instance::resolve(tcx, ty::ParamEnv::empty(Reveal::All), def_id, substs).unwrap()\n }"}, {"sha": "2ca6c76a8009a058e18f8bdc1c2e33f958544f8e", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -92,7 +92,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     assert_eq!(sig.inputs().len(), 1);\n     let substs = tcx.mk_substs([\n         Kind::from(self_ty),\n-        Kind::from(sig.inputs()[0]),\n+        sig.inputs()[0].into(),\n     ].iter().cloned());\n \n     debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n@@ -153,7 +153,7 @@ pub fn resolve_drop_in_place<'a, 'tcx>(\n     -> ty::Instance<'tcx>\n {\n     let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n-    let substs = tcx.intern_substs(&[Kind::from(ty)]);\n+    let substs = tcx.intern_substs(&[ty.into()]);\n     Instance::resolve(tcx, ty::ParamEnv::empty(traits::Reveal::All), def_id, substs).unwrap()\n }\n "}, {"sha": "04ebaa031fe5a305548574865e2c1724fe61dac1", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -65,7 +65,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, GeneratorInterior};\n-use rustc::ty::subst::{Kind, Substs};\n+use rustc::ty::subst::Substs;\n use util::dump_mir;\n use util::liveness::{self, LivenessMode};\n use rustc_const_math::ConstInt;\n@@ -858,8 +858,8 @@ impl MirPass for StateTransform {\n         // Compute GeneratorState<yield_ty, return_ty>\n         let state_did = tcx.lang_items().gen_state().unwrap();\n         let state_adt_ref = tcx.adt_def(state_did);\n-        let state_substs = tcx.mk_substs([Kind::from(yield_ty),\n-            Kind::from(mir.return_ty())].iter());\n+        let state_substs = tcx.mk_substs([yield_ty.into(),\n+            mir.return_ty().into()].iter());\n         let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n         // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local"}, {"sha": "37bd225a7d9cbd304286290c80835eac3e3b9880", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -28,7 +28,6 @@ use value::Value;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n-use rustc::ty::subst::Kind;\n use rustc::hir;\n \n use libc::{c_uint, c_char};\n@@ -413,8 +412,8 @@ pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             sig.map_bound(|sig| {\n                 let state_did = tcx.lang_items().gen_state().unwrap();\n                 let state_adt_ref = tcx.adt_def(state_did);\n-                let state_substs = tcx.mk_substs([Kind::from(sig.yield_ty),\n-                    Kind::from(sig.return_ty)].iter());\n+                let state_substs = tcx.mk_substs([sig.yield_ty.into(),\n+                    sig.return_ty.into()].iter());\n                 let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n                 tcx.mk_fn_sig(iter::once(env_ty),"}, {"sha": "650e530519887a71de58fd81c538aa7cf303ae39", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -19,7 +19,7 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use namespace::Namespace;\n-use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::subst::{Kind, UnpackedKind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, RegionKind, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -1136,7 +1136,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n             // Replace all lifetimes with 'static\n             for subst in &mut substs {\n-                if let Some(_) = subst.as_region() {\n+                if let UnpackedKind::Lifetime(_) = subst.unpack() {\n                     *subst = Kind::from(&RegionKind::ReStatic);\n                 }\n             }\n@@ -1146,8 +1146,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Fill in our own generics with the resolved lifetimes\n         assert_eq!(lifetimes.len(), generics.own_count());\n-        substs.extend(lifetimes.iter().map(|lt|\n-            Kind::from(self.ast_region_to_region(lt, None))));\n+        substs.extend(lifetimes.iter().map(|lt| Kind::from(self.ast_region_to_region(lt, None))));\n \n         debug!(\"impl_trait_ty_to_ty: final substs = {:?}\", substs);\n "}, {"sha": "039669a62e104ab6491651ad645610fa68c75e8f", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::DefId;\n use rustc::infer::{self, InferOk};\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, Reveal, ObligationCause};\n use util::common::ErrorReported;\n@@ -331,10 +331,9 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n         }\n \n         for outlive in outlives {\n-            if let Some(r) = outlive.as_region() {\n-                rcx.sub_regions(origin(), parent_scope, r);\n-            } else if let Some(ty) = outlive.as_type() {\n-                rcx.type_must_outlive(origin(), ty, parent_scope);\n+            match outlive.unpack() {\n+                UnpackedKind::Lifetime(lt) => rcx.sub_regions(origin(), parent_scope, lt),\n+                UnpackedKind::Type(ty) => rcx.type_must_outlive(origin(), ty, parent_scope),\n             }\n         }\n     }"}, {"sha": "44ac7a10e8287634637b692237a1fcbcf01095c1", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2037c6fec88fc02b7f5087f14f25b9476dd42d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=8b2037c6fec88fc02b7f5087f14f25b9476dd42d", "patch": "@@ -14,7 +14,7 @@\n //! We walk the set of items and, for each member, generate new constraints.\n \n use hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use rustc::hir;\n@@ -381,12 +381,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl,\n                    variance_i);\n-            if let Some(ty) = k.as_type() {\n-                self.add_constraints_from_ty(current, ty, variance_i);\n-            } else if let Some(r) = k.as_region() {\n-                self.add_constraints_from_region(current, r, variance_i);\n-            } else {\n-                bug!();\n+            match k.unpack() {\n+                UnpackedKind::Lifetime(lt) => {\n+                    self.add_constraints_from_region(current, lt, variance_i)\n+                }\n+                UnpackedKind::Type(ty) => {\n+                    self.add_constraints_from_ty(current, ty, variance_i)\n+                }\n             }\n         }\n     }"}]}