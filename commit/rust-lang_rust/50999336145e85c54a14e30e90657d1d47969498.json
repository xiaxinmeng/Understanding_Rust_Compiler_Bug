{"sha": "50999336145e85c54a14e30e90657d1d47969498", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwOTk5MzM2MTQ1ZTg1YzU0YTE0ZTMwZTkwNjU3ZDFkNDc5Njk0OTg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-17T10:18:02Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T11:08:38Z"}, "message": "move validation to its own file", "tree": {"sha": "a1b98a82871aa5c73946a2e60905b276e79fc7cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1b98a82871aa5c73946a2e60905b276e79fc7cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50999336145e85c54a14e30e90657d1d47969498", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50999336145e85c54a14e30e90657d1d47969498", "html_url": "https://github.com/rust-lang/rust/commit/50999336145e85c54a14e30e90657d1d47969498", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50999336145e85c54a14e30e90657d1d47969498/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2aeb5b89394af123fc872ebf952e22b9dcfa633", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2aeb5b89394af123fc872ebf952e22b9dcfa633", "html_url": "https://github.com/rust-lang/rust/commit/f2aeb5b89394af123fc872ebf952e22b9dcfa633"}], "stats": {"total": 677, "additions": 346, "deletions": 331}, "files": [{"sha": "d42fc8746c4c058c3ece7ca13d3917deb89150ea", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 331, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/50999336145e85c54a14e30e90657d1d47969498/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50999336145e85c54a14e30e90657d1d47969498/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=50999336145e85c54a14e30e90657d1d47969498", "patch": "@@ -7,15 +7,15 @@ use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::mir;\n use rustc::ty::layout::{\n-    self, Size, Align, HasDataLayout, LayoutOf, TyLayout, Primitive\n+    self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n };\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::fx::{FxHashSet, FxHasher};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::interpret::{\n-    GlobalId, Scalar, FrameInfo, AllocType,\n+    GlobalId, Scalar, FrameInfo,\n     EvalResult, EvalErrorKind,\n     ScalarMaybeUndef,\n     truncate, sign_extend,\n@@ -29,31 +29,6 @@ use super::{\n     Memory, Machine\n };\n \n-macro_rules! validation_failure{\n-    ($what:expr, $where:expr, $details:expr) => {{\n-        let where_ = if $where.is_empty() {\n-            String::new()\n-        } else {\n-            format!(\" at {}\", $where)\n-        };\n-        err!(ValidationFailure(format!(\n-            \"encountered {}{}, but expected {}\",\n-            $what, where_, $details,\n-        )))\n-    }};\n-    ($what:expr, $where:expr) => {{\n-        let where_ = if $where.is_empty() {\n-            String::new()\n-        } else {\n-            format!(\" at {}\", $where)\n-        };\n-        err!(ValidationFailure(format!(\n-            \"encountered {}{}\",\n-            $what, where_,\n-        )))\n-    }};\n-}\n-\n pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n@@ -670,243 +645,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         self.tcx.const_eval(param_env.and(gid)).map_err(|err| EvalErrorKind::ReferencedConstant(err).into())\n     }\n \n-    fn validate_scalar(\n-        &self,\n-        value: ScalarMaybeUndef,\n-        size: Size,\n-        scalar: &layout::Scalar,\n-        path: &str,\n-        ty: Ty,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"validate scalar: {:#?}, {:#?}, {:#?}, {}\", value, size, scalar, ty);\n-        let (lo, hi) = scalar.valid_range.clone().into_inner();\n-\n-        let value = match value {\n-            ScalarMaybeUndef::Scalar(scalar) => scalar,\n-            ScalarMaybeUndef::Undef => return validation_failure!(\"undefined bytes\", path),\n-        };\n-\n-        let bits = match value {\n-            Scalar::Bits { bits, size: value_size } => {\n-                assert_eq!(value_size as u64, size.bytes());\n-                bits\n-            },\n-            Scalar::Ptr(_) => {\n-                let ptr_size = self.memory.pointer_size();\n-                let ptr_max = u128::max_value() >> (128 - ptr_size.bits());\n-                return if lo > hi {\n-                    if lo - hi == 1 {\n-                        // no gap, all values are ok\n-                        Ok(())\n-                    } else if hi < ptr_max || lo > 1 {\n-                        let max = u128::max_value() >> (128 - size.bits());\n-                        validation_failure!(\n-                            \"pointer\",\n-                            path,\n-                            format!(\"something in the range {:?} or {:?}\", 0..=lo, hi..=max)\n-                        )\n-                    } else {\n-                        Ok(())\n-                    }\n-                } else if hi < ptr_max || lo > 1 {\n-                    validation_failure!(\n-                        \"pointer\",\n-                        path,\n-                        format!(\"something in the range {:?}\", scalar.valid_range)\n-                    )\n-                } else {\n-                    Ok(())\n-                };\n-            },\n-        };\n-\n-        // char gets a special treatment, because its number space is not contiguous so `TyLayout`\n-        // has no special checks for chars\n-        match ty.sty {\n-            ty::TyChar => {\n-                debug_assert_eq!(size.bytes(), 4);\n-                if ::std::char::from_u32(bits as u32).is_none() {\n-                    return err!(InvalidChar(bits));\n-                }\n-            }\n-            _ => {},\n-        }\n-\n-        use std::ops::RangeInclusive;\n-        let in_range = |bound: RangeInclusive<u128>| bound.contains(&bits);\n-        if lo > hi {\n-            if in_range(0..=hi) || in_range(lo..=u128::max_value()) {\n-                Ok(())\n-            } else {\n-                validation_failure!(\n-                    bits,\n-                    path,\n-                    format!(\"something in the range {:?} or {:?}\", ..=hi, lo..)\n-                )\n-            }\n-        } else {\n-            if in_range(scalar.valid_range.clone()) {\n-                Ok(())\n-            } else {\n-                validation_failure!(\n-                    bits,\n-                    path,\n-                    format!(\"something in the range {:?}\", scalar.valid_range)\n-                )\n-            }\n-        }\n-    }\n-\n-    /// This function checks the memory where `ptr` points to.\n-    /// It will error if the bits at the destination do not match the ones described by the layout.\n-    pub fn validate_mplace(\n-        &self,\n-        dest: MPlaceTy<'tcx>,\n-        path: String,\n-        seen: &mut FxHashSet<(MPlaceTy<'tcx>)>,\n-        todo: &mut Vec<(MPlaceTy<'tcx>, String)>,\n-    ) -> EvalResult<'tcx> {\n-        self.memory.dump_alloc(dest.to_ptr()?.alloc_id);\n-        trace!(\"validate_mplace: {:?}, {:#?}\", *dest, dest.layout);\n-\n-        // Find the right variant\n-        let (variant, dest) = match dest.layout.variants {\n-            layout::Variants::NicheFilling { niche: ref tag, .. } |\n-            layout::Variants::Tagged { ref tag, .. } => {\n-                let size = tag.value.size(self);\n-                // we first read the tag value as scalar, to be able to validate it\n-                let tag_mplace = self.mplace_field(dest, 0)?;\n-                let tag_value = self.read_scalar(tag_mplace.into())?;\n-                let path = format!(\"{}.TAG\", path);\n-                self.validate_scalar(\n-                    tag_value, size, tag, &path, tag_mplace.layout.ty\n-                )?;\n-                // then we read it again to get the index, to continue\n-                let variant = self.read_discriminant_as_variant_index(dest.into())?;\n-                let dest = self.mplace_downcast(dest, variant)?;\n-                trace!(\"variant layout: {:#?}\", dest.layout);\n-                (variant, dest)\n-            },\n-            layout::Variants::Single { index } => {\n-                (index, dest)\n-            }\n-        };\n-\n-        // Validate all fields\n-        match dest.layout.fields {\n-            // primitives are unions with zero fields\n-            layout::FieldPlacement::Union(0) => {\n-                match dest.layout.abi {\n-                    // nothing to do, whatever the pointer points to, it is never going to be read\n-                    layout::Abi::Uninhabited => validation_failure!(\"a value of an uninhabited type\", path),\n-                    // check that the scalar is a valid pointer or that its bit range matches the\n-                    // expectation.\n-                    layout::Abi::Scalar(ref scalar_layout) => {\n-                        let size = scalar_layout.value.size(self);\n-                        let value = self.read_value(dest.into())?;\n-                        let scalar = value.to_scalar_or_undef();\n-                        self.validate_scalar(scalar, size, scalar_layout, &path, dest.layout.ty)?;\n-                        if scalar_layout.value == Primitive::Pointer {\n-                            // ignore integer pointers, we can't reason about the final hardware\n-                            if let Scalar::Ptr(ptr) = scalar.not_undef()? {\n-                                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                                if let Some(AllocType::Static(did)) = alloc_kind {\n-                                    // statics from other crates are already checked\n-                                    // extern statics should not be validated as they have no body\n-                                    if !did.is_local() || self.tcx.is_foreign_item(did) {\n-                                        return Ok(());\n-                                    }\n-                                }\n-                                if value.layout.ty.builtin_deref(false).is_some() {\n-                                    trace!(\"Recursing below ptr {:#?}\", value);\n-                                    let ptr_place = self.ref_to_mplace(value)?;\n-                                    // we have not encountered this pointer+layout combination before\n-                                    if seen.insert(ptr_place) {\n-                                        todo.push((ptr_place, format!(\"(*{})\", path)))\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        Ok(())\n-                    },\n-                    _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", dest.layout.abi),\n-                }\n-            }\n-            layout::FieldPlacement::Union(_) => {\n-                // We can't check unions, their bits are allowed to be anything.\n-                // The fields don't need to correspond to any bit pattern of the union's fields.\n-                // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n-                Ok(())\n-            },\n-            layout::FieldPlacement::Array { count, .. } => {\n-                for i in 0..count {\n-                    let mut path = path.clone();\n-                    self.dump_field_name(&mut path, dest.layout.ty, i as usize, variant).unwrap();\n-                    let field = self.mplace_field(dest, i)?;\n-                    self.validate_mplace(field, path, seen, todo)?;\n-                }\n-                Ok(())\n-            },\n-            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                // fat pointers need special treatment\n-                match dest.layout.ty.builtin_deref(false).map(|tam| &tam.ty.sty) {\n-                    | Some(ty::TyStr)\n-                    | Some(ty::TySlice(_)) => {\n-                        // check the length (for nicer error messages)\n-                        let len_mplace = self.mplace_field(dest, 1)?;\n-                        let len = self.read_scalar(len_mplace.into())?;\n-                        let len = match len.to_bits(len_mplace.layout.size) {\n-                            Err(_) => return validation_failure!(\"length is not a valid integer\", path),\n-                            Ok(len) => len as u64,\n-                        };\n-                        // get the fat ptr, and recursively check it\n-                        let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n-                        assert_eq!(ptr.extra, PlaceExtra::Length(len));\n-                        let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n-                        if seen.insert(unpacked_ptr) {\n-                            let mut path = path.clone();\n-                            self.dump_field_name(&mut path, dest.layout.ty, 0, 0).unwrap();\n-                            todo.push((unpacked_ptr, path))\n-                        }\n-                    },\n-                    Some(ty::TyDynamic(..)) => {\n-                        // check the vtable (for nicer error messages)\n-                        let vtable = self.read_scalar(self.mplace_field(dest, 1)?.into())?;\n-                        let vtable = match vtable.to_ptr() {\n-                            Err(_) => return validation_failure!(\"vtable address is not a pointer\", path),\n-                            Ok(vtable) => vtable,\n-                        };\n-                        // get the fat ptr, and recursively check it\n-                        let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n-                        assert_eq!(ptr.extra, PlaceExtra::Vtable(vtable));\n-                        let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n-                        if seen.insert(unpacked_ptr) {\n-                            let mut path = path.clone();\n-                            self.dump_field_name(&mut path, dest.layout.ty, 0, 0).unwrap();\n-                            todo.push((unpacked_ptr, path))\n-                        }\n-                        // FIXME: More checks for the vtable... making sure it is exactly\n-                        // the one one would expect for this type.\n-                    },\n-                    Some(ty) =>\n-                        bug!(\"Unexpected fat pointer target type {:?}\", ty),\n-                    None => {\n-                        // Not a pointer, perform regular aggregate handling below\n-                        for i in 0..offsets.len() {\n-                            let mut path = path.clone();\n-                            self.dump_field_name(&mut path, dest.layout.ty, i, variant).unwrap();\n-                            let field = self.mplace_field(dest, i as u64)?;\n-                            self.validate_mplace(field, path, seen, todo)?;\n-                        }\n-                        // FIXME: For a TyStr, check that this is valid UTF-8.\n-                    },\n-                }\n-\n-                Ok(())\n-            }\n-        }\n-    }\n-\n     #[inline(always)]\n     pub fn frame(&self) -> &Frame<'mir, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n@@ -1041,72 +779,5 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn truncate(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n         truncate(value, ty.size)\n     }\n-\n-    fn dump_field_name(&self, s: &mut String, ty: Ty<'tcx>, i: usize, variant: usize) -> ::std::fmt::Result {\n-        match ty.sty {\n-            ty::TyBool |\n-            ty::TyChar |\n-            ty::TyInt(_) |\n-            ty::TyUint(_) |\n-            ty::TyFloat(_) |\n-            ty::TyFnPtr(_) |\n-            ty::TyNever |\n-            ty::TyFnDef(..) |\n-            ty::TyGeneratorWitness(..) |\n-            ty::TyForeign(..) |\n-            ty::TyDynamic(..) => {\n-                bug!(\"field_name({:?}): not applicable\", ty)\n-            }\n-\n-            // Potentially-fat pointers.\n-            ty::TyRef(_, pointee, _) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-                assert!(i < 2);\n-\n-                // Reuse the fat *T type as its own thin pointer data field.\n-                // This provides information about e.g. DST struct pointees\n-                // (which may have no non-DST form), and will work as long\n-                // as the `Abi` or `FieldPlacement` is checked by users.\n-                if i == 0 {\n-                    return write!(s, \".data_ptr\");\n-                }\n-\n-                match self.tcx.struct_tail(pointee).sty {\n-                    ty::TySlice(_) |\n-                    ty::TyStr => write!(s, \".len\"),\n-                    ty::TyDynamic(..) => write!(s, \".vtable_ptr\"),\n-                    _ => bug!(\"field_name({:?}): not applicable\", ty)\n-                }\n-            }\n-\n-            // Arrays and slices.\n-            ty::TyArray(_, _) |\n-            ty::TySlice(_) |\n-            ty::TyStr => write!(s, \"[{}]\", i),\n-\n-            // generators and closures.\n-            ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {\n-                let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                let freevar = self.tcx.with_freevars(node_id, |fv| fv[i]);\n-                write!(s, \".upvar({})\", self.tcx.hir.name(freevar.var_id()))\n-            }\n-\n-            ty::TyTuple(_) => write!(s, \".{}\", i),\n-\n-            // enums\n-            ty::TyAdt(def, ..) if def.is_enum() => {\n-                let variant = &def.variants[variant];\n-                write!(s, \".{}::{}\", variant.name, variant.fields[i].ident)\n-            }\n-\n-            // other ADTs.\n-            ty::TyAdt(def, _) => write!(s, \".{}\", def.non_enum_variant().fields[i].ident),\n-\n-            ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n-            ty::TyInfer(_) | ty::TyError => {\n-                bug!(\"dump_field_name: unexpected type `{}`\", ty)\n-            }\n-        }\n-    }\n }\n "}, {"sha": "b769dae0a7abc2c8b73af5d22f6c502feab10544", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50999336145e85c54a14e30e90657d1d47969498/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50999336145e85c54a14e30e90657d1d47969498/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=50999336145e85c54a14e30e90657d1d47969498", "patch": "@@ -11,6 +11,7 @@ mod step;\n mod terminator;\n mod traits;\n mod const_eval;\n+mod validity;\n \n pub use self::eval_context::{\n     EvalContext, Frame, StackPopCleanup, LocalValue,"}, {"sha": "53d30068310e2917cf61e60d8950f9f625efbd83", "filename": "src/librustc_mir/interpret/validity.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/50999336145e85c54a14e30e90657d1d47969498/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50999336145e85c54a14e30e90657d1d47969498/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=50999336145e85c54a14e30e90657d1d47969498", "patch": "@@ -0,0 +1,343 @@\n+use std::fmt::Write;\n+\n+use rustc::ty::layout::{self, Size, Primitive};\n+use rustc::ty::{self, Ty};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc::mir::interpret::{\n+    Scalar, AllocType, EvalResult, ScalarMaybeUndef,\n+};\n+\n+use super::{\n+    MPlaceTy, PlaceExtra, Machine, EvalContext\n+};\n+\n+macro_rules! validation_failure{\n+    ($what:expr, $where:expr, $details:expr) => {{\n+        let where_ = if $where.is_empty() {\n+            String::new()\n+        } else {\n+            format!(\" at {}\", $where)\n+        };\n+        err!(ValidationFailure(format!(\n+            \"encountered {}{}, but expected {}\",\n+            $what, where_, $details,\n+        )))\n+    }};\n+    ($what:expr, $where:expr) => {{\n+        let where_ = if $where.is_empty() {\n+            String::new()\n+        } else {\n+            format!(\" at {}\", $where)\n+        };\n+        err!(ValidationFailure(format!(\n+            \"encountered {}{}\",\n+            $what, where_,\n+        )))\n+    }};\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    fn validate_scalar(\n+        &self,\n+        value: ScalarMaybeUndef,\n+        size: Size,\n+        scalar: &layout::Scalar,\n+        path: &str,\n+        ty: Ty,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"validate scalar: {:#?}, {:#?}, {:#?}, {}\", value, size, scalar, ty);\n+        let (lo, hi) = scalar.valid_range.clone().into_inner();\n+\n+        let value = match value {\n+            ScalarMaybeUndef::Scalar(scalar) => scalar,\n+            ScalarMaybeUndef::Undef => return validation_failure!(\"undefined bytes\", path),\n+        };\n+\n+        let bits = match value {\n+            Scalar::Bits { bits, size: value_size } => {\n+                assert_eq!(value_size as u64, size.bytes());\n+                bits\n+            },\n+            Scalar::Ptr(_) => {\n+                let ptr_size = self.memory.pointer_size();\n+                let ptr_max = u128::max_value() >> (128 - ptr_size.bits());\n+                return if lo > hi {\n+                    if lo - hi == 1 {\n+                        // no gap, all values are ok\n+                        Ok(())\n+                    } else if hi < ptr_max || lo > 1 {\n+                        let max = u128::max_value() >> (128 - size.bits());\n+                        validation_failure!(\n+                            \"pointer\",\n+                            path,\n+                            format!(\"something in the range {:?} or {:?}\", 0..=lo, hi..=max)\n+                        )\n+                    } else {\n+                        Ok(())\n+                    }\n+                } else if hi < ptr_max || lo > 1 {\n+                    validation_failure!(\n+                        \"pointer\",\n+                        path,\n+                        format!(\"something in the range {:?}\", scalar.valid_range)\n+                    )\n+                } else {\n+                    Ok(())\n+                };\n+            },\n+        };\n+\n+        // char gets a special treatment, because its number space is not contiguous so `TyLayout`\n+        // has no special checks for chars\n+        match ty.sty {\n+            ty::TyChar => {\n+                debug_assert_eq!(size.bytes(), 4);\n+                if ::std::char::from_u32(bits as u32).is_none() {\n+                    return err!(InvalidChar(bits));\n+                }\n+            }\n+            _ => {},\n+        }\n+\n+        use std::ops::RangeInclusive;\n+        let in_range = |bound: RangeInclusive<u128>| bound.contains(&bits);\n+        if lo > hi {\n+            if in_range(0..=hi) || in_range(lo..=u128::max_value()) {\n+                Ok(())\n+            } else {\n+                validation_failure!(\n+                    bits,\n+                    path,\n+                    format!(\"something in the range {:?} or {:?}\", ..=hi, lo..)\n+                )\n+            }\n+        } else {\n+            if in_range(scalar.valid_range.clone()) {\n+                Ok(())\n+            } else {\n+                validation_failure!(\n+                    bits,\n+                    path,\n+                    format!(\"something in the range {:?}\", scalar.valid_range)\n+                )\n+            }\n+        }\n+    }\n+\n+    /// This function checks the memory where `ptr` points to.\n+    /// It will error if the bits at the destination do not match the ones described by the layout.\n+    pub fn validate_mplace(\n+        &self,\n+        dest: MPlaceTy<'tcx>,\n+        path: String,\n+        seen: &mut FxHashSet<(MPlaceTy<'tcx>)>,\n+        todo: &mut Vec<(MPlaceTy<'tcx>, String)>,\n+    ) -> EvalResult<'tcx> {\n+        self.memory.dump_alloc(dest.to_ptr()?.alloc_id);\n+        trace!(\"validate_mplace: {:?}, {:#?}\", *dest, dest.layout);\n+\n+        // Find the right variant\n+        let (variant, dest) = match dest.layout.variants {\n+            layout::Variants::NicheFilling { niche: ref tag, .. } |\n+            layout::Variants::Tagged { ref tag, .. } => {\n+                let size = tag.value.size(self);\n+                // we first read the tag value as scalar, to be able to validate it\n+                let tag_mplace = self.mplace_field(dest, 0)?;\n+                let tag_value = self.read_scalar(tag_mplace.into())?;\n+                let path = format!(\"{}.TAG\", path);\n+                self.validate_scalar(\n+                    tag_value, size, tag, &path, tag_mplace.layout.ty\n+                )?;\n+                // then we read it again to get the index, to continue\n+                let variant = self.read_discriminant_as_variant_index(dest.into())?;\n+                let dest = self.mplace_downcast(dest, variant)?;\n+                trace!(\"variant layout: {:#?}\", dest.layout);\n+                (variant, dest)\n+            },\n+            layout::Variants::Single { index } => {\n+                (index, dest)\n+            }\n+        };\n+\n+        // Validate all fields\n+        match dest.layout.fields {\n+            // primitives are unions with zero fields\n+            layout::FieldPlacement::Union(0) => {\n+                match dest.layout.abi {\n+                    // nothing to do, whatever the pointer points to, it is never going to be read\n+                    layout::Abi::Uninhabited => validation_failure!(\"a value of an uninhabited type\", path),\n+                    // check that the scalar is a valid pointer or that its bit range matches the\n+                    // expectation.\n+                    layout::Abi::Scalar(ref scalar_layout) => {\n+                        let size = scalar_layout.value.size(self);\n+                        let value = self.read_value(dest.into())?;\n+                        let scalar = value.to_scalar_or_undef();\n+                        self.validate_scalar(scalar, size, scalar_layout, &path, dest.layout.ty)?;\n+                        if scalar_layout.value == Primitive::Pointer {\n+                            // ignore integer pointers, we can't reason about the final hardware\n+                            if let Scalar::Ptr(ptr) = scalar.not_undef()? {\n+                                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                                if let Some(AllocType::Static(did)) = alloc_kind {\n+                                    // statics from other crates are already checked\n+                                    // extern statics should not be validated as they have no body\n+                                    if !did.is_local() || self.tcx.is_foreign_item(did) {\n+                                        return Ok(());\n+                                    }\n+                                }\n+                                if value.layout.ty.builtin_deref(false).is_some() {\n+                                    trace!(\"Recursing below ptr {:#?}\", value);\n+                                    let ptr_place = self.ref_to_mplace(value)?;\n+                                    // we have not encountered this pointer+layout combination before\n+                                    if seen.insert(ptr_place) {\n+                                        todo.push((ptr_place, format!(\"(*{})\", path)))\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        Ok(())\n+                    },\n+                    _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", dest.layout.abi),\n+                }\n+            }\n+            layout::FieldPlacement::Union(_) => {\n+                // We can't check unions, their bits are allowed to be anything.\n+                // The fields don't need to correspond to any bit pattern of the union's fields.\n+                // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n+                Ok(())\n+            },\n+            layout::FieldPlacement::Array { count, .. } => {\n+                for i in 0..count {\n+                    let mut path = path.clone();\n+                    self.dump_field_name(&mut path, dest.layout.ty, i as usize, variant).unwrap();\n+                    let field = self.mplace_field(dest, i)?;\n+                    self.validate_mplace(field, path, seen, todo)?;\n+                }\n+                Ok(())\n+            },\n+            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n+                // fat pointers need special treatment\n+                match dest.layout.ty.builtin_deref(false).map(|tam| &tam.ty.sty) {\n+                    | Some(ty::TyStr)\n+                    | Some(ty::TySlice(_)) => {\n+                        // check the length (for nicer error messages)\n+                        let len_mplace = self.mplace_field(dest, 1)?;\n+                        let len = self.read_scalar(len_mplace.into())?;\n+                        let len = match len.to_bits(len_mplace.layout.size) {\n+                            Err(_) => return validation_failure!(\"length is not a valid integer\", path),\n+                            Ok(len) => len as u64,\n+                        };\n+                        // get the fat ptr, and recursively check it\n+                        let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n+                        assert_eq!(ptr.extra, PlaceExtra::Length(len));\n+                        let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n+                        if seen.insert(unpacked_ptr) {\n+                            let mut path = path.clone();\n+                            self.dump_field_name(&mut path, dest.layout.ty, 0, 0).unwrap();\n+                            todo.push((unpacked_ptr, path))\n+                        }\n+                    },\n+                    Some(ty::TyDynamic(..)) => {\n+                        // check the vtable (for nicer error messages)\n+                        let vtable = self.read_scalar(self.mplace_field(dest, 1)?.into())?;\n+                        let vtable = match vtable.to_ptr() {\n+                            Err(_) => return validation_failure!(\"vtable address is not a pointer\", path),\n+                            Ok(vtable) => vtable,\n+                        };\n+                        // get the fat ptr, and recursively check it\n+                        let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n+                        assert_eq!(ptr.extra, PlaceExtra::Vtable(vtable));\n+                        let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n+                        if seen.insert(unpacked_ptr) {\n+                            let mut path = path.clone();\n+                            self.dump_field_name(&mut path, dest.layout.ty, 0, 0).unwrap();\n+                            todo.push((unpacked_ptr, path))\n+                        }\n+                        // FIXME: More checks for the vtable... making sure it is exactly\n+                        // the one one would expect for this type.\n+                    },\n+                    Some(ty) =>\n+                        bug!(\"Unexpected fat pointer target type {:?}\", ty),\n+                    None => {\n+                        // Not a pointer, perform regular aggregate handling below\n+                        for i in 0..offsets.len() {\n+                            let mut path = path.clone();\n+                            self.dump_field_name(&mut path, dest.layout.ty, i, variant).unwrap();\n+                            let field = self.mplace_field(dest, i as u64)?;\n+                            self.validate_mplace(field, path, seen, todo)?;\n+                        }\n+                        // FIXME: For a TyStr, check that this is valid UTF-8.\n+                    },\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    fn dump_field_name(&self, s: &mut String, ty: Ty<'tcx>, i: usize, variant: usize) -> ::std::fmt::Result {\n+        match ty.sty {\n+            ty::TyBool |\n+            ty::TyChar |\n+            ty::TyInt(_) |\n+            ty::TyUint(_) |\n+            ty::TyFloat(_) |\n+            ty::TyFnPtr(_) |\n+            ty::TyNever |\n+            ty::TyFnDef(..) |\n+            ty::TyGeneratorWitness(..) |\n+            ty::TyForeign(..) |\n+            ty::TyDynamic(..) => {\n+                bug!(\"field_name({:?}): not applicable\", ty)\n+            }\n+\n+            // Potentially-fat pointers.\n+            ty::TyRef(_, pointee, _) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+                assert!(i < 2);\n+\n+                // Reuse the fat *T type as its own thin pointer data field.\n+                // This provides information about e.g. DST struct pointees\n+                // (which may have no non-DST form), and will work as long\n+                // as the `Abi` or `FieldPlacement` is checked by users.\n+                if i == 0 {\n+                    return write!(s, \".data_ptr\");\n+                }\n+\n+                match self.tcx.struct_tail(pointee).sty {\n+                    ty::TySlice(_) |\n+                    ty::TyStr => write!(s, \".len\"),\n+                    ty::TyDynamic(..) => write!(s, \".vtable_ptr\"),\n+                    _ => bug!(\"field_name({:?}): not applicable\", ty)\n+                }\n+            }\n+\n+            // Arrays and slices.\n+            ty::TyArray(_, _) |\n+            ty::TySlice(_) |\n+            ty::TyStr => write!(s, \"[{}]\", i),\n+\n+            // generators and closures.\n+            ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {\n+                let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+                let freevar = self.tcx.with_freevars(node_id, |fv| fv[i]);\n+                write!(s, \".upvar({})\", self.tcx.hir.name(freevar.var_id()))\n+            }\n+\n+            ty::TyTuple(_) => write!(s, \".{}\", i),\n+\n+            // enums\n+            ty::TyAdt(def, ..) if def.is_enum() => {\n+                let variant = &def.variants[variant];\n+                write!(s, \".{}::{}\", variant.name, variant.fields[i].ident)\n+            }\n+\n+            // other ADTs.\n+            ty::TyAdt(def, _) => write!(s, \".{}\", def.non_enum_variant().fields[i].ident),\n+\n+            ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n+            ty::TyInfer(_) | ty::TyError => {\n+                bug!(\"dump_field_name: unexpected type `{}`\", ty)\n+            }\n+        }\n+    }\n+}"}]}