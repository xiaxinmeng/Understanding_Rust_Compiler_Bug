{"sha": "3321799e8fac622db50fe8c3284062f7d0f1bf53", "node_id": "C_kwDOAAsO6NoAKDMzMjE3OTllOGZhYzYyMmRiNTBmZThjMzI4NDA2MmY3ZDBmMWJmNTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T19:57:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T19:57:27Z"}, "message": "Auto merge of #14368 - HKalbasi:mir, r=HKalbasi\n\nMIR episode 3\n\nThis PR adds lowering for try operator and overloaded dereference, and adds evaluating support for function pointers and trait objects. It also adds a flag to `analysis-stats` to show percentage of functions that it fails to emit mir for them, which is currently `20%` (which is somehow lying, as most of the supported `80%` are tests). The most offenders are closure (1975 items) and overloaded index (415 items). I will try to add overloaded index before monday to have it in this PR, and tackle the closure in the next episode.", "tree": {"sha": "07ea55d6af66d030709b0cbb76e46792ba381972", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07ea55d6af66d030709b0cbb76e46792ba381972"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3321799e8fac622db50fe8c3284062f7d0f1bf53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3321799e8fac622db50fe8c3284062f7d0f1bf53", "html_url": "https://github.com/rust-lang/rust/commit/3321799e8fac622db50fe8c3284062f7d0f1bf53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3321799e8fac622db50fe8c3284062f7d0f1bf53/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d7511938a8864ccfa0a32d4884d9b92b0a37048", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d7511938a8864ccfa0a32d4884d9b92b0a37048", "html_url": "https://github.com/rust-lang/rust/commit/6d7511938a8864ccfa0a32d4884d9b92b0a37048"}, {"sha": "8a3ad7c3d592adac72b1fce6bc208cdf7a40c8ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a3ad7c3d592adac72b1fce6bc208cdf7a40c8ad", "html_url": "https://github.com/rust-lang/rust/commit/8a3ad7c3d592adac72b1fce6bc208cdf7a40c8ad"}], "stats": {"total": 4033, "additions": 3098, "deletions": 935}, "files": [{"sha": "7f9b9476dcd9110dcaac418f99653b2e617e8f8a", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -391,7 +391,7 @@ impl Body {\n             }\n         };\n         let expander = Expander::new(db, file_id, module);\n-        let (mut body, source_map) = Body::new(db, expander, params, body);\n+        let (mut body, source_map) = Body::new(db, expander, params, body, module.krate);\n         body.shrink_to_fit();\n \n         (Arc::new(body), Arc::new(source_map))\n@@ -420,8 +420,9 @@ impl Body {\n         expander: Expander,\n         params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n         body: Option<ast::Expr>,\n+        krate: CrateId,\n     ) -> (Body, BodySourceMap) {\n-        lower::lower(db, expander, params, body)\n+        lower::lower(db, expander, params, body, krate)\n     }\n \n     fn shrink_to_fit(&mut self) {"}, {"sha": "a93fcb3b1dc29cbfe88d92da2483d34bb0398622", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 156, "deletions": 23, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -3,6 +3,7 @@\n \n use std::{mem, sync::Arc};\n \n+use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     ast_id_map::AstIdMap,\n@@ -18,7 +19,7 @@ use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use syntax::{\n     ast::{\n-        self, ArrayExprKind, AstChildren, HasArgList, HasLoopBody, HasName, LiteralKind,\n+        self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasLoopBody, HasName, LiteralKind,\n         SlicePatComponents,\n     },\n     AstNode, AstPtr, SyntaxNodePtr,\n@@ -36,6 +37,7 @@ use crate::{\n         RecordFieldPat, RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n+    lang_item::LangItem,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n@@ -80,9 +82,11 @@ pub(super) fn lower(\n     expander: Expander,\n     params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n     body: Option<ast::Expr>,\n+    krate: CrateId,\n ) -> (Body, BodySourceMap) {\n     ExprCollector {\n         db,\n+        krate,\n         source_map: BodySourceMap::default(),\n         ast_id_map: db.ast_id_map(expander.current_file_id),\n         body: Body {\n@@ -96,6 +100,7 @@ pub(super) fn lower(\n             _c: Count::new(),\n         },\n         expander,\n+        current_try_block: None,\n         is_lowering_assignee_expr: false,\n         is_lowering_generator: false,\n     }\n@@ -107,7 +112,9 @@ struct ExprCollector<'a> {\n     expander: Expander,\n     ast_id_map: Arc<AstIdMap>,\n     body: Body,\n+    krate: CrateId,\n     source_map: BodySourceMap,\n+    current_try_block: Option<LabelId>,\n     is_lowering_assignee_expr: bool,\n     is_lowering_generator: bool,\n }\n@@ -176,8 +183,7 @@ impl ExprCollector<'_> {\n         self.source_map.expr_map.insert(src, id);\n         id\n     }\n-    // desugared exprs don't have ptr, that's wrong and should be fixed\n-    // somehow.\n+    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed somehow.\n     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n         self.body.exprs.alloc(expr)\n     }\n@@ -199,6 +205,10 @@ impl ExprCollector<'_> {\n         self.source_map.pat_map.insert(src, id);\n         id\n     }\n+    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {\n+        self.body.pats.alloc(pat)\n+    }\n     fn missing_pat(&mut self) -> PatId {\n         self.body.pats.alloc(Pat::Missing)\n     }\n@@ -214,6 +224,10 @@ impl ExprCollector<'_> {\n         self.source_map.label_map.insert(src, id);\n         id\n     }\n+    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_label_desugared(&mut self, label: Label) -> LabelId {\n+        self.body.labels.alloc(label)\n+    }\n     fn make_label(&mut self, label: Label, src: LabelSource) -> LabelId {\n         let id = self.body.labels.alloc(label);\n         self.source_map.label_map_back.insert(id, src);\n@@ -251,13 +265,7 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Let { pat, expr }, syntax_ptr)\n             }\n             ast::Expr::BlockExpr(e) => match e.modifier() {\n-                Some(ast::BlockModifier::Try(_)) => {\n-                    self.collect_block_(e, |id, statements, tail| Expr::TryBlock {\n-                        id,\n-                        statements,\n-                        tail,\n-                    })\n-                }\n+                Some(ast::BlockModifier::Try(_)) => self.collect_try_block(e),\n                 Some(ast::BlockModifier::Unsafe(_)) => {\n                     self.collect_block_(e, |id, statements, tail| Expr::Unsafe {\n                         id,\n@@ -437,10 +445,7 @@ impl ExprCollector<'_> {\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n             }\n-            ast::Expr::TryExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n-            }\n+            ast::Expr::TryExpr(e) => self.collect_try_operator(syntax_ptr, e),\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let type_ref = Interned::new(TypeRef::from_ast_opt(&self.ctx(), e.ty()));\n@@ -601,6 +606,126 @@ impl ExprCollector<'_> {\n         })\n     }\n \n+    /// Desugar `try { <stmts>; <expr> }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(<expr>) }`,\n+    /// `try { <stmts>; }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(()) }`\n+    /// and save the `<new_label>` to use it as a break target for desugaring of the `?` operator.\n+    fn collect_try_block(&mut self, e: BlockExpr) -> ExprId {\n+        let Some(try_from_output) = LangItem::TryTraitFromOutput.path(self.db, self.krate) else {\n+            return self.alloc_expr_desugared(Expr::Missing);\n+        };\n+        let prev_try_block = self.current_try_block.take();\n+        self.current_try_block =\n+            Some(self.alloc_label_desugared(Label { name: Name::generate_new_name() }));\n+        let expr_id = self.collect_block(e);\n+        let callee = self.alloc_expr_desugared(Expr::Path(try_from_output));\n+        let Expr::Block { label, tail, .. } = &mut self.body.exprs[expr_id] else {\n+            unreachable!(\"It is the output of collect block\");\n+        };\n+        *label = self.current_try_block;\n+        let next_tail = match *tail {\n+            Some(tail) => self.alloc_expr_desugared(Expr::Call {\n+                callee,\n+                args: Box::new([tail]),\n+                is_assignee_expr: false,\n+            }),\n+            None => {\n+                let unit = self.alloc_expr_desugared(Expr::Tuple {\n+                    exprs: Box::new([]),\n+                    is_assignee_expr: false,\n+                });\n+                self.alloc_expr_desugared(Expr::Call {\n+                    callee,\n+                    args: Box::new([unit]),\n+                    is_assignee_expr: false,\n+                })\n+            }\n+        };\n+        let Expr::Block { tail, .. } = &mut self.body.exprs[expr_id] else {\n+            unreachable!(\"It is the output of collect block\");\n+        };\n+        *tail = Some(next_tail);\n+        self.current_try_block = prev_try_block;\n+        expr_id\n+    }\n+\n+    /// Desugar `ast::TryExpr` from: `<expr>?` into:\n+    /// ```ignore (pseudo-rust)\n+    /// match Try::branch(<expr>) {\n+    ///     ControlFlow::Continue(val) => val,\n+    ///     ControlFlow::Break(residual) =>\n+    ///         // If there is an enclosing `try {...}`:\n+    ///         break 'catch_target Try::from_residual(residual),\n+    ///         // Otherwise:\n+    ///         return Try::from_residual(residual),\n+    /// }\n+    /// ```\n+    fn collect_try_operator(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::TryExpr) -> ExprId {\n+        let (try_branch, cf_continue, cf_break, try_from_residual) = 'if_chain: {\n+            if let Some(try_branch) = LangItem::TryTraitBranch.path(self.db, self.krate) {\n+                if let Some(cf_continue) = LangItem::ControlFlowContinue.path(self.db, self.krate) {\n+                    if let Some(cf_break) = LangItem::ControlFlowBreak.path(self.db, self.krate) {\n+                        if let Some(try_from_residual) =\n+                            LangItem::TryTraitFromResidual.path(self.db, self.krate)\n+                        {\n+                            break 'if_chain (try_branch, cf_continue, cf_break, try_from_residual);\n+                        }\n+                    }\n+                }\n+            }\n+            // Some of the needed lang items are missing, so we can't desugar\n+            return self.alloc_expr(Expr::Missing, syntax_ptr);\n+        };\n+        let operand = self.collect_expr_opt(e.expr());\n+        let try_branch = self.alloc_expr(Expr::Path(try_branch), syntax_ptr.clone());\n+        let expr = self.alloc_expr(\n+            Expr::Call { callee: try_branch, args: Box::new([operand]), is_assignee_expr: false },\n+            syntax_ptr.clone(),\n+        );\n+        let continue_name = Name::generate_new_name();\n+        let continue_binding =\n+            self.alloc_binding(continue_name.clone(), BindingAnnotation::Unannotated);\n+        let continue_bpat =\n+            self.alloc_pat_desugared(Pat::Bind { id: continue_binding, subpat: None });\n+        self.add_definition_to_binding(continue_binding, continue_bpat);\n+        let continue_arm = MatchArm {\n+            pat: self.alloc_pat_desugared(Pat::TupleStruct {\n+                path: Some(Box::new(cf_continue)),\n+                args: Box::new([continue_bpat]),\n+                ellipsis: None,\n+            }),\n+            guard: None,\n+            expr: self.alloc_expr(Expr::Path(Path::from(continue_name)), syntax_ptr.clone()),\n+        };\n+        let break_name = Name::generate_new_name();\n+        let break_binding = self.alloc_binding(break_name.clone(), BindingAnnotation::Unannotated);\n+        let break_bpat = self.alloc_pat_desugared(Pat::Bind { id: break_binding, subpat: None });\n+        self.add_definition_to_binding(break_binding, break_bpat);\n+        let break_arm = MatchArm {\n+            pat: self.alloc_pat_desugared(Pat::TupleStruct {\n+                path: Some(Box::new(cf_break)),\n+                args: Box::new([break_bpat]),\n+                ellipsis: None,\n+            }),\n+            guard: None,\n+            expr: {\n+                let x = self.alloc_expr(Expr::Path(Path::from(break_name)), syntax_ptr.clone());\n+                let callee = self.alloc_expr(Expr::Path(try_from_residual), syntax_ptr.clone());\n+                let result = self.alloc_expr(\n+                    Expr::Call { callee, args: Box::new([x]), is_assignee_expr: false },\n+                    syntax_ptr.clone(),\n+                );\n+                if let Some(label) = self.current_try_block {\n+                    let label = Some(self.body.labels[label].name.clone());\n+                    self.alloc_expr(Expr::Break { expr: Some(result), label }, syntax_ptr.clone())\n+                } else {\n+                    self.alloc_expr(Expr::Return { expr: Some(result) }, syntax_ptr.clone())\n+                }\n+            },\n+        };\n+        let arms = Box::new([continue_arm, break_arm]);\n+        self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n+    }\n+\n     fn collect_macro_call<F, T, U>(\n         &mut self,\n         mcall: ast::MacroCall,\n@@ -949,16 +1074,24 @@ impl ExprCollector<'_> {\n                         .collect(),\n                 }\n             }\n-            ast::Pat::LiteralPat(lit) => {\n-                if let Some(ast_lit) = lit.literal() {\n-                    let expr = Expr::Literal(ast_lit.kind().into());\n+            // FIXME: rustfmt removes this label if it is a block and not a loop\n+            ast::Pat::LiteralPat(lit) => 'b: loop {\n+                break if let Some(ast_lit) = lit.literal() {\n+                    let mut hir_lit: Literal = ast_lit.kind().into();\n+                    if lit.minus_token().is_some() {\n+                        let Some(h) = hir_lit.negate() else {\n+                            break 'b Pat::Missing;\n+                        };\n+                        hir_lit = h;\n+                    }\n+                    let expr = Expr::Literal(hir_lit);\n                     let expr_ptr = AstPtr::new(&ast::Expr::Literal(ast_lit));\n                     let expr_id = self.alloc_expr(expr, expr_ptr);\n                     Pat::Lit(expr_id)\n                 } else {\n                     Pat::Missing\n-                }\n-            }\n+                };\n+            },\n             ast::Pat::RestPat(_) => {\n                 // `RestPat` requires special handling and should not be mapped\n                 // to a Pat. Here we are using `Pat::Missing` as a fallback for\n@@ -1063,11 +1196,11 @@ impl From<ast::LiteralKind> for Literal {\n                         FloatTypeWrapper::new(lit.float_value().unwrap_or(Default::default())),\n                         builtin,\n                     )\n-                } else if let builtin @ Some(_) = lit.suffix().and_then(BuiltinInt::from_suffix) {\n-                    Literal::Int(lit.value().unwrap_or(0) as i128, builtin)\n-                } else {\n-                    let builtin = lit.suffix().and_then(BuiltinUint::from_suffix);\n+                } else if let builtin @ Some(_) = lit.suffix().and_then(BuiltinUint::from_suffix) {\n                     Literal::Uint(lit.value().unwrap_or(0), builtin)\n+                } else {\n+                    let builtin = lit.suffix().and_then(BuiltinInt::from_suffix);\n+                    Literal::Int(lit.value().unwrap_or(0) as i128, builtin)\n                 }\n             }\n             LiteralKind::FloatNumber(lit) => {"}, {"sha": "8c9d77620e188a018360f1984e1c9c6e9f1ea6ec", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -288,10 +288,6 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*expr);\n                 w!(self, \".await\");\n             }\n-            Expr::Try { expr } => {\n-                self.print_expr(*expr);\n-                w!(self, \"?\");\n-            }\n             Expr::Cast { expr, type_ref } => {\n                 self.print_expr(*expr);\n                 w!(self, \" as \");\n@@ -424,9 +420,6 @@ impl<'a> Printer<'a> {\n             Expr::Unsafe { id: _, statements, tail } => {\n                 self.print_block(Some(\"unsafe \"), statements, tail);\n             }\n-            Expr::TryBlock { id: _, statements, tail } => {\n-                self.print_block(Some(\"try \"), statements, tail);\n-            }\n             Expr::Async { id: _, statements, tail } => {\n                 self.print_block(Some(\"async \"), statements, tail);\n             }"}, {"sha": "8ddb89a4725d5d8af68da94b6e6789494c55078f", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -202,8 +202,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         }\n         Expr::Unsafe { id, statements, tail }\n         | Expr::Async { id, statements, tail }\n-        | Expr::Const { id, statements, tail }\n-        | Expr::TryBlock { id, statements, tail } => {\n+        | Expr::Const { id, statements, tail } => {\n             let mut scope = scopes.new_block_scope(*scope, *id, None);\n             // Overwrite the old scope for the block expr, so that every block scope can be found\n             // via the block itself (important for blocks that only contain items, no expressions)."}, {"sha": "7ede19cc3c2b48a34008113c7ac57d70aa59f1b8", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -92,6 +92,16 @@ pub enum Literal {\n     Float(FloatTypeWrapper, Option<BuiltinFloat>),\n }\n \n+impl Literal {\n+    pub fn negate(self) -> Option<Self> {\n+        if let Literal::Int(i, k) = self {\n+            Some(Literal::Int(-i, k))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Expr {\n     /// This is produced if the syntax tree does not have a required expression piece.\n@@ -112,11 +122,6 @@ pub enum Expr {\n         tail: Option<ExprId>,\n         label: Option<LabelId>,\n     },\n-    TryBlock {\n-        id: BlockId,\n-        statements: Box<[Statement]>,\n-        tail: Option<ExprId>,\n-    },\n     Async {\n         id: BlockId,\n         statements: Box<[Statement]>,\n@@ -192,9 +197,6 @@ pub enum Expr {\n     Await {\n         expr: ExprId,\n     },\n-    Try {\n-        expr: ExprId,\n-    },\n     Cast {\n         expr: ExprId,\n         type_ref: Interned<TypeRef>,\n@@ -303,7 +305,6 @@ impl Expr {\n                 f(*expr);\n             }\n             Expr::Block { statements, tail, .. }\n-            | Expr::TryBlock { statements, tail, .. }\n             | Expr::Unsafe { statements, tail, .. }\n             | Expr::Async { statements, tail, .. }\n             | Expr::Const { statements, tail, .. } => {\n@@ -383,7 +384,6 @@ impl Expr {\n             }\n             Expr::Field { expr, .. }\n             | Expr::Await { expr }\n-            | Expr::Try { expr }\n             | Expr::Cast { expr, .. }\n             | Expr::Ref { expr, .. }\n             | Expr::UnaryOp { expr, .. }"}, {"sha": "818054188bea32828e05f0fef2e910313820c381", "filename": "crates/hir-def/src/lang_item.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flang_item.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -8,8 +8,8 @@ use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n \n use crate::{\n-    db::DefDatabase, AdtId, AssocItemId, AttrDefId, CrateId, EnumId, EnumVariantId, FunctionId,\n-    ImplId, ModuleDefId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n+    db::DefDatabase, path::Path, AdtId, AssocItemId, AttrDefId, CrateId, EnumId, EnumVariantId,\n+    FunctionId, ImplId, ModuleDefId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -220,11 +220,6 @@ macro_rules! language_item_table {\n                 }\n             }\n \n-            /// Opposite of [`LangItem::name`]\n-            pub fn from_name(name: &hir_expand::name::Name) -> Option<Self> {\n-                Self::from_str(name.as_str()?)\n-            }\n-\n             /// Opposite of [`LangItem::name`]\n             pub fn from_str(name: &str) -> Option<Self> {\n                 match name {\n@@ -236,6 +231,18 @@ macro_rules! language_item_table {\n     }\n }\n \n+impl LangItem {\n+    /// Opposite of [`LangItem::name`]\n+    pub fn from_name(name: &hir_expand::name::Name) -> Option<Self> {\n+        Self::from_str(name.as_str()?)\n+    }\n+\n+    pub fn path(&self, db: &dyn DefDatabase, start_crate: CrateId) -> Option<Path> {\n+        let t = db.lang_item(start_crate, *self)?;\n+        Some(Path::LangItem(t))\n+    }\n+}\n+\n language_item_table! {\n //  Variant name,            Name,                     Getter method name,         Target                  Generic requirements;\n     Sized,                   sized,               sized_trait,                Target::Trait,          GenericRequirement::Exact(0);"}, {"sha": "c67c29818f5b14c6eeb04a6297b2368d5159c960", "filename": "crates/hir-def/src/path.rs", "status": "modified", "additions": 58, "deletions": 25, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -8,6 +8,7 @@ use std::{\n \n use crate::{\n     body::LowerCtx,\n+    lang_item::LangItemTarget,\n     type_ref::{ConstRefOrPath, LifetimeRef},\n };\n use hir_expand::name::Name;\n@@ -36,13 +37,19 @@ impl Display for ImportAlias {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Path {\n-    /// Type based path like `<T>::foo`.\n-    /// Note that paths like `<Type as Trait>::foo` are desugared to `Trait::<Self=Type>::foo`.\n-    type_anchor: Option<Interned<TypeRef>>,\n-    mod_path: Interned<ModPath>,\n-    /// Invariant: the same len as `self.mod_path.segments` or `None` if all segments are `None`.\n-    generic_args: Option<Box<[Option<Interned<GenericArgs>>]>>,\n+pub enum Path {\n+    /// A normal path\n+    Normal {\n+        /// Type based path like `<T>::foo`.\n+        /// Note that paths like `<Type as Trait>::foo` are desugared to `Trait::<Self=Type>::foo`.\n+        type_anchor: Option<Interned<TypeRef>>,\n+        mod_path: Interned<ModPath>,\n+        /// Invariant: the same len as `self.mod_path.segments` or `None` if all segments are `None`.\n+        generic_args: Option<Box<[Option<Interned<GenericArgs>>]>>,\n+    },\n+    /// A link to a lang item. It is used in desugaring of things like `x?`. We can show these\n+    /// links via a normal path since they might be private and not accessible in the usage place.\n+    LangItem(LangItemTarget),\n }\n \n /// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n@@ -102,51 +109,77 @@ impl Path {\n     ) -> Path {\n         let generic_args = generic_args.into();\n         assert_eq!(path.len(), generic_args.len());\n-        Path { type_anchor: None, mod_path: Interned::new(path), generic_args: Some(generic_args) }\n+        Path::Normal {\n+            type_anchor: None,\n+            mod_path: Interned::new(path),\n+            generic_args: Some(generic_args),\n+        }\n+    }\n+\n+    /// Converts a known mod path to `Path`.\n+    pub fn from_known_path_with_no_generic(path: ModPath) -> Path {\n+        Path::Normal { type_anchor: None, mod_path: Interned::new(path), generic_args: None }\n     }\n \n     pub fn kind(&self) -> &PathKind {\n-        &self.mod_path.kind\n+        match self {\n+            Path::Normal { mod_path, .. } => &mod_path.kind,\n+            Path::LangItem(_) => &PathKind::Abs,\n+        }\n     }\n \n     pub fn type_anchor(&self) -> Option<&TypeRef> {\n-        self.type_anchor.as_deref()\n+        match self {\n+            Path::Normal { type_anchor, .. } => type_anchor.as_deref(),\n+            Path::LangItem(_) => None,\n+        }\n     }\n \n     pub fn segments(&self) -> PathSegments<'_> {\n-        let s = PathSegments {\n-            segments: self.mod_path.segments(),\n-            generic_args: self.generic_args.as_deref(),\n+        let Path::Normal { mod_path, generic_args, .. } = self else {\n+            return PathSegments {\n+                segments: &[],\n+                generic_args: None,\n+            };\n         };\n+        let s =\n+            PathSegments { segments: mod_path.segments(), generic_args: generic_args.as_deref() };\n         if let Some(generic_args) = s.generic_args {\n             assert_eq!(s.segments.len(), generic_args.len());\n         }\n         s\n     }\n \n-    pub fn mod_path(&self) -> &ModPath {\n-        &self.mod_path\n+    pub fn mod_path(&self) -> Option<&ModPath> {\n+        match self {\n+            Path::Normal { mod_path, .. } => Some(&mod_path),\n+            Path::LangItem(_) => None,\n+        }\n     }\n \n     pub fn qualifier(&self) -> Option<Path> {\n-        if self.mod_path.is_ident() {\n+        let Path::Normal { mod_path, generic_args, type_anchor } = self else {\n+            return None;\n+        };\n+        if mod_path.is_ident() {\n             return None;\n         }\n-        let res = Path {\n-            type_anchor: self.type_anchor.clone(),\n+        let res = Path::Normal {\n+            type_anchor: type_anchor.clone(),\n             mod_path: Interned::new(ModPath::from_segments(\n-                self.mod_path.kind,\n-                self.mod_path.segments()[..self.mod_path.segments().len() - 1].iter().cloned(),\n+                mod_path.kind,\n+                mod_path.segments()[..mod_path.segments().len() - 1].iter().cloned(),\n             )),\n-            generic_args: self.generic_args.as_ref().map(|it| it[..it.len() - 1].to_vec().into()),\n+            generic_args: generic_args.as_ref().map(|it| it[..it.len() - 1].to_vec().into()),\n         };\n         Some(res)\n     }\n \n     pub fn is_self_type(&self) -> bool {\n-        self.type_anchor.is_none()\n-            && self.generic_args.as_deref().is_none()\n-            && self.mod_path.is_Self()\n+        let Path::Normal { mod_path, generic_args, type_anchor } = self else {\n+            return false;\n+        };\n+        type_anchor.is_none() && generic_args.as_deref().is_none() && mod_path.is_Self()\n     }\n }\n \n@@ -222,7 +255,7 @@ impl GenericArgs {\n \n impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n-        Path {\n+        Path::Normal {\n             type_anchor: None,\n             mod_path: Interned::new(ModPath::from_segments(PathKind::Plain, iter::once(name))),\n             generic_args: None,"}, {"sha": "407f38daad4f5e67e1cd11656ef4d81954c73859", "filename": "crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -75,8 +75,11 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n                     }\n                     // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                     Some(trait_ref) => {\n-                        let Path { mod_path, generic_args: path_generic_args, .. } =\n-                            Path::from_src(trait_ref.path()?, ctx)?;\n+                        let Path::Normal { mod_path, generic_args: path_generic_args, .. } =\n+                            Path::from_src(trait_ref.path()?, ctx)? else\n+                        {\n+                            return None;\n+                        };\n                         let num_segments = mod_path.segments().len();\n                         kind = mod_path.kind;\n \n@@ -157,7 +160,7 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n     }\n \n     let mod_path = Interned::new(ModPath::from_segments(kind, segments));\n-    return Some(Path {\n+    return Some(Path::Normal {\n         type_anchor,\n         mod_path,\n         generic_args: if generic_args.is_empty() { None } else { Some(generic_args.into()) },"}, {"sha": "958882d43e309d4b4c098db2bf4de0aefb7647c6", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -15,8 +15,9 @@ use crate::{\n     expr::{BindingId, ExprId, LabelId},\n     generics::{GenericParams, TypeOrConstParamData},\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n+    lang_item::LangItemTarget,\n     nameres::DefMap,\n-    path::{ModPath, PathKind},\n+    path::{ModPath, Path, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n     AdtId, AssocItemId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId,\n@@ -176,8 +177,27 @@ impl Resolver {\n     pub fn resolve_path_in_type_ns(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<(TypeNs, Option<usize>)> {\n+        let path = match path {\n+            Path::Normal { mod_path, .. } => mod_path,\n+            Path::LangItem(l) => {\n+                return Some((\n+                    match *l {\n+                        LangItemTarget::Union(x) => TypeNs::AdtId(x.into()),\n+                        LangItemTarget::TypeAlias(x) => TypeNs::TypeAliasId(x),\n+                        LangItemTarget::Struct(x) => TypeNs::AdtId(x.into()),\n+                        LangItemTarget::EnumVariant(x) => TypeNs::EnumVariantId(x),\n+                        LangItemTarget::EnumId(x) => TypeNs::AdtId(x.into()),\n+                        LangItemTarget::Trait(x) => TypeNs::TraitId(x),\n+                        LangItemTarget::Function(_)\n+                        | LangItemTarget::ImplDef(_)\n+                        | LangItemTarget::Static(_) => return None,\n+                    },\n+                    None,\n+                ))\n+            }\n+        };\n         let first_name = path.segments().first()?;\n         let skip_to_mod = path.kind != PathKind::Plain;\n         if skip_to_mod {\n@@ -217,7 +237,7 @@ impl Resolver {\n     pub fn resolve_path_in_type_ns_fully(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<TypeNs> {\n         let (res, unresolved) = self.resolve_path_in_type_ns(db, path)?;\n         if unresolved.is_some() {\n@@ -245,8 +265,24 @@ impl Resolver {\n     pub fn resolve_path_in_value_ns(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<ResolveValueResult> {\n+        let path = match path {\n+            Path::Normal { mod_path, .. } => mod_path,\n+            Path::LangItem(l) => {\n+                return Some(ResolveValueResult::ValueNs(match *l {\n+                    LangItemTarget::Function(x) => ValueNs::FunctionId(x),\n+                    LangItemTarget::Static(x) => ValueNs::StaticId(x),\n+                    LangItemTarget::Struct(x) => ValueNs::StructId(x),\n+                    LangItemTarget::EnumVariant(x) => ValueNs::EnumVariantId(x),\n+                    LangItemTarget::Union(_)\n+                    | LangItemTarget::ImplDef(_)\n+                    | LangItemTarget::TypeAlias(_)\n+                    | LangItemTarget::Trait(_)\n+                    | LangItemTarget::EnumId(_) => return None,\n+                }))\n+            }\n+        };\n         let n_segments = path.segments().len();\n         let tmp = name![self];\n         let first_name = if path.is_self() { &tmp } else { path.segments().first()? };\n@@ -340,7 +376,7 @@ impl Resolver {\n     pub fn resolve_path_in_value_ns_fully(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n             ResolveValueResult::ValueNs(it) => Some(it),\n@@ -441,7 +477,7 @@ impl Resolver {\n                 &Scope::ImplDefScope(impl_) => {\n                     if let Some(target_trait) = &db.impl_data(impl_).target_trait {\n                         if let Some(TypeNs::TraitId(trait_)) =\n-                            self.resolve_path_in_type_ns_fully(db, target_trait.path.mod_path())\n+                            self.resolve_path_in_type_ns_fully(db, &target_trait.path)\n                         {\n                             traits.insert(trait_);\n                         }"}, {"sha": "8099c20b027c28e49b7b05a1b394af7dcf90d127", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -78,7 +78,7 @@ impl Name {\n         Self::new_text(lt.text().into())\n     }\n \n-    /// Shortcut to create inline plain text name\n+    /// Shortcut to create inline plain text name. Panics if `text.len() > 22`\n     const fn new_inline(text: &str) -> Name {\n         Name::new_text(SmolStr::new_inline(text))\n     }\n@@ -112,6 +112,18 @@ impl Name {\n         Name::new_inline(\"[missing name]\")\n     }\n \n+    /// Generates a new name which is only equal to itself, by incrementing a counter. Due\n+    /// its implementation, it should not be used in things that salsa considers, like\n+    /// type names or field names, and it should be only used in names of local variables\n+    /// and labels and similar things.\n+    pub fn generate_new_name() -> Name {\n+        use std::sync::atomic::{AtomicUsize, Ordering};\n+        static CNT: AtomicUsize = AtomicUsize::new(0);\n+        let c = CNT.fetch_add(1, Ordering::Relaxed);\n+        // FIXME: Currently a `__RA_generated_name` in user code will break our analysis\n+        Name::new_text(format!(\"__RA_geneated_name_{c}\").into())\n+    }\n+\n     /// Returns the tuple index this name represents if it is a tuple field.\n     pub fn as_tuple_index(&self) -> Option<usize> {\n         match self.0 {\n@@ -343,6 +355,8 @@ pub mod known {\n         feature,\n         // known methods of lang items\n         call_once,\n+        call_mut,\n+        call,\n         eq,\n         ne,\n         ge,"}, {"sha": "7e69971fee789e5069790cfdddabb62dbf971fc2", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -4,7 +4,7 @@ use base_db::CrateId;\n use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData};\n use hir_def::{\n     expr::Expr,\n-    path::ModPath,\n+    path::Path,\n     resolver::{Resolver, ValueNs},\n     type_ref::ConstRef,\n     ConstId, EnumVariantId,\n@@ -15,7 +15,7 @@ use stdx::never;\n use crate::{\n     db::HirDatabase, infer::InferenceContext, layout::layout_of_ty, lower::ParamLoweringMode,\n     to_placeholder_idx, utils::Generics, Const, ConstData, ConstScalar, ConstValue, GenericArg,\n-    Interner, MemoryMap, Ty, TyBuilder,\n+    Interner, MemoryMap, Substitution, Ty, TyBuilder,\n };\n \n use super::mir::{interpret_mir, lower_to_mir, pad16, MirEvalError, MirLowerError};\n@@ -72,7 +72,7 @@ impl From<MirEvalError> for ConstEvalError {\n pub(crate) fn path_to_const(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n-    path: &ModPath,\n+    path: &Path,\n     mode: ParamLoweringMode,\n     args_lazy: impl FnOnce() -> Generics,\n     debruijn: DebruijnIndex,\n@@ -89,7 +89,7 @@ pub(crate) fn path_to_const(\n                     Some(x) => ConstValue::BoundVar(BoundVar::new(debruijn, x)),\n                     None => {\n                         never!(\n-                            \"Generic list doesn't contain this param: {:?}, {}, {:?}\",\n+                            \"Generic list doesn't contain this param: {:?}, {:?}, {:?}\",\n                             args,\n                             path,\n                             p\n@@ -169,6 +169,7 @@ pub(crate) fn const_eval_recover(\n     _: &dyn HirDatabase,\n     _: &[String],\n     _: &ConstId,\n+    _: &Substitution,\n ) -> Result<Const, ConstEvalError> {\n     Err(ConstEvalError::MirLowerError(MirLowerError::Loop))\n }\n@@ -184,10 +185,11 @@ pub(crate) fn const_eval_discriminant_recover(\n pub(crate) fn const_eval_query(\n     db: &dyn HirDatabase,\n     const_id: ConstId,\n+    subst: Substitution,\n ) -> Result<Const, ConstEvalError> {\n     let def = const_id.into();\n     let body = db.mir_body(def)?;\n-    let c = interpret_mir(db, &body, false)?;\n+    let c = interpret_mir(db, &body, subst, false)?;\n     Ok(c)\n }\n \n@@ -210,7 +212,7 @@ pub(crate) fn const_eval_discriminant_variant(\n         return Ok(value);\n     }\n     let mir_body = db.mir_body(def)?;\n-    let c = interpret_mir(db, &mir_body, false)?;\n+    let c = interpret_mir(db, &mir_body, Substitution::empty(Interner), false)?;\n     let c = try_const_usize(&c).unwrap() as i128;\n     Ok(c)\n }\n@@ -228,13 +230,13 @@ pub(crate) fn eval_to_const(\n     let db = ctx.db;\n     if let Expr::Path(p) = &ctx.body.exprs[expr] {\n         let resolver = &ctx.resolver;\n-        if let Some(c) = path_to_const(db, resolver, p.mod_path(), mode, args, debruijn) {\n+        if let Some(c) = path_to_const(db, resolver, p, mode, args, debruijn) {\n             return c;\n         }\n     }\n     let infer = ctx.clone().resolve_all();\n     if let Ok(mir_body) = lower_to_mir(ctx.db, ctx.owner, &ctx.body, &infer, expr) {\n-        if let Ok(result) = interpret_mir(db, &mir_body, true) {\n+        if let Ok(result) = interpret_mir(db, &mir_body, Substitution::empty(Interner), true) {\n             return result;\n         }\n     }"}, {"sha": "a0efc7541e3f5f9002378aaabed4d576b66e7824", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 557, "deletions": 29, "changes": 586, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -1,15 +1,19 @@\n use base_db::fixture::WithFixture;\n+use chalk_ir::Substitution;\n use hir_def::db::DefDatabase;\n \n use crate::{\n-    consteval::try_const_usize, db::HirDatabase, test_db::TestDB, Const, ConstScalar, Interner,\n+    consteval::try_const_usize, db::HirDatabase, mir::pad16, test_db::TestDB, Const, ConstScalar,\n+    Interner,\n };\n \n use super::{\n     super::mir::{MirEvalError, MirLowerError},\n     ConstEvalError,\n };\n \n+mod intrinsics;\n+\n fn simplify(e: ConstEvalError) -> ConstEvalError {\n     match e {\n         ConstEvalError::MirEvalError(MirEvalError::InFunction(_, e)) => {\n@@ -30,7 +34,12 @@ fn check_number(ra_fixture: &str, answer: i128) {\n     match &r.data(Interner).value {\n         chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n             ConstScalar::Bytes(b, _) => {\n-                assert_eq!(b, &answer.to_le_bytes()[0..b.len()]);\n+                assert_eq!(\n+                    b,\n+                    &answer.to_le_bytes()[0..b.len()],\n+                    \"Bytes differ. In decimal form: actual = {}, expected = {answer}\",\n+                    i128::from_le_bytes(pad16(b, true))\n+                );\n             }\n             x => panic!(\"Expected number but found {:?}\", x),\n         },\n@@ -56,7 +65,7 @@ fn eval_goal(ra_fixture: &str) -> Result<Const, ConstEvalError> {\n             _ => None,\n         })\n         .unwrap();\n-    db.const_eval(const_id)\n+    db.const_eval(const_id, Substitution::empty(Interner))\n }\n \n #[test]\n@@ -76,6 +85,49 @@ fn bit_op() {\n     check_number(r#\"const GOAL: i8 = 1 << 8\"#, 0);\n }\n \n+#[test]\n+fn casts() {\n+    check_number(r#\"const GOAL: usize = 12 as *const i32 as usize\"#, 12);\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: i32 = {\n+        let a = [10, 20, 3, 15];\n+        let x: &[i32] = &a;\n+        let y: *const [i32] = x;\n+        let z = y as *const i32;\n+        unsafe { *z }\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: i16 = {\n+        let a = &mut 5;\n+        let z = a as *mut _;\n+        unsafe { *z }\n+    };\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = {\n+        let a = [10, 20, 3, 15];\n+        let x: &[i32] = &a;\n+        let y: *const [i32] = x;\n+        let z = y as *const [u8]; // slice fat pointer cast don't touch metadata\n+        let w = unsafe { &*z };\n+        w.len()\n+    };\n+        \"#,\n+        4,\n+    );\n+}\n+\n #[test]\n fn locals() {\n     check_number(\n@@ -166,8 +218,7 @@ fn reference_autoderef() {\n \n #[test]\n fn overloaded_deref() {\n-    // FIXME: We should support this.\n-    check_fail(\n+    check_number(\n         r#\"\n     //- minicore: deref_mut\n     struct Foo;\n@@ -185,9 +236,7 @@ fn overloaded_deref() {\n         *y + *x\n     };\n     \"#,\n-        ConstEvalError::MirLowerError(MirLowerError::NotSupported(\n-            \"explicit overloaded deref\".into(),\n-        )),\n+        10,\n     );\n }\n \n@@ -218,6 +267,42 @@ fn overloaded_deref_autoref() {\n     );\n }\n \n+#[test]\n+fn overloaded_index() {\n+    check_number(\n+        r#\"\n+    //- minicore: index\n+    struct Foo;\n+\n+    impl core::ops::Index<usize> for Foo {\n+        type Output = i32;\n+        fn index(&self, index: usize) -> &i32 {\n+            if index == 7 {\n+                &700\n+            } else {\n+                &1000\n+            }\n+        }\n+    }\n+\n+    impl core::ops::IndexMut<usize> for Foo {\n+        fn index_mut(&mut self, index: usize) -> &mut i32 {\n+            if index == 7 {\n+                &mut 7\n+            } else {\n+                &mut 10\n+            }\n+        }\n+    }\n+\n+    const GOAL: i32 = {\n+        (Foo[2]) + (Foo[7]) + (*&Foo[2]) + (*&Foo[7]) + (*&mut Foo[2]) + (*&mut Foo[7])\n+    };\n+    \"#,\n+        3417,\n+    );\n+}\n+\n #[test]\n fn function_call() {\n     check_number(\n@@ -240,20 +325,6 @@ fn function_call() {\n     );\n }\n \n-#[test]\n-fn intrinsics() {\n-    check_number(\n-        r#\"\n-    extern \"rust-intrinsic\" {\n-        pub fn size_of<T>() -> usize;\n-    }\n-\n-    const GOAL: usize = size_of::<i32>();\n-    \"#,\n-        4,\n-    );\n-}\n-\n #[test]\n fn trait_basic() {\n     check_number(\n@@ -483,6 +554,42 @@ fn loops() {\n         \"#,\n         4,\n     );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let mut x = 0;\n+        loop {\n+            x = x + 1;\n+            if x == 5 {\n+                break x + 2;\n+            }\n+        }\n+    };\n+        \"#,\n+        7,\n+    );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        'a: loop {\n+            let x = 'b: loop {\n+                let x = 'c: loop {\n+                    let x = 'd: loop {\n+                        let x = 'e: loop {\n+                            break 'd 1;\n+                        };\n+                        break 2 + x;\n+                    };\n+                    break 3 + x;\n+                };\n+                break 'a 4 + x;\n+            };\n+            break 5 + x;\n+        }\n+    };\n+        \"#,\n+        8,\n+    );\n }\n \n #[test]\n@@ -522,6 +629,18 @@ fn for_loops() {\n     );\n }\n \n+#[test]\n+fn ranges() {\n+    check_number(\n+        r#\"\n+    //- minicore: range\n+    const GOAL: i32 = (1..2).start + (20..10).end + (100..=200).start + (2000..=1000).end\n+        + (10000..).start + (..100000).end + (..=1000000).end;\n+        \"#,\n+        1111111,\n+    );\n+}\n+\n #[test]\n fn recursion() {\n     check_number(\n@@ -555,6 +674,38 @@ fn structs() {\n         \"#,\n         17,\n     );\n+    check_number(\n+        r#\"\n+        struct Point {\n+            x: i32,\n+            y: i32,\n+        }\n+\n+        const GOAL: i32 = {\n+            let p = Point { x: 5, y: 2 };\n+            let p2 = Point { x: 3, ..p };\n+            p.x * 1000 + p.y * 100 + p2.x * 10 + p2.y\n+        };\n+        \"#,\n+        5232,\n+    );\n+    check_number(\n+        r#\"\n+        struct Point {\n+            x: i32,\n+            y: i32,\n+        }\n+\n+        const GOAL: i32 = {\n+            let p = Point { x: 5, y: 2 };\n+            let Point { x, y } = p;\n+            let Point { x: x2, .. } = p;\n+            let Point { y: y2, .. } = p;\n+            x * 1000 + y * 100 + x2 * 10 + y2\n+        };\n+        \"#,\n+        5252,\n+    );\n }\n \n #[test]\n@@ -599,13 +750,14 @@ fn tuples() {\n     );\n     check_number(\n         r#\"\n-    struct TupleLike(i32, u8, i64, u16);\n-    const GOAL: u8 = {\n+    struct TupleLike(i32, i64, u8, u16);\n+    const GOAL: i64 = {\n         let a = TupleLike(10, 20, 3, 15);\n-        a.1\n+        let TupleLike(b, .., c) = a;\n+        a.1 * 100 + b as i64 + c as i64\n     };\n         \"#,\n-        20,\n+        2025,\n     );\n     check_number(\n         r#\"\n@@ -652,6 +804,36 @@ fn path_pattern_matching() {\n     );\n }\n \n+#[test]\n+fn pattern_matching_literal() {\n+    check_number(\n+        r#\"\n+    const fn f(x: i32) -> i32 {\n+        match x {\n+            -1 => 1,\n+            1 => 10,\n+            _ => 100,\n+        }\n+    }\n+    const GOAL: i32 = f(-1) + f(1) + f(0) + f(-5);\n+        \"#,\n+        211,\n+    );\n+    check_number(\n+        r#\"\n+    const fn f(x: &str) -> u8 {\n+        match x {\n+            \"foo\" => 1,\n+            \"bar\" => 10,\n+            _ => 100,\n+        }\n+    }\n+    const GOAL: u8 = f(\"foo\") + f(\"bar\");\n+        \"#,\n+        11,\n+    );\n+}\n+\n #[test]\n fn pattern_matching_ergonomics() {\n     check_number(\n@@ -665,6 +847,16 @@ fn pattern_matching_ergonomics() {\n         \"#,\n         5,\n     );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let a = &(2, 3);\n+        let &(x, y) = a;\n+        x + y\n+    };\n+        \"#,\n+        5,\n+    );\n }\n \n #[test]\n@@ -748,6 +940,33 @@ fn function_param_patterns() {\n     );\n }\n \n+#[test]\n+fn match_guards() {\n+    check_number(\n+        r#\"\n+    //- minicore: option, eq\n+    impl<T: PartialEq> PartialEq for Option<T> {\n+        fn eq(&self, other: &Rhs) -> bool {\n+            match (self, other) {\n+                (Some(x), Some(y)) => x == y,\n+                (None, None) => true,\n+                _ => false,\n+            }\n+        }\n+    }\n+    fn f(x: Option<i32>) -> i32 {\n+        match x {\n+            y if y == Some(42) => 42000,\n+            Some(y) => y,\n+            None => 10\n+        }\n+    }\n+    const GOAL: i32 = f(Some(42)) + f(Some(2)) + f(None);\n+        \"#,\n+        42012,\n+    );\n+}\n+\n #[test]\n fn options() {\n     check_number(\n@@ -801,6 +1020,91 @@ fn options() {\n     );\n }\n \n+#[test]\n+fn from_trait() {\n+    check_number(\n+        r#\"\n+    //- minicore: from\n+    struct E1(i32);\n+    struct E2(i32);\n+\n+    impl From<E1> for E2 {\n+        fn from(E1(x): E1) -> Self {\n+            E2(1000 * x)\n+        }\n+    }\n+    const GOAL: i32 = {\n+        let x: E2 = E1(2).into();\n+        x.0\n+    };\n+    \"#,\n+        2000,\n+    );\n+}\n+\n+#[test]\n+fn try_operator() {\n+    check_number(\n+        r#\"\n+    //- minicore: option, try\n+    const fn f(x: Option<i32>, y: Option<i32>) -> Option<i32> {\n+        Some(x? * y?)\n+    }\n+    const fn g(x: Option<i32>, y: Option<i32>) -> i32 {\n+        match f(x, y) {\n+            Some(k) => k,\n+            None => 5,\n+        }\n+    }\n+    const GOAL: i32 = g(Some(10), Some(20)) + g(Some(30), None) + g(None, Some(40)) + g(None, None);\n+        \"#,\n+        215,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: result, try, from\n+    struct E1(i32);\n+    struct E2(i32);\n+\n+    impl From<E1> for E2 {\n+        fn from(E1(x): E1) -> Self {\n+            E2(1000 * x)\n+        }\n+    }\n+\n+    const fn f(x: Result<i32, E1>) -> Result<i32, E2> {\n+        Ok(x? * 10)\n+    }\n+    const fn g(x: Result<i32, E1>) -> i32 {\n+        match f(x) {\n+            Ok(k) => 7 * k,\n+            Err(E2(k)) => 5 * k,\n+        }\n+    }\n+    const GOAL: i32 = g(Ok(2)) + g(Err(E1(3)));\n+        \"#,\n+        15140,\n+    );\n+}\n+\n+#[test]\n+fn try_block() {\n+    check_number(\n+        r#\"\n+    //- minicore: option, try\n+    const fn g(x: Option<i32>, y: Option<i32>) -> i32 {\n+        let r = try { x? * y? };\n+        match r {\n+            Some(k) => k,\n+            None => 5,\n+        }\n+    }\n+    const GOAL: i32 = g(Some(10), Some(20)) + g(Some(30), None) + g(None, Some(40)) + g(None, None);\n+        \"#,\n+        215,\n+    );\n+}\n+\n #[test]\n fn or_pattern() {\n     check_number(\n@@ -839,6 +1143,220 @@ fn or_pattern() {\n     );\n }\n \n+#[test]\n+fn function_pointer() {\n+    check_number(\n+        r#\"\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    const GOAL: u8 = {\n+        let plus2 = add2;\n+        plus2(3)\n+    };\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    const GOAL: u8 = {\n+        let plus2: fn(u8) -> u8 = add2;\n+        plus2(3)\n+    };\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn mult3(x: u8) -> u8 {\n+        x * 3\n+    }\n+    const GOAL: u8 = {\n+        let x = [add2, mult3];\n+        x[0](1) + x[1](5)\n+    };\n+        \"#,\n+        18,\n+    );\n+}\n+\n+#[test]\n+fn enum_variant_as_function() {\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: u8 = {\n+        let f = Some;\n+        f(3).unwrap_or(2)\n+    };\n+        \"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: u8 = {\n+        let f: fn(u8) -> Option<u8> = Some;\n+        f(3).unwrap_or(2)\n+    };\n+        \"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    enum Foo {\n+        Add2(u8),\n+        Mult3(u8),\n+    }\n+    use Foo::*;\n+    const fn f(x: Foo) -> u8 {\n+        match x {\n+            Add2(x) => x + 2,\n+            Mult3(x) => x * 3,\n+        }\n+    }\n+    const GOAL: u8 = {\n+        let x = [Add2, Mult3];\n+        f(x[0](1)) + f(x[1](5))\n+    };\n+        \"#,\n+        18,\n+    );\n+}\n+\n+#[test]\n+fn function_traits() {\n+    check_number(\n+        r#\"\n+    //- minicore: fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn call(f: impl Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_mut(mut f: impl FnMut(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_once(f: impl FnOnce(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    const GOAL: u8 = call(add2, 3) + call_mut(add2, 3) + call_once(add2, 3);\n+        \"#,\n+        15,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn call(f: &dyn Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_mut(f: &mut dyn FnMut(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    const GOAL: u8 = call(&add2, 3) + call_mut(&mut add2, 3);\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn call(f: impl Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_mut(mut f: impl FnMut(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_once(f: impl FnOnce(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    const GOAL: u8 = {\n+        let add2: fn(u8) -> u8 = add2;\n+        call(add2, 3) + call_mut(add2, 3) + call_once(add2, 3)\n+    };\n+        \"#,\n+        15,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn call(f: &&&&&impl Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    const GOAL: u8 = call(&&&&&add2, 3);\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn dyn_trait() {\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    trait Foo {\n+        fn foo(&self) -> u8 { 10 }\n+    }\n+    struct S1;\n+    struct S2;\n+    struct S3;\n+    impl Foo for S1 {\n+        fn foo(&self) -> u8 { 1 }\n+    }\n+    impl Foo for S2 {\n+        fn foo(&self) -> u8 { 2 }\n+    }\n+    impl Foo for S3 {}\n+    const GOAL: u8 = {\n+        let x: &[&dyn Foo] = &[&S1, &S2, &S3];\n+        x[0].foo() + x[1].foo() + x[2].foo()\n+    };\n+        \"#,\n+        13,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    trait Foo {\n+        fn foo(&self) -> i32 { 10 }\n+    }\n+    trait Bar {\n+        fn bar(&self) -> i32 { 20 }\n+    }\n+\n+    struct S;\n+    impl Foo for S {\n+        fn foo(&self) -> i32 { 200 }\n+    }\n+    impl Bar for dyn Foo {\n+        fn bar(&self) -> i32 { 700 }\n+    }\n+    const GOAL: i32 = {\n+        let x: &dyn Foo = &S;\n+        x.bar() + x.foo()\n+    };\n+        \"#,\n+        900,\n+    );\n+}\n+\n #[test]\n fn array_and_index() {\n     check_number(\n@@ -867,6 +1385,17 @@ fn array_and_index() {\n     check_number(\n         r#\"\n     //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = {\n+        let a = [1, 2, 3];\n+        let x: &[i32] = &a;\n+        let y = &*x;\n+        y.len()\n+    };\"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n     const GOAL: usize = [1, 2, 3, 4, 5].len();\"#,\n         5,\n     );\n@@ -991,16 +1520,15 @@ fn const_generic_subst_fn() {\n \n #[test]\n fn const_generic_subst_assoc_const_impl() {\n-    // FIXME: this should evaluate to 5\n-    check_fail(\n+    check_number(\n         r#\"\n     struct Adder<const N: usize, const M: usize>;\n     impl<const N: usize, const M: usize> Adder<N, M> {\n         const VAL: usize = N + M;\n     }\n     const GOAL: usize = Adder::<2, 3>::VAL;\n     \"#,\n-        ConstEvalError::MirEvalError(MirEvalError::TypeError(\"missing generic arg\")),\n+        5,\n     );\n }\n "}, {"sha": "371d5cab3378ddccdf92da5102abcf1c8100befc", "filename": "crates/hir-ty/src/consteval/tests/intrinsics.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -0,0 +1,162 @@\n+use super::*;\n+\n+#[test]\n+fn size_of() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn size_of<T>() -> usize;\n+        }\n+\n+        const GOAL: usize = size_of::<i32>();\n+        \"#,\n+        4,\n+    );\n+}\n+\n+#[test]\n+fn transmute() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn transmute<T, U>(e: T) -> U;\n+        }\n+\n+        const GOAL: i32 = transmute((1i16, 1i16));\n+        \"#,\n+        0x00010001,\n+    );\n+}\n+\n+#[test]\n+fn const_eval_select() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn const_eval_select<ARG, F, G, RET>(arg: ARG, called_in_const: F, called_at_rt: G) -> RET\n+            where\n+                G: FnOnce<ARG, Output = RET>,\n+                F: FnOnce<ARG, Output = RET>;\n+        }\n+\n+        const fn in_const(x: i32, y: i32) -> i32 {\n+            x + y\n+        }\n+\n+        fn in_rt(x: i32, y: i32) -> i32 {\n+            x + y\n+        }\n+\n+        const GOAL: i32 = const_eval_select((2, 3), in_const, in_rt);\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn wrapping_add() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn wrapping_add<T>(a: T, b: T) -> T;\n+        }\n+\n+        const GOAL: u8 = wrapping_add(10, 250);\n+        \"#,\n+        4,\n+    );\n+}\n+\n+#[test]\n+fn offset() {\n+    check_number(\n+        r#\"\n+        //- minicore: coerce_unsized, index, slice\n+        extern \"rust-intrinsic\" {\n+            pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+        }\n+\n+        const GOAL: u8 = unsafe {\n+            let ar: &[(u8, u8, u8)] = &[\n+                (10, 11, 12),\n+                (20, 21, 22),\n+                (30, 31, 32),\n+                (40, 41, 42),\n+                (50, 51, 52),\n+            ];\n+            let ar: *const [(u8, u8, u8)] = ar;\n+            let ar = ar as *const (u8, u8, u8);\n+            let element = offset(ar, 2);\n+            element.1\n+        };\n+        \"#,\n+        31,\n+    );\n+}\n+\n+#[test]\n+fn arith_offset() {\n+    check_number(\n+        r#\"\n+        //- minicore: coerce_unsized, index, slice\n+        extern \"rust-intrinsic\" {\n+            pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n+        }\n+\n+        const GOAL: u8 = unsafe {\n+            let ar: &[(u8, u8, u8)] = &[\n+                (10, 11, 12),\n+                (20, 21, 22),\n+                (30, 31, 32),\n+                (40, 41, 42),\n+                (50, 51, 52),\n+            ];\n+            let ar: *const [(u8, u8, u8)] = ar;\n+            let ar = ar as *const (u8, u8, u8);\n+            let element = arith_offset(arith_offset(ar, 102), -100);\n+            element.1\n+        };\n+        \"#,\n+        31,\n+    );\n+}\n+\n+#[test]\n+fn copy_nonoverlapping() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+        }\n+\n+        const GOAL: u8 = unsafe {\n+            let mut x = 2;\n+            let y = 5;\n+            copy_nonoverlapping(&y, &mut x, 1);\n+            x\n+        };\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn copy() {\n+    check_number(\n+        r#\"\n+        //- minicore: coerce_unsized, index, slice\n+        extern \"rust-intrinsic\" {\n+            pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n+        }\n+\n+        const GOAL: i32 = unsafe {\n+            let mut x = [1i32, 2, 3, 4, 5];\n+            let y = (&mut x as *mut _) as *mut i32;\n+            let z = (y as usize + 4) as *const i32;\n+            copy(z, y, 4);\n+            x[0] + x[1] + x[2] + x[3] + x[4]\n+        };\n+        \"#,\n+        19,\n+    );\n+}"}, {"sha": "000944e0b5b0d865e58de866afd454900629a4ad", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -57,7 +57,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n \n     #[salsa::invoke(crate::consteval::const_eval_query)]\n     #[salsa::cycle(crate::consteval::const_eval_recover)]\n-    fn const_eval(&self, def: ConstId) -> Result<Const, ConstEvalError>;\n+    fn const_eval(&self, def: ConstId, subst: Substitution) -> Result<Const, ConstEvalError>;\n \n     #[salsa::invoke(crate::consteval::const_eval_discriminant_variant)]\n     #[salsa::cycle(crate::consteval::const_eval_discriminant_recover)]\n@@ -97,6 +97,10 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::generic_predicates_query)]\n     fn generic_predicates(&self, def: GenericDefId) -> Arc<[Binders<QuantifiedWhereClause>]>;\n \n+    #[salsa::invoke(crate::lower::trait_environment_for_body_query)]\n+    #[salsa::transparent]\n+    fn trait_environment_for_body(&self, def: DefWithBodyId) -> Arc<crate::TraitEnvironment>;\n+\n     #[salsa::invoke(crate::lower::trait_environment_query)]\n     fn trait_environment(&self, def: GenericDefId) -> Arc<crate::TraitEnvironment>;\n "}, {"sha": "664822ee6fb4d75e27154d5ec37c59653f7e4602", "filename": "crates/hir-ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -73,7 +73,7 @@ fn walk_unsafe(\n         }\n         Expr::Path(path) => {\n             let resolver = resolver_for_expr(db.upcast(), def, current);\n-            let value_or_partial = resolver.resolve_path_in_value_ns(db.upcast(), path.mod_path());\n+            let value_or_partial = resolver.resolve_path_in_value_ns(db.upcast(), path);\n             if let Some(ResolveValueResult::ValueNs(ValueNs::StaticId(id))) = value_or_partial {\n                 if db.static_data(id).mutable {\n                     unsafe_expr_cb(UnsafeExpr { expr: current, inside_unsafe_block });"}, {"sha": "38b7dee75fd5bfa09bf53a0a58be52a1782ec095", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -25,22 +25,22 @@ use hir_def::{\n     expr::{BindingAnnotation, BindingId, ExprId, ExprOrPatId, PatId},\n     lang_item::{LangItem, LangItemTarget},\n     layout::Integer,\n-    path::Path,\n+    path::{ModPath, Path},\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     type_ref::TypeRef,\n-    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n-    ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, ItemContainerId, Lookup,\n+    TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::name::{name, Name};\n use la_arena::ArenaMap;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use stdx::always;\n+use stdx::{always, never};\n \n use crate::{\n     db::HirDatabase, fold_tys, fold_tys_and_consts, infer::coerce::CoerceMany,\n-    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Const, DomainGoal,\n-    GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId, Substitution,\n-    TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    lower::ImplTraitLoweringMode, static_lifetime, to_assoc_type_id, AliasEq, AliasTy, Const,\n+    DomainGoal, GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId,\n+    Substitution, TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -57,6 +57,7 @@ mod expr;\n mod pat;\n mod coerce;\n mod closure;\n+mod mutability;\n \n /// The entry point of type inference.\n pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n@@ -99,6 +100,8 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n \n     ctx.infer_body();\n \n+    ctx.infer_mut_body();\n+\n     Arc::new(ctx.resolve_all())\n }\n \n@@ -110,10 +113,7 @@ pub(crate) fn normalize(db: &dyn HirDatabase, owner: DefWithBodyId, ty: Ty) -> T\n     if !ty.data(Interner).flags.intersects(TypeFlags::HAS_PROJECTION) {\n         return ty;\n     }\n-    let krate = owner.module(db.upcast()).krate();\n-    let trait_env = owner\n-        .as_generic_def_id()\n-        .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n+    let trait_env = db.trait_environment_for_body(owner);\n     let mut table = unify::InferenceTable::new(db, trait_env);\n \n     let ty_with_vars = table.normalize_associated_types_in(ty);\n@@ -276,6 +276,13 @@ pub struct Adjustment {\n     pub target: Ty,\n }\n \n+impl Adjustment {\n+    pub fn borrow(m: Mutability, ty: Ty) -> Self {\n+        let ty = TyKind::Ref(m, static_lifetime(), ty).intern(Interner);\n+        Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(m)), target: ty }\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum Adjust {\n     /// Go from ! to any type.\n@@ -506,10 +513,7 @@ impl<'a> InferenceContext<'a> {\n         body: &'a Body,\n         resolver: Resolver,\n     ) -> Self {\n-        let krate = owner.module(db.upcast()).krate();\n-        let trait_env = owner\n-            .as_generic_def_id()\n-            .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n+        let trait_env = db.trait_environment_for_body(owner);\n         InferenceContext {\n             result: InferenceResult::default(),\n             table: unify::InferenceTable::new(db, trait_env.clone()),\n@@ -851,7 +855,7 @@ impl<'a> InferenceContext<'a> {\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n         let (resolution, unresolved) = if value_ns {\n-            match self.resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_value_ns(self.db.upcast(), path) {\n                 Some(ResolveValueResult::ValueNs(value)) => match value {\n                     ValueNs::EnumVariantId(var) => {\n                         let substs = ctx.substs_from_path(path, var.into(), true);\n@@ -872,11 +876,15 @@ impl<'a> InferenceContext<'a> {\n                 None => return (self.err_ty(), None),\n             }\n         } else {\n-            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path) {\n                 Some(it) => it,\n                 None => return (self.err_ty(), None),\n             }\n         };\n+        let Some(mod_path) = path.mod_path() else {\n+            never!(\"resolver should always resolve lang item paths\");\n+            return (self.err_ty(), None);\n+        };\n         return match resolution {\n             TypeNs::AdtId(AdtId::StructId(strukt)) => {\n                 let substs = ctx.substs_from_path(path, strukt.into(), true);\n@@ -900,7 +908,7 @@ impl<'a> InferenceContext<'a> {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = generics.placeholder_subst(self.db);\n                 let ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n-                self.resolve_variant_on_alias(ty, unresolved, path)\n+                self.resolve_variant_on_alias(ty, unresolved, mod_path)\n             }\n             TypeNs::TypeAliasId(it) => {\n                 let container = it.lookup(self.db.upcast()).container;\n@@ -917,7 +925,7 @@ impl<'a> InferenceContext<'a> {\n                 let ty = TyBuilder::def_ty(self.db, it.into(), parent_subst)\n                     .fill_with_inference_vars(&mut self.table)\n                     .build();\n-                self.resolve_variant_on_alias(ty, unresolved, path)\n+                self.resolve_variant_on_alias(ty, unresolved, mod_path)\n             }\n             TypeNs::AdtSelfType(_) => {\n                 // FIXME this could happen in array size expressions, once we're checking them\n@@ -953,9 +961,9 @@ impl<'a> InferenceContext<'a> {\n         &mut self,\n         ty: Ty,\n         unresolved: Option<usize>,\n-        path: &Path,\n+        path: &ModPath,\n     ) -> (Ty, Option<VariantId>) {\n-        let remaining = unresolved.map(|x| path.segments().skip(x).len()).filter(|x| x > &0);\n+        let remaining = unresolved.map(|x| path.segments()[x..].len()).filter(|x| x > &0);\n         match remaining {\n             None => {\n                 let variant = ty.as_adt().and_then(|(adt_id, _)| match adt_id {\n@@ -969,7 +977,7 @@ impl<'a> InferenceContext<'a> {\n                 (ty, variant)\n             }\n             Some(1) => {\n-                let segment = path.mod_path().segments().last().unwrap();\n+                let segment = path.segments().last().unwrap();\n                 // this could be an enum variant or associated type\n                 if let Some((AdtId::EnumId(enum_id), _)) = ty.as_adt() {\n                     let enum_data = self.db.enum_data(enum_id);\n@@ -1017,10 +1025,6 @@ impl<'a> InferenceContext<'a> {\n         self.resolve_lang_item(lang)?.as_trait()\n     }\n \n-    fn resolve_ops_try_output(&self) -> Option<TypeAliasId> {\n-        self.resolve_output_on(self.resolve_lang_trait(LangItem::Try)?)\n-    }\n-\n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n         self.resolve_output_on(self.resolve_lang_trait(LangItem::Neg)?)\n     }"}, {"sha": "6e899249b696950536d2eba7df67247a54f404b8", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -51,11 +51,12 @@ fn success(\n pub(super) struct CoerceMany {\n     expected_ty: Ty,\n     final_ty: Option<Ty>,\n+    expressions: Vec<ExprId>,\n }\n \n impl CoerceMany {\n     pub(super) fn new(expected: Ty) -> Self {\n-        CoerceMany { expected_ty: expected, final_ty: None }\n+        CoerceMany { expected_ty: expected, final_ty: None, expressions: vec![] }\n     }\n \n     /// Returns the \"expected type\" with which this coercion was\n@@ -125,8 +126,15 @@ impl CoerceMany {\n             let result1 = ctx.table.coerce_inner(self.merged_ty(), &target_ty);\n             let result2 = ctx.table.coerce_inner(expr_ty.clone(), &target_ty);\n             if let (Ok(result1), Ok(result2)) = (result1, result2) {\n-                ctx.table.register_infer_ok(result1);\n-                ctx.table.register_infer_ok(result2);\n+                ctx.table.register_infer_ok(InferOk { value: (), goals: result1.goals });\n+                for &e in &self.expressions {\n+                    ctx.write_expr_adj(e, result1.value.0.clone());\n+                }\n+                ctx.table.register_infer_ok(InferOk { value: (), goals: result2.goals });\n+                if let Some(expr) = expr {\n+                    ctx.write_expr_adj(expr, result2.value.0);\n+                    self.expressions.push(expr);\n+                }\n                 return self.final_ty = Some(target_ty);\n             }\n         }\n@@ -148,6 +156,9 @@ impl CoerceMany {\n             }\n             cov_mark::hit!(coerce_merge_fail_fallback);\n         }\n+        if let Some(expr) = expr {\n+            self.expressions.push(expr);\n+        }\n     }\n }\n "}, {"sha": "d52188bb284a2196893679e50ecba3ca3130d864", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 66, "deletions": 46, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -34,6 +34,7 @@ use crate::{\n     method_resolution::{self, lang_items_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n+    traits::FnTrait,\n     utils::{generics, Generics},\n     Adjust, Adjustment, AdtId, AutoBorrow, Binders, CallableDefId, FnPointer, FnSig, FnSubst,\n     Interner, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt,\n@@ -158,26 +159,6 @@ impl<'a> InferenceContext<'a> {\n                 })\n                 .1\n             }\n-            Expr::TryBlock { id: _, statements, tail } => {\n-                // The type that is returned from the try block\n-                let try_ty = self.table.new_type_var();\n-                if let Some(ty) = expected.only_has_type(&mut self.table) {\n-                    self.unify(&try_ty, &ty);\n-                }\n-\n-                // The ok-ish type that is expected from the last expression\n-                let ok_ty =\n-                    self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_output());\n-\n-                self.infer_block(\n-                    tgt_expr,\n-                    statements,\n-                    *tail,\n-                    None,\n-                    &Expectation::has_type(ok_ty.clone()),\n-                );\n-                try_ty\n-            }\n             Expr::Async { id: _, statements, tail } => {\n                 let ret_ty = self.table.new_type_var();\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n@@ -385,16 +366,46 @@ impl<'a> InferenceContext<'a> {\n                         || res.is_none();\n                 let (param_tys, ret_ty) = match res {\n                     Some((func, params, ret_ty)) => {\n-                        let adjustments = auto_deref_adjust_steps(&derefs);\n-                        // FIXME: Handle call adjustments for Fn/FnMut\n-                        self.write_expr_adj(*callee, adjustments);\n-                        if let Some((trait_, func)) = func {\n-                            let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n-                                .push(callee_ty.clone())\n-                                .push(TyBuilder::tuple_with(params.iter().cloned()))\n-                                .build();\n-                            self.write_method_resolution(tgt_expr, func, subst.clone());\n+                        let mut adjustments = auto_deref_adjust_steps(&derefs);\n+                        if let Some(fn_x) = func {\n+                            match fn_x {\n+                                FnTrait::FnOnce => (),\n+                                FnTrait::FnMut => {\n+                                    if !matches!(\n+                                        derefed_callee.kind(Interner),\n+                                        TyKind::Ref(Mutability::Mut, _, _)\n+                                    ) {\n+                                        adjustments.push(Adjustment::borrow(\n+                                            Mutability::Mut,\n+                                            derefed_callee.clone(),\n+                                        ));\n+                                    }\n+                                }\n+                                FnTrait::Fn => {\n+                                    if !matches!(\n+                                        derefed_callee.kind(Interner),\n+                                        TyKind::Ref(Mutability::Not, _, _)\n+                                    ) {\n+                                        adjustments.push(Adjustment::borrow(\n+                                            Mutability::Not,\n+                                            derefed_callee.clone(),\n+                                        ));\n+                                    }\n+                                }\n+                            }\n+                            let trait_ = fn_x\n+                                .get_id(self.db, self.trait_env.krate)\n+                                .expect(\"We just used it\");\n+                            let trait_data = self.db.trait_data(trait_);\n+                            if let Some(func) = trait_data.method_by_name(&fn_x.method_name()) {\n+                                let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n+                                    .push(callee_ty.clone())\n+                                    .push(TyBuilder::tuple_with(params.iter().cloned()))\n+                                    .build();\n+                                self.write_method_resolution(tgt_expr, func, subst.clone());\n+                            }\n                         }\n+                        self.write_expr_adj(*callee, adjustments);\n                         (params, ret_ty)\n                     }\n                     None => {\n@@ -601,26 +612,18 @@ impl<'a> InferenceContext<'a> {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 self.resolve_associated_type(inner_ty, self.resolve_future_future_output())\n             }\n-            Expr::Try { expr } => {\n-                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                if let Some(trait_) = self.resolve_lang_trait(LangItem::Try) {\n-                    if let Some(func) = self.db.trait_data(trait_).method_by_name(&name!(branch)) {\n-                        let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n-                            .push(inner_ty.clone())\n-                            .build();\n-                        self.write_method_resolution(tgt_expr, func, subst.clone());\n-                    }\n-                    let try_output = self.resolve_output_on(trait_);\n-                    self.resolve_associated_type(inner_ty, try_output)\n-                } else {\n-                    self.err_ty()\n-                }\n-            }\n             Expr::Cast { expr, type_ref } => {\n                 let cast_ty = self.make_ty(type_ref);\n                 // FIXME: propagate the \"castable to\" expectation\n-                let _inner_ty = self.infer_expr_no_expect(*expr);\n-                // FIXME check the cast...\n+                let inner_ty = self.infer_expr_no_expect(*expr);\n+                match (inner_ty.kind(Interner), cast_ty.kind(Interner)) {\n+                    (TyKind::Ref(_, _, inner), TyKind::Raw(_, cast)) => {\n+                        // FIXME: record invalid cast diagnostic in case of mismatch\n+                        self.unify(inner, cast);\n+                    }\n+                    // FIXME check the other kinds of cast...\n+                    _ => (),\n+                }\n                 cast_ty\n             }\n             Expr::Ref { expr, rawness, mutability } => {\n@@ -656,6 +659,23 @@ impl<'a> InferenceContext<'a> {\n                 // FIXME: Note down method resolution her\n                 match op {\n                     UnaryOp::Deref => {\n+                        if let Some(deref_trait) = self\n+                            .db\n+                            .lang_item(self.table.trait_env.krate, LangItem::Deref)\n+                            .and_then(|l| l.as_trait())\n+                        {\n+                            if let Some(deref_fn) =\n+                                self.db.trait_data(deref_trait).method_by_name(&name![deref])\n+                            {\n+                                // FIXME: this is wrong in multiple ways, subst is empty, and we emit it even for builtin deref (note that\n+                                // the mutability is not wrong, and will be fixed in `self.infer_mut`).\n+                                self.write_method_resolution(\n+                                    tgt_expr,\n+                                    deref_fn,\n+                                    Substitution::empty(Interner),\n+                                );\n+                            }\n+                        }\n                         autoderef::deref(&mut self.table, inner_ty).unwrap_or_else(|| self.err_ty())\n                     }\n                     UnaryOp::Neg => {"}, {"sha": "7ed21d230c7f601c3ba7e0fa0bd6ffb485509e6c", "filename": "crates/hir-ty/src/infer/mutability.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -0,0 +1,196 @@\n+//! Finds if an expression is an immutable context or a mutable context, which is used in selecting\n+//! between `Deref` and `DerefMut` or `Index` and `IndexMut` or similar.\n+\n+use chalk_ir::Mutability;\n+use hir_def::{\n+    expr::{Array, BindingAnnotation, Expr, ExprId, PatId, Statement, UnaryOp},\n+    lang_item::LangItem,\n+};\n+use hir_expand::name;\n+\n+use crate::{lower::lower_to_chalk_mutability, Adjust, AutoBorrow, OverloadedDeref};\n+\n+use super::InferenceContext;\n+\n+impl<'a> InferenceContext<'a> {\n+    pub(crate) fn infer_mut_body(&mut self) {\n+        self.infer_mut_expr(self.body.body_expr, Mutability::Not);\n+    }\n+\n+    fn infer_mut_expr(&mut self, tgt_expr: ExprId, mut mutability: Mutability) {\n+        let mut v = vec![];\n+        let adjustments = self.result.expr_adjustments.get_mut(&tgt_expr).unwrap_or(&mut v);\n+        for adj in adjustments.iter_mut().rev() {\n+            match &mut adj.kind {\n+                Adjust::NeverToAny | Adjust::Deref(None) | Adjust::Pointer(_) => (),\n+                Adjust::Deref(Some(d)) => *d = OverloadedDeref(Some(mutability)),\n+                Adjust::Borrow(b) => match b {\n+                    AutoBorrow::Ref(m) | AutoBorrow::RawPtr(m) => mutability = *m,\n+                },\n+            }\n+        }\n+        self.infer_mut_expr_without_adjust(tgt_expr, mutability);\n+    }\n+\n+    fn infer_mut_expr_without_adjust(&mut self, tgt_expr: ExprId, mutability: Mutability) {\n+        match &self.body[tgt_expr] {\n+            Expr::Missing => (),\n+            &Expr::If { condition, then_branch, else_branch } => {\n+                self.infer_mut_expr(condition, Mutability::Not);\n+                self.infer_mut_expr(then_branch, Mutability::Not);\n+                if let Some(else_branch) = else_branch {\n+                    self.infer_mut_expr(else_branch, Mutability::Not);\n+                }\n+            }\n+            Expr::Let { pat, expr } => self.infer_mut_expr(*expr, self.pat_bound_mutability(*pat)),\n+            Expr::Block { id: _, statements, tail, label: _ }\n+            | Expr::Async { id: _, statements, tail }\n+            | Expr::Const { id: _, statements, tail }\n+            | Expr::Unsafe { id: _, statements, tail } => {\n+                for st in statements.iter() {\n+                    match st {\n+                        Statement::Let { pat, type_ref: _, initializer, else_branch } => {\n+                            if let Some(i) = initializer {\n+                                self.infer_mut_expr(*i, self.pat_bound_mutability(*pat));\n+                            }\n+                            if let Some(e) = else_branch {\n+                                self.infer_mut_expr(*e, Mutability::Not);\n+                            }\n+                        }\n+                        Statement::Expr { expr, has_semi: _ } => {\n+                            self.infer_mut_expr(*expr, Mutability::Not);\n+                        }\n+                    }\n+                }\n+                if let Some(tail) = tail {\n+                    self.infer_mut_expr(*tail, Mutability::Not);\n+                }\n+            }\n+            &Expr::For { iterable: c, pat: _, body, label: _ }\n+            | &Expr::While { condition: c, body, label: _ } => {\n+                self.infer_mut_expr(c, Mutability::Not);\n+                self.infer_mut_expr(body, Mutability::Not);\n+            }\n+            Expr::MethodCall { receiver: x, method_name: _, args, generic_args: _ }\n+            | Expr::Call { callee: x, args, is_assignee_expr: _ } => {\n+                self.infer_mut_not_expr_iter(args.iter().copied().chain(Some(*x)));\n+            }\n+            Expr::Match { expr, arms } => {\n+                let m = self.pat_iter_bound_mutability(arms.iter().map(|x| x.pat));\n+                self.infer_mut_expr(*expr, m);\n+                for arm in arms.iter() {\n+                    self.infer_mut_expr(arm.expr, Mutability::Not);\n+                }\n+            }\n+            Expr::Yield { expr }\n+            | Expr::Yeet { expr }\n+            | Expr::Return { expr }\n+            | Expr::Break { expr, label: _ } => {\n+                if let &Some(expr) = expr {\n+                    self.infer_mut_expr(expr, Mutability::Not);\n+                }\n+            }\n+            Expr::RecordLit { path: _, fields, spread, ellipsis: _, is_assignee_expr: _ } => {\n+                self.infer_mut_not_expr_iter(fields.iter().map(|x| x.expr).chain(*spread))\n+            }\n+            &Expr::Index { base, index } => {\n+                if let Some((f, _)) = self.result.method_resolutions.get_mut(&tgt_expr) {\n+                    if mutability == Mutability::Mut {\n+                        if let Some(index_trait) = self\n+                            .db\n+                            .lang_item(self.table.trait_env.krate, LangItem::IndexMut)\n+                            .and_then(|l| l.as_trait())\n+                        {\n+                            if let Some(index_fn) =\n+                                self.db.trait_data(index_trait).method_by_name(&name![index_mut])\n+                            {\n+                                *f = index_fn;\n+                            }\n+                        }\n+                    }\n+                }\n+                self.infer_mut_expr(base, mutability);\n+                self.infer_mut_expr(index, Mutability::Not);\n+            }\n+            Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n+                if let Some((f, _)) = self.result.method_resolutions.get_mut(&tgt_expr) {\n+                    if mutability == Mutability::Mut {\n+                        if let Some(deref_trait) = self\n+                            .db\n+                            .lang_item(self.table.trait_env.krate, LangItem::DerefMut)\n+                            .and_then(|l| l.as_trait())\n+                        {\n+                            if let Some(deref_fn) =\n+                                self.db.trait_data(deref_trait).method_by_name(&name![deref_mut])\n+                            {\n+                                *f = deref_fn;\n+                            }\n+                        }\n+                    }\n+                }\n+                self.infer_mut_expr(*expr, mutability);\n+            }\n+            Expr::Field { expr, name: _ } => {\n+                self.infer_mut_expr(*expr, mutability);\n+            }\n+            Expr::UnaryOp { expr, op: _ }\n+            | Expr::Range { lhs: Some(expr), rhs: None, range_type: _ }\n+            | Expr::Range { rhs: Some(expr), lhs: None, range_type: _ }\n+            | Expr::Await { expr }\n+            | Expr::Box { expr }\n+            | Expr::Loop { body: expr, label: _ }\n+            | Expr::Cast { expr, type_ref: _ } => {\n+                self.infer_mut_expr(*expr, Mutability::Not);\n+            }\n+            Expr::Ref { expr, rawness: _, mutability } => {\n+                let mutability = lower_to_chalk_mutability(*mutability);\n+                self.infer_mut_expr(*expr, mutability);\n+            }\n+            Expr::Array(Array::Repeat { initializer: lhs, repeat: rhs })\n+            | Expr::BinaryOp { lhs, rhs, op: _ }\n+            | Expr::Range { lhs: Some(lhs), rhs: Some(rhs), range_type: _ } => {\n+                self.infer_mut_expr(*lhs, Mutability::Not);\n+                self.infer_mut_expr(*rhs, Mutability::Not);\n+            }\n+            // not implemented\n+            Expr::Closure { .. } => (),\n+            Expr::Tuple { exprs, is_assignee_expr: _ }\n+            | Expr::Array(Array::ElementList { elements: exprs, is_assignee_expr: _ }) => {\n+                self.infer_mut_not_expr_iter(exprs.iter().copied());\n+            }\n+            // These don't need any action, as they don't have sub expressions\n+            Expr::Range { lhs: None, rhs: None, range_type: _ }\n+            | Expr::Literal(_)\n+            | Expr::Path(_)\n+            | Expr::Continue { .. }\n+            | Expr::Underscore => (),\n+        }\n+    }\n+\n+    fn infer_mut_not_expr_iter(&mut self, exprs: impl Iterator<Item = ExprId>) {\n+        for expr in exprs {\n+            self.infer_mut_expr(expr, Mutability::Not);\n+        }\n+    }\n+\n+    fn pat_iter_bound_mutability(&self, mut pat: impl Iterator<Item = PatId>) -> Mutability {\n+        if pat.any(|p| self.pat_bound_mutability(p) == Mutability::Mut) {\n+            Mutability::Mut\n+        } else {\n+            Mutability::Not\n+        }\n+    }\n+\n+    /// Checks if the pat contains a `ref mut` binding. Such paths makes the context of bounded expressions\n+    /// mutable. For example in `let (ref mut x0, ref x1) = *x;` we need to use `DerefMut` for `*x` but in\n+    /// `let (ref x0, ref x1) = *x;` we should use `Deref`.\n+    fn pat_bound_mutability(&self, pat: PatId) -> Mutability {\n+        let mut r = Mutability::Not;\n+        self.body.walk_bindings_in_pat(pat, |b| {\n+            if self.body.bindings[b].mode == BindingAnnotation::RefMut {\n+                r = Mutability::Mut;\n+            }\n+        });\n+        r\n+    }\n+}"}, {"sha": "266e410187581bc6889ef077497a7a7292f34a10", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -39,7 +39,7 @@ impl<'a> InferenceContext<'a> {\n         } else {\n             // FIXME: report error, unresolved first path segment\n             let value_or_partial =\n-                self.resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path())?;\n+                self.resolver.resolve_path_in_value_ns(self.db.upcast(), path)?;\n \n             match value_or_partial {\n                 ResolveValueResult::ValueNs(it) => (it, None),"}, {"sha": "0e516b9399a68534dcdfb134dc36c7db8e4c9cca", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -8,16 +8,15 @@ use chalk_ir::{\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n-use hir_def::{FunctionId, TraitId};\n use hir_expand::name;\n use stdx::never;\n \n use super::{InferOk, InferResult, InferenceContext, TypeError};\n use crate::{\n-    db::HirDatabase, fold_tys, static_lifetime, traits::FnTrait, AliasEq, AliasTy, BoundVar,\n-    Canonical, Const, DebruijnIndex, GenericArg, GenericArgData, Goal, Guidance, InEnvironment,\n-    InferenceVar, Interner, Lifetime, ParamKind, ProjectionTy, ProjectionTyExt, Scalar, Solution,\n-    Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind, VariableKind,\n+    db::HirDatabase, fold_tys, static_lifetime, to_chalk_trait_id, traits::FnTrait, AliasEq,\n+    AliasTy, BoundVar, Canonical, Const, DebruijnIndex, GenericArg, GenericArgData, Goal, Guidance,\n+    InEnvironment, InferenceVar, Interner, Lifetime, ParamKind, ProjectionTy, ProjectionTyExt,\n+    Scalar, Solution, Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind, VariableKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -631,18 +630,21 @@ impl<'a> InferenceTable<'a> {\n         &mut self,\n         ty: &Ty,\n         num_args: usize,\n-    ) -> Option<(Option<(TraitId, FunctionId)>, Vec<Ty>, Ty)> {\n+    ) -> Option<(Option<FnTrait>, Vec<Ty>, Ty)> {\n         match ty.callable_sig(self.db) {\n             Some(sig) => Some((None, sig.params().to_vec(), sig.ret().clone())),\n-            None => self.callable_sig_from_fn_trait(ty, num_args),\n+            None => {\n+                let (f, args_ty, return_ty) = self.callable_sig_from_fn_trait(ty, num_args)?;\n+                Some((Some(f), args_ty, return_ty))\n+            }\n         }\n     }\n \n     fn callable_sig_from_fn_trait(\n         &mut self,\n         ty: &Ty,\n         num_args: usize,\n-    ) -> Option<(Option<(TraitId, FunctionId)>, Vec<Ty>, Ty)> {\n+    ) -> Option<(FnTrait, Vec<Ty>, Ty)> {\n         let krate = self.trait_env.krate;\n         let fn_once_trait = FnTrait::FnOnce.get_id(self.db, krate)?;\n         let trait_data = self.db.trait_data(fn_once_trait);\n@@ -676,19 +678,28 @@ impl<'a> InferenceTable<'a> {\n         };\n \n         let trait_env = self.trait_env.env.clone();\n+        let mut trait_ref = projection.trait_ref(self.db);\n         let obligation = InEnvironment {\n-            goal: projection.trait_ref(self.db).cast(Interner),\n-            environment: trait_env,\n+            goal: trait_ref.clone().cast(Interner),\n+            environment: trait_env.clone(),\n         };\n         let canonical = self.canonicalize(obligation.clone());\n         if self.db.trait_solve(krate, canonical.value.cast(Interner)).is_some() {\n             self.register_obligation(obligation.goal);\n             let return_ty = self.normalize_projection_ty(projection);\n-            Some((\n-                Some(fn_once_trait).zip(trait_data.method_by_name(&name!(call_once))),\n-                arg_tys,\n-                return_ty,\n-            ))\n+            for fn_x in [FnTrait::Fn, FnTrait::FnMut, FnTrait::FnOnce] {\n+                let fn_x_trait = fn_x.get_id(self.db, krate)?;\n+                trait_ref.trait_id = to_chalk_trait_id(fn_x_trait);\n+                let obligation: chalk_ir::InEnvironment<chalk_ir::Goal<Interner>> = InEnvironment {\n+                    goal: trait_ref.clone().cast(Interner),\n+                    environment: trait_env.clone(),\n+                };\n+                let canonical = self.canonicalize(obligation.clone());\n+                if self.db.trait_solve(krate, canonical.value.cast(Interner)).is_some() {\n+                    return Some((fn_x, arg_tys, return_ty));\n+                }\n+            }\n+            unreachable!(\"It should at least implement FnOnce at this point\");\n         } else {\n             None\n         }"}, {"sha": "782a8ab4aa2ab7a475a77b85d0bfab78b5de0f08", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -576,10 +576,14 @@ where\n }\n \n pub fn callable_sig_from_fnonce(\n-    self_ty: &Ty,\n+    mut self_ty: &Ty,\n     env: Arc<TraitEnvironment>,\n     db: &dyn HirDatabase,\n ) -> Option<CallableSig> {\n+    if let Some((ty, _, _)) = self_ty.as_reference() {\n+        // This will happen when it implements fn or fn mut, since we add a autoborrow adjustment\n+        self_ty = ty;\n+    }\n     let krate = env.krate;\n     let fn_once_trait = FnTrait::FnOnce.get_id(db, krate)?;\n     let output_assoc_type = db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;"}, {"sha": "e7490087e762b4402ce17c542a0a456b4a7fba8e", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 62, "deletions": 26, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -25,12 +25,12 @@ use hir_def::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n     lang_item::{lang_attr, LangItem},\n-    path::{GenericArg, ModPath, Path, PathKind, PathSegment, PathSegments},\n+    path::{GenericArg, GenericArgs, ModPath, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{ConstRefOrPath, TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef},\n-    AdtId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n-    HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, StaticId, StructId,\n-    TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n+    AdtId, AssocItemId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n+    GenericDefId, HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, StaticId,\n+    StructId, TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::Name, ExpandResult};\n use intern::Interned;\n@@ -425,11 +425,10 @@ impl<'a> TyLoweringContext<'a> {\n         if path.segments().len() > 1 {\n             return None;\n         }\n-        let resolution =\n-            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n-                Some((it, None)) => it,\n-                _ => return None,\n-            };\n+        let resolution = match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path) {\n+            Some((it, None)) => it,\n+            _ => return None,\n+        };\n         match resolution {\n             TypeNs::GenericParam(param_id) => Some(param_id.into()),\n             _ => None,\n@@ -608,7 +607,7 @@ impl<'a> TyLoweringContext<'a> {\n         }\n \n         let (resolution, remaining_index) =\n-            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path) {\n                 Some(it) => it,\n                 None => return (TyKind::Error.intern(Interner), None),\n             };\n@@ -716,7 +715,7 @@ impl<'a> TyLoweringContext<'a> {\n         resolved: ValueTyDefId,\n         infer_args: bool,\n     ) -> Substitution {\n-        let last = path.segments().last().expect(\"path should have at least one segment\");\n+        let last = path.segments().last();\n         let (segment, generic_def) = match resolved {\n             ValueTyDefId::FunctionId(it) => (last, Some(it.into())),\n             ValueTyDefId::StructId(it) => (last, Some(it.into())),\n@@ -732,13 +731,20 @@ impl<'a> TyLoweringContext<'a> {\n                 let len = path.segments().len();\n                 let penultimate = len.checked_sub(2).and_then(|idx| path.segments().get(idx));\n                 let segment = match penultimate {\n-                    Some(segment) if segment.args_and_bindings.is_some() => segment,\n+                    Some(segment) if segment.args_and_bindings.is_some() => Some(segment),\n                     _ => last,\n                 };\n                 (segment, Some(var.parent.into()))\n             }\n         };\n-        self.substs_from_path_segment(segment, generic_def, infer_args, None)\n+        if let Some(segment) = segment {\n+            self.substs_from_path_segment(segment, generic_def, infer_args, None)\n+        } else if let Some(generic_def) = generic_def {\n+            // lang item\n+            self.substs_from_args_and_bindings(None, Some(generic_def), infer_args, None)\n+        } else {\n+            Substitution::empty(Interner)\n+        }\n     }\n \n     fn substs_from_path_segment(\n@@ -747,6 +753,21 @@ impl<'a> TyLoweringContext<'a> {\n         def: Option<GenericDefId>,\n         infer_args: bool,\n         explicit_self_ty: Option<Ty>,\n+    ) -> Substitution {\n+        self.substs_from_args_and_bindings(\n+            segment.args_and_bindings,\n+            def,\n+            infer_args,\n+            explicit_self_ty,\n+        )\n+    }\n+\n+    fn substs_from_args_and_bindings(\n+        &self,\n+        args_and_bindings: Option<&GenericArgs>,\n+        def: Option<GenericDefId>,\n+        infer_args: bool,\n+        explicit_self_ty: Option<Ty>,\n     ) -> Substitution {\n         // Remember that the item's own generic args come before its parent's.\n         let mut substs = Vec::new();\n@@ -780,7 +801,7 @@ impl<'a> TyLoweringContext<'a> {\n         };\n         let mut had_explicit_args = false;\n \n-        if let Some(generic_args) = &segment.args_and_bindings {\n+        if let Some(generic_args) = &args_and_bindings {\n             if !generic_args.has_self_type {\n                 fill_self_params();\n             }\n@@ -879,12 +900,11 @@ impl<'a> TyLoweringContext<'a> {\n         path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<TraitRef> {\n-        let resolved =\n-            match self.resolver.resolve_path_in_type_ns_fully(self.db.upcast(), path.mod_path())? {\n-                // FIXME(trait_alias): We need to handle trait alias here.\n-                TypeNs::TraitId(tr) => tr,\n-                _ => return None,\n-            };\n+        let resolved = match self.resolver.resolve_path_in_type_ns_fully(self.db.upcast(), path)? {\n+            // FIXME(trait_alias): We need to handle trait alias here.\n+            TypeNs::TraitId(tr) => tr,\n+            _ => return None,\n+        };\n         let segment = path.segments().last().expect(\"path should have at least one segment\");\n         Some(self.lower_trait_ref_from_resolved_path(resolved, segment, explicit_self_ty))\n     }\n@@ -1381,9 +1401,7 @@ pub(crate) fn generic_predicates_for_param_query(\n                             Some(it) => it,\n                             None => return true,\n                         };\n-                        let tr = match resolver\n-                            .resolve_path_in_type_ns_fully(db.upcast(), path.mod_path())\n-                        {\n+                        let tr = match resolver.resolve_path_in_type_ns_fully(db.upcast(), path) {\n                             Some(TypeNs::TraitId(tr)) => tr,\n                             _ => return false,\n                         };\n@@ -1423,6 +1441,17 @@ pub(crate) fn generic_predicates_for_param_recover(\n     Arc::new([])\n }\n \n+pub(crate) fn trait_environment_for_body_query(\n+    db: &dyn HirDatabase,\n+    def: DefWithBodyId,\n+) -> Arc<TraitEnvironment> {\n+    let Some(def) = def.as_generic_def_id() else {\n+        let krate = def.module(db.upcast()).krate();\n+        return Arc::new(TraitEnvironment::empty(krate));\n+    };\n+    db.trait_environment(def)\n+}\n+\n pub(crate) fn trait_environment_query(\n     db: &dyn HirDatabase,\n     def: GenericDefId,\n@@ -1948,7 +1977,7 @@ pub(crate) fn generic_arg_to_chalk<'a, T>(\n             // as types. Maybe here is not the best place to do it, but\n             // it works.\n             if let TypeRef::Path(p) = t {\n-                let p = p.mod_path();\n+                let p = p.mod_path()?;\n                 if p.kind == PathKind::Plain {\n                     if let [n] = p.segments() {\n                         let c = ConstRefOrPath::Path(n.clone());\n@@ -1977,8 +2006,15 @@ pub(crate) fn const_or_path_to_chalk(\n         ConstRefOrPath::Scalar(s) => intern_const_ref(db, s, expected_ty, resolver.krate()),\n         ConstRefOrPath::Path(n) => {\n             let path = ModPath::from_segments(PathKind::Plain, Some(n.clone()));\n-            path_to_const(db, resolver, &path, mode, args, debruijn)\n-                .unwrap_or_else(|| unknown_const(expected_ty))\n+            path_to_const(\n+                db,\n+                resolver,\n+                &Path::from_known_path_with_no_generic(path),\n+                mode,\n+                args,\n+                debruijn,\n+            )\n+            .unwrap_or_else(|| unknown_const(expected_ty))\n         }\n     }\n }"}, {"sha": "2003d24038b1d89e4ffba040ae587c343e0447de", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -5,7 +5,7 @@\n use std::{ops::ControlFlow, sync::Arc};\n \n use base_db::{CrateId, Edition};\n-use chalk_ir::{cast::Cast, Mutability, TyKind, UniverseIndex};\n+use chalk_ir::{cast::Cast, Mutability, TyKind, UniverseIndex, WhereClause};\n use hir_def::{\n     data::ImplData, item_scope::ItemScope, lang_item::LangItem, nameres::DefMap, AssocItemId,\n     BlockId, ConstId, FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId,\n@@ -20,7 +20,7 @@ use crate::{\n     autoderef::{self, AutoderefKind},\n     db::HirDatabase,\n     from_chalk_trait_id, from_foreign_def_id,\n-    infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n+    infer::{unify::InferenceTable, Adjust, Adjustment, OverloadedDeref, PointerCast},\n     primitive::{FloatTy, IntTy, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::all_super_traits,\n@@ -600,9 +600,9 @@ impl ReceiverAdjustments {\n             }\n         }\n         if let Some(m) = self.autoref {\n-            ty = TyKind::Ref(m, static_lifetime(), ty).intern(Interner);\n-            adjust\n-                .push(Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(m)), target: ty.clone() });\n+            let a = Adjustment::borrow(m, ty);\n+            ty = a.target.clone();\n+            adjust.push(a);\n         }\n         if self.unsize_array {\n             ty = 'x: {\n@@ -692,6 +692,39 @@ pub fn lookup_impl_const(\n         .unwrap_or((const_id, subs))\n }\n \n+/// Checks if the self parameter of `Trait` method is the `dyn Trait` and we should\n+/// call the method using the vtable.\n+pub fn is_dyn_method(\n+    db: &dyn HirDatabase,\n+    _env: Arc<TraitEnvironment>,\n+    func: FunctionId,\n+    fn_subst: Substitution,\n+) -> Option<usize> {\n+    let ItemContainerId::TraitId(trait_id) = func.lookup(db.upcast()).container else {\n+        return None;\n+    };\n+    let trait_params = db.generic_params(trait_id.into()).type_or_consts.len();\n+    let fn_params = fn_subst.len(Interner) - trait_params;\n+    let trait_ref = TraitRef {\n+        trait_id: to_chalk_trait_id(trait_id),\n+        substitution: Substitution::from_iter(Interner, fn_subst.iter(Interner).skip(fn_params)),\n+    };\n+    let self_ty = trait_ref.self_type_parameter(Interner);\n+    if let TyKind::Dyn(d) = self_ty.kind(Interner) {\n+        let is_my_trait_in_bounds =\n+            d.bounds.skip_binders().as_slice(Interner).iter().any(|x| match x.skip_binders() {\n+                // rustc doesn't accept `impl Foo<2> for dyn Foo<5>`, so if the trait id is equal, no matter\n+                // what the generics are, we are sure that the method is come from the vtable.\n+                WhereClause::Implemented(tr) => tr.trait_id == trait_ref.trait_id,\n+                _ => false,\n+            });\n+        if is_my_trait_in_bounds {\n+            return Some(fn_params);\n+        }\n+    }\n+    None\n+}\n+\n /// Looks up the impl method that actually runs for the trait method `func`.\n ///\n /// Returns `func` if it's not a method defined in a trait or the lookup failed.\n@@ -701,9 +734,8 @@ pub fn lookup_impl_method(\n     func: FunctionId,\n     fn_subst: Substitution,\n ) -> (FunctionId, Substitution) {\n-    let trait_id = match func.lookup(db.upcast()).container {\n-        ItemContainerId::TraitId(id) => id,\n-        _ => return (func, fn_subst),\n+    let ItemContainerId::TraitId(trait_id) = func.lookup(db.upcast()).container else {\n+        return (func, fn_subst)\n     };\n     let trait_params = db.generic_params(trait_id.into()).type_or_consts.len();\n     let fn_params = fn_subst.len(Interner) - trait_params;"}, {"sha": "7b83645faef7d7193f935d96fa6eeb488dd24294", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 541, "deletions": 210, "changes": 751, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -1,6 +1,6 @@\n //! This module provides a MIR interpreter, which is used in const eval.\n \n-use std::{borrow::Cow, collections::HashMap, iter};\n+use std::{borrow::Cow, collections::HashMap, iter, ops::Range, sync::Arc};\n \n use base_db::CrateId;\n use chalk_ir::{\n@@ -11,7 +11,7 @@ use hir_def::{\n     builtin_type::BuiltinType,\n     lang_item::{lang_attr, LangItem},\n     layout::{Layout, LayoutError, RustcEnumVariantIdx, TagEncoding, Variants},\n-    AdtId, DefWithBodyId, EnumVariantId, FunctionId, HasModule, Lookup, VariantId,\n+    AdtId, DefWithBodyId, EnumVariantId, FunctionId, HasModule, ItemContainerId, Lookup, VariantId,\n };\n use intern::Interned;\n use la_arena::ArenaMap;\n@@ -23,19 +23,62 @@ use crate::{\n     infer::{normalize, PointerCast},\n     layout::layout_of_ty,\n     mapping::from_chalk,\n-    method_resolution::lookup_impl_method,\n-    CallableDefId, Const, ConstScalar, Interner, MemoryMap, Substitution, Ty, TyBuilder, TyExt,\n+    method_resolution::{is_dyn_method, lookup_impl_method},\n+    traits::FnTrait,\n+    CallableDefId, Const, ConstScalar, FnDefId, GenericArgData, Interner, MemoryMap, Substitution,\n+    TraitEnvironment, Ty, TyBuilder, TyExt,\n };\n \n use super::{\n     const_as_usize, return_slot, AggregateKind, BinOp, CastKind, LocalId, MirBody, MirLowerError,\n     Operand, Place, ProjectionElem, Rvalue, StatementKind, Terminator, UnOp,\n };\n \n+macro_rules! from_bytes {\n+    ($ty:tt, $value:expr) => {\n+        ($ty::from_le_bytes(match ($value).try_into() {\n+            Ok(x) => x,\n+            Err(_) => return Err(MirEvalError::TypeError(\"mismatched size\")),\n+        }))\n+    };\n+}\n+\n+#[derive(Debug, Default)]\n+struct VTableMap {\n+    ty_to_id: HashMap<Ty, usize>,\n+    id_to_ty: Vec<Ty>,\n+}\n+\n+impl VTableMap {\n+    fn id(&mut self, ty: Ty) -> usize {\n+        if let Some(x) = self.ty_to_id.get(&ty) {\n+            return *x;\n+        }\n+        let id = self.id_to_ty.len();\n+        self.id_to_ty.push(ty.clone());\n+        self.ty_to_id.insert(ty, id);\n+        id\n+    }\n+\n+    fn ty(&self, id: usize) -> Result<&Ty> {\n+        self.id_to_ty.get(id).ok_or(MirEvalError::InvalidVTableId(id))\n+    }\n+\n+    fn ty_of_bytes(&self, bytes: &[u8]) -> Result<&Ty> {\n+        let id = from_bytes!(usize, bytes);\n+        self.ty(id)\n+    }\n+}\n+\n pub struct Evaluator<'a> {\n     db: &'a dyn HirDatabase,\n+    trait_env: Arc<TraitEnvironment>,\n     stack: Vec<u8>,\n     heap: Vec<u8>,\n+    /// We don't really have function pointers, i.e. pointers to some assembly instructions that we can run. Instead, we\n+    /// store the type as an interned id in place of function and vtable pointers, and we recover back the type at the\n+    /// time of use.\n+    vtable_map: VTableMap,\n     crate_id: CrateId,\n     // FIXME: This is a workaround, see the comment on `interpret_mir`\n     assert_placeholder_ty_is_unused: bool,\n@@ -53,11 +96,18 @@ enum Address {\n \n use Address::*;\n \n+#[derive(Debug, Clone, Copy)]\n struct Interval {\n     addr: Address,\n     size: usize,\n }\n \n+#[derive(Debug, Clone)]\n+struct IntervalAndTy {\n+    interval: Interval,\n+    ty: Ty,\n+}\n+\n impl Interval {\n     fn new(addr: Address, size: usize) -> Self {\n         Self { addr, size }\n@@ -66,6 +116,36 @@ impl Interval {\n     fn get<'a>(&self, memory: &'a Evaluator<'a>) -> Result<&'a [u8]> {\n         memory.read_memory(self.addr, self.size)\n     }\n+\n+    fn write_from_bytes(&self, memory: &mut Evaluator<'_>, bytes: &[u8]) -> Result<()> {\n+        memory.write_memory(self.addr, bytes)\n+    }\n+\n+    fn write_from_interval(&self, memory: &mut Evaluator<'_>, interval: Interval) -> Result<()> {\n+        // FIXME: this could be more efficent\n+        let bytes = &interval.get(memory)?.to_vec();\n+        memory.write_memory(self.addr, bytes)\n+    }\n+\n+    fn slice(self, range: Range<usize>) -> Interval {\n+        Interval { addr: self.addr.offset(range.start), size: range.len() }\n+    }\n+}\n+\n+impl IntervalAndTy {\n+    fn get<'a>(&self, memory: &'a Evaluator<'a>) -> Result<&'a [u8]> {\n+        memory.read_memory(self.interval.addr, self.interval.size)\n+    }\n+\n+    fn new(\n+        addr: Address,\n+        ty: Ty,\n+        evaluator: &Evaluator<'_>,\n+        locals: &Locals<'_>,\n+    ) -> Result<IntervalAndTy> {\n+        let size = evaluator.size_of_sized(&ty, locals, \"type of interval\")?;\n+        Ok(IntervalAndTy { interval: Interval { addr, size }, ty })\n+    }\n }\n \n enum IntervalOrOwned {\n@@ -81,23 +161,14 @@ impl IntervalOrOwned {\n     }\n }\n \n-macro_rules! from_bytes {\n-    ($ty:tt, $value:expr) => {\n-        ($ty::from_le_bytes(match ($value).try_into() {\n-            Ok(x) => x,\n-            Err(_) => return Err(MirEvalError::TypeError(\"mismatched size\")),\n-        }))\n-    };\n-}\n-\n impl Address {\n     fn from_bytes(x: &[u8]) -> Result<Self> {\n         Ok(Address::from_usize(from_bytes!(usize, x)))\n     }\n \n     fn from_usize(x: usize) -> Self {\n         if x > usize::MAX / 2 {\n-            Stack(usize::MAX - x)\n+            Stack(x - usize::MAX / 2)\n         } else {\n             Heap(x)\n         }\n@@ -109,7 +180,7 @@ impl Address {\n \n     fn to_usize(&self) -> usize {\n         let as_num = match self {\n-            Stack(x) => usize::MAX - *x,\n+            Stack(x) => *x + usize::MAX / 2,\n             Heap(x) => *x,\n         };\n         as_num\n@@ -136,7 +207,7 @@ pub enum MirEvalError {\n     /// Means that code had undefined behavior. We don't try to actively detect UB, but if it was detected\n     /// then use this type of error.\n     UndefinedBehavior(&'static str),\n-    Panic,\n+    Panic(String),\n     MirLowerError(FunctionId, MirLowerError),\n     TypeIsUnsized(Ty, &'static str),\n     NotSupported(String),\n@@ -145,6 +216,7 @@ pub enum MirEvalError {\n     ExecutionLimitExceeded,\n     StackOverflow,\n     TargetDataLayoutNotAvailable,\n+    InvalidVTableId(usize),\n }\n \n impl std::fmt::Debug for MirEvalError {\n@@ -158,14 +230,15 @@ impl std::fmt::Debug for MirEvalError {\n             Self::UndefinedBehavior(arg0) => {\n                 f.debug_tuple(\"UndefinedBehavior\").field(arg0).finish()\n             }\n-            Self::Panic => write!(f, \"Panic\"),\n+            Self::Panic(msg) => write!(f, \"Panic with message:\\n{msg:?}\"),\n             Self::TargetDataLayoutNotAvailable => write!(f, \"TargetDataLayoutNotAvailable\"),\n             Self::TypeIsUnsized(ty, it) => write!(f, \"{ty:?} is unsized. {it} should be sized.\"),\n             Self::ExecutionLimitExceeded => write!(f, \"execution limit exceeded\"),\n             Self::StackOverflow => write!(f, \"stack overflow\"),\n             Self::MirLowerError(arg0, arg1) => {\n                 f.debug_tuple(\"MirLowerError\").field(arg0).field(arg1).finish()\n             }\n+            Self::InvalidVTableId(arg0) => f.debug_tuple(\"InvalidVTableId\").field(arg0).finish(),\n             Self::NotSupported(arg0) => f.debug_tuple(\"NotSupported\").field(arg0).finish(),\n             Self::InvalidConst(arg0) => {\n                 let data = &arg0.data(Interner);\n@@ -209,6 +282,7 @@ struct Locals<'a> {\n pub fn interpret_mir(\n     db: &dyn HirDatabase,\n     body: &MirBody,\n+    subst: Substitution,\n     // FIXME: This is workaround. Ideally, const generics should have a separate body (issue #7434), but now\n     // they share their body with their parent, so in MIR lowering we have locals of the parent body, which\n     // might have placeholders. With this argument, we (wrongly) assume that every placeholder type has\n@@ -217,27 +291,30 @@ pub fn interpret_mir(\n     assert_placeholder_ty_is_unused: bool,\n ) -> Result<Const> {\n     let ty = body.locals[return_slot()].ty.clone();\n-    let mut evaluator =\n-        Evaluator::new(db, body.owner.module(db.upcast()).krate(), assert_placeholder_ty_is_unused);\n-    let bytes = evaluator.interpret_mir_with_no_arg(&body)?;\n+    let mut evaluator = Evaluator::new(db, body, assert_placeholder_ty_is_unused);\n+    let bytes = evaluator.interpret_mir(&body, None.into_iter(), subst.clone())?;\n     let memory_map = evaluator.create_memory_map(\n         &bytes,\n         &ty,\n-        &Locals { ptr: &ArenaMap::new(), body: &body, subst: &Substitution::empty(Interner) },\n+        &Locals { ptr: &ArenaMap::new(), body: &body, subst: &subst },\n     )?;\n     return Ok(intern_const_scalar(ConstScalar::Bytes(bytes, memory_map), ty));\n }\n \n impl Evaluator<'_> {\n     pub fn new<'a>(\n         db: &'a dyn HirDatabase,\n-        crate_id: CrateId,\n+        body: &MirBody,\n         assert_placeholder_ty_is_unused: bool,\n     ) -> Evaluator<'a> {\n+        let crate_id = body.owner.module(db.upcast()).krate();\n+        let trait_env = db.trait_environment_for_body(body.owner);\n         Evaluator {\n             stack: vec![0],\n             heap: vec![0],\n+            vtable_map: VTableMap::default(),\n             db,\n+            trait_env,\n             crate_id,\n             assert_placeholder_ty_is_unused,\n             stack_depth_limit: 100,\n@@ -246,7 +323,19 @@ impl Evaluator<'_> {\n     }\n \n     fn place_addr(&self, p: &Place, locals: &Locals<'_>) -> Result<Address> {\n-        Ok(self.place_addr_and_ty(p, locals)?.0)\n+        Ok(self.place_addr_and_ty_and_metadata(p, locals)?.0)\n+    }\n+\n+    fn place_interval(&self, p: &Place, locals: &Locals<'_>) -> Result<Interval> {\n+        let place_addr_and_ty = self.place_addr_and_ty_and_metadata(p, locals)?;\n+        Ok(Interval {\n+            addr: place_addr_and_ty.0,\n+            size: self.size_of_sized(\n+                &place_addr_and_ty.1,\n+                locals,\n+                \"Type of place that we need its interval\",\n+            )?,\n+        })\n     }\n \n     fn ptr_size(&self) -> usize {\n@@ -256,10 +345,15 @@ impl Evaluator<'_> {\n         }\n     }\n \n-    fn place_addr_and_ty<'a>(&'a self, p: &Place, locals: &'a Locals<'a>) -> Result<(Address, Ty)> {\n+    fn place_addr_and_ty_and_metadata<'a>(\n+        &'a self,\n+        p: &Place,\n+        locals: &'a Locals<'a>,\n+    ) -> Result<(Address, Ty, Option<Interval>)> {\n         let mut addr = locals.ptr[p.local];\n         let mut ty: Ty =\n             self.ty_filler(&locals.body.locals[p.local].ty, locals.subst, locals.body.owner)?;\n+        let mut metadata = None; // locals are always sized\n         for proj in &p.projection {\n             match proj {\n                 ProjectionElem::Deref => {\n@@ -271,12 +365,18 @@ impl Evaluator<'_> {\n                             ))\n                         }\n                     };\n+                    metadata = if self.size_of(&ty, locals)?.is_none() {\n+                        Some(Interval { addr: addr.offset(self.ptr_size()), size: self.ptr_size() })\n+                    } else {\n+                        None\n+                    };\n                     let x = from_bytes!(usize, self.read_memory(addr, self.ptr_size())?);\n                     addr = Address::from_usize(x);\n                 }\n                 ProjectionElem::Index(op) => {\n                     let offset =\n                         from_bytes!(usize, self.read_memory(locals.ptr[*op], self.ptr_size())?);\n+                    metadata = None; // Result of index is always sized\n                     match &ty.data(Interner).kind {\n                         TyKind::Ref(_, _, inner) => match &inner.data(Interner).kind {\n                             TyKind::Slice(inner) => {\n@@ -314,6 +414,7 @@ impl Evaluator<'_> {\n                             .clone();\n                         let offset = layout.fields.offset(f).bytes_usize();\n                         addr = addr.offset(offset);\n+                        metadata = None; // tuple field is always sized\n                     }\n                     _ => return Err(MirEvalError::TypeError(\"Only tuple has tuple fields\")),\n                 },\n@@ -343,6 +444,8 @@ impl Evaluator<'_> {\n                             .offset(u32::from(f.local_id.into_raw()) as usize)\n                             .bytes_usize();\n                         addr = addr.offset(offset);\n+                        // FIXME: support structs with unsized fields\n+                        metadata = None;\n                     }\n                     _ => return Err(MirEvalError::TypeError(\"Only adt has fields\")),\n                 },\n@@ -353,7 +456,7 @@ impl Evaluator<'_> {\n                 ProjectionElem::OpaqueCast(_) => not_supported!(\"opaque cast\"),\n             }\n         }\n-        Ok((addr, ty))\n+        Ok((addr, ty, metadata))\n     }\n \n     fn layout(&self, ty: &Ty) -> Result<Layout> {\n@@ -368,16 +471,23 @@ impl Evaluator<'_> {\n     }\n \n     fn place_ty<'a>(&'a self, p: &Place, locals: &'a Locals<'a>) -> Result<Ty> {\n-        Ok(self.place_addr_and_ty(p, locals)?.1)\n+        Ok(self.place_addr_and_ty_and_metadata(p, locals)?.1)\n     }\n \n-    fn operand_ty<'a>(&'a self, o: &'a Operand, locals: &'a Locals<'a>) -> Result<Ty> {\n+    fn operand_ty(&self, o: &Operand, locals: &Locals<'_>) -> Result<Ty> {\n         Ok(match o {\n             Operand::Copy(p) | Operand::Move(p) => self.place_ty(p, locals)?,\n             Operand::Constant(c) => c.data(Interner).ty.clone(),\n         })\n     }\n \n+    fn operand_ty_and_eval(&mut self, o: &Operand, locals: &Locals<'_>) -> Result<IntervalAndTy> {\n+        Ok(IntervalAndTy {\n+            interval: self.eval_operand(o, locals)?,\n+            ty: self.operand_ty(o, locals)?,\n+        })\n+    }\n+\n     fn interpret_mir(\n         &mut self,\n         body: &MirBody,\n@@ -455,116 +565,23 @@ impl Evaluator<'_> {\n                     cleanup: _,\n                     from_hir_call: _,\n                 } => {\n+                    let destination = self.place_interval(destination, &locals)?;\n                     let fn_ty = self.operand_ty(func, &locals)?;\n+                    let args = args\n+                        .iter()\n+                        .map(|x| self.operand_ty_and_eval(x, &locals))\n+                        .collect::<Result<Vec<_>>>()?;\n                     match &fn_ty.data(Interner).kind {\n+                        TyKind::Function(_) => {\n+                            let bytes = self.eval_operand(func, &locals)?;\n+                            self.exec_fn_pointer(bytes, destination, &args, &locals)?;\n+                        }\n                         TyKind::FnDef(def, generic_args) => {\n-                            let def: CallableDefId = from_chalk(self.db, *def);\n-                            let generic_args = self.subst_filler(generic_args, &locals);\n-                            match def {\n-                                CallableDefId::FunctionId(def) => {\n-                                    let arg_bytes = args\n-                                        .iter()\n-                                        .map(|x| {\n-                                            Ok(self\n-                                                .eval_operand(x, &locals)?\n-                                                .get(&self)?\n-                                                .to_owned())\n-                                        })\n-                                        .collect::<Result<Vec<_>>>()?\n-                                        .into_iter();\n-                                    let function_data = self.db.function_data(def);\n-                                    let is_intrinsic = match &function_data.abi {\n-                                        Some(abi) => *abi == Interned::new_str(\"rust-intrinsic\"),\n-                                        None => match def.lookup(self.db.upcast()).container {\n-                                            hir_def::ItemContainerId::ExternBlockId(block) => {\n-                                                let id = block.lookup(self.db.upcast()).id;\n-                                                id.item_tree(self.db.upcast())[id.value]\n-                                                    .abi\n-                                                    .as_deref()\n-                                                    == Some(\"rust-intrinsic\")\n-                                            }\n-                                            _ => false,\n-                                        },\n-                                    };\n-                                    let result = if is_intrinsic {\n-                                        self.exec_intrinsic(\n-                                            function_data\n-                                                .name\n-                                                .as_text()\n-                                                .unwrap_or_default()\n-                                                .as_str(),\n-                                            arg_bytes,\n-                                            generic_args,\n-                                            &locals,\n-                                        )?\n-                                    } else if let Some(x) = self.detect_lang_function(def) {\n-                                        self.exec_lang_item(x, arg_bytes)?\n-                                    } else {\n-                                        let trait_env = {\n-                                            let Some(d) = body.owner.as_generic_def_id() else {\n-                                                not_supported!(\"trait resolving in non generic def id\");\n-                                            };\n-                                            self.db.trait_environment(d)\n-                                        };\n-                                        let (imp, generic_args) = lookup_impl_method(\n-                                            self.db,\n-                                            trait_env,\n-                                            def,\n-                                            generic_args.clone(),\n-                                        );\n-                                        let generic_args =\n-                                            self.subst_filler(&generic_args, &locals);\n-                                        let def = imp.into();\n-                                        let mir_body = self\n-                                            .db\n-                                            .mir_body(def)\n-                                            .map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n-                                        self.interpret_mir(&mir_body, arg_bytes, generic_args)\n-                                            .map_err(|e| {\n-                                                MirEvalError::InFunction(imp, Box::new(e))\n-                                            })?\n-                                    };\n-                                    let dest_addr = self.place_addr(destination, &locals)?;\n-                                    self.write_memory(dest_addr, &result)?;\n-                                }\n-                                CallableDefId::StructId(id) => {\n-                                    let (size, variant_layout, tag) = self.layout_of_variant(\n-                                        id.into(),\n-                                        generic_args.clone(),\n-                                        &locals,\n-                                    )?;\n-                                    let result = self.make_by_layout(\n-                                        size,\n-                                        &variant_layout,\n-                                        tag,\n-                                        args,\n-                                        &locals,\n-                                    )?;\n-                                    let dest_addr = self.place_addr(destination, &locals)?;\n-                                    self.write_memory(dest_addr, &result)?;\n-                                }\n-                                CallableDefId::EnumVariantId(id) => {\n-                                    let (size, variant_layout, tag) = self.layout_of_variant(\n-                                        id.into(),\n-                                        generic_args.clone(),\n-                                        &locals,\n-                                    )?;\n-                                    let result = self.make_by_layout(\n-                                        size,\n-                                        &variant_layout,\n-                                        tag,\n-                                        args,\n-                                        &locals,\n-                                    )?;\n-                                    let dest_addr = self.place_addr(destination, &locals)?;\n-                                    self.write_memory(dest_addr, &result)?;\n-                                }\n-                            }\n-                            current_block_idx =\n-                                target.expect(\"broken mir, function without target\");\n+                            self.exec_fn_def(*def, generic_args, destination, &args, &locals)?;\n                         }\n-                        _ => not_supported!(\"unknown function type\"),\n+                        x => not_supported!(\"unknown function type {x:?}\"),\n                     }\n+                    current_block_idx = target.expect(\"broken mir, function without target\");\n                 }\n                 Terminator::SwitchInt { discr, targets } => {\n                     let val = u128::from_le_bytes(pad16(\n@@ -584,7 +601,7 @@ impl Evaluator<'_> {\n                         .to_owned());\n                 }\n                 Terminator::Unreachable => {\n-                    return Err(MirEvalError::UndefinedBehavior(\"unreachable executed\"))\n+                    return Err(MirEvalError::UndefinedBehavior(\"unreachable executed\"));\n                 }\n                 _ => not_supported!(\"unknown terminator\"),\n             }\n@@ -600,8 +617,12 @@ impl Evaluator<'_> {\n         Ok(match r {\n             Rvalue::Use(x) => Borrowed(self.eval_operand(x, locals)?),\n             Rvalue::Ref(_, p) => {\n-                let addr = self.place_addr(p, locals)?;\n-                Owned(addr.to_bytes())\n+                let (addr, _, metadata) = self.place_addr_and_ty_and_metadata(p, locals)?;\n+                let mut r = addr.to_bytes();\n+                if let Some(metadata) = metadata {\n+                    r.extend(metadata.get(self)?);\n+                }\n+                Owned(r)\n             }\n             Rvalue::Len(_) => not_supported!(\"rvalue len\"),\n             Rvalue::UnaryOp(op, val) => {\n@@ -640,7 +661,14 @@ impl Evaluator<'_> {\n                 let mut ty = self.operand_ty(lhs, locals)?;\n                 while let TyKind::Ref(_, _, z) = ty.kind(Interner) {\n                     ty = z.clone();\n-                    let size = self.size_of_sized(&ty, locals, \"operand of binary op\")?;\n+                    let size = if ty.kind(Interner) == &TyKind::Str {\n+                        let ns = from_bytes!(usize, &lc[self.ptr_size()..self.ptr_size() * 2]);\n+                        lc = &lc[..self.ptr_size()];\n+                        rc = &rc[..self.ptr_size()];\n+                        ns\n+                    } else {\n+                        self.size_of_sized(&ty, locals, \"operand of binary op\")?\n+                    };\n                     lc = self.read_memory(Address::from_bytes(lc)?, size)?;\n                     rc = self.read_memory(Address::from_bytes(rc)?, size)?;\n                 }\n@@ -672,8 +700,12 @@ impl Evaluator<'_> {\n                         let r = match op {\n                             BinOp::Add => l128.overflowing_add(r128).0,\n                             BinOp::Mul => l128.overflowing_mul(r128).0,\n-                            BinOp::Div => l128.checked_div(r128).ok_or(MirEvalError::Panic)?,\n-                            BinOp::Rem => l128.checked_rem(r128).ok_or(MirEvalError::Panic)?,\n+                            BinOp::Div => l128.checked_div(r128).ok_or_else(|| {\n+                                MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n+                            })?,\n+                            BinOp::Rem => l128.checked_rem(r128).ok_or_else(|| {\n+                                MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n+                            })?,\n                             BinOp::Sub => l128.overflowing_sub(r128).0,\n                             BinOp::BitAnd => l128 & r128,\n                             BinOp::BitOr => l128 | r128,\n@@ -683,16 +715,16 @@ impl Evaluator<'_> {\n                         let r = r.to_le_bytes();\n                         for &k in &r[lc.len()..] {\n                             if k != 0 && (k != 255 || !is_signed) {\n-                                return Err(MirEvalError::Panic);\n+                                return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n                             }\n                         }\n                         Owned(r[0..lc.len()].into())\n                     }\n                     BinOp::Shl | BinOp::Shr => {\n                         let shift_amout = if r128 < 0 {\n-                            return Err(MirEvalError::Panic);\n+                            return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n                         } else if r128 > 128 {\n-                            return Err(MirEvalError::Panic);\n+                            return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n                         } else {\n                             r128 as u8\n                         };\n@@ -710,8 +742,24 @@ impl Evaluator<'_> {\n                 let ty = self.place_ty(p, locals)?;\n                 let bytes = self.eval_place(p, locals)?.get(&self)?;\n                 let layout = self.layout(&ty)?;\n+                let enum_id = 'b: {\n+                    match ty.kind(Interner) {\n+                        TyKind::Adt(e, _) => match e.0 {\n+                            AdtId::EnumId(e) => break 'b e,\n+                            _ => (),\n+                        },\n+                        _ => (),\n+                    }\n+                    return Ok(Owned(0u128.to_le_bytes().to_vec()));\n+                };\n                 match layout.variants {\n-                    Variants::Single { .. } => Owned(0u128.to_le_bytes().to_vec()),\n+                    Variants::Single { index } => {\n+                        let r = self.db.const_eval_discriminant(EnumVariantId {\n+                            parent: enum_id,\n+                            local_id: index.0,\n+                        })?;\n+                        Owned(r.to_le_bytes().to_vec())\n+                    }\n                     Variants::Multiple { tag, tag_encoding, .. } => {\n                         let Some(target_data_layout) = self.db.target_data_layout(self.crate_id) else {\n                             not_supported!(\"missing target data layout\");\n@@ -727,13 +775,6 @@ impl Evaluator<'_> {\n                                 let tag = &bytes[offset..offset + size];\n                                 let candidate_discriminant = i128::from_le_bytes(pad16(tag, false))\n                                     .wrapping_sub(niche_start as i128);\n-                                let enum_id = match ty.kind(Interner) {\n-                                    TyKind::Adt(e, _) => match e.0 {\n-                                        AdtId::EnumId(e) => e,\n-                                        _ => not_supported!(\"Non enum with multi variant layout\"),\n-                                    },\n-                                    _ => not_supported!(\"Non adt with multi variant layout\"),\n-                                };\n                                 let enum_data = self.db.enum_data(enum_id);\n                                 let result = 'b: {\n                                     for (local_id, _) in enum_data.variants.iter() {\n@@ -759,48 +800,65 @@ impl Evaluator<'_> {\n             }\n             Rvalue::ShallowInitBox(_, _) => not_supported!(\"shallow init box\"),\n             Rvalue::CopyForDeref(_) => not_supported!(\"copy for deref\"),\n-            Rvalue::Aggregate(kind, values) => match kind {\n-                AggregateKind::Array(_) => {\n-                    let mut r = vec![];\n-                    for x in values {\n-                        let value = self.eval_operand(x, locals)?.get(&self)?;\n-                        r.extend(value);\n+            Rvalue::Aggregate(kind, values) => {\n+                let values = values\n+                    .iter()\n+                    .map(|x| self.eval_operand(x, locals))\n+                    .collect::<Result<Vec<_>>>()?;\n+                match kind {\n+                    AggregateKind::Array(_) => {\n+                        let mut r = vec![];\n+                        for x in values {\n+                            let value = x.get(&self)?;\n+                            r.extend(value);\n+                        }\n+                        Owned(r)\n+                    }\n+                    AggregateKind::Tuple(ty) => {\n+                        let layout = self.layout(&ty)?;\n+                        Owned(self.make_by_layout(\n+                            layout.size.bytes_usize(),\n+                            &layout,\n+                            None,\n+                            values.iter().copied(),\n+                        )?)\n+                    }\n+                    AggregateKind::Union(x, f) => {\n+                        let layout = self.layout_adt((*x).into(), Substitution::empty(Interner))?;\n+                        let offset = layout\n+                            .fields\n+                            .offset(u32::from(f.local_id.into_raw()) as usize)\n+                            .bytes_usize();\n+                        let op = values[0].get(&self)?;\n+                        let mut result = vec![0; layout.size.bytes_usize()];\n+                        result[offset..offset + op.len()].copy_from_slice(op);\n+                        Owned(result)\n+                    }\n+                    AggregateKind::Adt(x, subst) => {\n+                        let subst = self.subst_filler(subst, locals);\n+                        let (size, variant_layout, tag) =\n+                            self.layout_of_variant(*x, subst, locals)?;\n+                        Owned(self.make_by_layout(\n+                            size,\n+                            &variant_layout,\n+                            tag,\n+                            values.iter().copied(),\n+                        )?)\n                     }\n-                    Owned(r)\n-                }\n-                AggregateKind::Tuple(ty) => {\n-                    let layout = self.layout(&ty)?;\n-                    Owned(self.make_by_layout(\n-                        layout.size.bytes_usize(),\n-                        &layout,\n-                        None,\n-                        values,\n-                        locals,\n-                    )?)\n-                }\n-                AggregateKind::Union(x, f) => {\n-                    let layout = self.layout_adt((*x).into(), Substitution::empty(Interner))?;\n-                    let offset = layout\n-                        .fields\n-                        .offset(u32::from(f.local_id.into_raw()) as usize)\n-                        .bytes_usize();\n-                    let op = self.eval_operand(&values[0], locals)?.get(&self)?;\n-                    let mut result = vec![0; layout.size.bytes_usize()];\n-                    result[offset..offset + op.len()].copy_from_slice(op);\n-                    Owned(result)\n-                }\n-                AggregateKind::Adt(x, subst) => {\n-                    let (size, variant_layout, tag) =\n-                        self.layout_of_variant(*x, subst.clone(), locals)?;\n-                    Owned(self.make_by_layout(size, &variant_layout, tag, values, locals)?)\n                 }\n-            },\n+            }\n             Rvalue::Cast(kind, operand, target_ty) => match kind {\n-                CastKind::PointerExposeAddress => not_supported!(\"exposing pointer address\"),\n-                CastKind::PointerFromExposedAddress => {\n-                    not_supported!(\"creating pointer from exposed address\")\n-                }\n                 CastKind::Pointer(cast) => match cast {\n+                    PointerCast::ReifyFnPointer => {\n+                        let current_ty = self.operand_ty(operand, locals)?;\n+                        if let TyKind::FnDef(_, _) = &current_ty.data(Interner).kind {\n+                            let id = self.vtable_map.id(current_ty);\n+                            let ptr_size = self.ptr_size();\n+                            Owned(id.to_le_bytes()[0..ptr_size].to_vec())\n+                        } else {\n+                            not_supported!(\"ReifyFnPointer cast of a non FnDef type\");\n+                        }\n+                    }\n                     PointerCast::Unsize => {\n                         let current_ty = self.operand_ty(operand, locals)?;\n                         match &target_ty.data(Interner).kind {\n@@ -826,7 +884,18 @@ impl Evaluator<'_> {\n                                         }\n                                         _ => not_supported!(\"slice unsizing from non pointers\"),\n                                     },\n-                                    TyKind::Dyn(_) => not_supported!(\"dyn pointer unsize cast\"),\n+                                    TyKind::Dyn(_) => match &current_ty.data(Interner).kind {\n+                                        TyKind::Raw(_, ty) | TyKind::Ref(_, _, ty) => {\n+                                            let vtable = self.vtable_map.id(ty.clone());\n+                                            let addr =\n+                                                self.eval_operand(operand, locals)?.get(&self)?;\n+                                            let mut r = Vec::with_capacity(16);\n+                                            r.extend(addr.iter().copied());\n+                                            r.extend(vtable.to_le_bytes().into_iter());\n+                                            Owned(r)\n+                                        }\n+                                        _ => not_supported!(\"dyn unsizing from non pointers\"),\n+                                    },\n                                     _ => not_supported!(\"unknown unsized cast\"),\n                                 }\n                             }\n@@ -836,7 +905,9 @@ impl Evaluator<'_> {\n                     x => not_supported!(\"pointer cast {x:?}\"),\n                 },\n                 CastKind::DynStar => not_supported!(\"dyn star cast\"),\n-                CastKind::IntToInt => {\n+                CastKind::IntToInt\n+                | CastKind::PointerExposeAddress\n+                | CastKind::PointerFromExposedAddress => {\n                     // FIXME: handle signed cast\n                     let current = pad16(self.eval_operand(operand, locals)?.get(&self)?, false);\n                     let dest_size =\n@@ -846,7 +917,12 @@ impl Evaluator<'_> {\n                 CastKind::FloatToInt => not_supported!(\"float to int cast\"),\n                 CastKind::FloatToFloat => not_supported!(\"float to float cast\"),\n                 CastKind::IntToFloat => not_supported!(\"float to int cast\"),\n-                CastKind::PtrToPtr => not_supported!(\"ptr to ptr cast\"),\n+                CastKind::PtrToPtr => {\n+                    let current = pad16(self.eval_operand(operand, locals)?.get(&self)?, false);\n+                    let dest_size =\n+                        self.size_of_sized(target_ty, locals, \"destination of ptr to ptr cast\")?;\n+                    Owned(current[0..dest_size].to_vec())\n+                }\n                 CastKind::FnPtrToPtr => not_supported!(\"fn ptr to ptr cast\"),\n             },\n         })\n@@ -913,16 +989,15 @@ impl Evaluator<'_> {\n         size: usize, // Not neccessarily equal to variant_layout.size\n         variant_layout: &Layout,\n         tag: Option<(usize, usize, i128)>,\n-        values: &Vec<Operand>,\n-        locals: &Locals<'_>,\n+        values: impl Iterator<Item = Interval>,\n     ) -> Result<Vec<u8>> {\n         let mut result = vec![0; size];\n         if let Some((offset, size, value)) = tag {\n             result[offset..offset + size].copy_from_slice(&value.to_le_bytes()[0..size]);\n         }\n-        for (i, op) in values.iter().enumerate() {\n+        for (i, op) in values.enumerate() {\n             let offset = variant_layout.fields.offset(i).bytes_usize();\n-            let op = self.eval_operand(op, locals)?.get(&self)?;\n+            let op = op.get(&self)?;\n             result[offset..offset + op.len()].copy_from_slice(op);\n         }\n         Ok(result)\n@@ -1124,12 +1199,27 @@ impl Evaluator<'_> {\n     }\n \n     fn detect_lang_function(&self, def: FunctionId) -> Option<LangItem> {\n+        use LangItem::*;\n         let candidate = lang_attr(self.db.upcast(), def)?;\n-        // filter normal lang functions out\n-        if [LangItem::IntoIterIntoIter, LangItem::IteratorNext].contains(&candidate) {\n+        // We want to execute these functions with special logic\n+        if [PanicFmt, BeginPanic, SliceLen].contains(&candidate) {\n+            return Some(candidate);\n+        }\n+        None\n+    }\n+\n+    fn detect_fn_trait(&self, def: FunctionId) -> Option<FnTrait> {\n+        use LangItem::*;\n+        let ItemContainerId::TraitId(parent) = self.db.lookup_intern_function(def).container else {\n             return None;\n+        };\n+        let l = lang_attr(self.db.upcast(), parent)?;\n+        match l {\n+            FnOnce => Some(FnTrait::FnOnce),\n+            FnMut => Some(FnTrait::FnMut),\n+            Fn => Some(FnTrait::Fn),\n+            _ => None,\n         }\n-        Some(candidate)\n     }\n \n     fn create_memory_map(&self, bytes: &[u8], ty: &Ty, locals: &Locals<'_>) -> Result<MemoryMap> {\n@@ -1199,35 +1289,276 @@ impl Evaluator<'_> {\n     }\n \n     fn exec_intrinsic(\n-        &self,\n+        &mut self,\n         as_str: &str,\n-        _arg_bytes: impl Iterator<Item = Vec<u8>>,\n+        args: &[IntervalAndTy],\n         generic_args: Substitution,\n+        destination: Interval,\n         locals: &Locals<'_>,\n-    ) -> Result<Vec<u8>> {\n+    ) -> Result<()> {\n         match as_str {\n             \"size_of\" => {\n                 let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n                     return Err(MirEvalError::TypeError(\"size_of generic arg is not provided\"));\n                 };\n-                let size = self.size_of(ty, locals)?;\n-                match size {\n-                    Some(x) => Ok(x.to_le_bytes().to_vec()),\n-                    None => return Err(MirEvalError::TypeError(\"size_of arg is unsized\")),\n+                let size = self.size_of_sized(ty, locals, \"size_of arg\")?;\n+                destination.write_from_bytes(self, &size.to_le_bytes()[0..destination.size])\n+            }\n+            \"wrapping_add\" => {\n+                let [lhs, rhs] = args else {\n+                    return Err(MirEvalError::TypeError(\"const_eval_select args are not provided\"));\n+                };\n+                let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n+                let ans = lhs.wrapping_add(rhs);\n+                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n+            }\n+            \"copy\" | \"copy_nonoverlapping\" => {\n+                let [src, dst, offset] = args else {\n+                    return Err(MirEvalError::TypeError(\"copy_nonoverlapping args are not provided\"));\n+                };\n+                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                    return Err(MirEvalError::TypeError(\"copy_nonoverlapping generic arg is not provided\"));\n+                };\n+                let src = Address::from_bytes(src.get(self)?)?;\n+                let dst = Address::from_bytes(dst.get(self)?)?;\n+                let offset = from_bytes!(usize, offset.get(self)?);\n+                let size = self.size_of_sized(ty, locals, \"copy_nonoverlapping ptr type\")?;\n+                let size = offset * size;\n+                let src = Interval { addr: src, size };\n+                let dst = Interval { addr: dst, size };\n+                dst.write_from_interval(self, src)\n+            }\n+            \"offset\" | \"arith_offset\" => {\n+                let [ptr, offset] = args else {\n+                    return Err(MirEvalError::TypeError(\"offset args are not provided\"));\n+                };\n+                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                    return Err(MirEvalError::TypeError(\"offset generic arg is not provided\"));\n+                };\n+                let ptr = u128::from_le_bytes(pad16(ptr.get(self)?, false));\n+                let offset = u128::from_le_bytes(pad16(offset.get(self)?, false));\n+                let size = self.size_of_sized(ty, locals, \"offset ptr type\")? as u128;\n+                let ans = ptr + offset * size;\n+                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n+            }\n+            \"assert_inhabited\" | \"assert_zero_valid\" | \"assert_uninit_valid\" => {\n+                // FIXME: We should actually implement these checks\n+                Ok(())\n+            }\n+            \"forget\" => {\n+                // We don't call any drop glue yet, so there is nothing here\n+                Ok(())\n+            }\n+            \"transmute\" => {\n+                let [arg] = args else {\n+                    return Err(MirEvalError::TypeError(\"trasmute arg is not provided\"));\n+                };\n+                destination.write_from_interval(self, arg.interval)\n+            }\n+            \"const_eval_select\" => {\n+                let [tuple, const_fn, _] = args else {\n+                    return Err(MirEvalError::TypeError(\"const_eval_select args are not provided\"));\n+                };\n+                let mut args = vec![const_fn.clone()];\n+                let TyKind::Tuple(_, fields) = tuple.ty.kind(Interner) else {\n+                    return Err(MirEvalError::TypeError(\"const_eval_select arg[0] is not a tuple\"));\n+                };\n+                let layout = self.layout(&tuple.ty)?;\n+                for (i, field) in fields.iter(Interner).enumerate() {\n+                    let field = field.assert_ty_ref(Interner).clone();\n+                    let offset = layout.fields.offset(i).bytes_usize();\n+                    let addr = tuple.interval.addr.offset(offset);\n+                    args.push(IntervalAndTy::new(addr, field, self, locals)?);\n                 }\n+                self.exec_fn_trait(&args, destination, locals)\n             }\n             _ => not_supported!(\"unknown intrinsic {as_str}\"),\n         }\n     }\n \n-    pub(crate) fn exec_lang_item(\n-        &self,\n-        x: LangItem,\n-        mut args: std::vec::IntoIter<Vec<u8>>,\n-    ) -> Result<Vec<u8>> {\n+    fn exec_fn_pointer(\n+        &mut self,\n+        bytes: Interval,\n+        destination: Interval,\n+        args: &[IntervalAndTy],\n+        locals: &Locals<'_>,\n+    ) -> Result<()> {\n+        let id = from_bytes!(usize, bytes.get(self)?);\n+        let next_ty = self.vtable_map.ty(id)?.clone();\n+        if let TyKind::FnDef(def, generic_args) = &next_ty.data(Interner).kind {\n+            self.exec_fn_def(*def, generic_args, destination, args, &locals)?;\n+        } else {\n+            return Err(MirEvalError::TypeError(\"function pointer to non function\"));\n+        }\n+        Ok(())\n+    }\n+\n+    fn exec_fn_def(\n+        &mut self,\n+        def: FnDefId,\n+        generic_args: &Substitution,\n+        destination: Interval,\n+        args: &[IntervalAndTy],\n+        locals: &Locals<'_>,\n+    ) -> Result<()> {\n+        let def: CallableDefId = from_chalk(self.db, def);\n+        let generic_args = self.subst_filler(generic_args, &locals);\n+        match def {\n+            CallableDefId::FunctionId(def) => {\n+                if let Some(_) = self.detect_fn_trait(def) {\n+                    self.exec_fn_trait(&args, destination, locals)?;\n+                    return Ok(());\n+                }\n+                self.exec_fn_with_args(def, args, generic_args, locals, destination)?;\n+            }\n+            CallableDefId::StructId(id) => {\n+                let (size, variant_layout, tag) =\n+                    self.layout_of_variant(id.into(), generic_args.clone(), &locals)?;\n+                let result = self.make_by_layout(\n+                    size,\n+                    &variant_layout,\n+                    tag,\n+                    args.iter().map(|x| x.interval),\n+                )?;\n+                destination.write_from_bytes(self, &result)?;\n+            }\n+            CallableDefId::EnumVariantId(id) => {\n+                let (size, variant_layout, tag) =\n+                    self.layout_of_variant(id.into(), generic_args.clone(), &locals)?;\n+                let result = self.make_by_layout(\n+                    size,\n+                    &variant_layout,\n+                    tag,\n+                    args.iter().map(|x| x.interval),\n+                )?;\n+                destination.write_from_bytes(self, &result)?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn exec_fn_with_args(\n+        &mut self,\n+        def: FunctionId,\n+        args: &[IntervalAndTy],\n+        generic_args: Substitution,\n+        locals: &Locals<'_>,\n+        destination: Interval,\n+    ) -> Result<()> {\n+        let function_data = self.db.function_data(def);\n+        let is_intrinsic = match &function_data.abi {\n+            Some(abi) => *abi == Interned::new_str(\"rust-intrinsic\"),\n+            None => match def.lookup(self.db.upcast()).container {\n+                hir_def::ItemContainerId::ExternBlockId(block) => {\n+                    let id = block.lookup(self.db.upcast()).id;\n+                    id.item_tree(self.db.upcast())[id.value].abi.as_deref()\n+                        == Some(\"rust-intrinsic\")\n+                }\n+                _ => false,\n+            },\n+        };\n+        if is_intrinsic {\n+            return self.exec_intrinsic(\n+                function_data.name.as_text().unwrap_or_default().as_str(),\n+                args,\n+                generic_args,\n+                destination,\n+                &locals,\n+            );\n+        }\n+        let arg_bytes =\n+            args.iter().map(|x| Ok(x.get(&self)?.to_owned())).collect::<Result<Vec<_>>>()?;\n+        let result = if let Some(x) = self.detect_lang_function(def) {\n+            self.exec_lang_item(x, &arg_bytes)?\n+        } else {\n+            if let Some(self_ty_idx) =\n+                is_dyn_method(self.db, self.trait_env.clone(), def, generic_args.clone())\n+            {\n+                // In the layout of current possible receiver, which at the moment of writing this code is one of\n+                // `&T`, `&mut T`, `Box<T>`, `Rc<T>`, `Arc<T>`, and `Pin<P>` where `P` is one of possible recievers,\n+                // the vtable is exactly in the `[ptr_size..2*ptr_size]` bytes. So we can use it without branching on\n+                // the type.\n+                let ty = self\n+                    .vtable_map\n+                    .ty_of_bytes(&arg_bytes[0][self.ptr_size()..self.ptr_size() * 2])?;\n+                let mut args_for_target = args.to_vec();\n+                args_for_target[0] = IntervalAndTy {\n+                    interval: args_for_target[0].interval.slice(0..self.ptr_size()),\n+                    ty: ty.clone(),\n+                };\n+                let ty = GenericArgData::Ty(ty.clone()).intern(Interner);\n+                let generics_for_target = Substitution::from_iter(\n+                    Interner,\n+                    generic_args.iter(Interner).enumerate().map(|(i, x)| {\n+                        if i == self_ty_idx {\n+                            &ty\n+                        } else {\n+                            x\n+                        }\n+                    }),\n+                );\n+                return self.exec_fn_with_args(\n+                    def,\n+                    &args_for_target,\n+                    generics_for_target,\n+                    locals,\n+                    destination,\n+                );\n+            }\n+            let (imp, generic_args) =\n+                lookup_impl_method(self.db, self.trait_env.clone(), def, generic_args.clone());\n+            let generic_args = self.subst_filler(&generic_args, &locals);\n+            let def = imp.into();\n+            let mir_body =\n+                self.db.mir_body(def).map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n+            self.interpret_mir(&mir_body, arg_bytes.iter().cloned(), generic_args)\n+                .map_err(|e| MirEvalError::InFunction(imp, Box::new(e)))?\n+        };\n+        destination.write_from_bytes(self, &result)?;\n+        Ok(())\n+    }\n+\n+    fn exec_fn_trait(\n+        &mut self,\n+        args: &[IntervalAndTy],\n+        destination: Interval,\n+        locals: &Locals<'_>,\n+    ) -> Result<()> {\n+        let func = args.get(0).ok_or(MirEvalError::TypeError(\"fn trait with no arg\"))?;\n+        let mut func_ty = func.ty.clone();\n+        let mut func_data = func.interval;\n+        while let TyKind::Ref(_, _, z) = func_ty.kind(Interner) {\n+            func_ty = z.clone();\n+            if matches!(func_ty.kind(Interner), TyKind::Dyn(_)) {\n+                let id =\n+                    from_bytes!(usize, &func_data.get(self)?[self.ptr_size()..self.ptr_size() * 2]);\n+                func_data = func_data.slice(0..self.ptr_size());\n+                func_ty = self.vtable_map.ty(id)?.clone();\n+            }\n+            let size = self.size_of_sized(&func_ty, locals, \"self type of fn trait\")?;\n+            func_data = Interval { addr: Address::from_bytes(func_data.get(self)?)?, size };\n+        }\n+        match &func_ty.data(Interner).kind {\n+            TyKind::FnDef(def, subst) => {\n+                self.exec_fn_def(*def, subst, destination, &args[1..], locals)?;\n+            }\n+            TyKind::Function(_) => {\n+                self.exec_fn_pointer(func_data, destination, &args[1..], locals)?;\n+            }\n+            x => not_supported!(\"Call FnTrait methods with type {x:?}\"),\n+        }\n+        Ok(())\n+    }\n+\n+    fn exec_lang_item(&self, x: LangItem, args: &[Vec<u8>]) -> Result<Vec<u8>> {\n         use LangItem::*;\n+        let mut args = args.iter();\n         match x {\n-            PanicFmt | BeginPanic => Err(MirEvalError::Panic),\n+            // FIXME: we want to find the panic message from arguments, but it wouldn't work\n+            // currently even if we do that, since macro expansion of panic related macros\n+            // is dummy.\n+            PanicFmt | BeginPanic => Err(MirEvalError::Panic(\"<format-args>\".to_string())),\n             SliceLen => {\n                 let arg = args\n                     .next()"}, {"sha": "1821796be33c16f3dcd069752f960efd3af5aec0", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 219, "deletions": 379, "changes": 598, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -4,19 +4,21 @@ use std::{iter, mem, sync::Arc};\n \n use chalk_ir::{BoundVar, ConstData, DebruijnIndex, TyKind};\n use hir_def::{\n+    adt::{StructKind, VariantData},\n     body::Body,\n     expr::{\n         Array, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm, Pat, PatId,\n-        RecordLitField,\n+        RecordFieldPat, RecordLitField,\n     },\n     lang_item::{LangItem, LangItemTarget},\n     layout::LayoutError,\n     path::Path,\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n-    DefWithBodyId, EnumVariantId, HasModule,\n+    AdtId, DefWithBodyId, EnumVariantId, HasModule, ItemContainerId, LocalFieldId, TraitId,\n };\n use hir_expand::name::Name;\n use la_arena::ArenaMap;\n+use rustc_hash::FxHashMap;\n \n use crate::{\n     consteval::ConstEvalError, db::HirDatabase, display::HirDisplay, infer::TypeMismatch,\n@@ -27,18 +29,25 @@ use crate::{\n use super::*;\n \n mod as_place;\n+mod pattern_matching;\n \n-#[derive(Debug, Clone, Copy)]\n+use pattern_matching::AdtPatternShape;\n+\n+#[derive(Debug, Clone)]\n struct LoopBlocks {\n     begin: BasicBlockId,\n     /// `None` for loops that are not terminating\n     end: Option<BasicBlockId>,\n+    place: Place,\n }\n \n struct MirLowerCtx<'a> {\n     result: MirBody,\n     owner: DefWithBodyId,\n     current_loop_blocks: Option<LoopBlocks>,\n+    // FIXME: we should resolve labels in HIR lowering and always work with label id here, not\n+    // with raw names.\n+    labeled_loop_blocks: FxHashMap<Name, LoopBlocks>,\n     discr_temp: Option<Place>,\n     db: &'a dyn HirDatabase,\n     body: &'a Body,\n@@ -50,6 +59,8 @@ pub enum MirLowerError {\n     ConstEvalError(Box<ConstEvalError>),\n     LayoutError(LayoutError),\n     IncompleteExpr,\n+    /// Trying to lower a trait function, instead of an implementation\n+    TraitFunctionDefinition(TraitId, Name),\n     UnresolvedName(String),\n     RecordLiteralWithoutPath,\n     UnresolvedMethod,\n@@ -66,6 +77,7 @@ pub enum MirLowerError {\n     ImplementationError(&'static str),\n     LangItemNotFound(LangItem),\n     MutatingRvalue,\n+    UnresolvedLabel,\n }\n \n macro_rules! not_supported {\n@@ -200,26 +212,42 @@ impl MirLowerCtx<'_> {\n         mut current: BasicBlockId,\n     ) -> Result<Option<BasicBlockId>> {\n         match &self.body.exprs[expr_id] {\n-            Expr::Missing => Err(MirLowerError::IncompleteExpr),\n+            Expr::Missing => {\n+                if let DefWithBodyId::FunctionId(f) = self.owner {\n+                    let assoc = self.db.lookup_intern_function(f);\n+                    if let ItemContainerId::TraitId(t) = assoc.container {\n+                        let name = &self.db.function_data(f).name;\n+                        return Err(MirLowerError::TraitFunctionDefinition(t, name.clone()));\n+                    }\n+                }\n+                Err(MirLowerError::IncompleteExpr)\n+            },\n             Expr::Path(p) => {\n                 let unresolved_name = || MirLowerError::unresolved_path(self.db, p);\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n                 let pr = resolver\n-                    .resolve_path_in_value_ns(self.db.upcast(), p.mod_path())\n+                    .resolve_path_in_value_ns(self.db.upcast(), p)\n                     .ok_or_else(unresolved_name)?;\n                 let pr = match pr {\n                     ResolveValueResult::ValueNs(v) => v,\n                     ResolveValueResult::Partial(..) => {\n-                        if let Some(assoc) = self\n+                        if let Some((assoc, subst)) = self\n                             .infer\n                             .assoc_resolutions_for_expr(expr_id)\n                         {\n-                            match assoc.0 {\n+                            match assoc {\n                                 hir_def::AssocItemId::ConstId(c) => {\n-                                    self.lower_const(c, current, place, expr_id.into())?;\n+                                    self.lower_const(c, current, place, subst, expr_id.into())?;\n+                                    return Ok(Some(current))\n+                                },\n+                                hir_def::AssocItemId::FunctionId(_) => {\n+                                    // FnDefs are zero sized, no action is needed.\n                                     return Ok(Some(current))\n+                                }\n+                                hir_def::AssocItemId::TypeAliasId(_) => {\n+                                    // FIXME: If it is unreachable, use proper error instead of `not_supported`.\n+                                    not_supported!(\"associated functions and types\")\n                                 },\n-                                _ => not_supported!(\"associated functions and types\"),\n                             }\n                         } else if let Some(variant) = self\n                             .infer\n@@ -246,19 +274,23 @@ impl MirLowerCtx<'_> {\n                         Ok(Some(current))\n                     }\n                     ValueNs::ConstId(const_id) => {\n-                        self.lower_const(const_id, current, place, expr_id.into())?;\n+                        self.lower_const(const_id, current, place, Substitution::empty(Interner), expr_id.into())?;\n                         Ok(Some(current))\n                     }\n                     ValueNs::EnumVariantId(variant_id) => {\n-                        let ty = self.infer.type_of_expr[expr_id].clone();\n-                        let current = self.lower_enum_variant(\n-                            variant_id,\n-                            current,\n-                            place,\n-                            ty,\n-                            vec![],\n-                            expr_id.into(),\n-                        )?;\n+                        let variant_data = &self.db.enum_data(variant_id.parent).variants[variant_id.local_id];\n+                        if variant_data.variant_data.kind() == StructKind::Unit {\n+                            let ty = self.infer.type_of_expr[expr_id].clone();\n+                            current = self.lower_enum_variant(\n+                                variant_id,\n+                                current,\n+                                place,\n+                                ty,\n+                                vec![],\n+                                expr_id.into(),\n+                            )?;\n+                        }\n+                        // Otherwise its a tuple like enum, treated like a zero sized function, so no action is needed\n                         Ok(Some(current))\n                     }\n                     ValueNs::GenericParam(p) => {\n@@ -287,7 +319,7 @@ impl MirLowerCtx<'_> {\n                         );\n                         Ok(Some(current))\n                     }\n-                    ValueNs::StructId(_) => {\n+                    ValueNs::FunctionId(_) | ValueNs::StructId(_) => {\n                         // It's probably a unit struct or a zero sized function, so no action is needed.\n                         Ok(Some(current))\n                     }\n@@ -349,19 +381,29 @@ impl MirLowerCtx<'_> {\n                 Ok(self.merge_blocks(Some(then_target), else_target))\n             }\n             Expr::Unsafe { id: _, statements, tail } => {\n-                self.lower_block_to_place(None, statements, current, *tail, place)\n+                self.lower_block_to_place(statements, current, *tail, place)\n             }\n             Expr::Block { id: _, statements, tail, label } => {\n-                self.lower_block_to_place(*label, statements, current, *tail, place)\n+                if let Some(label) = label {\n+                    self.lower_loop(current, place.clone(), Some(*label), |this, begin| {\n+                        if let Some(block) = this.lower_block_to_place(statements, begin, *tail, place)? {\n+                            let end = this.current_loop_end()?;\n+                            this.set_goto(block, end);\n+                        }\n+                        Ok(())\n+                    })\n+                } else {\n+                    self.lower_block_to_place(statements, current, *tail, place)\n+                }\n             }\n-            Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin| {\n+            Expr::Loop { body, label } => self.lower_loop(current, place, *label, |this, begin| {\n                 if let Some((_, block)) = this.lower_expr_as_place(begin, *body, true)? {\n                     this.set_goto(block, begin);\n                 }\n                 Ok(())\n             }),\n             Expr::While { condition, body, label } => {\n-                self.lower_loop(current, *label, |this, begin| {\n+                self.lower_loop(current, place, *label, |this, begin| {\n                     let Some((discr, to_switch)) = this.lower_expr_to_some_operand(*condition, begin)? else {\n                         return Ok(());\n                     };\n@@ -412,7 +454,7 @@ impl MirLowerCtx<'_> {\n                     return Ok(None);\n                 };\n                 self.push_assignment(current, ref_mut_iterator_place.clone(), Rvalue::Ref(BorrowKind::Mut { allow_two_phase_borrow: false }, iterator_place), expr_id.into());\n-                self.lower_loop(current, label, |this, begin| {\n+                self.lower_loop(current, place, label, |this, begin| {\n                     let Some(current) = this.lower_call(iter_next_fn_op, vec![Operand::Copy(ref_mut_iterator_place)], option_item_place.clone(), begin, false)?\n                     else {\n                         return Ok(());\n@@ -426,44 +468,45 @@ impl MirLowerCtx<'_> {\n                         current,\n                         pat.into(),\n                         Some(end),\n-                        &[pat], &None)?;\n+                        AdtPatternShape::Tuple { args: &[pat], ellipsis: None },\n+                    )?;\n                     if let Some((_, block)) = this.lower_expr_as_place(current, body, true)? {\n                         this.set_goto(block, begin);\n                     }\n                     Ok(())\n                 })\n             },\n             Expr::Call { callee, args, .. } => {\n+                if let Some((func_id, generic_args)) =\n+                    self.infer.method_resolution(expr_id) {\n+                    let ty = chalk_ir::TyKind::FnDef(\n+                        CallableDefId::FunctionId(func_id).to_chalk(self.db),\n+                        generic_args,\n+                    )\n+                    .intern(Interner);\n+                    let func = Operand::from_bytes(vec![], ty);\n+                    return self.lower_call_and_args(\n+                        func,\n+                        iter::once(*callee).chain(args.iter().copied()),\n+                        place,\n+                        current,\n+                        self.is_uninhabited(expr_id),\n+                    );\n+                }\n                 let callee_ty = self.expr_ty_after_adjustments(*callee);\n                 match &callee_ty.data(Interner).kind {\n                     chalk_ir::TyKind::FnDef(..) => {\n                         let func = Operand::from_bytes(vec![], callee_ty.clone());\n                         self.lower_call_and_args(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id))\n                     }\n-                    TyKind::Scalar(_)\n-                    | TyKind::Tuple(_, _)\n-                    | TyKind::Array(_, _)\n-                    | TyKind::Adt(_, _)\n-                    | TyKind::Str\n-                    | TyKind::Foreign(_)\n-                    | TyKind::Slice(_) => {\n-                        return Err(MirLowerError::TypeError(\"function call on data type\"))\n+                    chalk_ir::TyKind::Function(_) => {\n+                        let Some((func, current)) = self.lower_expr_to_some_operand(*callee, current)? else {\n+                            return Ok(None);\n+                        };\n+                        self.lower_call_and_args(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id))\n                     }\n                     TyKind::Error => return Err(MirLowerError::MissingFunctionDefinition),\n-                    TyKind::AssociatedType(_, _)\n-                    | TyKind::Raw(_, _)\n-                    | TyKind::Ref(_, _, _)\n-                    | TyKind::OpaqueType(_, _)\n-                    | TyKind::Never\n-                    | TyKind::Closure(_, _)\n-                    | TyKind::Generator(_, _)\n-                    | TyKind::GeneratorWitness(_, _)\n-                    | TyKind::Placeholder(_)\n-                    | TyKind::Dyn(_)\n-                    | TyKind::Alias(_)\n-                    | TyKind::Function(_)\n-                    | TyKind::BoundVar(_)\n-                    | TyKind::InferenceVar(_, _) => not_supported!(\"dynamic function call\"),\n+                    _ => return Err(MirLowerError::TypeError(\"function call on bad type\")),\n                 }\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n@@ -491,17 +534,24 @@ impl MirLowerCtx<'_> {\n                 let cond_ty = self.expr_ty_after_adjustments(*expr);\n                 let mut end = None;\n                 for MatchArm { pat, guard, expr } in arms.iter() {\n-                    if guard.is_some() {\n-                        not_supported!(\"pattern matching with guard\");\n-                    }\n-                    let (then, otherwise) = self.pattern_match(\n+                    let (then, mut otherwise) = self.pattern_match(\n                         current,\n                         None,\n                         cond_place.clone(),\n                         cond_ty.clone(),\n                         *pat,\n                         BindingAnnotation::Unannotated,\n                     )?;\n+                    let then = if let &Some(guard) = guard {\n+                        let next = self.new_basic_block();\n+                        let o = otherwise.get_or_insert_with(|| self.new_basic_block());\n+                        if let Some((discr, c)) = self.lower_expr_to_some_operand(guard, then)? {\n+                            self.set_terminator(c, Terminator::SwitchInt { discr, targets: SwitchTargets::static_if(1, next, *o) });\n+                        }\n+                        next\n+                    } else {\n+                        then\n+                    };\n                     if let Some(block) = self.lower_expr_to_place(*expr, place.clone(), then)? {\n                         let r = end.get_or_insert_with(|| self.new_basic_block());\n                         self.set_goto(block, *r);\n@@ -524,24 +574,28 @@ impl MirLowerCtx<'_> {\n                 Some(_) => not_supported!(\"continue with label\"),\n                 None => {\n                     let loop_data =\n-                        self.current_loop_blocks.ok_or(MirLowerError::ContinueWithoutLoop)?;\n+                        self.current_loop_blocks.as_ref().ok_or(MirLowerError::ContinueWithoutLoop)?;\n                     self.set_goto(current, loop_data.begin);\n                     Ok(None)\n                 }\n             },\n             Expr::Break { expr, label } => {\n-                if expr.is_some() {\n-                    not_supported!(\"break with value\");\n-                }\n-                match label {\n-                    Some(_) => not_supported!(\"break with label\"),\n-                    None => {\n-                        let end =\n-                            self.current_loop_end()?;\n-                        self.set_goto(current, end);\n-                        Ok(None)\n-                    }\n+                if let Some(expr) = expr {\n+                    let loop_data = match label {\n+                        Some(l) => self.labeled_loop_blocks.get(l).ok_or(MirLowerError::UnresolvedLabel)?,\n+                        None => self.current_loop_blocks.as_ref().ok_or(MirLowerError::BreakWithoutLoop)?,\n+                    };\n+                    let Some(c) = self.lower_expr_to_place(*expr, loop_data.place.clone(), current)? else {\n+                        return Ok(None);\n+                    };\n+                    current = c;\n                 }\n+                let end = match label {\n+                    Some(l) => self.labeled_loop_blocks.get(l).ok_or(MirLowerError::UnresolvedLabel)?.end.expect(\"We always generate end for labeled loops\"),\n+                    None => self.current_loop_end()?,\n+                };\n+                self.set_goto(current, end);\n+                Ok(None)\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n@@ -555,7 +609,17 @@ impl MirLowerCtx<'_> {\n                 Ok(None)\n             }\n             Expr::Yield { .. } => not_supported!(\"yield\"),\n-            Expr::RecordLit { fields, path, .. } => {\n+            Expr::RecordLit { fields, path, spread, ellipsis: _, is_assignee_expr: _ } => {\n+                let spread_place = match spread {\n+                    &Some(x) => {\n+                        let Some((p, c)) = self.lower_expr_as_place(current, x, true)? else {\n+                            return Ok(None);\n+                        };\n+                        current = c;\n+                        Some(p)\n+                    },\n+                    None => None,\n+                };\n                 let variant_id = self\n                     .infer\n                     .variant_resolution_for_expr(expr_id)\n@@ -585,9 +649,24 @@ impl MirLowerCtx<'_> {\n                             place,\n                             Rvalue::Aggregate(\n                                 AggregateKind::Adt(variant_id, subst),\n-                                operands.into_iter().map(|x| x).collect::<Option<_>>().ok_or(\n-                                    MirLowerError::TypeError(\"missing field in record literal\"),\n-                                )?,\n+                                match spread_place {\n+                                    Some(sp) => operands.into_iter().enumerate().map(|(i, x)| {\n+                                        match x {\n+                                            Some(x) => x,\n+                                            None => {\n+                                                let mut p = sp.clone();\n+                                                p.projection.push(ProjectionElem::Field(FieldId {\n+                                                    parent: variant_id,\n+                                                    local_id: LocalFieldId::from_raw(RawIdx::from(i as u32)),\n+                                                }));\n+                                                Operand::Copy(p)\n+                                            },\n+                                        }\n+                                    }).collect(),\n+                                    None => operands.into_iter().collect::<Option<_>>().ok_or(\n+                                        MirLowerError::TypeError(\"missing field in record literal\"),\n+                                    )?,\n+                                },\n                             ),\n                             expr_id.into(),\n                         );\n@@ -608,9 +687,7 @@ impl MirLowerCtx<'_> {\n                 }\n             }\n             Expr::Await { .. } => not_supported!(\"await\"),\n-            Expr::Try { .. } => not_supported!(\"? operator\"),\n             Expr::Yeet { .. } => not_supported!(\"yeet\"),\n-            Expr::TryBlock { .. } => not_supported!(\"try block\"),\n             Expr::Async { .. } => not_supported!(\"async block\"),\n             Expr::Const { .. } => not_supported!(\"anonymous const block\"),\n             Expr::Cast { expr, type_ref: _ } => {\n@@ -703,7 +780,49 @@ impl MirLowerCtx<'_> {\n                 );\n                 Ok(Some(current))\n             }\n-            Expr::Range { .. } => not_supported!(\"range\"),\n+            &Expr::Range { lhs, rhs, range_type: _ } => {\n+                let ty = self.expr_ty(expr_id);\n+                let Some((adt, subst)) = ty.as_adt() else {\n+                    return Err(MirLowerError::TypeError(\"Range type is not adt\"));\n+                };\n+                let AdtId::StructId(st) = adt else {\n+                    return Err(MirLowerError::TypeError(\"Range type is not struct\"));\n+                };\n+                let mut lp = None;\n+                let mut rp = None;\n+                if let Some(x) = lhs {\n+                    let Some((o, c)) = self.lower_expr_to_some_operand(x, current)? else {\n+                        return Ok(None);\n+                    };\n+                    lp = Some(o);\n+                    current = c;\n+                }\n+                if let Some(x) = rhs {\n+                    let Some((o, c)) = self.lower_expr_to_some_operand(x, current)? else {\n+                        return Ok(None);\n+                    };\n+                    rp = Some(o);\n+                    current = c;\n+                }\n+                self.push_assignment(\n+                    current,\n+                    place,\n+                    Rvalue::Aggregate(\n+                        AggregateKind::Adt(st.into(), subst.clone()),\n+                        self.db.struct_data(st).variant_data.fields().iter().map(|x| {\n+                            let o = match x.1.name.as_str() {\n+                                Some(\"start\") => lp.take(),\n+                                Some(\"end\") => rp.take(),\n+                                Some(\"exhausted\") => Some(Operand::from_bytes(vec![0], TyBuilder::bool())),\n+                                _ => None,\n+                            };\n+                            o.ok_or(MirLowerError::UnresolvedField)\n+                        }).collect::<Result<_>>()?,\n+                    ),\n+                    expr_id.into(),\n+                );\n+                Ok(Some(current))\n+            },\n             Expr::Closure { .. } => not_supported!(\"closure\"),\n             Expr::Tuple { exprs, is_assignee_expr: _ } => {\n                 let Some(values) = exprs\n@@ -832,9 +951,10 @@ impl MirLowerCtx<'_> {\n         const_id: hir_def::ConstId,\n         prev_block: BasicBlockId,\n         place: Place,\n+        subst: Substitution,\n         span: MirSpan,\n     ) -> Result<()> {\n-        let c = self.db.const_eval(const_id)?;\n+        let c = self.db.const_eval(const_id, subst)?;\n         self.write_const_to_place(c, prev_block, place, span)\n     }\n \n@@ -872,7 +992,7 @@ impl MirLowerCtx<'_> {\n     ) -> Result<BasicBlockId> {\n         let subst = match ty.kind(Interner) {\n             TyKind::Adt(_, subst) => subst.clone(),\n-            _ => not_supported!(\"Non ADT enum\"),\n+            _ => implementation_error!(\"Non ADT enum\"),\n         };\n         self.push_assignment(\n             prev_block,\n@@ -970,287 +1090,6 @@ impl MirLowerCtx<'_> {\n         self.push_statement(block, StatementKind::Assign(place, rvalue).with_span(span));\n     }\n \n-    /// It gets a `current` unterminated block, appends some statements and possibly a terminator to it to check if\n-    /// the pattern matches and write bindings, and returns two unterminated blocks, one for the matched path (which\n-    /// can be the `current` block) and one for the mismatched path. If the input pattern is irrefutable, the\n-    /// mismatched path block is `None`.\n-    ///\n-    /// By default, it will create a new block for mismatched path. If you already have one, you can provide it with\n-    /// `current_else` argument to save an unneccessary jump. If `current_else` isn't `None`, the result mismatched path\n-    /// wouldn't be `None` as well. Note that this function will add jumps to the beginning of the `current_else` block,\n-    /// so it should be an empty block.\n-    fn pattern_match(\n-        &mut self,\n-        mut current: BasicBlockId,\n-        mut current_else: Option<BasicBlockId>,\n-        mut cond_place: Place,\n-        mut cond_ty: Ty,\n-        pattern: PatId,\n-        mut binding_mode: BindingAnnotation,\n-    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        Ok(match &self.body.pats[pattern] {\n-            Pat::Missing => return Err(MirLowerError::IncompleteExpr),\n-            Pat::Wild => (current, current_else),\n-            Pat::Tuple { args, ellipsis } => {\n-                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n-                let subst = match cond_ty.kind(Interner) {\n-                    TyKind::Tuple(_, s) => s,\n-                    _ => {\n-                        return Err(MirLowerError::TypeError(\n-                            \"non tuple type matched with tuple pattern\",\n-                        ))\n-                    }\n-                };\n-                self.pattern_match_tuple_like(\n-                    current,\n-                    current_else,\n-                    args.iter().enumerate().map(|(i, x)| {\n-                        (\n-                            PlaceElem::TupleField(i),\n-                            *x,\n-                            subst.at(Interner, i).assert_ty_ref(Interner).clone(),\n-                        )\n-                    }),\n-                    *ellipsis,\n-                    &cond_place,\n-                    binding_mode,\n-                )?\n-            }\n-            Pat::Or(pats) => {\n-                let then_target = self.new_basic_block();\n-                let mut finished = false;\n-                for pat in &**pats {\n-                    let (next, next_else) = self.pattern_match(\n-                        current,\n-                        None,\n-                        cond_place.clone(),\n-                        cond_ty.clone(),\n-                        *pat,\n-                        binding_mode,\n-                    )?;\n-                    self.set_goto(next, then_target);\n-                    match next_else {\n-                        Some(t) => {\n-                            current = t;\n-                        }\n-                        None => {\n-                            finished = true;\n-                            break;\n-                        }\n-                    }\n-                }\n-                if !finished {\n-                    let ce = *current_else.get_or_insert_with(|| self.new_basic_block());\n-                    self.set_goto(current, ce);\n-                }\n-                (then_target, current_else)\n-            }\n-            Pat::Record { .. } => not_supported!(\"record pattern\"),\n-            Pat::Range { .. } => not_supported!(\"range pattern\"),\n-            Pat::Slice { .. } => not_supported!(\"slice pattern\"),\n-            Pat::Path(_) => {\n-                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n-                    not_supported!(\"unresolved variant\");\n-                };\n-                self.pattern_matching_variant(\n-                    cond_ty,\n-                    binding_mode,\n-                    cond_place,\n-                    variant,\n-                    current,\n-                    pattern.into(),\n-                    current_else,\n-                    &[],\n-                    &None,\n-                )?\n-            }\n-            Pat::Lit(l) => {\n-                let then_target = self.new_basic_block();\n-                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n-                match &self.body.exprs[*l] {\n-                    Expr::Literal(l) => match l {\n-                        hir_def::expr::Literal::Int(x, _) => {\n-                            self.set_terminator(\n-                                current,\n-                                Terminator::SwitchInt {\n-                                    discr: Operand::Copy(cond_place),\n-                                    targets: SwitchTargets::static_if(\n-                                        *x as u128,\n-                                        then_target,\n-                                        else_target,\n-                                    ),\n-                                },\n-                            );\n-                        }\n-                        hir_def::expr::Literal::Uint(x, _) => {\n-                            self.set_terminator(\n-                                current,\n-                                Terminator::SwitchInt {\n-                                    discr: Operand::Copy(cond_place),\n-                                    targets: SwitchTargets::static_if(*x, then_target, else_target),\n-                                },\n-                            );\n-                        }\n-                        _ => not_supported!(\"non int path literal\"),\n-                    },\n-                    _ => not_supported!(\"expression path literal\"),\n-                }\n-                (then_target, Some(else_target))\n-            }\n-            Pat::Bind { id, subpat } => {\n-                let target_place = self.result.binding_locals[*id];\n-                let mode = self.body.bindings[*id].mode;\n-                if let Some(subpat) = subpat {\n-                    (current, current_else) = self.pattern_match(\n-                        current,\n-                        current_else,\n-                        cond_place.clone(),\n-                        cond_ty,\n-                        *subpat,\n-                        binding_mode,\n-                    )?\n-                }\n-                if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n-                    binding_mode = mode;\n-                }\n-                self.push_storage_live(*id, current);\n-                self.push_assignment(\n-                    current,\n-                    target_place.into(),\n-                    match binding_mode {\n-                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n-                            Operand::Copy(cond_place).into()\n-                        }\n-                        BindingAnnotation::Ref => Rvalue::Ref(BorrowKind::Shared, cond_place),\n-                        BindingAnnotation::RefMut => Rvalue::Ref(\n-                            BorrowKind::Mut { allow_two_phase_borrow: false },\n-                            cond_place,\n-                        ),\n-                    },\n-                    pattern.into(),\n-                );\n-                (current, current_else)\n-            }\n-            Pat::TupleStruct { path: _, args, ellipsis } => {\n-                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n-                    not_supported!(\"unresolved variant\");\n-                };\n-                self.pattern_matching_variant(\n-                    cond_ty,\n-                    binding_mode,\n-                    cond_place,\n-                    variant,\n-                    current,\n-                    pattern.into(),\n-                    current_else,\n-                    args,\n-                    ellipsis,\n-                )?\n-            }\n-            Pat::Ref { .. } => not_supported!(\"& pattern\"),\n-            Pat::Box { .. } => not_supported!(\"box pattern\"),\n-            Pat::ConstBlock(_) => not_supported!(\"const block pattern\"),\n-        })\n-    }\n-\n-    fn pattern_matching_variant(\n-        &mut self,\n-        mut cond_ty: Ty,\n-        mut binding_mode: BindingAnnotation,\n-        mut cond_place: Place,\n-        variant: VariantId,\n-        current: BasicBlockId,\n-        span: MirSpan,\n-        current_else: Option<BasicBlockId>,\n-        args: &[PatId],\n-        ellipsis: &Option<usize>,\n-    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n-        let subst = match cond_ty.kind(Interner) {\n-            TyKind::Adt(_, s) => s,\n-            _ => return Err(MirLowerError::TypeError(\"non adt type matched with tuple struct\")),\n-        };\n-        let fields_type = self.db.field_types(variant);\n-        Ok(match variant {\n-            VariantId::EnumVariantId(v) => {\n-                let e = self.db.const_eval_discriminant(v)? as u128;\n-                let next = self.new_basic_block();\n-                let tmp = self.discr_temp_place();\n-                self.push_assignment(\n-                    current,\n-                    tmp.clone(),\n-                    Rvalue::Discriminant(cond_place.clone()),\n-                    span,\n-                );\n-                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n-                self.set_terminator(\n-                    current,\n-                    Terminator::SwitchInt {\n-                        discr: Operand::Copy(tmp),\n-                        targets: SwitchTargets::static_if(e, next, else_target),\n-                    },\n-                );\n-                let enum_data = self.db.enum_data(v.parent);\n-                let fields =\n-                    enum_data.variants[v.local_id].variant_data.fields().iter().map(|(x, _)| {\n-                        (\n-                            PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n-                            fields_type[x].clone().substitute(Interner, subst),\n-                        )\n-                    });\n-                self.pattern_match_tuple_like(\n-                    next,\n-                    Some(else_target),\n-                    args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n-                    *ellipsis,\n-                    &cond_place,\n-                    binding_mode,\n-                )?\n-            }\n-            VariantId::StructId(s) => {\n-                let struct_data = self.db.struct_data(s);\n-                let fields = struct_data.variant_data.fields().iter().map(|(x, _)| {\n-                    (\n-                        PlaceElem::Field(FieldId { parent: s.into(), local_id: x }),\n-                        fields_type[x].clone().substitute(Interner, subst),\n-                    )\n-                });\n-                self.pattern_match_tuple_like(\n-                    current,\n-                    current_else,\n-                    args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n-                    *ellipsis,\n-                    &cond_place,\n-                    binding_mode,\n-                )?\n-            }\n-            VariantId::UnionId(_) => {\n-                return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n-            }\n-        })\n-    }\n-\n-    fn pattern_match_tuple_like(\n-        &mut self,\n-        mut current: BasicBlockId,\n-        mut current_else: Option<BasicBlockId>,\n-        args: impl Iterator<Item = (PlaceElem, PatId, Ty)>,\n-        ellipsis: Option<usize>,\n-        cond_place: &Place,\n-        binding_mode: BindingAnnotation,\n-    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        if ellipsis.is_some() {\n-            not_supported!(\"tuple like pattern with ellipsis\");\n-        }\n-        for (proj, arg, ty) in args {\n-            let mut cond_place = cond_place.clone();\n-            cond_place.projection.push(proj);\n-            (current, current_else) =\n-                self.pattern_match(current, current_else, cond_place, ty, arg, binding_mode)?;\n-        }\n-        Ok((current, current_else))\n-    }\n-\n     fn discr_temp_place(&mut self) -> Place {\n         match &self.discr_temp {\n             Some(x) => x.clone(),\n@@ -1266,19 +1105,34 @@ impl MirLowerCtx<'_> {\n     fn lower_loop(\n         &mut self,\n         prev_block: BasicBlockId,\n+        place: Place,\n         label: Option<LabelId>,\n         f: impl FnOnce(&mut MirLowerCtx<'_>, BasicBlockId) -> Result<()>,\n     ) -> Result<Option<BasicBlockId>> {\n-        if label.is_some() {\n-            not_supported!(\"loop with label\");\n-        }\n         let begin = self.new_basic_block();\n-        let prev =\n-            mem::replace(&mut self.current_loop_blocks, Some(LoopBlocks { begin, end: None }));\n+        let prev = mem::replace(\n+            &mut self.current_loop_blocks,\n+            Some(LoopBlocks { begin, end: None, place }),\n+        );\n+        let prev_label = if let Some(label) = label {\n+            // We should generate the end now, to make sure that it wouldn't change later. It is\n+            // bad as we may emit end (unneccessary unreachable block) for unterminating loop, but\n+            // it should not affect correctness.\n+            self.current_loop_end()?;\n+            self.labeled_loop_blocks.insert(\n+                self.body.labels[label].name.clone(),\n+                self.current_loop_blocks.as_ref().unwrap().clone(),\n+            )\n+        } else {\n+            None\n+        };\n         self.set_goto(prev_block, begin);\n         f(self, begin)?;\n         let my = mem::replace(&mut self.current_loop_blocks, prev)\n             .ok_or(MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\"))?;\n+        if let Some(prev) = prev_label {\n+            self.labeled_loop_blocks.insert(self.body.labels[label.unwrap()].name.clone(), prev);\n+        }\n         Ok(my.end)\n     }\n \n@@ -1366,15 +1220,11 @@ impl MirLowerCtx<'_> {\n \n     fn lower_block_to_place(\n         &mut self,\n-        label: Option<LabelId>,\n         statements: &[hir_def::expr::Statement],\n         mut current: BasicBlockId,\n         tail: Option<ExprId>,\n         place: Place,\n     ) -> Result<Option<Idx<BasicBlock>>> {\n-        if label.is_some() {\n-            not_supported!(\"block with label\");\n-        }\n         for statement in statements.iter() {\n             match statement {\n                 hir_def::expr::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n@@ -1428,22 +1278,6 @@ impl MirLowerCtx<'_> {\n     }\n }\n \n-fn pattern_matching_dereference(\n-    cond_ty: &mut Ty,\n-    binding_mode: &mut BindingAnnotation,\n-    cond_place: &mut Place,\n-) {\n-    while let Some((ty, _, mu)) = cond_ty.as_reference() {\n-        if mu == Mutability::Mut && *binding_mode != BindingAnnotation::Ref {\n-            *binding_mode = BindingAnnotation::RefMut;\n-        } else {\n-            *binding_mode = BindingAnnotation::Ref;\n-        }\n-        *cond_ty = ty.clone();\n-        cond_place.projection.push(ProjectionElem::Deref);\n-    }\n-}\n-\n fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n     Ok(match (source_ty.kind(Interner), target_ty.kind(Interner)) {\n         (TyKind::Scalar(s), TyKind::Scalar(t)) => match (s, t) {\n@@ -1452,6 +1286,11 @@ fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n             (_, chalk_ir::Scalar::Float(_)) => CastKind::IntToFloat,\n             (_, _) => CastKind::IntToInt,\n         },\n+        (TyKind::Scalar(_), TyKind::Raw(..)) => CastKind::PointerFromExposedAddress,\n+        (TyKind::Raw(..), TyKind::Scalar(_)) => CastKind::PointerExposeAddress,\n+        (TyKind::Raw(..) | TyKind::Ref(..), TyKind::Raw(..) | TyKind::Ref(..)) => {\n+            CastKind::PtrToPtr\n+        }\n         // Enum to int casts\n         (TyKind::Scalar(_), TyKind::Adt(..)) | (TyKind::Adt(..), TyKind::Scalar(_)) => {\n             CastKind::IntToInt\n@@ -1552,6 +1391,7 @@ pub fn lower_to_mir(\n         body,\n         owner,\n         current_loop_blocks: None,\n+        labeled_loop_blocks: Default::default(),\n         discr_temp: None,\n     };\n     let mut current = start_block;"}, {"sha": "425904850ba85436609d711cf2152a28e6ed5733", "filename": "crates/hir-ty/src/mir/lower/as_place.rs", "status": "modified", "additions": 87, "deletions": 4, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -1,6 +1,7 @@\n //! MIR lowering for places\n \n use super::*;\n+use hir_def::FunctionId;\n use hir_expand::name;\n \n macro_rules! not_supported {\n@@ -125,7 +126,7 @@ impl MirLowerCtx<'_> {\n         match &self.body.exprs[expr_id] {\n             Expr::Path(p) => {\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n-                let Some(pr) = resolver.resolve_path_in_value_ns(self.db.upcast(), p.mod_path()) else {\n+                let Some(pr) = resolver.resolve_path_in_value_ns(self.db.upcast(), p) else {\n                     return Err(MirLowerError::unresolved_path(self.db, p));\n                 };\n                 let pr = match pr {\n@@ -145,10 +146,32 @@ impl MirLowerCtx<'_> {\n                         self.expr_ty(*expr).kind(Interner),\n                         TyKind::Ref(..) | TyKind::Raw(..)\n                     ) {\n-                        let Some(_) = self.lower_expr_as_place(current, *expr, true)? else {\n+                        let Some((p, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n                             return Ok(None);\n                         };\n-                        not_supported!(\"explicit overloaded deref\");\n+                        return self.lower_overloaded_deref(\n+                            current,\n+                            p,\n+                            self.expr_ty_after_adjustments(*expr),\n+                            self.expr_ty(expr_id),\n+                            expr_id.into(),\n+                            'b: {\n+                                if let Some((f, _)) = self.infer.method_resolution(expr_id) {\n+                                    if let Some(deref_trait) =\n+                                        self.resolve_lang_item(LangItem::DerefMut)?.as_trait()\n+                                    {\n+                                        if let Some(deref_fn) = self\n+                                            .db\n+                                            .trait_data(deref_trait)\n+                                            .method_by_name(&name![deref_mut])\n+                                        {\n+                                            break 'b deref_fn == f;\n+                                        }\n+                                    }\n+                                }\n+                                false\n+                            },\n+                        );\n                     }\n                     let Some((mut r, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n                         return Ok(None);\n@@ -171,7 +194,24 @@ impl MirLowerCtx<'_> {\n                 if index_ty != TyBuilder::usize()\n                     || !matches!(base_ty.kind(Interner), TyKind::Array(..) | TyKind::Slice(..))\n                 {\n-                    not_supported!(\"overloaded index\");\n+                    let Some(index_fn) = self.infer.method_resolution(expr_id) else {\n+                        return Err(MirLowerError::UnresolvedMethod);\n+                    };\n+                    let Some((base_place, current)) = self.lower_expr_as_place(current, *base, true)? else {\n+                        return Ok(None);\n+                    };\n+                    let Some((index_operand, current)) = self.lower_expr_to_some_operand(*index, current)? else {\n+                        return Ok(None);\n+                    };\n+                    return self.lower_overloaded_index(\n+                        current,\n+                        base_place,\n+                        self.expr_ty_after_adjustments(*base),\n+                        self.expr_ty(expr_id),\n+                        index_operand,\n+                        expr_id.into(),\n+                        index_fn,\n+                    );\n                 }\n                 let Some((mut p_base, current)) =\n                     self.lower_expr_as_place(current, *base, true)? else {\n@@ -188,6 +228,49 @@ impl MirLowerCtx<'_> {\n         }\n     }\n \n+    fn lower_overloaded_index(\n+        &mut self,\n+        current: BasicBlockId,\n+        place: Place,\n+        base_ty: Ty,\n+        result_ty: Ty,\n+        index_operand: Operand,\n+        span: MirSpan,\n+        index_fn: (FunctionId, Substitution),\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let is_mutable = 'b: {\n+            if let Some(index_mut_trait) = self.resolve_lang_item(LangItem::IndexMut)?.as_trait() {\n+                if let Some(index_mut_fn) =\n+                    self.db.trait_data(index_mut_trait).method_by_name(&name![index_mut])\n+                {\n+                    break 'b index_mut_fn == index_fn.0;\n+                }\n+            }\n+            false\n+        };\n+        let (mutability, borrow_kind) = match is_mutable {\n+            true => (Mutability::Mut, BorrowKind::Mut { allow_two_phase_borrow: false }),\n+            false => (Mutability::Not, BorrowKind::Shared),\n+        };\n+        let base_ref = TyKind::Ref(mutability, static_lifetime(), base_ty).intern(Interner);\n+        let result_ref = TyKind::Ref(mutability, static_lifetime(), result_ty).intern(Interner);\n+        let ref_place: Place = self.temp(base_ref)?.into();\n+        self.push_assignment(current, ref_place.clone(), Rvalue::Ref(borrow_kind, place), span);\n+        let mut result: Place = self.temp(result_ref)?.into();\n+        let index_fn_op = Operand::const_zst(\n+            TyKind::FnDef(\n+                self.db.intern_callable_def(CallableDefId::FunctionId(index_fn.0)).into(),\n+                index_fn.1,\n+            )\n+            .intern(Interner),\n+        );\n+        let Some(current) = self.lower_call(index_fn_op, vec![Operand::Copy(ref_place), index_operand], result.clone(), current, false)? else {\n+            return Ok(None);\n+        };\n+        result.projection.push(ProjectionElem::Deref);\n+        Ok(Some((result, current)))\n+    }\n+\n     fn lower_overloaded_deref(\n         &mut self,\n         current: BasicBlockId,"}, {"sha": "c3ced82aab7bd43f4dc8b144230e69cc20b1fbd6", "filename": "crates/hir-ty/src/mir/lower/pattern_matching.rs", "status": "added", "additions": 399, "deletions": 0, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -0,0 +1,399 @@\n+//! MIR lowering for patterns\n+\n+use super::*;\n+\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirLowerError::NotSupported(format!($x)))\n+    };\n+}\n+\n+pub(super) enum AdtPatternShape<'a> {\n+    Tuple { args: &'a [PatId], ellipsis: Option<usize> },\n+    Record { args: &'a [RecordFieldPat] },\n+    Unit,\n+}\n+\n+impl MirLowerCtx<'_> {\n+    /// It gets a `current` unterminated block, appends some statements and possibly a terminator to it to check if\n+    /// the pattern matches and write bindings, and returns two unterminated blocks, one for the matched path (which\n+    /// can be the `current` block) and one for the mismatched path. If the input pattern is irrefutable, the\n+    /// mismatched path block is `None`.\n+    ///\n+    /// By default, it will create a new block for mismatched path. If you already have one, you can provide it with\n+    /// `current_else` argument to save an unneccessary jump. If `current_else` isn't `None`, the result mismatched path\n+    /// wouldn't be `None` as well. Note that this function will add jumps to the beginning of the `current_else` block,\n+    /// so it should be an empty block.\n+    pub(super) fn pattern_match(\n+        &mut self,\n+        mut current: BasicBlockId,\n+        mut current_else: Option<BasicBlockId>,\n+        mut cond_place: Place,\n+        mut cond_ty: Ty,\n+        pattern: PatId,\n+        mut binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        Ok(match &self.body.pats[pattern] {\n+            Pat::Missing => return Err(MirLowerError::IncompleteExpr),\n+            Pat::Wild => (current, current_else),\n+            Pat::Tuple { args, ellipsis } => {\n+                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+                let subst = match cond_ty.kind(Interner) {\n+                    TyKind::Tuple(_, s) => s,\n+                    _ => {\n+                        return Err(MirLowerError::TypeError(\n+                            \"non tuple type matched with tuple pattern\",\n+                        ))\n+                    }\n+                };\n+                self.pattern_match_tuple_like(\n+                    current,\n+                    current_else,\n+                    args,\n+                    *ellipsis,\n+                    subst.iter(Interner).enumerate().map(|(i, x)| {\n+                        (PlaceElem::TupleField(i), x.assert_ty_ref(Interner).clone())\n+                    }),\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            Pat::Or(pats) => {\n+                let then_target = self.new_basic_block();\n+                let mut finished = false;\n+                for pat in &**pats {\n+                    let (next, next_else) = self.pattern_match(\n+                        current,\n+                        None,\n+                        cond_place.clone(),\n+                        cond_ty.clone(),\n+                        *pat,\n+                        binding_mode,\n+                    )?;\n+                    self.set_goto(next, then_target);\n+                    match next_else {\n+                        Some(t) => {\n+                            current = t;\n+                        }\n+                        None => {\n+                            finished = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+                if !finished {\n+                    let ce = *current_else.get_or_insert_with(|| self.new_basic_block());\n+                    self.set_goto(current, ce);\n+                }\n+                (then_target, current_else)\n+            }\n+            Pat::Record { args, .. } => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    AdtPatternShape::Record { args: &*args },\n+                )?\n+            }\n+            Pat::Range { .. } => not_supported!(\"range pattern\"),\n+            Pat::Slice { .. } => not_supported!(\"slice pattern\"),\n+            Pat::Path(_) => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    AdtPatternShape::Unit,\n+                )?\n+            }\n+            Pat::Lit(l) => match &self.body.exprs[*l] {\n+                Expr::Literal(l) => {\n+                    let c = self.lower_literal_to_operand(cond_ty, l)?;\n+                    self.pattern_match_const(current_else, current, c, cond_place, pattern)?\n+                }\n+                _ => not_supported!(\"expression path literal\"),\n+            },\n+            Pat::Bind { id, subpat } => {\n+                let target_place = self.result.binding_locals[*id];\n+                let mode = self.body.bindings[*id].mode;\n+                if let Some(subpat) = subpat {\n+                    (current, current_else) = self.pattern_match(\n+                        current,\n+                        current_else,\n+                        cond_place.clone(),\n+                        cond_ty,\n+                        *subpat,\n+                        binding_mode,\n+                    )?\n+                }\n+                if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n+                    binding_mode = mode;\n+                }\n+                self.push_storage_live(*id, current);\n+                self.push_assignment(\n+                    current,\n+                    target_place.into(),\n+                    match binding_mode {\n+                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n+                            Operand::Copy(cond_place).into()\n+                        }\n+                        BindingAnnotation::Ref => Rvalue::Ref(BorrowKind::Shared, cond_place),\n+                        BindingAnnotation::RefMut => Rvalue::Ref(\n+                            BorrowKind::Mut { allow_two_phase_borrow: false },\n+                            cond_place,\n+                        ),\n+                    },\n+                    pattern.into(),\n+                );\n+                (current, current_else)\n+            }\n+            Pat::TupleStruct { path: _, args, ellipsis } => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    AdtPatternShape::Tuple { args, ellipsis: *ellipsis },\n+                )?\n+            }\n+            Pat::Ref { pat, mutability: _ } => {\n+                if let Some((ty, _, _)) = cond_ty.as_reference() {\n+                    cond_ty = ty.clone();\n+                    cond_place.projection.push(ProjectionElem::Deref);\n+                    self.pattern_match(\n+                        current,\n+                        current_else,\n+                        cond_place,\n+                        cond_ty,\n+                        *pat,\n+                        binding_mode,\n+                    )?\n+                } else {\n+                    return Err(MirLowerError::TypeError(\"& pattern for non reference\"));\n+                }\n+            }\n+            Pat::Box { .. } => not_supported!(\"box pattern\"),\n+            Pat::ConstBlock(_) => not_supported!(\"const block pattern\"),\n+        })\n+    }\n+\n+    fn pattern_match_const(\n+        &mut self,\n+        current_else: Option<BasicBlockId>,\n+        current: BasicBlockId,\n+        c: Operand,\n+        cond_place: Place,\n+        pattern: Idx<Pat>,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        let then_target = self.new_basic_block();\n+        let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n+        let discr: Place = self.temp(TyBuilder::bool())?.into();\n+        self.push_assignment(\n+            current,\n+            discr.clone(),\n+            Rvalue::CheckedBinaryOp(BinOp::Eq, c, Operand::Copy(cond_place)),\n+            pattern.into(),\n+        );\n+        let discr = Operand::Copy(discr);\n+        self.set_terminator(\n+            current,\n+            Terminator::SwitchInt {\n+                discr,\n+                targets: SwitchTargets::static_if(1, then_target, else_target),\n+            },\n+        );\n+        Ok((then_target, Some(else_target)))\n+    }\n+\n+    pub(super) fn pattern_matching_variant(\n+        &mut self,\n+        mut cond_ty: Ty,\n+        mut binding_mode: BindingAnnotation,\n+        mut cond_place: Place,\n+        variant: VariantId,\n+        current: BasicBlockId,\n+        span: MirSpan,\n+        current_else: Option<BasicBlockId>,\n+        shape: AdtPatternShape<'_>,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+        let subst = match cond_ty.kind(Interner) {\n+            TyKind::Adt(_, s) => s,\n+            _ => return Err(MirLowerError::TypeError(\"non adt type matched with tuple struct\")),\n+        };\n+        Ok(match variant {\n+            VariantId::EnumVariantId(v) => {\n+                let e = self.db.const_eval_discriminant(v)? as u128;\n+                let next = self.new_basic_block();\n+                let tmp = self.discr_temp_place();\n+                self.push_assignment(\n+                    current,\n+                    tmp.clone(),\n+                    Rvalue::Discriminant(cond_place.clone()),\n+                    span,\n+                );\n+                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n+                self.set_terminator(\n+                    current,\n+                    Terminator::SwitchInt {\n+                        discr: Operand::Copy(tmp),\n+                        targets: SwitchTargets::static_if(e, next, else_target),\n+                    },\n+                );\n+                let enum_data = self.db.enum_data(v.parent);\n+                self.pattern_matching_variant_fields(\n+                    shape,\n+                    &enum_data.variants[v.local_id].variant_data,\n+                    variant,\n+                    subst,\n+                    next,\n+                    Some(else_target),\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            VariantId::StructId(s) => {\n+                let struct_data = self.db.struct_data(s);\n+                self.pattern_matching_variant_fields(\n+                    shape,\n+                    &struct_data.variant_data,\n+                    variant,\n+                    subst,\n+                    current,\n+                    current_else,\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            VariantId::UnionId(_) => {\n+                return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n+            }\n+        })\n+    }\n+\n+    fn pattern_matching_variant_fields(\n+        &mut self,\n+        shape: AdtPatternShape<'_>,\n+        variant_data: &VariantData,\n+        v: VariantId,\n+        subst: &Substitution,\n+        current: BasicBlockId,\n+        current_else: Option<BasicBlockId>,\n+        cond_place: &Place,\n+        binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        let fields_type = self.db.field_types(v);\n+        Ok(match shape {\n+            AdtPatternShape::Record { args } => {\n+                let it = args\n+                    .iter()\n+                    .map(|x| {\n+                        let field_id =\n+                            variant_data.field(&x.name).ok_or(MirLowerError::UnresolvedField)?;\n+                        Ok((\n+                            PlaceElem::Field(FieldId { parent: v.into(), local_id: field_id }),\n+                            x.pat,\n+                            fields_type[field_id].clone().substitute(Interner, subst),\n+                        ))\n+                    })\n+                    .collect::<Result<Vec<_>>>()?;\n+                self.pattern_match_adt(\n+                    current,\n+                    current_else,\n+                    it.into_iter(),\n+                    cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            AdtPatternShape::Tuple { args, ellipsis } => {\n+                let fields = variant_data.fields().iter().map(|(x, _)| {\n+                    (\n+                        PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n+                        fields_type[x].clone().substitute(Interner, subst),\n+                    )\n+                });\n+                self.pattern_match_tuple_like(\n+                    current,\n+                    current_else,\n+                    args,\n+                    ellipsis,\n+                    fields,\n+                    cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            AdtPatternShape::Unit => (current, current_else),\n+        })\n+    }\n+\n+    fn pattern_match_adt(\n+        &mut self,\n+        mut current: BasicBlockId,\n+        mut current_else: Option<BasicBlockId>,\n+        args: impl Iterator<Item = (PlaceElem, PatId, Ty)>,\n+        cond_place: &Place,\n+        binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        for (proj, arg, ty) in args {\n+            let mut cond_place = cond_place.clone();\n+            cond_place.projection.push(proj);\n+            (current, current_else) =\n+                self.pattern_match(current, current_else, cond_place, ty, arg, binding_mode)?;\n+        }\n+        Ok((current, current_else))\n+    }\n+\n+    fn pattern_match_tuple_like(\n+        &mut self,\n+        current: BasicBlockId,\n+        current_else: Option<BasicBlockId>,\n+        args: &[PatId],\n+        ellipsis: Option<usize>,\n+        fields: impl DoubleEndedIterator<Item = (PlaceElem, Ty)> + Clone,\n+        cond_place: &Place,\n+        binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        let (al, ar) = args.split_at(ellipsis.unwrap_or(args.len()));\n+        let it = al\n+            .iter()\n+            .zip(fields.clone())\n+            .chain(ar.iter().rev().zip(fields.rev()))\n+            .map(|(x, y)| (y.0, *x, y.1));\n+        self.pattern_match_adt(current, current_else, it, cond_place, binding_mode)\n+    }\n+}\n+\n+fn pattern_matching_dereference(\n+    cond_ty: &mut Ty,\n+    binding_mode: &mut BindingAnnotation,\n+    cond_place: &mut Place,\n+) {\n+    while let Some((ty, _, mu)) = cond_ty.as_reference() {\n+        if mu == Mutability::Mut && *binding_mode != BindingAnnotation::Ref {\n+            *binding_mode = BindingAnnotation::RefMut;\n+        } else {\n+            *binding_mode = BindingAnnotation::Ref;\n+        }\n+        *cond_ty = ty.clone();\n+        cond_place.projection.push(ProjectionElem::Deref);\n+    }\n+}"}, {"sha": "9ec2913dce970560a970f16dcc2b205235dd853c", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -1,6 +1,6 @@\n //! A pretty-printer for MIR.\n \n-use std::fmt::{Display, Write};\n+use std::fmt::{Debug, Display, Write};\n \n use hir_def::{body::Body, expr::BindingId};\n use hir_expand::name::Name;\n@@ -23,6 +23,18 @@ impl MirBody {\n         ctx.for_body();\n         ctx.result\n     }\n+\n+    // String with lines is rendered poorly in `dbg` macros, which I use very much, so this\n+    // function exists to solve that.\n+    pub fn dbg(&self, db: &dyn HirDatabase) -> impl Debug {\n+        struct StringDbg(String);\n+        impl Debug for StringDbg {\n+            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+                f.write_str(&self.0)\n+            }\n+        }\n+        StringDbg(self.pretty_print(db))\n+    }\n }\n \n struct MirPrettyCtx<'a> {\n@@ -77,6 +89,7 @@ impl Display for LocalName {\n \n impl<'a> MirPrettyCtx<'a> {\n     fn for_body(&mut self) {\n+        wln!(self, \"// {:?}\", self.body.owner);\n         self.with_block(|this| {\n             this.locals();\n             wln!(this);\n@@ -300,9 +313,9 @@ impl<'a> MirPrettyCtx<'a> {\n                 w!(self, \")\");\n             }\n             Rvalue::Cast(ck, op, ty) => {\n-                w!(self, \"Discriminant({ck:?}\");\n+                w!(self, \"Cast({ck:?}, \");\n                 self.operand(op);\n-                w!(self, \"{})\", ty.display(self.db));\n+                w!(self, \", {})\", ty.display(self.db));\n             }\n             Rvalue::CheckedBinaryOp(b, o1, o2) => {\n                 self.operand(o1);"}, {"sha": "9f624cc32c0ce25dfa95372833205bf41d99b4d5", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -258,7 +258,6 @@ fn test() {\n \n #[test]\n fn coerce_autoderef_block() {\n-    // FIXME: We should know mutability in overloaded deref\n     check_no_mismatches(\n         r#\"\n //- minicore: deref\n@@ -268,7 +267,7 @@ fn takes_ref_str(x: &str) {}\n fn returns_string() -> String { loop {} }\n fn test() {\n     takes_ref_str(&{ returns_string() });\n-               // ^^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(None), Deref(Some(OverloadedDeref(None))), Borrow(Ref(Not))\n+               // ^^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(None), Deref(Some(OverloadedDeref(Some(Not)))), Borrow(Ref(Not))\n }\n \"#,\n     );\n@@ -396,10 +395,40 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn coerce_fn_item_to_fn_ptr_in_array() {\n+    check_no_mismatches(\n+        r\"\n+fn foo(x: u32) -> isize { 1 }\n+fn bar(x: u32) -> isize { 1 }\n+fn test() {\n+    let f = [foo, bar];\n+          // ^^^ adjustments: Pointer(ReifyFnPointer)\n+}\",\n+    );\n+}\n+\n #[test]\n fn coerce_fn_items_in_match_arms() {\n     cov_mark::check!(coerce_fn_reification);\n \n+    check_no_mismatches(\n+        r\"\n+fn foo1(x: u32) -> isize { 1 }\n+fn foo2(x: u32) -> isize { 2 }\n+fn foo3(x: u32) -> isize { 3 }\n+fn test() {\n+    let x = match 1 {\n+        1 => foo1,\n+          // ^^^^ adjustments: Pointer(ReifyFnPointer)\n+        2 => foo2,\n+          // ^^^^ adjustments: Pointer(ReifyFnPointer)\n+        _ => foo3,\n+          // ^^^^ adjustments: Pointer(ReifyFnPointer)\n+    };\n+    x;\n+}\",\n+    );\n     check_types(\n         r\"\n fn foo1(x: u32) -> isize { 1 }"}, {"sha": "f3ca93672d9fccd6b0488bbc883a1cff4e857146", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -1255,7 +1255,6 @@ fn foo<T: Trait>(a: &T) {\n \n #[test]\n fn autoderef_visibility_field() {\n-    // FIXME: We should know mutability in overloaded deref\n     check(\n         r#\"\n //- minicore: deref\n@@ -1277,7 +1276,7 @@ mod a {\n mod b {\n     fn foo() {\n         let x = super::a::Bar::new().0;\n-             // ^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(Some(OverloadedDeref(None)))\n+             // ^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(Some(OverloadedDeref(Some(Not))))\n              // ^^^^^^^^^^^^^^^^^^^^^^ type: char\n     }\n }"}, {"sha": "8322b9e1ca64ad3c01e6666a078054c9b4fe059c", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -2696,6 +2696,21 @@ fn f() {\n     )\n }\n \n+#[test]\n+fn infer_ref_to_raw_cast() {\n+    check_types(\n+        r#\"\n+struct S;\n+\n+fn f() {\n+    let s = &mut S;\n+    let s = s as *mut _;\n+      //^ *mut S\n+}\n+    \"#,\n+    );\n+}\n+\n #[test]\n fn infer_missing_type() {\n     check_types(\n@@ -3258,25 +3273,6 @@ fn f<T>(t: Ark<T>) {\n     );\n }\n \n-// FIXME\n-#[test]\n-fn castable_to2() {\n-    check_infer(\n-        r#\"\n-fn func() {\n-    let x = &0u32 as *const _;\n-}\n-\"#,\n-        expect![[r#\"\n-            10..44 '{     ...t _; }': ()\n-            20..21 'x': *const {unknown}\n-            24..29 '&0u32': &u32\n-            24..41 '&0u32 ...onst _': *const {unknown}\n-            25..29 '0u32': u32\n-        \"#]],\n-    );\n-}\n-\n #[test]\n fn issue_14275() {\n     // FIXME: evaluate const generic"}, {"sha": "97ec1bb871d4b44067b64d305701e0e6fcbd2a65", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -206,19 +206,27 @@ fn test() {\n fn infer_try_trait() {\n     check_types(\n         r#\"\n-//- minicore: try, result\n+//- minicore: try, result, from\n fn test() {\n     let r: Result<i32, u64> = Result::Ok(1);\n     let v = r?;\n     v;\n } //^ i32\n-\n-impl<O, E> core::ops::Try for Result<O, E> {\n-    type Output = O;\n-    type Error = Result<core::convert::Infallible, E>;\n+\"#,\n+    );\n }\n \n-impl<T, E, F: From<E>> core::ops::FromResidual<Result<core::convert::Infallible, E>> for Result<T, F> {}\n+#[test]\n+fn infer_try_block() {\n+    // FIXME: We should test more cases, but it currently doesn't work, since\n+    // our labeled block type inference is broken.\n+    check_types(\n+        r#\"\n+//- minicore: try, option\n+fn test() {\n+    let x: Option<_> = try { Some(2)?; };\n+      //^ Option<()>\n+}\n \"#,\n     );\n }"}, {"sha": "e7fffc4cc7d74b19218c3f58579da8e73c4c00e5", "filename": "crates/hir-ty/src/traits.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -11,6 +11,7 @@ use hir_def::{\n     lang_item::{LangItem, LangItemTarget},\n     TraitId,\n };\n+use hir_expand::name::{name, Name};\n use stdx::panic_context;\n \n use crate::{\n@@ -187,7 +188,15 @@ impl FnTrait {\n         }\n     }\n \n-    pub fn get_id(&self, db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n+    pub fn method_name(self) -> Name {\n+        match self {\n+            FnTrait::FnOnce => name!(call_once),\n+            FnTrait::FnMut => name!(call_mut),\n+            FnTrait::Fn => name!(call),\n+        }\n+    }\n+\n+    pub fn get_id(self, db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n         let target = db.lang_item(krate, self.lang_item())?;\n         match target {\n             LangItemTarget::Trait(t) => Some(t),"}, {"sha": "a6967414aa8559f2f6b05e734a6cf469ffc12600", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -130,7 +130,7 @@ fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId, cb: impl FnMut(Tra\n             WherePredicate::Lifetime { .. } => None,\n         })\n         .filter(|(_, bound_modifier)| matches!(bound_modifier, TraitBoundModifier::None))\n-        .filter_map(|(path, _)| match resolver.resolve_path_in_type_ns_fully(db, path.mod_path()) {\n+        .filter_map(|(path, _)| match resolver.resolve_path_in_type_ns_fully(db, path) {\n             Some(TypeNs::TraitId(t)) => Some(t),\n             _ => None,\n         })"}, {"sha": "dbf618afa6fedf2691fe309e1a22dd9e4090ed43", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -1801,7 +1801,7 @@ impl Function {\n         let body = db\n             .mir_body(self.id.into())\n             .map_err(|e| MirEvalError::MirLowerError(self.id.into(), e))?;\n-        interpret_mir(db, &body, false)?;\n+        interpret_mir(db, &body, Substitution::empty(Interner), false)?;\n         Ok(())\n     }\n }\n@@ -1947,7 +1947,7 @@ impl Const {\n     }\n \n     pub fn render_eval(self, db: &dyn HirDatabase) -> Result<String, ConstEvalError> {\n-        let c = db.const_eval(self.id)?;\n+        let c = db.const_eval(self.id, Substitution::empty(Interner))?;\n         let r = format!(\"{}\", HexifiedConst(c).display(db));\n         // We want to see things like `<utf8-error>` and `<layout-error>` as they are probably bug in our\n         // implementation, but there is no need to show things like `<enum-not-supported>` or `<ref-not-supported>` to"}, {"sha": "9709970db1eecec2ff308f044e43088fbd9cd682", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -1076,10 +1076,7 @@ impl<'db> SemanticsImpl<'db> {\n         let hygiene = hir_expand::hygiene::Hygiene::new(self.db.upcast(), analyze.file_id);\n         let ctx = body::LowerCtx::with_hygiene(self.db.upcast(), &hygiene);\n         let hir_path = Path::from_src(path.clone(), &ctx)?;\n-        match analyze\n-            .resolver\n-            .resolve_path_in_type_ns_fully(self.db.upcast(), hir_path.mod_path())?\n-        {\n+        match analyze.resolver.resolve_path_in_type_ns_fully(self.db.upcast(), &hir_path)? {\n             TypeNs::TraitId(id) => Some(Trait { id }),\n             _ => None,\n         }"}, {"sha": "5b18e445727f3fac47cfb33bf9e1789aae23aa78", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -420,7 +420,10 @@ impl SourceAnalyzer {\n             None\n         } else {\n             // Shorthand syntax, resolve to the local\n-            let path = ModPath::from_segments(PathKind::Plain, once(local_name.clone()));\n+            let path = Path::from_known_path_with_no_generic(ModPath::from_segments(\n+                PathKind::Plain,\n+                once(local_name.clone()),\n+            ));\n             match self.resolver.resolve_path_in_value_ns_fully(db.upcast(), &path) {\n                 Some(ValueNs::LocalBinding(binding_id)) => {\n                     Some(Local { binding_id, parent: self.resolver.body_owner()? })\n@@ -461,7 +464,7 @@ impl SourceAnalyzer {\n     ) -> Option<Macro> {\n         let ctx = body::LowerCtx::new(db.upcast(), macro_call.file_id);\n         let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &ctx))?;\n-        self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()).map(|it| it.into())\n+        self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()?).map(|it| it.into())\n     }\n \n     pub(crate) fn resolve_bind_pat_to_const(\n@@ -801,15 +804,11 @@ impl SourceAnalyzer {\n         func: FunctionId,\n         substs: Substitution,\n     ) -> FunctionId {\n-        let krate = self.resolver.krate();\n         let owner = match self.resolver.body_owner() {\n             Some(it) => it,\n             None => return func,\n         };\n-        let env = owner.as_generic_def_id().map_or_else(\n-            || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n-            |d| db.trait_environment(d),\n-        );\n+        let env = db.trait_environment_for_body(owner);\n         method_resolution::lookup_impl_method(db, env, func, substs).0\n     }\n \n@@ -819,15 +818,11 @@ impl SourceAnalyzer {\n         const_id: ConstId,\n         subs: Substitution,\n     ) -> ConstId {\n-        let krate = self.resolver.krate();\n         let owner = match self.resolver.body_owner() {\n             Some(it) => it,\n             None => return const_id,\n         };\n-        let env = owner.as_generic_def_id().map_or_else(\n-            || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n-            |d| db.trait_environment(d),\n-        );\n+        let env = db.trait_environment_for_body(owner);\n         method_resolution::lookup_impl_const(db, env, const_id, subs).0\n     }\n \n@@ -946,7 +941,7 @@ pub(crate) fn resolve_hir_path_as_macro(\n     resolver: &Resolver,\n     path: &Path,\n ) -> Option<Macro> {\n-    resolver.resolve_path_as_macro(db.upcast(), path.mod_path()).map(Into::into)\n+    resolver.resolve_path_as_macro(db.upcast(), path.mod_path()?).map(Into::into)\n }\n \n fn resolve_hir_path_(\n@@ -962,8 +957,7 @@ fn resolve_hir_path_(\n                 res.map(|ty_ns| (ty_ns, path.segments().first()))\n             }\n             None => {\n-                let (ty, remaining_idx) =\n-                    resolver.resolve_path_in_type_ns(db.upcast(), path.mod_path())?;\n+                let (ty, remaining_idx) = resolver.resolve_path_in_type_ns(db.upcast(), path)?;\n                 match remaining_idx {\n                     Some(remaining_idx) => {\n                         if remaining_idx + 1 == path.segments().len() {\n@@ -1019,7 +1013,7 @@ fn resolve_hir_path_(\n \n     let body_owner = resolver.body_owner();\n     let values = || {\n-        resolver.resolve_path_in_value_ns_fully(db.upcast(), path.mod_path()).and_then(|val| {\n+        resolver.resolve_path_in_value_ns_fully(db.upcast(), path).and_then(|val| {\n             let res = match val {\n                 ValueNs::LocalBinding(binding_id) => {\n                     let var = Local { parent: body_owner?, binding_id };\n@@ -1039,14 +1033,14 @@ fn resolve_hir_path_(\n \n     let items = || {\n         resolver\n-            .resolve_module_path_in_items(db.upcast(), path.mod_path())\n+            .resolve_module_path_in_items(db.upcast(), path.mod_path()?)\n             .take_types()\n             .map(|it| PathResolution::Def(it.into()))\n     };\n \n     let macros = || {\n         resolver\n-            .resolve_path_as_macro(db.upcast(), path.mod_path())\n+            .resolve_path_as_macro(db.upcast(), path.mod_path()?)\n             .map(|def| PathResolution::Def(ModuleDef::Macro(def.into())))\n     };\n \n@@ -1074,7 +1068,7 @@ fn resolve_hir_path_qualifier(\n     path: &Path,\n ) -> Option<PathResolution> {\n     resolver\n-        .resolve_path_in_type_ns_fully(db.upcast(), path.mod_path())\n+        .resolve_path_in_type_ns_fully(db.upcast(), &path)\n         .map(|ty| match ty {\n             TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n             TypeNs::GenericParam(id) => PathResolution::TypeParam(id.into()),\n@@ -1089,7 +1083,7 @@ fn resolve_hir_path_qualifier(\n         })\n         .or_else(|| {\n             resolver\n-                .resolve_module_path_in_items(db.upcast(), path.mod_path())\n+                .resolve_module_path_in_items(db.upcast(), path.mod_path()?)\n                 .take_types()\n                 .map(|it| PathResolution::Def(it.into()))\n         })"}, {"sha": "2e26f59d030ff6d3da36343f2fe48449fc9ce3b6", "filename": "crates/ide-assists/src/handlers/replace_try_expr_with_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -20,7 +20,7 @@ use crate::assist_context::{AssistContext, Assists};\n // Replaces a `try` expression with a `match` expression.\n //\n // ```\n-// # //- minicore:option\n+// # //- minicore: try, option\n // fn handle() {\n //     let pat = Some(true)$0?;\n // }\n@@ -111,7 +111,7 @@ mod tests {\n         check_assist(\n             replace_try_expr_with_match,\n             r#\"\n-//- minicore:option\n+//- minicore: try, option\n fn test() {\n     let pat = Some(true)$0?;\n }\n@@ -132,7 +132,7 @@ fn test() {\n         check_assist(\n             replace_try_expr_with_match,\n             r#\"\n-//- minicore:result\n+//- minicore: try, from, result\n fn test() {\n     let pat = Ok(true)$0?;\n }"}, {"sha": "aff11367de9a6f96b2829ba4187895ed1a54c646", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -2352,7 +2352,7 @@ fn doctest_replace_try_expr_with_match() {\n     check_doc_test(\n         \"replace_try_expr_with_match\",\n         r#####\"\n-//- minicore:option\n+//- minicore: try, option\n fn handle() {\n     let pat = Some(true)$0?;\n }"}, {"sha": "17a70f5701bc9827837c0695851213cdf5c71551", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 95, "deletions": 9, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -564,32 +564,93 @@ fn f(x: [(i32, u8); 10]) {\n         );\n     }\n \n+    #[test]\n+    fn overloaded_index() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: index\n+use core::ops::{Index, IndexMut};\n+\n+struct Foo;\n+impl Index<usize> for Foo {\n+    type Output = (i32, u8);\n+    fn index(&self, index: usize) -> &(i32, u8) {\n+        &(5, 2)\n+    }\n+}\n+impl IndexMut<usize> for Foo {\n+    fn index_mut(&mut self, index: usize) -> &mut (i32, u8) {\n+        &mut (5, 2)\n+    }\n+}\n+fn f() {\n+    let mut x = Foo;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    let y = &x[2];\n+    let x = Foo;\n+    let y = &mut x[2];\n+               //^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let mut x = &mut Foo;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    let y: &mut (i32, u8) = &mut x[2];\n+    let x = Foo;\n+    let ref mut y = x[7];\n+                  //^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let (ref mut y, _) = x[3];\n+                       //^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    match x[10] {\n+        //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+        (ref y, _) => (),\n+        (_, ref mut y) => (),\n+    }\n+    let mut x = Foo;\n+    let mut i = 5;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    let y = &mut x[i];\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn overloaded_deref() {\n-        // FIXME: check for false negative\n         check_diagnostics(\n             r#\"\n //- minicore: deref_mut\n use core::ops::{Deref, DerefMut};\n \n struct Foo;\n impl Deref for Foo {\n-    type Target = i32;\n-    fn deref(&self) -> &i32 {\n-        &5\n+    type Target = (i32, u8);\n+    fn deref(&self) -> &(i32, u8) {\n+        &(5, 2)\n     }\n }\n impl DerefMut for Foo {\n-    fn deref_mut(&mut self) -> &mut i32 {\n-        &mut 5\n+    fn deref_mut(&mut self) -> &mut (i32, u8) {\n+        &mut (5, 2)\n     }\n }\n fn f() {\n-    let x = Foo;\n+    let mut x = Foo;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n     let y = &*x;\n     let x = Foo;\n-    let mut x = Foo;\n-    let y: &mut i32 = &mut x;\n+    let y = &mut *x;\n+               //^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let x = Foo;\n+    let x = Foo;\n+    let y: &mut (i32, u8) = &mut x;\n+                          //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let ref mut y = *x;\n+                  //^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let (ref mut y, _) = *x;\n+                       //^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    match *x {\n+        //^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+        (ref y, _) => (),\n+        (_, ref mut y) => (),\n+    }\n }\n \"#,\n         );\n@@ -631,6 +692,31 @@ fn f(inp: (Foo, Foo, Foo, Foo)) {\n         );\n     }\n \n+    #[test]\n+    fn fn_traits() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: fn\n+fn fn_ref(mut x: impl Fn(u8) -> u8) -> u8 {\n+        //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    x(2)\n+}\n+fn fn_mut(x: impl FnMut(u8) -> u8) -> u8 {\n+    x(2)\n+  //^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+}\n+fn fn_borrow_mut(mut x: &mut impl FnMut(u8) -> u8) -> u8 {\n+               //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    x(2)\n+}\n+fn fn_once(mut x: impl FnOnce(u8) -> u8) -> u8 {\n+         //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    x(2)\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn respect_allow_unused_mut() {\n         // FIXME: respect"}, {"sha": "fb7b15e05d81f66c4286c4fc3adf34d6bae6de39", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -409,7 +409,6 @@ pub(super) fn definition(\n             }\n             match it.eval(db) {\n                 Ok(()) => Some(\"pass\".into()),\n-                Err(MirEvalError::Panic) => Some(\"fail\".into()),\n                 Err(MirEvalError::MirLowerError(f, e)) => {\n                     let name = &db.function_data(f).name;\n                     Some(format!(\"error: fail to lower {name} due {e:?}\"))"}, {"sha": "70ec915e96745ba35295d86b98436a435df12141", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -5009,7 +5009,7 @@ fn foo() {\n fn hover_try_expr_res() {\n     check_hover_range(\n         r#\"\n-//- minicore:result\n+//- minicore: try, from, result\n struct FooError;\n \n fn foo() -> Result<(), FooError> {\n@@ -5023,7 +5023,7 @@ fn foo() -> Result<(), FooError> {\n     );\n     check_hover_range(\n         r#\"\n-//- minicore:result\n+//- minicore: try, from, result\n struct FooError;\n struct BarError;\n \n@@ -5044,6 +5044,7 @@ fn foo() -> Result<(), FooError> {\n fn hover_try_expr() {\n     check_hover_range(\n         r#\"\n+//- minicore: try\n struct NotResult<T, U>(T, U);\n struct Short;\n struct Looooong;\n@@ -5061,6 +5062,7 @@ fn foo() -> NotResult<(), Looooong> {\n     );\n     check_hover_range(\n         r#\"\n+//- minicore: try\n struct NotResult<T, U>(T, U);\n struct Short;\n struct Looooong;\n@@ -5092,7 +5094,7 @@ fn foo() -> Option<()> {\n \"#,\n         expect![[r#\"\n                 ```rust\n-                <Option<i32> as Try>::Output\n+                i32\n                 ```\"#]],\n     );\n }"}, {"sha": "11e6dc05fa106aa3b82014c270625df3fd4c1ddc", "filename": "crates/ide/src/inlay_hints/chaining.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -435,7 +435,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3415..3423,\n+                                        range: 5805..5813,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -448,7 +448,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3447..3451,\n+                                        range: 5837..5841,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -468,7 +468,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3415..3423,\n+                                        range: 5805..5813,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -481,7 +481,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3447..3451,\n+                                        range: 5837..5841,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -501,7 +501,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3415..3423,\n+                                        range: 5805..5813,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -514,7 +514,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3447..3451,\n+                                        range: 5837..5841,\n                                     },\n                                 ),\n                                 tooltip: \"\","}, {"sha": "5cc3bad04be188023941dad52578928374bbb34a", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -1126,5 +1126,5 @@ fn benchmark_syntax_highlighting_parser() {\n             .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Function))\n             .count()\n     };\n-    assert_eq!(hash, 1608);\n+    assert_eq!(hash, 1170);\n }"}, {"sha": "e1504743bfdb6ee3e4fd39c0c53d8102f5919fb0", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -2,6 +2,7 @@\n //! errors.\n \n use std::{\n+    collections::HashMap,\n     env,\n     time::{SystemTime, UNIX_EPOCH},\n };\n@@ -153,6 +154,10 @@ impl flags::AnalysisStats {\n             self.run_inference(&host, db, &vfs, &funcs, verbosity);\n         }\n \n+        if self.mir_stats {\n+            self.lower_mir(db, &funcs);\n+        }\n+\n         let total_span = analysis_sw.elapsed();\n         eprintln!(\"{:<20} {total_span}\", \"Total:\");\n         report_metric(\"total time\", total_span.time.as_millis() as u64, \"ms\");\n@@ -189,6 +194,24 @@ impl flags::AnalysisStats {\n         Ok(())\n     }\n \n+    fn lower_mir(&self, db: &RootDatabase, funcs: &[Function]) {\n+        let all = funcs.len();\n+        let mut fail = 0;\n+        let mut h: HashMap<String, usize> = HashMap::new();\n+        for f in funcs {\n+            let f = FunctionId::from(*f);\n+            let Err(e) = db.mir_body(f.into()) else {\n+                continue;\n+            };\n+            let es = format!(\"{:?}\", e);\n+            *h.entry(es).or_default() += 1;\n+            fail += 1;\n+        }\n+        let h = h.into_iter().sorted_by_key(|x| x.1).collect::<Vec<_>>();\n+        eprintln!(\"Mir failed reasons: {:#?}\", h);\n+        eprintln!(\"Mir failed bodies: {fail} ({}%)\", fail * 100 / all);\n+    }\n+\n     fn run_inference(\n         &self,\n         host: &AnalysisHost,"}, {"sha": "b085a0a892a50a2c3edf1839491ca158b93c5cf1", "filename": "crates/rust-analyzer/src/cli/flags.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -66,6 +66,8 @@ xflags::xflags! {\n             optional --memory-usage\n             /// Print the total length of all source and macro files (whitespace is not counted).\n             optional --source-stats\n+            /// Print the number of bodies that fail to lower to mir, in addition to failed reasons.\n+            optional --mir-stats\n \n             /// Only analyze items matching this path.\n             optional -o, --only path: String\n@@ -172,6 +174,7 @@ pub struct AnalysisStats {\n     pub parallel: bool,\n     pub memory_usage: bool,\n     pub source_stats: bool,\n+    pub mir_stats: bool,\n     pub only: Option<String>,\n     pub with_deps: bool,\n     pub no_sysroot: bool,"}, {"sha": "1c15a606f957854b0ce41af2f9d610671a27f973", "filename": "crates/syntax/rust.ungram", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Frust.ungram?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -613,7 +613,7 @@ Pat =\n | ConstBlockPat\n \n LiteralPat =\n-  Literal\n+  '-'? Literal\n \n IdentPat =\n   Attr* 'ref'? 'mut'? Name ('@' Pat)?"}, {"sha": "0e84aca5c7d9ab68b31b3e8e4e33831c8188b1a9", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -1375,6 +1375,7 @@ pub struct LiteralPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl LiteralPat {\n+    pub fn minus_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![-]) }\n     pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n }\n "}, {"sha": "77a8363a185c1ba8585de4959e5cbcc27edb1361", "filename": "crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -535,6 +535,7 @@ impl Field {\n                     \"!\" => \"excl\",\n                     \"*\" => \"star\",\n                     \"&\" => \"amp\",\n+                    \"-\" => \"minus\",\n                     \"_\" => \"underscore\",\n                     \".\" => \"dot\",\n                     \"..\" => \"dotdot\","}, {"sha": "118b9ad631bfa0248ef220dcacee30bacf9b3909", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 126, "deletions": 5, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -181,7 +181,7 @@ pub mod convert {\n     }\n     // endregion:as_ref\n     // region:infallible\n-    pub enum Infallibe {}\n+    pub enum Infallible {}\n     // endregion:infallible\n }\n \n@@ -375,16 +375,82 @@ pub mod ops {\n             type Output;\n             extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n         }\n+\n+        mod impls {\n+            use crate::marker::Tuple;\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+            impl<A: Tuple, F: ?Sized> const Fn<A> for &F\n+            where\n+                F: ~const Fn<A>,\n+            {\n+                extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n+                    (**self).call(args)\n+                }\n+            }\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+            impl<A: Tuple, F: ?Sized> const FnMut<A> for &F\n+            where\n+                F: ~const Fn<A>,\n+            {\n+                extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+                    (**self).call(args)\n+                }\n+            }\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+            impl<A: Tuple, F: ?Sized> const FnOnce<A> for &F\n+            where\n+                F: ~const Fn<A>,\n+            {\n+                type Output = F::Output;\n+\n+                extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+                    (*self).call(args)\n+                }\n+            }\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+            impl<A: Tuple, F: ?Sized> const FnMut<A> for &mut F\n+            where\n+                F: ~const FnMut<A>,\n+            {\n+                extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+                    (*self).call_mut(args)\n+                }\n+            }\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+            impl<A: Tuple, F: ?Sized> const FnOnce<A> for &mut F\n+            where\n+                F: ~const FnMut<A>,\n+            {\n+                type Output = F::Output;\n+                extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+                    (*self).call_mut(args)\n+                }\n+            }\n+        }\n     }\n     pub use self::function::{Fn, FnMut, FnOnce};\n     // endregion:fn\n     // region:try\n     mod try_ {\n+        use super::super::convert::Infallible;\n+\n         pub enum ControlFlow<B, C = ()> {\n+            #[lang = \"Continue\"]\n             Continue(C),\n+            #[lang = \"Break\"]\n             Break(B),\n         }\n-        pub trait FromResidual<R = Self::Residual> {\n+        pub trait FromResidual<R = <Self as Try>::Residual> {\n             #[lang = \"from_residual\"]\n             fn from_residual(residual: R) -> Self;\n         }\n@@ -400,14 +466,66 @@ pub mod ops {\n \n         impl<B, C> Try for ControlFlow<B, C> {\n             type Output = C;\n-            type Residual = ControlFlow<B, convert::Infallible>;\n+            type Residual = ControlFlow<B, Infallible>;\n             fn from_output(output: Self::Output) -> Self {}\n             fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {}\n         }\n \n         impl<B, C> FromResidual for ControlFlow<B, C> {\n-            fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {}\n+            fn from_residual(residual: ControlFlow<B, Infallible>) -> Self {}\n+        }\n+        // region:option\n+        impl<T> Try for Option<T> {\n+            type Output = T;\n+            type Residual = Option<Infallible>;\n+            fn from_output(output: Self::Output) -> Self {\n+                Some(output)\n+            }\n+            fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+                match self {\n+                    Some(x) => ControlFlow::Continue(x),\n+                    None => ControlFlow::Break(None),\n+                }\n+            }\n+        }\n+\n+        impl<T> FromResidual for Option<T> {\n+            fn from_residual(x: Option<Infallible>) -> Self {\n+                match x {\n+                    None => None,\n+                }\n+            }\n+        }\n+        // endregion:option\n+        // region:result\n+        // region:from\n+        use super::super::convert::From;\n+\n+        impl<T, E> Try for Result<T, E> {\n+            type Output = T;\n+            type Residual = Result<Infallible, E>;\n+\n+            fn from_output(output: Self::Output) -> Self {\n+                Ok(output)\n+            }\n+\n+            fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+                match self {\n+                    Ok(v) => ControlFlow::Continue(v),\n+                    Err(e) => ControlFlow::Break(Err(e)),\n+                }\n+            }\n         }\n+\n+        impl<T, E, F: From<E>> FromResidual<Result<Infallible, E>> for Result<T, F> {\n+            fn from_residual(residual: Result<Infallible, E>) -> Self {\n+                match residual {\n+                    Err(e) => Err(From::from(e)),\n+                }\n+            }\n+        }\n+        // endregion:from\n+        // endregion:result\n     }\n     pub use self::try_::{ControlFlow, FromResidual, Try};\n     // endregion:try\n@@ -541,7 +659,10 @@ pub mod option {\n             loop {}\n         }\n         pub fn unwrap_or(self, default: T) -> T {\n-            loop {}\n+            match self {\n+                Some(val) => val,\n+                None => default,\n+            }\n         }\n         // region:fn\n         pub fn and_then<U, F>(self, f: F) -> Option<U>"}, {"sha": "f6597efd8fd279363e9090d8e035b74931149ce8", "filename": "lib/la-arena/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3321799e8fac622db50fe8c3284062f7d0f1bf53/lib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3321799e8fac622db50fe8c3284062f7d0f1bf53/lib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Flib.rs?ref=3321799e8fac622db50fe8c3284062f7d0f1bf53", "patch": "@@ -295,7 +295,7 @@ impl<T> Arena<T> {\n     /// ```\n     pub fn iter(\n         &self,\n-    ) -> impl Iterator<Item = (Idx<T>, &T)> + ExactSizeIterator + DoubleEndedIterator {\n+    ) -> impl Iterator<Item = (Idx<T>, &T)> + ExactSizeIterator + DoubleEndedIterator + Clone {\n         self.data.iter().enumerate().map(|(idx, value)| (Idx::from_raw(RawIdx(idx as u32)), value))\n     }\n "}]}