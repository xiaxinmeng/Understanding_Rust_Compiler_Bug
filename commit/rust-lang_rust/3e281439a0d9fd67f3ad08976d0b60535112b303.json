{"sha": "3e281439a0d9fd67f3ad08976d0b60535112b303", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMjgxNDM5YTBkOWZkNjdmM2FkMDg5NzZkMGI2MDUzNTExMmIzMDM=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-19T02:32:00Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-19T23:35:26Z"}, "message": "Union-find `rank` optimization for infer.\n\nMakes deep-vector2 not run out of stack when suffix inference is\nenabled.", "tree": {"sha": "ce68799a932af7decd770d85619f72c3b4dffd6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce68799a932af7decd770d85619f72c3b4dffd6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e281439a0d9fd67f3ad08976d0b60535112b303", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e281439a0d9fd67f3ad08976d0b60535112b303", "html_url": "https://github.com/rust-lang/rust/commit/3e281439a0d9fd67f3ad08976d0b60535112b303", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e281439a0d9fd67f3ad08976d0b60535112b303/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "906169d608c51b032666e05fff4d870968abe9d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/906169d608c51b032666e05fff4d870968abe9d4", "html_url": "https://github.com/rust-lang/rust/commit/906169d608c51b032666e05fff4d870968abe9d4"}], "stats": {"total": 101, "additions": 78, "deletions": 23}, "files": [{"sha": "7624f4f928c3ce912cdc177e498d334f40a625b8", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 78, "deletions": 23, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3e281439a0d9fd67f3ad08976d0b60535112b303/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e281439a0d9fd67f3ad08976d0b60535112b303/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=3e281439a0d9fd67f3ad08976d0b60535112b303", "patch": "@@ -267,7 +267,7 @@ type bounds<T:copy> = {lb: bound<T>, ub: bound<T>};\n \n enum var_value<V:copy, T:copy> {\n     redirect(V),\n-    root(T)\n+    root(T, uint),\n }\n \n type vals_and_bindings<V:copy, T:copy> = {\n@@ -278,6 +278,7 @@ type vals_and_bindings<V:copy, T:copy> = {\n enum node<V:copy, T:copy> = {\n     root: V,\n     possible_types: T,\n+    rank: uint,\n };\n \n enum infer_ctxt = @{\n@@ -475,7 +476,8 @@ impl<V:copy vid, T:copy to_str> of to_str for var_value<V,T> {\n     fn to_str(cx: infer_ctxt) -> str {\n         alt self {\n           redirect(vid) { #fmt(\"redirect(%s)\", vid.to_str()) }\n-          root(pt) { #fmt(\"root(%s)\", pt.to_str(cx)) }\n+          root(pt, rk) { #fmt(\"root(%s, %s)\", pt.to_str(cx),\n+                              uint::to_str(rk, 10u)) }\n         }\n     }\n }\n@@ -578,7 +580,7 @@ impl methods for infer_ctxt {\n         let id = *self.ty_var_counter;\n         *self.ty_var_counter += 1u;\n         self.tvb.vals.insert(id,\n-                             root({lb: none, ub: none}));\n+                             root({lb: none, ub: none}, 0u));\n         ret tv_vid(id);\n     }\n \n@@ -595,7 +597,7 @@ impl methods for infer_ctxt {\n         *self.ty_var_integral_counter += 1u;\n \n         self.tvib.vals.insert(id,\n-                              root(int_ty_set_all()));\n+                              root(int_ty_set_all(), 0u));\n         ret tvi_vid(id);\n     }\n \n@@ -607,7 +609,7 @@ impl methods for infer_ctxt {\n         let id = *self.region_var_counter;\n         *self.region_var_counter += 1u;\n         self.rb.vals.insert(id,\n-                            root({lb: none, ub: none}));\n+                            root({lb: none, ub: none}, 0u));\n         ret region_vid(id);\n     }\n \n@@ -661,8 +663,8 @@ impl unify_methods for infer_ctxt {\n                 }\n                 nde\n               }\n-              root(pt) {\n-                node({root: vid, possible_types: pt})\n+              root(pt, rk) {\n+                node({root: vid, possible_types: pt, rank: rk})\n               }\n             }\n           }\n@@ -722,9 +724,10 @@ impl unify_methods for infer_ctxt {\n     //    a.lb <: c.lb\n     //    b.lb <: c.lb\n     // If this cannot be achieved, the result is failure.\n+\n     fn set_var_to_merged_bounds<V:copy vid, T:copy to_str st>(\n         vb: vals_and_bindings<V, bounds<T>>,\n-        v_id: V, a: bounds<T>, b: bounds<T>) -> ures {\n+        v_id: V, a: bounds<T>, b: bounds<T>, rank: uint) -> ures {\n \n         // Think of the two diamonds, we want to find the\n         // intersection.  There are basically four possibilities (you\n@@ -765,7 +768,7 @@ impl unify_methods for infer_ctxt {\n             // the new bounds must themselves\n             // be relatable:\n             self.bnds(bnds.lb, bnds.ub).then {||\n-                self.set(vb, v_id, root(bnds));\n+                self.set(vb, v_id, root(bnds, rank));\n                 uok()\n         }\n         }}}}}\n@@ -802,15 +805,42 @@ impl unify_methods for infer_ctxt {\n           _ { /*fallthrough*/ }\n         }\n \n-        // For max perf, we should consider the rank here.  But for now,\n-        // we always make b redirect to a.\n-        self.set(vb, b_id, redirect(a_id));\n-\n         // Otherwise, we need to merge A and B so as to guarantee that\n         // A remains a subtype of B.  Actually, there are other options,\n         // but that's the route we choose to take.\n-        self.set_var_to_merged_bounds(vb, a_id, a_bounds, b_bounds).then {||\n-            uok()\n+\n+        // Rank optimization\n+\n+        // Make the node with greater rank the parent of the node with\n+        // smaller rank.\n+        if nde_a.rank > nde_b.rank {\n+            #debug[\"vars(): a has smaller rank\"];\n+            // a has greater rank, so a should become b's parent,\n+            // i.e., b should redirect to a.\n+            self.set(vb, b_id, redirect(a_id));\n+            self.set_var_to_merged_bounds(\n+                vb, a_id, a_bounds, b_bounds, nde_a.rank).then {||\n+                uok()\n+            }\n+        } else if nde_a.rank < nde_b.rank {\n+            #debug[\"vars(): b has smaller rank\"];\n+            // b has geater rank, so a should redirect to b.\n+            self.set(vb, a_id, redirect(b_id));\n+            self.set_var_to_merged_bounds(\n+                vb, b_id, a_bounds, b_bounds, nde_b.rank).then {||\n+                uok()\n+            }\n+        } else {\n+            #debug[\"vars(): a and b have equal rank\"];\n+            assert nde_a.rank == nde_b.rank;\n+            // If equal, just redirect one to the other and increment\n+            // the other's rank.  We choose arbitrarily to redirect b\n+            // to a and increment a's rank.\n+            self.set(vb, b_id, redirect(a_id));\n+            self.set_var_to_merged_bounds(\n+                vb, a_id, a_bounds, b_bounds, nde_a.rank + 1u).then {||\n+                uok()\n+            }\n         }\n     }\n \n@@ -835,8 +865,29 @@ impl unify_methods for infer_ctxt {\n         if *intersection == INT_TY_SET_EMPTY {\n             ret err(ty::terr_no_integral_type);\n         }\n-        self.set(vb, a_id, root(intersection));\n-        self.set(vb, b_id, redirect(a_id));\n+\n+        // Rank optimization\n+        if nde_a.rank > nde_b.rank {\n+            #debug[\"vars_integral(): a has smaller rank\"];\n+            // a has greater rank, so a should become b's parent,\n+            // i.e., b should redirect to a.\n+            self.set(vb, a_id, root(intersection, nde_a.rank));\n+            self.set(vb, b_id, redirect(a_id));\n+        } else if nde_a.rank < nde_b.rank {\n+            #debug[\"vars_integral(): b has smaller rank\"];\n+            // b has greater rank, so a should redirect to b.\n+            self.set(vb, b_id, root(intersection, nde_b.rank));\n+            self.set(vb, a_id, redirect(b_id));\n+        } else {\n+            #debug[\"vars_integral(): a and b have equal rank\"];\n+            assert nde_a.rank == nde_b.rank;\n+            // If equal, just redirect one to the other and increment\n+            // the other's rank.  We choose arbitrarily to redirect b\n+            // to a and increment a's rank.\n+            self.set(vb, a_id, root(intersection, nde_a.rank + 1u));\n+            self.set(vb, b_id, redirect(a_id));\n+        };\n+\n         uok()\n     }\n \n@@ -852,7 +903,8 @@ impl unify_methods for infer_ctxt {\n                a_id.to_str(), a_bounds.to_str(self),\n                b.to_str(self)];\n         let b_bounds = {lb: none, ub: some(b)};\n-        self.set_var_to_merged_bounds(vb, a_id, a_bounds, b_bounds)\n+        self.set_var_to_merged_bounds(vb, a_id, a_bounds, b_bounds,\n+                                      nde_a.rank)\n     }\n \n     fn vart_integral<V: copy vid>(\n@@ -871,7 +923,7 @@ impl unify_methods for infer_ctxt {\n         if *intersection == INT_TY_SET_EMPTY {\n             ret err(ty::terr_no_integral_type);\n         }\n-        self.set(vb, a_id, root(intersection));\n+        self.set(vb, a_id, root(intersection, nde_a.rank));\n         uok()\n     }\n \n@@ -887,7 +939,8 @@ impl unify_methods for infer_ctxt {\n         #debug[\"tvar(%s <: %s=%s)\",\n                a.to_str(self),\n                b_id.to_str(), b_bounds.to_str(self)];\n-        self.set_var_to_merged_bounds(vb, b_id, a_bounds, b_bounds)\n+        self.set_var_to_merged_bounds(vb, b_id, a_bounds, b_bounds,\n+                                      nde_b.rank)\n     }\n \n     fn tvar_integral<V: copy vid>(\n@@ -906,7 +959,7 @@ impl unify_methods for infer_ctxt {\n         if *intersection == INT_TY_SET_EMPTY {\n             ret err(ty::terr_no_integral_type);\n         }\n-        self.set(vb, b_id, root(intersection));\n+        self.set(vb, b_id, root(intersection, nde_b.rank));\n         uok()\n     }\n \n@@ -1197,7 +1250,8 @@ impl methods for resolve_state {\n                 self.infcx.set(\n                     self.infcx.tvib, vid,\n                     root(convert_integral_ty_to_int_ty_set(self.infcx.tcx,\n-                                                           ty)));\n+                                                           ty),\n+                        nde.rank));\n                 ty\n               }\n               force_none {\n@@ -2564,7 +2618,8 @@ fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n         #debug[\"bnd=none\"];\n         let a_bounds = self.with_bnd(a_bounds, b);\n         self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n-            self.infcx().set(vb, a_id, root(a_bounds));\n+            self.infcx().set(vb, a_id, root(a_bounds,\n+                                            nde_a.rank));\n             ok(b)\n         }\n       }"}]}