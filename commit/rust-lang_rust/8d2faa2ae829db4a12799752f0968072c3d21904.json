{"sha": "8d2faa2ae829db4a12799752f0968072c3d21904", "node_id": "C_kwDOAAsO6NoAKDhkMmZhYTJhZTgyOWRiNGExMjc5OTc1MmYwOTY4MDcyYzNkMjE5MDQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-09-27T19:42:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-27T19:42:22Z"}, "message": "Rollup merge of #102281 - RalfJung:invalid-enums, r=cjgillot\n\nmake invalid_value lint a bit smarter around enums\n\nFixes https://github.com/rust-lang/rust/issues/102043", "tree": {"sha": "51bc4f7b24be50de7957098416f8dc52c41522d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51bc4f7b24be50de7957098416f8dc52c41522d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d2faa2ae829db4a12799752f0968072c3d21904", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjM1IeCRBK7hj4Ov3rIwAAhdQIAHO3jzp4kXg55duMVEjTVYWO\n/wWVT4Wv8kn7QMt9OfS9vtdQBqXpLwMHJzlT866NHjYZp2kPxJFxGmwuXXOBaSJm\nV4cw0ibkgD+ZZxht08nmCvbUDzqQXoxEiHC3umZamfTui0JW31c8D1C4JoOiKk1K\nMwSn4gOmrSE5YfTjXkkDROnAY0+U4JMEj+Vd9gs5/jEDrxQZ7XL4hhqkeZ8zBzAc\ntX+BFJAk6SWnTcuAxlJygprRRUL5k2veQZvKPgsyg8RJEoh7/Vh2jaNWmITdy9rb\nVFxmYzteXcywPMhbJV6vJhga9++6VF8/+40O0N5hGkbPygAOfWJHxmXuddj8mLk=\n=G7EU\n-----END PGP SIGNATURE-----\n", "payload": "tree 51bc4f7b24be50de7957098416f8dc52c41522d9\nparent 4cef648c1ee90f064e3fdd7d5e0e30e283c6993c\nparent 67fd09d3b833d2ede9aeef10c1f05cff68aac225\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1664307742 +0200\ncommitter GitHub <noreply@github.com> 1664307742 +0200\n\nRollup merge of #102281 - RalfJung:invalid-enums, r=cjgillot\n\nmake invalid_value lint a bit smarter around enums\n\nFixes https://github.com/rust-lang/rust/issues/102043\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d2faa2ae829db4a12799752f0968072c3d21904", "html_url": "https://github.com/rust-lang/rust/commit/8d2faa2ae829db4a12799752f0968072c3d21904", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d2faa2ae829db4a12799752f0968072c3d21904/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cef648c1ee90f064e3fdd7d5e0e30e283c6993c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cef648c1ee90f064e3fdd7d5e0e30e283c6993c", "html_url": "https://github.com/rust-lang/rust/commit/4cef648c1ee90f064e3fdd7d5e0e30e283c6993c"}, {"sha": "67fd09d3b833d2ede9aeef10c1f05cff68aac225", "url": "https://api.github.com/repos/rust-lang/rust/commits/67fd09d3b833d2ede9aeef10c1f05cff68aac225", "html_url": "https://github.com/rust-lang/rust/commit/67fd09d3b833d2ede9aeef10c1f05cff68aac225"}], "stats": {"total": 506, "additions": 343, "deletions": 163}, "files": [{"sha": "146c4971348ea411dac25ee0bfdd9111f120c859", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 117, "deletions": 51, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/8d2faa2ae829db4a12799752f0968072c3d21904/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2faa2ae829db4a12799752f0968072c3d21904/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=8d2faa2ae829db4a12799752f0968072c3d21904", "patch": "@@ -46,8 +46,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::Instance;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Instance, Ty, TyCtxt, VariantDef};\n use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n@@ -2425,12 +2424,63 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             None\n         }\n \n-        /// Test if this enum has several actually \"existing\" variants.\n-        /// Zero-sized uninhabited variants do not always have a tag assigned and thus do not \"exist\".\n-        fn is_multi_variant<'tcx>(adt: ty::AdtDef<'tcx>) -> bool {\n-            // As an approximation, we only count dataless variants. Those are definitely inhabited.\n-            let existing_variants = adt.variants().iter().filter(|v| v.fields.is_empty()).count();\n-            existing_variants > 1\n+        /// Determines whether the given type is inhabited. `None` means that we don't know.\n+        fn ty_inhabited<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n+            use rustc_type_ir::sty::TyKind::*;\n+            if !cx.tcx.type_uninhabited_from(cx.param_env.and(ty)).is_empty() {\n+                // This is definitely uninhabited from some module.\n+                return Some(false);\n+            }\n+            match ty.kind() {\n+                Never => Some(false),\n+                Int(_) | Uint(_) | Float(_) | Bool | Char | RawPtr(_) => Some(true),\n+                // Fallback for more complicated types. (Note that `&!` might be considered\n+                // uninhabited so references are \"complicated\", too.)\n+                _ => None,\n+            }\n+        }\n+        /// Determines whether a product type formed from a list of types is inhabited.\n+        fn tys_inhabited<'tcx>(\n+            cx: &LateContext<'tcx>,\n+            tys: impl Iterator<Item = Ty<'tcx>>,\n+        ) -> Option<bool> {\n+            let mut definitely_inhabited = true; // with no fields, we are definitely inhabited.\n+            for ty in tys {\n+                match ty_inhabited(cx, ty) {\n+                    // If any type is uninhabited, the product is uninhabited.\n+                    Some(false) => return Some(false),\n+                    // Otherwise go searching for a `None`.\n+                    None => {\n+                        // We don't know.\n+                        definitely_inhabited = false;\n+                    }\n+                    Some(true) => {}\n+                }\n+            }\n+            if definitely_inhabited { Some(true) } else { None }\n+        }\n+\n+        fn variant_find_init_error<'tcx>(\n+            cx: &LateContext<'tcx>,\n+            variant: &VariantDef,\n+            substs: ty::SubstsRef<'tcx>,\n+            descr: &str,\n+            init: InitKind,\n+        ) -> Option<InitError> {\n+            variant.fields.iter().find_map(|field| {\n+                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(|(mut msg, span)| {\n+                    if span.is_none() {\n+                        // Point to this field, should be helpful for figuring\n+                        // out where the source of the error is.\n+                        let span = cx.tcx.def_span(field.did);\n+                        write!(&mut msg, \" (in this {descr})\").unwrap();\n+                        (msg, Some(span))\n+                    } else {\n+                        // Just forward.\n+                        (msg, span)\n+                    }\n+                })\n+            })\n         }\n \n         /// Return `Some` only if we are sure this type does *not*\n@@ -2468,14 +2518,15 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 RawPtr(_) if init == InitKind::Uninit => {\n                     Some((\"raw pointers must not be uninitialized\".to_string(), None))\n                 }\n-                // Recurse and checks for some compound types.\n+                // Recurse and checks for some compound types. (but not unions)\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n                     // First check if this ADT has a layout attribute (like `NonNull` and friends).\n                     use std::ops::Bound;\n                     match cx.tcx.layout_scalar_valid_range(adt_def.did()) {\n                         // We exploit here that `layout_scalar_valid_range` will never\n                         // return `Bound::Excluded`.  (And we have tests checking that we\n                         // handle the attribute correctly.)\n+                        // We don't add a span since users cannot declare such types anyway.\n                         (Bound::Included(lo), _) if lo > 0 => {\n                             return Some((format!(\"`{}` must be non-null\", ty), None));\n                         }\n@@ -2492,50 +2543,65 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         }\n                         _ => {}\n                     }\n-                    // Now, recurse.\n-                    match adt_def.variants().len() {\n-                        0 => Some((\"enums with no variants have no valid value\".to_string(), None)),\n-                        1 => {\n-                            // Struct, or enum with exactly one variant.\n-                            // Proceed recursively, check all fields.\n-                            let variant = &adt_def.variant(VariantIdx::from_u32(0));\n-                            variant.fields.iter().find_map(|field| {\n-                                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(\n-                                    |(mut msg, span)| {\n-                                        if span.is_none() {\n-                                            // Point to this field, should be helpful for figuring\n-                                            // out where the source of the error is.\n-                                            let span = cx.tcx.def_span(field.did);\n-                                            write!(\n-                                                &mut msg,\n-                                                \" (in this {} field)\",\n-                                                adt_def.descr()\n-                                            )\n-                                            .unwrap();\n-                                            (msg, Some(span))\n-                                        } else {\n-                                            // Just forward.\n-                                            (msg, span)\n-                                        }\n-                                    },\n-                                )\n-                            })\n-                        }\n-                        // Multi-variant enum.\n-                        _ => {\n-                            if init == InitKind::Uninit && is_multi_variant(*adt_def) {\n-                                let span = cx.tcx.def_span(adt_def.did());\n-                                Some((\n-                                    \"enums have to be initialized to a variant\".to_string(),\n-                                    Some(span),\n-                                ))\n-                            } else {\n-                                // In principle, for zero-initialization we could figure out which variant corresponds\n-                                // to tag 0, and check that... but for now we just accept all zero-initializations.\n-                                None\n-                            }\n+                    // Handle structs.\n+                    if adt_def.is_struct() {\n+                        return variant_find_init_error(\n+                            cx,\n+                            adt_def.non_enum_variant(),\n+                            substs,\n+                            \"struct field\",\n+                            init,\n+                        );\n+                    }\n+                    // And now, enums.\n+                    let span = cx.tcx.def_span(adt_def.did());\n+                    let mut potential_variants = adt_def.variants().iter().filter_map(|variant| {\n+                        let inhabited = tys_inhabited(\n+                            cx,\n+                            variant.fields.iter().map(|field| field.ty(cx.tcx, substs)),\n+                        );\n+                        let definitely_inhabited = match inhabited {\n+                            // Entirely skip uninhbaited variants.\n+                            Some(false) => return None,\n+                            // Forward the others, but remember which ones are definitely inhabited.\n+                            Some(true) => true,\n+                            None => false,\n+                        };\n+                        Some((variant, definitely_inhabited))\n+                    });\n+                    let Some(first_variant) = potential_variants.next() else {\n+                        return Some((\"enums with no inhabited variants have no valid value\".to_string(), Some(span)));\n+                    };\n+                    // So we have at least one potentially inhabited variant. Might we have two?\n+                    let Some(second_variant) = potential_variants.next() else {\n+                        // There is only one potentially inhabited variant. So we can recursively check that variant!\n+                        return variant_find_init_error(\n+                            cx,\n+                            &first_variant.0,\n+                            substs,\n+                            \"field of the only potentially inhabited enum variant\",\n+                            init,\n+                        );\n+                    };\n+                    // So we have at least two potentially inhabited variants.\n+                    // If we can prove that we have at least two *definitely* inhabited variants,\n+                    // then we have a tag and hence leaving this uninit is definitely disallowed.\n+                    // (Leaving it zeroed could be okay, depending on which variant is encoded as zero tag.)\n+                    if init == InitKind::Uninit {\n+                        let definitely_inhabited = (first_variant.1 as usize)\n+                            + (second_variant.1 as usize)\n+                            + potential_variants\n+                                .filter(|(_variant, definitely_inhabited)| *definitely_inhabited)\n+                                .count();\n+                        if definitely_inhabited > 1 {\n+                            return Some((\n+                                \"enums with multiple inhabited variants have to be initialized to a variant\".to_string(),\n+                                Some(span),\n+                            ));\n                         }\n                     }\n+                    // We couldn't find anything wrong here.\n+                    None\n                 }\n                 Tuple(..) => {\n                     // Proceed recursively, check all fields."}, {"sha": "80395e32db0caa8ff2217b843e075245c107e422", "filename": "src/test/ui/consts/const-eval/ub-enum.32bit.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr?ref=8d2faa2ae829db4a12799752f0968072c3d21904", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:23:1\n+  --> $DIR/ub-enum.rs:24:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000001, but expected a valid enum tag\n@@ -10,7 +10,7 @@ LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:26:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -22,7 +22,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:31:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -33,7 +33,7 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:43:1\n+  --> $DIR/ub-enum.rs:44:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n@@ -44,7 +44,7 @@ LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:45:1\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -55,7 +55,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:49:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -66,13 +66,13 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:59:42\n+  --> $DIR/ub-enum.rs:60:42\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:64:1\n+  --> $DIR/ub-enum.rs:65:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -83,7 +83,7 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:82:1\n+  --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n@@ -94,7 +94,7 @@ LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:84:1\n+  --> $DIR/ub-enum.rs:85:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n@@ -105,7 +105,7 @@ LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:92:1\n+  --> $DIR/ub-enum.rs:93:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n@@ -116,13 +116,13 @@ LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::tran\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:97:77\n+  --> $DIR/ub-enum.rs:98:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:99:77\n+  --> $DIR/ub-enum.rs:100:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n@@ -132,7 +132,7 @@ error: aborting due to 13 previous errors\n For more information about this error, try `rustc --explain E0080`.\n Future incompatibility report: Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:26:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -145,7 +145,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:31:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -158,7 +158,7 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:45:1\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -171,7 +171,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:49:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -184,7 +184,7 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:64:1\n+  --> $DIR/ub-enum.rs:65:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes"}, {"sha": "d20f63a7289947f3ffc95f9e05041c85f7e31c9c", "filename": "src/test/ui/consts/const-eval/ub-enum.64bit.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr?ref=8d2faa2ae829db4a12799752f0968072c3d21904", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:23:1\n+  --> $DIR/ub-enum.rs:24:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000001, but expected a valid enum tag\n@@ -10,7 +10,7 @@ LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:26:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -22,7 +22,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:31:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -33,7 +33,7 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:43:1\n+  --> $DIR/ub-enum.rs:44:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n@@ -44,7 +44,7 @@ LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:45:1\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -55,7 +55,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:49:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -66,13 +66,13 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:59:42\n+  --> $DIR/ub-enum.rs:60:42\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:64:1\n+  --> $DIR/ub-enum.rs:65:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -83,7 +83,7 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:82:1\n+  --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n@@ -94,7 +94,7 @@ LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:84:1\n+  --> $DIR/ub-enum.rs:85:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n@@ -105,7 +105,7 @@ LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:92:1\n+  --> $DIR/ub-enum.rs:93:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n@@ -116,13 +116,13 @@ LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::tran\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:97:77\n+  --> $DIR/ub-enum.rs:98:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:99:77\n+  --> $DIR/ub-enum.rs:100:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n@@ -132,7 +132,7 @@ error: aborting due to 13 previous errors\n For more information about this error, try `rustc --explain E0080`.\n Future incompatibility report: Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:26:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -145,7 +145,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:31:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -158,7 +158,7 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:45:1\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -171,7 +171,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:49:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -184,7 +184,7 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:64:1\n+  --> $DIR/ub-enum.rs:65:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes"}, {"sha": "9e1c28e2351a81322880d355812db2ff4e94852c", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=8d2faa2ae829db4a12799752f0968072c3d21904", "patch": "@@ -1,5 +1,6 @@\n // stderr-per-bitwidth\n #![feature(never_type)]\n+#![allow(invalid_value)]\n \n use std::mem;\n "}, {"sha": "b568518b4499dae0a7a6fc6f6fc00c9e774d6ca7", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=8d2faa2ae829db4a12799752f0968072c3d21904", "patch": "@@ -40,11 +40,11 @@ LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: enums with no variants have no valid value (in this struct field)\n-  --> $DIR/validate_uninhabited_zsts.rs:16:22\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/validate_uninhabited_zsts.rs:13:5\n    |\n-LL |     pub struct Empty(Void);\n-   |                      ^^^^\n+LL |     enum Void {}\n+   |     ^^^^^^^^^\n \n error: aborting due to 2 previous errors; 2 warnings emitted\n "}, {"sha": "b568518b4499dae0a7a6fc6f6fc00c9e774d6ca7", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.64bit.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr?ref=8d2faa2ae829db4a12799752f0968072c3d21904", "patch": "@@ -40,11 +40,11 @@ LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: enums with no variants have no valid value (in this struct field)\n-  --> $DIR/validate_uninhabited_zsts.rs:16:22\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/validate_uninhabited_zsts.rs:13:5\n    |\n-LL |     pub struct Empty(Void);\n-   |                      ^^^^\n+LL |     enum Void {}\n+   |     ^^^^^^^^^\n \n error: aborting due to 2 previous errors; 2 warnings emitted\n "}, {"sha": "51edb2b7baf598fbe306991ef6240b41331d5a44", "filename": "src/test/ui/lint/invalid_value.rs", "status": "renamed", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs?ref=8d2faa2ae829db4a12799752f0968072c3d21904", "patch": "@@ -34,6 +34,16 @@ enum OneFruit {\n     Banana,\n }\n \n+enum OneFruitNonZero {\n+    Apple(!),\n+    Banana(NonZeroU32),\n+}\n+\n+enum TwoUninhabited {\n+    A(!),\n+    B(Void),\n+}\n+\n #[allow(unused)]\n fn generic<T: 'static>() {\n     unsafe {\n@@ -84,6 +94,12 @@ fn main() {\n         let _val: [fn(); 2] = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: [fn(); 2] = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: TwoUninhabited = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: TwoUninhabited = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: OneFruitNonZero = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: OneFruitNonZero = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Things that can be zero, but not uninit.\n         let _val: bool = mem::zeroed();\n         let _val: bool = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n@@ -112,6 +128,16 @@ fn main() {\n         let _val: *const [()] = mem::zeroed();\n         let _val: *const [()] = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        // Things where 0 is okay due to rustc implementation details,\n+        // but that are not guaranteed to keep working.\n+        let _val: Result<i32, i32> = mem::zeroed();\n+        let _val: Result<i32, i32> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        // Some things that happen to work due to rustc implementation details,\n+        // but are not guaranteed to keep working.\n+        let _val: OneFruit = mem::zeroed();\n+        let _val: OneFruit = mem::uninitialized();\n+\n         // Transmute-from-0\n         let _val: &'static i32 = mem::transmute(0usize); //~ ERROR: does not permit zero-initialization\n         let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n@@ -129,9 +155,5 @@ fn main() {\n         let _val: bool = MaybeUninit::zeroed().assume_init();\n         let _val: [bool; 0] = MaybeUninit::uninit().assume_init();\n         let _val: [!; 0] = MaybeUninit::zeroed().assume_init();\n-\n-        // Some things that happen to work due to rustc implementation details,\n-        // but are not guaranteed to keep working.\n-        let _val: OneFruit = mem::uninitialized();\n     }\n }", "previous_filename": "src/test/ui/lint/uninitialized-zeroed.rs"}, {"sha": "750b3c76c44c2a82618a072b9f6f474f04d168e5", "filename": "src/test/ui/lint/invalid_value.stderr", "status": "renamed", "additions": 145, "deletions": 62, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr?ref=8d2faa2ae829db4a12799752f0968072c3d21904", "patch": "@@ -1,5 +1,5 @@\n error: the type `&T` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:40:32\n+  --> $DIR/invalid_value.rs:50:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -8,14 +8,14 @@ LL |         let _val: &'static T = mem::zeroed();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: the lint level is defined here\n-  --> $DIR/uninitialized-zeroed.rs:6:9\n+  --> $DIR/invalid_value.rs:6:9\n    |\n LL | #![deny(invalid_value)]\n    |         ^^^^^^^^^^^^^\n    = note: references must be non-null\n \n error: the type `&T` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:41:32\n+  --> $DIR/invalid_value.rs:51:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Wrap<&T>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:43:38\n+  --> $DIR/invalid_value.rs:53:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n@@ -35,13 +35,13 @@ LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<&T>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:44:38\n+  --> $DIR/invalid_value.rs:54:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -50,13 +50,13 @@ LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `!` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:51:23\n+  --> $DIR/invalid_value.rs:61:23\n    |\n LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n@@ -67,7 +67,7 @@ LL |         let _val: ! = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:52:23\n+  --> $DIR/invalid_value.rs:62:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |         let _val: ! = mem::uninitialized();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:54:30\n+  --> $DIR/invalid_value.rs:64:30\n    |\n LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n@@ -89,7 +89,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:55:30\n+  --> $DIR/invalid_value.rs:65:30\n    |\n LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n@@ -100,29 +100,37 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    = note: integers must not be uninitialized\n \n error: the type `Void` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:57:26\n+  --> $DIR/invalid_value.rs:67:26\n    |\n LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n    |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:12:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error: the type `Void` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:58:26\n+  --> $DIR/invalid_value.rs:68:26\n    |\n LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n    |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:12:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:60:34\n+  --> $DIR/invalid_value.rs:70:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -133,7 +141,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    = note: references must be non-null\n \n error: the type `&i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:61:34\n+  --> $DIR/invalid_value.rs:71:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -144,7 +152,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Ref` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:63:25\n+  --> $DIR/invalid_value.rs:73:25\n    |\n LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n@@ -153,13 +161,13 @@ LL |         let _val: Ref = mem::zeroed();\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:12\n+  --> $DIR/invalid_value.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `Ref` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:64:25\n+  --> $DIR/invalid_value.rs:74:25\n    |\n LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -168,13 +176,13 @@ LL |         let _val: Ref = mem::uninitialized();\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:12\n+  --> $DIR/invalid_value.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:66:26\n+  --> $DIR/invalid_value.rs:76:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -185,7 +193,7 @@ LL |         let _val: fn() = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:67:26\n+  --> $DIR/invalid_value.rs:77:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -196,7 +204,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    = note: function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:69:32\n+  --> $DIR/invalid_value.rs:79:32\n    |\n LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -205,13 +213,13 @@ LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:70:32\n+  --> $DIR/invalid_value.rs:80:32\n    |\n LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -220,43 +228,43 @@ LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `WrapEnum<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:72:36\n+  --> $DIR/invalid_value.rs:82:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n    |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:18:28\n+note: function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:73:36\n+  --> $DIR/invalid_value.rs:83:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n    |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:18:28\n+note: function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:75:42\n+  --> $DIR/invalid_value.rs:85:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n@@ -265,13 +273,13 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:15:16\n+  --> $DIR/invalid_value.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:76:42\n+  --> $DIR/invalid_value.rs:86:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n@@ -280,13 +288,13 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:15:16\n+  --> $DIR/invalid_value.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:78:34\n+  --> $DIR/invalid_value.rs:88:34\n    |\n LL |         let _val: NonNull<i32> = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -297,7 +305,7 @@ LL |         let _val: NonNull<i32> = mem::zeroed();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:79:34\n+  --> $DIR/invalid_value.rs:89:34\n    |\n LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -308,7 +316,7 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `*const dyn Send` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:81:37\n+  --> $DIR/invalid_value.rs:91:37\n    |\n LL |         let _val: *const dyn Send = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n@@ -319,7 +327,7 @@ LL |         let _val: *const dyn Send = mem::zeroed();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `*const dyn Send` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:82:37\n+  --> $DIR/invalid_value.rs:92:37\n    |\n LL |         let _val: *const dyn Send = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n@@ -330,7 +338,7 @@ LL |         let _val: *const dyn Send = mem::uninitialized();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `[fn(); 2]` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:84:31\n+  --> $DIR/invalid_value.rs:94:31\n    |\n LL |         let _val: [fn(); 2] = mem::zeroed();\n    |                               ^^^^^^^^^^^^^\n@@ -341,7 +349,7 @@ LL |         let _val: [fn(); 2] = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `[fn(); 2]` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:85:31\n+  --> $DIR/invalid_value.rs:95:31\n    |\n LL |         let _val: [fn(); 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -351,8 +359,68 @@ LL |         let _val: [fn(); 2] = mem::uninitialized();\n    |\n    = note: function pointers must be non-null\n \n+error: the type `TwoUninhabited` does not permit zero-initialization\n+  --> $DIR/invalid_value.rs:97:36\n+   |\n+LL |         let _val: TwoUninhabited = mem::zeroed();\n+   |                                    ^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:42:1\n+   |\n+LL | enum TwoUninhabited {\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: the type `TwoUninhabited` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:98:36\n+   |\n+LL |         let _val: TwoUninhabited = mem::uninitialized();\n+   |                                    ^^^^^^^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:42:1\n+   |\n+LL | enum TwoUninhabited {\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: the type `OneFruitNonZero` does not permit zero-initialization\n+  --> $DIR/invalid_value.rs:100:37\n+   |\n+LL |         let _val: OneFruitNonZero = mem::zeroed();\n+   |                                     ^^^^^^^^^^^^^\n+   |                                     |\n+   |                                     this code causes undefined behavior when executed\n+   |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:39:12\n+   |\n+LL |     Banana(NonZeroU32),\n+   |            ^^^^^^^^^^\n+\n+error: the type `OneFruitNonZero` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:101:37\n+   |\n+LL |         let _val: OneFruitNonZero = mem::uninitialized();\n+   |                                     ^^^^^^^^^^^^^^^^^^^^\n+   |                                     |\n+   |                                     this code causes undefined behavior when executed\n+   |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:39:12\n+   |\n+LL |     Banana(NonZeroU32),\n+   |            ^^^^^^^^^^\n+\n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:89:26\n+  --> $DIR/invalid_value.rs:105:26\n    |\n LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -363,7 +431,7 @@ LL |         let _val: bool = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `Wrap<char>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:92:32\n+  --> $DIR/invalid_value.rs:108:32\n    |\n LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -372,13 +440,13 @@ LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: characters must be a valid Unicode codepoint (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `NonBig` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:95:28\n+  --> $DIR/invalid_value.rs:111:28\n    |\n LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n@@ -389,22 +457,22 @@ LL |         let _val: NonBig = mem::uninitialized();\n    = note: `NonBig` must be initialized inside its custom valid range\n \n error: the type `Fruit` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:98:27\n+  --> $DIR/invalid_value.rs:114:27\n    |\n LL |         let _val: Fruit = mem::uninitialized();\n    |                           ^^^^^^^^^^^^^^^^^^^^\n    |                           |\n    |                           this code causes undefined behavior when executed\n    |                           help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: enums have to be initialized to a variant\n-  --> $DIR/uninitialized-zeroed.rs:26:1\n+note: enums with multiple inhabited variants have to be initialized to a variant\n+  --> $DIR/invalid_value.rs:26:1\n    |\n LL | enum Fruit {\n    | ^^^^^^^^^^\n \n error: the type `[bool; 2]` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:101:31\n+  --> $DIR/invalid_value.rs:117:31\n    |\n LL |         let _val: [bool; 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -415,7 +483,7 @@ LL |         let _val: [bool; 2] = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:104:25\n+  --> $DIR/invalid_value.rs:120:25\n    |\n LL |         let _val: i32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -426,7 +494,7 @@ LL |         let _val: i32 = mem::uninitialized();\n    = note: integers must not be uninitialized\n \n error: the type `f32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:107:25\n+  --> $DIR/invalid_value.rs:123:25\n    |\n LL |         let _val: f32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -437,7 +505,7 @@ LL |         let _val: f32 = mem::uninitialized();\n    = note: floats must not be uninitialized\n \n error: the type `*const ()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:110:31\n+  --> $DIR/invalid_value.rs:126:31\n    |\n LL |         let _val: *const () = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -448,7 +516,7 @@ LL |         let _val: *const () = mem::uninitialized();\n    = note: raw pointers must not be uninitialized\n \n error: the type `*const [()]` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:113:33\n+  --> $DIR/invalid_value.rs:129:33\n    |\n LL |         let _val: *const [()] = mem::uninitialized();\n    |                                 ^^^^^^^^^^^^^^^^^^^^\n@@ -458,8 +526,23 @@ LL |         let _val: *const [()] = mem::uninitialized();\n    |\n    = note: raw pointers must not be uninitialized\n \n+error: the type `Result<i32, i32>` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:134:38\n+   |\n+LL |         let _val: Result<i32, i32> = mem::uninitialized();\n+   |                                      ^^^^^^^^^^^^^^^^^^^^\n+   |                                      |\n+   |                                      this code causes undefined behavior when executed\n+   |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: enums with multiple inhabited variants have to be initialized to a variant\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | pub enum Result<T, E> {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:116:34\n+  --> $DIR/invalid_value.rs:142:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -470,7 +553,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    = note: references must be non-null\n \n error: the type `&[i32]` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:117:36\n+  --> $DIR/invalid_value.rs:143:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -481,7 +564,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    = note: references must be non-null\n \n error: the type `NonZeroU32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:118:32\n+  --> $DIR/invalid_value.rs:144:32\n    |\n LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n@@ -492,7 +575,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:121:34\n+  --> $DIR/invalid_value.rs:147:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -503,7 +586,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:122:34\n+  --> $DIR/invalid_value.rs:148:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -514,7 +597,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:123:26\n+  --> $DIR/invalid_value.rs:149:26\n    |\n LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -524,5 +607,5 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |\n    = note: booleans must be either `true` or `false`\n \n-error: aborting due to 43 previous errors\n+error: aborting due to 48 previous errors\n ", "previous_filename": "src/test/ui/lint/uninitialized-zeroed.stderr"}, {"sha": "6d37de8ff3f688a2ed52643f785ce9ee7e096b47", "filename": "src/test/ui/statics/uninhabited-static.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2faa2ae829db4a12799752f0968072c3d21904/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr?ref=8d2faa2ae829db4a12799752f0968072c3d21904", "patch": "@@ -59,7 +59,11 @@ LL | static VOID2: Void = unsafe { std::mem::transmute(()) };\n    |                               help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: `#[warn(invalid_value)]` on by default\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/uninhabited-static.rs:4:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $DIR/uninhabited-static.rs:16:32\n@@ -76,7 +80,11 @@ LL | static NEVER2: Void = unsafe { std::mem::transmute(()) };\n    |                                this code causes undefined behavior when executed\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/uninhabited-static.rs:4:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error: aborting due to 6 previous errors; 2 warnings emitted\n "}]}