{"sha": "044aa87d7808f89c38a79d8c68d03249246bf9cb", "node_id": "C_kwDOAAsO6NoAKDA0NGFhODdkNzgwOGY4OWMzOGE3OWQ4YzY4ZDAzMjQ5MjQ2YmY5Y2I", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-16T09:54:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-16T09:54:28Z"}, "message": "Merge from rustc", "tree": {"sha": "84aa26d240aff1e24fe4ea6b57439dc885e98f44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84aa26d240aff1e24fe4ea6b57439dc885e98f44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/044aa87d7808f89c38a79d8c68d03249246bf9cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/044aa87d7808f89c38a79d8c68d03249246bf9cb", "html_url": "https://github.com/rust-lang/rust/commit/044aa87d7808f89c38a79d8c68d03249246bf9cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/044aa87d7808f89c38a79d8c68d03249246bf9cb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "html_url": "https://github.com/rust-lang/rust/commit/f0ab39b60ef631da86a5069935fdc9ba2e5d0def"}, {"sha": "fd8947095678c61c5cbc70509e053621baca282d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd8947095678c61c5cbc70509e053621baca282d", "html_url": "https://github.com/rust-lang/rust/commit/fd8947095678c61c5cbc70509e053621baca282d"}], "stats": {"total": 9442, "additions": 2119, "deletions": 7323}, "files": [{"sha": "6a1525f7530d8950cce9fb44f368f862258cd595", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -3495,25 +3495,6 @@ dependencies = [\n  \"serde_json\",\n ]\n \n-[[package]]\n-name = \"rls-data\"\n-version = \"0.19.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a58135eb039f3a3279a33779192f0ee78b56f57ae636e25cec83530e41debb99\"\n-dependencies = [\n- \"rls-span\",\n- \"serde\",\n-]\n-\n-[[package]]\n-name = \"rls-span\"\n-version = \"0.5.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f0eea58478fc06e15f71b03236612173a1b81e9770314edecfa664375e3e4c86\"\n-dependencies = [\n- \"serde\",\n-]\n-\n [[package]]\n name = \"rust-demangler\"\n version = \"0.0.1\"\n@@ -3965,7 +3946,6 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_parse\",\n  \"rustc_plugin_impl\",\n- \"rustc_save_analysis\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4625,27 +4605,6 @@ dependencies = [\n  \"tracing\",\n ]\n \n-[[package]]\n-name = \"rustc_save_analysis\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"rls-data\",\n- \"rls-span\",\n- \"rustc_ast\",\n- \"rustc_ast_pretty\",\n- \"rustc_data_structures\",\n- \"rustc_errors\",\n- \"rustc_hir\",\n- \"rustc_hir_pretty\",\n- \"rustc_lexer\",\n- \"rustc_macros\",\n- \"rustc_middle\",\n- \"rustc_session\",\n- \"rustc_span\",\n- \"serde_json\",\n- \"tracing\",\n-]\n-\n [[package]]\n name = \"rustc_serialize\"\n version = \"0.0.0\""}, {"sha": "c4442b34fe42bc4a43e09db5f81210488b4f091a", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -139,13 +139,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::Cast(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n-                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Cast));\n                     hir::ExprKind::Cast(expr, ty)\n                 }\n                 ExprKind::Type(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n-                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Cast));\n                     hir::ExprKind::Type(expr, ty)\n                 }\n                 ExprKind::AddrOf(k, m, ohs) => {"}, {"sha": "6bafbfbc14c736434928d400a33d49af769fa496", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -378,8 +378,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             )\n                         });\n \n-                        let lowered_ty = this\n-                            .lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        let lowered_ty = this.lower_ty(\n+                            ty,\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::ImplSelf),\n+                        );\n \n                         (trait_ref, lowered_ty)\n                     });\n@@ -458,7 +460,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         body: Option<&Expr>,\n     ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n-        let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+        let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::ConstTy));\n         (ty, self.lower_const_body(span, body))\n     }\n \n@@ -608,8 +610,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n                 ForeignItemKind::Static(t, m, _) => {\n-                    let ty =\n-                        self.lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                    let ty = self\n+                        .lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::StaticTy));\n                     hir::ForeignItemKind::Static(ty, *m)\n                 }\n                 ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n@@ -679,11 +681,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 qself,\n                 path,\n                 ParamMode::ExplicitNamed, // no `'_` in declarations (Issue #61124)\n-                &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                &ImplTraitContext::Disallowed(ImplTraitPosition::FieldTy),\n             );\n             self.arena.alloc(t)\n         } else {\n-            self.lower_ty(&f.ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+            self.lower_ty(&f.ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FieldTy))\n         };\n         let hir_id = self.lower_node_id(f.id);\n         self.lower_attrs(hir_id, &f.attrs);\n@@ -708,7 +710,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let (generics, kind, has_default) = match &i.kind {\n             AssocItemKind::Const(_, ty, default) => {\n-                let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty =\n+                    self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::ConstTy));\n                 let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n                 (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body), body.is_some())\n             }\n@@ -746,7 +749,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         let ty = ty.as_ref().map(|x| {\n-                            this.lower_ty(x, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+                            this.lower_ty(\n+                                x,\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::AssocTy),\n+                            )\n                         });\n                         hir::TraitItemKind::Type(\n                             this.lower_param_bounds(\n@@ -805,7 +811,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let (generics, kind) = match &i.kind {\n             AssocItemKind::Const(_, ty, expr) => {\n-                let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty =\n+                    self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::ConstTy));\n                 (\n                     hir::Generics::empty(),\n                     hir::ImplItemKind::Const(ty, self.lower_const_body(i.span, expr.as_deref())),\n@@ -1441,7 +1448,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir_id: self.next_id(),\n                 bound_generic_params: self.lower_generic_params(bound_generic_params),\n                 bounded_ty: self\n-                    .lower_ty(bounded_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                    .lower_ty(bounded_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Bound)),\n                 bounds: self.arena.alloc_from_iter(bounds.iter().map(|bound| {\n                     self.lower_param_bound(\n                         bound,\n@@ -1465,9 +1472,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             WherePredicate::EqPredicate(WhereEqPredicate { lhs_ty, rhs_ty, span }) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     lhs_ty: self\n-                        .lower_ty(lhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                        .lower_ty(lhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Bound)),\n                     rhs_ty: self\n-                        .lower_ty(rhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                        .lower_ty(rhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Bound)),\n                     span: self.lower_span(*span),\n                 })\n             }"}, {"sha": "b543be3be50839ffa0ef2eee5bd5068c922f4cec", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -253,7 +253,6 @@ enum ImplTraitContext {\n enum ImplTraitPosition {\n     Path,\n     Variable,\n-    Type,\n     Trait,\n     AsyncBlock,\n     Bound,\n@@ -270,14 +269,20 @@ enum ImplTraitPosition {\n     FnTraitReturn,\n     TraitReturn,\n     ImplReturn,\n+    GenericDefault,\n+    ConstTy,\n+    StaticTy,\n+    AssocTy,\n+    FieldTy,\n+    Cast,\n+    ImplSelf,\n }\n \n impl std::fmt::Display for ImplTraitPosition {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         let name = match self {\n             ImplTraitPosition::Path => \"path\",\n             ImplTraitPosition::Variable => \"variable binding\",\n-            ImplTraitPosition::Type => \"type\",\n             ImplTraitPosition::Trait => \"trait\",\n             ImplTraitPosition::AsyncBlock => \"async block\",\n             ImplTraitPosition::Bound => \"bound\",\n@@ -294,6 +299,13 @@ impl std::fmt::Display for ImplTraitPosition {\n             ImplTraitPosition::FnTraitReturn => \"`Fn` trait return\",\n             ImplTraitPosition::TraitReturn => \"trait method return\",\n             ImplTraitPosition::ImplReturn => \"`impl` method return\",\n+            ImplTraitPosition::GenericDefault => \"generic parameter default\",\n+            ImplTraitPosition::ConstTy => \"const type\",\n+            ImplTraitPosition::StaticTy => \"static type\",\n+            ImplTraitPosition::AssocTy => \"associated type\",\n+            ImplTraitPosition::FieldTy => \"field type\",\n+            ImplTraitPosition::Cast => \"cast type\",\n+            ImplTraitPosition::ImplSelf => \"impl header\",\n         };\n \n         write!(f, \"{name}\")\n@@ -2166,15 +2178,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             GenericParamKind::Type { default, .. } => {\n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n-                        self.lower_ty(x, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+                        self.lower_ty(\n+                            x,\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::GenericDefault),\n+                        )\n                     }),\n                     synthetic: false,\n                 };\n \n                 (hir::ParamName::Plain(self.lower_ident(param.ident)), kind)\n             }\n             GenericParamKind::Const { ty, kw_span: _, default } => {\n-                let ty = self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                let ty = self.lower_ty(\n+                    &ty,\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::GenericDefault),\n+                );\n                 let default = default.as_ref().map(|def| self.lower_anon_const(def));\n                 (\n                     hir::ParamName::Plain(self.lower_ident(param.ident)),"}, {"sha": "c4e4e0517ece3f73a0c1bf0f1a1c4334ea2499e9", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1144,7 +1144,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 LateBoundRegionConversionTime::FnCall,\n                                 tcx.fn_sig(method_did).subst(tcx, method_substs).input(0),\n                             )\n-                            && infcx.can_eq(self.param_env, ty, self_ty).is_ok()\n+                            && infcx.can_eq(self.param_env, ty, self_ty)\n                         {\n                             err.span_suggestion_verbose(\n                                 fn_call_span.shrink_to_lo(),\n@@ -1182,13 +1182,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         );\n                     }\n                     let parent_did = tcx.parent(method_did);\n-                    let parent_self_ty = (tcx.def_kind(parent_did)\n-                        == rustc_hir::def::DefKind::Impl)\n-                        .then_some(parent_did)\n-                        .and_then(|did| match tcx.type_of(did).kind() {\n-                            ty::Adt(def, ..) => Some(def.did()),\n-                            _ => None,\n-                        });\n+                    let parent_self_ty =\n+                        matches!(tcx.def_kind(parent_did), rustc_hir::def::DefKind::Impl { .. })\n+                            .then_some(parent_did)\n+                            .and_then(|did| match tcx.type_of(did).kind() {\n+                                ty::Adt(def, ..) => Some(def.did()),\n+                                _ => None,\n+                            });\n                     let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n                         matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n                     });"}, {"sha": "a82e695d649053346b9b8637be59aea84f574659", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -852,9 +852,9 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let tcx = self.infcx.tcx;\n         let region_parent = tcx.parent(region.def_id);\n-        if tcx.def_kind(region_parent) != DefKind::Impl {\n+        let DefKind::Impl { .. } = tcx.def_kind(region_parent) else {\n             return None;\n-        }\n+        };\n \n         let found = tcx\n             .any_free_region_meets(&tcx.type_of(region_parent), |r| *r == ty::ReEarlyBound(region));"}, {"sha": "0d2367c2f83d324e291a5830efe67e39c69479dd", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -640,7 +640,8 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         sym::assert_inhabited | sym::assert_zero_valid | sym::assert_mem_uninitialized_valid => {\n             intrinsic_args!(fx, args => (); intrinsic);\n \n-            let layout = fx.layout_of(substs.type_at(0));\n+            let ty = substs.type_at(0);\n+            let layout = fx.layout_of(ty);\n             if layout.abi.is_uninhabited() {\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic_nounwind(\n@@ -653,7 +654,10 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             }\n \n             if intrinsic == sym::assert_zero_valid\n-                && !fx.tcx.permits_zero_init(fx.param_env().and(layout))\n+                && !fx\n+                    .tcx\n+                    .permits_zero_init(fx.param_env().and(ty))\n+                    .expect(\"expected to have layout during codegen\")\n             {\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic_nounwind(\n@@ -669,7 +673,10 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             }\n \n             if intrinsic == sym::assert_mem_uninitialized_valid\n-                && !fx.tcx.permits_uninit_init(fx.param_env().and(layout))\n+                && !fx\n+                    .tcx\n+                    .permits_uninit_init(fx.param_env().and(ty))\n+                    .expect(\"expected to have layout during codegen\")\n             {\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic_nounwind("}, {"sha": "11bd47a8f0c7929d865cd9867a5e8003b8e4c512", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -2,17 +2,16 @@ use std::collections::hash_map::Entry::*;\n \n use rustc_ast::expand::allocator::ALLOCATOR_METHODS;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportInfo, SymbolExportKind, SymbolExportLevel,\n };\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n-use rustc_middle::ty::{self, SymbolName, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, SymbolName, TyCtxt};\n use rustc_session::config::{CrateType, OomStrategy};\n use rustc_target::spec::SanitizerSet;\n \n@@ -74,32 +73,34 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             //\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n-            match tcx.hir().get_by_def_id(def_id) {\n-                Node::ForeignItem(..) => {\n-                    tcx.native_library(def_id).map_or(false, |library| library.kind.is_statically_included()).then_some(def_id)\n-                }\n+            if let Some(parent_id) = tcx.opt_local_parent(def_id)\n+                && let DefKind::ForeignMod = tcx.def_kind(parent_id)\n+            {\n+                let library = tcx.native_library(def_id)?;\n+                return library.kind.is_statically_included().then_some(def_id);\n+            }\n \n-                // Only consider nodes that actually have exported symbols.\n-                Node::Item(&hir::Item {\n-                    kind: hir::ItemKind::Static(..) | hir::ItemKind::Fn(..),\n-                    ..\n-                })\n-                | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n-                    let generics = tcx.generics_of(def_id);\n-                    if !generics.requires_monomorphization(tcx)\n-                        // Functions marked with #[inline] are codegened with \"internal\"\n-                        // linkage and are not exported unless marked with an extern\n-                        // indicator\n-                        && (!Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n-                            || tcx.codegen_fn_attrs(def_id.to_def_id()).contains_extern_indicator())\n-                    {\n-                        Some(def_id)\n-                    } else {\n-                        None\n-                    }\n-                }\n+            // Only consider nodes that actually have exported symbols.\n+            match tcx.def_kind(def_id) {\n+                DefKind::Fn | DefKind::Static(_) => {}\n+                DefKind::AssocFn if tcx.impl_of_method(def_id.to_def_id()).is_some() => {}\n+                _ => return None,\n+            };\n \n-                _ => None,\n+            let generics = tcx.generics_of(def_id);\n+            if generics.requires_monomorphization(tcx) {\n+                return None;\n+            }\n+\n+            // Functions marked with #[inline] are codegened with \"internal\"\n+            // linkage and are not exported unless marked with an extern\n+            // indicator\n+            if !Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n+                || tcx.codegen_fn_attrs(def_id.to_def_id()).contains_extern_indicator()\n+            {\n+                Some(def_id)\n+            } else {\n+                None\n             }\n         })\n         .map(|def_id| {\n@@ -118,7 +119,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n                 tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())),\n                 export_level\n             );\n-            (def_id.to_def_id(), SymbolExportInfo {\n+            let info = SymbolExportInfo {\n                 level: export_level,\n                 kind: if tcx.is_static(def_id.to_def_id()) {\n                     if codegen_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n@@ -130,8 +131,10 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n                     SymbolExportKind::Text\n                 },\n                 used: codegen_attrs.flags.contains(CodegenFnAttrFlags::USED)\n-                    || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER) || used,\n-            })\n+                    || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n+                    || used,\n+            };\n+            (def_id.to_def_id(), info)\n         })\n         .collect();\n \n@@ -457,9 +460,7 @@ fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel\n         let target = &tcx.sess.target.llvm_target;\n         // WebAssembly cannot export data symbols, so reduce their export level\n         if target.contains(\"emscripten\") {\n-            if let Some(Node::Item(&hir::Item { kind: hir::ItemKind::Static(..), .. })) =\n-                tcx.hir().get_if_local(sym_def_id)\n-            {\n+            if let DefKind::Static(_) = tcx.def_kind(sym_def_id) {\n                 return SymbolExportLevel::Rust;\n             }\n         }"}, {"sha": "9af408646ae031668b3d397c6019dfe4053ea2cc", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -674,8 +674,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let layout = bx.layout_of(ty);\n             let do_panic = match intrinsic {\n                 Inhabited => layout.abi.is_uninhabited(),\n-                ZeroValid => !bx.tcx().permits_zero_init(bx.param_env().and(layout)),\n-                MemUninitializedValid => !bx.tcx().permits_uninit_init(bx.param_env().and(layout)),\n+                ZeroValid => !bx\n+                    .tcx()\n+                    .permits_zero_init(bx.param_env().and(ty))\n+                    .expect(\"expected to have layout during codegen\"),\n+                MemUninitializedValid => !bx\n+                    .tcx()\n+                    .permits_uninit_init(bx.param_env().and(ty))\n+                    .expect(\"expected to have layout during codegen\"),\n             };\n             Some(if do_panic {\n                 let msg_str = with_no_visible_paths!({"}, {"sha": "a6afbad5b2402062e9a236c5cfdfca39e803f567", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -3,12 +3,12 @@ use rustc_attr::InstructionSetAttr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n-use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n@@ -440,12 +440,9 @@ fn asm_target_features(tcx: TyCtxt<'_>, did: DefId) -> &FxHashSet<Symbol> {\n /// Checks the function annotated with `#[target_feature]` is not a safe\n /// trait method implementation, reporting an error if it is.\n pub fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span: Span) {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n-    let node = tcx.hir().get(hir_id);\n-    if let hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) = node {\n-        let parent_id = tcx.hir().get_parent_item(hir_id);\n-        let parent_item = tcx.hir().expect_item(parent_id.def_id);\n-        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = parent_item.kind {\n+    if let DefKind::AssocFn = tcx.def_kind(id) {\n+        let parent_id = tcx.local_parent(id);\n+        if let DefKind::Impl { of_trait: true } = tcx.def_kind(parent_id) {\n             tcx.sess\n                 .struct_span_err(\n                     attr_span,"}, {"sha": "45f7c7560558461385ab86aba5df96a397bed13d", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -186,7 +186,7 @@ pub(super) fn op_to_const<'tcx>(\n                         0,\n                     ),\n                 };\n-                let len = b.to_machine_usize(ecx).unwrap();\n+                let len = b.to_target_usize(ecx).unwrap();\n                 let start = start.try_into().unwrap();\n                 let len: usize = len.try_into().unwrap();\n                 ConstValue::Slice { data, start, end: start + len }"}, {"sha": "9eaab1f47a7ea940d99073a76567f3b3895c3d45", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -17,7 +17,8 @@ pub fn is_unstable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n \n pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     let parent_id = tcx.local_parent(def_id);\n-    tcx.def_kind(parent_id) == DefKind::Impl && tcx.constness(parent_id) == hir::Constness::Const\n+    matches!(tcx.def_kind(parent_id), DefKind::Impl { .. })\n+        && tcx.constness(parent_id) == hir::Constness::Const\n }\n \n /// Checks whether an item is considered to be `const`. If it is a constructor, it is const. If"}, {"sha": "a44f70ed0590634159dd145cc5c26d91e9b52fd9", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -244,7 +244,7 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n         assert_eq!(args.len(), 2);\n \n         let ptr = self.read_pointer(&args[0])?;\n-        let target_align = self.read_scalar(&args[1])?.to_machine_usize(self)?;\n+        let target_align = self.read_scalar(&args[1])?.to_target_usize(self)?;\n \n         if !target_align.is_power_of_two() {\n             throw_ub_format!(\"`align_offset` called with non-power-of-two align: {}\", target_align);\n@@ -276,7 +276,7 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n                     Ok(ControlFlow::Break(()))\n                 } else {\n                     // Not alignable in const, return `usize::MAX`.\n-                    let usize_max = Scalar::from_machine_usize(self.machine_usize_max(), self);\n+                    let usize_max = Scalar::from_target_usize(self.target_usize_max(), self);\n                     self.write_scalar(usize_max, dest)?;\n                     self.return_to_block(ret)?;\n                     Ok(ControlFlow::Break(()))\n@@ -470,8 +470,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 ecx.write_scalar(Scalar::from_u8(cmp), dest)?;\n             }\n             sym::const_allocate => {\n-                let size = ecx.read_scalar(&args[0])?.to_machine_usize(ecx)?;\n-                let align = ecx.read_scalar(&args[1])?.to_machine_usize(ecx)?;\n+                let size = ecx.read_scalar(&args[0])?.to_target_usize(ecx)?;\n+                let align = ecx.read_scalar(&args[1])?.to_target_usize(ecx)?;\n \n                 let align = match Align::from_bytes(align) {\n                     Ok(a) => a,\n@@ -487,8 +487,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             }\n             sym::const_deallocate => {\n                 let ptr = ecx.read_pointer(&args[0])?;\n-                let size = ecx.read_scalar(&args[1])?.to_machine_usize(ecx)?;\n-                let align = ecx.read_scalar(&args[2])?.to_machine_usize(ecx)?;\n+                let size = ecx.read_scalar(&args[1])?.to_target_usize(ecx)?;\n+                let align = ecx.read_scalar(&args[2])?.to_target_usize(ecx)?;\n \n                 let size = Size::from_bytes(size);\n                 let align = match Align::from_bytes(align) {"}, {"sha": "3cdf1e6e30c99f85f4303dce637d745f0ad3e4ff", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -155,7 +155,7 @@ pub(crate) fn deref_mir_constant<'tcx>(\n         // In case of unsized types, figure out the real type behind.\n         MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n             ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n-            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n+            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_target_usize(&tcx).unwrap()),\n             _ => bug!(\n                 \"type {} should not have metadata, but had {:?}\",\n                 mplace.layout.ty,"}, {"sha": "a73f778d4db2091471fe63bd08e84ba7a000a132", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -239,7 +239,7 @@ fn create_pointee_place<'tcx>(\n         MPlaceTy::from_aligned_ptr_with_meta(\n             ptr.into(),\n             layout,\n-            MemPlaceMeta::Meta(Scalar::from_machine_usize(num_elems as u64, &tcx)),\n+            MemPlaceMeta::Meta(Scalar::from_target_usize(num_elems as u64, &tcx)),\n         )\n     } else {\n         create_mplace_from_layout(ecx, ty)\n@@ -355,7 +355,7 @@ fn valtree_into_mplace<'tcx>(\n             let imm = match inner_ty.kind() {\n                 ty::Slice(_) | ty::Str => {\n                     let len = valtree.unwrap_branch().len();\n-                    let len_scalar = Scalar::from_machine_usize(len as u64, &tcx);\n+                    let len_scalar = Scalar::from_target_usize(len as u64, &tcx);\n \n                     Immediate::ScalarPair(\n                         Scalar::from_maybe_pointer((*pointee_place).ptr, &tcx),\n@@ -426,7 +426,7 @@ fn valtree_into_mplace<'tcx>(\n                         place\n                             .offset_with_meta(\n                                 offset,\n-                                MemPlaceMeta::Meta(Scalar::from_machine_usize(\n+                                MemPlaceMeta::Meta(Scalar::from_target_usize(\n                                     num_elems as u64,\n                                     &tcx,\n                                 )),"}, {"sha": "68a91eabda7b9ed6a0eeab25085f618810d59338", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -231,7 +231,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // First cast to usize.\n         let scalar = src.to_scalar();\n         let addr = self.cast_from_int_like(scalar, src.layout, self.tcx.types.usize)?;\n-        let addr = addr.to_machine_usize(self)?;\n+        let addr = addr.to_target_usize(self)?;\n \n         // Then turn address into pointer.\n         let ptr = M::ptr_from_addr_cast(&self, addr)?;"}, {"sha": "c8bf769cfd8b714928a5ced247366b20a852962c", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -639,7 +639,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             ty::Slice(_) | ty::Str => {\n-                let len = metadata.unwrap_meta().to_machine_usize(self)?;\n+                let len = metadata.unwrap_meta().to_target_usize(self)?;\n                 let elem = layout.field(self, 0);\n \n                 // Make sure the slice is not too big."}, {"sha": "8877bb479d488e294ffbc16366dd356dd7e7a4cb", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -71,15 +71,15 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n         sym::pref_align_of => {\n             // Correctly handles non-monomorphic calls, so there is no need for ensure_monomorphic_enough.\n             let layout = tcx.layout_of(param_env.and(tp_ty)).map_err(|e| err_inval!(Layout(e)))?;\n-            ConstValue::from_machine_usize(layout.align.pref.bytes(), &tcx)\n+            ConstValue::from_target_usize(layout.align.pref.bytes(), &tcx)\n         }\n         sym::type_id => {\n             ensure_monomorphic_enough(tcx, tp_ty)?;\n             ConstValue::from_u64(tcx.type_id_hash(tp_ty))\n         }\n         sym::variant_count => match tp_ty.kind() {\n             // Correctly handles non-monomorphic calls, so there is no need for ensure_monomorphic_enough.\n-            ty::Adt(adt, _) => ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx),\n+            ty::Adt(adt, _) => ConstValue::from_target_usize(adt.variants().len() as u64, &tcx),\n             ty::Alias(..) | ty::Param(_) | ty::Placeholder(_) | ty::Infer(_) => {\n                 throw_inval!(TooGeneric)\n             }\n@@ -104,7 +104,7 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n             | ty::GeneratorWitnessMIR(_, _)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Error(_) => ConstValue::from_machine_usize(0u64, &tcx),\n+            | ty::Error(_) => ConstValue::from_target_usize(0u64, &tcx),\n         },\n         other => bug!(\"`{}` is not a zero arg intrinsic\", other),\n     })\n@@ -156,7 +156,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     _ => bug!(),\n                 };\n \n-                self.write_scalar(Scalar::from_machine_usize(result, self), dest)?;\n+                self.write_scalar(Scalar::from_target_usize(result, self), dest)?;\n             }\n \n             sym::pref_align_of\n@@ -302,15 +302,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             sym::offset => {\n                 let ptr = self.read_pointer(&args[0])?;\n-                let offset_count = self.read_machine_isize(&args[1])?;\n+                let offset_count = self.read_target_isize(&args[1])?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n                 self.write_pointer(offset_ptr, dest)?;\n             }\n             sym::arith_offset => {\n                 let ptr = self.read_pointer(&args[0])?;\n-                let offset_count = self.read_machine_isize(&args[1])?;\n+                let offset_count = self.read_target_isize(&args[1])?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n@@ -376,7 +376,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         // The signed form of the intrinsic allows this. If we interpret the\n                         // difference as isize, we'll get the proper signed difference. If that\n                         // seems *positive*, they were more than isize::MAX apart.\n-                        let dist = val.to_machine_isize(self)?;\n+                        let dist = val.to_target_isize(self)?;\n                         if dist >= 0 {\n                             throw_ub_format!(\n                                 \"`{}` called when first pointer is too far before second\",\n@@ -386,7 +386,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         dist\n                     } else {\n                         // b >= a\n-                        let dist = val.to_machine_isize(self)?;\n+                        let dist = val.to_target_isize(self)?;\n                         // If converting to isize produced a *negative* result, we had an overflow\n                         // because they were more than isize::MAX apart.\n                         if dist < 0 {\n@@ -411,10 +411,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Perform division by size to compute return value.\n                 let ret_layout = if intrinsic_name == sym::ptr_offset_from_unsigned {\n-                    assert!(0 <= dist && dist <= self.machine_isize_max());\n+                    assert!(0 <= dist && dist <= self.target_isize_max());\n                     usize_layout\n                 } else {\n-                    assert!(self.machine_isize_min() <= dist && dist <= self.machine_isize_max());\n+                    assert!(self.target_isize_min() <= dist && dist <= self.target_isize_max());\n                     isize_layout\n                 };\n                 let pointee_layout = self.layout_of(substs.type_at(0))?;\n@@ -448,7 +448,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n \n                 if intrinsic_name == sym::assert_zero_valid {\n-                    let should_panic = !self.tcx.permits_zero_init(self.param_env.and(layout));\n+                    let should_panic = !self\n+                        .tcx\n+                        .permits_zero_init(self.param_env.and(ty))\n+                        .map_err(|_| err_inval!(TooGeneric))?;\n \n                     if should_panic {\n                         M::abort(\n@@ -462,7 +465,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n \n                 if intrinsic_name == sym::assert_mem_uninitialized_valid {\n-                    let should_panic = !self.tcx.permits_uninit_init(self.param_env.and(layout));\n+                    let should_panic = !self\n+                        .tcx\n+                        .permits_uninit_init(self.param_env.and(ty))\n+                        .map_err(|_| err_inval!(TooGeneric))?;\n \n                     if should_panic {\n                         M::abort(\n@@ -525,12 +531,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::vtable_size => {\n                 let ptr = self.read_pointer(&args[0])?;\n                 let (size, _align) = self.get_vtable_size_and_align(ptr)?;\n-                self.write_scalar(Scalar::from_machine_usize(size.bytes(), self), dest)?;\n+                self.write_scalar(Scalar::from_target_usize(size.bytes(), self), dest)?;\n             }\n             sym::vtable_align => {\n                 let ptr = self.read_pointer(&args[0])?;\n                 let (_size, align) = self.get_vtable_size_and_align(ptr)?;\n-                self.write_scalar(Scalar::from_machine_usize(align.bytes(), self), dest)?;\n+                self.write_scalar(Scalar::from_target_usize(align.bytes(), self), dest)?;\n             }\n \n             _ => return Ok(false),\n@@ -669,10 +675,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         count: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        let count = self.read_machine_usize(&count)?;\n+        let count = self.read_target_usize(&count)?;\n         let layout = self.layout_of(src.layout.ty.builtin_deref(true).unwrap().ty)?;\n         let (size, align) = (layout.size, layout.align.abi);\n-        // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+        // `checked_mul` enforces a too small bound (the correct one would probably be target_isize_max),\n         // but no actual allocation can be big enough for the difference to be noticeable.\n         let size = size.checked_mul(count, self).ok_or_else(|| {\n             err_ub_format!(\n@@ -697,9 +703,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let dst = self.read_pointer(&dst)?;\n         let byte = self.read_scalar(&byte)?.to_u8()?;\n-        let count = self.read_machine_usize(&count)?;\n+        let count = self.read_target_usize(&count)?;\n \n-        // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+        // `checked_mul` enforces a too small bound (the correct one would probably be target_isize_max),\n         // but no actual allocation can be big enough for the difference to be noticeable.\n         let len = layout\n             .size"}, {"sha": "635987d039e09342742bd4c2582343ff8a577539", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -425,7 +425,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     throw_ub!(PointerOutOfBounds {\n                         alloc_id,\n                         alloc_size,\n-                        ptr_offset: self.machine_usize_to_isize(offset.bytes()),\n+                        ptr_offset: self.target_usize_to_isize(offset.bytes()),\n                         ptr_size: size,\n                         msg,\n                     })"}, {"sha": "ba41019aa938c5d27e8ae79fcd555b56273711cf", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -52,7 +52,7 @@ impl<Prov: Provenance> Immediate<Prov> {\n     }\n \n     pub fn new_slice(val: Scalar<Prov>, len: u64, cx: &impl HasDataLayout) -> Self {\n-        Immediate::ScalarPair(val, Scalar::from_machine_usize(len, cx))\n+        Immediate::ScalarPair(val, Scalar::from_target_usize(len, cx))\n     }\n \n     pub fn new_dyn_trait(\n@@ -414,12 +414,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.read_scalar(op)?.to_pointer(self)\n     }\n     /// Read a pointer-sized unsigned integer from a place.\n-    pub fn read_machine_usize(&self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx, u64> {\n-        self.read_scalar(op)?.to_machine_usize(self)\n+    pub fn read_target_usize(&self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx, u64> {\n+        self.read_scalar(op)?.to_target_usize(self)\n     }\n     /// Read a pointer-sized signed integer from a place.\n-    pub fn read_machine_isize(&self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx, i64> {\n-        self.read_scalar(op)?.to_machine_isize(self)\n+    pub fn read_target_isize(&self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx, i64> {\n+        self.read_scalar(op)?.to_target_isize(self)\n     }\n \n     /// Turn the wide MPlace into a string (must already be dereferenced!)"}, {"sha": "88485c06ed86cde303c10f226586c74cd59a60ba", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -229,7 +229,7 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind() {\n-                ty::Slice(..) | ty::Str => self.mplace.meta.unwrap_meta().to_machine_usize(cx),\n+                ty::Slice(..) | ty::Str => self.mplace.meta.unwrap_meta().to_target_usize(cx),\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n@@ -756,7 +756,7 @@ where\n         mutbl: Mutability,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl)?;\n-        let meta = Scalar::from_machine_usize(u64::try_from(str.len()).unwrap(), self);\n+        let meta = Scalar::from_target_usize(u64::try_from(str.len()).unwrap(), self);\n         let mplace = MemPlace { ptr: ptr.into(), meta: MemPlaceMeta::Meta(meta) };\n \n         let ty = self.tcx.mk_ref("}, {"sha": "91da930db4fbf121be79afbba9b62a3a9a50128d", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -319,7 +319,7 @@ where\n             // implement this.\n             ty::Array(inner, _) => (MemPlaceMeta::None, self.tcx.mk_array(*inner, inner_len)),\n             ty::Slice(..) => {\n-                let len = Scalar::from_machine_usize(inner_len, self);\n+                let len = Scalar::from_target_usize(inner_len, self);\n                 (MemPlaceMeta::Meta(len), base.layout.ty)\n             }\n             _ => {\n@@ -363,7 +363,7 @@ where\n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.local_to_op(self.frame(), local, Some(layout))?;\n-                let n = self.read_machine_usize(&n)?;\n+                let n = self.read_target_usize(&n)?;\n                 self.place_index(base, n)?\n             }\n             ConstantIndex { offset, min_length, from_end } => {\n@@ -392,7 +392,7 @@ where\n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.local_to_op(self.frame(), local, Some(layout))?;\n-                let n = self.read_machine_usize(&n)?;\n+                let n = self.read_target_usize(&n)?;\n                 self.operand_index(base, n)?\n             }\n             ConstantIndex { offset, min_length, from_end } => {"}, {"sha": "8252e73c5d9374624ddaaebddb0ac5c617dfb108", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -242,7 +242,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let src = self.eval_place(place)?;\n                 let op = self.place_to_op(&src)?;\n                 let len = op.len(self)?;\n-                self.write_scalar(Scalar::from_machine_usize(len, self), &dest)?;\n+                self.write_scalar(Scalar::from_target_usize(len, self), &dest)?;\n             }\n \n             Ref(_, borrow_kind, place) => {\n@@ -297,7 +297,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     mir::NullOp::SizeOf => layout.size.bytes(),\n                     mir::NullOp::AlignOf => layout.align.abi.bytes(),\n                 };\n-                self.write_scalar(Scalar::from_machine_usize(val, self), &dest)?;\n+                self.write_scalar(Scalar::from_target_usize(val, self), &dest)?;\n             }\n \n             ShallowInitBox(ref operand, _) => {"}, {"sha": "820ee320474248d76d31f8fc886c1873b2b1d81d", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -348,7 +348,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // FIXME: check if the type/trait match what ty::Dynamic says?\n             }\n             ty::Slice(..) | ty::Str => {\n-                let _len = meta.unwrap_meta().to_machine_usize(self.ecx)?;\n+                let _len = meta.unwrap_meta().to_target_usize(self.ecx)?;\n                 // We do not check that `len * elem_size <= isize::MAX`:\n                 // that is only required for references, and there it falls out of the\n                 // \"dereferenceable\" check performed by Stacked Borrows."}, {"sha": "964efcc9062dba56cb0bde2e09e7e41f64d81f5e", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -59,11 +59,8 @@ pub fn provide(providers: &mut Providers) {\n         const_eval::deref_mir_constant(tcx, param_env, value)\n     };\n     providers.permits_uninit_init = |tcx, param_env_and_ty| {\n-        let (param_env, ty) = param_env_and_ty.into_parts();\n-        util::might_permit_raw_init(tcx, param_env, ty, InitKind::UninitMitigated0x01Fill)\n-    };\n-    providers.permits_zero_init = |tcx, param_env_and_ty| {\n-        let (param_env, ty) = param_env_and_ty.into_parts();\n-        util::might_permit_raw_init(tcx, param_env, ty, InitKind::Zero)\n+        util::might_permit_raw_init(tcx, param_env_and_ty, InitKind::UninitMitigated0x01Fill)\n     };\n+    providers.permits_zero_init =\n+        |tcx, param_env_and_ty| util::might_permit_raw_init(tcx, param_env_and_ty, InitKind::Zero);\n }"}, {"sha": "2eba1e11466a45b6b4693e6d033b93dfebebf6d2", "filename": "compiler/rustc_const_eval/src/util/might_permit_raw_init.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,5 +1,5 @@\n-use rustc_middle::ty::layout::{LayoutCx, LayoutOf, TyAndLayout};\n-use rustc_middle::ty::{ParamEnv, TyCtxt};\n+use rustc_middle::ty::layout::{LayoutCx, LayoutError, LayoutOf, TyAndLayout};\n+use rustc_middle::ty::{ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_session::Limit;\n use rustc_target::abi::{Abi, FieldsShape, InitKind, Scalar, Variants};\n \n@@ -20,15 +20,14 @@ use crate::interpret::{InterpCx, MemoryKind, OpTy};\n /// to the full uninit check).\n pub fn might_permit_raw_init<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n-    ty: TyAndLayout<'tcx>,\n+    param_env_and_ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n     kind: InitKind,\n-) -> bool {\n+) -> Result<bool, LayoutError<'tcx>> {\n     if tcx.sess.opts.unstable_opts.strict_init_checks {\n-        might_permit_raw_init_strict(ty, tcx, kind)\n+        might_permit_raw_init_strict(tcx.layout_of(param_env_and_ty)?, tcx, kind)\n     } else {\n-        let layout_cx = LayoutCx { tcx, param_env };\n-        might_permit_raw_init_lax(ty, &layout_cx, kind)\n+        let layout_cx = LayoutCx { tcx, param_env: param_env_and_ty.param_env };\n+        might_permit_raw_init_lax(tcx.layout_of(param_env_and_ty)?, &layout_cx, kind)\n     }\n }\n \n@@ -38,7 +37,7 @@ fn might_permit_raw_init_strict<'tcx>(\n     ty: TyAndLayout<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     kind: InitKind,\n-) -> bool {\n+) -> Result<bool, LayoutError<'tcx>> {\n     let machine = CompileTimeInterpreter::new(\n         Limit::new(0),\n         /*can_access_statics:*/ false,\n@@ -65,7 +64,7 @@ fn might_permit_raw_init_strict<'tcx>(\n     // This does *not* actually check that references are dereferenceable, but since all types that\n     // require dereferenceability also require non-null, we don't actually get any false negatives\n     // due to this.\n-    cx.validate_operand(&ot).is_ok()\n+    Ok(cx.validate_operand(&ot).is_ok())\n }\n \n /// Implements the 'lax' (default) version of the `might_permit_raw_init` checks; see that function for\n@@ -74,7 +73,7 @@ fn might_permit_raw_init_lax<'tcx>(\n     this: TyAndLayout<'tcx>,\n     cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n     init_kind: InitKind,\n-) -> bool {\n+) -> Result<bool, LayoutError<'tcx>> {\n     let scalar_allows_raw_init = move |s: Scalar| -> bool {\n         match init_kind {\n             InitKind::Zero => {\n@@ -103,20 +102,20 @@ fn might_permit_raw_init_lax<'tcx>(\n     };\n     if !valid {\n         // This is definitely not okay.\n-        return false;\n+        return Ok(false);\n     }\n \n     // Special magic check for references and boxes (i.e., special pointer types).\n     if let Some(pointee) = this.ty.builtin_deref(false) {\n-        let pointee = cx.layout_of(pointee.ty).expect(\"need to be able to compute layouts\");\n+        let pointee = cx.layout_of(pointee.ty)?;\n         // We need to ensure that the LLVM attributes `aligned` and `dereferenceable(size)` are satisfied.\n         if pointee.align.abi.bytes() > 1 {\n             // 0x01-filling is not aligned.\n-            return false;\n+            return Ok(false);\n         }\n         if pointee.size.bytes() > 0 {\n             // A 'fake' integer pointer is not sufficiently dereferenceable.\n-            return false;\n+            return Ok(false);\n         }\n     }\n \n@@ -129,9 +128,9 @@ fn might_permit_raw_init_lax<'tcx>(\n         }\n         FieldsShape::Arbitrary { offsets, .. } => {\n             for idx in 0..offsets.len() {\n-                if !might_permit_raw_init_lax(this.field(cx, idx), cx, init_kind) {\n+                if !might_permit_raw_init_lax(this.field(cx, idx), cx, init_kind)? {\n                     // We found a field that is unhappy with this kind of initialization.\n-                    return false;\n+                    return Ok(false);\n                 }\n             }\n         }\n@@ -148,5 +147,5 @@ fn might_permit_raw_init_lax<'tcx>(\n         }\n     }\n \n-    true\n+    Ok(true)\n }"}, {"sha": "cdec4f912779cd90926f017751c01b679c92cbef", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -22,7 +22,6 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n-rustc_save_analysis = { path = \"../rustc_save_analysis\" }\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_error_codes = { path = \"../rustc_error_codes\" }"}, {"sha": "1a4fe07b47656af786bca9d5bfecb3fde3225460", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -25,13 +25,10 @@ use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{ErrorGuaranteed, PResult, TerminalUrl};\n use rustc_feature::find_gated_cfg;\n-use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_interface::util::{self, collect_crate_types, get_codegen_backend};\n use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n use rustc_metadata::locator;\n-use rustc_save_analysis as save;\n-use rustc_save_analysis::DumpHandler;\n use rustc_session::config::{nightly_options, CG_OPTIONS, Z_OPTIONS};\n use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, TrimmedDefPaths};\n use rustc_session::cstore::MetadataLoader;\n@@ -343,22 +340,7 @@ fn run_compiler(\n                 return early_exit();\n             }\n \n-            queries.global_ctxt()?.enter(|tcx| {\n-                let result = tcx.analysis(());\n-                if sess.opts.unstable_opts.save_analysis {\n-                    let crate_name = tcx.crate_name(LOCAL_CRATE);\n-                    sess.time(\"save_analysis\", || {\n-                        save::process_crate(\n-                            tcx,\n-                            crate_name,\n-                            &sess.io.input,\n-                            None,\n-                            DumpHandler::new(sess.io.output_dir.as_deref(), crate_name),\n-                        )\n-                    });\n-                }\n-                result\n-            })?;\n+            queries.global_ctxt()?.enter(|tcx| tcx.analysis(()))?;\n \n             if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n                 return early_exit();"}, {"sha": "c5b2b6c2d735758dddf390e189091c1e96ba6306", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -140,6 +140,18 @@ infer_lifetime_param_suggestion_elided = each elided lifetime in input position\n \n infer_region_explanation = {$pref_kind ->\n     *[should_not_happen] [{$pref_kind}]\n+    [ref_valid_for] ...the reference is valid for\n+    [content_valid_for] ...but the borrowed content is only valid for\n+    [type_obj_valid_for] object type is valid for\n+    [source_pointer_valid_for] source pointer is only valid for\n+    [type_satisfy] type must satisfy\n+    [type_outlive] type must outlive\n+    [lf_param_instantiated_with] lifetime parameter instantiated with\n+    [lf_param_must_outlive] but lifetime parameter must outlive\n+    [lf_instantiated_with] lifetime instantiated with\n+    [lf_must_outlive] but lifetime must outlive\n+    [pointer_valid_for] the pointer is valid for\n+    [data_valid_for] but the referenced data is only valid for\n     [empty] {\"\"}\n }{$pref_kind ->\n     [empty] {\"\"}\n@@ -148,7 +160,6 @@ infer_region_explanation = {$pref_kind ->\n     *[should_not_happen] [{$desc_kind}]\n     [restatic] the static lifetime\n     [revar] lifetime {$desc_arg}\n-\n     [as_defined] the lifetime `{$desc_arg}` as defined here\n     [as_defined_anon] the anonymous lifetime as defined here\n     [defined_here] the anonymous lifetime defined here\n@@ -158,8 +169,16 @@ infer_region_explanation = {$pref_kind ->\n     *[should_not_happen] [{$suff_kind}]\n     [empty]{\"\"}\n     [continues] ...\n+    [req_by_binding] {\" \"}as required by this binding\n }\n \n+infer_outlives_content = lifetime of reference outlives lifetime of borrowed content...\n+infer_outlives_bound = lifetime of the source pointer does not outlive lifetime bound of the object type\n+infer_fullfill_req_lifetime = the type `{$ty}` does not fulfill the required lifetime\n+infer_lf_bound_not_satisfied = lifetime bound not satisfied\n+infer_borrowed_too_long = a value of type `{$ty}` is borrowed for too long\n+infer_ref_longer_than_data = in type `{$ty}`, reference has a longer lifetime than the data it references\n+\n infer_mismatched_static_lifetime = incompatible lifetime on type\n infer_does_not_outlive_static_from_impl = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n infer_implicit_static_lifetime_note = this has an implicit `'static` lifetime requirement\n@@ -308,3 +327,21 @@ infer_ril_introduced_here = `'static` requirement introduced here\n infer_ril_introduced_by = requirement introduced by this return type\n infer_ril_because_of = because of this returned expression\n infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type\n+\n+infer_where_remove = remove the `where` clause\n+infer_where_copy_predicates = copy the `where` clause predicates from the trait\n+\n+infer_srs_remove_and_box = consider removing this semicolon and boxing the expressions\n+infer_srs_remove = consider removing this semicolon\n+infer_srs_add = consider returning the local binding `{$ident}`\n+infer_srs_add_one = consider returning one of these bindings\n+\n+infer_await_both_futures = consider `await`ing on both `Future`s\n+infer_await_future = consider `await`ing on the `Future`\n+infer_await_note = calling an async function returns a future\n+\n+infer_prlf_defined_with_sub = the lifetime `{$sub_symbol}` defined here...\n+infer_prlf_defined_without_sub = the lifetime defined here...\n+infer_prlf_must_oultive_with_sup = ...must outlive the lifetime `{$sup_symbol}` defined here\n+infer_prlf_must_oultive_without_sup = ...must outlive the lifetime defined here\n+infer_prlf_known_limitation = this is a known limitation that will be removed in the future (see issue #100013 <https://github.com/rust-lang/rust/issues/100013> for more information)"}, {"sha": "36c2ff4682301c967c1656e4ac8441d9f6c92196", "filename": "compiler/rustc_error_messages/locales/en-US/save_analysis.ftl", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1 +0,0 @@\n-save_analysis_could_not_open = Could not open `{$file_name}`: `{$err}`"}, {"sha": "579466ed366d86f03a34962d8f2f55963dc29f63", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -67,7 +67,6 @@ fluent_messages! {\n     privacy => \"../locales/en-US/privacy.ftl\",\n     query_system => \"../locales/en-US/query_system.ftl\",\n     resolve => \"../locales/en-US/resolve.ftl\",\n-    save_analysis => \"../locales/en-US/save_analysis.ftl\",\n     session => \"../locales/en-US/session.ftl\",\n     symbol_mangling => \"../locales/en-US/symbol_mangling.ftl\",\n     trait_selection => \"../locales/en-US/trait_selection.ftl\","}, {"sha": "0599ae04a90abdfa6a8d1487d6a98867a8c12152", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -116,7 +116,9 @@ pub enum DefKind {\n     LifetimeParam,\n     /// A use of `global_asm!`.\n     GlobalAsm,\n-    Impl,\n+    Impl {\n+        of_trait: bool,\n+    },\n     Closure,\n     Generator,\n }\n@@ -155,7 +157,7 @@ impl DefKind {\n             DefKind::AnonConst => \"constant expression\",\n             DefKind::InlineConst => \"inline constant\",\n             DefKind::Field => \"field\",\n-            DefKind::Impl => \"implementation\",\n+            DefKind::Impl { .. } => \"implementation\",\n             DefKind::Closure => \"closure\",\n             DefKind::Generator => \"generator\",\n             DefKind::ExternCrate => \"extern crate\",\n@@ -171,7 +173,7 @@ impl DefKind {\n             | DefKind::AssocFn\n             | DefKind::Enum\n             | DefKind::OpaqueTy\n-            | DefKind::Impl\n+            | DefKind::Impl { .. }\n             | DefKind::Use\n             | DefKind::InlineConst\n             | DefKind::ExternCrate => \"an\",\n@@ -216,7 +218,7 @@ impl DefKind {\n             | DefKind::Use\n             | DefKind::ForeignMod\n             | DefKind::GlobalAsm\n-            | DefKind::Impl\n+            | DefKind::Impl { .. }\n             | DefKind::ImplTraitPlaceholder => None,\n         }\n     }\n@@ -255,7 +257,7 @@ impl DefKind {\n             | DefKind::ForeignMod\n             | DefKind::OpaqueTy\n             | DefKind::ImplTraitPlaceholder\n-            | DefKind::Impl\n+            | DefKind::Impl { .. }\n             | DefKind::Field\n             | DefKind::TyParam\n             | DefKind::ConstParam"}, {"sha": "961deac544a8843d03cd4e7917737e85f0b09bf7", "filename": "compiler/rustc_hir/src/target.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -116,7 +116,7 @@ impl Target {\n             DefKind::Union => Target::Union,\n             DefKind::Trait => Target::Trait,\n             DefKind::TraitAlias => Target::TraitAlias,\n-            DefKind::Impl => Target::Impl,\n+            DefKind::Impl { .. } => Target::Impl,\n             _ => panic!(\"impossible case reached\"),\n         }\n     }"}, {"sha": "46dc4141e66193956d9c7ac1daa9d08bc0b9be04", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1970,7 +1970,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             ) = &qself.kind {\n                                 // If the path segment already has type params, we want to overwrite\n                                 // them.\n-                                match &path.segments[..] {\n+                                match &path.segments {\n                                     // `segment` is the previous to last element on the path,\n                                     // which would normally be the `enum` itself, while the last\n                                     // `_` `PathSegment` corresponds to the variant.\n@@ -2232,7 +2232,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                         tcx.erase_regions(impl_.self_ty()),\n                                         tcx.erase_regions(qself_ty),\n                                     )\n-                                    .is_ok()\n                             })\n                             && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n                         })\n@@ -2671,7 +2670,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(path.segments.iter(), |err| {\n-                    if let [hir::PathSegment { args: Some(args), ident, .. }] = &path.segments[..] {\n+                    if let [hir::PathSegment { args: Some(args), ident, .. }] = &path.segments {\n                         err.span_suggestion_verbose(\n                             ident.span.shrink_to_hi().to(args.span_ext),\n                             \"the `Self` type doesn't accept type parameters\","}, {"sha": "49ad09800a5a05eba56c45f5a48f0f3791320672", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 40, "deletions": 69, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -21,7 +21,9 @@ use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::layout::{LayoutError, MAX_SIMD_LANES};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, AdtDef, ParamEnv, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, AdtDef, DefIdTree, ParamEnv, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable,\n+};\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n@@ -174,16 +176,8 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         Ok(l) => l,\n         // Foreign statics that overflow their allowed size should emit an error\n         Err(LayoutError::SizeOverflow(_))\n-            if {\n-                let node = tcx.hir().get_by_def_id(def_id);\n-                matches!(\n-                    node,\n-                    hir::Node::ForeignItem(hir::ForeignItem {\n-                        kind: hir::ForeignItemKind::Static(..),\n-                        ..\n-                    })\n-                )\n-            } =>\n+            if matches!(tcx.def_kind(def_id), DefKind::Static(_)\n+                if tcx.def_kind(tcx.local_parent(def_id)) == DefKind::ForeignMod) =>\n         {\n             tcx.sess\n                 .struct_span_err(span, \"extern static is too large for the current architecture\")\n@@ -215,7 +209,7 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n fn check_opaque(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     let item = tcx.hir().item(id);\n     let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item.kind else {\n-        tcx.sess.delay_span_bug(tcx.hir().span(id.hir_id()), \"expected opaque item\");\n+        tcx.sess.delay_span_bug(item.span, \"expected opaque item\");\n         return;\n     };\n \n@@ -529,45 +523,34 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n             check_enum(tcx, id.owner_id.def_id);\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n-        DefKind::Impl => {\n-            let it = tcx.hir().item(id);\n-            let hir::ItemKind::Impl(impl_) = it.kind else { return };\n-            debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.owner_id);\n-            if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.owner_id) {\n+        DefKind::Impl { of_trait } => {\n+            if of_trait && let Some(impl_trait_ref) = tcx.impl_trait_ref(id.owner_id) {\n                 check_impl_items_against_trait(\n                     tcx,\n-                    it.span,\n-                    it.owner_id.def_id,\n+                    id.owner_id.def_id,\n                     impl_trait_ref.subst_identity(),\n-                    &impl_.items,\n                 );\n-                check_on_unimplemented(tcx, it);\n+                check_on_unimplemented(tcx, id);\n             }\n         }\n         DefKind::Trait => {\n-            let it = tcx.hir().item(id);\n-            let hir::ItemKind::Trait(_, _, _, _, items) = it.kind else {\n-                return;\n-            };\n-            check_on_unimplemented(tcx, it);\n-\n-            for item in items.iter() {\n-                let item = tcx.hir().trait_item(item.id);\n-                match &item.kind {\n-                    hir::TraitItemKind::Fn(sig, _) => {\n-                        let abi = sig.header.abi;\n-                        fn_maybe_err(tcx, item.ident.span, abi);\n+            let assoc_items = tcx.associated_items(id.owner_id);\n+            check_on_unimplemented(tcx, id);\n+\n+            for assoc_item in assoc_items.in_definition_order() {\n+                match assoc_item.kind {\n+                    ty::AssocKind::Fn => {\n+                        let abi = tcx.fn_sig(assoc_item.def_id).skip_binder().abi();\n+                        fn_maybe_err(tcx, assoc_item.ident(tcx).span, abi);\n                     }\n-                    hir::TraitItemKind::Type(.., Some(default)) => {\n-                        let assoc_item = tcx.associated_item(item.owner_id);\n+                    ty::AssocKind::Type if assoc_item.defaultness(tcx).has_value() => {\n                         let trait_substs =\n-                            InternalSubsts::identity_for_item(tcx, it.owner_id.to_def_id());\n+                            InternalSubsts::identity_for_item(tcx, id.owner_id.to_def_id());\n                         let _: Result<_, rustc_errors::ErrorGuaranteed> = check_type_bounds(\n                             tcx,\n                             assoc_item,\n                             assoc_item,\n-                            default.span,\n-                            tcx.mk_trait_ref(it.owner_id.to_def_id(), trait_substs),\n+                            tcx.mk_trait_ref(id.owner_id.to_def_id(), trait_substs),\n                         );\n                     }\n                     _ => {}\n@@ -679,7 +662,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     }\n }\n \n-pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n+pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: hir::ItemId) {\n     // an error would be reported if this fails.\n     let _ = OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n }\n@@ -689,7 +672,7 @@ pub(super) fn check_specialization_validity<'tcx>(\n     trait_def: &ty::TraitDef,\n     trait_item: &ty::AssocItem,\n     impl_id: DefId,\n-    impl_item: &hir::ImplItemRef,\n+    impl_item: DefId,\n ) {\n     let Ok(ancestors) = trait_def.ancestors(tcx, impl_id) else { return };\n     let mut ancestor_impls = ancestors.skip(1).filter_map(|parent| {\n@@ -735,10 +718,8 @@ pub(super) fn check_specialization_validity<'tcx>(\n \n fn check_impl_items_against_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    full_impl_span: Span,\n     impl_id: LocalDefId,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    impl_item_refs: &[hir::ImplItemRef],\n ) {\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n@@ -747,12 +728,14 @@ fn check_impl_items_against_trait<'tcx>(\n         return;\n     }\n \n+    let impl_item_refs = tcx.associated_item_def_ids(impl_id);\n+\n     // Negative impls are not expected to have any items\n     match tcx.impl_polarity(impl_id) {\n         ty::ImplPolarity::Reservation | ty::ImplPolarity::Positive => {}\n         ty::ImplPolarity::Negative => {\n             if let [first_item_ref, ..] = impl_item_refs {\n-                let first_item_span = tcx.hir().impl_item(first_item_ref.id).span;\n+                let first_item_span = tcx.def_span(first_item_ref);\n                 struct_span_err!(\n                     tcx.sess,\n                     first_item_span,\n@@ -767,43 +750,27 @@ fn check_impl_items_against_trait<'tcx>(\n \n     let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n \n-    for impl_item in impl_item_refs {\n-        let ty_impl_item = tcx.associated_item(impl_item.id.owner_id);\n+    for &impl_item in impl_item_refs {\n+        let ty_impl_item = tcx.associated_item(impl_item);\n         let ty_trait_item = if let Some(trait_item_id) = ty_impl_item.trait_item_def_id {\n             tcx.associated_item(trait_item_id)\n         } else {\n             // Checked in `associated_item`.\n-            tcx.sess.delay_span_bug(impl_item.span, \"missing associated item in trait\");\n+            tcx.sess.delay_span_bug(tcx.def_span(impl_item), \"missing associated item in trait\");\n             continue;\n         };\n-        let impl_item_full = tcx.hir().impl_item(impl_item.id);\n-        match impl_item_full.kind {\n-            hir::ImplItemKind::Const(..) => {\n+        match ty_impl_item.kind {\n+            ty::AssocKind::Const => {\n                 let _ = tcx.compare_impl_const((\n-                    impl_item.id.owner_id.def_id,\n+                    impl_item.expect_local(),\n                     ty_impl_item.trait_item_def_id.unwrap(),\n                 ));\n             }\n-            hir::ImplItemKind::Fn(..) => {\n-                let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                compare_impl_method(\n-                    tcx,\n-                    &ty_impl_item,\n-                    &ty_trait_item,\n-                    impl_trait_ref,\n-                    opt_trait_span,\n-                );\n+            ty::AssocKind::Fn => {\n+                compare_impl_method(tcx, &ty_impl_item, &ty_trait_item, impl_trait_ref);\n             }\n-            hir::ImplItemKind::Type(impl_ty) => {\n-                let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                compare_impl_ty(\n-                    tcx,\n-                    &ty_impl_item,\n-                    impl_ty.span,\n-                    &ty_trait_item,\n-                    impl_trait_ref,\n-                    opt_trait_span,\n-                );\n+            ty::AssocKind::Type => {\n+                compare_impl_ty(tcx, &ty_impl_item, &ty_trait_item, impl_trait_ref);\n             }\n         }\n \n@@ -838,6 +805,8 @@ fn check_impl_items_against_trait<'tcx>(\n                 .map_or(false, |node_item| !node_item.defining_node.is_from_trait());\n \n             if !is_implemented_here {\n+                let full_impl_span =\n+                    tcx.hir().span_with_body(tcx.hir().local_def_id_to_hir_id(impl_id));\n                 match tcx.eval_default_body_stability(trait_item_id, full_impl_span) {\n                     EvalResult::Deny { feature, reason, issue, .. } => default_body_is_unstable(\n                         tcx,\n@@ -864,6 +833,8 @@ fn check_impl_items_against_trait<'tcx>(\n         }\n \n         if !missing_items.is_empty() {\n+            let full_impl_span =\n+                tcx.hir().span_with_body(tcx.hir().local_def_id_to_hir_id(impl_id));\n             missing_items_err(tcx, tcx.def_span(impl_id), &missing_items, full_impl_span);\n         }\n "}, {"sha": "6b0eade2d32666b726a461f1afa1995727de4966", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -33,31 +33,26 @@ use std::iter;\n /// # Parameters\n ///\n /// - `impl_m`: type of the method we are checking\n-/// - `impl_m_span`: span to use for reporting errors\n /// - `trait_m`: the method in the trait\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n pub(super) fn compare_impl_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    trait_item_span: Option<Span>,\n ) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    let impl_m_span = tcx.def_span(impl_m.def_id);\n-\n     let _: Result<_, ErrorGuaranteed> = try {\n-        compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)?;\n-        compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false)?;\n+        compare_self_type(tcx, impl_m, trait_m, impl_trait_ref)?;\n+        compare_number_of_generics(tcx, impl_m, trait_m, false)?;\n         compare_generic_param_kinds(tcx, impl_m, trait_m, false)?;\n-        compare_number_of_method_arguments(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_number_of_method_arguments(tcx, impl_m, trait_m)?;\n         compare_synthetic_generics(tcx, impl_m, trait_m)?;\n-        compare_asyncness(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_asyncness(tcx, impl_m, trait_m)?;\n         compare_method_predicate_entailment(\n             tcx,\n             impl_m,\n-            impl_m_span,\n             trait_m,\n             impl_trait_ref,\n             CheckImpliedWfMode::Check,\n@@ -131,11 +126,10 @@ pub(super) fn compare_impl_method<'tcx>(\n ///\n /// Finally we register each of these predicates as an obligation and check that\n /// they hold.\n-#[instrument(level = \"debug\", skip(tcx, impl_m_span, impl_trait_ref))]\n+#[instrument(level = \"debug\", skip(tcx, impl_trait_ref))]\n fn compare_method_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     check_implied_wf: CheckImpliedWfMode,\n@@ -148,6 +142,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     // FIXME(@lcnr): remove that after removing `cause.body_id` from\n     // obligations.\n     let impl_m_def_id = impl_m.def_id.expect_local();\n+    let impl_m_span = tcx.def_span(impl_m_def_id);\n     let cause = ObligationCause::new(\n         impl_m_span,\n         impl_m_def_id,\n@@ -315,7 +310,6 @@ fn compare_method_predicate_entailment<'tcx>(\n                 return compare_method_predicate_entailment(\n                     tcx,\n                     impl_m,\n-                    impl_m_span,\n                     trait_m,\n                     impl_trait_ref,\n                     CheckImpliedWfMode::Skip,\n@@ -353,7 +347,6 @@ fn compare_method_predicate_entailment<'tcx>(\n                 return compare_method_predicate_entailment(\n                     tcx,\n                     impl_m,\n-                    impl_m_span,\n                     trait_m,\n                     impl_trait_ref,\n                     CheckImpliedWfMode::Skip,\n@@ -535,9 +528,7 @@ enum CheckImpliedWfMode {\n fn compare_asyncness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n-    trait_item_span: Option<Span>,\n ) -> Result<(), ErrorGuaranteed> {\n     if tcx.asyncness(trait_m.def_id) == hir::IsAsync::Async {\n         match tcx.fn_sig(impl_m.def_id).skip_binder().skip_binder().output().kind() {\n@@ -549,9 +540,9 @@ fn compare_asyncness<'tcx>(\n             }\n             _ => {\n                 return Err(tcx.sess.emit_err(crate::errors::AsyncTraitImplShouldBeAsync {\n-                    span: impl_m_span,\n+                    span: tcx.def_span(impl_m.def_id),\n                     method_name: trait_m.name,\n-                    trait_item_span,\n+                    trait_item_span: tcx.hir().span_if_local(trait_m.def_id),\n                 }));\n             }\n         };\n@@ -606,7 +597,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n \n     // First, check a few of the same things as `compare_impl_method`,\n     // just so we don't ICE during substitution later.\n-    compare_number_of_generics(tcx, impl_m, trait_m, tcx.hir().span_if_local(impl_m.def_id), true)?;\n+    compare_number_of_generics(tcx, impl_m, trait_m, true)?;\n     compare_generic_param_kinds(tcx, impl_m, trait_m, true)?;\n     check_region_bounds_on_impl_item(tcx, impl_m, trait_m, true)?;\n \n@@ -1094,7 +1085,6 @@ fn extract_spans_for_error_reporting<'tcx>(\n fn compare_self_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n@@ -1116,7 +1106,7 @@ fn compare_self_type<'tcx>(\n \n         let infcx = tcx.infer_ctxt().build();\n         let self_arg_ty = tcx.liberate_late_bound_regions(method.def_id, self_arg_ty);\n-        let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n+        let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty);\n         match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n             ExplicitSelf::ByValue => \"self\".to_owned(),\n             ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n@@ -1130,6 +1120,7 @@ fn compare_self_type<'tcx>(\n \n         (false, true) => {\n             let self_descr = self_string(impl_m);\n+            let impl_m_span = tcx.def_span(impl_m.def_id);\n             let mut err = struct_span_err!(\n                 tcx.sess,\n                 impl_m_span,\n@@ -1149,6 +1140,7 @@ fn compare_self_type<'tcx>(\n \n         (true, false) => {\n             let self_descr = self_string(trait_m);\n+            let impl_m_span = tcx.def_span(impl_m.def_id);\n             let mut err = struct_span_err!(\n                 tcx.sess,\n                 impl_m_span,\n@@ -1196,7 +1188,6 @@ fn compare_number_of_generics<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_: &ty::AssocItem,\n     trait_: &ty::AssocItem,\n-    trait_span: Option<Span>,\n     delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_own_counts = tcx.generics_of(trait_.def_id).own_counts();\n@@ -1256,6 +1247,7 @@ fn compare_number_of_generics<'tcx>(\n                     .collect();\n                 (Some(arg_spans), impl_trait_spans)\n             } else {\n+                let trait_span = tcx.hir().span_if_local(trait_.def_id);\n                 (trait_span.map(|s| vec![s]), vec![])\n             };\n \n@@ -1338,9 +1330,7 @@ fn compare_number_of_generics<'tcx>(\n fn compare_number_of_method_arguments<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n-    trait_item_span: Option<Span>,\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n@@ -1362,7 +1352,7 @@ fn compare_number_of_method_arguments<'tcx>(\n                     }\n                 })\n             })\n-            .or(trait_item_span);\n+            .or_else(|| tcx.hir().span_if_local(trait_m.def_id));\n \n         let (impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n         let pos = impl_number_args.saturating_sub(1);\n@@ -1377,7 +1367,7 @@ fn compare_number_of_method_arguments<'tcx>(\n                     arg.span.with_lo(impl_m_sig.decl.inputs[0].span.lo())\n                 }\n             })\n-            .unwrap_or(impl_m_span);\n+            .unwrap_or_else(|| tcx.def_span(impl_m.def_id));\n \n         let mut err = struct_span_err!(\n             tcx.sess,\n@@ -1747,22 +1737,16 @@ pub(super) fn compare_impl_const_raw(\n pub(super) fn compare_impl_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_ty: &ty::AssocItem,\n-    impl_ty_span: Span,\n     trait_ty: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    trait_item_span: Option<Span>,\n ) {\n     debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let _: Result<(), ErrorGuaranteed> = try {\n-        compare_number_of_generics(tcx, impl_ty, trait_ty, trait_item_span, false)?;\n-\n+        compare_number_of_generics(tcx, impl_ty, trait_ty, false)?;\n         compare_generic_param_kinds(tcx, impl_ty, trait_ty, false)?;\n-\n-        let sp = tcx.def_span(impl_ty.def_id);\n-        compare_type_predicate_entailment(tcx, impl_ty, sp, trait_ty, impl_trait_ref)?;\n-\n-        check_type_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)?;\n+        compare_type_predicate_entailment(tcx, impl_ty, trait_ty, impl_trait_ref)?;\n+        check_type_bounds(tcx, trait_ty, impl_ty, impl_trait_ref)?;\n     };\n }\n \n@@ -1771,7 +1755,6 @@ pub(super) fn compare_impl_ty<'tcx>(\n fn compare_type_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_ty: &ty::AssocItem,\n-    impl_ty_span: Span,\n     trait_ty: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n@@ -1808,6 +1791,7 @@ fn compare_type_predicate_entailment<'tcx>(\n \n     debug!(\"compare_type_predicate_entailment: bounds={:?}\", hybrid_preds);\n \n+    let impl_ty_span = tcx.def_span(impl_ty_def_id);\n     let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_def_id);\n     let param_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&hybrid_preds.predicates),\n@@ -1873,7 +1857,6 @@ pub(super) fn check_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ty: &ty::AssocItem,\n     impl_ty: &ty::AssocItem,\n-    impl_ty_span: Span,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     // Given\n@@ -2009,8 +1992,15 @@ pub(super) fn check_type_bounds<'tcx>(\n     let infcx = tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(&infcx);\n \n-    let assumed_wf_types =\n-        ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty.def_id.expect_local());\n+    let impl_ty_span = match tcx.hir().get_by_def_id(impl_ty_def_id) {\n+        hir::Node::TraitItem(hir::TraitItem {\n+            kind: hir::TraitItemKind::Type(_, Some(ty)),\n+            ..\n+        }) => ty.span,\n+        hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Type(ty), .. }) => ty.span,\n+        _ => bug!(),\n+    };\n+    let assumed_wf_types = ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty_def_id);\n \n     let normalize_cause = ObligationCause::new(\n         impl_ty_span,"}, {"sha": "56ac18c492792ac0206ad56b88d0c63963e13eab", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -414,15 +414,15 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                 // Check that sym actually points to a function. Later passes\n                 // depend on this.\n                 hir::InlineAsmOperand::SymFn { anon_const } => {\n-                    let ty = self.tcx.typeck_body(anon_const.body).node_type(anon_const.hir_id);\n+                    let ty = self.tcx.type_of(anon_const.def_id);\n                     match ty.kind() {\n                         ty::Never | ty::Error(_) => {}\n                         ty::FnDef(..) => {}\n                         _ => {\n                             let mut err =\n                                 self.tcx.sess.struct_span_err(*op_sp, \"invalid `sym` operand\");\n                             err.span_label(\n-                                self.tcx.hir().span(anon_const.body.hir_id),\n+                                self.tcx.def_span(anon_const.def_id),\n                                 &format!(\"is {} `{}`\", ty.kind().article(), ty),\n                             );\n                             err.help(\"`sym` operands must refer to either a function or a static\");"}, {"sha": "7b013cabc3ab58bd7e4f3eeeb0206088458e03e4", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -75,7 +75,6 @@ pub use check::check_abi;\n use check::check_mod_item_types;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder};\n-use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_index::bit_set::BitSet;\n@@ -169,27 +168,24 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId) {\n     }\n }\n \n-fn report_forbidden_specialization(\n-    tcx: TyCtxt<'_>,\n-    impl_item: &hir::ImplItemRef,\n-    parent_impl: DefId,\n-) {\n+fn report_forbidden_specialization(tcx: TyCtxt<'_>, impl_item: DefId, parent_impl: DefId) {\n+    let span = tcx.def_span(impl_item);\n+    let ident = tcx.item_name(impl_item);\n     let mut err = struct_span_err!(\n         tcx.sess,\n-        impl_item.span,\n+        span,\n         E0520,\n-        \"`{}` specializes an item from a parent `impl`, but \\\n-         that item is not marked `default`\",\n-        impl_item.ident\n+        \"`{}` specializes an item from a parent `impl`, but that item is not marked `default`\",\n+        ident,\n     );\n-    err.span_label(impl_item.span, format!(\"cannot specialize default item `{}`\", impl_item.ident));\n+    err.span_label(span, format!(\"cannot specialize default item `{}`\", ident));\n \n     match tcx.span_of_impl(parent_impl) {\n         Ok(span) => {\n             err.span_label(span, \"parent `impl` is here\");\n             err.note(&format!(\n                 \"to specialize, `{}` in the parent `impl` must be marked `default`\",\n-                impl_item.ident\n+                ident\n             ));\n         }\n         Err(cname) => {"}, {"sha": "c64d507f82848772c1bf8480a5d5b9c8cabe3e86", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1716,7 +1716,7 @@ fn receiver_is_valid<'tcx>(\n     let cause =\n         ObligationCause::new(span, wfcx.body_def_id, traits::ObligationCauseCode::MethodReceiver);\n \n-    let can_eq_self = |ty| infcx.can_eq(wfcx.param_env, self_ty, ty).is_ok();\n+    let can_eq_self = |ty| infcx.can_eq(wfcx.param_env, self_ty, ty);\n \n     // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {"}, {"sha": "c0ba385987d77b60eeb34d4e7e449ceebc8bdc4b", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -202,8 +202,7 @@ fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'_>, impl_did: LocalDefId)\n fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\", impl_did);\n \n-    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n-    let span = tcx.hir().span(impl_hir_id);\n+    let span = tcx.def_span(impl_did);\n \n     let dispatch_from_dyn_trait = tcx.require_lang_item(LangItem::DispatchFromDyn, Some(span));\n "}, {"sha": "f0b6ab03ad69324b3619e9a04a3cdafd894d67c2", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 37, "deletions": 57, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -14,7 +14,6 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n-use rustc_span::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n pub fn crate_inherent_impls(tcx: TyCtxt<'_>, (): ()) -> CrateInherentImpls {\n@@ -57,99 +56,90 @@ const ADD_ATTR: &str =\n     \"alternatively add `#[rustc_allow_incoherent_impl]` to the relevant impl items\";\n \n impl<'tcx> InherentCollect<'tcx> {\n-    fn check_def_id(&mut self, item: &hir::Item<'_>, self_ty: Ty<'tcx>, def_id: DefId, span: Span) {\n-        let impl_def_id = item.owner_id;\n-        if let Some(def_id) = def_id.as_local() {\n+    fn check_def_id(&mut self, impl_def_id: LocalDefId, self_ty: Ty<'tcx>, ty_def_id: DefId) {\n+        if let Some(ty_def_id) = ty_def_id.as_local() {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            let vec = self.impls_map.inherent_impls.entry(def_id).or_default();\n+            let vec = self.impls_map.inherent_impls.entry(ty_def_id).or_default();\n             vec.push(impl_def_id.to_def_id());\n             return;\n         }\n \n         if self.tcx.features().rustc_attrs {\n-            let hir::ItemKind::Impl(&hir::Impl { items, .. }) = item.kind else {\n-                bug!(\"expected `impl` item: {:?}\", item);\n-            };\n+            let items = self.tcx.associated_item_def_ids(impl_def_id);\n \n-            if !self.tcx.has_attr(def_id, sym::rustc_has_incoherent_inherent_impls) {\n+            if !self.tcx.has_attr(ty_def_id, sym::rustc_has_incoherent_inherent_impls) {\n+                let impl_span = self.tcx.def_span(impl_def_id);\n                 struct_span_err!(\n                     self.tcx.sess,\n-                    span,\n+                    impl_span,\n                     E0390,\n                     \"cannot define inherent `impl` for a type outside of the crate where the type is defined\",\n                 )\n                 .help(INTO_DEFINING_CRATE)\n-                .span_help(span, ADD_ATTR_TO_TY)\n+                .span_help(impl_span, ADD_ATTR_TO_TY)\n                 .emit();\n                 return;\n             }\n \n-            for impl_item in items {\n-                if !self\n-                    .tcx\n-                    .has_attr(impl_item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n-                {\n+            for &impl_item in items {\n+                if !self.tcx.has_attr(impl_item, sym::rustc_allow_incoherent_impl) {\n+                    let impl_span = self.tcx.def_span(impl_def_id);\n                     struct_span_err!(\n                         self.tcx.sess,\n-                        span,\n+                        impl_span,\n                         E0390,\n                         \"cannot define inherent `impl` for a type outside of the crate where the type is defined\",\n                     )\n                     .help(INTO_DEFINING_CRATE)\n-                    .span_help(self.tcx.hir().span(impl_item.id.hir_id()), ADD_ATTR)\n+                    .span_help(self.tcx.def_span(impl_item), ADD_ATTR)\n                     .emit();\n                     return;\n                 }\n             }\n \n             if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) {\n-                self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id.def_id);\n+                self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n             } else {\n                 bug!(\"unexpected self type: {:?}\", self_ty);\n             }\n         } else {\n+            let impl_span = self.tcx.def_span(impl_def_id);\n             struct_span_err!(\n                 self.tcx.sess,\n-                span,\n+                impl_span,\n                 E0116,\n                 \"cannot define inherent `impl` for a type outside of the crate \\\n                               where the type is defined\"\n             )\n-            .span_label(span, \"impl for type defined outside of crate.\")\n+            .span_label(impl_span, \"impl for type defined outside of crate.\")\n             .note(\"define and implement a trait or new type instead\")\n             .emit();\n         }\n     }\n \n-    fn check_primitive_impl(\n-        &mut self,\n-        impl_def_id: LocalDefId,\n-        ty: Ty<'tcx>,\n-        items: &[hir::ImplItemRef],\n-        span: Span,\n-    ) {\n+    fn check_primitive_impl(&mut self, impl_def_id: LocalDefId, ty: Ty<'tcx>) {\n+        let items = self.tcx.associated_item_def_ids(impl_def_id);\n         if !self.tcx.hir().rustc_coherence_is_core() {\n             if self.tcx.features().rustc_attrs {\n-                for item in items {\n-                    if !self\n-                        .tcx\n-                        .has_attr(item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n-                    {\n+                for &impl_item in items {\n+                    if !self.tcx.has_attr(impl_item, sym::rustc_allow_incoherent_impl) {\n+                        let span = self.tcx.def_span(impl_def_id);\n                         struct_span_err!(\n                             self.tcx.sess,\n                             span,\n                             E0390,\n                             \"cannot define inherent `impl` for primitive types outside of `core`\",\n                         )\n                         .help(INTO_CORE)\n-                        .span_help(item.span, ADD_ATTR)\n+                        .span_help(self.tcx.def_span(impl_item), ADD_ATTR)\n                         .emit();\n                         return;\n                     }\n                 }\n             } else {\n+                let span = self.tcx.def_span(impl_def_id);\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     span,\n@@ -177,35 +167,27 @@ impl<'tcx> InherentCollect<'tcx> {\n     }\n \n     fn check_item(&mut self, id: hir::ItemId) {\n-        if !matches!(self.tcx.def_kind(id.owner_id), DefKind::Impl) {\n+        if !matches!(self.tcx.def_kind(id.owner_id), DefKind::Impl { of_trait: false }) {\n             return;\n         }\n \n-        let item = self.tcx.hir().item(id);\n-        let impl_span = self.tcx.hir().span(id.hir_id());\n-        let hir::ItemKind::Impl(hir::Impl { of_trait: None, items, .. }) = item.kind else {\n-            return;\n-        };\n-\n-        let self_ty = self.tcx.type_of(item.owner_id);\n+        let id = id.owner_id.def_id;\n+        let item_span = self.tcx.def_span(id);\n+        let self_ty = self.tcx.type_of(id);\n         match *self_ty.kind() {\n-            ty::Adt(def, _) => {\n-                self.check_def_id(item, self_ty, def.did(), impl_span);\n-            }\n-            ty::Foreign(did) => {\n-                self.check_def_id(item, self_ty, did, impl_span);\n-            }\n+            ty::Adt(def, _) => self.check_def_id(id, self_ty, def.did()),\n+            ty::Foreign(did) => self.check_def_id(id, self_ty, did),\n             ty::Dynamic(data, ..) if data.principal_def_id().is_some() => {\n-                self.check_def_id(item, self_ty, data.principal_def_id().unwrap(), impl_span);\n+                self.check_def_id(id, self_ty, data.principal_def_id().unwrap());\n             }\n             ty::Dynamic(..) => {\n                 struct_span_err!(\n                     self.tcx.sess,\n-                    impl_span,\n+                    item_span,\n                     E0785,\n                     \"cannot define inherent `impl` for a dyn auto trait\"\n                 )\n-                .span_label(impl_span, \"impl requires at least one non-auto trait\")\n+                .span_label(item_span, \"impl requires at least one non-auto trait\")\n                 .note(\"define and implement a new trait or type instead\")\n                 .emit();\n             }\n@@ -221,18 +203,16 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Ref(..)\n             | ty::Never\n             | ty::FnPtr(_)\n-            | ty::Tuple(..) => {\n-                self.check_primitive_impl(item.owner_id.def_id, self_ty, items, impl_span)\n-            }\n+            | ty::Tuple(..) => self.check_primitive_impl(id, self_ty),\n             ty::Alias(..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n-                    impl_span,\n+                    item_span,\n                     E0118,\n                     \"no nominal type found for inherent implementation\"\n                 );\n \n-                err.span_label(impl_span, \"impl requires a nominal type\")\n+                err.span_label(item_span, \"impl requires a nominal type\")\n                     .note(\"either implement a trait on it or create a newtype to wrap it instead\");\n \n                 err.emit();\n@@ -245,7 +225,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Bound(..)\n             | ty::Placeholder(_)\n             | ty::Infer(_) => {\n-                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.owner_id, self_ty);\n+                bug!(\"unexpected impl self type of impl: {:?} {:?}\", id, self_ty);\n             }\n             ty::Error(_) => {}\n         }"}, {"sha": "f0a0e7e3e929354e66d81f0e6d9f75abdfcc7270", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -39,25 +39,27 @@ fn do_orphan_check_impl<'tcx>(\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_def_id = trait_ref.def_id;\n \n-    let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(impl_) = item.kind else {\n-        bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n-    };\n-    let sp = tcx.def_span(def_id);\n-    let tr = impl_.of_trait.as_ref().unwrap();\n-\n-    match traits::orphan_check(tcx, item.owner_id.to_def_id()) {\n+    match traits::orphan_check(tcx, def_id.to_def_id()) {\n         Ok(()) => {}\n-        Err(err) => emit_orphan_check_error(\n-            tcx,\n-            sp,\n-            item.span,\n-            tr.path.span,\n-            trait_ref,\n-            impl_.self_ty.span,\n-            &impl_.generics,\n-            err,\n-        )?,\n+        Err(err) => {\n+            let item = tcx.hir().expect_item(def_id);\n+            let hir::ItemKind::Impl(impl_) = item.kind else {\n+                bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n+            };\n+            let tr = impl_.of_trait.as_ref().unwrap();\n+            let sp = tcx.def_span(def_id);\n+\n+            emit_orphan_check_error(\n+                tcx,\n+                sp,\n+                item.span,\n+                tr.path.span,\n+                trait_ref,\n+                impl_.self_ty.span,\n+                &impl_.generics,\n+                err,\n+            )?\n+        }\n     }\n \n     // In addition to the above rules, we restrict impls of auto traits\n@@ -235,7 +237,10 @@ fn do_orphan_check_impl<'tcx>(\n             | ty::GeneratorWitnessMIR(..)\n             | ty::Bound(..)\n             | ty::Placeholder(..)\n-            | ty::Infer(..) => span_bug!(sp, \"weird self type for autotrait impl\"),\n+            | ty::Infer(..) => {\n+                let sp = tcx.def_span(def_id);\n+                span_bug!(sp, \"weird self type for autotrait impl\")\n+            }\n \n             ty::Error(..) => (LocalImpl::Allow, NonlocalImpl::Allow),\n         };\n@@ -254,6 +259,7 @@ fn do_orphan_check_impl<'tcx>(\n                                 is one of the trait object's trait bounds\",\n                         trait = tcx.def_path_str(trait_def_id),\n                     );\n+                    let sp = tcx.def_span(def_id);\n                     let reported =\n                         struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).note(label).emit();\n                     return Err(reported);\n@@ -282,6 +288,7 @@ fn do_orphan_check_impl<'tcx>(\n                             non-struct/enum type\",\n                 )),\n             } {\n+                let sp = tcx.def_span(def_id);\n                 let reported =\n                     struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).span_label(sp, label).emit();\n                 return Err(reported);"}, {"sha": "d8606f759b24b30b1c9964917e0ff66205e0cfe8", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1563,7 +1563,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             // See issue #83753. If someone writes an associated type on a non-trait, just treat it as\n             // there being no supertrait HRTBs.\n             match tcx.def_kind(def_id) {\n-                DefKind::Trait | DefKind::TraitAlias | DefKind::Impl => {}\n+                DefKind::Trait | DefKind::TraitAlias | DefKind::Impl { .. } => {}\n                 _ => break None,\n             }\n "}, {"sha": "4f30318412d7e860c7aa719a971a0268b9e25dec", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -55,7 +55,7 @@ fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let min_specialization = tcx.features().min_specialization;\n     let module = tcx.hir_module_items(module_def_id);\n     for id in module.items() {\n-        if matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::Impl { .. }) {\n             enforce_impl_params_are_constrained(tcx, id.owner_id.def_id);\n             if min_specialization {\n                 check_min_specialization(tcx, id.owner_id.def_id);"}, {"sha": "76e87a9e566295dcd978a36df4f3f16650f40152", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -298,6 +298,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // call's arguments and we can provide a more explicit span.\n                 let sig = self.tcx.fn_sig(def_id).subst_identity();\n                 let def_self_ty = sig.input(0).skip_binder();\n+                let param_tys = sig.inputs().skip_binder().iter().skip(1);\n+                // If there's an arity mismatch, pointing out the call as the source of an inference\n+                // can be misleading, so we skip it.\n+                if param_tys.len() != args.len() {\n+                    continue;\n+                }\n                 let rcvr_ty = self.node_ty(rcvr.hir_id);\n                 // Get the evaluated type *after* calling the method call, so that the influence\n                 // of the arguments can be reflected in the receiver type. The receiver\n@@ -321,15 +327,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut param_args = FxHashMap::default();\n                 let mut param_expected = FxHashMap::default();\n                 let mut param_found = FxHashMap::default();\n-                if self.can_eq(self.param_env, ty, found).is_ok() {\n+                if self.can_eq(self.param_env, ty, found) {\n                     // We only point at the first place where the found type was inferred.\n-                    for (i, param_ty) in sig.inputs().skip_binder().iter().skip(1).enumerate() {\n+                    for (param_ty, arg) in param_tys.zip(args) {\n                         if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n                             // We found an argument that references a type parameter in `Self`,\n                             // so we assume that this is the argument that caused the found\n                             // type, which we know already because of `can_eq` above was first\n                             // inferred in this method call.\n-                            let arg = &args[i];\n                             let arg_ty = self.node_ty(arg.hir_id);\n                             if !arg.span.overlaps(mismatch_span) {\n                                 err.span_label(\n@@ -369,7 +374,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 for (param, (arg, arg_ty)) in param_args.iter() {\n                     let Some(expected) = param_expected.get(param) else { continue; };\n                     let Some(found) = param_found.get(param) else { continue; };\n-                    if self.can_eq(self.param_env, *arg_ty, *found).is_err() { continue; }\n+                    if !self.can_eq(self.param_env, *arg_ty, *found) { continue; }\n                     self.emit_coerce_suggestions(err, arg, *found, *expected, None, None);\n                 }\n \n@@ -379,7 +384,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 if ty != prev\n                     && param_args.is_empty()\n-                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                    && self.can_eq(self.param_env, ty, found)\n                 {\n                     // We only point at the first place where the found type was inferred.\n                     if !segment.ident.span.overlaps(mismatch_span) {\n@@ -401,7 +406,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 if ty != prev\n                     && let Some(span) = prev_span\n-                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                    && self.can_eq(self.param_env, ty, found)\n                 {\n                     // We only point at the first place where the found type was inferred.\n                     // We use the *previous* span because if the type is known *here* it means\n@@ -764,7 +769,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let ty::Adt(expected_adt, substs) = expected.kind() {\n             if let hir::ExprKind::Field(base, ident) = expr.kind {\n                 let base_ty = self.typeck_results.borrow().expr_ty(base);\n-                if self.can_eq(self.param_env, base_ty, expected).is_ok()\n+                if self.can_eq(self.param_env, base_ty, expected)\n                     && let Some(base_span) = base.span.find_ancestor_inside(expr.span)\n                 {\n                     err.span_suggestion_verbose(\n@@ -1357,7 +1362,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref expr),\n                 _,\n                 &ty::Ref(_, checked, _),\n-            ) if self.can_sub(self.param_env, checked, expected).is_ok() => {\n+            ) if self.can_sub(self.param_env, checked, expected) => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest removing a `&`.\n                 if sm.is_imported(expr.span) {\n@@ -2003,7 +2008,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n         let hir::StmtKind::Semi(tail_expr) = stmt.kind else { return; };\n         let Some(ty) = self.node_ty_opt(tail_expr.hir_id) else { return; };\n-        if self.can_eq(self.param_env, expected_ty, ty).is_ok() {\n+        if self.can_eq(self.param_env, expected_ty, ty) {\n             err.span_suggestion_short(\n                 stmt.span.with_lo(tail_expr.span.hi()),\n                 \"remove this semicolon\","}, {"sha": "7ce721e94cb238d938403bac1b78e48404051f31", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1015,7 +1015,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let expr_inner_ty = substs.type_at(0);\n             let expected_inner_ty = expected_substs.type_at(0);\n             if let ty::Ref(_, ty, hir::Mutability::Not) = expr_inner_ty.kind()\n-                && self.can_eq(self.param_env, *ty, expected_inner_ty).is_ok()\n+                && self.can_eq(self.param_env, *ty, expected_inner_ty)\n             {\n                 let def_path = self.tcx.def_path_str(adt_def.did());\n                 if self.type_is_copy_modulo_regions(self.param_env, *ty, expr.span) {\n@@ -1054,7 +1054,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some(result_did) = self.tcx.get_diagnostic_item(sym::Result)\n             && adt_def.did() == result_did\n             // Check that the error types are equal\n-            && self.can_eq(self.param_env, substs.type_at(1), expected_substs.type_at(1)).is_ok()\n+            && self.can_eq(self.param_env, substs.type_at(1), expected_substs.type_at(1))\n         {\n             return suggest_copied_or_cloned();\n         } else if let Some(option_did) = self.tcx.get_diagnostic_item(sym::Option)"}, {"sha": "a35fa008a9557793c9e88de163f94dc25efb1247", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -517,8 +517,7 @@ fn method_autoderef_steps<'tcx>(\n         .by_ref()\n         .map(|(ty, d)| {\n             let step = CandidateStep {\n-                self_ty: infcx\n-                    .make_query_response_ignoring_pending_obligations(inference_vars.clone(), ty),\n+                self_ty: infcx.make_query_response_ignoring_pending_obligations(inference_vars, ty),\n                 autoderefs: d,\n                 from_unsafe_deref: reached_raw_pointer,\n                 unsize: false,\n@@ -936,7 +935,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         return false;\n                     }\n                 }\n-                self.can_sub(self.param_env, fty.output(), expected).is_ok()\n+                self.can_sub(self.param_env, fty.output(), expected)\n             }),\n             _ => false,\n         }"}, {"sha": "3881efe87db5c4030cd11920b9f73210c718db2d", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             self.demand_eqtype_with_origin(&self.pattern_cause(ti, cause_span), expected, actual)?;\n         if let Some(expr) = ti.origin_expr {\n             self.suggest_fn_call(&mut diag, expr, expected, |output| {\n-                self.can_eq(self.param_env, output, actual).is_ok()\n+                self.can_eq(self.param_env, output, actual)\n             });\n         }\n         Some(diag)\n@@ -675,7 +675,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         match (expected.kind(), actual.kind(), ba) {\n             (ty::Ref(_, inner_ty, _), _, hir::BindingAnnotation::NONE)\n-                if self.can_eq(self.param_env, *inner_ty, actual).is_ok() =>\n+                if self.can_eq(self.param_env, *inner_ty, actual) =>\n             {\n                 err.span_suggestion_verbose(\n                     span.shrink_to_lo(),\n@@ -685,7 +685,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n             (_, ty::Ref(_, inner_ty, _), hir::BindingAnnotation::REF)\n-                if self.can_eq(self.param_env, expected, *inner_ty).is_ok() =>\n+                if self.can_eq(self.param_env, expected, *inner_ty) =>\n             {\n                 err.span_suggestion_verbose(\n                     span.with_hi(span.lo() + BytePos(4)),"}, {"sha": "0c2713fb1a7c80d61620f700017799b5c5ea0b5d", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -933,3 +933,216 @@ pub struct ButNeedsToSatisfy {\n     pub has_lifetime: bool,\n     pub lifetime: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_outlives_content, code = \"E0312\")]\n+pub struct OutlivesContent<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_outlives_bound, code = \"E0476\")]\n+pub struct OutlivesBound<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_fullfill_req_lifetime, code = \"E0477\")]\n+pub struct FullfillReqLifetime<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+    #[subdiagnostic]\n+    pub note: Option<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_lf_bound_not_satisfied, code = \"E0478\")]\n+pub struct LfBoundNotSatisfied<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_ref_longer_than_data, code = \"E0491\")]\n+pub struct RefLongerThanData<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum WhereClauseSuggestions {\n+    #[suggestion(\n+        infer_where_remove,\n+        code = \"\",\n+        applicability = \"machine-applicable\",\n+        style = \"verbose\"\n+    )]\n+    Remove {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(\n+        infer_where_copy_predicates,\n+        code = \"{space}where {trait_predicates}\",\n+        applicability = \"machine-applicable\",\n+        style = \"verbose\"\n+    )]\n+    CopyPredicates {\n+        #[primary_span]\n+        span: Span,\n+        space: &'static str,\n+        trait_predicates: String,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestRemoveSemiOrReturnBinding {\n+    #[multipart_suggestion(infer_srs_remove_and_box, applicability = \"machine-applicable\")]\n+    RemoveAndBox {\n+        #[suggestion_part(code = \"Box::new(\")]\n+        first_lo: Span,\n+        #[suggestion_part(code = \")\")]\n+        first_hi: Span,\n+        #[suggestion_part(code = \"Box::new(\")]\n+        second_lo: Span,\n+        #[suggestion_part(code = \")\")]\n+        second_hi: Span,\n+        #[suggestion_part(code = \"\")]\n+        sp: Span,\n+    },\n+    #[suggestion(\n+        infer_srs_remove,\n+        style = \"short\",\n+        code = \"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Remove {\n+        #[primary_span]\n+        sp: Span,\n+    },\n+    #[suggestion(\n+        infer_srs_add,\n+        style = \"verbose\",\n+        code = \"{code}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    Add {\n+        #[primary_span]\n+        sp: Span,\n+        code: String,\n+        ident: Ident,\n+    },\n+    #[note(infer_srs_add_one)]\n+    AddOne {\n+        #[primary_span]\n+        spans: MultiSpan,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ConsiderAddingAwait {\n+    #[help(infer_await_both_futures)]\n+    BothFuturesHelp,\n+    #[multipart_suggestion(infer_await_both_futures, applicability = \"maybe-incorrect\")]\n+    BothFuturesSugg {\n+        #[suggestion_part(code = \".await\")]\n+        first: Span,\n+        #[suggestion_part(code = \".await\")]\n+        second: Span,\n+    },\n+    #[suggestion(\n+        infer_await_future,\n+        code = \".await\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    FutureSugg {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(infer_await_note)]\n+    FutureSuggNote {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[multipart_suggestion(\n+        infer_await_future,\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    FutureSuggMultiple {\n+        #[suggestion_part(code = \".await\")]\n+        spans: Vec<Span>,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum PlaceholderRelationLfNotSatisfied {\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasBoth {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_with_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_with_sup)]\n+        sup_span: Span,\n+        sub_symbol: Symbol,\n+        sup_symbol: Symbol,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasSub {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_with_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_without_sup)]\n+        sup_span: Span,\n+        sub_symbol: Symbol,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasSup {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_without_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_with_sup)]\n+        sup_span: Span,\n+        sup_symbol: Symbol,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasNone {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_without_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_without_sup)]\n+        sup_span: Span,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    OnlyPrimarySpan {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+}"}, {"sha": "cb96aeec5f34f4c11d83ad3feb83d74d98e9d920", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -121,16 +121,42 @@ impl<'a> DescriptionCtx<'a> {\n \n pub enum PrefixKind {\n     Empty,\n+    RefValidFor,\n+    ContentValidFor,\n+    TypeObjValidFor,\n+    SourcePointerValidFor,\n+    TypeSatisfy,\n+    TypeOutlive,\n+    LfParamInstantiatedWith,\n+    LfParamMustOutlive,\n+    LfInstantiatedWith,\n+    LfMustOutlive,\n+    PointerValidFor,\n+    DataValidFor,\n }\n \n pub enum SuffixKind {\n+    Empty,\n     Continues,\n+    ReqByBinding,\n }\n \n impl IntoDiagnosticArg for PrefixKind {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n         let kind = match self {\n             Self::Empty => \"empty\",\n+            Self::RefValidFor => \"ref_valid_for\",\n+            Self::ContentValidFor => \"content_valid_for\",\n+            Self::TypeObjValidFor => \"type_obj_valid_for\",\n+            Self::SourcePointerValidFor => \"source_pointer_valid_for\",\n+            Self::TypeSatisfy => \"type_satisfy\",\n+            Self::TypeOutlive => \"type_outlive\",\n+            Self::LfParamInstantiatedWith => \"lf_param_instantiated_with\",\n+            Self::LfParamMustOutlive => \"lf_param_must_outlive\",\n+            Self::LfInstantiatedWith => \"lf_instantiated_with\",\n+            Self::LfMustOutlive => \"lf_must_outlive\",\n+            Self::PointerValidFor => \"pointer_valid_for\",\n+            Self::DataValidFor => \"data_valid_for\",\n         }\n         .into();\n         rustc_errors::DiagnosticArgValue::Str(kind)\n@@ -140,7 +166,9 @@ impl IntoDiagnosticArg for PrefixKind {\n impl IntoDiagnosticArg for SuffixKind {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n         let kind = match self {\n+            Self::Empty => \"empty\",\n             Self::Continues => \"continues\",\n+            Self::ReqByBinding => \"req_by_binding\",\n         }\n         .into();\n         rustc_errors::DiagnosticArgValue::Str(kind)\n@@ -166,17 +194,19 @@ impl RegionExplanation<'_> {\n }\n \n impl AddToDiagnostic for RegionExplanation<'_> {\n-    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n     where\n         F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n     {\n-        if let Some(span) = self.desc.span {\n-            diag.span_note(span, fluent::infer_region_explanation);\n-        } else {\n-            diag.note(fluent::infer_region_explanation);\n-        }\n-        self.desc.add_to(diag);\n         diag.set_arg(\"pref_kind\", self.prefix);\n         diag.set_arg(\"suff_kind\", self.suffix);\n+        let desc_span = self.desc.span;\n+        self.desc.add_to(diag);\n+        let msg = f(diag, fluent::infer_region_explanation.into());\n+        if let Some(span) = desc_span {\n+            diag.span_note(span, msg);\n+        } else {\n+            diag.note(msg);\n+        }\n     }\n }"}, {"sha": "bb7947e3141ba7bde55a53a9620201737d644671", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -751,15 +751,16 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     };\n                     let msg = \"`match` arms have incompatible types\";\n                     err.span_label(outer, msg);\n-                    self.suggest_remove_semi_or_return_binding(\n-                        err,\n+                    if let Some(subdiag) = self.suggest_remove_semi_or_return_binding(\n                         prior_arm_block_id,\n                         prior_arm_ty,\n                         prior_arm_span,\n                         arm_block_id,\n                         arm_ty,\n                         arm_span,\n-                    );\n+                    ) {\n+                        err.subdiagnostic(subdiag);\n+                    }\n                     if let Some(ret_sp) = opt_suggest_box_span {\n                         // Get return type span and point to it.\n                         self.suggest_boxing_for_return_impl_trait(\n@@ -784,15 +785,16 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 if let Some(sp) = outer_span {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n                 }\n-                self.suggest_remove_semi_or_return_binding(\n-                    err,\n+                if let Some(subdiag) = self.suggest_remove_semi_or_return_binding(\n                     Some(then_id),\n                     then_ty,\n                     then_span,\n                     Some(else_id),\n                     else_ty,\n                     else_span,\n-                );\n+                ) {\n+                    err.subdiagnostic(subdiag);\n+                }\n                 if let Some(ret_sp) = opt_suggest_box_span {\n                     self.suggest_boxing_for_return_impl_trait(\n                         err,"}, {"sha": "2b5a19914a327112047f0a743a56441e268d7b25", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1061,7 +1061,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                 };\n \n                 let parent_def_id = generics.parent.unwrap();\n-                if tcx.def_kind(parent_def_id) == DefKind::Impl {\n+                if let DefKind::Impl { .. } = tcx.def_kind(parent_def_id) {\n                     let parent_ty = tcx.bound_type_of(parent_def_id).subst(tcx, substs);\n                     match (parent_ty.kind(), &ty.kind) {\n                         ("}, {"sha": "e8d94f0c04eaaa69db8eddaa0f8d3fca09f241bc", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_relation.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,5 +1,8 @@\n-use crate::infer::{\n-    error_reporting::nice_region_error::NiceRegionError, RegionResolutionError, SubregionOrigin,\n+use crate::{\n+    errors::PlaceholderRelationLfNotSatisfied,\n+    infer::{\n+        error_reporting::nice_region_error::NiceRegionError, RegionResolutionError, SubregionOrigin,\n+    },\n };\n use rustc_data_structures::intern::Interned;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n@@ -16,8 +19,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 Region(Interned(RePlaceholder(ty::Placeholder { name: sub_name, .. }), _)),\n                 Region(Interned(RePlaceholder(ty::Placeholder { name: sup_name, .. }), _)),\n             )) => {\n-                let msg = \"lifetime bound not satisfied\";\n-                let mut err = self.tcx().sess.struct_span_err(*span, msg);\n+                let span = *span;\n                 let (sub_span, sub_symbol) = match sub_name {\n                     ty::BrNamed(def_id, symbol) => {\n                         (Some(self.tcx().def_span(def_id)), Some(symbol))\n@@ -32,41 +34,47 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                     ty::BrAnon(_, span) => (*span, None),\n                     ty::BrEnv => (None, None),\n                 };\n-                match (sub_span, sup_span, sub_symbol, sup_symbol) {\n-                    (Some(sub_span), Some(sup_span), Some(sub_symbol), Some(sup_symbol)) => {\n-                        err.span_note(\n+                let diag = match (sub_span, sup_span, sub_symbol, sup_symbol) {\n+                    (Some(sub_span), Some(sup_span), Some(&sub_symbol), Some(&sup_symbol)) => {\n+                        PlaceholderRelationLfNotSatisfied::HasBoth {\n+                            span,\n                             sub_span,\n-                            format!(\"the lifetime `{sub_symbol}` defined here...\"),\n-                        );\n-                        err.span_note(\n                             sup_span,\n-                            format!(\"...must outlive the lifetime `{sup_symbol}` defined here\"),\n-                        );\n+                            sub_symbol,\n+                            sup_symbol,\n+                            note: (),\n+                        }\n                     }\n-                    (Some(sub_span), Some(sup_span), _, Some(sup_symbol)) => {\n-                        err.span_note(sub_span, \"the lifetime defined here...\");\n-                        err.span_note(\n+                    (Some(sub_span), Some(sup_span), _, Some(&sup_symbol)) => {\n+                        PlaceholderRelationLfNotSatisfied::HasSup {\n+                            span,\n+                            sub_span,\n                             sup_span,\n-                            format!(\"...must outlive the lifetime `{sup_symbol}` defined here\"),\n-                        );\n+                            sup_symbol,\n+                            note: (),\n+                        }\n                     }\n-                    (Some(sub_span), Some(sup_span), Some(sub_symbol), _) => {\n-                        err.span_note(\n+                    (Some(sub_span), Some(sup_span), Some(&sub_symbol), _) => {\n+                        PlaceholderRelationLfNotSatisfied::HasSub {\n+                            span,\n                             sub_span,\n-                            format!(\"the lifetime `{sub_symbol}` defined here...\"),\n-                        );\n-                        err.span_note(sup_span, \"...must outlive the lifetime defined here\");\n+                            sup_span,\n+                            sub_symbol,\n+                            note: (),\n+                        }\n                     }\n                     (Some(sub_span), Some(sup_span), _, _) => {\n-                        err.span_note(sub_span, \"the lifetime defined here...\");\n-                        err.span_note(sup_span, \"...must outlive the lifetime defined here\");\n+                        PlaceholderRelationLfNotSatisfied::HasNone {\n+                            span,\n+                            sub_span,\n+                            sup_span,\n+                            note: (),\n+                        }\n                     }\n-                    _ => {}\n-                }\n-                err.note(\"this is a known limitation that will be removed in the future (see issue #100013 <https://github.com/rust-lang/rust/issues/100013> for more information)\");\n-                Some(err)\n+                    _ => PlaceholderRelationLfNotSatisfied::OnlyPrimarySpan { span, note: () },\n+                };\n+                Some(self.tcx().sess.create_err(diag))\n             }\n-\n             _ => None,\n         }\n     }"}, {"sha": "e0e89158a58386ec0e7eb4dd944dfef060e089c7", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 83, "deletions": 111, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,9 +1,11 @@\n-use crate::errors::RegionOriginNote;\n+use crate::errors::{\n+    note_and_explain, FullfillReqLifetime, LfBoundNotSatisfied, OutlivesBound, OutlivesContent,\n+    RefLongerThanData, RegionOriginNote, WhereClauseSuggestions,\n+};\n use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n use crate::infer::{self, SubregionOrigin};\n use rustc_errors::{\n-    fluent, struct_span_err, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed,\n+    fluent, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic,\n };\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::traits::ObligationCauseCode;\n@@ -119,130 +121,105 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 err\n             }\n             infer::Reborrow(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0312,\n-                    \"lifetime of reference outlives lifetime of borrowed content...\"\n-                );\n-                note_and_explain_region(\n+                let reference_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"...the reference is valid for \",\n                     sub,\n-                    \"...\",\n                     None,\n+                    note_and_explain::PrefixKind::RefValidFor,\n+                    note_and_explain::SuffixKind::Continues,\n                 );\n-                note_and_explain_region(\n+                let content_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"...but the borrowed content is only valid for \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::ContentValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                OutlivesContent {\n+                    span,\n+                    notes: reference_valid.into_iter().chain(content_valid).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateObjectBound(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0476,\n-                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n-                     object type\"\n-                );\n-                note_and_explain_region(\n+                let object_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"object type is valid for \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::TypeObjValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let pointer_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"source pointer is only valid for \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::SourcePointerValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                OutlivesBound {\n+                    span,\n+                    notes: object_valid.into_iter().chain(pointer_valid).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateParamBound(span, ty, opt_span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0477,\n-                    \"the type `{}` does not fulfill the required lifetime\",\n-                    self.ty_to_string(ty)\n+                let prefix = match *sub {\n+                    ty::ReStatic => note_and_explain::PrefixKind::TypeSatisfy,\n+                    _ => note_and_explain::PrefixKind::TypeOutlive,\n+                };\n+                let suffix = if opt_span.is_some() {\n+                    note_and_explain::SuffixKind::ReqByBinding\n+                } else {\n+                    note_and_explain::SuffixKind::Empty\n+                };\n+                let note = note_and_explain::RegionExplanation::new(\n+                    self.tcx, sub, opt_span, prefix, suffix,\n                 );\n-                match *sub {\n-                    ty::ReStatic => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must satisfy \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                    _ => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must outlive \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                }\n-                err\n+                FullfillReqLifetime { span, ty: self.resolve_vars_if_possible(ty), note }\n+                    .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateRegionParamBound(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n+                let param_instantiated = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"lifetime parameter instantiated with \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfParamInstantiatedWith,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let param_must_outlive = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"but lifetime parameter must outlive \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfParamMustOutlive,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                LfBoundNotSatisfied {\n+                    span,\n+                    notes: param_instantiated.into_iter().chain(param_must_outlive).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0491,\n-                    \"in type `{}`, reference has a longer lifetime than the data it references\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n+                let pointer_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"the pointer is valid for \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::PointerValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let data_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"but the referenced data is only valid for \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::DataValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                RefLongerThanData {\n+                    span,\n+                    ty: self.resolve_vars_if_possible(ty),\n+                    notes: pointer_valid.into_iter().chain(data_valid).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => {\n                 let mut err = self.report_extra_impl_obligation(\n@@ -279,25 +256,25 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 err\n             }\n             infer::AscribeUserTypeProvePredicate(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n+                let instantiated = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"lifetime instantiated with \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfInstantiatedWith,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let must_outlive = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"but lifetime must outlive \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfMustOutlive,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                LfBoundNotSatisfied {\n+                    span,\n+                    notes: instantiated.into_iter().chain(must_outlive).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n         };\n         if sub.is_error() || sup.is_error() {\n@@ -347,22 +324,17 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n         let Some(generics) = self.tcx.hir().get_generics(impl_item_def_id) else { return; };\n \n-        if trait_predicates.is_empty() {\n-            err.span_suggestion_verbose(\n-                generics.where_clause_span,\n-                \"remove the `where` clause\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n+        let suggestion = if trait_predicates.is_empty() {\n+            WhereClauseSuggestions::Remove { span: generics.where_clause_span }\n         } else {\n             let space = if generics.where_clause_span.is_empty() { \" \" } else { \"\" };\n-            err.span_suggestion_verbose(\n-                generics.where_clause_span,\n-                \"copy the `where` clause predicates from the trait\",\n-                format!(\"{space}where {}\", trait_predicates.join(\", \")),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n+            WhereClauseSuggestions::CopyPredicates {\n+                span: generics.where_clause_span,\n+                space,\n+                trait_predicates: trait_predicates.join(\", \"),\n+            }\n+        };\n+        err.subdiagnostic(suggestion);\n     }\n \n     pub(super) fn report_placeholder_failure("}, {"sha": "b6337d6853fa3c835a095c427aea97099df672ec", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -504,7 +504,9 @@ fn foo(&self) -> Self::T { String::new() }\n         let methods: Vec<(Span, String)> = items\n             .in_definition_order()\n             .filter(|item| {\n-                ty::AssocKind::Fn == item.kind && Some(item.name) != current_method_ident\n+                ty::AssocKind::Fn == item.kind\n+                    && Some(item.name) != current_method_ident\n+                    && !tcx.is_doc_hidden(item.def_id)\n             })\n             .filter_map(|item| {\n                 let method = tcx.fn_sig(item.def_id).subst_identity();\n@@ -576,7 +578,7 @@ fn foo(&self) -> Self::T { String::new() }\n                                 tcx.impl_defaultness(item.id.owner_id)\n                             {\n                                 let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n-                                if self.infcx.can_eq(param_env, assoc_ty, found).is_ok() {\n+                                if self.infcx.can_eq(param_env, assoc_ty, found) {\n                                     diag.span_label(\n                                         item.span,\n                                         \"associated type defaults can't be assumed inside the \\\n@@ -598,7 +600,7 @@ fn foo(&self) -> Self::T { String::new() }\n                     if let hir::AssocItemKind::Type = item.kind {\n                         let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n \n-                        if self.infcx.can_eq(param_env, assoc_ty, found).is_ok() {\n+                        if self.infcx.can_eq(param_env, assoc_ty, found) {\n                             diag.span_label(item.span, \"expected this associated type\");\n                             return true;\n                         }"}, {"sha": "18c5097a26289d5530f9a2600768808e522cfe62", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 70, "deletions": 77, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -11,21 +11,22 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self as ty, IsSuggestable, Ty, TypeVisitable};\n use rustc_span::{sym, BytePos, Span};\n \n-use crate::errors::SuggAddLetForLetChains;\n+use crate::errors::{\n+    ConsiderAddingAwait, SuggAddLetForLetChains, SuggestRemoveSemiOrReturnBinding,\n+};\n \n use super::TypeErrCtxt;\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub(super) fn suggest_remove_semi_or_return_binding(\n         &self,\n-        err: &mut Diagnostic,\n         first_id: Option<hir::HirId>,\n         first_ty: Ty<'tcx>,\n         first_span: Span,\n         second_id: Option<hir::HirId>,\n         second_ty: Ty<'tcx>,\n         second_span: Span,\n-    ) {\n+    ) -> Option<SuggestRemoveSemiOrReturnBinding> {\n         let remove_semicolon = [\n             (first_id, self.resolve_vars_if_possible(second_ty)),\n             (second_id, self.resolve_vars_if_possible(first_ty)),\n@@ -37,35 +38,29 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         });\n         match remove_semicolon {\n             Some((sp, StatementAsExpression::NeedsBoxing)) => {\n-                err.multipart_suggestion(\n-                    \"consider removing this semicolon and boxing the expressions\",\n-                    vec![\n-                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (first_span.shrink_to_hi(), \")\".to_string()),\n-                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (second_span.shrink_to_hi(), \")\".to_string()),\n-                        (sp, String::new()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n+                Some(SuggestRemoveSemiOrReturnBinding::RemoveAndBox {\n+                    first_lo: first_span.shrink_to_lo(),\n+                    first_hi: first_span.shrink_to_hi(),\n+                    second_lo: second_span.shrink_to_lo(),\n+                    second_hi: second_span.shrink_to_hi(),\n+                    sp,\n+                })\n             }\n             Some((sp, StatementAsExpression::CorrectType)) => {\n-                err.span_suggestion_short(\n-                    sp,\n-                    \"consider removing this semicolon\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n+                Some(SuggestRemoveSemiOrReturnBinding::Remove { sp })\n             }\n             None => {\n+                let mut ret = None;\n                 for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n                     if let Some(id) = id\n                         && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n-                        && self.consider_returning_binding(blk, ty, err)\n+                        && let Some(diag) = self.consider_returning_binding_diag(blk, ty)\n                     {\n+                        ret = Some(diag);\n                         break;\n                     }\n                 }\n+                ret\n             }\n         }\n     }\n@@ -198,7 +193,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             return;\n         }\n \n-        match (\n+        let subdiag = match (\n             self.get_impl_future_output_ty(exp_found.expected),\n             self.get_impl_future_output_ty(exp_found.found),\n         ) {\n@@ -207,65 +202,56 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             {\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n                     let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    diag.multipart_suggestion(\n-                        \"consider `await`ing on both `Future`s\",\n-                        vec![\n-                            (then_span.shrink_to_hi(), \".await\".to_string()),\n-                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    Some(ConsiderAddingAwait::BothFuturesSugg {\n+                        first: then_span.shrink_to_hi(),\n+                        second: exp_span.shrink_to_hi(),\n+                    })\n                 }\n                 ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                     prior_arms,\n                     ..\n                 }) => {\n                     if let [.., arm_span] = &prior_arms[..] {\n-                        diag.multipart_suggestion(\n-                            \"consider `await`ing on both `Future`s\",\n-                            vec![\n-                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n-                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        Some(ConsiderAddingAwait::BothFuturesSugg {\n+                            first: arm_span.shrink_to_hi(),\n+                            second: exp_span.shrink_to_hi(),\n+                        })\n                     } else {\n-                        diag.help(\"consider `await`ing on both `Future`s\");\n+                        Some(ConsiderAddingAwait::BothFuturesHelp)\n                     }\n                 }\n-                _ => {\n-                    diag.help(\"consider `await`ing on both `Future`s\");\n-                }\n+                _ => Some(ConsiderAddingAwait::BothFuturesHelp),\n             },\n             (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n-                self.suggest_await_on_future(diag, exp_span);\n-                diag.span_note(exp_span, \"calling an async function returns a future\");\n+                // FIXME: Seems like we can't have a suggestion and a note with different spans in a single subdiagnostic\n+                diag.subdiagnostic(ConsiderAddingAwait::FutureSugg {\n+                    span: exp_span.shrink_to_hi(),\n+                });\n+                Some(ConsiderAddingAwait::FutureSuggNote { span: exp_span })\n             }\n             (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n             {\n                 ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n-                    self.suggest_await_on_future(diag, then_span.shrink_to_hi());\n+                    Some(ConsiderAddingAwait::FutureSugg { span: then_span.shrink_to_hi() })\n                 }\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n                     let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    self.suggest_await_on_future(diag, then_span.shrink_to_hi());\n+                    Some(ConsiderAddingAwait::FutureSugg { span: then_span.shrink_to_hi() })\n                 }\n                 ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                     ref prior_arms,\n                     ..\n-                }) => {\n-                    diag.multipart_suggestion_verbose(\n-                        \"consider `await`ing on the `Future`\",\n-                        prior_arms\n-                            .iter()\n-                            .map(|arm| (arm.shrink_to_hi(), \".await\".to_string()))\n-                            .collect(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                _ => {}\n+                }) => Some({\n+                    ConsiderAddingAwait::FutureSuggMultiple {\n+                        spans: prior_arms.iter().map(|arm| arm.shrink_to_hi()).collect(),\n+                    }\n+                }),\n+                _ => None,\n             },\n-            _ => {}\n+            _ => None,\n+        };\n+        if let Some(subdiag) = subdiag {\n+            diag.subdiagnostic(subdiag);\n         }\n     }\n \n@@ -655,16 +641,15 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n     /// Suggest returning a local binding with a compatible type if the block\n     /// has no return expression.\n-    pub fn consider_returning_binding(\n+    pub fn consider_returning_binding_diag(\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n-        err: &mut Diagnostic,\n-    ) -> bool {\n+    ) -> Option<SuggestRemoveSemiOrReturnBinding> {\n         let blk = blk.innermost_block();\n         // Do not suggest if we have a tail expr.\n         if blk.expr.is_some() {\n-            return false;\n+            return None;\n         }\n         let mut shadowed = FxIndexSet::default();\n         let mut candidate_idents = vec![];\n@@ -733,7 +718,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         match &candidate_idents[..] {\n             [(ident, _ty)] => {\n                 let sm = self.tcx.sess.source_map();\n-                if let Some(stmt) = blk.stmts.last() {\n+                let (span, sugg) = if let Some(stmt) = blk.stmts.last() {\n                     let stmt_span = sm.stmt_span(stmt.span, blk.span);\n                     let sugg = if sm.is_multiline(blk.span)\n                         && let Some(spacing) = sm.indentation_before(stmt_span)\n@@ -742,12 +727,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     } else {\n                         format!(\" {ident}\")\n                     };\n-                    err.span_suggestion_verbose(\n-                        stmt_span.shrink_to_hi(),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    (stmt_span.shrink_to_hi(), sugg)\n                 } else {\n                     let sugg = if sm.is_multiline(blk.span)\n                         && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n@@ -757,21 +737,34 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         format!(\" {ident} \")\n                     };\n                     let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n-                    err.span_suggestion_verbose(\n+                    (\n                         sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n                         sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                true\n+                    )\n+                };\n+                Some(SuggestRemoveSemiOrReturnBinding::Add { sp: span, code: sugg, ident: *ident })\n             }\n             values if (1..3).contains(&values.len()) => {\n                 let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n-                err.span_note(spans, \"consider returning one of these bindings\");\n+                Some(SuggestRemoveSemiOrReturnBinding::AddOne { spans: spans.into() })\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn consider_returning_binding(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) -> bool {\n+        let diag = self.consider_returning_binding_diag(blk, expected_ty);\n+        match diag {\n+            Some(diag) => {\n+                err.subdiagnostic(diag);\n                 true\n             }\n-            _ => false,\n+            None => false,\n         }\n     }\n }"}, {"sha": "17e734f0700321bfd4abbaae605029566968106b", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -880,30 +880,20 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n     }\n \n-    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| {\n-            self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n-        })\n+        self.probe(|_| self.at(origin, param_env).sub(a, b).is_ok())\n     }\n \n-    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| {\n-            self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n-        })\n+        self.probe(|_| self.at(origin, param_env).eq(a, b).is_ok())\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "ac32988d3ac6e7543ecd97c0af2c4b471fcfd95a", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -691,7 +691,6 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(proc_macro_execution_strategy, ProcMacroExecutionStrategy::CrossThread);\n     untracked!(profile_closures, true);\n     untracked!(query_dep_graph, true);\n-    untracked!(save_analysis, true);\n     untracked!(self_profile, SwitchWithOptPath::Enabled(None));\n     untracked!(self_profile_events, Some(vec![String::new()]));\n     untracked!(span_debug, true);"}, {"sha": "43047051f0f65578020c7129ae0f990b729ab32e", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -838,7 +838,7 @@ fn should_encode_visibility(def_kind: DefKind) -> bool {\n         | DefKind::ForeignMod\n         | DefKind::OpaqueTy\n         | DefKind::ImplTraitPlaceholder\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::Field => true,\n         DefKind::TyParam\n         | DefKind::ConstParam\n@@ -873,7 +873,7 @@ fn should_encode_stability(def_kind: DefKind) -> bool {\n         | DefKind::ImplTraitPlaceholder\n         | DefKind::Enum\n         | DefKind::Union\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::Trait\n         | DefKind::TraitAlias\n         | DefKind::Macro(..)\n@@ -951,7 +951,7 @@ fn should_encode_variances(def_kind: DefKind) -> bool {\n         | DefKind::Const\n         | DefKind::ForeignMod\n         | DefKind::TyAlias\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::Trait\n         | DefKind::TraitAlias\n         | DefKind::Macro(..)\n@@ -988,7 +988,7 @@ fn should_encode_generics(def_kind: DefKind) -> bool {\n         | DefKind::InlineConst\n         | DefKind::OpaqueTy\n         | DefKind::ImplTraitPlaceholder\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::Field\n         | DefKind::TyParam\n         | DefKind::Closure\n@@ -1018,7 +1018,7 @@ fn should_encode_type(tcx: TyCtxt<'_>, def_id: LocalDefId, def_kind: DefKind) ->\n         | DefKind::TyAlias\n         | DefKind::OpaqueTy\n         | DefKind::ForeignTy\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::AssocFn\n         | DefKind::AssocConst\n         | DefKind::Closure\n@@ -1081,7 +1081,7 @@ fn should_encode_const(def_kind: DefKind) -> bool {\n         | DefKind::OpaqueTy\n         | DefKind::ImplTraitPlaceholder\n         | DefKind::ForeignTy\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::AssocFn\n         | DefKind::Closure\n         | DefKind::Generator\n@@ -1860,7 +1860,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             FxHashMap::default();\n \n         for id in tcx.hir().items() {\n-            if matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n+            if matches!(tcx.def_kind(id.owner_id), DefKind::Impl { .. }) {\n                 if let Some(trait_ref) = tcx.impl_trait_ref(id.owner_id) {\n                     let trait_ref = trait_ref.subst_identity();\n \n@@ -2261,7 +2261,7 @@ pub fn provide(providers: &mut Providers) {\n \n             let mut trait_impls = Vec::new();\n             for id in tcx.hir().items() {\n-                if matches!(tcx.def_kind(id.owner_id), DefKind::Impl)\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::Impl { .. })\n                     && tcx.impl_trait_ref(id.owner_id).is_some()\n                 {\n                     trait_impls.push(id.owner_id.to_def_id())"}, {"sha": "b89d48ec15ae9265ec0d80b8d5228dfcf2bb7e94", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -136,7 +136,8 @@ fixed_size_enum! {\n         ( Field                                    )\n         ( LifetimeParam                            )\n         ( GlobalAsm                                )\n-        ( Impl                                     )\n+        ( Impl { of_trait: false }                 )\n+        ( Impl { of_trait: true }                  )\n         ( Closure                                  )\n         ( Generator                                )\n         ( Static(ast::Mutability::Not)             )"}, {"sha": "ba93330d5812030449f8a7500f6a1192c3d0339f", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -203,7 +203,7 @@ impl<'hir> Map<'hir> {\n                 ItemKind::Use(..) => DefKind::Use,\n                 ItemKind::ForeignMod { .. } => DefKind::ForeignMod,\n                 ItemKind::GlobalAsm(..) => DefKind::GlobalAsm,\n-                ItemKind::Impl { .. } => DefKind::Impl,\n+                ItemKind::Impl(impl_) => DefKind::Impl { of_trait: impl_.of_trait.is_some() },\n             },\n             Node::ForeignItem(item) => match item.kind {\n                 ForeignItemKind::Fn(..) => DefKind::Fn,"}, {"sha": "60927eed85d3b34748325cee677200666e77d2f2", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -19,29 +19,29 @@ pub trait PointerArithmetic: HasDataLayout {\n \n     #[inline(always)]\n     fn max_size_of_val(&self) -> Size {\n-        Size::from_bytes(self.machine_isize_max())\n+        Size::from_bytes(self.target_isize_max())\n     }\n \n     #[inline]\n-    fn machine_usize_max(&self) -> u64 {\n+    fn target_usize_max(&self) -> u64 {\n         self.pointer_size().unsigned_int_max().try_into().unwrap()\n     }\n \n     #[inline]\n-    fn machine_isize_min(&self) -> i64 {\n+    fn target_isize_min(&self) -> i64 {\n         self.pointer_size().signed_int_min().try_into().unwrap()\n     }\n \n     #[inline]\n-    fn machine_isize_max(&self) -> i64 {\n+    fn target_isize_max(&self) -> i64 {\n         self.pointer_size().signed_int_max().try_into().unwrap()\n     }\n \n     #[inline]\n-    fn machine_usize_to_isize(&self, val: u64) -> i64 {\n+    fn target_usize_to_isize(&self, val: u64) -> i64 {\n         let val = val as i64;\n         // Now wrap-around into the machine_isize range.\n-        if val > self.machine_isize_max() {\n+        if val > self.target_isize_max() {\n             // This can only happen if the ptr size is < 64, so we know max_usize_plus_1 fits into\n             // i64.\n             debug_assert!(self.pointer_size().bits() < 64);\n@@ -76,11 +76,11 @@ pub trait PointerArithmetic: HasDataLayout {\n         let n = i.unsigned_abs();\n         if i >= 0 {\n             let (val, over) = self.overflowing_offset(val, n);\n-            (val, over || i > self.machine_isize_max())\n+            (val, over || i > self.target_isize_max())\n         } else {\n             let res = val.overflowing_sub(n);\n             let (val, over) = self.truncate_to_ptr(res);\n-            (val, over || i < self.machine_isize_min())\n+            (val, over || i < self.target_isize_min())\n         }\n     }\n "}, {"sha": "36dbbe4bf77650895d05a7133213976331c47c4f", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -75,8 +75,8 @@ impl<'tcx> ConstValue<'tcx> {\n         self.try_to_scalar_int()?.try_into().ok()\n     }\n \n-    pub fn try_to_machine_usize(&self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n-        self.try_to_scalar_int()?.try_to_machine_usize(tcx).ok()\n+    pub fn try_to_target_usize(&self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n+        self.try_to_scalar_int()?.try_to_target_usize(tcx).ok()\n     }\n \n     pub fn try_to_bits_for_ty(\n@@ -97,8 +97,8 @@ impl<'tcx> ConstValue<'tcx> {\n         ConstValue::Scalar(Scalar::from_u64(i))\n     }\n \n-    pub fn from_machine_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n-        ConstValue::Scalar(Scalar::from_machine_usize(i, cx))\n+    pub fn from_target_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n+        ConstValue::Scalar(Scalar::from_target_usize(i, cx))\n     }\n }\n \n@@ -241,7 +241,7 @@ impl<Prov> Scalar<Prov> {\n     }\n \n     #[inline]\n-    pub fn from_machine_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n+    pub fn from_target_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n         Self::from_uint(i, cx.data_layout().pointer_size)\n     }\n \n@@ -268,7 +268,7 @@ impl<Prov> Scalar<Prov> {\n     }\n \n     #[inline]\n-    pub fn from_machine_isize(i: i64, cx: &impl HasDataLayout) -> Self {\n+    pub fn from_target_isize(i: i64, cx: &impl HasDataLayout) -> Self {\n         Self::from_int(i, cx.data_layout().pointer_size)\n     }\n \n@@ -429,7 +429,7 @@ impl<'tcx, Prov: Provenance> Scalar<Prov> {\n \n     /// Converts the scalar to produce a machine-pointer-sized unsigned integer.\n     /// Fails if the scalar is a pointer.\n-    pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n+    pub fn to_target_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         let b = self.to_uint(cx.data_layout().pointer_size)?;\n         Ok(u64::try_from(b).unwrap())\n     }\n@@ -469,7 +469,7 @@ impl<'tcx, Prov: Provenance> Scalar<Prov> {\n \n     /// Converts the scalar to produce a machine-pointer-sized signed integer.\n     /// Fails if the scalar is a pointer.\n-    pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, i64> {\n+    pub fn to_target_isize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, i64> {\n         let b = self.to_int(cx.data_layout().pointer_size)?;\n         Ok(i64::try_from(b).unwrap())\n     }"}, {"sha": "c596e91160c8a267f62765e925ac61c685c43d1f", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -2357,10 +2357,10 @@ impl<'tcx> ConstantKind<'tcx> {\n     ) -> Option<u64> {\n         match self {\n             Self::Ty(ct) => ct.try_eval_target_usize(tcx, param_env),\n-            Self::Val(val, _) => val.try_to_machine_usize(tcx),\n+            Self::Val(val, _) => val.try_to_target_usize(tcx),\n             Self::Unevaluated(uneval, _) => {\n                 match tcx.const_eval_resolve(param_env, *uneval, None) {\n-                    Ok(val) => val.try_to_machine_usize(tcx),\n+                    Ok(val) => val.try_to_target_usize(tcx),\n                     Err(_) => None,\n                 }\n             }"}, {"sha": "4b34f6b4881bf7c00e3e9e318457bdd6c0b67240", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -2143,12 +2143,12 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query permits_uninit_init(key: ty::ParamEnvAnd<'tcx, TyAndLayout<'tcx>>) -> bool {\n-        desc { \"checking to see if `{}` permits being left uninit\", key.value.ty }\n+    query permits_uninit_init(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> Result<bool, ty::layout::LayoutError<'tcx>> {\n+        desc { \"checking to see if `{}` permits being left uninit\", key.value }\n     }\n \n-    query permits_zero_init(key: ty::ParamEnvAnd<'tcx, TyAndLayout<'tcx>>) -> bool {\n-        desc { \"checking to see if `{}` permits being left zeroed\", key.value.ty }\n+    query permits_zero_init(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> Result<bool, ty::layout::LayoutError<'tcx>> {\n+        desc { \"checking to see if `{}` permits being left zeroed\", key.value }\n     }\n \n     query compare_impl_const("}, {"sha": "f127b6275a21d881e056555d6c15b7fa17390e26", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -406,6 +406,7 @@ impl<'tcx> AdtDef<'tcx> {\n     }\n \n     /// Return the index of `VariantDef` given a variant id.\n+    #[inline]\n     pub fn variant_index_with_id(self, vid: DefId) -> VariantIdx {\n         self.variants()\n             .iter_enumerated()"}, {"sha": "927f18f59b979660a7c87aa5f72b474c6dc50149", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -206,7 +206,7 @@ impl<'tcx> Const<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,\n     ) -> Option<u64> {\n-        self.kind().eval(tcx, param_env).try_to_machine_usize(tcx)\n+        self.kind().eval(tcx, param_env).try_to_target_usize(tcx)\n     }\n \n     #[inline]"}, {"sha": "eecd78ab6c0484aeb1c7b7ac1d770589a8a2f657", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -232,7 +232,7 @@ impl ScalarInt {\n     }\n \n     #[inline]\n-    pub fn try_to_machine_usize(&self, tcx: TyCtxt<'_>) -> Result<u64, Size> {\n+    pub fn try_to_target_usize(&self, tcx: TyCtxt<'_>) -> Result<u64, Size> {\n         Ok(self.to_bits(tcx.data_layout.pointer_size)? as u64)\n     }\n "}, {"sha": "58c5e21df66b9bd220dbba1177d8ed08ae8c8079", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -125,8 +125,8 @@ impl<'tcx> ConstKind<'tcx> {\n     }\n \n     #[inline]\n-    pub fn try_to_machine_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n-        self.try_to_value()?.try_to_machine_usize(tcx)\n+    pub fn try_to_target_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n+        self.try_to_value()?.try_to_target_usize(tcx)\n     }\n }\n "}, {"sha": "5ed4af2e9229db0b0d35e2f016a96cce792fbcbf", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -78,8 +78,8 @@ impl<'tcx> ValTree<'tcx> {\n         }\n     }\n \n-    pub fn try_to_machine_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n-        self.try_to_scalar_int().map(|s| s.try_to_machine_usize(tcx).ok()).flatten()\n+    pub fn try_to_target_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n+        self.try_to_scalar_int().map(|s| s.try_to_target_usize(tcx).ok()).flatten()\n     }\n \n     /// Get the values inside the ValTree as a slice of bytes. This only works for"}, {"sha": "c9aa0ec66d5614d233d6bb89aae76d60bb7a9ff5", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -125,7 +125,7 @@ impl FlagComputation {\n                 self.bound_computation(ts, |flags, ts| flags.add_tys(ts));\n             }\n \n-            &ty::GeneratorWitnessMIR(_, ref substs) => {\n+            ty::GeneratorWitnessMIR(_, substs) => {\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n                 self.add_substs(substs);"}, {"sha": "e268553f8268b3605993937f5d87e833631def45", "filename": "compiler/rustc_middle/src/ty/inhabitedness/inhabited_predicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -159,7 +159,7 @@ impl<'tcx> InhabitedPredicate<'tcx> {\n         match self {\n             Self::ConstIsZero(c) => {\n                 let c = ty::EarlyBinder(c).subst(tcx, substs);\n-                let pred = match c.kind().try_to_machine_usize(tcx) {\n+                let pred = match c.kind().try_to_target_usize(tcx) {\n                     Some(0) => Self::True,\n                     Some(1..) => Self::False,\n                     None => Self::ConstIsZero(c),"}, {"sha": "690c0d58e01c18379cc12a6c93a30a51c8a1930a", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -191,7 +191,7 @@ fn inhabited_predicate_type<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> InhabitedP\n \n         // If we can evaluate the array length before having a `ParamEnv`, then\n         // we can simplify the predicate. This is an optimization.\n-        Array(ty, len) => match len.kind().try_to_machine_usize(tcx) {\n+        Array(ty, len) => match len.kind().try_to_target_usize(tcx) {\n             Some(0) => InhabitedPredicate::True,\n             Some(1..) => ty.inhabited_predicate(tcx),\n             None => ty.inhabited_predicate(tcx).or(tcx, InhabitedPredicate::ConstIsZero(len)),"}, {"sha": "a1b5eaed2f178e144089f41d686481cc911b7a64", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -2429,7 +2429,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         if let DefKind::AssocConst | DefKind::AssocFn | DefKind::AssocTy = self.def_kind(def_id) {\n             let parent = self.parent(def_id);\n-            if let DefKind::Impl = self.def_kind(parent) {\n+            if let DefKind::Impl { .. } = self.def_kind(parent) {\n                 return Some(parent);\n             }\n         }"}, {"sha": "ed54aa96f5b8983380dc3179187b54d4fe9a5f3d", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -30,7 +30,6 @@ use crate::traits::specialization_graph;\n use crate::traits::{self, ImplSource};\n use crate::ty::context::TyCtxtFeed;\n use crate::ty::fast_reject::SimplifiedType;\n-use crate::ty::layout::TyAndLayout;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::GeneratorDiagnosticData;"}, {"sha": "35831ff8706428e71b0ac02694a7792aa2c54052", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -167,7 +167,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 | DefKind::Fn\n                 | DefKind::AssocFn\n                 | DefKind::AssocConst\n-                | DefKind::Impl,\n+                | DefKind::Impl { .. },\n                 def_id,\n             ) => Some(def_id),\n             Res::Err => None,"}, {"sha": "c57ec137d4b778fafaa889e1a678f9c37834c26f", "filename": "compiler/rustc_mir_transform/src/copy_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -22,7 +22,7 @@ pub struct CopyProp;\n \n impl<'tcx> MirPass<'tcx> for CopyProp {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        sess.mir_opt_level() >= 4\n+        sess.mir_opt_level() >= 1\n     }\n \n     #[instrument(level = \"trace\", skip(self, tcx, body))]\n@@ -96,7 +96,7 @@ fn fully_moved_locals(ssa: &SsaLocals, body: &Body<'_>) -> BitSet<Local> {\n     fully_moved\n }\n \n-/// Utility to help performing subtitution of `*pattern` by `target`.\n+/// Utility to help performing substitution of `*pattern` by `target`.\n struct Replacer<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fully_moved: BitSet<Local>,"}, {"sha": "1079377fbacd2f35b44dc008731a35d7642e7cc5", "filename": "compiler/rustc_mir_transform/src/instcombine.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -6,7 +6,8 @@ use rustc_middle::mir::{\n     BinOp, Body, Constant, ConstantKind, LocalDecls, Operand, Place, ProjectionElem, Rvalue,\n     SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n };\n-use rustc_middle::ty::{self, layout::TyAndLayout, ParamEnv, ParamEnvAnd, SubstsRef, Ty, TyCtxt};\n+use rustc_middle::ty::layout::LayoutError;\n+use rustc_middle::ty::{self, ParamEnv, ParamEnvAnd, SubstsRef, Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n \n pub struct InstCombine;\n@@ -230,38 +231,41 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n \n         // Check this is a foldable intrinsic before we query the layout of our generic parameter\n         let Some(assert_panics) = intrinsic_assert_panics(intrinsic_name) else { return; };\n-        let Ok(layout) = self.tcx.layout_of(self.param_env.and(ty)) else { return; };\n-        if assert_panics(self.tcx, self.param_env.and(layout)) {\n-            // If we know the assert panics, indicate to later opts that the call diverges\n-            *target = None;\n-        } else {\n-            // If we know the assert does not panic, turn the call into a Goto\n-            terminator.kind = TerminatorKind::Goto { target: *target_block };\n+        match assert_panics(self.tcx, self.param_env.and(ty)) {\n+            // We don't know the layout, don't touch the assertion\n+            Err(_) => {}\n+            Ok(true) => {\n+                // If we know the assert panics, indicate to later opts that the call diverges\n+                *target = None;\n+            }\n+            Ok(false) => {\n+                // If we know the assert does not panic, turn the call into a Goto\n+                terminator.kind = TerminatorKind::Goto { target: *target_block };\n+            }\n         }\n     }\n }\n \n fn intrinsic_assert_panics<'tcx>(\n     intrinsic_name: Symbol,\n-) -> Option<fn(TyCtxt<'tcx>, ParamEnvAnd<'tcx, TyAndLayout<'tcx>>) -> bool> {\n+) -> Option<fn(TyCtxt<'tcx>, ParamEnvAnd<'tcx, Ty<'tcx>>) -> Result<bool, LayoutError<'tcx>>> {\n     fn inhabited_predicate<'tcx>(\n-        _tcx: TyCtxt<'tcx>,\n-        param_env_and_layout: ParamEnvAnd<'tcx, TyAndLayout<'tcx>>,\n-    ) -> bool {\n-        let (_param_env, layout) = param_env_and_layout.into_parts();\n-        layout.abi.is_uninhabited()\n+        tcx: TyCtxt<'tcx>,\n+        param_env_and_ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ) -> Result<bool, LayoutError<'tcx>> {\n+        Ok(tcx.layout_of(param_env_and_ty)?.abi.is_uninhabited())\n     }\n     fn zero_valid_predicate<'tcx>(\n         tcx: TyCtxt<'tcx>,\n-        param_env_and_layout: ParamEnvAnd<'tcx, TyAndLayout<'tcx>>,\n-    ) -> bool {\n-        !tcx.permits_zero_init(param_env_and_layout)\n+        param_env_and_ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ) -> Result<bool, LayoutError<'tcx>> {\n+        Ok(!tcx.permits_zero_init(param_env_and_ty)?)\n     }\n     fn mem_uninitialized_valid_predicate<'tcx>(\n         tcx: TyCtxt<'tcx>,\n-        param_env_and_layout: ParamEnvAnd<'tcx, TyAndLayout<'tcx>>,\n-    ) -> bool {\n-        !tcx.permits_uninit_init(param_env_and_layout)\n+        param_env_and_ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ) -> Result<bool, LayoutError<'tcx>> {\n+        Ok(!tcx.permits_uninit_init(param_env_and_ty)?)\n     }\n \n     match intrinsic_name {"}, {"sha": "65c15d9c67497b2fc06414f6a9a88a64c82abe7b", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -19,6 +19,33 @@ pub struct SsaLocals {\n     copy_classes: IndexVec<Local, Local>,\n }\n \n+/// We often encounter MIR bodies with 1 or 2 basic blocks. In those cases, it's unnecessary to\n+/// actually compute dominators, we can just compare block indices because bb0 is always the first\n+/// block, and in any body all other blocks are always always dominated by bb0.\n+struct SmallDominators {\n+    inner: Option<Dominators<BasicBlock>>,\n+}\n+\n+trait DomExt {\n+    fn dominates(self, _other: Self, dominators: &SmallDominators) -> bool;\n+}\n+\n+impl DomExt for Location {\n+    fn dominates(self, other: Location, dominators: &SmallDominators) -> bool {\n+        if self.block == other.block {\n+            self.statement_index <= other.statement_index\n+        } else {\n+            dominators.dominates(self.block, other.block)\n+        }\n+    }\n+}\n+\n+impl SmallDominators {\n+    fn dominates(&self, dom: BasicBlock, node: BasicBlock) -> bool {\n+        if let Some(inner) = &self.inner { inner.dominates(dom, node) } else { dom < node }\n+    }\n+}\n+\n impl SsaLocals {\n     pub fn new<'tcx>(\n         tcx: TyCtxt<'tcx>,\n@@ -29,7 +56,9 @@ impl SsaLocals {\n         let assignment_order = Vec::new();\n \n         let assignments = IndexVec::from_elem(Set1::Empty, &body.local_decls);\n-        let dominators = body.basic_blocks.dominators();\n+        let dominators =\n+            if body.basic_blocks.len() > 2 { Some(body.basic_blocks.dominators()) } else { None };\n+        let dominators = SmallDominators { inner: dominators };\n         let mut visitor = SsaVisitor { assignments, assignment_order, dominators };\n \n         for (local, decl) in body.local_decls.iter_enumerated() {\n@@ -41,8 +70,14 @@ impl SsaLocals {\n             }\n         }\n \n-        for (bb, data) in traversal::reverse_postorder(body) {\n-            visitor.visit_basic_block_data(bb, data);\n+        if body.basic_blocks.len() > 2 {\n+            for (bb, data) in traversal::reverse_postorder(body) {\n+                visitor.visit_basic_block_data(bb, data);\n+            }\n+        } else {\n+            for (bb, data) in body.basic_blocks.iter_enumerated() {\n+                visitor.visit_basic_block_data(bb, data);\n+            }\n         }\n \n         for var_debug_info in &body.var_debug_info {\n@@ -139,7 +174,7 @@ enum LocationExtended {\n }\n \n struct SsaVisitor {\n-    dominators: Dominators<BasicBlock>,\n+    dominators: SmallDominators,\n     assignments: IndexVec<Local, Set1<LocationExtended>>,\n     assignment_order: Vec<Local>,\n }"}, {"sha": "bbe4e67977c9449e5871a412ad19c0b837f0c914", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 43, "deletions": 73, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1191,28 +1191,14 @@ impl<'v> RootCollector<'_, 'v> {\n     fn process_item(&mut self, id: hir::ItemId) {\n         match self.tcx.def_kind(id.owner_id) {\n             DefKind::Enum | DefKind::Struct | DefKind::Union => {\n-                let item = self.tcx.hir().item(id);\n-                match item.kind {\n-                    hir::ItemKind::Enum(_, ref generics)\n-                    | hir::ItemKind::Struct(_, ref generics)\n-                    | hir::ItemKind::Union(_, ref generics) => {\n-                        if generics.params.is_empty() {\n-                            if self.mode == MonoItemCollectionMode::Eager {\n-                                debug!(\n-                                    \"RootCollector: ADT drop-glue for {}\",\n-                                    self.tcx.def_path_str(item.owner_id.to_def_id())\n-                                );\n-\n-                                let ty = Instance::new(\n-                                    item.owner_id.to_def_id(),\n-                                    InternalSubsts::empty(),\n-                                )\n-                                .ty(self.tcx, ty::ParamEnv::reveal_all());\n-                                visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n-                            }\n-                        }\n-                    }\n-                    _ => bug!(),\n+                if self.mode == MonoItemCollectionMode::Eager\n+                    && self.tcx.generics_of(id.owner_id).count() == 0\n+                {\n+                    debug!(\"RootCollector: ADT drop-glue for `{id:?}`\",);\n+\n+                    let ty =\n+                        self.tcx.bound_type_of(id.owner_id.to_def_id()).no_bound_vars().unwrap();\n+                    visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n                 }\n             }\n             DefKind::GlobalAsm => {\n@@ -1238,10 +1224,9 @@ impl<'v> RootCollector<'_, 'v> {\n                     collect_const_value(self.tcx, val, &mut self.output);\n                 }\n             }\n-            DefKind::Impl => {\n+            DefKind::Impl { .. } => {\n                 if self.mode == MonoItemCollectionMode::Eager {\n-                    let item = self.tcx.hir().item(id);\n-                    create_mono_items_for_default_impls(self.tcx, item, self.output);\n+                    create_mono_items_for_default_impls(self.tcx, id, self.output);\n                 }\n             }\n             DefKind::Fn => {\n@@ -1326,66 +1311,51 @@ fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     generics.requires_monomorphization(tcx)\n }\n \n+#[instrument(level = \"debug\", skip(tcx, output))]\n fn create_mono_items_for_default_impls<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    item: &'tcx hir::Item<'tcx>,\n+    item: hir::ItemId,\n     output: &mut MonoItems<'tcx>,\n ) {\n-    match item.kind {\n-        hir::ItemKind::Impl(ref impl_) => {\n-            if matches!(impl_.polarity, hir::ImplPolarity::Negative(_)) {\n-                return;\n-            }\n+    let polarity = tcx.impl_polarity(item.owner_id);\n+    if matches!(polarity, ty::ImplPolarity::Negative) {\n+        return;\n+    }\n \n-            for param in impl_.generics.params {\n-                match param.kind {\n-                    hir::GenericParamKind::Lifetime { .. } => {}\n-                    hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => {\n-                        return;\n-                    }\n-                }\n-            }\n+    if tcx.generics_of(item.owner_id).own_requires_monomorphization() {\n+        return;\n+    }\n \n-            debug!(\n-                \"create_mono_items_for_default_impls(item={})\",\n-                tcx.def_path_str(item.owner_id.to_def_id())\n-            );\n+    let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) else {\n+        return;\n+    };\n \n-            if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n-                let trait_ref = trait_ref.subst_identity();\n+    let trait_ref = trait_ref.subst_identity();\n \n-                let param_env = ty::ParamEnv::reveal_all();\n-                let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n-                let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);\n-                for method in tcx.provided_trait_methods(trait_ref.def_id) {\n-                    if overridden_methods.contains_key(&method.def_id) {\n-                        continue;\n-                    }\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n+    let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);\n+    for method in tcx.provided_trait_methods(trait_ref.def_id) {\n+        if overridden_methods.contains_key(&method.def_id) {\n+            continue;\n+        }\n \n-                    if tcx.generics_of(method.def_id).own_requires_monomorphization() {\n-                        continue;\n-                    }\n+        if tcx.generics_of(method.def_id).own_requires_monomorphization() {\n+            continue;\n+        }\n \n-                    let substs =\n-                        InternalSubsts::for_item(tcx, method.def_id, |param, _| match param.kind {\n-                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                            GenericParamDefKind::Type { .. }\n-                            | GenericParamDefKind::Const { .. } => {\n-                                trait_ref.substs[param.index as usize]\n-                            }\n-                        });\n-                    let instance =\n-                        ty::Instance::expect_resolve(tcx, param_env, method.def_id, substs);\n-\n-                    let mono_item = create_fn_mono_item(tcx, instance, DUMMY_SP);\n-                    if mono_item.node.is_instantiable(tcx) && should_codegen_locally(tcx, &instance)\n-                    {\n-                        output.push(mono_item);\n-                    }\n-                }\n+        let substs = InternalSubsts::for_item(tcx, method.def_id, |param, _| match param.kind {\n+            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+            GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                trait_ref.substs[param.index as usize]\n             }\n+        });\n+        let instance = ty::Instance::expect_resolve(tcx, param_env, method.def_id, substs);\n+\n+        let mono_item = create_fn_mono_item(tcx, instance, DUMMY_SP);\n+        if mono_item.node.is_instantiable(tcx) && should_codegen_locally(tcx, &instance) {\n+            output.push(mono_item);\n         }\n-        _ => bug!(),\n     }\n }\n "}, {"sha": "207ad332c22c23fe2cd58c863f22ba8585cb1ad2", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -172,7 +172,7 @@ fn mark_used_by_default_parameters<'tcx>(\n         | DefKind::Field\n         | DefKind::LifetimeParam\n         | DefKind::GlobalAsm\n-        | DefKind::Impl => {\n+        | DefKind::Impl { .. } => {\n             for param in &generics.params {\n                 debug!(?param, \"(other)\");\n                 if let ty::GenericParamDefKind::Lifetime = param.kind {"}, {"sha": "7cfffe390d3ffaaadc098d6593cd5380abd411ac", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -526,10 +526,8 @@ fn check_item<'tcx>(\n                 }\n             }\n         }\n-        DefKind::Impl => {\n-            let of_trait = tcx.impl_trait_ref(id.owner_id);\n-\n-            if of_trait.is_some() {\n+        DefKind::Impl { of_trait } => {\n+            if of_trait {\n                 worklist.push(id.owner_id.def_id);\n             }\n \n@@ -541,7 +539,7 @@ fn check_item<'tcx>(\n \n             // And we access the Map here to get HirId from LocalDefId\n             for id in local_def_ids {\n-                if of_trait.is_some() || has_allow_dead_code_or_lang_attr(tcx, id) {\n+                if of_trait || has_allow_dead_code_or_lang_attr(tcx, id) {\n                     worklist.push(id);\n                 }\n             }"}, {"sha": "678f1815d012cd17fc1d20b82e17bd88b9348fa4", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -145,7 +145,7 @@ fn check_liveness(tcx: TyCtxt<'_>, def_id: DefId) {\n \n     // Don't run unused pass for #[derive()]\n     let parent = tcx.local_parent(local_def_id);\n-    if let DefKind::Impl = tcx.def_kind(parent)\n+    if let DefKind::Impl { .. } = tcx.def_kind(parent)\n         && tcx.has_attr(parent.to_def_id(), sym::automatically_derived)\n     {\n         return;"}, {"sha": "051100c56f81311b6fc47f5a2600b12c2dde2461", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -320,31 +320,28 @@ fn check_item<'tcx>(\n         worklist.push(id.owner_id.def_id);\n     }\n \n-    if !matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n+    if !matches!(tcx.def_kind(id.owner_id), DefKind::Impl { of_trait: true }) {\n         return;\n     }\n \n     // We need only trait impls here, not inherent impls, and only non-exported ones\n-    let item = tcx.hir().item(id);\n-    if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n-        item.kind\n-    {\n-        if !effective_visibilities.is_reachable(item.owner_id.def_id) {\n-            worklist.extend(items.iter().map(|ii_ref| ii_ref.id.owner_id.def_id));\n+    if effective_visibilities.is_reachable(id.owner_id.def_id) {\n+        return;\n+    }\n \n-            let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res else {\n-                unreachable!();\n-            };\n+    let items = tcx.associated_item_def_ids(id.owner_id);\n+    worklist.extend(items.iter().map(|ii_ref| ii_ref.expect_local()));\n \n-            if !trait_def_id.is_local() {\n-                return;\n-            }\n+    let Some(trait_def_id) = tcx.trait_id_of_impl(id.owner_id.to_def_id()) else {\n+        unreachable!();\n+    };\n \n-            worklist.extend(\n-                tcx.provided_trait_methods(trait_def_id).map(|assoc| assoc.def_id.expect_local()),\n-            );\n-        }\n+    if !trait_def_id.is_local() {\n+        return;\n     }\n+\n+    worklist\n+        .extend(tcx.provided_trait_methods(trait_def_id).map(|assoc| assoc.def_id.expect_local()));\n }\n \n fn has_custom_linkage(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {"}, {"sha": "4675bd79c46297c1c3194b16d626b01c7856719f", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -593,7 +593,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             | DefKind::InlineConst\n             | DefKind::Field\n             | DefKind::GlobalAsm\n-            | DefKind::Impl\n+            | DefKind::Impl { .. }\n             | DefKind::Closure\n             | DefKind::Generator => (),\n         }\n@@ -1997,7 +1997,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n             // Subitems of inherent impls have their own publicity.\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n-            DefKind::Impl => {\n+            DefKind::Impl { .. } => {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::Impl(ref impl_) = item.kind {\n                     let impl_vis ="}, {"sha": "81c7e4673d41b7e11e950cfd2eba1363a4cbf11a", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -92,7 +92,7 @@ where\n         let mut lock = self.cache.lock();\n         // We may be overwriting another value. This is all right, since the dep-graph\n         // will check that the fingerprint matches.\n-        lock.insert(key, (value.clone(), index));\n+        lock.insert(key, (value, index));\n         value\n     }\n \n@@ -153,7 +153,7 @@ where\n \n     #[inline]\n     fn complete(&self, _key: (), value: V, index: DepNodeIndex) -> Self::Stored {\n-        *self.cache.lock() = Some((value.clone(), index));\n+        *self.cache.lock() = Some((value, index));\n         value\n     }\n \n@@ -283,7 +283,7 @@ where\n         let mut lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n-        lock.insert(key, (value.clone(), index));\n+        lock.insert(key, (value, index));\n         value\n     }\n "}, {"sha": "5dc651638f79de2ba5a58ab0356bf7f4b14a0346", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -987,7 +987,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 | DefKind::LifetimeParam\n                 | DefKind::GlobalAsm\n                 | DefKind::Closure\n-                | DefKind::Impl\n+                | DefKind::Impl { .. }\n                 | DefKind::Generator,\n                 _,\n             )"}, {"sha": "181e27f334b40219e08be56fb5c3cc5f9b70e4f9", "filename": "compiler/rustc_save_analysis/Cargo.toml", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2FCargo.toml?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,21 +0,0 @@\n-[package]\n-name = \"rustc_save_analysis\"\n-version = \"0.0.0\"\n-edition = \"2021\"\n-\n-[dependencies]\n-tracing = \"0.1\"\n-rustc_middle = { path = \"../rustc_middle\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n-rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n-rustc_data_structures = { path = \"../rustc_data_structures\" }\n-rustc_errors = { path = \"../rustc_errors\" }\n-rustc_hir = { path = \"../rustc_hir\" }\n-rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n-rustc_lexer = { path = \"../rustc_lexer\" }\n-rustc_macros = { path = \"../rustc_macros\" }\n-serde_json = \"1\"\n-rustc_session = { path = \"../rustc_session\" }\n-rustc_span = { path = \"../rustc_span\" }\n-rls-data = \"0.19\"\n-rls-span = \"0.5\""}, {"sha": "3982111e38e08307f6aaacebe270a3c947f2cd78", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "removed", "additions": 0, "deletions": 1465, "changes": 1465, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,1465 +0,0 @@\n-//! Write the output of rustc's analysis to an implementor of Dump.\n-//!\n-//! Dumping the analysis is implemented by walking the AST and getting a bunch of\n-//! info out from all over the place. We use `DefId`s to identify objects. The\n-//! tricky part is getting syntactic (span, source text) and semantic (reference\n-//! `DefId`s) information for parts of expressions which the compiler has discarded.\n-//! E.g., in a path `foo::bar::baz`, the compiler only keeps a span for the whole\n-//! path and a reference to `baz`, but we want spans and references for all three\n-//! idents.\n-//!\n-//! SpanUtils is used to manipulate spans. In particular, to extract sub-spans\n-//! from spans (e.g., the span for `bar` from the above example path).\n-//! DumpVisitor walks the AST and processes it, and Dumper is used for\n-//! recording the output.\n-\n-use rustc_ast as ast;\n-use rustc_ast::walk_list;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir as hir;\n-use rustc_hir::def::{DefKind as HirDefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir_pretty::{bounds_to_string, fn_to_string, generic_params_to_string, ty_to_string};\n-use rustc_middle::hir::nested_filter;\n-use rustc_middle::span_bug;\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n-use rustc_session::config::Input;\n-use rustc_span::symbol::Ident;\n-use rustc_span::*;\n-\n-use std::env;\n-use std::path::Path;\n-\n-use crate::dumper::{Access, Dumper};\n-use crate::sig;\n-use crate::span_utils::SpanUtils;\n-use crate::{\n-    escape, generated_code, id_from_def_id, id_from_hir_id, lower_attributes, PathCollector,\n-    SaveContext,\n-};\n-\n-use rls_data::{\n-    CompilationOptions, CratePreludeData, Def, DefKind, GlobalCrateId, Import, ImportKind, Ref,\n-    RefKind, Relation, RelationKind, SpanData,\n-};\n-\n-#[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5213\n-macro_rules! down_cast_data {\n-    ($id:ident, $kind:ident, $sp:expr) => {\n-        let super::Data::$kind($id) = $id else {\n-            span_bug!($sp, \"unexpected data kind: {:?}\", $id);\n-        };\n-    };\n-}\n-\n-macro_rules! access_from {\n-    ($save_ctxt:expr, $id:expr) => {\n-        Access {\n-            public: $save_ctxt.tcx.visibility($id).is_public(),\n-            reachable: $save_ctxt.effective_visibilities.is_reachable($id),\n-        }\n-    };\n-}\n-\n-pub struct DumpVisitor<'tcx> {\n-    pub save_ctxt: SaveContext<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    dumper: Dumper,\n-\n-    span: SpanUtils<'tcx>,\n-    // Set of macro definition (callee) spans, and the set\n-    // of macro use (callsite) spans. We store these to ensure\n-    // we only write one macro def per unique macro definition, and\n-    // one macro use per unique callsite span.\n-    // mac_defs: FxHashSet<Span>,\n-    // macro_calls: FxHashSet<Span>,\n-}\n-\n-impl<'tcx> DumpVisitor<'tcx> {\n-    pub fn new(save_ctxt: SaveContext<'tcx>) -> DumpVisitor<'tcx> {\n-        let span_utils = SpanUtils::new(&save_ctxt.tcx.sess);\n-        let dumper = Dumper::new(save_ctxt.config.clone());\n-        DumpVisitor { tcx: save_ctxt.tcx, save_ctxt, dumper, span: span_utils }\n-    }\n-\n-    pub fn analysis(&self) -> &rls_data::Analysis {\n-        self.dumper.analysis()\n-    }\n-\n-    fn nest_typeck_results<F>(&mut self, item_def_id: LocalDefId, f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n-        let typeck_results = if self.tcx.has_typeck_results(item_def_id) {\n-            Some(self.tcx.typeck(item_def_id))\n-        } else {\n-            None\n-        };\n-\n-        let old_maybe_typeck_results = self.save_ctxt.maybe_typeck_results;\n-        self.save_ctxt.maybe_typeck_results = typeck_results;\n-        f(self);\n-        self.save_ctxt.maybe_typeck_results = old_maybe_typeck_results;\n-    }\n-\n-    fn span_from_span(&self, span: Span) -> SpanData {\n-        self.save_ctxt.span_from_span(span)\n-    }\n-\n-    fn lookup_def_id(&self, ref_id: hir::HirId) -> Option<DefId> {\n-        self.save_ctxt.lookup_def_id(ref_id)\n-    }\n-\n-    pub fn dump_crate_info(&mut self, name: Symbol) {\n-        let crate_root = self.tcx.sess.local_crate_source_file().map(|source_file| {\n-            match source_file.file_name() {\n-                Some(_) => source_file.parent().unwrap().display(),\n-                None => source_file.display(),\n-            }\n-            .to_string()\n-        });\n-\n-        let data = CratePreludeData {\n-            crate_id: GlobalCrateId {\n-                name: name.to_string(),\n-                disambiguator: (self.tcx.sess.local_stable_crate_id().to_u64(), 0),\n-            },\n-            crate_root: crate_root.unwrap_or_else(|| \"<no source>\".to_owned()),\n-            external_crates: self.save_ctxt.get_external_crates(),\n-            span: self.span_from_span(self.tcx.def_span(CRATE_DEF_ID)),\n-        };\n-\n-        self.dumper.crate_prelude(data);\n-    }\n-\n-    pub fn dump_compilation_options(&mut self, input: &Input, crate_name: Symbol) {\n-        // Apply possible `remap-path-prefix` remapping to the input source file\n-        // (and don't include remapping args anymore)\n-        let (program, arguments) = {\n-            let remap_arg_indices = {\n-                let mut indices = FxHashSet::default();\n-                // Args are guaranteed to be valid UTF-8 (checked early)\n-                for (i, e) in env::args().enumerate() {\n-                    if e.starts_with(\"--remap-path-prefix=\") {\n-                        indices.insert(i);\n-                    } else if e == \"--remap-path-prefix\" {\n-                        indices.insert(i);\n-                        indices.insert(i + 1);\n-                    }\n-                }\n-                indices\n-            };\n-\n-            let mut args = env::args()\n-                .enumerate()\n-                .filter(|(i, _)| !remap_arg_indices.contains(i))\n-                .map(|(_, arg)| match input {\n-                    Input::File(ref path) if path == Path::new(&arg) => self\n-                        .tcx\n-                        .sess\n-                        .local_crate_source_file()\n-                        .as_ref()\n-                        .unwrap()\n-                        .to_string_lossy()\n-                        .into(),\n-                    _ => arg,\n-                });\n-\n-            (args.next().unwrap(), args.collect())\n-        };\n-\n-        let data = CompilationOptions {\n-            directory: self.tcx.sess.opts.working_dir.remapped_path_if_available().into(),\n-            program,\n-            arguments,\n-            output: self.save_ctxt.compilation_output(crate_name),\n-        };\n-\n-        self.dumper.compilation_opts(data);\n-    }\n-\n-    fn write_segments(&mut self, segments: impl IntoIterator<Item = &'tcx hir::PathSegment<'tcx>>) {\n-        for seg in segments {\n-            if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n-                self.dumper.dump_ref(data);\n-            }\n-        }\n-    }\n-\n-    fn write_sub_paths<R>(&mut self, path: &'tcx hir::Path<'tcx, R>) {\n-        self.write_segments(path.segments)\n-    }\n-\n-    // As write_sub_paths, but does not process the last ident in the path (assuming it\n-    // will be processed elsewhere). See note on write_sub_paths about global.\n-    fn write_sub_paths_truncated<R>(&mut self, path: &'tcx hir::Path<'tcx, R>) {\n-        if let [segments @ .., _] = path.segments {\n-            self.write_segments(segments)\n-        }\n-    }\n-\n-    fn process_formals(&mut self, formals: &'tcx [hir::Param<'tcx>], qualname: &str) {\n-        for arg in formals {\n-            self.visit_pat(&arg.pat);\n-            let mut collector = PathCollector::new(self.tcx);\n-            collector.visit_pat(&arg.pat);\n-\n-            for (hir_id, ident, ..) in collector.collected_idents {\n-                let typ = match self.save_ctxt.typeck_results().node_type_opt(hir_id) {\n-                    Some(s) => s.to_string(),\n-                    None => continue,\n-                };\n-                if !self.span.filter_generated(ident.span) {\n-                    let id = id_from_hir_id(hir_id);\n-                    let span = self.span_from_span(ident.span);\n-\n-                    self.dumper.dump_def(\n-                        &Access { public: false, reachable: false },\n-                        Def {\n-                            kind: DefKind::Local,\n-                            id,\n-                            span,\n-                            name: ident.to_string(),\n-                            qualname: format!(\"{}::{}\", qualname, ident),\n-                            value: typ,\n-                            parent: None,\n-                            children: vec![],\n-                            decl_id: None,\n-                            docs: String::new(),\n-                            sig: None,\n-                            attributes: vec![],\n-                        },\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    fn process_method(\n-        &mut self,\n-        sig: &'tcx hir::FnSig<'tcx>,\n-        body: Option<hir::BodyId>,\n-        owner_id: hir::OwnerId,\n-        ident: Ident,\n-        generics: &'tcx hir::Generics<'tcx>,\n-        span: Span,\n-    ) {\n-        debug!(\"process_method: {:?}:{}\", owner_id, ident);\n-\n-        let map = self.tcx.hir();\n-        let hir_id: hir::HirId = owner_id.into();\n-        self.nest_typeck_results(owner_id.def_id, |v| {\n-            if let Some(mut method_data) = v.save_ctxt.get_method_data(owner_id, ident, span) {\n-                if let Some(body) = body {\n-                    v.process_formals(map.body(body).params, &method_data.qualname);\n-                }\n-                v.process_generic_params(&generics, &method_data.qualname, hir_id);\n-\n-                method_data.value =\n-                    fn_to_string(sig.decl, sig.header, Some(ident.name), generics, &[], None);\n-                method_data.sig =\n-                    sig::method_signature(owner_id, ident, generics, sig, &v.save_ctxt);\n-\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, owner_id.def_id), method_data);\n-            }\n-\n-            // walk arg and return types\n-            for arg in sig.decl.inputs {\n-                v.visit_ty(arg);\n-            }\n-\n-            if let hir::FnRetTy::Return(ref ret_ty) = sig.decl.output {\n-                v.visit_ty(ret_ty)\n-            }\n-\n-            // walk the fn body\n-            if let Some(body) = body {\n-                v.visit_expr(&map.body(body).value);\n-            }\n-        });\n-    }\n-\n-    fn process_struct_field_def(\n-        &mut self,\n-        field: &'tcx hir::FieldDef<'tcx>,\n-        parent_id: LocalDefId,\n-    ) {\n-        let field_data = self.save_ctxt.get_field_data(field, parent_id);\n-        if let Some(field_data) = field_data {\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, field.def_id), field_data);\n-        }\n-    }\n-\n-    // Dump generic params bindings, then visit_generics\n-    fn process_generic_params(\n-        &mut self,\n-        generics: &'tcx hir::Generics<'tcx>,\n-        prefix: &str,\n-        id: hir::HirId,\n-    ) {\n-        for param in generics.params {\n-            match param.kind {\n-                hir::GenericParamKind::Lifetime { .. } => {}\n-                hir::GenericParamKind::Type { .. } => {\n-                    let param_ss = param.name.ident().span;\n-                    let name = escape(self.span.snippet(param_ss));\n-                    // Append $id to name to make sure each one is unique.\n-                    let qualname = format!(\"{}::{}${}\", prefix, name, id);\n-                    if !self.span.filter_generated(param_ss) {\n-                        let id = id_from_def_id(param.def_id.to_def_id());\n-                        let span = self.span_from_span(param_ss);\n-\n-                        self.dumper.dump_def(\n-                            &Access { public: false, reachable: false },\n-                            Def {\n-                                kind: DefKind::Type,\n-                                id,\n-                                span,\n-                                name,\n-                                qualname,\n-                                value: String::new(),\n-                                parent: None,\n-                                children: vec![],\n-                                decl_id: None,\n-                                docs: String::new(),\n-                                sig: None,\n-                                attributes: vec![],\n-                            },\n-                        );\n-                    }\n-                }\n-                hir::GenericParamKind::Const { .. } => {}\n-            }\n-        }\n-\n-        self.visit_generics(generics)\n-    }\n-\n-    fn process_fn(\n-        &mut self,\n-        item: &'tcx hir::Item<'tcx>,\n-        decl: &'tcx hir::FnDecl<'tcx>,\n-        _header: &'tcx hir::FnHeader,\n-        ty_params: &'tcx hir::Generics<'tcx>,\n-        body: hir::BodyId,\n-    ) {\n-        let map = self.tcx.hir();\n-        self.nest_typeck_results(item.owner_id.def_id, |v| {\n-            let body = map.body(body);\n-            if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n-                down_cast_data!(fn_data, DefData, item.span);\n-                v.process_formals(body.params, &fn_data.qualname);\n-                v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id());\n-\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item.owner_id.def_id), fn_data);\n-            }\n-\n-            for arg in decl.inputs {\n-                v.visit_ty(arg)\n-            }\n-\n-            if let hir::FnRetTy::Return(ref ret_ty) = decl.output {\n-                v.visit_ty(ret_ty)\n-            }\n-\n-            v.visit_expr(&body.value);\n-        });\n-    }\n-\n-    fn process_static_or_const_item(\n-        &mut self,\n-        item: &'tcx hir::Item<'tcx>,\n-        typ: &'tcx hir::Ty<'tcx>,\n-        expr: &'tcx hir::Expr<'tcx>,\n-    ) {\n-        self.nest_typeck_results(item.owner_id.def_id, |v| {\n-            if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n-                down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item.owner_id.def_id), var_data);\n-            }\n-            v.visit_ty(&typ);\n-            v.visit_expr(expr);\n-        });\n-    }\n-\n-    fn process_assoc_const(\n-        &mut self,\n-        owner_id: hir::OwnerId,\n-        ident: Ident,\n-        typ: &'tcx hir::Ty<'tcx>,\n-        expr: Option<&'tcx hir::Expr<'tcx>>,\n-        parent_id: DefId,\n-        attrs: &'tcx [ast::Attribute],\n-    ) {\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(owner_id.to_def_id()));\n-\n-        if !self.span.filter_generated(ident.span) {\n-            let sig = sig::assoc_const_signature(owner_id, ident.name, typ, expr, &self.save_ctxt);\n-            let span = self.span_from_span(ident.span);\n-\n-            self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, owner_id.def_id),\n-                Def {\n-                    kind: DefKind::Const,\n-                    id: id_from_def_id(owner_id.to_def_id()),\n-                    span,\n-                    name: ident.name.to_string(),\n-                    qualname,\n-                    value: ty_to_string(&typ),\n-                    parent: Some(id_from_def_id(parent_id)),\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.save_ctxt.docs_for_attrs(attrs),\n-                    sig,\n-                    attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n-                },\n-            );\n-        }\n-\n-        // walk type and init value\n-        self.nest_typeck_results(owner_id.def_id, |v| {\n-            v.visit_ty(typ);\n-            if let Some(expr) = expr {\n-                v.visit_expr(expr);\n-            }\n-        });\n-    }\n-\n-    // FIXME tuple structs should generate tuple-specific data.\n-    fn process_struct(\n-        &mut self,\n-        item: &'tcx hir::Item<'tcx>,\n-        def: &'tcx hir::VariantData<'tcx>,\n-        ty_params: &'tcx hir::Generics<'tcx>,\n-    ) {\n-        debug!(\"process_struct {:?} {:?}\", item, item.span);\n-        let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n-\n-        let kind = match item.kind {\n-            hir::ItemKind::Struct(_, _) => DefKind::Struct,\n-            hir::ItemKind::Union(_, _) => DefKind::Union,\n-            _ => unreachable!(),\n-        };\n-\n-        let (value, fields) = match item.kind {\n-            hir::ItemKind::Struct(hir::VariantData::Struct(ref fields, ..), ..)\n-            | hir::ItemKind::Union(hir::VariantData::Struct(ref fields, ..), ..) => {\n-                let include_priv_fields = !self.save_ctxt.config.pub_only;\n-                let fields_str = fields\n-                    .iter()\n-                    .filter_map(|f| {\n-                        if include_priv_fields {\n-                            return Some(f.ident.to_string());\n-                        }\n-                        if self.save_ctxt.tcx.visibility(f.def_id).is_public() {\n-                            Some(f.ident.to_string())\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .collect::<Vec<_>>()\n-                    .join(\", \");\n-                let value = format!(\"{} {{ {} }}\", name, fields_str);\n-                (value, fields.iter().map(|f| id_from_def_id(f.def_id.to_def_id())).collect())\n-            }\n-            _ => (String::new(), vec![]),\n-        };\n-\n-        if !self.span.filter_generated(item.ident.span) {\n-            let span = self.span_from_span(item.ident.span);\n-            let attrs = self.tcx.hir().attrs(item.hir_id());\n-            self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item.owner_id.def_id),\n-                Def {\n-                    kind,\n-                    id: id_from_def_id(item.owner_id.to_def_id()),\n-                    span,\n-                    name,\n-                    qualname: qualname.clone(),\n-                    value,\n-                    parent: None,\n-                    children: fields,\n-                    decl_id: None,\n-                    docs: self.save_ctxt.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, &self.save_ctxt),\n-                    attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                },\n-            );\n-        }\n-\n-        self.nest_typeck_results(item.owner_id.def_id, |v| {\n-            for field in def.fields() {\n-                v.process_struct_field_def(field, item.owner_id.def_id);\n-                v.visit_ty(&field.ty);\n-            }\n-\n-            v.process_generic_params(ty_params, &qualname, item.hir_id());\n-        });\n-    }\n-\n-    fn process_enum(\n-        &mut self,\n-        item: &'tcx hir::Item<'tcx>,\n-        enum_definition: &'tcx hir::EnumDef<'tcx>,\n-        ty_params: &'tcx hir::Generics<'tcx>,\n-    ) {\n-        let enum_data = self.save_ctxt.get_item_data(item);\n-        let Some(enum_data) = enum_data else {\n-            return;\n-        };\n-        down_cast_data!(enum_data, DefData, item.span);\n-\n-        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n-\n-        for variant in enum_definition.variants {\n-            let name = variant.ident.name.to_string();\n-            let qualname = format!(\"{}::{}\", enum_data.qualname, name);\n-            let name_span = variant.ident.span;\n-\n-            match variant.data {\n-                hir::VariantData::Struct(ref fields, ..) => {\n-                    let fields_str =\n-                        fields.iter().map(|f| f.ident.to_string()).collect::<Vec<_>>().join(\", \");\n-                    let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n-                    if !self.span.filter_generated(name_span) {\n-                        let span = self.span_from_span(name_span);\n-                        let id = id_from_def_id(variant.def_id.to_def_id());\n-                        let parent = Some(id_from_def_id(item.owner_id.to_def_id()));\n-                        let attrs = self.tcx.hir().attrs(variant.hir_id);\n-\n-                        self.dumper.dump_def(\n-                            &access,\n-                            Def {\n-                                kind: DefKind::StructVariant,\n-                                id,\n-                                span,\n-                                name,\n-                                qualname,\n-                                value,\n-                                parent,\n-                                children: vec![],\n-                                decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(attrs),\n-                                sig: sig::variant_signature(variant, &self.save_ctxt),\n-                                attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                            },\n-                        );\n-                    }\n-                }\n-                ref v => {\n-                    let mut value = format!(\"{}::{}\", enum_data.name, name);\n-                    if let hir::VariantData::Tuple(fields, _, _) = v {\n-                        value.push('(');\n-                        value.push_str(\n-                            &fields\n-                                .iter()\n-                                .map(|f| ty_to_string(&f.ty))\n-                                .collect::<Vec<_>>()\n-                                .join(\", \"),\n-                        );\n-                        value.push(')');\n-                    }\n-                    if !self.span.filter_generated(name_span) {\n-                        let span = self.span_from_span(name_span);\n-                        let id = id_from_def_id(variant.def_id.to_def_id());\n-                        let parent = Some(id_from_def_id(item.owner_id.to_def_id()));\n-                        let attrs = self.tcx.hir().attrs(variant.hir_id);\n-\n-                        self.dumper.dump_def(\n-                            &access,\n-                            Def {\n-                                kind: DefKind::TupleVariant,\n-                                id,\n-                                span,\n-                                name,\n-                                qualname,\n-                                value,\n-                                parent,\n-                                children: vec![],\n-                                decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(attrs),\n-                                sig: sig::variant_signature(variant, &self.save_ctxt),\n-                                attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                            },\n-                        );\n-                    }\n-                }\n-            }\n-\n-            for field in variant.data.fields() {\n-                self.process_struct_field_def(field, variant.def_id);\n-                self.visit_ty(field.ty);\n-            }\n-        }\n-        self.process_generic_params(ty_params, &enum_data.qualname, item.hir_id());\n-        self.dumper.dump_def(&access, enum_data);\n-    }\n-\n-    fn process_impl(&mut self, item: &'tcx hir::Item<'tcx>, impl_: &'tcx hir::Impl<'tcx>) {\n-        if let Some(impl_data) = self.save_ctxt.get_item_data(item) {\n-            if !self.span.filter_generated(item.span) {\n-                if let super::Data::RelationData(rel, imp) = impl_data {\n-                    self.dumper.dump_relation(rel);\n-                    self.dumper.dump_impl(imp);\n-                } else {\n-                    span_bug!(item.span, \"unexpected data kind: {:?}\", impl_data);\n-                }\n-            }\n-        }\n-\n-        let map = self.tcx.hir();\n-        self.nest_typeck_results(item.owner_id.def_id, |v| {\n-            v.visit_ty(&impl_.self_ty);\n-            if let Some(trait_ref) = &impl_.of_trait {\n-                v.process_path(trait_ref.hir_ref_id, &hir::QPath::Resolved(None, &trait_ref.path));\n-            }\n-            v.process_generic_params(&impl_.generics, \"\", item.hir_id());\n-            for impl_item in impl_.items {\n-                v.process_impl_item(map.impl_item(impl_item.id), item.owner_id.to_def_id());\n-            }\n-        });\n-    }\n-\n-    fn process_trait(\n-        &mut self,\n-        item: &'tcx hir::Item<'tcx>,\n-        generics: &'tcx hir::Generics<'tcx>,\n-        trait_refs: hir::GenericBounds<'tcx>,\n-        methods: &'tcx [hir::TraitItemRef],\n-    ) {\n-        let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n-        let mut val = name.clone();\n-        if !generics.params.is_empty() {\n-            val.push_str(&generic_params_to_string(generics.params));\n-        }\n-        if !trait_refs.is_empty() {\n-            val.push_str(\": \");\n-            val.push_str(&bounds_to_string(trait_refs));\n-        }\n-        if !self.span.filter_generated(item.ident.span) {\n-            let id = id_from_def_id(item.owner_id.to_def_id());\n-            let span = self.span_from_span(item.ident.span);\n-            let children =\n-                methods.iter().map(|i| id_from_def_id(i.id.owner_id.to_def_id())).collect();\n-            let attrs = self.tcx.hir().attrs(item.hir_id());\n-            self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item.owner_id.def_id),\n-                Def {\n-                    kind: DefKind::Trait,\n-                    id,\n-                    span,\n-                    name,\n-                    qualname: qualname.clone(),\n-                    value: val,\n-                    parent: None,\n-                    children,\n-                    decl_id: None,\n-                    docs: self.save_ctxt.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, &self.save_ctxt),\n-                    attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                },\n-            );\n-        }\n-\n-        // supertraits\n-        for super_bound in trait_refs.iter() {\n-            let (def_id, sub_span) = match *super_bound {\n-                hir::GenericBound::Trait(ref trait_ref, _) => (\n-                    self.lookup_def_id(trait_ref.trait_ref.hir_ref_id),\n-                    trait_ref.trait_ref.path.segments.last().unwrap().ident.span,\n-                ),\n-                hir::GenericBound::LangItemTrait(lang_item, span, _, _) => {\n-                    (Some(self.tcx.require_lang_item(lang_item, Some(span))), span)\n-                }\n-                hir::GenericBound::Outlives(..) => continue,\n-            };\n-\n-            if let Some(id) = def_id {\n-                if !self.span.filter_generated(sub_span) {\n-                    let span = self.span_from_span(sub_span);\n-                    self.dumper.dump_ref(Ref {\n-                        kind: RefKind::Type,\n-                        span: span.clone(),\n-                        ref_id: id_from_def_id(id),\n-                    });\n-\n-                    self.dumper.dump_relation(Relation {\n-                        kind: RelationKind::SuperTrait,\n-                        span,\n-                        from: id_from_def_id(id),\n-                        to: id_from_def_id(item.owner_id.to_def_id()),\n-                    });\n-                }\n-            }\n-        }\n-\n-        // walk generics and methods\n-        self.process_generic_params(generics, &qualname, item.hir_id());\n-        for method in methods {\n-            let map = self.tcx.hir();\n-            self.process_trait_item(map.trait_item(method.id), item.owner_id.to_def_id())\n-        }\n-    }\n-\n-    // `item` is the module in question, represented as an( item.\n-    fn process_mod(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item.owner_id.def_id), mod_data);\n-        }\n-    }\n-\n-    fn dump_path_ref(&mut self, id: hir::HirId, path: &hir::QPath<'tcx>) {\n-        let path_data = self.save_ctxt.get_path_data(id, path);\n-        if let Some(path_data) = path_data {\n-            self.dumper.dump_ref(path_data);\n-        }\n-    }\n-\n-    fn dump_path_segment_ref(&mut self, id: hir::HirId, segment: &hir::PathSegment<'tcx>) {\n-        let segment_data = self.save_ctxt.get_path_segment_data_with_id(segment, id);\n-        if let Some(segment_data) = segment_data {\n-            self.dumper.dump_ref(segment_data);\n-        }\n-    }\n-\n-    fn process_path(&mut self, id: hir::HirId, path: &hir::QPath<'tcx>) {\n-        if self.span.filter_generated(path.span()) {\n-            return;\n-        }\n-        self.dump_path_ref(id, path);\n-\n-        // Type arguments\n-        let segments = match path {\n-            hir::QPath::Resolved(ty, path) => {\n-                if let Some(ty) = ty {\n-                    self.visit_ty(ty);\n-                }\n-                path.segments\n-            }\n-            hir::QPath::TypeRelative(ty, segment) => {\n-                self.visit_ty(ty);\n-                std::slice::from_ref(*segment)\n-            }\n-            hir::QPath::LangItem(..) => return,\n-        };\n-        for seg in segments {\n-            if let Some(ref generic_args) = seg.args {\n-                for arg in generic_args.args {\n-                    if let hir::GenericArg::Type(ref ty) = arg {\n-                        self.visit_ty(ty);\n-                    }\n-                }\n-            }\n-        }\n-\n-        if let hir::QPath::Resolved(_, path) = path {\n-            self.write_sub_paths_truncated(path);\n-        }\n-    }\n-\n-    fn process_struct_lit(\n-        &mut self,\n-        ex: &'tcx hir::Expr<'tcx>,\n-        path: &'tcx hir::QPath<'tcx>,\n-        fields: &'tcx [hir::ExprField<'tcx>],\n-        variant: &'tcx ty::VariantDef,\n-        rest: Option<&'tcx hir::Expr<'tcx>>,\n-    ) {\n-        if let Some(_ex_res_data) = self.save_ctxt.get_expr_data(ex) {\n-            if let hir::QPath::Resolved(_, path) = path {\n-                self.write_sub_paths_truncated(path);\n-            }\n-            // For MyEnum::MyVariant, get_expr_data gives us MyEnum, not MyVariant.\n-            // For recording the span's ref id, we want MyVariant.\n-            if !generated_code(ex.span) {\n-                let sub_span = path.last_segment_span();\n-                let span = self.save_ctxt.span_from_span(sub_span);\n-                let reff =\n-                    Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(variant.def_id) };\n-                self.dumper.dump_ref(reff);\n-            }\n-\n-            for field in fields {\n-                if let Some(field_data) = self.save_ctxt.get_field_ref_data(field, variant) {\n-                    self.dumper.dump_ref(field_data);\n-                }\n-\n-                self.visit_expr(&field.expr)\n-            }\n-        }\n-\n-        if let Some(base) = rest {\n-            self.visit_expr(&base);\n-        }\n-    }\n-\n-    fn process_method_call(\n-        &mut self,\n-        ex: &'tcx hir::Expr<'tcx>,\n-        seg: &'tcx hir::PathSegment<'tcx>,\n-        receiver: &'tcx hir::Expr<'tcx>,\n-        args: &'tcx [hir::Expr<'tcx>],\n-    ) {\n-        debug!(\"process_method_call {:?} {:?}\", ex, ex.span);\n-        if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n-            down_cast_data!(mcd, RefData, ex.span);\n-            if !generated_code(ex.span) {\n-                self.dumper.dump_ref(mcd);\n-            }\n-        }\n-\n-        // Explicit types in the turbo-fish.\n-        if let Some(generic_args) = seg.args {\n-            for arg in generic_args.args {\n-                if let hir::GenericArg::Type(ty) = arg {\n-                    self.visit_ty(&ty)\n-                };\n-            }\n-        }\n-\n-        // walk receiver and args\n-        self.visit_expr(receiver);\n-        walk_list!(self, visit_expr, args);\n-    }\n-\n-    fn process_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n-        match p.kind {\n-            hir::PatKind::Struct(ref _path, fields, _) => {\n-                // FIXME do something with _path?\n-                let adt = match self.save_ctxt.typeck_results().node_type_opt(p.hir_id) {\n-                    Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n-                    _ => {\n-                        intravisit::walk_pat(self, p);\n-                        return;\n-                    }\n-                };\n-                let variant = adt.variant_of_res(self.save_ctxt.get_path_res(p.hir_id));\n-\n-                for field in fields {\n-                    if let Some(index) = self.tcx.find_field_index(field.ident, variant) {\n-                        if !self.span.filter_generated(field.ident.span) {\n-                            let span = self.span_from_span(field.ident.span);\n-                            self.dumper.dump_ref(Ref {\n-                                kind: RefKind::Variable,\n-                                span,\n-                                ref_id: id_from_def_id(variant.fields[index].did),\n-                            });\n-                        }\n-                    }\n-                    self.visit_pat(&field.pat);\n-                }\n-            }\n-            _ => intravisit::walk_pat(self, p),\n-        }\n-    }\n-\n-    fn process_var_decl(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n-        // The pattern could declare multiple new vars,\n-        // we must walk the pattern and collect them all.\n-        let mut collector = PathCollector::new(self.tcx);\n-        collector.visit_pat(&pat);\n-        self.visit_pat(&pat);\n-\n-        // Process collected paths.\n-        for (id, ident, _) in collector.collected_idents {\n-            let res = self.save_ctxt.get_path_res(id);\n-            match res {\n-                Res::Local(hir_id) => {\n-                    let typ = self\n-                        .save_ctxt\n-                        .typeck_results()\n-                        .node_type_opt(hir_id)\n-                        .map(|t| t.to_string())\n-                        .unwrap_or_default();\n-\n-                    // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-                    if !self.span.filter_generated(ident.span) {\n-                        let qualname = format!(\"{}${}\", ident, hir_id);\n-                        let id = id_from_hir_id(hir_id);\n-                        let span = self.span_from_span(ident.span);\n-\n-                        self.dumper.dump_def(\n-                            &Access { public: false, reachable: false },\n-                            Def {\n-                                kind: DefKind::Local,\n-                                id,\n-                                span,\n-                                name: ident.to_string(),\n-                                qualname,\n-                                value: typ,\n-                                parent: None,\n-                                children: vec![],\n-                                decl_id: None,\n-                                docs: String::new(),\n-                                sig: None,\n-                                attributes: vec![],\n-                            },\n-                        );\n-                    }\n-                }\n-                Res::Def(\n-                    HirDefKind::Ctor(..)\n-                    | HirDefKind::Const\n-                    | HirDefKind::AssocConst\n-                    | HirDefKind::Struct\n-                    | HirDefKind::Variant\n-                    | HirDefKind::TyAlias\n-                    | HirDefKind::AssocTy,\n-                    _,\n-                )\n-                | Res::SelfTyParam { .. }\n-                | Res::SelfTyAlias { .. } => {\n-                    self.dump_path_segment_ref(\n-                        id,\n-                        &hir::PathSegment::new(ident, hir::HirId::INVALID, Res::Err),\n-                    );\n-                }\n-                def => {\n-                    error!(\"unexpected definition kind when processing collected idents: {:?}\", def)\n-                }\n-            }\n-        }\n-\n-        for (id, ref path) in collector.collected_paths {\n-            self.process_path(id, path);\n-        }\n-    }\n-\n-    /// Extracts macro use and definition information from the AST node defined\n-    /// by the given NodeId, using the expansion information from the node's\n-    /// span.\n-    ///\n-    /// If the span is not macro-generated, do nothing, else use callee and\n-    /// callsite spans to record macro definition and use data, using the\n-    /// mac_uses and mac_defs sets to prevent multiples.\n-    fn process_macro_use(&mut self, _span: Span) {\n-        // FIXME if we're not dumping the defs (see below), there is no point\n-        // dumping refs either.\n-        // let source_span = span.source_callsite();\n-        // if !self.macro_calls.insert(source_span) {\n-        //     return;\n-        // }\n-\n-        // let data = match self.save_ctxt.get_macro_use_data(span) {\n-        //     None => return,\n-        //     Some(data) => data,\n-        // };\n-\n-        // self.dumper.macro_use(data);\n-\n-        // FIXME write the macro def\n-        // let mut hasher = DefaultHasher::new();\n-        // data.callee_span.hash(&mut hasher);\n-        // let hash = hasher.finish();\n-        // let qualname = format!(\"{}::{}\", data.name, hash);\n-        // Don't write macro definition for imported macros\n-        // if !self.mac_defs.contains(&data.callee_span)\n-        //     && !data.imported {\n-        //     self.mac_defs.insert(data.callee_span);\n-        //     if let Some(sub_span) = self.span.span_for_macro_def_name(data.callee_span) {\n-        //         self.dumper.macro_data(MacroData {\n-        //             span: sub_span,\n-        //             name: data.name.clone(),\n-        //             qualname: qualname.clone(),\n-        //             // FIXME where do macro docs come from?\n-        //             docs: String::new(),\n-        //         }.lower(self.tcx));\n-        //     }\n-        // }\n-    }\n-\n-    fn process_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>, trait_id: DefId) {\n-        self.process_macro_use(trait_item.span);\n-        match trait_item.kind {\n-            hir::TraitItemKind::Const(ref ty, body) => {\n-                let body = body.map(|b| self.tcx.hir().body(b).value);\n-                let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n-                self.process_assoc_const(\n-                    trait_item.owner_id,\n-                    trait_item.ident,\n-                    &ty,\n-                    body,\n-                    trait_id,\n-                    attrs,\n-                );\n-            }\n-            hir::TraitItemKind::Fn(ref sig, ref trait_fn) => {\n-                let body =\n-                    if let hir::TraitFn::Provided(body) = trait_fn { Some(*body) } else { None };\n-                self.process_method(\n-                    sig,\n-                    body,\n-                    trait_item.owner_id,\n-                    trait_item.ident,\n-                    &trait_item.generics,\n-                    trait_item.span,\n-                );\n-            }\n-            hir::TraitItemKind::Type(ref bounds, ref default_ty) => {\n-                // FIXME do something with _bounds (for type refs)\n-                let name = trait_item.ident.name.to_string();\n-                let qualname =\n-                    format!(\"::{}\", self.tcx.def_path_str(trait_item.owner_id.to_def_id()));\n-\n-                if !self.span.filter_generated(trait_item.ident.span) {\n-                    let span = self.span_from_span(trait_item.ident.span);\n-                    let id = id_from_def_id(trait_item.owner_id.to_def_id());\n-                    let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n-\n-                    self.dumper.dump_def(\n-                        &Access { public: true, reachable: true },\n-                        Def {\n-                            kind: DefKind::Type,\n-                            id,\n-                            span,\n-                            name,\n-                            qualname,\n-                            value: self.span.snippet(trait_item.span),\n-                            parent: Some(id_from_def_id(trait_id)),\n-                            children: vec![],\n-                            decl_id: None,\n-                            docs: self.save_ctxt.docs_for_attrs(attrs),\n-                            sig: sig::assoc_type_signature(\n-                                trait_item.owner_id,\n-                                trait_item.ident,\n-                                Some(bounds),\n-                                default_ty.as_deref(),\n-                                &self.save_ctxt,\n-                            ),\n-                            attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                        },\n-                    );\n-                }\n-\n-                if let Some(default_ty) = default_ty {\n-                    self.visit_ty(default_ty)\n-                }\n-            }\n-        }\n-    }\n-\n-    fn process_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>, impl_id: DefId) {\n-        self.process_macro_use(impl_item.span);\n-        match impl_item.kind {\n-            hir::ImplItemKind::Const(ref ty, body) => {\n-                let body = self.tcx.hir().body(body);\n-                let attrs = self.tcx.hir().attrs(impl_item.hir_id());\n-                self.process_assoc_const(\n-                    impl_item.owner_id,\n-                    impl_item.ident,\n-                    &ty,\n-                    Some(&body.value),\n-                    impl_id,\n-                    attrs,\n-                );\n-            }\n-            hir::ImplItemKind::Fn(ref sig, body) => {\n-                self.process_method(\n-                    sig,\n-                    Some(body),\n-                    impl_item.owner_id,\n-                    impl_item.ident,\n-                    &impl_item.generics,\n-                    impl_item.span,\n-                );\n-            }\n-            hir::ImplItemKind::Type(ref ty) => {\n-                // FIXME: uses of the assoc type should ideally point to this\n-                // 'def' and the name here should be a ref to the def in the\n-                // trait.\n-                self.visit_ty(ty)\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn process_crate(&mut self) {\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(CRATE_DEF_ID.to_def_id()));\n-\n-        let sm = self.tcx.sess.source_map();\n-        let krate_mod = self.tcx.hir().root_module();\n-        let filename = sm.span_to_filename(krate_mod.spans.inner_span);\n-        let data_id = id_from_def_id(CRATE_DEF_ID.to_def_id());\n-        let children =\n-            krate_mod.item_ids.iter().map(|i| id_from_def_id(i.owner_id.to_def_id())).collect();\n-        let span = self.span_from_span(krate_mod.spans.inner_span);\n-        let attrs = self.tcx.hir().attrs(hir::CRATE_HIR_ID);\n-\n-        self.dumper.dump_def(\n-            &Access { public: true, reachable: true },\n-            Def {\n-                kind: DefKind::Mod,\n-                id: data_id,\n-                name: String::new(),\n-                qualname,\n-                span,\n-                value: filename.prefer_remapped().to_string(),\n-                children,\n-                parent: None,\n-                decl_id: None,\n-                docs: self.save_ctxt.docs_for_attrs(attrs),\n-                sig: None,\n-                attributes: lower_attributes(attrs.to_owned(), &self.save_ctxt),\n-            },\n-        );\n-        self.tcx.hir().walk_toplevel_module(self);\n-    }\n-\n-    fn process_bounds(&mut self, bounds: hir::GenericBounds<'tcx>) {\n-        for bound in bounds {\n-            if let hir::GenericBound::Trait(ref trait_ref, _) = *bound {\n-                self.process_path(\n-                    trait_ref.trait_ref.hir_ref_id,\n-                    &hir::QPath::Resolved(None, &trait_ref.trait_ref.path),\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.tcx.hir()\n-    }\n-\n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_macro_use(item.span);\n-        match item.kind {\n-            hir::ItemKind::Use(path, hir::UseKind::Single) => {\n-                let sub_span = path.segments.last().unwrap().ident.span;\n-                if !self.span.filter_generated(sub_span) {\n-                    let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n-                    let ref_id = self.lookup_def_id(item.hir_id()).map(id_from_def_id);\n-                    let span = self.span_from_span(sub_span);\n-                    let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n-                    self.dumper.import(\n-                        &access,\n-                        Import {\n-                            kind: ImportKind::Use,\n-                            ref_id,\n-                            span,\n-                            alias_span: None,\n-                            name: item.ident.to_string(),\n-                            value: String::new(),\n-                            parent: Some(id_from_def_id(parent.to_def_id())),\n-                        },\n-                    );\n-                    self.write_sub_paths_truncated(&path);\n-                }\n-            }\n-            hir::ItemKind::Use(path, hir::UseKind::Glob) => {\n-                // Make a comma-separated list of names of imported modules.\n-                let names = self.tcx.names_imported_by_glob_use(item.owner_id.def_id);\n-                let names: Vec<_> = names.iter().map(|n| n.to_string()).collect();\n-\n-                // Otherwise it's a span with wrong macro expansion info, which\n-                // we don't want to track anyway, since it's probably macro-internal `use`\n-                if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n-                    if !self.span.filter_generated(item.span) {\n-                        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n-                        let span = self.span_from_span(sub_span);\n-                        let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n-                        self.dumper.import(\n-                            &access,\n-                            Import {\n-                                kind: ImportKind::GlobUse,\n-                                ref_id: None,\n-                                span,\n-                                alias_span: None,\n-                                name: \"*\".to_owned(),\n-                                value: names.join(\", \"),\n-                                parent: Some(id_from_def_id(parent.to_def_id())),\n-                            },\n-                        );\n-                        self.write_sub_paths(&path);\n-                    }\n-                }\n-            }\n-            hir::ItemKind::ExternCrate(_) => {\n-                let name_span = item.ident.span;\n-                if !self.span.filter_generated(name_span) {\n-                    let span = self.span_from_span(name_span);\n-                    let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n-                    self.dumper.import(\n-                        &Access { public: false, reachable: false },\n-                        Import {\n-                            kind: ImportKind::ExternCrate,\n-                            ref_id: None,\n-                            span,\n-                            alias_span: None,\n-                            name: item.ident.to_string(),\n-                            value: String::new(),\n-                            parent: Some(id_from_def_id(parent.to_def_id())),\n-                        },\n-                    );\n-                }\n-            }\n-            hir::ItemKind::Fn(ref sig, ref ty_params, body) => {\n-                self.process_fn(item, sig.decl, &sig.header, ty_params, body)\n-            }\n-            hir::ItemKind::Static(ref typ, _, body) => {\n-                let body = self.tcx.hir().body(body);\n-                self.process_static_or_const_item(item, typ, &body.value)\n-            }\n-            hir::ItemKind::Const(ref typ, body) => {\n-                let body = self.tcx.hir().body(body);\n-                self.process_static_or_const_item(item, typ, &body.value)\n-            }\n-            hir::ItemKind::Struct(ref def, ref ty_params)\n-            | hir::ItemKind::Union(ref def, ref ty_params) => {\n-                self.process_struct(item, def, ty_params)\n-            }\n-            hir::ItemKind::Enum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n-            hir::ItemKind::Impl(ref impl_) => self.process_impl(item, impl_),\n-            hir::ItemKind::Trait(_, _, ref generics, ref trait_refs, methods) => {\n-                self.process_trait(item, generics, trait_refs, methods)\n-            }\n-            hir::ItemKind::Mod(ref m) => {\n-                self.process_mod(item);\n-                intravisit::walk_mod(self, m, item.hir_id());\n-            }\n-            hir::ItemKind::TyAlias(ty, ref generics) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n-                let value = ty_to_string(&ty);\n-                if !self.span.filter_generated(item.ident.span) {\n-                    let span = self.span_from_span(item.ident.span);\n-                    let id = id_from_def_id(item.owner_id.to_def_id());\n-                    let attrs = self.tcx.hir().attrs(item.hir_id());\n-\n-                    self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item.owner_id.def_id),\n-                        Def {\n-                            kind: DefKind::Type,\n-                            id,\n-                            span,\n-                            name: item.ident.to_string(),\n-                            qualname: qualname.clone(),\n-                            value,\n-                            parent: None,\n-                            children: vec![],\n-                            decl_id: None,\n-                            docs: self.save_ctxt.docs_for_attrs(attrs),\n-                            sig: sig::item_signature(item, &self.save_ctxt),\n-                            attributes: lower_attributes(attrs.to_vec(), &self.save_ctxt),\n-                        },\n-                    );\n-                }\n-\n-                self.visit_ty(ty);\n-                self.process_generic_params(generics, &qualname, item.hir_id());\n-            }\n-            _ => intravisit::walk_item(self, item),\n-        }\n-    }\n-\n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n-        for param in generics.params {\n-            match param.kind {\n-                hir::GenericParamKind::Lifetime { .. } => {}\n-                hir::GenericParamKind::Type { ref default, .. } => {\n-                    if let Some(ref ty) = default {\n-                        self.visit_ty(ty);\n-                    }\n-                }\n-                hir::GenericParamKind::Const { ref ty, ref default } => {\n-                    self.visit_ty(ty);\n-                    if let Some(default) = default {\n-                        self.visit_anon_const(default);\n-                    }\n-                }\n-            }\n-        }\n-        for pred in generics.predicates {\n-            if let hir::WherePredicate::BoundPredicate(ref wbp) = *pred {\n-                self.process_bounds(wbp.bounds);\n-                self.visit_ty(wbp.bounded_ty);\n-            }\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n-        self.process_macro_use(t.span);\n-        match t.kind {\n-            hir::TyKind::Path(ref path) => {\n-                if generated_code(t.span) {\n-                    return;\n-                }\n-\n-                if let Some(id) = self.lookup_def_id(t.hir_id) {\n-                    let sub_span = path.last_segment_span();\n-                    let span = self.span_from_span(sub_span);\n-                    self.dumper.dump_ref(Ref {\n-                        kind: RefKind::Type,\n-                        span,\n-                        ref_id: id_from_def_id(id),\n-                    });\n-                }\n-\n-                if let hir::QPath::Resolved(_, path) = path {\n-                    self.write_sub_paths_truncated(path);\n-                }\n-                intravisit::walk_qpath(self, path, t.hir_id);\n-            }\n-            hir::TyKind::Array(ref ty, ref length) => {\n-                self.visit_ty(ty);\n-                let map = self.tcx.hir();\n-                match length {\n-                    // FIXME(generic_arg_infer): We probably want to\n-                    // output the inferred type here? :shrug:\n-                    hir::ArrayLen::Infer(..) => {}\n-                    hir::ArrayLen::Body(anon_const) => self\n-                        .nest_typeck_results(anon_const.def_id, |v| {\n-                            v.visit_expr(&map.body(anon_const.body).value)\n-                        }),\n-                }\n-            }\n-            hir::TyKind::OpaqueDef(item_id, _, _) => {\n-                let item = self.tcx.hir().item(item_id);\n-                self.nest_typeck_results(item_id.owner_id.def_id, |v| v.visit_item(item));\n-            }\n-            _ => intravisit::walk_ty(self, t),\n-        }\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n-        debug!(\"visit_expr {:?}\", ex.kind);\n-        self.process_macro_use(ex.span);\n-        match ex.kind {\n-            hir::ExprKind::Struct(ref path, ref fields, ref rest) => {\n-                let hir_expr = self.save_ctxt.tcx.hir().expect_expr(ex.hir_id);\n-                let adt = match self.save_ctxt.typeck_results().expr_ty_opt(&hir_expr) {\n-                    Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n-                    _ => {\n-                        intravisit::walk_expr(self, ex);\n-                        return;\n-                    }\n-                };\n-                let res = self.save_ctxt.get_path_res(hir_expr.hir_id);\n-                self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), *rest)\n-            }\n-            hir::ExprKind::MethodCall(ref seg, receiver, args, _) => {\n-                self.process_method_call(ex, seg, receiver, args)\n-            }\n-            hir::ExprKind::Field(ref sub_ex, _) => {\n-                self.visit_expr(&sub_ex);\n-\n-                if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n-                    down_cast_data!(field_data, RefData, ex.span);\n-                    if !generated_code(ex.span) {\n-                        self.dumper.dump_ref(field_data);\n-                    }\n-                }\n-            }\n-            hir::ExprKind::Closure(&hir::Closure { ref fn_decl, body, def_id, .. }) => {\n-                let id = format!(\"${}\", ex.hir_id);\n-\n-                // walk arg and return types\n-                for ty in fn_decl.inputs {\n-                    self.visit_ty(ty);\n-                }\n-\n-                if let hir::FnRetTy::Return(ref ret_ty) = fn_decl.output {\n-                    self.visit_ty(ret_ty);\n-                }\n-\n-                // walk the body\n-                let map = self.tcx.hir();\n-                self.nest_typeck_results(def_id, |v| {\n-                    let body = map.body(body);\n-                    v.process_formals(body.params, &id);\n-                    v.visit_expr(&body.value)\n-                });\n-            }\n-            hir::ExprKind::Repeat(ref expr, ref length) => {\n-                self.visit_expr(expr);\n-                let map = self.tcx.hir();\n-                match length {\n-                    // FIXME(generic_arg_infer): We probably want to\n-                    // output the inferred type here? :shrug:\n-                    hir::ArrayLen::Infer(..) => {}\n-                    hir::ArrayLen::Body(anon_const) => self\n-                        .nest_typeck_results(anon_const.def_id, |v| {\n-                            v.visit_expr(&map.body(anon_const.body).value)\n-                        }),\n-                }\n-            }\n-            // In particular, we take this branch for call and path expressions,\n-            // where we'll index the idents involved just by continuing to walk.\n-            _ => intravisit::walk_expr(self, ex),\n-        }\n-    }\n-\n-    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n-        self.process_macro_use(p.span);\n-        self.process_pat(p);\n-    }\n-\n-    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n-        self.process_var_decl(&arm.pat);\n-        if let Some(hir::Guard::If(expr)) = &arm.guard {\n-            self.visit_expr(expr);\n-        }\n-        self.visit_expr(&arm.body);\n-    }\n-\n-    fn visit_qpath(&mut self, path: &'tcx hir::QPath<'tcx>, id: hir::HirId, _: Span) {\n-        self.process_path(id, path);\n-    }\n-\n-    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-        self.process_macro_use(s.span);\n-        intravisit::walk_stmt(self, s)\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.process_macro_use(l.span);\n-        self.process_var_decl(&l.pat);\n-\n-        // Just walk the initializer, the else branch and type (don't want to walk the pattern again).\n-        walk_list!(self, visit_ty, &l.ty);\n-        walk_list!(self, visit_expr, &l.init);\n-        walk_list!(self, visit_block, l.els);\n-    }\n-\n-    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n-\n-        match item.kind {\n-            hir::ForeignItemKind::Fn(decl, _, ref generics) => {\n-                if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n-                    down_cast_data!(fn_data, DefData, item.span);\n-\n-                    self.process_generic_params(generics, &fn_data.qualname, item.hir_id());\n-                    self.dumper.dump_def(&access, fn_data);\n-                }\n-\n-                for ty in decl.inputs {\n-                    self.visit_ty(ty);\n-                }\n-\n-                if let hir::FnRetTy::Return(ref ret_ty) = decl.output {\n-                    self.visit_ty(ret_ty);\n-                }\n-            }\n-            hir::ForeignItemKind::Static(ref ty, _) => {\n-                if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n-                    down_cast_data!(var_data, DefData, item.span);\n-                    self.dumper.dump_def(&access, var_data);\n-                }\n-\n-                self.visit_ty(ty);\n-            }\n-            hir::ForeignItemKind::Type => {\n-                if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n-                    down_cast_data!(var_data, DefData, item.span);\n-                    self.dumper.dump_def(&access, var_data);\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "5a2628287d60d6155fab1ba035988f71b94696ff", "filename": "compiler/rustc_save_analysis/src/dumper.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Fdumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Fdumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdumper.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,91 +0,0 @@\n-use rls_data::config::Config;\n-use rls_data::{\n-    self, Analysis, CompilationOptions, CratePreludeData, Def, DefKind, Impl, Import, MacroRef,\n-    Ref, RefKind, Relation,\n-};\n-use rls_span::{Column, Row};\n-\n-#[derive(Debug)]\n-pub struct Access {\n-    pub reachable: bool,\n-    pub public: bool,\n-}\n-\n-pub struct Dumper {\n-    result: Analysis,\n-    config: Config,\n-}\n-\n-impl Dumper {\n-    pub fn new(config: Config) -> Dumper {\n-        Dumper { config: config.clone(), result: Analysis::new(config) }\n-    }\n-\n-    pub fn analysis(&self) -> &Analysis {\n-        &self.result\n-    }\n-}\n-\n-impl Dumper {\n-    pub fn crate_prelude(&mut self, data: CratePreludeData) {\n-        self.result.prelude = Some(data)\n-    }\n-\n-    pub fn compilation_opts(&mut self, data: CompilationOptions) {\n-        self.result.compilation = Some(data);\n-    }\n-\n-    pub fn _macro_use(&mut self, data: MacroRef) {\n-        if self.config.pub_only || self.config.reachable_only {\n-            return;\n-        }\n-        self.result.macro_refs.push(data);\n-    }\n-\n-    pub fn import(&mut self, access: &Access, import: Import) {\n-        if !access.public && self.config.pub_only || !access.reachable && self.config.reachable_only\n-        {\n-            return;\n-        }\n-        self.result.imports.push(import);\n-    }\n-\n-    pub fn dump_ref(&mut self, data: Ref) {\n-        if self.config.pub_only || self.config.reachable_only {\n-            return;\n-        }\n-        self.result.refs.push(data);\n-    }\n-\n-    pub fn dump_def(&mut self, access: &Access, mut data: Def) {\n-        if !access.public && self.config.pub_only || !access.reachable && self.config.reachable_only\n-        {\n-            return;\n-        }\n-        if data.kind == DefKind::Mod && data.span.file_name.to_str().unwrap() != data.value {\n-            // If the module is an out-of-line definition, then we'll make the\n-            // definition the first character in the module's file and turn\n-            // the declaration into a reference to it.\n-            let rf = Ref { kind: RefKind::Mod, span: data.span, ref_id: data.id };\n-            self.result.refs.push(rf);\n-            data.span = rls_data::SpanData {\n-                file_name: data.value.clone().into(),\n-                byte_start: 0,\n-                byte_end: 0,\n-                line_start: Row::new_one_indexed(1),\n-                line_end: Row::new_one_indexed(1),\n-                column_start: Column::new_one_indexed(1),\n-                column_end: Column::new_one_indexed(1),\n-            }\n-        }\n-        self.result.defs.push(data);\n-    }\n-\n-    pub fn dump_relation(&mut self, data: Relation) {\n-        self.result.relations.push(data);\n-    }\n-\n-    pub fn dump_impl(&mut self, data: Impl) {\n-        self.result.impls.push(data);\n-    }\n-}"}, {"sha": "585aac8c1c3cc034fabcde0ea890a4e7c1ddb32c", "filename": "compiler/rustc_save_analysis/src/errors.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,10 +0,0 @@\n-use rustc_macros::Diagnostic;\n-\n-use std::path::Path;\n-\n-#[derive(Diagnostic)]\n-#[diag(save_analysis_could_not_open)]\n-pub(crate) struct CouldNotOpen<'a> {\n-    pub file_name: &'a Path,\n-    pub err: std::io::Error,\n-}"}, {"sha": "a9a92cc4f62ed9102a3039f58f01657f60eaef8d", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "removed", "additions": 0, "deletions": 1067, "changes": 1067, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,1067 +0,0 @@\n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(if_let_guard)]\n-#![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n-#![feature(never_type)]\n-#![deny(rustc::untranslatable_diagnostic)]\n-#![deny(rustc::diagnostic_outside_of_impl)]\n-\n-#[macro_use]\n-extern crate tracing;\n-\n-mod dump_visitor;\n-mod dumper;\n-#[macro_use]\n-mod span_utils;\n-mod errors;\n-mod sig;\n-\n-use rustc_ast as ast;\n-use rustc_ast::util::comments::beautify_doc_string;\n-use rustc_ast_pretty::pprust::attribute_to_string;\n-use rustc_hir as hir;\n-use rustc_hir::def::{DefKind as HirDefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::Node;\n-use rustc_hir_pretty::{enum_def_to_string, fn_to_string, ty_to_string};\n-use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::EffectiveVisibilities;\n-use rustc_middle::ty::{self, print::with_no_trimmed_paths, DefIdTree, TyCtxt};\n-use rustc_middle::{bug, span_bug};\n-use rustc_session::config::{CrateType, Input, OutputType};\n-use rustc_session::cstore::ExternCrate;\n-use rustc_session::output::{filename_for_metadata, out_filename};\n-use rustc_span::symbol::Ident;\n-use rustc_span::*;\n-\n-use std::cell::Cell;\n-use std::env;\n-use std::fs::File;\n-use std::io::BufWriter;\n-use std::path::{Path, PathBuf};\n-\n-use dump_visitor::DumpVisitor;\n-use span_utils::SpanUtils;\n-\n-use rls_data::config::Config;\n-use rls_data::{\n-    Analysis, Def, DefKind, ExternalCrateData, GlobalCrateId, Impl, ImplKind, MacroRef, Ref,\n-    RefKind, Relation, RelationKind, SpanData,\n-};\n-\n-pub struct SaveContext<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n-    effective_visibilities: &'tcx EffectiveVisibilities,\n-    span_utils: SpanUtils<'tcx>,\n-    config: Config,\n-    impl_counter: Cell<u32>,\n-}\n-\n-#[derive(Debug)]\n-pub enum Data {\n-    RefData(Ref),\n-    DefData(Def),\n-    RelationData(Relation, Impl),\n-}\n-\n-impl<'tcx> SaveContext<'tcx> {\n-    /// Gets the type-checking results for the current body.\n-    /// As this will ICE if called outside bodies, only call when working with\n-    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n-    #[track_caller]\n-    fn typeck_results(&self) -> &'tcx ty::TypeckResults<'tcx> {\n-        self.maybe_typeck_results.expect(\"`SaveContext::typeck_results` called outside of body\")\n-    }\n-\n-    fn span_from_span(&self, span: Span) -> SpanData {\n-        use rls_span::{Column, Row};\n-\n-        let sm = self.tcx.sess.source_map();\n-        let start = sm.lookup_char_pos(span.lo());\n-        let end = sm.lookup_char_pos(span.hi());\n-\n-        SpanData {\n-            file_name: start.file.name.prefer_remapped().to_string().into(),\n-            byte_start: span.lo().0,\n-            byte_end: span.hi().0,\n-            line_start: Row::new_one_indexed(start.line as u32),\n-            line_end: Row::new_one_indexed(end.line as u32),\n-            column_start: Column::new_one_indexed(start.col.0 as u32 + 1),\n-            column_end: Column::new_one_indexed(end.col.0 as u32 + 1),\n-        }\n-    }\n-\n-    /// Returns path to the compilation output (e.g., libfoo-12345678.rmeta)\n-    pub fn compilation_output(&self, crate_name: Symbol) -> PathBuf {\n-        let sess = &self.tcx.sess;\n-        // Save-analysis is emitted per whole session, not per each crate type\n-        let crate_type = sess.crate_types()[0];\n-        let outputs = &*self.tcx.output_filenames(());\n-\n-        if outputs.outputs.contains_key(&OutputType::Metadata) {\n-            filename_for_metadata(sess, crate_name, outputs)\n-        } else if outputs.outputs.should_codegen() {\n-            out_filename(sess, crate_type, outputs, crate_name)\n-        } else {\n-            // Otherwise it's only a DepInfo, in which case we return early and\n-            // not even reach the analysis stage.\n-            unreachable!()\n-        }\n-    }\n-\n-    /// List external crates used by the current crate.\n-    pub fn get_external_crates(&self) -> Vec<ExternalCrateData> {\n-        let mut result = Vec::with_capacity(self.tcx.crates(()).len());\n-\n-        for &n in self.tcx.crates(()).iter() {\n-            let Some(&ExternCrate { span, .. }) = self.tcx.extern_crate(n.as_def_id()) else {\n-                debug!(\"skipping crate {}, no data\", n);\n-                continue;\n-            };\n-            let lo_loc = self.span_utils.sess.source_map().lookup_char_pos(span.lo());\n-            result.push(ExternalCrateData {\n-                // FIXME: change file_name field to PathBuf in rls-data\n-                // https://github.com/nrc/rls-data/issues/7\n-                file_name: self.span_utils.make_filename_string(&lo_loc.file),\n-                num: n.as_u32(),\n-                id: GlobalCrateId {\n-                    name: self.tcx.crate_name(n).to_string(),\n-                    disambiguator: (\n-                        self.tcx.def_path_hash(n.as_def_id()).stable_crate_id().to_u64(),\n-                        0,\n-                    ),\n-                },\n-            });\n-        }\n-\n-        result\n-    }\n-\n-    pub fn get_extern_item_data(&self, item: &hir::ForeignItem<'_>) -> Option<Data> {\n-        let def_id = item.owner_id.to_def_id();\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-        let attrs = self.tcx.hir().attrs(item.hir_id());\n-        match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, arg_names, ref generics) => {\n-                filter!(self.span_utils, item.ident.span);\n-\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::ForeignFunction,\n-                    id: id_from_def_id(def_id),\n-                    span: self.span_from_span(item.ident.span),\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    value: fn_to_string(\n-                        decl,\n-                        hir::FnHeader {\n-                            // functions in extern block are implicitly unsafe\n-                            unsafety: hir::Unsafety::Unsafe,\n-                            // functions in extern block cannot be const\n-                            constness: hir::Constness::NotConst,\n-                            abi: self.tcx.hir().get_foreign_abi(item.hir_id()),\n-                            // functions in extern block cannot be async\n-                            asyncness: hir::IsAsync::NotAsync,\n-                        },\n-                        Some(item.ident.name),\n-                        generics,\n-                        arg_names,\n-                        None,\n-                    ),\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::foreign_item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ForeignItemKind::Static(ref ty, _) => {\n-                filter!(self.span_utils, item.ident.span);\n-\n-                let id = id_from_def_id(def_id);\n-                let span = self.span_from_span(item.ident.span);\n-\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::ForeignStatic,\n-                    id,\n-                    span,\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    value: ty_to_string(ty),\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::foreign_item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            // FIXME(plietar): needs a new DefKind in rls-data\n-            hir::ForeignItemKind::Type => None,\n-        }\n-    }\n-\n-    pub fn get_item_data(&self, item: &hir::Item<'_>) -> Option<Data> {\n-        let def_id = item.owner_id.to_def_id();\n-        let attrs = self.tcx.hir().attrs(item.hir_id());\n-        match item.kind {\n-            hir::ItemKind::Fn(ref sig, ref generics, _) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-                filter!(self.span_utils, item.ident.span);\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::Function,\n-                    id: id_from_def_id(def_id),\n-                    span: self.span_from_span(item.ident.span),\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    value: fn_to_string(\n-                        sig.decl,\n-                        sig.header,\n-                        Some(item.ident.name),\n-                        generics,\n-                        &[],\n-                        None,\n-                    ),\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ItemKind::Static(ref typ, ..) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-\n-                filter!(self.span_utils, item.ident.span);\n-\n-                let id = id_from_def_id(def_id);\n-                let span = self.span_from_span(item.ident.span);\n-\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::Static,\n-                    id,\n-                    span,\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    value: ty_to_string(&typ),\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ItemKind::Const(ref typ, _) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-                filter!(self.span_utils, item.ident.span);\n-\n-                let id = id_from_def_id(def_id);\n-                let span = self.span_from_span(item.ident.span);\n-\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::Const,\n-                    id,\n-                    span,\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    value: ty_to_string(typ),\n-                    parent: None,\n-                    children: vec![],\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ItemKind::Mod(ref m) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-\n-                let sm = self.tcx.sess.source_map();\n-                let filename = sm.span_to_filename(m.spans.inner_span);\n-\n-                filter!(self.span_utils, item.ident.span);\n-\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::Mod,\n-                    id: id_from_def_id(def_id),\n-                    name: item.ident.to_string(),\n-                    qualname,\n-                    span: self.span_from_span(item.ident.span),\n-                    value: filename.prefer_remapped().to_string(),\n-                    parent: None,\n-                    children: m\n-                        .item_ids\n-                        .iter()\n-                        .map(|i| id_from_def_id(i.owner_id.to_def_id()))\n-                        .collect(),\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ItemKind::Enum(ref def, ref generics) => {\n-                let name = item.ident.to_string();\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n-                filter!(self.span_utils, item.ident.span);\n-                let value =\n-                    enum_def_to_string(def, generics, item.ident.name, item.span);\n-                Some(Data::DefData(Def {\n-                    kind: DefKind::Enum,\n-                    id: id_from_def_id(def_id),\n-                    span: self.span_from_span(item.ident.span),\n-                    name,\n-                    qualname,\n-                    value,\n-                    parent: None,\n-                    children: def.variants.iter().map(|v| id_from_def_id(v.def_id.to_def_id())).collect(),\n-                    decl_id: None,\n-                    docs: self.docs_for_attrs(attrs),\n-                    sig: sig::item_signature(item, self),\n-                    attributes: lower_attributes(attrs.to_vec(), self),\n-                }))\n-            }\n-            hir::ItemKind::Impl(hir::Impl { ref of_trait, ref self_ty, ref items, .. })\n-                if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = self_ty.kind =>\n-            {\n-                // Common case impl for a struct or something basic.\n-                if generated_code(path.span) {\n-                    return None;\n-                }\n-                let sub_span = path.segments.last().unwrap().ident.span;\n-                filter!(self.span_utils, sub_span);\n-\n-                let impl_id = self.next_impl_id();\n-                let span = self.span_from_span(sub_span);\n-\n-                let type_data = self.lookup_def_id(self_ty.hir_id);\n-                type_data.map(|type_data| {\n-                    Data::RelationData(\n-                        Relation {\n-                            kind: RelationKind::Impl { id: impl_id },\n-                            span: span.clone(),\n-                            from: id_from_def_id(type_data),\n-                            to: of_trait\n-                                .as_ref()\n-                                .and_then(|t| self.lookup_def_id(t.hir_ref_id))\n-                                .map(id_from_def_id)\n-                                .unwrap_or_else(null_id),\n-                        },\n-                        Impl {\n-                            id: impl_id,\n-                            kind: match *of_trait {\n-                                Some(_) => ImplKind::Direct,\n-                                None => ImplKind::Inherent,\n-                            },\n-                            span,\n-                            value: String::new(),\n-                            parent: None,\n-                            children: items\n-                                .iter()\n-                                .map(|i| id_from_def_id(i.id.owner_id.to_def_id()))\n-                                .collect(),\n-                            docs: String::new(),\n-                            sig: None,\n-                            attributes: vec![],\n-                        },\n-                    )\n-                })\n-            }\n-            hir::ItemKind::Impl(_) => None,\n-            _ => {\n-                // FIXME\n-                bug!();\n-            }\n-        }\n-    }\n-\n-    pub fn get_field_data(&self, field: &hir::FieldDef<'_>, scope: LocalDefId) -> Option<Def> {\n-        let name = field.ident.to_string();\n-        let qualname = format!(\"::{}::{}\", self.tcx.def_path_str(scope.to_def_id()), field.ident);\n-        filter!(self.span_utils, field.ident.span);\n-        let field_def_id = field.def_id.to_def_id();\n-        let typ = self.tcx.type_of(field_def_id).to_string();\n-\n-        let id = id_from_def_id(field_def_id);\n-        let span = self.span_from_span(field.ident.span);\n-        let attrs = self.tcx.hir().attrs(field.hir_id);\n-\n-        Some(Def {\n-            kind: DefKind::Field,\n-            id,\n-            span,\n-            name,\n-            qualname,\n-            value: typ,\n-            parent: Some(id_from_def_id(scope.to_def_id())),\n-            children: vec![],\n-            decl_id: None,\n-            docs: self.docs_for_attrs(attrs),\n-            sig: sig::field_signature(field, self),\n-            attributes: lower_attributes(attrs.to_vec(), self),\n-        })\n-    }\n-\n-    // FIXME would be nice to take a MethodItem here, but the ast provides both\n-    // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self, owner_id: hir::OwnerId, ident: Ident, span: Span) -> Option<Def> {\n-        // The qualname for a method is the trait name or name of the struct in an impl in\n-        // which the method is declared in, followed by the method's name.\n-        let (qualname, parent_scope, decl_id, docs, attributes) =\n-            match self.tcx.impl_of_method(owner_id.to_def_id()) {\n-                Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n-                    Some(Node::Item(item)) => match item.kind {\n-                        hir::ItemKind::Impl(hir::Impl { ref self_ty, .. }) => {\n-                            let hir = self.tcx.hir();\n-\n-                            let mut qualname = String::from(\"<\");\n-                            qualname\n-                                .push_str(&rustc_hir_pretty::id_to_string(&hir, self_ty.hir_id));\n-\n-                            let trait_id = self.tcx.trait_id_of_impl(impl_id);\n-                            let mut docs = String::new();\n-                            let mut attrs = vec![];\n-                            if let Some(Node::ImplItem(_)) = hir.find(owner_id.into()) {\n-                                attrs = self.tcx.hir().attrs(owner_id.into()).to_vec();\n-                                docs = self.docs_for_attrs(&attrs);\n-                            }\n-\n-                            let mut decl_id = None;\n-                            if let Some(def_id) = trait_id {\n-                                // A method in a trait impl.\n-                                qualname.push_str(\" as \");\n-                                qualname.push_str(&self.tcx.def_path_str(def_id));\n-\n-                                decl_id = self\n-                                    .tcx\n-                                    .associated_items(def_id)\n-                                    .filter_by_name_unhygienic(ident.name)\n-                                    .next()\n-                                    .map(|item| item.def_id);\n-                            }\n-                            qualname.push('>');\n-\n-                            (qualname, trait_id, decl_id, docs, attrs)\n-                        }\n-                        _ => {\n-                            span_bug!(\n-                                span,\n-                                \"Container {:?} for method {:?} not an impl?\",\n-                                impl_id,\n-                                owner_id,\n-                            );\n-                        }\n-                    },\n-                    r => {\n-                        span_bug!(\n-                            span,\n-                            \"Container {:?} for method {:?} is not a node item {:?}\",\n-                            impl_id,\n-                            owner_id,\n-                            r\n-                        );\n-                    }\n-                },\n-                None => match self.tcx.trait_of_item(owner_id.to_def_id()) {\n-                    Some(def_id) => {\n-                        let mut docs = String::new();\n-                        let mut attrs = vec![];\n-\n-                        if let Some(Node::TraitItem(_)) = self.tcx.hir().find(owner_id.into()) {\n-                            attrs = self.tcx.hir().attrs(owner_id.into()).to_vec();\n-                            docs = self.docs_for_attrs(&attrs);\n-                        }\n-\n-                        (\n-                            format!(\"::{}\", self.tcx.def_path_str(def_id)),\n-                            Some(def_id),\n-                            None,\n-                            docs,\n-                            attrs,\n-                        )\n-                    }\n-                    None => {\n-                        debug!(\"could not find container for method {:?} at {:?}\", owner_id, span);\n-                        // This is not necessarily a bug, if there was a compilation error,\n-                        // the typeck results we need might not exist.\n-                        return None;\n-                    }\n-                },\n-            };\n-\n-        let qualname = format!(\"{}::{}\", qualname, ident.name);\n-\n-        filter!(self.span_utils, ident.span);\n-\n-        Some(Def {\n-            kind: DefKind::Method,\n-            id: id_from_def_id(owner_id.to_def_id()),\n-            span: self.span_from_span(ident.span),\n-            name: ident.name.to_string(),\n-            qualname,\n-            // FIXME you get better data here by using the visitor.\n-            value: String::new(),\n-            parent: parent_scope.map(id_from_def_id),\n-            children: vec![],\n-            decl_id: decl_id.map(id_from_def_id),\n-            docs,\n-            sig: None,\n-            attributes: lower_attributes(attributes, self),\n-        })\n-    }\n-\n-    pub fn get_expr_data(&self, expr: &hir::Expr<'_>) -> Option<Data> {\n-        let ty = self.typeck_results().expr_ty_adjusted_opt(expr)?;\n-        if matches!(ty.kind(), ty::Error(_)) {\n-            return None;\n-        }\n-        match expr.kind {\n-            hir::ExprKind::Field(ref sub_ex, ident) => {\n-                match self.typeck_results().expr_ty_adjusted(&sub_ex).kind() {\n-                    ty::Adt(def, _) if !def.is_enum() => {\n-                        let variant = &def.non_enum_variant();\n-                        filter!(self.span_utils, ident.span);\n-                        let span = self.span_from_span(ident.span);\n-                        Some(Data::RefData(Ref {\n-                            kind: RefKind::Variable,\n-                            span,\n-                            ref_id: self\n-                                .tcx\n-                                .find_field_index(ident, variant)\n-                                .map(|index| id_from_def_id(variant.fields[index].did))\n-                                .unwrap_or_else(null_id),\n-                        }))\n-                    }\n-                    ty::Tuple(..) => None,\n-                    _ => {\n-                        debug!(\"expected struct or union type, found {:?}\", ty);\n-                        None\n-                    }\n-                }\n-            }\n-            hir::ExprKind::Struct(qpath, ..) => match ty.kind() {\n-                ty::Adt(def, _) => {\n-                    let sub_span = qpath.last_segment_span();\n-                    filter!(self.span_utils, sub_span);\n-                    let span = self.span_from_span(sub_span);\n-                    Some(Data::RefData(Ref {\n-                        kind: RefKind::Type,\n-                        span,\n-                        ref_id: id_from_def_id(def.did()),\n-                    }))\n-                }\n-                _ => {\n-                    debug!(\"expected adt, found {:?}\", ty);\n-                    None\n-                }\n-            },\n-            hir::ExprKind::MethodCall(ref seg, ..) => {\n-                let Some(method_id) = self.typeck_results().type_dependent_def_id(expr.hir_id) else {\n-                    debug!(\"could not resolve method id for {:?}\", expr);\n-                    return None;\n-                };\n-                let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n-                    ty::ImplContainer => (Some(method_id), None),\n-                    ty::TraitContainer => (None, Some(method_id)),\n-                };\n-                let sub_span = seg.ident.span;\n-                filter!(self.span_utils, sub_span);\n-                let span = self.span_from_span(sub_span);\n-                Some(Data::RefData(Ref {\n-                    kind: RefKind::Function,\n-                    span,\n-                    ref_id: def_id.or(decl_id).map(id_from_def_id).unwrap_or_else(null_id),\n-                }))\n-            }\n-            hir::ExprKind::Path(ref path) => {\n-                self.get_path_data(expr.hir_id, path).map(Data::RefData)\n-            }\n-            _ => {\n-                // FIXME\n-                bug!(\"invalid expression: {:?}\", expr);\n-            }\n-        }\n-    }\n-\n-    pub fn get_path_res(&self, hir_id: hir::HirId) -> Res {\n-        match self.tcx.hir().get(hir_id) {\n-            Node::TraitRef(tr) => tr.path.res,\n-\n-            Node::Item(&hir::Item { kind: hir::ItemKind::Use(path, _), .. }) => {\n-                path.res.get(0).copied().unwrap_or(Res::Err)\n-            }\n-            Node::PathSegment(seg) => {\n-                if seg.res != Res::Err {\n-                    seg.res\n-                } else {\n-                    let parent_node = self.tcx.hir().parent_id(hir_id);\n-                    self.get_path_res(parent_node)\n-                }\n-            }\n-\n-            Node::Expr(&hir::Expr { kind: hir::ExprKind::Struct(ref qpath, ..), .. }) => {\n-                self.typeck_results().qpath_res(qpath, hir_id)\n-            }\n-\n-            Node::Expr(&hir::Expr { kind: hir::ExprKind::Path(ref qpath), .. })\n-            | Node::Pat(&hir::Pat {\n-                kind:\n-                    hir::PatKind::Path(ref qpath)\n-                    | hir::PatKind::Struct(ref qpath, ..)\n-                    | hir::PatKind::TupleStruct(ref qpath, ..),\n-                ..\n-            })\n-            | Node::Ty(&hir::Ty { kind: hir::TyKind::Path(ref qpath), .. }) => match qpath {\n-                hir::QPath::Resolved(_, path) => path.res,\n-                hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => {\n-                    // #75962: `self.typeck_results` may be different from the `hir_id`'s result.\n-                    if self.tcx.has_typeck_results(hir_id.owner.to_def_id()) {\n-                        self.tcx.typeck(hir_id.owner.def_id).qpath_res(qpath, hir_id)\n-                    } else {\n-                        Res::Err\n-                    }\n-                }\n-            },\n-\n-            Node::Pat(&hir::Pat { kind: hir::PatKind::Binding(_, canonical_id, ..), .. }) => {\n-                Res::Local(canonical_id)\n-            }\n-\n-            _ => Res::Err,\n-        }\n-    }\n-\n-    pub fn get_path_data(&self, id: hir::HirId, path: &hir::QPath<'_>) -> Option<Ref> {\n-        let segment = match path {\n-            hir::QPath::Resolved(_, path) => path.segments.last(),\n-            hir::QPath::TypeRelative(_, segment) => Some(*segment),\n-            hir::QPath::LangItem(..) => None,\n-        };\n-        segment.and_then(|seg| {\n-            self.get_path_segment_data(seg).or_else(|| self.get_path_segment_data_with_id(seg, id))\n-        })\n-    }\n-\n-    pub fn get_path_segment_data(&self, path_seg: &hir::PathSegment<'_>) -> Option<Ref> {\n-        self.get_path_segment_data_with_id(path_seg, path_seg.hir_id)\n-    }\n-\n-    pub fn get_path_segment_data_with_id(\n-        &self,\n-        path_seg: &hir::PathSegment<'_>,\n-        id: hir::HirId,\n-    ) -> Option<Ref> {\n-        // Returns true if the path is function type sugar, e.g., `Fn(A) -> B`.\n-        fn fn_type(seg: &hir::PathSegment<'_>) -> bool {\n-            seg.args.map_or(false, |args| args.parenthesized)\n-        }\n-\n-        let res = self.get_path_res(id);\n-        let span = path_seg.ident.span;\n-        filter!(self.span_utils, span);\n-        let span = self.span_from_span(span);\n-\n-        match res {\n-            Res::Local(id) => {\n-                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_hir_id(id) })\n-            }\n-            Res::Def(HirDefKind::Trait, def_id) if fn_type(path_seg) => {\n-                Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(def_id) })\n-            }\n-            Res::Def(\n-                HirDefKind::Struct\n-                | HirDefKind::Variant\n-                | HirDefKind::Union\n-                | HirDefKind::Enum\n-                | HirDefKind::TyAlias\n-                | HirDefKind::ForeignTy\n-                | HirDefKind::TraitAlias\n-                | HirDefKind::AssocTy\n-                | HirDefKind::Trait\n-                | HirDefKind::OpaqueTy\n-                | HirDefKind::ImplTraitPlaceholder\n-                | HirDefKind::TyParam,\n-                def_id,\n-            ) => Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(def_id) }),\n-            Res::Def(HirDefKind::ConstParam, def_id) => {\n-                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(def_id) })\n-            }\n-            Res::Def(HirDefKind::Ctor(..), def_id) => {\n-                // This is a reference to a tuple struct or an enum variant where the def_id points\n-                // to an invisible constructor function. That is not a very useful\n-                // def, so adjust to point to the tuple struct or enum variant itself.\n-                let parent_def_id = self.tcx.parent(def_id);\n-                Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(parent_def_id) })\n-            }\n-            Res::Def(HirDefKind::Static(_) | HirDefKind::Const | HirDefKind::AssocConst, _) => {\n-                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(res.def_id()) })\n-            }\n-            Res::Def(HirDefKind::AssocFn, decl_id) => {\n-                let def_id = if decl_id.is_local() {\n-                    if self.tcx.impl_defaultness(decl_id).has_value() {\n-                        Some(decl_id)\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                };\n-                Some(Ref {\n-                    kind: RefKind::Function,\n-                    span,\n-                    ref_id: id_from_def_id(def_id.unwrap_or(decl_id)),\n-                })\n-            }\n-            Res::Def(HirDefKind::Fn, def_id) => {\n-                Some(Ref { kind: RefKind::Function, span, ref_id: id_from_def_id(def_id) })\n-            }\n-            Res::Def(HirDefKind::Mod, def_id) => {\n-                Some(Ref { kind: RefKind::Mod, span, ref_id: id_from_def_id(def_id) })\n-            }\n-\n-            Res::Def(\n-                HirDefKind::Macro(..)\n-                | HirDefKind::ExternCrate\n-                | HirDefKind::ForeignMod\n-                | HirDefKind::LifetimeParam\n-                | HirDefKind::AnonConst\n-                | HirDefKind::InlineConst\n-                | HirDefKind::Use\n-                | HirDefKind::Field\n-                | HirDefKind::GlobalAsm\n-                | HirDefKind::Impl\n-                | HirDefKind::Closure\n-                | HirDefKind::Generator,\n-                _,\n-            )\n-            | Res::PrimTy(..)\n-            | Res::SelfTyParam { .. }\n-            | Res::SelfTyAlias { .. }\n-            | Res::ToolMod\n-            | Res::NonMacroAttr(..)\n-            | Res::SelfCtor(..)\n-            | Res::Err => None,\n-        }\n-    }\n-\n-    pub fn get_field_ref_data(\n-        &self,\n-        field_ref: &hir::ExprField<'_>,\n-        variant: &ty::VariantDef,\n-    ) -> Option<Ref> {\n-        filter!(self.span_utils, field_ref.ident.span);\n-        self.tcx.find_field_index(field_ref.ident, variant).map(|index| {\n-            let span = self.span_from_span(field_ref.ident.span);\n-            Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(variant.fields[index].did) }\n-        })\n-    }\n-\n-    /// Attempt to return MacroRef for any AST node.\n-    ///\n-    /// For a given piece of AST defined by the supplied Span and NodeId,\n-    /// returns `None` if the node is not macro-generated or the span is malformed,\n-    /// else uses the expansion callsite and callee to return some MacroRef.\n-    ///\n-    /// FIXME: [`DumpVisitor::process_macro_use`] should actually dump this data\n-    #[allow(dead_code)]\n-    fn get_macro_use_data(&self, span: Span) -> Option<MacroRef> {\n-        if !generated_code(span) {\n-            return None;\n-        }\n-        // Note we take care to use the source callsite/callee, to handle\n-        // nested expansions and ensure we only generate data for source-visible\n-        // macro uses.\n-        let callsite = span.source_callsite();\n-        let callsite_span = self.span_from_span(callsite);\n-        let callee = span.source_callee()?;\n-\n-        let mac_name = match callee.kind {\n-            ExpnKind::Macro(kind, name) => match kind {\n-                MacroKind::Bang => name,\n-\n-                // Ignore attribute macros, their spans are usually mangled\n-                // FIXME(eddyb) is this really the case anymore?\n-                MacroKind::Attr | MacroKind::Derive => return None,\n-            },\n-\n-            // These are not macros.\n-            // FIXME(eddyb) maybe there is a way to handle them usefully?\n-            ExpnKind::Inlined | ExpnKind::Root | ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => {\n-                return None;\n-            }\n-        };\n-\n-        let callee_span = self.span_from_span(callee.def_site);\n-        Some(MacroRef {\n-            span: callsite_span,\n-            qualname: mac_name.to_string(), // FIXME: generate the real qualname\n-            callee_span,\n-        })\n-    }\n-\n-    fn lookup_def_id(&self, ref_id: hir::HirId) -> Option<DefId> {\n-        match self.get_path_res(ref_id) {\n-            Res::PrimTy(_) | Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } | Res::Err => None,\n-            def => def.opt_def_id(),\n-        }\n-    }\n-\n-    fn docs_for_attrs(&self, attrs: &[ast::Attribute]) -> String {\n-        let mut result = String::new();\n-\n-        for attr in attrs {\n-            if let Some((val, kind)) = attr.doc_str_and_comment_kind() {\n-                // FIXME: Should save-analysis beautify doc strings itself or leave it to users?\n-                result.push_str(beautify_doc_string(val, kind).as_str());\n-                result.push('\\n');\n-            }\n-        }\n-\n-        if !self.config.full_docs {\n-            if let Some(index) = result.find(\"\\n\\n\") {\n-                result.truncate(index);\n-            }\n-        }\n-\n-        result\n-    }\n-\n-    fn next_impl_id(&self) -> u32 {\n-        let next = self.impl_counter.get();\n-        self.impl_counter.set(next + 1);\n-        next\n-    }\n-}\n-\n-// An AST visitor for collecting paths (e.g., the names of structs) and formal\n-// variables (idents) from patterns.\n-struct PathCollector<'l> {\n-    tcx: TyCtxt<'l>,\n-    collected_paths: Vec<(hir::HirId, &'l hir::QPath<'l>)>,\n-    collected_idents: Vec<(hir::HirId, Ident, hir::Mutability)>,\n-}\n-\n-impl<'l> PathCollector<'l> {\n-    fn new(tcx: TyCtxt<'l>) -> PathCollector<'l> {\n-        PathCollector { tcx, collected_paths: vec![], collected_idents: vec![] }\n-    }\n-}\n-\n-impl<'l> Visitor<'l> for PathCollector<'l> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.tcx.hir()\n-    }\n-\n-    fn visit_pat(&mut self, p: &'l hir::Pat<'l>) {\n-        match p.kind {\n-            hir::PatKind::Struct(ref path, ..) => {\n-                self.collected_paths.push((p.hir_id, path));\n-            }\n-            hir::PatKind::TupleStruct(ref path, ..) | hir::PatKind::Path(ref path) => {\n-                self.collected_paths.push((p.hir_id, path));\n-            }\n-            hir::PatKind::Binding(hir::BindingAnnotation(_, mutbl), _, ident, _) => {\n-                debug!(\n-                    \"PathCollector, visit ident in pat {}: {:?} {:?}\",\n-                    ident, p.span, ident.span\n-                );\n-                self.collected_idents.push((p.hir_id, ident, mutbl));\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_pat(self, p);\n-    }\n-}\n-\n-/// Defines what to do with the results of saving the analysis.\n-pub trait SaveHandler {\n-    fn save(&mut self, save_ctxt: &SaveContext<'_>, analysis: &Analysis);\n-}\n-\n-/// Dump the save-analysis results to a file.\n-pub struct DumpHandler<'a> {\n-    odir: Option<&'a Path>,\n-    cratename: String,\n-}\n-\n-impl<'a> DumpHandler<'a> {\n-    pub fn new(odir: Option<&'a Path>, cratename: Symbol) -> DumpHandler<'a> {\n-        DumpHandler { odir, cratename: cratename.to_string() }\n-    }\n-\n-    fn output_file(&self, ctx: &SaveContext<'_>) -> (BufWriter<File>, PathBuf) {\n-        let sess = &ctx.tcx.sess;\n-        let file_name = match ctx.config.output_file {\n-            Some(ref s) => PathBuf::from(s),\n-            None => {\n-                let mut root_path = match self.odir {\n-                    Some(val) => val.join(\"save-analysis\"),\n-                    None => PathBuf::from(\"save-analysis-temp\"),\n-                };\n-\n-                if let Err(e) = std::fs::create_dir_all(&root_path) {\n-                    error!(\"Could not create directory {}: {}\", root_path.display(), e);\n-                }\n-\n-                let executable = sess.crate_types().iter().any(|ct| *ct == CrateType::Executable);\n-                let mut out_name = if executable { String::new() } else { \"lib\".to_owned() };\n-                out_name.push_str(&self.cratename);\n-                out_name.push_str(&sess.opts.cg.extra_filename);\n-                out_name.push_str(\".json\");\n-                root_path.push(&out_name);\n-\n-                root_path\n-            }\n-        };\n-\n-        info!(\"Writing output to {}\", file_name.display());\n-\n-        let output_file = BufWriter::new(File::create(&file_name).unwrap_or_else(|e| {\n-            sess.emit_fatal(errors::CouldNotOpen { file_name: file_name.as_path(), err: e })\n-        }));\n-\n-        (output_file, file_name)\n-    }\n-}\n-\n-impl SaveHandler for DumpHandler<'_> {\n-    fn save(&mut self, save_ctxt: &SaveContext<'_>, analysis: &Analysis) {\n-        let sess = &save_ctxt.tcx.sess;\n-        let (output, file_name) = self.output_file(&save_ctxt);\n-        if let Err(e) = serde_json::to_writer(output, &analysis) {\n-            error!(\"Can't serialize save-analysis: {:?}\", e);\n-        }\n-\n-        if sess.opts.json_artifact_notifications {\n-            sess.parse_sess.span_diagnostic.emit_artifact_notification(&file_name, \"save-analysis\");\n-        }\n-    }\n-}\n-\n-/// Call a callback with the results of save-analysis.\n-pub struct CallbackHandler<'b> {\n-    pub callback: &'b mut dyn FnMut(&rls_data::Analysis),\n-}\n-\n-impl SaveHandler for CallbackHandler<'_> {\n-    fn save(&mut self, _: &SaveContext<'_>, analysis: &Analysis) {\n-        (self.callback)(analysis)\n-    }\n-}\n-\n-pub fn process_crate<H: SaveHandler>(\n-    tcx: TyCtxt<'_>,\n-    cratename: Symbol,\n-    input: &Input,\n-    config: Option<Config>,\n-    mut handler: H,\n-) {\n-    with_no_trimmed_paths!({\n-        tcx.dep_graph.with_ignore(|| {\n-            info!(\"Dumping crate {}\", cratename);\n-\n-            // Privacy checking must be done outside of type inference; use a\n-            // fallback in case effective visibilities couldn't have been correctly computed.\n-            let effective_visibilities = match tcx.sess.compile_status() {\n-                Ok(..) => tcx.effective_visibilities(()),\n-                Err(..) => tcx.arena.alloc(EffectiveVisibilities::default()),\n-            };\n-\n-            let save_ctxt = SaveContext {\n-                tcx,\n-                maybe_typeck_results: None,\n-                effective_visibilities: &effective_visibilities,\n-                span_utils: SpanUtils::new(&tcx.sess),\n-                config: find_config(config),\n-                impl_counter: Cell::new(0),\n-            };\n-\n-            let mut visitor = DumpVisitor::new(save_ctxt);\n-\n-            visitor.dump_crate_info(cratename);\n-            visitor.dump_compilation_options(input, cratename);\n-            visitor.process_crate();\n-\n-            handler.save(&visitor.save_ctxt, &visitor.analysis())\n-        })\n-    })\n-}\n-\n-fn find_config(supplied: Option<Config>) -> Config {\n-    if let Some(config) = supplied {\n-        return config;\n-    }\n-\n-    match env::var_os(\"RUST_SAVE_ANALYSIS_CONFIG\") {\n-        None => Config::default(),\n-        Some(config) => config\n-            .to_str()\n-            .ok_or(())\n-            .map_err(|_| error!(\"`RUST_SAVE_ANALYSIS_CONFIG` isn't UTF-8\"))\n-            .and_then(|cfg| {\n-                serde_json::from_str(cfg)\n-                    .map_err(|_| error!(\"Could not deserialize save-analysis config\"))\n-            })\n-            .unwrap_or_default(),\n-    }\n-}\n-\n-// Utility functions for the module.\n-\n-// Helper function to escape quotes in a string\n-fn escape(s: String) -> String {\n-    s.replace('\\\"', \"\\\"\\\"\")\n-}\n-\n-// Helper function to determine if a span came from a\n-// macro expansion or syntax extension.\n-fn generated_code(span: Span) -> bool {\n-    span.from_expansion() || span.is_dummy()\n-}\n-\n-// DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n-// we use our own Id which is the same, but without the newtype.\n-fn id_from_def_id(id: DefId) -> rls_data::Id {\n-    rls_data::Id { krate: id.krate.as_u32(), index: id.index.as_u32() }\n-}\n-\n-fn id_from_hir_id(id: hir::HirId) -> rls_data::Id {\n-    // Create a *fake* `DefId` out of a `HirId` by combining the owner\n-    // `local_def_index` and the `local_id`.\n-    // This will work unless you have *billions* of definitions in a single\n-    // crate (very unlikely to actually happen).\n-    rls_data::Id {\n-        krate: LOCAL_CRATE.as_u32(),\n-        index: id.owner.def_id.local_def_index.as_u32() | id.local_id.as_u32().reverse_bits(),\n-    }\n-}\n-\n-fn null_id() -> rls_data::Id {\n-    rls_data::Id { krate: u32::MAX, index: u32::MAX }\n-}\n-\n-fn lower_attributes(attrs: Vec<ast::Attribute>, scx: &SaveContext<'_>) -> Vec<rls_data::Attribute> {\n-    attrs\n-        .into_iter()\n-        // Only retain real attributes. Doc comments are lowered separately.\n-        .filter(|attr| !attr.has_name(sym::doc))\n-        .map(|mut attr| {\n-            // Remove the surrounding '#[..]' or '#![..]' of the pretty printed\n-            // attribute. First normalize all inner attribute (#![..]) to outer\n-            // ones (#[..]), then remove the two leading and the one trailing character.\n-            attr.style = ast::AttrStyle::Outer;\n-            let value = attribute_to_string(&attr);\n-            // This str slicing works correctly, because the leading and trailing characters\n-            // are in the ASCII range and thus exactly one byte each.\n-            let value = value[2..value.len() - 1].to_string();\n-\n-            rls_data::Attribute { value, span: scx.span_from_span(attr.span) }\n-        })\n-        .collect()\n-}"}, {"sha": "a50a8178de38bb3af51f44380575ee81c39b3887", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "removed", "additions": 0, "deletions": 931, "changes": 931, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,931 +0,0 @@\n-// A signature is a string representation of an item's type signature, excluding\n-// any body. It also includes ids for any defs or refs in the signature. For\n-// example:\n-//\n-// ```\n-// fn foo(x: String) {\n-//     println!(\"{}\", x);\n-// }\n-// ```\n-// The signature string is something like \"fn foo(x: String) {}\" and the signature\n-// will have defs for `foo` and `x` and a ref for `String`.\n-//\n-// All signature text should parse in the correct context (i.e., in a module or\n-// impl, etc.). Clients may want to trim trailing `{}` or `;`. The text of a\n-// signature is not guaranteed to be stable (it may improve or change as the\n-// syntax changes, or whitespace or punctuation may change). It is also likely\n-// not to be pretty - no attempt is made to prettify the text. It is recommended\n-// that clients run the text through Rustfmt.\n-//\n-// This module generates Signatures for items by walking the AST and looking up\n-// references.\n-//\n-// Signatures do not include visibility info. I'm not sure if this is a feature\n-// or an omission (FIXME).\n-//\n-// FIXME where clauses need implementing, defs/refs in generics are mostly missing.\n-\n-use crate::{id_from_def_id, SaveContext};\n-\n-use rls_data::{SigElement, Signature};\n-\n-use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir_pretty::id_to_string;\n-use rustc_hir_pretty::{bounds_to_string, path_segment_to_string, path_to_string, ty_to_string};\n-use rustc_span::def_id::LocalDefId;\n-use rustc_span::symbol::{Ident, Symbol};\n-\n-pub fn item_signature(item: &hir::Item<'_>, scx: &SaveContext<'_>) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    item.make(0, None, scx).ok()\n-}\n-\n-pub fn foreign_item_signature(\n-    item: &hir::ForeignItem<'_>,\n-    scx: &SaveContext<'_>,\n-) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    item.make(0, None, scx).ok()\n-}\n-\n-/// Signature for a struct or tuple field declaration.\n-/// Does not include a trailing comma.\n-pub fn field_signature(field: &hir::FieldDef<'_>, scx: &SaveContext<'_>) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    field.make(0, None, scx).ok()\n-}\n-\n-/// Does not include a trailing comma.\n-pub fn variant_signature(variant: &hir::Variant<'_>, scx: &SaveContext<'_>) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    variant.make(0, None, scx).ok()\n-}\n-\n-pub fn method_signature(\n-    id: hir::OwnerId,\n-    ident: Ident,\n-    generics: &hir::Generics<'_>,\n-    m: &hir::FnSig<'_>,\n-    scx: &SaveContext<'_>,\n-) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    make_method_signature(id, ident, generics, m, scx).ok()\n-}\n-\n-pub fn assoc_const_signature(\n-    id: hir::OwnerId,\n-    ident: Symbol,\n-    ty: &hir::Ty<'_>,\n-    default: Option<&hir::Expr<'_>>,\n-    scx: &SaveContext<'_>,\n-) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    make_assoc_const_signature(id, ident, ty, default, scx).ok()\n-}\n-\n-pub fn assoc_type_signature(\n-    id: hir::OwnerId,\n-    ident: Ident,\n-    bounds: Option<hir::GenericBounds<'_>>,\n-    default: Option<&hir::Ty<'_>>,\n-    scx: &SaveContext<'_>,\n-) -> Option<Signature> {\n-    if !scx.config.signatures {\n-        return None;\n-    }\n-    make_assoc_type_signature(id, ident, bounds, default, scx).ok()\n-}\n-\n-type Result = std::result::Result<Signature, &'static str>;\n-\n-trait Sig {\n-    type Parent;\n-    fn make(&self, offset: usize, id: Option<Self::Parent>, scx: &SaveContext<'_>) -> Result;\n-}\n-\n-fn extend_sig(\n-    mut sig: Signature,\n-    text: String,\n-    defs: Vec<SigElement>,\n-    refs: Vec<SigElement>,\n-) -> Signature {\n-    sig.text = text;\n-    sig.defs.extend(defs.into_iter());\n-    sig.refs.extend(refs.into_iter());\n-    sig\n-}\n-\n-fn replace_text(mut sig: Signature, text: String) -> Signature {\n-    sig.text = text;\n-    sig\n-}\n-\n-fn merge_sigs(text: String, sigs: Vec<Signature>) -> Signature {\n-    let mut result = Signature { text, defs: vec![], refs: vec![] };\n-\n-    let (defs, refs): (Vec<_>, Vec<_>) = sigs.into_iter().map(|s| (s.defs, s.refs)).unzip();\n-\n-    result.defs.extend(defs.into_iter().flat_map(|ds| ds.into_iter()));\n-    result.refs.extend(refs.into_iter().flat_map(|rs| rs.into_iter()));\n-\n-    result\n-}\n-\n-fn text_sig(text: String) -> Signature {\n-    Signature { text, defs: vec![], refs: vec![] }\n-}\n-\n-impl<'hir> Sig for hir::Ty<'hir> {\n-    type Parent = hir::HirId;\n-    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n-        let id = Some(self.hir_id);\n-        match self.kind {\n-            hir::TyKind::Slice(ref ty) => {\n-                let nested = ty.make(offset + 1, id, scx)?;\n-                let text = format!(\"[{}]\", nested.text);\n-                Ok(replace_text(nested, text))\n-            }\n-            hir::TyKind::Ptr(ref mt) => {\n-                let prefix = match mt.mutbl {\n-                    hir::Mutability::Mut => \"*mut \",\n-                    hir::Mutability::Not => \"*const \",\n-                };\n-                let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n-                let text = format!(\"{}{}\", prefix, nested.text);\n-                Ok(replace_text(nested, text))\n-            }\n-            hir::TyKind::Ref(ref lifetime, ref mt) => {\n-                let mut prefix = \"&\".to_owned();\n-                prefix.push_str(&lifetime.ident.to_string());\n-                prefix.push(' ');\n-                if mt.mutbl.is_mut() {\n-                    prefix.push_str(\"mut \");\n-                };\n-\n-                let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n-                let text = format!(\"{}{}\", prefix, nested.text);\n-                Ok(replace_text(nested, text))\n-            }\n-            hir::TyKind::Never => Ok(text_sig(\"!\".to_owned())),\n-            hir::TyKind::Tup(ts) => {\n-                let mut text = \"(\".to_owned();\n-                let mut defs = vec![];\n-                let mut refs = vec![];\n-                for t in ts {\n-                    let nested = t.make(offset + text.len(), id, scx)?;\n-                    text.push_str(&nested.text);\n-                    text.push(',');\n-                    defs.extend(nested.defs.into_iter());\n-                    refs.extend(nested.refs.into_iter());\n-                }\n-                text.push(')');\n-                Ok(Signature { text, defs, refs })\n-            }\n-            hir::TyKind::BareFn(ref f) => {\n-                let mut text = String::new();\n-                if !f.generic_params.is_empty() {\n-                    // FIXME defs, bounds on lifetimes\n-                    text.push_str(\"for<\");\n-                    text.push_str(\n-                        &f.generic_params\n-                            .iter()\n-                            .filter_map(|param| match param.kind {\n-                                hir::GenericParamKind::Lifetime { .. } => {\n-                                    Some(param.name.ident().to_string())\n-                                }\n-                                _ => None,\n-                            })\n-                            .collect::<Vec<_>>()\n-                            .join(\", \"),\n-                    );\n-                    text.push('>');\n-                }\n-\n-                if let hir::Unsafety::Unsafe = f.unsafety {\n-                    text.push_str(\"unsafe \");\n-                }\n-                text.push_str(\"fn(\");\n-\n-                let mut defs = vec![];\n-                let mut refs = vec![];\n-                for i in f.decl.inputs {\n-                    let nested = i.make(offset + text.len(), Some(i.hir_id), scx)?;\n-                    text.push_str(&nested.text);\n-                    text.push(',');\n-                    defs.extend(nested.defs.into_iter());\n-                    refs.extend(nested.refs.into_iter());\n-                }\n-                text.push(')');\n-                if let hir::FnRetTy::Return(ref t) = f.decl.output {\n-                    text.push_str(\" -> \");\n-                    let nested = t.make(offset + text.len(), None, scx)?;\n-                    text.push_str(&nested.text);\n-                    text.push(',');\n-                    defs.extend(nested.defs.into_iter());\n-                    refs.extend(nested.refs.into_iter());\n-                }\n-\n-                Ok(Signature { text, defs, refs })\n-            }\n-            hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.make(offset, id, scx),\n-            hir::TyKind::Path(hir::QPath::Resolved(Some(ref qself), ref path)) => {\n-                let nested_ty = qself.make(offset + 1, id, scx)?;\n-                let prefix = format!(\n-                    \"<{} as {}>::\",\n-                    nested_ty.text,\n-                    path_segment_to_string(&path.segments[0])\n-                );\n-\n-                let name = path_segment_to_string(path.segments.last().ok_or(\"Bad path\")?);\n-                let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n-                let id = id_from_def_id(res.def_id());\n-                if path.segments.len() == 2 {\n-                    let start = offset + prefix.len();\n-                    let end = start + name.len();\n-\n-                    Ok(Signature {\n-                        text: prefix + &name,\n-                        defs: vec![],\n-                        refs: vec![SigElement { id, start, end }],\n-                    })\n-                } else {\n-                    let start = offset + prefix.len() + 5;\n-                    let end = start + name.len();\n-                    // FIXME should put the proper path in there, not ellipsis.\n-                    Ok(Signature {\n-                        text: prefix + \"...::\" + &name,\n-                        defs: vec![],\n-                        refs: vec![SigElement { id, start, end }],\n-                    })\n-                }\n-            }\n-            hir::TyKind::Path(hir::QPath::TypeRelative(ty, segment)) => {\n-                let nested_ty = ty.make(offset + 1, id, scx)?;\n-                let prefix = format!(\"<{}>::\", nested_ty.text);\n-\n-                let name = path_segment_to_string(segment);\n-                let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n-                let id = id_from_def_id(res.def_id());\n-\n-                let start = offset + prefix.len();\n-                let end = start + name.len();\n-                Ok(Signature {\n-                    text: prefix + &name,\n-                    defs: vec![],\n-                    refs: vec![SigElement { id, start, end }],\n-                })\n-            }\n-            hir::TyKind::Path(hir::QPath::LangItem(lang_item, _, _)) => {\n-                Ok(text_sig(format!(\"#[lang = \\\"{}\\\"]\", lang_item.name())))\n-            }\n-            hir::TyKind::TraitObject(bounds, ..) => {\n-                // FIXME recurse into bounds\n-                let bounds: Vec<hir::GenericBound<'_>> = bounds\n-                    .iter()\n-                    .map(|hir::PolyTraitRef { bound_generic_params, trait_ref, span }| {\n-                        hir::GenericBound::Trait(\n-                            hir::PolyTraitRef {\n-                                bound_generic_params,\n-                                trait_ref: hir::TraitRef {\n-                                    path: trait_ref.path,\n-                                    hir_ref_id: trait_ref.hir_ref_id,\n-                                },\n-                                span: *span,\n-                            },\n-                            hir::TraitBoundModifier::None,\n-                        )\n-                    })\n-                    .collect();\n-                let nested = bounds_to_string(&bounds);\n-                Ok(text_sig(nested))\n-            }\n-            hir::TyKind::Array(ref ty, ref length) => {\n-                let nested_ty = ty.make(offset + 1, id, scx)?;\n-                let expr = id_to_string(&scx.tcx.hir(), length.hir_id()).replace('\\n', \" \");\n-                let text = format!(\"[{}; {}]\", nested_ty.text, expr);\n-                Ok(replace_text(nested_ty, text))\n-            }\n-            hir::TyKind::OpaqueDef(item_id, _, _) => {\n-                let item = scx.tcx.hir().item(item_id);\n-                item.make(offset, Some(item_id.hir_id()), scx)\n-            }\n-            hir::TyKind::Typeof(_) | hir::TyKind::Infer | hir::TyKind::Err => Err(\"Ty\"),\n-        }\n-    }\n-}\n-\n-impl<'hir> Sig for hir::Item<'hir> {\n-    type Parent = hir::HirId;\n-    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n-        let id = Some(self.hir_id());\n-\n-        match self.kind {\n-            hir::ItemKind::Static(ref ty, m, ref body) => {\n-                let mut text = \"static \".to_owned();\n-                if m.is_mut() {\n-                    text.push_str(\"mut \");\n-                }\n-                let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_def_id(self.owner_id.to_def_id()),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n-                text.push_str(&name);\n-                text.push_str(\": \");\n-\n-                let ty = ty.make(offset + text.len(), id, scx)?;\n-                text.push_str(&ty.text);\n-\n-                text.push_str(\" = \");\n-                let expr = id_to_string(&scx.tcx.hir(), body.hir_id).replace('\\n', \" \");\n-                text.push_str(&expr);\n-\n-                text.push(';');\n-\n-                Ok(extend_sig(ty, text, defs, vec![]))\n-            }\n-            hir::ItemKind::Const(ref ty, ref body) => {\n-                let mut text = \"const \".to_owned();\n-                let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_def_id(self.owner_id.to_def_id()),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n-                text.push_str(&name);\n-                text.push_str(\": \");\n-\n-                let ty = ty.make(offset + text.len(), id, scx)?;\n-                text.push_str(&ty.text);\n-\n-                text.push_str(\" = \");\n-                let expr = id_to_string(&scx.tcx.hir(), body.hir_id).replace('\\n', \" \");\n-                text.push_str(&expr);\n-\n-                text.push(';');\n-\n-                Ok(extend_sig(ty, text, defs, vec![]))\n-            }\n-            hir::ItemKind::Fn(hir::FnSig { ref decl, header, span: _ }, ref generics, _) => {\n-                let mut text = String::new();\n-                if let hir::Constness::Const = header.constness {\n-                    text.push_str(\"const \");\n-                }\n-                if hir::IsAsync::Async == header.asyncness {\n-                    text.push_str(\"async \");\n-                }\n-                if let hir::Unsafety::Unsafe = header.unsafety {\n-                    text.push_str(\"unsafe \");\n-                }\n-                text.push_str(\"fn \");\n-\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-\n-                sig.text.push('(');\n-                for i in decl.inputs {\n-                    // FIXME should descend into patterns to add defs.\n-                    sig.text.push_str(\": \");\n-                    let nested = i.make(offset + sig.text.len(), Some(i.hir_id), scx)?;\n-                    sig.text.push_str(&nested.text);\n-                    sig.text.push(',');\n-                    sig.defs.extend(nested.defs.into_iter());\n-                    sig.refs.extend(nested.refs.into_iter());\n-                }\n-                sig.text.push(')');\n-\n-                if let hir::FnRetTy::Return(ref t) = decl.output {\n-                    sig.text.push_str(\" -> \");\n-                    let nested = t.make(offset + sig.text.len(), None, scx)?;\n-                    sig.text.push_str(&nested.text);\n-                    sig.defs.extend(nested.defs.into_iter());\n-                    sig.refs.extend(nested.refs.into_iter());\n-                }\n-                sig.text.push_str(\" {}\");\n-\n-                Ok(sig)\n-            }\n-            hir::ItemKind::Macro(..) => {\n-                let mut text = \"macro\".to_owned();\n-                let name = self.ident.to_string();\n-                text.push_str(&name);\n-                text.push_str(&\"! {}\");\n-\n-                Ok(text_sig(text))\n-            }\n-            hir::ItemKind::Mod(ref _mod) => {\n-                let mut text = \"mod \".to_owned();\n-                let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_def_id(self.owner_id.to_def_id()),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n-                text.push_str(&name);\n-                // Could be either `mod foo;` or `mod foo { ... }`, but we'll just pick one.\n-                text.push(';');\n-\n-                Ok(Signature { text, defs, refs: vec![] })\n-            }\n-            hir::ItemKind::TyAlias(ref ty, ref generics) => {\n-                let text = \"type \".to_owned();\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-\n-                sig.text.push_str(\" = \");\n-                let ty = ty.make(offset + sig.text.len(), id, scx)?;\n-                sig.text.push_str(&ty.text);\n-                sig.text.push(';');\n-\n-                Ok(merge_sigs(sig.text.clone(), vec![sig, ty]))\n-            }\n-            hir::ItemKind::Enum(_, ref generics) => {\n-                let text = \"enum \".to_owned();\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-                sig.text.push_str(\" {}\");\n-                Ok(sig)\n-            }\n-            hir::ItemKind::Struct(_, ref generics) => {\n-                let text = \"struct \".to_owned();\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-                sig.text.push_str(\" {}\");\n-                Ok(sig)\n-            }\n-            hir::ItemKind::Union(_, ref generics) => {\n-                let text = \"union \".to_owned();\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-                sig.text.push_str(\" {}\");\n-                Ok(sig)\n-            }\n-            hir::ItemKind::Trait(is_auto, unsafety, ref generics, bounds, _) => {\n-                let mut text = String::new();\n-\n-                if is_auto == hir::IsAuto::Yes {\n-                    text.push_str(\"auto \");\n-                }\n-\n-                if let hir::Unsafety::Unsafe = unsafety {\n-                    text.push_str(\"unsafe \");\n-                }\n-                text.push_str(\"trait \");\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-\n-                if !bounds.is_empty() {\n-                    sig.text.push_str(\": \");\n-                    sig.text.push_str(&bounds_to_string(bounds));\n-                }\n-                // FIXME where clause\n-                sig.text.push_str(\" {}\");\n-\n-                Ok(sig)\n-            }\n-            hir::ItemKind::TraitAlias(ref generics, bounds) => {\n-                let mut text = String::new();\n-                text.push_str(\"trait \");\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-\n-                if !bounds.is_empty() {\n-                    sig.text.push_str(\" = \");\n-                    sig.text.push_str(&bounds_to_string(bounds));\n-                }\n-                // FIXME where clause\n-                sig.text.push(';');\n-\n-                Ok(sig)\n-            }\n-            hir::ItemKind::Impl(hir::Impl {\n-                unsafety,\n-                polarity,\n-                defaultness,\n-                defaultness_span: _,\n-                constness,\n-                ref generics,\n-                ref of_trait,\n-                ref self_ty,\n-                items: _,\n-            }) => {\n-                let mut text = String::new();\n-                if let hir::Defaultness::Default { .. } = defaultness {\n-                    text.push_str(\"default \");\n-                }\n-                if let hir::Unsafety::Unsafe = unsafety {\n-                    text.push_str(\"unsafe \");\n-                }\n-                text.push_str(\"impl\");\n-                if let hir::Constness::Const = constness {\n-                    text.push_str(\" const\");\n-                }\n-\n-                let generics_sig =\n-                    generics.make(offset + text.len(), Some(self.owner_id.def_id), scx)?;\n-                text.push_str(&generics_sig.text);\n-\n-                text.push(' ');\n-\n-                let trait_sig = if let Some(ref t) = *of_trait {\n-                    if let hir::ImplPolarity::Negative(_) = polarity {\n-                        text.push('!');\n-                    }\n-                    let trait_sig = t.path.make(offset + text.len(), id, scx)?;\n-                    text.push_str(&trait_sig.text);\n-                    text.push_str(\" for \");\n-                    trait_sig\n-                } else {\n-                    text_sig(String::new())\n-                };\n-\n-                let ty_sig = self_ty.make(offset + text.len(), id, scx)?;\n-                text.push_str(&ty_sig.text);\n-\n-                text.push_str(\" {}\");\n-\n-                Ok(merge_sigs(text, vec![generics_sig, trait_sig, ty_sig]))\n-\n-                // FIXME where clause\n-            }\n-            hir::ItemKind::ForeignMod { .. } => Err(\"extern mod\"),\n-            hir::ItemKind::GlobalAsm(_) => Err(\"global asm\"),\n-            hir::ItemKind::ExternCrate(_) => Err(\"extern crate\"),\n-            hir::ItemKind::OpaqueTy(ref opaque) => {\n-                if opaque.in_trait {\n-                    Err(\"opaque type in trait\")\n-                } else {\n-                    Err(\"opaque type\")\n-                }\n-            }\n-            // FIXME should implement this (e.g., pub use).\n-            hir::ItemKind::Use(..) => Err(\"import\"),\n-        }\n-    }\n-}\n-\n-impl<'hir> Sig for hir::Path<'hir> {\n-    type Parent = hir::HirId;\n-    fn make(&self, offset: usize, id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n-        let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n-\n-        let (name, start, end) = match res {\n-            Res::PrimTy(..) | Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } | Res::Err => {\n-                return Ok(Signature { text: path_to_string(self), defs: vec![], refs: vec![] });\n-            }\n-            Res::Def(DefKind::AssocConst | DefKind::Variant | DefKind::Ctor(..), _) => {\n-                let len = self.segments.len();\n-                if len < 2 {\n-                    return Err(\"Bad path\");\n-                }\n-                // FIXME: really we should descend into the generics here and add SigElements for\n-                // them.\n-                // FIXME: would be nice to have a def for the first path segment.\n-                let seg1 = path_segment_to_string(&self.segments[len - 2]);\n-                let seg2 = path_segment_to_string(&self.segments[len - 1]);\n-                let start = offset + seg1.len() + 2;\n-                (format!(\"{}::{}\", seg1, seg2), start, start + seg2.len())\n-            }\n-            _ => {\n-                let name = path_segment_to_string(self.segments.last().ok_or(\"Bad path\")?);\n-                let end = offset + name.len();\n-                (name, offset, end)\n-            }\n-        };\n-\n-        let id = id_from_def_id(res.def_id());\n-        Ok(Signature { text: name, defs: vec![], refs: vec![SigElement { id, start, end }] })\n-    }\n-}\n-\n-// This does not cover the where clause, which must be processed separately.\n-impl<'hir> Sig for hir::Generics<'hir> {\n-    type Parent = LocalDefId;\n-    fn make(&self, offset: usize, _parent_id: Option<LocalDefId>, scx: &SaveContext<'_>) -> Result {\n-        if self.params.is_empty() {\n-            return Ok(text_sig(String::new()));\n-        }\n-\n-        let mut text = \"<\".to_owned();\n-\n-        let mut defs = Vec::with_capacity(self.params.len());\n-        for param in self.params {\n-            let mut param_text = String::new();\n-            if let hir::GenericParamKind::Const { .. } = param.kind {\n-                param_text.push_str(\"const \");\n-            }\n-            param_text.push_str(param.name.ident().as_str());\n-            defs.push(SigElement {\n-                id: id_from_def_id(param.def_id.to_def_id()),\n-                start: offset + text.len(),\n-                end: offset + text.len() + param_text.as_str().len(),\n-            });\n-            if let hir::GenericParamKind::Const { ref ty, default } = param.kind {\n-                param_text.push_str(\": \");\n-                param_text.push_str(&ty_to_string(&ty));\n-                if let Some(default) = default {\n-                    param_text.push_str(\" = \");\n-                    param_text.push_str(&id_to_string(&scx.tcx.hir(), default.hir_id));\n-                }\n-            }\n-            text.push_str(&param_text);\n-            text.push(',');\n-        }\n-\n-        text.push('>');\n-        Ok(Signature { text, defs, refs: vec![] })\n-    }\n-}\n-\n-impl<'hir> Sig for hir::FieldDef<'hir> {\n-    type Parent = LocalDefId;\n-    fn make(&self, offset: usize, _parent_id: Option<LocalDefId>, scx: &SaveContext<'_>) -> Result {\n-        let mut text = String::new();\n-\n-        text.push_str(&self.ident.to_string());\n-        let defs = Some(SigElement {\n-            id: id_from_def_id(self.def_id.to_def_id()),\n-            start: offset,\n-            end: offset + text.len(),\n-        });\n-        text.push_str(\": \");\n-\n-        let mut ty_sig = self.ty.make(offset + text.len(), Some(self.hir_id), scx)?;\n-        text.push_str(&ty_sig.text);\n-        ty_sig.text = text;\n-        ty_sig.defs.extend(defs.into_iter());\n-        Ok(ty_sig)\n-    }\n-}\n-\n-impl<'hir> Sig for hir::Variant<'hir> {\n-    type Parent = LocalDefId;\n-    fn make(&self, offset: usize, parent_id: Option<LocalDefId>, scx: &SaveContext<'_>) -> Result {\n-        let mut text = self.ident.to_string();\n-        match self.data {\n-            hir::VariantData::Struct(fields, r) => {\n-                let id = parent_id.ok_or(\"Missing id for Variant's parent\")?;\n-                let name_def = SigElement {\n-                    id: id_from_def_id(id.to_def_id()),\n-                    start: offset,\n-                    end: offset + text.len(),\n-                };\n-                text.push_str(\" { \");\n-                let mut defs = vec![name_def];\n-                let mut refs = vec![];\n-                if r {\n-                    text.push_str(\"/* parse error */ \");\n-                } else {\n-                    for f in fields {\n-                        let field_sig = f.make(offset + text.len(), Some(id), scx)?;\n-                        text.push_str(&field_sig.text);\n-                        text.push_str(\", \");\n-                        defs.extend(field_sig.defs.into_iter());\n-                        refs.extend(field_sig.refs.into_iter());\n-                    }\n-                }\n-                text.push('}');\n-                Ok(Signature { text, defs, refs })\n-            }\n-            hir::VariantData::Tuple(fields, _, def_id) => {\n-                let name_def = SigElement {\n-                    id: id_from_def_id(def_id.to_def_id()),\n-                    start: offset,\n-                    end: offset + text.len(),\n-                };\n-                text.push('(');\n-                let mut defs = vec![name_def];\n-                let mut refs = vec![];\n-                for f in fields {\n-                    let field_sig = f.make(offset + text.len(), Some(def_id), scx)?;\n-                    text.push_str(&field_sig.text);\n-                    text.push_str(\", \");\n-                    defs.extend(field_sig.defs.into_iter());\n-                    refs.extend(field_sig.refs.into_iter());\n-                }\n-                text.push(')');\n-                Ok(Signature { text, defs, refs })\n-            }\n-            hir::VariantData::Unit(_, def_id) => {\n-                let name_def = SigElement {\n-                    id: id_from_def_id(def_id.to_def_id()),\n-                    start: offset,\n-                    end: offset + text.len(),\n-                };\n-                Ok(Signature { text, defs: vec![name_def], refs: vec![] })\n-            }\n-        }\n-    }\n-}\n-\n-impl<'hir> Sig for hir::ForeignItem<'hir> {\n-    type Parent = hir::HirId;\n-    fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n-        let id = Some(self.hir_id());\n-        match self.kind {\n-            hir::ForeignItemKind::Fn(decl, _, ref generics) => {\n-                let mut text = String::new();\n-                text.push_str(\"fn \");\n-\n-                let mut sig =\n-                    name_and_generics(text, offset, generics, self.owner_id, self.ident, scx)?;\n-\n-                sig.text.push('(');\n-                for i in decl.inputs {\n-                    sig.text.push_str(\": \");\n-                    let nested = i.make(offset + sig.text.len(), Some(i.hir_id), scx)?;\n-                    sig.text.push_str(&nested.text);\n-                    sig.text.push(',');\n-                    sig.defs.extend(nested.defs.into_iter());\n-                    sig.refs.extend(nested.refs.into_iter());\n-                }\n-                sig.text.push(')');\n-\n-                if let hir::FnRetTy::Return(ref t) = decl.output {\n-                    sig.text.push_str(\" -> \");\n-                    let nested = t.make(offset + sig.text.len(), None, scx)?;\n-                    sig.text.push_str(&nested.text);\n-                    sig.defs.extend(nested.defs.into_iter());\n-                    sig.refs.extend(nested.refs.into_iter());\n-                }\n-                sig.text.push(';');\n-\n-                Ok(sig)\n-            }\n-            hir::ForeignItemKind::Static(ref ty, m) => {\n-                let mut text = \"static \".to_owned();\n-                text.push_str(m.prefix_str());\n-\n-                let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_def_id(self.owner_id.to_def_id()),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n-                text.push_str(&name);\n-                text.push_str(\": \");\n-\n-                let ty_sig = ty.make(offset + text.len(), id, scx)?;\n-                text.push(';');\n-\n-                Ok(extend_sig(ty_sig, text, defs, vec![]))\n-            }\n-            hir::ForeignItemKind::Type => {\n-                let mut text = \"type \".to_owned();\n-                let name = self.ident.to_string();\n-                let defs = vec![SigElement {\n-                    id: id_from_def_id(self.owner_id.to_def_id()),\n-                    start: offset + text.len(),\n-                    end: offset + text.len() + name.len(),\n-                }];\n-                text.push_str(&name);\n-                text.push(';');\n-\n-                Ok(Signature { text, defs, refs: vec![] })\n-            }\n-        }\n-    }\n-}\n-\n-fn name_and_generics(\n-    mut text: String,\n-    offset: usize,\n-    generics: &hir::Generics<'_>,\n-    id: hir::OwnerId,\n-    name: Ident,\n-    scx: &SaveContext<'_>,\n-) -> Result {\n-    let name = name.to_string();\n-    let def = SigElement {\n-        id: id_from_def_id(id.to_def_id()),\n-        start: offset + text.len(),\n-        end: offset + text.len() + name.len(),\n-    };\n-    text.push_str(&name);\n-    let generics: Signature = generics.make(offset + text.len(), Some(id.def_id), scx)?;\n-    // FIXME where clause\n-    let text = format!(\"{}{}\", text, generics.text);\n-    Ok(extend_sig(generics, text, vec![def], vec![]))\n-}\n-\n-fn make_assoc_type_signature(\n-    id: hir::OwnerId,\n-    ident: Ident,\n-    bounds: Option<hir::GenericBounds<'_>>,\n-    default: Option<&hir::Ty<'_>>,\n-    scx: &SaveContext<'_>,\n-) -> Result {\n-    let mut text = \"type \".to_owned();\n-    let name = ident.to_string();\n-    let mut defs = vec![SigElement {\n-        id: id_from_def_id(id.to_def_id()),\n-        start: text.len(),\n-        end: text.len() + name.len(),\n-    }];\n-    let mut refs = vec![];\n-    text.push_str(&name);\n-    if let Some(bounds) = bounds {\n-        text.push_str(\": \");\n-        // FIXME should descend into bounds\n-        text.push_str(&bounds_to_string(bounds));\n-    }\n-    if let Some(default) = default {\n-        text.push_str(\" = \");\n-        let ty_sig = default.make(text.len(), Some(id.into()), scx)?;\n-        text.push_str(&ty_sig.text);\n-        defs.extend(ty_sig.defs.into_iter());\n-        refs.extend(ty_sig.refs.into_iter());\n-    }\n-    text.push(';');\n-    Ok(Signature { text, defs, refs })\n-}\n-\n-fn make_assoc_const_signature(\n-    id: hir::OwnerId,\n-    ident: Symbol,\n-    ty: &hir::Ty<'_>,\n-    default: Option<&hir::Expr<'_>>,\n-    scx: &SaveContext<'_>,\n-) -> Result {\n-    let mut text = \"const \".to_owned();\n-    let name = ident.to_string();\n-    let mut defs = vec![SigElement {\n-        id: id_from_def_id(id.to_def_id()),\n-        start: text.len(),\n-        end: text.len() + name.len(),\n-    }];\n-    let mut refs = vec![];\n-    text.push_str(&name);\n-    text.push_str(\": \");\n-\n-    let ty_sig = ty.make(text.len(), Some(id.into()), scx)?;\n-    text.push_str(&ty_sig.text);\n-    defs.extend(ty_sig.defs.into_iter());\n-    refs.extend(ty_sig.refs.into_iter());\n-\n-    if let Some(default) = default {\n-        text.push_str(\" = \");\n-        text.push_str(&id_to_string(&scx.tcx.hir(), default.hir_id));\n-    }\n-    text.push(';');\n-    Ok(Signature { text, defs, refs })\n-}\n-\n-fn make_method_signature(\n-    id: hir::OwnerId,\n-    ident: Ident,\n-    generics: &hir::Generics<'_>,\n-    m: &hir::FnSig<'_>,\n-    scx: &SaveContext<'_>,\n-) -> Result {\n-    // FIXME code dup with function signature\n-    let mut text = String::new();\n-    if let hir::Constness::Const = m.header.constness {\n-        text.push_str(\"const \");\n-    }\n-    if hir::IsAsync::Async == m.header.asyncness {\n-        text.push_str(\"async \");\n-    }\n-    if let hir::Unsafety::Unsafe = m.header.unsafety {\n-        text.push_str(\"unsafe \");\n-    }\n-    text.push_str(\"fn \");\n-\n-    let mut sig = name_and_generics(text, 0, generics, id, ident, scx)?;\n-\n-    sig.text.push('(');\n-    for i in m.decl.inputs {\n-        sig.text.push_str(\": \");\n-        let nested = i.make(sig.text.len(), Some(i.hir_id), scx)?;\n-        sig.text.push_str(&nested.text);\n-        sig.text.push(',');\n-        sig.defs.extend(nested.defs.into_iter());\n-        sig.refs.extend(nested.refs.into_iter());\n-    }\n-    sig.text.push(')');\n-\n-    if let hir::FnRetTy::Return(ref t) = m.decl.output {\n-        sig.text.push_str(\" -> \");\n-        let nested = t.make(sig.text.len(), None, scx)?;\n-        sig.text.push_str(&nested.text);\n-        sig.defs.extend(nested.defs.into_iter());\n-        sig.refs.extend(nested.refs.into_iter());\n-    }\n-    sig.text.push_str(\" {}\");\n-\n-    Ok(sig)\n-}"}, {"sha": "e65d57bb3db3e7737ffbc18b8670df244346be6f", "filename": "compiler/rustc_save_analysis/src/span_utils.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,96 +0,0 @@\n-use crate::generated_code;\n-use rustc_data_structures::sync::Lrc;\n-use rustc_lexer::{tokenize, TokenKind};\n-use rustc_session::Session;\n-use rustc_span::*;\n-\n-#[derive(Clone)]\n-pub struct SpanUtils<'a> {\n-    pub sess: &'a Session,\n-}\n-\n-impl<'a> SpanUtils<'a> {\n-    pub fn new(sess: &'a Session) -> SpanUtils<'a> {\n-        SpanUtils { sess }\n-    }\n-\n-    pub fn make_filename_string(&self, file: &SourceFile) -> String {\n-        match &file.name {\n-            FileName::Real(RealFileName::LocalPath(path)) => {\n-                if path.is_absolute() {\n-                    self.sess.source_map().path_mapping().map_prefix(path).0.display().to_string()\n-                } else {\n-                    self.sess\n-                        .opts\n-                        .working_dir\n-                        .remapped_path_if_available()\n-                        .join(&path)\n-                        .display()\n-                        .to_string()\n-                }\n-            }\n-            filename => filename.prefer_remapped().to_string(),\n-        }\n-    }\n-\n-    pub fn snippet(&self, span: Span) -> String {\n-        match self.sess.source_map().span_to_snippet(span) {\n-            Ok(s) => s,\n-            Err(_) => String::new(),\n-        }\n-    }\n-\n-    /// Finds the span of `*` token withing the larger `span`.\n-    pub fn sub_span_of_star(&self, mut span: Span) -> Option<Span> {\n-        let begin = self.sess.source_map().lookup_byte_offset(span.lo());\n-        let end = self.sess.source_map().lookup_byte_offset(span.hi());\n-        // Make the range zero-length if the span is invalid.\n-        if begin.sf.start_pos != end.sf.start_pos {\n-            span = span.shrink_to_lo();\n-        }\n-\n-        let sf = Lrc::clone(&begin.sf);\n-\n-        self.sess.source_map().ensure_source_file_source_present(Lrc::clone(&sf));\n-        let src =\n-            sf.src.clone().or_else(|| sf.external_src.borrow().get_source().map(Lrc::clone))?;\n-        let to_index = |pos: BytePos| -> usize { (pos - sf.start_pos).0 as usize };\n-        let text = &src[to_index(span.lo())..to_index(span.hi())];\n-        let start_pos = {\n-            let mut pos = 0;\n-            tokenize(text)\n-                .map(|token| {\n-                    let start = pos;\n-                    pos += token.len;\n-                    (start, token)\n-                })\n-                .find(|(_pos, token)| token.kind == TokenKind::Star)?\n-                .0\n-        };\n-        let lo = span.lo() + BytePos(start_pos as u32);\n-        let hi = lo + BytePos(1);\n-        Some(span.with_lo(lo).with_hi(hi))\n-    }\n-\n-    /// Return true if the span is generated code, and\n-    /// it is not a subspan of the root callsite.\n-    ///\n-    /// Used to filter out spans of minimal value,\n-    /// such as references to macro internal variables.\n-    pub fn filter_generated(&self, span: Span) -> bool {\n-        if generated_code(span) {\n-            return true;\n-        }\n-\n-        //If the span comes from a fake source_file, filter it.\n-        !self.sess.source_map().lookup_char_pos(span.lo()).file.is_real_file()\n-    }\n-}\n-\n-macro_rules! filter {\n-    ($util: expr, $parent: expr) => {\n-        if $util.filter_generated($parent) {\n-            return None;\n-        }\n-    };\n-}"}, {"sha": "d9e68320f8ffa5e1fa5247c391294f3b1e4c326b", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1629,9 +1629,6 @@ options! {\n     saturating_float_casts: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"make float->int casts UB-free: numbers outside the integer type's range are clipped to \\\n         the max/min integer respectively, and NaN is mapped to 0 (default: yes)\"),\n-    save_analysis: bool = (false, parse_bool, [UNTRACKED],\n-        \"write syntax and type analysis (in JSON format) information, in \\\n-        addition to normal output (default: no)\"),\n     self_profile: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n         parse_switch_with_opt_path, [UNTRACKED],\n         \"run the self profiler and output the raw event data\"),"}, {"sha": "28aa3d5270590f2c6c15d7faf54619bf77b84e51", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -547,7 +547,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             response.value.certainty == Certainty::Yes\n                 && response.has_no_inference_or_external_constraints()\n         }) {\n-            return Ok(response.clone());\n+            return Ok(*response);\n         }\n \n         let certainty = candidates.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {"}, {"sha": "edb36b4ac814161f25ce19c24c166f17e496ea7f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1628,7 +1628,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // Eventually I'll need to implement param-env-aware\n                 // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n                 let param_env = ty::ParamEnv::empty();\n-                if self.can_sub(param_env, error, implication).is_ok() {\n+                if self.can_sub(param_env, error, implication) {\n                     debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n                     return true;\n                 }"}, {"sha": "52ed64868c053466ee4a048d1ddaaef92bff6062", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n             let impl_self_ty = impl_trait_ref.self_ty();\n \n-            if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n+            if self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n                 self_match_impls.push((def_id, impl_substs));\n \n                 if iter::zip(\n@@ -261,7 +261,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // Arrays give us `[]`, `[{ty}; _]` and `[{ty}; N]`\n             if let ty::Array(aty, len) = self_ty.kind() {\n                 flags.push((sym::_Self, Some(\"[]\".to_string())));\n-                let len = len.kind().try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n+                let len = len.kind().try_to_value().and_then(|v| v.try_to_target_usize(self.tcx));\n                 flags.push((sym::_Self, Some(format!(\"[{}; _]\", aty))));\n                 if let Some(n) = len {\n                     flags.push((sym::_Self, Some(format!(\"[{}; {}]\", aty, n))));"}, {"sha": "135232d1b2089da0b49b139e285ab7942379d008", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -748,10 +748,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let real_ty = real_trait_pred.self_ty();\n             // We `erase_late_bound_regions` here because `make_subregion` does not handle\n             // `ReLateBound`, and we don't particularly care about the regions.\n-            if self\n-                .can_eq(obligation.param_env, self.tcx.erase_late_bound_regions(real_ty), arg_ty)\n-                .is_err()\n-            {\n+            if !self.can_eq(\n+                obligation.param_env,\n+                self.tcx.erase_late_bound_regions(real_ty),\n+                arg_ty,\n+            ) {\n                 continue;\n             }\n \n@@ -3690,7 +3691,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     let Some((span, (assoc, ty))) = entry else { continue; };\n                     if primary_spans.is_empty() || type_diffs.iter().any(|diff| {\n                         let Sorts(expected_found) = diff else { return false; };\n-                        self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                        self.can_eq(param_env, expected_found.found, ty)\n                     }) {\n                         // FIXME: this doesn't quite work for `Iterator::collect`\n                         // because we have `Vec<i32>` and `()`, but we'd want `i32`\n@@ -3717,10 +3718,10 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         let ty_str = with_forced_trimmed_paths!(self.ty_to_string(ty));\n \n                         let assoc = with_forced_trimmed_paths!(self.tcx.def_path_str(assoc));\n-                        if self.can_eq(param_env, ty, *prev_ty).is_err() {\n+                        if !self.can_eq(param_env, ty, *prev_ty) {\n                             if type_diffs.iter().any(|diff| {\n                                 let Sorts(expected_found) = diff else { return false; };\n-                                self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                                self.can_eq(param_env, expected_found.found, ty)\n                             }) {\n                                 primary_spans.push(span);\n                             }\n@@ -3868,7 +3869,7 @@ fn hint_missing_borrow<'tcx>(\n         let (found_ty, found_refs) = get_deref_type_and_refs(*found_arg);\n         let (expected_ty, expected_refs) = get_deref_type_and_refs(*expected_arg);\n \n-        if infcx.can_eq(param_env, found_ty, expected_ty).is_ok() {\n+        if infcx.can_eq(param_env, found_ty, expected_ty) {\n             // FIXME: This could handle more exotic cases like mutability mismatches too!\n             if found_refs.len() < expected_refs.len()\n                 && found_refs[..] == expected_refs[expected_refs.len() - found_refs.len()..]"}, {"sha": "7ef39b20107438e0266f8a06b7eba2cf9aecf4b3", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -599,7 +599,7 @@ fn virtual_call_violation_for_method<'tcx>(\n             return false;\n         }\n \n-        contains_illegal_self_type_reference(tcx, trait_def_id, pred.clone())\n+        contains_illegal_self_type_reference(tcx, trait_def_id, pred)\n     }) {\n         return Some(MethodViolationCode::WhereClauseReferencesSelf);\n     }"}, {"sha": "2fe9d135fa562f23824b1e379f447a98a1f58b02", "filename": "compiler/rustc_ty_utils/src/implied_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -21,7 +21,7 @@ fn assumed_wf_types(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Ty<'_>> {\n             assumed_wf_types.extend(liberated_sig.inputs_and_output);\n             tcx.intern_type_list(&assumed_wf_types)\n         }\n-        DefKind::Impl => {\n+        DefKind::Impl { .. } => {\n             match tcx.impl_trait_ref(def_id) {\n                 Some(trait_ref) => {\n                     let types: Vec<_> = trait_ref.skip_binder().substs.types().collect();"}, {"sha": "e080726d91d589bb2ca323c9e2f16158ee96146d", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -336,7 +336,7 @@ impl<I: Interner> PartialEq for TyKind<I> {\n                 a_d == b_d && a_s == b_s && a_m == b_m\n             }\n             (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g == b_g,\n-            (&GeneratorWitnessMIR(ref a_d, ref a_s), &GeneratorWitnessMIR(ref b_d, ref b_s)) => {\n+            (GeneratorWitnessMIR(a_d, a_s), GeneratorWitnessMIR(b_d, b_s)) => {\n                 a_d == b_d && a_s == b_s\n             }\n             (Tuple(a_t), Tuple(b_t)) => a_t == b_t,\n@@ -397,8 +397,8 @@ impl<I: Interner> Ord for TyKind<I> {\n                 }\n                 (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g.cmp(b_g),\n                 (\n-                    &GeneratorWitnessMIR(ref a_d, ref a_s),\n-                    &GeneratorWitnessMIR(ref b_d, ref b_s),\n+                    GeneratorWitnessMIR(a_d, a_s),\n+                    GeneratorWitnessMIR(b_d, b_s),\n                 ) => match Ord::cmp(a_d, b_d) {\n                     Ordering::Equal => Ord::cmp(a_s, b_s),\n                     cmp => cmp,"}, {"sha": "b4d58376aea5d363fa8b708b2ebbf470eeb785d0", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1491,9 +1491,10 @@ mod impls {\n         }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A: ?Sized, B: ?Sized> PartialOrd<&B> for &A\n+    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+    impl<A: ?Sized, B: ?Sized> const PartialOrd<&B> for &A\n     where\n-        A: PartialOrd<B>,\n+        A: ~const PartialOrd<B>,\n     {\n         #[inline]\n         fn partial_cmp(&self, other: &&B) -> Option<Ordering> {"}, {"sha": "87f077325f8bef527102c17c1bcdbb810cc98bc9", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -457,6 +457,10 @@ impl CStr {\n     /// to a contiguous region of memory terminated with a 0 byte to represent\n     /// the end of the string.\n     ///\n+    /// The type of the returned pointer is\n+    /// [`*const c_char`][crate::ffi::c_char], and whether it's\n+    /// an alias for `*const i8` or `*const u8` is platform-specific.\n+    ///\n     /// **WARNING**\n     ///\n     /// The returned pointer is read-only; writing to it (including passing it\n@@ -470,6 +474,7 @@ impl CStr {\n     /// # #![allow(unused_must_use)] #![allow(temporary_cstring_as_ptr)]\n     /// use std::ffi::CString;\n     ///\n+    /// // Do not do this:\n     /// let ptr = CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr();\n     /// unsafe {\n     ///     // `ptr` is dangling"}, {"sha": "ee13dae60b1984da3c8628aabdb64b871b48f551", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -216,7 +216,8 @@ pub fn spin_loop() {\n ///\n /// Note however, that `black_box` is only (and can only be) provided on a \"best-effort\" basis. The\n /// extent to which it can block optimisations may vary depending upon the platform and code-gen\n-/// backend used. Programs cannot rely on `black_box` for *correctness* in any way.\n+/// backend used. Programs cannot rely on `black_box` for *correctness*, beyond it behaving as the\n+/// identity function.\n ///\n /// [`std::convert::identity`]: crate::convert::identity\n ///"}, {"sha": "b8ab2656473df7007ffc2b13993180c280218020", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 60, "deletions": 38, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -96,7 +96,7 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     }\n }\n \n-impl<Idx: PartialOrd<Idx>> Range<Idx> {\n+impl<Idx: ~const PartialOrd<Idx>> Range<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -116,10 +116,11 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// assert!(!(f32::NAN..1.0).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    pub fn contains<U>(&self, item: &U) -> bool\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<Idx>,\n+        Idx: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -142,7 +143,8 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// assert!( (f32::NAN..5.0).is_empty());\n     /// ```\n     #[stable(feature = \"range_is_empty\", since = \"1.47.0\")]\n-    pub fn is_empty(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn is_empty(&self) -> bool {\n         !(self.start < self.end)\n     }\n }\n@@ -199,7 +201,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     }\n }\n \n-impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n+impl<Idx: ~const PartialOrd<Idx>> RangeFrom<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -214,10 +216,11 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// assert!(!(f32::NAN..).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    pub fn contains<U>(&self, item: &U) -> bool\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<Idx>,\n+        Idx: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -280,7 +283,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     }\n }\n \n-impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n+impl<Idx: ~const PartialOrd<Idx>> RangeTo<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -295,10 +298,11 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// assert!(!(..f32::NAN).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    pub fn contains<U>(&self, item: &U) -> bool\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<Idx>,\n+        Idx: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -437,7 +441,8 @@ impl<Idx> RangeInclusive<Idx> {\n     /// ```\n     #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n     #[inline]\n-    pub fn into_inner(self) -> (Idx, Idx) {\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn into_inner(self) -> (Idx, Idx) {\n         (self.start, self.end)\n     }\n }\n@@ -469,7 +474,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     }\n }\n \n-impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n+impl<Idx: ~const PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -500,10 +505,11 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(!r.contains(&3) && !r.contains(&5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    pub fn contains<U>(&self, item: &U) -> bool\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<Idx>,\n+        Idx: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -535,8 +541,9 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(r.is_empty());\n     /// ```\n     #[stable(feature = \"range_is_empty\", since = \"1.47.0\")]\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n     #[inline]\n-    pub fn is_empty(&self) -> bool {\n+    pub const fn is_empty(&self) -> bool {\n         self.exhausted || !(self.start <= self.end)\n     }\n }\n@@ -598,7 +605,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     }\n }\n \n-impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n+impl<Idx: ~const PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -613,10 +620,11 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// assert!(!(..=f32::NAN).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    pub fn contains<U>(&self, item: &U) -> bool\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<Idx>,\n+        Idx: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -757,6 +765,7 @@ impl<T: Clone> Bound<&T> {\n /// `RangeBounds` is implemented by Rust's built-in range types, produced\n /// by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.\n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n+#[const_trait]\n pub trait RangeBounds<T: ?Sized> {\n     /// Start index bound.\n     ///\n@@ -809,8 +818,8 @@ pub trait RangeBounds<T: ?Sized> {\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     fn contains<U>(&self, item: &U) -> bool\n     where\n-        T: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<T>,\n+        T: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<T>,\n     {\n         (match self.start_bound() {\n             Included(start) => start <= item,\n@@ -827,7 +836,8 @@ pub trait RangeBounds<T: ?Sized> {\n use self::Bound::{Excluded, Included, Unbounded};\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T: ?Sized> RangeBounds<T> for RangeFull {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T: ?Sized> const RangeBounds<T> for RangeFull {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -837,7 +847,8 @@ impl<T: ?Sized> RangeBounds<T> for RangeFull {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeFrom<T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeFrom<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -847,7 +858,8 @@ impl<T> RangeBounds<T> for RangeFrom<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeTo<T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeTo<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -857,7 +869,8 @@ impl<T> RangeBounds<T> for RangeTo<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for Range<T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for Range<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -867,7 +880,8 @@ impl<T> RangeBounds<T> for Range<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeInclusive<T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeInclusive<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -883,7 +897,8 @@ impl<T> RangeBounds<T> for RangeInclusive<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeToInclusive<T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeToInclusive<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -893,7 +908,8 @@ impl<T> RangeBounds<T> for RangeToInclusive<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for (Bound<T>, Bound<T>) {\n     fn start_bound(&self) -> Bound<&T> {\n         match *self {\n             (Included(ref start), _) => Included(start),\n@@ -912,7 +928,8 @@ impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<'a, T: ?Sized + 'a> const RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n     fn start_bound(&self) -> Bound<&T> {\n         self.0\n     }\n@@ -923,7 +940,8 @@ impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeFrom<&T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeFrom<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -933,7 +951,8 @@ impl<T> RangeBounds<T> for RangeFrom<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeTo<&T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeTo<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -943,7 +962,8 @@ impl<T> RangeBounds<T> for RangeTo<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for Range<&T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for Range<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -953,7 +973,8 @@ impl<T> RangeBounds<T> for Range<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeInclusive<&T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeInclusive<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -963,7 +984,8 @@ impl<T> RangeBounds<T> for RangeInclusive<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeToInclusive<&T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeToInclusive<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }"}, {"sha": "c550378e7d6b79ba680de269dc5db64ed327e4c4", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -334,6 +334,10 @@ impl File {\n     ///\n     /// See the [`OpenOptions::open`] method for more details.\n     ///\n+    /// If you only need to read the entire file contents,\n+    /// consider [`std::fs::read()`][self::read] or\n+    /// [`std::fs::read_to_string()`][self::read_to_string] instead.\n+    ///\n     /// # Errors\n     ///\n     /// This function will return an error if `path` does not already exist.\n@@ -343,9 +347,12 @@ impl File {\n     ///\n     /// ```no_run\n     /// use std::fs::File;\n+    /// use std::io::Read;\n     ///\n     /// fn main() -> std::io::Result<()> {\n     ///     let mut f = File::open(\"foo.txt\")?;\n+    ///     let mut data = vec![];\n+    ///     f.read_to_end(&mut data)?;\n     ///     Ok(())\n     /// }\n     /// ```\n@@ -361,16 +368,20 @@ impl File {\n     ///\n     /// Depending on the platform, this function may fail if the\n     /// full directory path does not exist.\n-    ///\n     /// See the [`OpenOptions::open`] function for more details.\n     ///\n+    /// See also [`std::fs::write()`][self::write] for a simple function to\n+    /// create a file with a given data.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::fs::File;\n+    /// use std::io::Write;\n     ///\n     /// fn main() -> std::io::Result<()> {\n     ///     let mut f = File::create(\"foo.txt\")?;\n+    ///     f.write_all(&1234_u32.to_be_bytes())?;\n     ///     Ok(())\n     /// }\n     /// ```\n@@ -397,9 +408,11 @@ impl File {\n     /// #![feature(file_create_new)]\n     ///\n     /// use std::fs::File;\n+    /// use std::io::Write;\n     ///\n     /// fn main() -> std::io::Result<()> {\n     ///     let mut f = File::create_new(\"foo.txt\")?;\n+    ///     f.write_all(\"Hello, world!\".as_bytes())?;\n     ///     Ok(())\n     /// }\n     /// ```\n@@ -426,9 +439,11 @@ impl File {\n     ///\n     /// ```no_run\n     /// use std::fs::File;\n+    /// use std::io::Write;\n     ///\n     /// fn main() -> std::io::Result<()> {\n     ///     let mut f = File::options().append(true).open(\"example.log\")?;\n+    ///     writeln!(&mut f, \"new line\")?;\n     ///     Ok(())\n     /// }\n     /// ```\n@@ -966,6 +981,9 @@ impl OpenOptions {\n     /// In order for the file to be created, [`OpenOptions::write`] or\n     /// [`OpenOptions::append`] access must be used.\n     ///\n+    /// See also [`std::fs::write()`][self::write] for a simple function to\n+    /// create a file with a given data.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run"}, {"sha": "fe9934439d152fddbfa0c417abae9c8a465a7cf6", "filename": "library/std/src/sys/itron/thread_parking.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -0,0 +1,37 @@\n+use super::abi;\n+use super::error::expect_success_aborting;\n+use super::time::with_tmos;\n+use crate::time::Duration;\n+\n+pub type ThreadId = abi::ID;\n+\n+pub use super::task::current_task_id_aborting as current;\n+\n+pub fn park(_hint: usize) {\n+    match unsafe { abi::slp_tsk() } {\n+        abi::E_OK | abi::E_RLWAI => {}\n+        err => {\n+            expect_success_aborting(err, &\"slp_tsk\");\n+        }\n+    }\n+}\n+\n+pub fn park_timeout(dur: Duration, _hint: usize) {\n+    match with_tmos(dur, |tmo| unsafe { abi::tslp_tsk(tmo) }) {\n+        abi::E_OK | abi::E_RLWAI | abi::E_TMOUT => {}\n+        err => {\n+            expect_success_aborting(err, &\"tslp_tsk\");\n+        }\n+    }\n+}\n+\n+pub fn unpark(id: ThreadId, _hint: usize) {\n+    match unsafe { abi::wup_tsk(id) } {\n+        // It is allowed to try to wake up a destroyed or unrelated task, so we ignore all\n+        // errors that could result from that situation.\n+        abi::E_OK | abi::E_NOEXS | abi::E_OBJ | abi::E_QOVR => {}\n+        err => {\n+            expect_success_aborting(err, &\"wup_tsk\");\n+        }\n+    }\n+}"}, {"sha": "e432edd207754e5151252c136a0946d0821d1a6a", "filename": "library/std/src/sys/itron/wait_flag.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,72 +0,0 @@\n-use crate::mem::MaybeUninit;\n-use crate::time::Duration;\n-\n-use super::{\n-    abi,\n-    error::{expect_success, fail},\n-    time::with_tmos,\n-};\n-\n-const CLEAR: abi::FLGPTN = 0;\n-const RAISED: abi::FLGPTN = 1;\n-\n-/// A thread parking primitive that is not susceptible to race conditions,\n-/// but provides no atomic ordering guarantees and allows only one `raise` per wait.\n-pub struct WaitFlag {\n-    flag: abi::ID,\n-}\n-\n-impl WaitFlag {\n-    /// Creates a new wait flag.\n-    pub fn new() -> WaitFlag {\n-        let flag = expect_success(\n-            unsafe {\n-                abi::acre_flg(&abi::T_CFLG {\n-                    flgatr: abi::TA_FIFO | abi::TA_WSGL | abi::TA_CLR,\n-                    iflgptn: CLEAR,\n-                })\n-            },\n-            &\"acre_flg\",\n-        );\n-\n-        WaitFlag { flag }\n-    }\n-\n-    /// Wait for the wait flag to be raised.\n-    pub fn wait(&self) {\n-        let mut token = MaybeUninit::uninit();\n-        expect_success(\n-            unsafe { abi::wai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr()) },\n-            &\"wai_flg\",\n-        );\n-    }\n-\n-    /// Wait for the wait flag to be raised or the timeout to occur.\n-    ///\n-    /// Returns whether the flag was raised (`true`) or the operation timed out (`false`).\n-    pub fn wait_timeout(&self, dur: Duration) -> bool {\n-        let mut token = MaybeUninit::uninit();\n-        let res = with_tmos(dur, |tmout| unsafe {\n-            abi::twai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr(), tmout)\n-        });\n-\n-        match res {\n-            abi::E_OK => true,\n-            abi::E_TMOUT => false,\n-            error => fail(error, &\"twai_flg\"),\n-        }\n-    }\n-\n-    /// Raise the wait flag.\n-    ///\n-    /// Calls to this function should be balanced with the number of successful waits.\n-    pub fn raise(&self) {\n-        expect_success(unsafe { abi::set_flg(self.flag, RAISED) }, &\"set_flg\");\n-    }\n-}\n-\n-impl Drop for WaitFlag {\n-    fn drop(&mut self) {\n-        expect_success(unsafe { abi::del_flg(self.flag) }, &\"del_flg\");\n-    }\n-}"}, {"sha": "923d27fd9369d40219d1777cfef77e5e1332909f", "filename": "library/std/src/sys/solid/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -13,9 +13,9 @@ mod itron {\n     pub(super) mod spin;\n     pub(super) mod task;\n     pub mod thread;\n+    pub mod thread_parking;\n     pub(super) mod time;\n     use super::unsupported;\n-    pub mod wait_flag;\n }\n \n pub mod alloc;\n@@ -43,8 +43,8 @@ pub use self::itron::thread;\n pub mod memchr;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n+pub use self::itron::thread_parking;\n pub mod time;\n-pub use self::itron::wait_flag;\n \n mod rwlock;\n "}, {"sha": "e8e028bb3308f1c480b2ced3e33d6ebda6d370ab", "filename": "library/std/src/sys_common/thread_parking/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -14,12 +14,10 @@ cfg_if::cfg_if! {\n     } else if #[cfg(any(\n         target_os = \"netbsd\",\n         all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+        target_os = \"solid_asp3\",\n     ))] {\n         mod id;\n         pub use id::Parker;\n-    } else if #[cfg(target_os = \"solid_asp3\")] {\n-        mod wait_flag;\n-        pub use wait_flag::Parker;\n     } else if #[cfg(any(windows, target_family = \"unix\"))] {\n         pub use crate::sys::thread_parking::Parker;\n     } else {"}, {"sha": "d0f8899a94eb8507ff233f5d8321bf576fc8827e", "filename": "library/std/src/sys_common/thread_parking/wait_flag.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,102 +0,0 @@\n-//! A wait-flag-based thread parker.\n-//!\n-//! Some operating systems provide low-level parking primitives like wait counts,\n-//! event flags or semaphores which are not susceptible to race conditions (meaning\n-//! the wakeup can occur before the wait operation). To implement the `std` thread\n-//! parker on top of these primitives, we only have to ensure that parking is fast\n-//! when the thread token is available, the atomic ordering guarantees are maintained\n-//! and spurious wakeups are minimized.\n-//!\n-//! To achieve this, this parker uses an atomic variable with three states: `EMPTY`,\n-//! `PARKED` and `NOTIFIED`:\n-//! * `EMPTY` means the token has not been made available, but the thread is not\n-//!    currently waiting on it.\n-//! * `PARKED` means the token is not available and the thread is parked.\n-//! * `NOTIFIED` means the token is available.\n-//!\n-//! `park` and `park_timeout` change the state from `EMPTY` to `PARKED` and from\n-//! `NOTIFIED` to `EMPTY`. If the state was `NOTIFIED`, the thread was unparked and\n-//! execution can continue without calling into the OS. If the state was `EMPTY`,\n-//! the token is not available and the thread waits on the primitive (here called\n-//! \"wait flag\").\n-//!\n-//! `unpark` changes the state to `NOTIFIED`. If the state was `PARKED`, the thread\n-//! is or will be sleeping on the wait flag, so we raise it.\n-\n-use crate::pin::Pin;\n-use crate::sync::atomic::AtomicI8;\n-use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n-use crate::sys::wait_flag::WaitFlag;\n-use crate::time::Duration;\n-\n-const EMPTY: i8 = 0;\n-const PARKED: i8 = -1;\n-const NOTIFIED: i8 = 1;\n-\n-pub struct Parker {\n-    state: AtomicI8,\n-    wait_flag: WaitFlag,\n-}\n-\n-impl Parker {\n-    /// Construct a parker for the current thread. The UNIX parker\n-    /// implementation requires this to happen in-place.\n-    pub unsafe fn new_in_place(parker: *mut Parker) {\n-        parker.write(Parker { state: AtomicI8::new(EMPTY), wait_flag: WaitFlag::new() })\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        match self.state.fetch_sub(1, Acquire) {\n-            // NOTIFIED => EMPTY\n-            NOTIFIED => return,\n-            // EMPTY => PARKED\n-            EMPTY => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-\n-        // Avoid waking up from spurious wakeups (these are quite likely, see below).\n-        loop {\n-            self.wait_flag.wait();\n-\n-            match self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Relaxed) {\n-                Ok(_) => return,\n-                Err(PARKED) => (),\n-                Err(_) => panic!(\"inconsistent park state\"),\n-            }\n-        }\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        match self.state.fetch_sub(1, Acquire) {\n-            NOTIFIED => return,\n-            EMPTY => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-\n-        self.wait_flag.wait_timeout(dur);\n-\n-        // Either a wakeup or a timeout occurred. Wakeups may be spurious, as there can be\n-        // a race condition when `unpark` is performed between receiving the timeout and\n-        // resetting the state, resulting in the eventflag being set unnecessarily. `park`\n-        // is protected against this by looping until the token is actually given, but\n-        // here we cannot easily tell.\n-\n-        // Use `swap` to provide acquire ordering.\n-        match self.state.swap(EMPTY, Acquire) {\n-            NOTIFIED => (),\n-            PARKED => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-    }\n-\n-    // This implementation doesn't require `Pin`, but other implementations do.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-\n-        if state == PARKED {\n-            self.wait_flag.raise();\n-        }\n-    }\n-}"}, {"sha": "952c70cec1c057007046515372e9bf139f279c42", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -780,7 +780,6 @@ impl<'a> Builder<'a> {\n                 install::Clippy,\n                 install::Miri,\n                 install::LlvmTools,\n-                install::Analysis,\n                 install::Src,\n                 install::Rustc\n             ),\n@@ -1802,16 +1801,6 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        if mode == Mode::Std && self.config.extended && compiler.is_final_stage(self) {\n-            rustflags.arg(\"-Zsave-analysis\");\n-            cargo.env(\n-                \"RUST_SAVE_ANALYSIS_CONFIG\",\n-                \"{\\\"output_file\\\": null,\\\"full_docs\\\": false,\\\n-                       \\\"pub_only\\\": true,\\\"reachable_only\\\": false,\\\n-                       \\\"distro_crate\\\": true,\\\"signatures\\\": false,\\\"borrow_data\\\": false}\",\n-            );\n-        }\n-\n         // If Control Flow Guard is enabled, pass the `control-flow-guard` flag to rustc\n         // when compiling the standard library, since this might be linked into the final outputs\n         // produced by rustc. Since this mitigation is only available on Windows, only enable it"}, {"sha": "9b2b549612d81183f64c027f2a5a182cdd4368d7", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -12,6 +12,7 @@ use std::collections::HashSet;\n use std::env;\n use std::ffi::OsStr;\n use std::fs;\n+use std::io::Write;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n@@ -753,22 +754,28 @@ impl Step for Analysis {\n         });\n     }\n \n-    /// Creates a tarball of save-analysis metadata, if available.\n+    /// Creates a tarball of (degenerate) save-analysis metadata, if available.\n     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         if compiler.host != builder.config.build {\n             return None;\n         }\n \n-        builder.ensure(compile::Std::new(compiler, target));\n         let src = builder\n             .stage_out(compiler, Mode::Std)\n             .join(target.triple)\n             .join(builder.cargo_dir())\n             .join(\"deps\")\n             .join(\"save-analysis\");\n \n+        // Write a file indicating that this component has been removed.\n+        t!(std::fs::create_dir_all(&src));\n+        let mut removed = src.clone();\n+        removed.push(\"removed.json\");\n+        let mut f = t!(std::fs::File::create(removed));\n+        t!(write!(f, r#\"{{ \"warning\": \"The `rust-analysis` component has been removed.\" }}\"#));\n+\n         let mut tarball = Tarball::new(builder, \"rust-analysis\", &target.triple);\n         tarball.include_target_in_component_name(true);\n         tarball.add_dir(src, format!(\"lib/rustlib/{}/analysis\", target.triple));"}, {"sha": "ac3843c3344eb97cf3446c1d4d8d268721f90156", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -243,18 +243,6 @@ install!((self, builder, _config),\n             );\n         }\n     };\n-    Analysis, alias = \"analysis\", Self::should_build(_config), only_hosts: false, {\n-        // `expect` should be safe, only None with host != build, but this\n-        // only uses the `build` compiler\n-        let tarball = builder.ensure(dist::Analysis {\n-            // Find the actual compiler (handling the full bootstrap option) which\n-            // produced the save-analysis data because that data isn't copied\n-            // through the sysroot uplifting.\n-            compiler: builder.compiler_for(builder.top_stage, builder.config.build, self.target),\n-            target: self.target\n-        }).expect(\"missing analysis\");\n-        install_sh(builder, \"analysis\", self.compiler.stage, Some(self.target), &tarball);\n-    };\n     Rustc, path = \"compiler/rustc\", true, only_hosts: true, {\n         let tarball = builder.ensure(dist::Rustc {\n             compiler: builder.compiler(builder.top_stage, self.target),"}, {"sha": "d8843280b844f36755de3e45b41c4d8680ad6815", "filename": "src/doc/rustc/src/json.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -223,7 +223,6 @@ flag][option-emit] documentation.\n        - \"link\": The generated crate as specified by the crate-type.\n        - \"dep-info\": The `.d` file with dependency information in a Makefile-like syntax.\n        - \"metadata\": The Rust `.rmeta` file containing metadata about the crate.\n-       - \"save-analysis\": A JSON file emitted by the `-Zsave-analysis` feature.\n     */\n     \"emit\": \"link\"\n }"}, {"sha": "dd58a5b51fc1a1d2726b992c8bc778cfdc510191", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -164,10 +164,10 @@ impl Cfg {\n     /// Renders the configuration for human display, as a short HTML description.\n     pub(crate) fn render_short_html(&self) -> String {\n         let mut msg = Display(self, Format::ShortHtml).to_string();\n-        if self.should_capitalize_first_letter() {\n-            if let Some(i) = msg.find(|c: char| c.is_ascii_alphanumeric()) {\n-                msg[i..i + 1].make_ascii_uppercase();\n-            }\n+        if self.should_capitalize_first_letter() &&\n+            let Some(i) = msg.find(|c: char| c.is_ascii_alphanumeric())\n+        {\n+            msg[i..i + 1].make_ascii_uppercase();\n         }\n         msg\n     }"}, {"sha": "8bb8f122e2268b373de9b7a5c0f1d6d1ca355a72", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -390,18 +390,17 @@ pub(crate) fn build_impl(\n \n     // Only inline impl if the implemented trait is\n     // reachable in rustdoc generated documentation\n-    if !did.is_local() {\n-        if let Some(traitref) = associated_trait {\n-            let did = traitref.def_id;\n-            if !cx.cache.effective_visibilities.is_directly_public(tcx, did) {\n-                return;\n-            }\n+    if !did.is_local() && let Some(traitref) = associated_trait {\n+        let did = traitref.def_id;\n+        if !cx.cache.effective_visibilities.is_directly_public(tcx, did) {\n+            return;\n+        }\n \n-            if let Some(stab) = tcx.lookup_stability(did) {\n-                if stab.is_unstable() && stab.feature == sym::rustc_private {\n-                    return;\n-                }\n-            }\n+        if let Some(stab) = tcx.lookup_stability(did) &&\n+            stab.is_unstable() &&\n+            stab.feature == sym::rustc_private\n+        {\n+            return;\n         }\n     }\n \n@@ -525,10 +524,8 @@ pub(crate) fn build_impl(\n     }\n \n     while let Some(ty) = stack.pop() {\n-        if let Some(did) = ty.def_id(&cx.cache) {\n-            if tcx.is_doc_hidden(did) {\n-                return;\n-            }\n+        if let Some(did) = ty.def_id(&cx.cache) && tcx.is_doc_hidden(did) {\n+            return;\n         }\n         if let Some(generics) = ty.generics() {\n             stack.extend(generics);"}, {"sha": "65736bb16fc05e1d18ab2b6571238ced860459a7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 57, "deletions": 62, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -787,43 +787,43 @@ fn clean_ty_generics<'tcx>(\n                 None\n             })();\n \n-            if let Some(param_idx) = param_idx {\n-                if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n-                    let p: WherePredicate = clean_predicate(*p, cx)?;\n+            if let Some(param_idx) = param_idx\n+                && let Some(b) = impl_trait.get_mut(&param_idx.into())\n+            {\n+                let p: WherePredicate = clean_predicate(*p, cx)?;\n+\n+                b.extend(\n+                    p.get_bounds()\n+                        .into_iter()\n+                        .flatten()\n+                        .cloned()\n+                        .filter(|b| !b.is_sized_bound(cx)),\n+                );\n \n-                    b.extend(\n-                        p.get_bounds()\n+                let proj = projection.map(|p| {\n+                    (\n+                        clean_projection(p.map_bound(|p| p.projection_ty), cx, None),\n+                        p.map_bound(|p| p.term),\n+                    )\n+                });\n+                if let Some(((_, trait_did, name), rhs)) = proj\n+                    .as_ref()\n+                    .and_then(|(lhs, rhs): &(Type, _)| Some((lhs.projection()?, rhs)))\n+                {\n+                    // FIXME(...): Remove this unwrap()\n+                    impl_trait_proj.entry(param_idx).or_default().push((\n+                        trait_did,\n+                        name,\n+                        rhs.map_bound(|rhs| rhs.ty().unwrap()),\n+                        p.get_bound_params()\n                             .into_iter()\n                             .flatten()\n-                            .cloned()\n-                            .filter(|b| !b.is_sized_bound(cx)),\n-                    );\n-\n-                    let proj = projection.map(|p| {\n-                        (\n-                            clean_projection(p.map_bound(|p| p.projection_ty), cx, None),\n-                            p.map_bound(|p| p.term),\n-                        )\n-                    });\n-                    if let Some(((_, trait_did, name), rhs)) = proj\n-                        .as_ref()\n-                        .and_then(|(lhs, rhs): &(Type, _)| Some((lhs.projection()?, rhs)))\n-                    {\n-                        // FIXME(...): Remove this unwrap()\n-                        impl_trait_proj.entry(param_idx).or_default().push((\n-                            trait_did,\n-                            name,\n-                            rhs.map_bound(|rhs| rhs.ty().unwrap()),\n-                            p.get_bound_params()\n-                                .into_iter()\n-                                .flatten()\n-                                .map(|param| GenericParamDef::lifetime(param.0))\n-                                .collect(),\n-                        ));\n-                    }\n-\n-                    return None;\n+                            .map(|param| GenericParamDef::lifetime(param.0))\n+                            .collect(),\n+                    ));\n                 }\n+\n+                return None;\n             }\n \n             Some(p)\n@@ -886,7 +886,7 @@ fn clean_ty_generics<'tcx>(\n     // `?Sized` bound for each one we didn't find to be `Sized`.\n     for tp in &stripped_params {\n         if let types::GenericParamDefKind::Type { .. } = tp.kind\n-        && !sized_params.contains(&tp.name)\n+            && !sized_params.contains(&tp.name)\n         {\n             where_predicates.push(WherePredicate::BoundPredicate {\n                 ty: Type::Generic(tp.name),\n@@ -1461,10 +1461,10 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             // Try to normalize `<X as Y>::T` to a type\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             // `hir_to_ty` can return projection types with escaping vars for GATs, e.g. `<() as Trait>::Gat<'_>`\n-            if !ty.has_escaping_bound_vars() {\n-                if let Some(normalized_value) = normalize(cx, ty::Binder::dummy(ty)) {\n-                    return clean_middle_ty(normalized_value, cx, None);\n-                }\n+            if !ty.has_escaping_bound_vars()\n+                && let Some(normalized_value) = normalize(cx, ty::Binder::dummy(ty))\n+            {\n+                return clean_middle_ty(normalized_value, cx, None);\n             }\n \n             let trait_segments = &p.segments[..p.segments.len() - 1];\n@@ -1878,11 +1878,9 @@ fn clean_middle_opaque_bounds<'tcx>(\n                 _ => return None,\n             };\n \n-            if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n-                if trait_ref.def_id() == sized {\n-                    has_sized = true;\n-                    return None;\n-                }\n+            if let Some(sized) = cx.tcx.lang_items().sized_trait() && trait_ref.def_id() == sized {\n+                has_sized = true;\n+                return None;\n             }\n \n             let bindings: ThinVec<_> = bounds\n@@ -2392,17 +2390,15 @@ fn clean_use_statement_inner<'tcx>(\n     let is_visible_from_parent_mod =\n         visibility.is_accessible_from(parent_mod, cx.tcx) && !current_mod.is_top_level_module();\n \n-    if pub_underscore {\n-        if let Some(ref inline) = inline_attr {\n-            rustc_errors::struct_span_err!(\n-                cx.tcx.sess,\n-                inline.span(),\n-                E0780,\n-                \"anonymous imports cannot be inlined\"\n-            )\n-            .span_label(import.span, \"anonymous import\")\n-            .emit();\n-        }\n+    if pub_underscore && let Some(ref inline) = inline_attr {\n+        rustc_errors::struct_span_err!(\n+            cx.tcx.sess,\n+            inline.span(),\n+            E0780,\n+            \"anonymous imports cannot be inlined\"\n+        )\n+        .span_label(import.span, \"anonymous import\")\n+        .emit();\n     }\n \n     // We consider inlining the documentation of `pub use` statements, but we\n@@ -2438,14 +2434,13 @@ fn clean_use_statement_inner<'tcx>(\n         }\n         Import::new_glob(resolve_use_source(cx, path), true)\n     } else {\n-        if inline_attr.is_none() {\n-            if let Res::Def(DefKind::Mod, did) = path.res {\n-                if !did.is_local() && did.is_crate_root() {\n-                    // if we're `pub use`ing an extern crate root, don't inline it unless we\n-                    // were specifically asked for it\n-                    denied = true;\n-                }\n-            }\n+        if inline_attr.is_none()\n+            && let Res::Def(DefKind::Mod, did) = path.res\n+            && !did.is_local() && did.is_crate_root()\n+        {\n+            // if we're `pub use`ing an extern crate root, don't inline it unless we\n+            // were specifically asked for it\n+            denied = true;\n         }\n         if !denied {\n             let mut visited = DefIdSet::default();"}, {"sha": "fc1396e86f6b1341bb3fbe8a231d2e8b54724706", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -182,10 +182,8 @@ impl ExternalCrate {\n             return Local;\n         }\n \n-        if extern_url_takes_precedence {\n-            if let Some(url) = extern_url {\n-                return to_remote(url);\n-            }\n+        if extern_url_takes_precedence && let Some(url) = extern_url {\n+            return to_remote(url);\n         }\n \n         // Failing that, see if there's an attribute specifying where to find this\n@@ -1176,10 +1174,10 @@ impl GenericBound {\n \n     pub(crate) fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n         use rustc_hir::TraitBoundModifier as TBM;\n-        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n-            if Some(trait_.def_id()) == cx.tcx.lang_items().sized_trait() {\n-                return true;\n-            }\n+        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self &&\n+            Some(trait_.def_id()) == cx.tcx.lang_items().sized_trait()\n+        {\n+            return true;\n         }\n         false\n     }"}, {"sha": "4d8ce54dc5c62669e9b6e2d167e56de5b262275a", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -345,10 +345,10 @@ pub(crate) fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n             return true;\n         }\n \n-        if let hir::ExprKind::Unary(hir::UnOp::Neg, expr) = &expr.kind {\n-            if let hir::ExprKind::Lit(_) = &expr.kind {\n-                return true;\n-            }\n+        if let hir::ExprKind::Unary(hir::UnOp::Neg, expr) = &expr.kind &&\n+            let hir::ExprKind::Lit(_) = &expr.kind\n+        {\n+            return true;\n         }\n     }\n "}, {"sha": "0eba81c7c1ee3e0f7a2d836a41ca1ce7941b236b", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -229,11 +229,11 @@ fn scrape_test_config(attrs: &[ast::Attribute]) -> GlobalTestOptions {\n         if attr.has_name(sym::no_crate_inject) {\n             opts.no_crate_inject = true;\n         }\n-        if attr.has_name(sym::attr) {\n-            if let Some(l) = attr.meta_item_list() {\n-                for item in l {\n-                    opts.attrs.push(pprust::meta_list_item_to_string(item));\n-                }\n+        if attr.has_name(sym::attr)\n+            && let Some(l) = attr.meta_item_list()\n+        {\n+            for item in l {\n+                opts.attrs.push(pprust::meta_list_item_to_string(item));\n             }\n         }\n     }\n@@ -594,31 +594,28 @@ pub(crate) fn make_test(\n             loop {\n                 match parser.parse_item(ForceCollect::No) {\n                     Ok(Some(item)) => {\n-                        if !found_main {\n-                            if let ast::ItemKind::Fn(..) = item.kind {\n-                                if item.ident.name == sym::main {\n-                                    found_main = true;\n-                                }\n-                            }\n+                        if !found_main &&\n+                            let ast::ItemKind::Fn(..) = item.kind &&\n+                            item.ident.name == sym::main\n+                        {\n+                            found_main = true;\n                         }\n \n-                        if !found_extern_crate {\n-                            if let ast::ItemKind::ExternCrate(original) = item.kind {\n-                                // This code will never be reached if `crate_name` is none because\n-                                // `found_extern_crate` is initialized to `true` if it is none.\n-                                let crate_name = crate_name.unwrap();\n+                        if !found_extern_crate &&\n+                            let ast::ItemKind::ExternCrate(original) = item.kind\n+                        {\n+                            // This code will never be reached if `crate_name` is none because\n+                            // `found_extern_crate` is initialized to `true` if it is none.\n+                            let crate_name = crate_name.unwrap();\n \n-                                match original {\n-                                    Some(name) => found_extern_crate = name.as_str() == crate_name,\n-                                    None => found_extern_crate = item.ident.as_str() == crate_name,\n-                                }\n+                            match original {\n+                                Some(name) => found_extern_crate = name.as_str() == crate_name,\n+                                None => found_extern_crate = item.ident.as_str() == crate_name,\n                             }\n                         }\n \n-                        if !found_macro {\n-                            if let ast::ItemKind::MacCall(..) = item.kind {\n-                                found_macro = true;\n-                            }\n+                        if !found_macro && let ast::ItemKind::MacCall(..) = item.kind {\n+                            found_macro = true;\n                         }\n \n                         if found_main && found_extern_crate {\n@@ -972,14 +969,12 @@ impl Collector {\n     fn get_filename(&self) -> FileName {\n         if let Some(ref source_map) = self.source_map {\n             let filename = source_map.span_to_filename(self.position);\n-            if let FileName::Real(ref filename) = filename {\n-                if let Ok(cur_dir) = env::current_dir() {\n-                    if let Some(local_path) = filename.local_path() {\n-                        if let Ok(path) = local_path.strip_prefix(&cur_dir) {\n-                            return path.to_owned().into();\n-                        }\n-                    }\n-                }\n+            if let FileName::Real(ref filename) = filename &&\n+                let Ok(cur_dir) = env::current_dir() &&\n+                let Some(local_path) = filename.local_path() &&\n+                let Ok(path) = local_path.strip_prefix(&cur_dir)\n+            {\n+                return path.to_owned().into();\n             }\n             filename\n         } else if let Some(ref filename) = self.filename {"}, {"sha": "b1db16cfe3cacd6081854c4143289d41151f04c5", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -229,16 +229,15 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         }\n \n         // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = *item.kind {\n-            if let Some(trait_) = &i.trait_ {\n-                if !i.kind.is_blanket() {\n-                    self.cache\n-                        .implementors\n-                        .entry(trait_.def_id())\n-                        .or_default()\n-                        .push(Impl { impl_item: item.clone() });\n-                }\n-            }\n+        if let clean::ImplItem(ref i) = *item.kind &&\n+            let Some(trait_) = &i.trait_ &&\n+            !i.kind.is_blanket()\n+        {\n+            self.cache\n+                .implementors\n+                .entry(trait_.def_id())\n+                .or_default()\n+                .push(Impl { impl_item: item.clone() });\n         }\n \n         // Index this method for searching later on."}, {"sha": "452e14918faf7a2fe0696d990381f7b697833c81", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -140,7 +140,7 @@ impl From<DefKind> for ItemType {\n             | DefKind::Field\n             | DefKind::LifetimeParam\n             | DefKind::GlobalAsm\n-            | DefKind::Impl\n+            | DefKind::Impl { .. }\n             | DefKind::Closure\n             | DefKind::Generator => Self::ForeignType,\n         }"}, {"sha": "1ed0b0bc2d558eec00c7b93f7fbbc10226d4d216", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -710,11 +710,9 @@ pub(crate) fn href_with_root_path(\n             }\n         }\n     };\n-    if !is_remote {\n-        if let Some(root_path) = root_path {\n-            let root = root_path.trim_end_matches('/');\n-            url_parts.push_front(root);\n-        }\n+    if !is_remote && let Some(root_path) = root_path {\n+        let root = root_path.trim_end_matches('/');\n+        url_parts.push_front(root);\n     }\n     debug!(?url_parts);\n     match shortty {"}, {"sha": "2c9fc4e3ca37824f4455dc47f397bc1e8f79525c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -466,10 +466,8 @@ impl<'a> PeekIter<'a> {\n     }\n     /// Returns the next item after the current one. It doesn't interfere with `peek_next` output.\n     fn peek(&mut self) -> Option<&(TokenKind, &'a str)> {\n-        if self.stored.is_empty() {\n-            if let Some(next) = self.iter.next() {\n-                self.stored.push_back(next);\n-            }\n+        if self.stored.is_empty() && let Some(next) = self.iter.next() {\n+            self.stored.push_back(next);\n         }\n         self.stored.front()\n     }"}, {"sha": "5e4a595627b4a367385ca479c30f8257cdf3579e", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -705,14 +705,12 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             shared.fs.write(scrape_examples_help_file, v)?;\n         }\n \n-        if let Some(ref redirections) = shared.redirections {\n-            if !redirections.borrow().is_empty() {\n-                let redirect_map_path =\n-                    self.dst.join(crate_name.as_str()).join(\"redirect-map.json\");\n-                let paths = serde_json::to_string(&*redirections.borrow()).unwrap();\n-                shared.ensure_dir(&self.dst.join(crate_name.as_str()))?;\n-                shared.fs.write(redirect_map_path, paths)?;\n-            }\n+        if let Some(ref redirections) = shared.redirections && !redirections.borrow().is_empty() {\n+            let redirect_map_path =\n+                self.dst.join(crate_name.as_str()).join(\"redirect-map.json\");\n+            let paths = serde_json::to_string(&*redirections.borrow()).unwrap();\n+            shared.ensure_dir(&self.dst.join(crate_name.as_str()))?;\n+            shared.fs.write(redirect_map_path, paths)?;\n         }\n \n         // No need for it anymore."}, {"sha": "e6a040d02e565b464792ba16784b377367ae42ea", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -2225,14 +2225,13 @@ fn sidebar_deref_methods(\n         })\n     {\n         debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n-        if let Some(did) = target.def_id(c) {\n-            if let Some(type_did) = impl_.inner_impl().for_.def_id(c) {\n-                // `impl Deref<Target = S> for S`\n-                if did == type_did || !derefs.insert(did) {\n-                    // Avoid infinite cycles\n-                    return;\n-                }\n-            }\n+        if let Some(did) = target.def_id(c) &&\n+            let Some(type_did) = impl_.inner_impl().for_.def_id(c) &&\n+            // `impl Deref<Target = S> for S`\n+            (did == type_did || !derefs.insert(did))\n+        {\n+            // Avoid infinite cycles\n+            return;\n         }\n         let deref_mut = v.iter().any(|i| i.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n         let inner_impl = target\n@@ -2266,25 +2265,24 @@ fn sidebar_deref_methods(\n         }\n \n         // Recurse into any further impls that might exist for `target`\n-        if let Some(target_did) = target.def_id(c) {\n-            if let Some(target_impls) = c.impls.get(&target_did) {\n-                if let Some(target_deref_impl) = target_impls.iter().find(|i| {\n-                    i.inner_impl()\n-                        .trait_\n-                        .as_ref()\n-                        .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n-                        .unwrap_or(false)\n-                }) {\n-                    sidebar_deref_methods(\n-                        cx,\n-                        out,\n-                        target_deref_impl,\n-                        target_impls,\n-                        derefs,\n-                        used_links,\n-                    );\n-                }\n-            }\n+        if let Some(target_did) = target.def_id(c) &&\n+            let Some(target_impls) = c.impls.get(&target_did) &&\n+            let Some(target_deref_impl) = target_impls.iter().find(|i| {\n+                i.inner_impl()\n+                    .trait_\n+                    .as_ref()\n+                    .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n+                    .unwrap_or(false)\n+            })\n+        {\n+            sidebar_deref_methods(\n+                cx,\n+                out,\n+                target_deref_impl,\n+                target_impls,\n+                derefs,\n+                used_links,\n+            );\n         }\n     }\n }"}, {"sha": "e3788fe57d013d8eb06fc50a963272055266da59", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -80,12 +80,11 @@ impl<'tcx> JsonRenderer<'tcx> {\n                         // document primitive items in an arbitrary crate by using\n                         // `doc(primitive)`.\n                         let mut is_primitive_impl = false;\n-                        if let clean::types::ItemKind::ImplItem(ref impl_) = *item.kind {\n-                            if impl_.trait_.is_none() {\n-                                if let clean::types::Type::Primitive(_) = impl_.for_ {\n-                                    is_primitive_impl = true;\n-                                }\n-                            }\n+                        if let clean::types::ItemKind::ImplItem(ref impl_) = *item.kind &&\n+                            impl_.trait_.is_none() &&\n+                            let clean::types::Type::Primitive(_) = impl_.for_\n+                        {\n+                            is_primitive_impl = true;\n                         }\n \n                         if item.item_id.is_local() || is_primitive_impl {"}, {"sha": "a39d57d42b72e1910b9ea2c61e31b51039cca559", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -82,18 +82,17 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n     let def_id = item.item_id.expect_def_id().expect_local();\n \n     // check if parent is trait impl\n-    if let Some(parent_def_id) = cx.tcx.opt_local_parent(def_id) {\n-        if let Some(parent_node) = cx.tcx.hir().find_by_def_id(parent_def_id) {\n-            if matches!(\n-                parent_node,\n-                hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }),\n-                    ..\n-                })\n-            ) {\n-                return false;\n-            }\n-        }\n+    if let Some(parent_def_id) = cx.tcx.opt_local_parent(def_id) &&\n+        let Some(parent_node) = cx.tcx.hir().find_by_def_id(parent_def_id) &&\n+        matches!(\n+            parent_node,\n+            hir::Node::Item(hir::Item {\n+                kind: hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }),\n+                ..\n+            })\n+        )\n+    {\n+        return false;\n     }\n \n     if cx.tcx.is_doc_hidden(def_id.to_def_id())"}, {"sha": "b2208da9060dcd0c0db38207c3203718d1f19ec1", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -359,7 +359,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 _ => def_id,\n             })\n             .and_then(|self_id| match tcx.def_kind(self_id) {\n-                DefKind::Impl => self.def_id_to_res(self_id),\n+                DefKind::Impl { .. } => self.def_id_to_res(self_id),\n                 DefKind::Use => None,\n                 def_kind => Some(Res::Def(def_kind, self_id)),\n             })\n@@ -1761,7 +1761,7 @@ fn resolution_failure(\n                             }\n                             Trait | TyAlias | ForeignTy | OpaqueTy | ImplTraitPlaceholder\n                             | TraitAlias | TyParam | Static(_) => \"associated item\",\n-                            Impl | GlobalAsm => unreachable!(\"not a path\"),\n+                            Impl { .. } | GlobalAsm => unreachable!(\"not a path\"),\n                         }\n                     } else {\n                         \"associated item\""}, {"sha": "189b37b69d132db3785e4cfcd1dbb6ea7c9ec0cf", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -156,39 +156,38 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in new_items_external.iter().chain(new_items_local.iter()) {\n-        if let ImplItem(box Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n-            if trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n-                && cleaner.keep_impl(for_, true)\n-            {\n-                let target = items\n-                    .iter()\n-                    .find_map(|item| match *item.kind {\n-                        AssocTypeItem(ref t, _) => Some(&t.type_),\n-                        _ => None,\n-                    })\n-                    .expect(\"Deref impl without Target type\");\n+        if let ImplItem(box Impl { ref for_, ref trait_, ref items, .. }) = *it.kind &&\n+            trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait() &&\n+            cleaner.keep_impl(for_, true)\n+        {\n+            let target = items\n+                .iter()\n+                .find_map(|item| match *item.kind {\n+                    AssocTypeItem(ref t, _) => Some(&t.type_),\n+                    _ => None,\n+                })\n+                .expect(\"Deref impl without Target type\");\n \n-                if let Some(prim) = target.primitive_type() {\n-                    cleaner.prims.insert(prim);\n-                } else if let Some(did) = target.def_id(&cx.cache) {\n-                    cleaner.items.insert(did.into());\n-                }\n-                if let Some(for_did) = for_.def_id(&cx.cache) {\n-                    if type_did_to_deref_target.insert(for_did, target).is_none() {\n-                        // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n-                        // `Deref` target type and the impl for type positions, this map of types is keyed by\n-                        // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n-                        if cleaner.keep_impl_with_def_id(for_did.into()) {\n-                            let mut targets = DefIdSet::default();\n-                            targets.insert(for_did);\n-                            add_deref_target(\n-                                cx,\n-                                &type_did_to_deref_target,\n-                                &mut cleaner,\n-                                &mut targets,\n-                                for_did,\n-                            );\n-                        }\n+            if let Some(prim) = target.primitive_type() {\n+                cleaner.prims.insert(prim);\n+            } else if let Some(did) = target.def_id(&cx.cache) {\n+                cleaner.items.insert(did.into());\n+            }\n+            if let Some(for_did) = for_.def_id(&cx.cache) {\n+                if type_did_to_deref_target.insert(for_did, target).is_none() {\n+                    // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n+                    // `Deref` target type and the impl for type positions, this map of types is keyed by\n+                    // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n+                    if cleaner.keep_impl_with_def_id(for_did.into()) {\n+                        let mut targets = DefIdSet::default();\n+                        targets.insert(for_did);\n+                        add_deref_target(\n+                            cx,\n+                            &type_did_to_deref_target,\n+                            &mut cleaner,\n+                            &mut targets,\n+                            for_did,\n+                        );\n                     }\n                 }\n             }"}, {"sha": "eac362b37b20988d60a1fa17c5db65199e834ee9", "filename": "src/librustdoc/passes/lint/html_tags.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -210,11 +210,9 @@ fn extract_path_backwards(text: &str, end_pos: usize) -> Option<usize> {\n             .take_while(|(_, c)| is_id_start(*c) || is_id_continue(*c))\n             .reduce(|_accum, item| item)\n             .and_then(|(new_pos, c)| is_id_start(c).then_some(new_pos));\n-        if let Some(new_pos) = new_pos {\n-            if current_pos != new_pos {\n-                current_pos = new_pos;\n-                continue;\n-            }\n+        if let Some(new_pos) = new_pos && current_pos != new_pos {\n+            current_pos = new_pos;\n+            continue;\n         }\n         break;\n     }"}, {"sha": "cba55e5fe655c7eb19c2a12266b190ec4f7ec6d0", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -201,27 +201,25 @@ impl<'a> DocFolder for ImplStripper<'a, '_> {\n             // Because we don't inline in `maybe_inline_local` if the output format is JSON,\n             // we need to make a special check for JSON output: we want to keep it unless it has\n             // a `#[doc(hidden)]` attribute if the `for_` type is exported.\n-            if let Some(did) = imp.for_.def_id(self.cache) {\n-                if !imp.for_.is_assoc_ty() && !self.should_keep_impl(&i, did) {\n-                    debug!(\"ImplStripper: impl item for stripped type; removing\");\n-                    return None;\n-                }\n+            if let Some(did) = imp.for_.def_id(self.cache) &&\n+                !imp.for_.is_assoc_ty() && !self.should_keep_impl(&i, did)\n+            {\n+                debug!(\"ImplStripper: impl item for stripped type; removing\");\n+                return None;\n             }\n-            if let Some(did) = imp.trait_.as_ref().map(|t| t.def_id()) {\n-                if !self.should_keep_impl(&i, did) {\n-                    debug!(\"ImplStripper: impl item for stripped trait; removing\");\n-                    return None;\n-                }\n+            if let Some(did) = imp.trait_.as_ref().map(|t| t.def_id()) &&\n+                !self.should_keep_impl(&i, did) {\n+                debug!(\"ImplStripper: impl item for stripped trait; removing\");\n+                return None;\n             }\n             if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n                 for typaram in generics {\n-                    if let Some(did) = typaram.def_id(self.cache) {\n-                        if !self.should_keep_impl(&i, did) {\n-                            debug!(\n-                                \"ImplStripper: stripped item in trait's generics; removing impl\"\n-                            );\n-                            return None;\n-                        }\n+                    if let Some(did) = typaram.def_id(self.cache) && !self.should_keep_impl(&i, did)\n+                    {\n+                        debug!(\n+                            \"ImplStripper: stripped item in trait's generics; removing impl\"\n+                        );\n+                        return None;\n                     }\n                 }\n             }"}, {"sha": "4dc750c03b488d1a80cd5e66a33e4b09a9dcba18", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let ty::Array(element_type, cst) = ty.kind();\n             if let ConstKind::Value(ty::ValTree::Leaf(element_count)) = cst.kind();\n-            if let Ok(element_count) = element_count.try_to_machine_usize(cx.tcx);\n+            if let Ok(element_count) = element_count.try_to_target_usize(cx.tcx);\n             if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < u128::from(element_count) * u128::from(element_size);\n "}, {"sha": "32c6312e06946a1180235d3de00db25ebff23a8c", "filename": "src/tools/clippy/clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -41,7 +41,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n         if let ExprKind::Repeat(_, _) = expr.kind\n           && let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind()\n           && let ConstKind::Value(ty::ValTree::Leaf(element_count)) = cst.kind()\n-          && let Ok(element_count) = element_count.try_to_machine_usize(cx.tcx)\n+          && let Ok(element_count) = element_count.try_to_target_usize(cx.tcx)\n           && let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes())\n           && !cx.tcx.hir().parent_iter(expr.hir_id)\n               .any(|(_, node)| matches!(node, Node::Item(Item { kind: ItemKind::Static(..), .. })))"}, {"sha": "a37e2772d35584b52f2a7e18b29c37a1e00e241c", "filename": "src/tools/clippy/clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n         let mut map = FxHashMap::<Res, ExistingName>::default();\n \n         for id in cx.tcx.hir().items() {\n-            if matches!(cx.tcx.def_kind(id.owner_id), DefKind::Impl)\n+            if matches!(cx.tcx.def_kind(id.owner_id), DefKind::Impl { .. })\n                 && let item = cx.tcx.hir().item(id)\n                 && let ItemKind::Impl(Impl {\n                   items,"}, {"sha": "8b00ce2cc258632bed3ee8259c169a86870e2ec4", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -640,7 +640,7 @@ pub fn miri_to_const<'tcx>(tcx: TyCtxt<'tcx>, result: mir::ConstantKind<'tcx>) -\n         },\n         mir::ConstantKind::Val(ConstValue::ByRef { alloc, offset: _ }, _) => match result.ty().kind() {\n             ty::Array(sub_type, len) => match sub_type.kind() {\n-                ty::Float(FloatTy::F32) => match len.kind().try_to_machine_usize(tcx) {\n+                ty::Float(FloatTy::F32) => match len.kind().try_to_target_usize(tcx) {\n                     Some(len) => alloc\n                         .inner()\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * usize::try_from(len).unwrap()))\n@@ -651,7 +651,7 @@ pub fn miri_to_const<'tcx>(tcx: TyCtxt<'tcx>, result: mir::ConstantKind<'tcx>) -\n                         .map(Constant::Vec),\n                     _ => None,\n                 },\n-                ty::Float(FloatTy::F64) => match len.kind().try_to_machine_usize(tcx) {\n+                ty::Float(FloatTy::F64) => match len.kind().try_to_target_usize(tcx) {\n                     Some(len) => alloc\n                         .inner()\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * usize::try_from(len).unwrap()))"}, {"sha": "3b8713e2b108cabb356f84dcae45de26d85f2ad9", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -552,7 +552,7 @@ fn non_local_item_children_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: Symbol)\n             .filter(|item| item.ident.name == name)\n             .map(|child| child.res.expect_non_local())\n             .collect(),\n-        DefKind::Impl => tcx\n+        DefKind::Impl { .. } => tcx\n             .associated_item_def_ids(def_id)\n             .iter()\n             .copied()"}, {"sha": "b766916402e4f5689c7dbb75eb1ad40fb52f2b6e", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -717,7 +717,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             throw_ub!(PointerOutOfBounds {\n                 alloc_id,\n                 alloc_size,\n-                ptr_offset: this.machine_usize_to_isize(base_offset.bytes()),\n+                ptr_offset: this.target_usize_to_isize(base_offset.bytes()),\n                 ptr_size: size,\n                 msg: CheckInAllocMsg::InboundsTest\n             });"}, {"sha": "d61e17cbf9a4aee3de02fabb8917b71baef32e19", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -236,7 +236,7 @@ impl MainThreadState {\n                     this.machine.main_fn_ret_place.unwrap().ptr,\n                     this.machine.layouts.isize,\n                 );\n-                let exit_code = this.read_machine_isize(&ret_place.into())?;\n+                let exit_code = this.read_target_isize(&ret_place.into())?;\n                 // Need to call this ourselves since we are not going to return to the scheduler\n                 // loop, and we want the main thread TLS to not show up as memory leaks.\n                 this.terminate_active_thread()?;\n@@ -287,7 +287,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     // First argument is constructed later, because it's skipped if the entry function uses #[start].\n \n     // Second argument (argc): length of `config.args`.\n-    let argc = Scalar::from_machine_usize(u64::try_from(config.args.len()).unwrap(), &ecx);\n+    let argc = Scalar::from_target_usize(u64::try_from(config.args.len()).unwrap(), &ecx);\n     // Third argument (`argv`): created from `config.args`.\n     let argv = {\n         // Put each argument in memory, collect pointers."}, {"sha": "5286023e0f64e0174e22c1dfb4f64288e2be77ad", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -758,10 +758,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let seconds_place = this.mplace_field(tp, 0)?;\n         let seconds_scalar = this.read_scalar(&seconds_place.into())?;\n-        let seconds = seconds_scalar.to_machine_isize(this)?;\n+        let seconds = seconds_scalar.to_target_isize(this)?;\n         let nanoseconds_place = this.mplace_field(tp, 1)?;\n         let nanoseconds_scalar = this.read_scalar(&nanoseconds_place.into())?;\n-        let nanoseconds = nanoseconds_scalar.to_machine_isize(this)?;\n+        let nanoseconds = nanoseconds_scalar.to_target_isize(this)?;\n \n         Ok(try {\n             // tv_sec must be non-negative."}, {"sha": "2ba18293121dcaa3bb7c11a875953b1b86f0ff6e", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -207,7 +207,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n                     .checked_add(max(size.bytes(), 1))\n                     .ok_or_else(|| err_exhaust!(AddressSpaceFull))?;\n                 // Even if `Size` didn't overflow, we might still have filled up the address space.\n-                if global_state.next_base_addr > ecx.machine_usize_max() {\n+                if global_state.next_base_addr > ecx.target_usize_max() {\n                     throw_exhaust!(AddressSpaceFull);\n                 }\n                 // Given that `next_base_addr` increases in each allocation, pushing the"}, {"sha": "79d5dfb5551bd47a72425068cb495c490a28c8be", "filename": "src/tools/miri/src/operator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -56,7 +56,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriInterpCx<'mir, 'tcx> {\n             Offset => {\n                 assert!(left.layout.ty.is_unsafe_ptr());\n                 let ptr = left.to_scalar().to_pointer(self)?;\n-                let offset = right.to_scalar().to_machine_isize(self)?;\n+                let offset = right.to_scalar().to_target_isize(self)?;\n \n                 let pointee_ty =\n                     left.layout.ty.builtin_deref(true).expect(\"Offset called on non-ptr type\").ty;\n@@ -73,14 +73,14 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriInterpCx<'mir, 'tcx> {\n                 // We do the actual operation with usize-typed scalars.\n                 let left = ImmTy::from_uint(ptr.addr().bytes(), self.machine.layouts.usize);\n                 let right = ImmTy::from_uint(\n-                    right.to_scalar().to_machine_usize(self)?,\n+                    right.to_scalar().to_target_usize(self)?,\n                     self.machine.layouts.usize,\n                 );\n                 let (result, overflowing, _ty) =\n                     self.overflowing_binary_op(bin_op, &left, &right)?;\n                 // Construct a new pointer with the provenance of `ptr` (the LHS).\n                 let result_ptr =\n-                    Pointer::new(ptr.provenance, Size::from_bytes(result.to_machine_usize(self)?));\n+                    Pointer::new(ptr.provenance, Size::from_bytes(result.to_target_usize(self)?));\n                 (Scalar::from_maybe_pointer(result_ptr, self), overflowing, left.layout.ty)\n             }\n "}, {"sha": "1e4ab2f0f622730109c28c5ccec807c646ef62fb", "filename": "src/tools/miri/src/shims/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -24,7 +24,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let frame_count = this.active_thread_stack().len();\n \n-        this.write_scalar(Scalar::from_machine_usize(frame_count.try_into().unwrap(), this), dest)\n+        this.write_scalar(Scalar::from_target_usize(frame_count.try_into().unwrap(), this), dest)\n     }\n \n     fn handle_miri_get_backtrace(\n@@ -205,11 +205,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n             1 => {\n                 this.write_scalar(\n-                    Scalar::from_machine_usize(name.len().try_into().unwrap(), this),\n+                    Scalar::from_target_usize(name.len().try_into().unwrap(), this),\n                     &this.mplace_field(&dest, 0)?.into(),\n                 )?;\n                 this.write_scalar(\n-                    Scalar::from_machine_usize(filename.len().try_into().unwrap(), this),\n+                    Scalar::from_target_usize(filename.len().try_into().unwrap(), this),\n                     &this.mplace_field(&dest, 1)?.into(),\n                 )?;\n             }"}, {"sha": "f50c135435fd778713745547338c39baf6d69530", "filename": "src/tools/miri/src/shims/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -323,7 +323,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.assert_target_os_is_unix(\"getcwd\");\n \n         let buf = this.read_pointer(buf_op)?;\n-        let size = this.read_machine_usize(size_op)?;\n+        let size = this.read_target_usize(size_op)?;\n \n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`getcwd`\", reject_with)?;"}, {"sha": "e628c44a86788697d70a2911364628166fb19655", "filename": "src/tools/miri/src/shims/ffi_support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fffi_support.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -36,7 +36,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             ty::Int(IntTy::Isize) => {\n                 // This will fail if host != target, but then the entire FFI thing probably won't work well\n                 // in that situation.\n-                return Ok(CArg::ISize(k.to_machine_isize(cx)?.try_into().unwrap()));\n+                return Ok(CArg::ISize(k.to_target_isize(cx)?.try_into().unwrap()));\n             }\n             // the uints\n             ty::Uint(UintTy::U8) => {\n@@ -54,7 +54,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             ty::Uint(UintTy::Usize) => {\n                 // This will fail if host != target, but then the entire FFI thing probably won't work well\n                 // in that situation.\n-                return Ok(CArg::USize(k.to_machine_usize(cx)?.try_into().unwrap()));\n+                return Ok(CArg::USize(k.to_target_usize(cx)?.try_into().unwrap()));\n             }\n             _ => {}\n         }"}, {"sha": "2d9eb37a2580672c442241150276505535bce3c5", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -449,7 +449,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [ptr, out, out_size] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let out = this.read_pointer(out)?;\n-                let out_size = this.read_scalar(out_size)?.to_machine_usize(this)?;\n+                let out_size = this.read_scalar(out_size)?.to_target_usize(this)?;\n \n                 // The host affects program behavior here, so this requires isolation to be disabled.\n                 this.check_no_isolation(\"`miri_host_to_target_path`\")?;\n@@ -490,7 +490,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [bytes] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let (ptr, len) = this.read_immediate(bytes)?.to_scalar_pair();\n                 let ptr = ptr.to_pointer(this)?;\n-                let len = len.to_machine_usize(this)?;\n+                let len = len.to_target_usize(this)?;\n                 let msg = this.read_bytes_ptr_strip_provenance(ptr, Size::from_bytes(len))?;\n \n                 // Note: we're ignoring errors writing to host stdout/stderr.\n@@ -504,15 +504,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             // Standard C allocation\n             \"malloc\" => {\n                 let [size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let size = this.read_machine_usize(size)?;\n+                let size = this.read_target_usize(size)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C)?;\n                 this.write_pointer(res, dest)?;\n             }\n             \"calloc\" => {\n                 let [items, len] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let items = this.read_machine_usize(items)?;\n-                let len = this.read_machine_usize(len)?;\n+                let items = this.read_target_usize(items)?;\n+                let len = this.read_target_usize(len)?;\n                 let size = items\n                     .checked_mul(len)\n                     .ok_or_else(|| err_ub_format!(\"overflow during calloc size computation\"))?;\n@@ -528,16 +528,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [old_ptr, new_size] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let old_ptr = this.read_pointer(old_ptr)?;\n-                let new_size = this.read_machine_usize(new_size)?;\n+                let new_size = this.read_target_usize(new_size)?;\n                 let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n                 this.write_pointer(res, dest)?;\n             }\n \n             // Rust allocation\n             \"__rust_alloc\" | \"miri_alloc\" => {\n                 let [size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n-                let size = this.read_machine_usize(size)?;\n-                let align = this.read_machine_usize(align)?;\n+                let size = this.read_target_usize(size)?;\n+                let align = this.read_target_usize(align)?;\n \n                 let default = |this: &mut MiriInterpCx<'mir, 'tcx>| {\n                     Self::check_alloc_request(size, align)?;\n@@ -569,8 +569,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n             \"__rust_alloc_zeroed\" => {\n                 let [size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n-                let size = this.read_machine_usize(size)?;\n-                let align = this.read_machine_usize(align)?;\n+                let size = this.read_target_usize(size)?;\n+                let align = this.read_target_usize(align)?;\n \n                 return this.emulate_allocator(Symbol::intern(\"__rg_alloc_zeroed\"), |this| {\n                     Self::check_alloc_request(size, align)?;\n@@ -593,8 +593,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"__rust_dealloc\" | \"miri_dealloc\" => {\n                 let [ptr, old_size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n-                let old_size = this.read_machine_usize(old_size)?;\n-                let align = this.read_machine_usize(align)?;\n+                let old_size = this.read_target_usize(old_size)?;\n+                let align = this.read_target_usize(align)?;\n \n                 let default = |this: &mut MiriInterpCx<'mir, 'tcx>| {\n                     let memory_kind = match link_name.as_str() {\n@@ -625,9 +625,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [ptr, old_size, align, new_size] =\n                     this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n-                let old_size = this.read_machine_usize(old_size)?;\n-                let align = this.read_machine_usize(align)?;\n-                let new_size = this.read_machine_usize(new_size)?;\n+                let old_size = this.read_target_usize(old_size)?;\n+                let align = this.read_target_usize(align)?;\n+                let new_size = this.read_target_usize(new_size)?;\n                 // No need to check old_size; we anyway check that they match the allocation.\n \n                 return this.emulate_allocator(Symbol::intern(\"__rg_realloc\"), |this| {\n@@ -651,7 +651,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let left = this.read_pointer(left)?;\n                 let right = this.read_pointer(right)?;\n-                let n = Size::from_bytes(this.read_machine_usize(n)?);\n+                let n = Size::from_bytes(this.read_target_usize(n)?);\n \n                 let result = {\n                     let left_bytes = this.read_bytes_ptr_strip_provenance(left, n)?;\n@@ -672,7 +672,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let val = this.read_scalar(val)?.to_i32()?;\n-                let num = this.read_machine_usize(num)?;\n+                let num = this.read_target_usize(num)?;\n                 // The docs say val is \"interpreted as unsigned char\".\n                 #[allow(clippy::cast_sign_loss, clippy::cast_possible_truncation)]\n                 let val = val as u8;\n@@ -696,7 +696,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let val = this.read_scalar(val)?.to_i32()?;\n-                let num = this.read_machine_usize(num)?;\n+                let num = this.read_target_usize(num)?;\n                 // The docs say val is \"interpreted as unsigned char\".\n                 #[allow(clippy::cast_sign_loss, clippy::cast_possible_truncation)]\n                 let val = val as u8;\n@@ -717,7 +717,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let ptr = this.read_pointer(ptr)?;\n                 let n = this.read_c_str(ptr)?.len();\n                 this.write_scalar(\n-                    Scalar::from_machine_usize(u64::try_from(n).unwrap(), this),\n+                    Scalar::from_target_usize(u64::try_from(n).unwrap(), this),\n                     dest,\n                 )?;\n             }"}, {"sha": "d21a1560699c24f0ddd9806022e3f919aef0ed3e", "filename": "src/tools/miri/src/shims/intrinsics/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -111,8 +111,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let ty_layout = this.layout_of(ty)?;\n                 let val_byte = this.read_scalar(val_byte)?.to_u8()?;\n                 let ptr = this.read_pointer(ptr)?;\n-                let count = this.read_machine_usize(count)?;\n-                // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+                let count = this.read_target_usize(count)?;\n+                // `checked_mul` enforces a too small bound (the correct one would probably be target_isize_max),\n                 // but no actual allocation can be big enough for the difference to be noticeable.\n                 let byte_count = ty_layout.size.checked_mul(count, this).ok_or_else(|| {\n                     err_ub_format!(\"overflow computing total size of `{intrinsic_name}`\")\n@@ -124,7 +124,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [ptr, mask] = check_arg_count(args)?;\n \n                 let ptr = this.read_pointer(ptr)?;\n-                let mask = this.read_machine_usize(mask)?;\n+                let mask = this.read_target_usize(mask)?;\n \n                 let masked_addr = Size::from_bytes(ptr.addr().bytes() & mask);\n "}, {"sha": "f2e16521290fe98e8fdd397f14a15eb7e670eb73", "filename": "src/tools/miri/src/shims/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -202,7 +202,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                         }\n                         Op::WrappingOffset => {\n                             let ptr = left.to_scalar().to_pointer(this)?;\n-                            let offset_count = right.to_scalar().to_machine_isize(this)?;\n+                            let offset_count = right.to_scalar().to_target_isize(this)?;\n                             let pointee_ty = left.layout.ty.builtin_deref(true).unwrap().ty;\n \n                             let pointee_size = i64::try_from(this.layout_of(pointee_ty)?.size.bytes()).unwrap();"}, {"sha": "dbc48876a4b0651c2a8e14534ec5a64b4d9a3bf9", "filename": "src/tools/miri/src/shims/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fmod.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -80,7 +80,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             return Ok(false);\n         }\n \n-        let req_align = this.read_machine_usize(align_op)?;\n+        let req_align = this.read_target_usize(align_op)?;\n \n         // Stop if the alignment is not a power of two.\n         if !req_align.is_power_of_two() {\n@@ -106,7 +106,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         // Return error result (usize::MAX), and jump to caller.\n-        this.write_scalar(Scalar::from_machine_usize(this.machine_usize_max(), this), dest)?;\n+        this.write_scalar(Scalar::from_target_usize(this.target_usize_max(), this), dest)?;\n         this.go_to_block(ret);\n         Ok(true)\n     }"}, {"sha": "e9119f9e1eced337bee74b36c0f743e258686161", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -108,7 +108,7 @@ impl<'tcx> TlsData<'tcx> {\n     ) -> InterpResult<'tcx> {\n         match self.keys.get_mut(&key) {\n             Some(TlsEntry { data, .. }) => {\n-                if new_data.to_machine_usize(cx)? != 0 {\n+                if new_data.to_target_usize(cx)? != 0 {\n                     trace!(\"TLS key {} for thread {:?} stored: {:?}\", key, thread_id, new_data);\n                     data.insert(thread_id, new_data);\n                 } else {\n@@ -356,7 +356,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             state.last_key = Some(key);\n             trace!(\"Running TLS dtor {:?} on {:?} at {:?}\", instance, ptr, active_thread);\n             assert!(\n-                !ptr.to_machine_usize(this).unwrap() != 0,\n+                !ptr.to_target_usize(this).unwrap() != 0,\n                 \"data can't be NULL when dtor is called!\"\n             );\n "}, {"sha": "c371e85c312e8ff0f6f7d1051d9f83e6c9a06276", "filename": "src/tools/miri/src/shims/unix/foreign_items.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -78,19 +78,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [fd, buf, count] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_pointer(buf)?;\n-                let count = this.read_machine_usize(count)?;\n+                let count = this.read_target_usize(count)?;\n                 let result = this.read(fd, buf, count)?;\n-                this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(result, this), dest)?;\n             }\n             \"write\" => {\n                 let [fd, buf, n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_pointer(buf)?;\n-                let count = this.read_machine_usize(n)?;\n+                let count = this.read_target_usize(n)?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, count);\n                 let result = this.write(fd, buf, count)?;\n                 // Now, `result` is the value we return back to the program.\n-                this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(result, this), dest)?;\n             }\n             \"unlink\" => {\n                 let [path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n@@ -151,14 +151,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"readlink\" => {\n                 let [pathname, buf, bufsize] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.readlink(pathname, buf, bufsize)?;\n-                this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(result, this), dest)?;\n             }\n             \"posix_fadvise\" => {\n                 let [fd, offset, len, advice] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n-                this.read_machine_isize(offset)?;\n-                this.read_machine_isize(len)?;\n+                this.read_target_isize(offset)?;\n+                this.read_target_isize(len)?;\n                 this.read_scalar(advice)?.to_i32()?;\n                 // fadvise is only informational, we can ignore it.\n                 this.write_null(dest)?;\n@@ -191,8 +191,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"posix_memalign\" => {\n                 let [ret, align, size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ret = this.deref_operand(ret)?;\n-                let align = this.read_machine_usize(align)?;\n-                let size = this.read_machine_usize(size)?;\n+                let align = this.read_target_usize(align)?;\n+                let size = this.read_target_usize(size)?;\n                 // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n                 // But failure to adhere to this is not UB, it's an error condition.\n                 if !align.is_power_of_two() || align < this.pointer_size().bytes() {\n@@ -216,7 +216,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             // Dynamic symbol loading\n             \"dlsym\" => {\n                 let [handle, symbol] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                this.read_machine_usize(handle)?;\n+                this.read_target_usize(handle)?;\n                 let symbol = this.read_pointer(symbol)?;\n                 let symbol_name = this.read_c_str(symbol)?;\n                 if let Some(dlsym) = Dlsym::from_str(symbol_name, &this.tcx.sess.target.os)? {\n@@ -472,7 +472,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [errnum, buf, buflen] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errnum = this.read_scalar(errnum)?;\n                 let buf = this.read_pointer(buf)?;\n-                let buflen = this.read_machine_usize(buflen)?;\n+                let buflen = this.read_target_usize(buflen)?;\n \n                 let error = this.try_errnum_to_io_error(errnum)?;\n                 let formatted = match error {\n@@ -565,7 +565,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let uid = this.read_scalar(uid)?.to_u32()?;\n                 let pwd = this.deref_operand(pwd)?;\n                 let buf = this.read_pointer(buf)?;\n-                let buflen = this.read_machine_usize(buflen)?;\n+                let buflen = this.read_target_usize(buflen)?;\n                 let result = this.deref_operand(result)?;\n \n                 // Must be for \"us\"."}, {"sha": "d05c4d98fad6fd0b315f5d3c1556b7ee850e3f2c", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -754,7 +754,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // We cap the number of read bytes to the largest value that we are able to fit in both the\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count\n-            .min(u64::try_from(this.machine_isize_max()).unwrap())\n+            .min(u64::try_from(this.target_isize_max()).unwrap())\n             .min(u64::try_from(isize::MAX).unwrap());\n         let communicate = this.machine.communicate();\n \n@@ -807,7 +807,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // We cap the number of written bytes to the largest value that we are able to fit in both the\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count\n-            .min(u64::try_from(this.machine_isize_max()).unwrap())\n+            .min(u64::try_from(this.target_isize_max()).unwrap())\n             .min(u64::try_from(isize::MAX).unwrap());\n         let communicate = this.machine.communicate();\n \n@@ -1290,7 +1290,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // The libc API for opendir says that this method returns a pointer to an opaque\n                 // structure, but we are returning an ID number. Thus, pass it as a scalar of\n                 // pointer width.\n-                Ok(Scalar::from_machine_usize(id, this))\n+                Ok(Scalar::from_target_usize(id, this))\n             }\n             Err(e) => {\n                 this.set_last_error_from_io_error(e.kind())?;\n@@ -1307,7 +1307,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         this.assert_target_os(\"linux\", \"readdir64\");\n \n-        let dirp = this.read_machine_usize(dirp_op)?;\n+        let dirp = this.read_target_usize(dirp_op)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n@@ -1399,7 +1399,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         this.assert_target_os(\"macos\", \"readdir_r\");\n \n-        let dirp = this.read_machine_usize(dirp_op)?;\n+        let dirp = this.read_target_usize(dirp_op)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n@@ -1492,7 +1492,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn closedir(&mut self, dirp_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let dirp = this.read_machine_usize(dirp_op)?;\n+        let dirp = this.read_target_usize(dirp_op)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n@@ -1656,7 +1656,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let pathname = this.read_path_from_c_str(this.read_pointer(pathname_op)?)?;\n         let buf = this.read_pointer(buf_op)?;\n-        let bufsize = this.read_machine_usize(bufsize_op)?;\n+        let bufsize = this.read_target_usize(bufsize_op)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n@@ -1727,7 +1727,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.reject_in_isolation(\"`realpath`\", reject_with)?;\n             let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n-            return Ok(Scalar::from_machine_usize(0, this));\n+            return Ok(Scalar::from_target_usize(0, this));\n         }\n \n         let result = std::fs::canonicalize(pathname);\n@@ -1758,7 +1758,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                         // seems like a bit of a mess anyway: <https://eklitzke.org/path-max-is-tricky>.\n                         let enametoolong = this.eval_libc(\"ENAMETOOLONG\");\n                         this.set_last_error(enametoolong)?;\n-                        return Ok(Scalar::from_machine_usize(0, this));\n+                        return Ok(Scalar::from_target_usize(0, this));\n                     }\n                     processed_ptr\n                 };\n@@ -1767,7 +1767,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n             Err(e) => {\n                 this.set_last_error_from_io_error(e.kind())?;\n-                Ok(Scalar::from_machine_usize(0, this))\n+                Ok(Scalar::from_target_usize(0, this))\n             }\n         }\n     }"}, {"sha": "f4e7824d91df47583e64493b7763677c3d2b573c", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -125,18 +125,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // argument, we have to also check all arguments *before* it to ensure that they\n                 // have the right type.\n \n-                let sys_getrandom = this.eval_libc(\"SYS_getrandom\").to_machine_usize(this)?;\n+                let sys_getrandom = this.eval_libc(\"SYS_getrandom\").to_target_usize(this)?;\n \n-                let sys_statx = this.eval_libc(\"SYS_statx\").to_machine_usize(this)?;\n+                let sys_statx = this.eval_libc(\"SYS_statx\").to_target_usize(this)?;\n \n-                let sys_futex = this.eval_libc(\"SYS_futex\").to_machine_usize(this)?;\n+                let sys_futex = this.eval_libc(\"SYS_futex\").to_target_usize(this)?;\n \n                 if args.is_empty() {\n                     throw_ub_format!(\n                         \"incorrect number of arguments for syscall: got 0, expected at least 1\"\n                     );\n                 }\n-                match this.read_machine_usize(&args[0])? {\n+                match this.read_target_usize(&args[0])? {\n                     // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n                     // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n                     id if id == sys_getrandom => {\n@@ -161,7 +161,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                         }\n                         let result =\n                             this.linux_statx(&args[1], &args[2], &args[3], &args[4], &args[5])?;\n-                        this.write_scalar(Scalar::from_machine_isize(result.into(), this), dest)?;\n+                        this.write_scalar(Scalar::from_target_isize(result.into(), this), dest)?;\n                     }\n                     // `futex` is used by some synchonization primitives.\n                     id if id == sys_futex => {\n@@ -184,7 +184,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [pid, cpusetsize, mask] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(pid)?.to_i32()?;\n-                this.read_machine_usize(cpusetsize)?;\n+                this.read_target_usize(cpusetsize)?;\n                 this.deref_operand(mask)?;\n                 // FIXME: we just return an error; `num_cpus` then falls back to `sysconf`.\n                 let einval = this.eval_libc(\"EINVAL\");\n@@ -216,14 +216,14 @@ fn getrandom<'tcx>(\n     dest: &PlaceTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx> {\n     let ptr = this.read_pointer(ptr)?;\n-    let len = this.read_machine_usize(len)?;\n+    let len = this.read_target_usize(len)?;\n \n     // The only supported flags are GRND_RANDOM and GRND_NONBLOCK,\n     // neither of which have any effect on our current PRNG.\n     // See <https://github.com/rust-lang/rust/pull/79196> for a discussion of argument sizes.\n     let _flags = this.read_scalar(flags)?.to_i32();\n \n     this.gen_random(ptr, len)?;\n-    this.write_scalar(Scalar::from_machine_usize(len, this), dest)?;\n+    this.write_scalar(Scalar::from_target_usize(len, this), dest)?;\n     Ok(())\n }"}, {"sha": "ffe3ca69c5866197a68fd91638b33d86455f71a1", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -81,7 +81,7 @@ pub fn futex<'tcx>(\n             if bitset == 0 {\n                 let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n-                this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(-1, this), dest)?;\n                 return Ok(());\n             }\n \n@@ -101,7 +101,7 @@ pub fn futex<'tcx>(\n                     None => {\n                         let einval = this.eval_libc(\"EINVAL\");\n                         this.set_last_error(einval)?;\n-                        this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                        this.write_scalar(Scalar::from_target_isize(-1, this), dest)?;\n                         return Ok(());\n                     }\n                 };\n@@ -173,7 +173,7 @@ pub fn futex<'tcx>(\n                 this.block_thread(thread);\n                 this.futex_wait(addr_usize, thread, bitset);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero.\n-                this.write_scalar(Scalar::from_machine_isize(0, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(0, this), dest)?;\n                 // Register a timeout callback if a timeout was specified.\n                 // This callback will override the return value when the timeout triggers.\n                 if let Some(timeout_time) = timeout_time {\n@@ -196,7 +196,7 @@ pub fn futex<'tcx>(\n                             this.futex_remove_waiter(self.addr_usize, self.thread);\n                             let etimedout = this.eval_libc(\"ETIMEDOUT\");\n                             this.set_last_error(etimedout)?;\n-                            this.write_scalar(Scalar::from_machine_isize(-1, this), &self.dest)?;\n+                            this.write_scalar(Scalar::from_target_isize(-1, this), &self.dest)?;\n \n                             Ok(())\n                         }\n@@ -213,7 +213,7 @@ pub fn futex<'tcx>(\n                 // right away without sleeping: -1 and errno set to EAGAIN.\n                 let eagain = this.eval_libc(\"EAGAIN\");\n                 this.set_last_error(eagain)?;\n-                this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(-1, this), dest)?;\n             }\n         }\n         // FUTEX_WAKE: (int *addr, int op = FUTEX_WAKE, int val)\n@@ -239,7 +239,7 @@ pub fn futex<'tcx>(\n             if bitset == 0 {\n                 let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n-                this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(-1, this), dest)?;\n                 return Ok(());\n             }\n             // Together with the SeqCst fence in futex_wait, this makes sure that futex_wait\n@@ -257,7 +257,7 @@ pub fn futex<'tcx>(\n                     break;\n                 }\n             }\n-            this.write_scalar(Scalar::from_machine_isize(n, this), dest)?;\n+            this.write_scalar(Scalar::from_target_isize(n, this), dest)?;\n         }\n         op => throw_unsup_format!(\"Miri does not support `futex` syscall with op={}\", op),\n     }"}, {"sha": "9177ecefe1207372ff3c4b5f9938a2328038b489", "filename": "src/tools/miri/src/shims/unix/macos/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fdlsym.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -39,7 +39,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             Dlsym::getentropy => {\n                 let [ptr, len] = check_arg_count(args)?;\n                 let ptr = this.read_pointer(ptr)?;\n-                let len = this.read_machine_usize(len)?;\n+                let len = this.read_target_usize(len)?;\n                 this.gen_random(ptr, len)?;\n                 this.write_null(dest)?;\n             }"}, {"sha": "1271788a97ef069998bcd46c3a3bee4936b4d69e", "filename": "src/tools/miri/src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -161,13 +161,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             // Querying system information\n             \"pthread_get_stackaddr_np\" => {\n                 let [thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                this.read_machine_usize(thread)?;\n+                this.read_target_usize(thread)?;\n                 let stack_addr = Scalar::from_uint(this.machine.stack_addr, this.pointer_size());\n                 this.write_scalar(stack_addr, dest)?;\n             }\n             \"pthread_get_stacksize_np\" => {\n                 let [thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                this.read_machine_usize(thread)?;\n+                this.read_target_usize(thread)?;\n                 let stack_size = Scalar::from_uint(this.machine.stack_size, this.pointer_size());\n                 this.write_scalar(stack_size, dest)?;\n             }\n@@ -176,7 +176,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"pthread_setname_np\" => {\n                 let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let thread = this.pthread_self()?;\n-                let max_len = this.eval_libc(\"MAXTHREADNAMESIZE\").to_machine_usize(this)?;\n+                let max_len = this.eval_libc(\"MAXTHREADNAMESIZE\").to_target_usize(this)?;\n                 let res = this.pthread_setname_np(\n                     thread,\n                     this.read_scalar(name)?,"}, {"sha": "6165cfd2823070991e8b212c67db0e17d400674b", "filename": "src/tools/miri/src/shims/unix/thread.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -42,7 +42,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             throw_unsup_format!(\"Miri supports pthread_join only with retval==NULL\");\n         }\n \n-        let thread_id = this.read_machine_usize(thread)?;\n+        let thread_id = this.read_target_usize(thread)?;\n         this.join_thread_exclusive(thread_id.try_into().expect(\"thread ID should fit in u32\"))?;\n \n         Ok(0)\n@@ -51,7 +51,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn pthread_detach(&mut self, thread: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let thread_id = this.read_machine_usize(thread)?;\n+        let thread_id = this.read_target_usize(thread)?;\n         this.detach_thread(\n             thread_id.try_into().expect(\"thread ID should fit in u32\"),\n             /*allow_terminated_joined*/ false,\n@@ -64,7 +64,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let thread_id = this.get_active_thread();\n-        Ok(Scalar::from_machine_usize(thread_id.into(), this))\n+        Ok(Scalar::from_target_usize(thread_id.into(), this))\n     }\n \n     /// Set the name of the current thread. `max_name_len` is the maximal length of the name\n@@ -77,7 +77,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n-        let thread = ThreadId::try_from(thread.to_machine_usize(this)?).unwrap();\n+        let thread = ThreadId::try_from(thread.to_target_usize(this)?).unwrap();\n         let name = name.to_pointer(this)?;\n \n         let name = this.read_c_str(name)?.to_owned();\n@@ -100,9 +100,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n-        let thread = ThreadId::try_from(thread.to_machine_usize(this)?).unwrap();\n+        let thread = ThreadId::try_from(thread.to_target_usize(this)?).unwrap();\n         let name_out = name_out.to_pointer(this)?;\n-        let len = len.to_machine_usize(this)?;\n+        let len = len.to_target_usize(this)?;\n \n         let name = this.get_thread_name(thread).to_owned();\n         let (success, _written) = this.write_c_str(&name, name_out, len)?;"}, {"sha": "60dd299c438130bc8d58a5d97a1cb66801e8632d", "filename": "src/tools/miri/src/shims/windows/dlsym.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -67,10 +67,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     byte_offset,\n                     _key,\n                 ] = check_arg_count(args)?;\n-                let handle = this.read_machine_isize(handle)?;\n+                let handle = this.read_target_isize(handle)?;\n                 let buf = this.read_pointer(buf)?;\n                 let n = this.read_scalar(n)?.to_u32()?;\n-                let byte_offset = this.read_machine_usize(byte_offset)?; // is actually a pointer\n+                let byte_offset = this.read_target_usize(byte_offset)?; // is actually a pointer\n                 let io_status_block = this.deref_operand(io_status_block)?;\n \n                 if byte_offset != 0 {\n@@ -104,7 +104,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     let io_status_information =\n                         this.mplace_field_named(&io_status_block, \"Information\")?;\n                     this.write_scalar(\n-                        Scalar::from_machine_usize(n.into(), this),\n+                        Scalar::from_target_usize(n.into(), this),\n                         &io_status_information.into(),\n                     )?;\n                 }"}, {"sha": "a3d7176a9768623e9ff8c2f726aab6cc40c8862a", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -73,9 +73,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"HeapAlloc\" => {\n                 let [handle, flags, size] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(handle)?;\n+                this.read_target_isize(handle)?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n-                let size = this.read_machine_usize(size)?;\n+                let size = this.read_target_usize(size)?;\n                 let heap_zero_memory = 0x00000008; // HEAP_ZERO_MEMORY\n                 let zero_init = (flags & heap_zero_memory) == heap_zero_memory;\n                 let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap)?;\n@@ -84,7 +84,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"HeapFree\" => {\n                 let [handle, flags, ptr] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(handle)?;\n+                this.read_target_isize(handle)?;\n                 this.read_scalar(flags)?.to_u32()?;\n                 let ptr = this.read_pointer(ptr)?;\n                 this.free(ptr, MiriMemoryKind::WinHeap)?;\n@@ -93,10 +93,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"HeapReAlloc\" => {\n                 let [handle, flags, ptr, size] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(handle)?;\n+                this.read_target_isize(handle)?;\n                 this.read_scalar(flags)?.to_u32()?;\n                 let ptr = this.read_pointer(ptr)?;\n-                let size = this.read_machine_usize(size)?;\n+                let size = this.read_target_usize(size)?;\n                 let res = this.realloc(ptr, size, MiriMemoryKind::WinHeap)?;\n                 this.write_pointer(res, dest)?;\n             }\n@@ -299,7 +299,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 #[allow(non_snake_case)]\n                 let [hModule, lpProcName] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(hModule)?;\n+                this.read_target_isize(hModule)?;\n                 let name = this.read_c_str(this.read_pointer(lpProcName)?)?;\n                 if let Some(dlsym) = Dlsym::from_str(name, &this.tcx.sess.target.os)? {\n                     let ptr = this.create_fn_alloc_ptr(FnVal::Other(dlsym));\n@@ -323,7 +323,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [algorithm, ptr, len, flags] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let algorithm = this.read_scalar(algorithm)?;\n-                let algorithm = algorithm.to_machine_usize(this)?;\n+                let algorithm = algorithm.to_target_usize(this)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let len = this.read_scalar(len)?.to_u32()?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n@@ -357,7 +357,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // `term` needs this, so we fake it.\n                 let [console, buffer_info] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(console)?;\n+                this.read_target_isize(console)?;\n                 this.deref_operand(buffer_info)?;\n                 // Indicate an error.\n                 // FIXME: we should set last_error, but to what?\n@@ -371,7 +371,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // one it is. This is very fake, but libtest needs it so we cannot make it a\n                 // std-only shim.\n                 // FIXME: this should return real HANDLEs when io support is added\n-                this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n+                this.write_scalar(Scalar::from_target_isize(which.into(), this), dest)?;\n             }\n             \"CloseHandle\" => {\n                 let [handle] =\n@@ -386,7 +386,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.check_no_isolation(\"`GetModuleFileNameW`\")?;\n \n-                let handle = this.read_machine_usize(handle)?;\n+                let handle = this.read_target_usize(handle)?;\n                 let filename = this.read_pointer(filename)?;\n                 let size = this.read_scalar(size)?.to_u32()?;\n \n@@ -473,7 +473,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"GetConsoleMode\" if this.frame_in_std() => {\n                 let [console, mode] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_machine_isize(console)?;\n+                this.read_target_isize(console)?;\n                 this.deref_operand(mode)?;\n                 // Indicate an error.\n                 this.write_null(dest)?;"}, {"sha": "8bffa9991c75af7bbb07a8e9bbaf18efecad9d05", "filename": "src/tools/miri/src/shims/windows/handle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fhandle.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -124,14 +124,14 @@ impl Handle {\n         // see https://docs.microsoft.com/en-us/windows/win32/winprog64/interprocess-communication\n         #[allow(clippy::cast_possible_wrap)] // we want it to wrap\n         let signed_handle = self.to_packed() as i32;\n-        Scalar::from_machine_isize(signed_handle.into(), cx)\n+        Scalar::from_target_isize(signed_handle.into(), cx)\n     }\n \n     pub fn from_scalar<'tcx>(\n         handle: Scalar<Provenance>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Option<Self>> {\n-        let sign_extended_handle = handle.to_machine_isize(cx)?;\n+        let sign_extended_handle = handle.to_target_isize(cx)?;\n \n         #[allow(clippy::cast_sign_loss)] // we want to lose the sign\n         let handle = if let Ok(signed_handle) = i32::try_from(sign_extended_handle) {"}, {"sha": "b9cc3e15be9fe3135eb57a2d4cc6511925c77bd4", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -273,7 +273,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let ptr = this.read_pointer(ptr_op)?;\n         let compare = this.read_pointer(compare_op)?;\n-        let size = this.read_machine_usize(size_op)?;\n+        let size = this.read_target_usize(size_op)?;\n         let timeout_ms = this.read_scalar(timeout_op)?.to_u32()?;\n \n         let thread = this.get_active_thread();"}, {"sha": "9cbae1588598507ac5741edcf36dea2d0a1a59fd", "filename": "src/tools/miri/src/shims/windows/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -21,7 +21,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let security = this.read_pointer(security_op)?;\n         // stacksize is ignored, but still needs to be a valid usize\n-        this.read_machine_usize(stacksize_op)?;\n+        this.read_target_usize(stacksize_op)?;\n         let start_routine = this.read_pointer(start_op)?;\n         let func_arg = this.read_immediate(arg_op)?;\n         let flags = this.read_scalar(flags_op)?.to_u32()?;"}, {"sha": "4c93f8a16b670a2969feed8ae112162c7fbc1789", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -192,8 +192,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"regex-automata\",\n     \"regex-syntax\",\n     \"remove_dir_all\",\n-    \"rls-data\",\n-    \"rls-span\",\n     \"rustc-demangle\",\n     \"rustc-hash\",\n     \"rustc-rayon\","}, {"sha": "84a42ca36ef1c3c48692b93444dcf46f0d0897fc", "filename": "src/tools/x/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fx%2FCargo.toml?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"x\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n description = \"Run x.py slightly more conveniently\"\n edition = \"2021\"\n publish = false"}, {"sha": "5da8a2888ec8385c6c6ab54a0189a787182e72c5", "filename": "src/tools/x/src/main.rs", "status": "modified", "additions": 59, "deletions": 15, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fx%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/src%2Ftools%2Fx%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fx%2Fsrc%2Fmain.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -9,11 +9,47 @@\n //! We also don't use `pwsh` on Windows, because it is not installed by default;\n \n use std::{\n-    env, io,\n+    env::{self, consts::EXE_EXTENSION},\n+    io,\n     path::Path,\n     process::{self, Command, ExitStatus},\n };\n \n+const PYTHON: &str = \"python\";\n+const PYTHON2: &str = \"python2\";\n+const PYTHON3: &str = \"python3\";\n+\n+fn python() -> &'static str {\n+    let val = match env::var_os(\"PATH\") {\n+        Some(val) => val,\n+        None => return PYTHON,\n+    };\n+\n+    let mut python2 = false;\n+    let mut python3 = false;\n+\n+    for dir in env::split_paths(&val) {\n+        // `python` should always take precedence over python2 / python3 if it exists\n+        if dir.join(PYTHON).with_extension(EXE_EXTENSION).exists() {\n+            return PYTHON;\n+        }\n+\n+        python2 |= dir.join(PYTHON2).with_extension(EXE_EXTENSION).exists();\n+        python3 |= dir.join(PYTHON3).with_extension(EXE_EXTENSION).exists();\n+    }\n+\n+    // try 3 before 2\n+    if python3 {\n+        PYTHON3\n+    } else if python2 {\n+        PYTHON2\n+    } else {\n+        // Python was not found on path, so exit\n+        eprintln!(\"Unable to find python in your PATH. Please check it is installed.\");\n+        process::exit(1);\n+    }\n+}\n+\n #[cfg(windows)]\n fn x_command(dir: &Path) -> Command {\n     let mut cmd = Command::new(\"powershell.exe\");\n@@ -51,6 +87,17 @@ fn exec_or_status(command: &mut Command) -> io::Result<ExitStatus> {\n     command.status()\n }\n \n+fn handle_result(result: io::Result<ExitStatus>, cmd: Command) {\n+    match result {\n+        Err(error) => {\n+            eprintln!(\"Failed to invoke `{:?}`: {}\", cmd, error);\n+        }\n+        Ok(status) => {\n+            process::exit(status.code().unwrap_or(1));\n+        }\n+    }\n+}\n+\n fn main() {\n     match env::args().skip(1).next().as_deref() {\n         Some(\"--wrapper-version\") => {\n@@ -70,22 +117,19 @@ fn main() {\n \n     for dir in current.ancestors() {\n         let candidate = dir.join(\"x.py\");\n-\n         if candidate.exists() {\n-            let mut cmd = x_command(dir);\n-\n-            cmd.args(env::args().skip(1)).current_dir(dir);\n-\n-            let result = exec_or_status(&mut cmd);\n-\n-            match result {\n-                Err(error) => {\n-                    eprintln!(\"Failed to invoke `{:?}`: {}\", cmd, error);\n-                }\n-                Ok(status) => {\n-                    process::exit(status.code().unwrap_or(1));\n-                }\n+            let shell_script_candidate = dir.join(\"x\");\n+            let mut cmd: Command;\n+            if shell_script_candidate.exists() {\n+                cmd = x_command(dir);\n+                cmd.args(env::args().skip(1)).current_dir(dir);\n+            } else {\n+                // For older checkouts that do not have the x shell script, default to python\n+                cmd = Command::new(python());\n+                cmd.arg(&candidate).args(env::args().skip(1)).current_dir(dir);\n             }\n+            let result = exec_or_status(&mut cmd);\n+            handle_result(result, cmd);\n         }\n     }\n "}, {"sha": "1d8209e8ea54e64f83d98694727d7c6d8f7e3c14", "filename": "tests/codegen/move-operands.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fmove-operands.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fmove-operands.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmove-operands.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -C no-prepopulate-passes -Zmir-enable-passes=+DestinationPropagation\n+// compile-flags: -C no-prepopulate-passes -Zmir-enable-passes=+DestinationPropagation,-CopyProp\n \n #![crate_type = \"lib\"]\n "}, {"sha": "faac7566a0c493e2be45b9115fd1450cb35709ce", "filename": "tests/codegen/simd-intrinsic/simd-intrinsic-generic-arithmetic-saturating.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-arithmetic-saturating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-arithmetic-saturating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-arithmetic-saturating.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -116,150 +116,150 @@ extern \"platform-intrinsic\" {\n     fn simd_saturating_sub<T>(x: T, y: T) -> T;\n }\n \n-// NOTE(eddyb) `%{{x|_3}}` is used because on some targets (e.g. WASM)\n+// NOTE(eddyb) `%{{x|1}}` is used because on some targets (e.g. WASM)\n // SIMD vectors are passed directly, resulting in `%x` being a vector,\n // while on others they're passed indirectly, resulting in `%x` being\n-// a pointer to a vector, and `%_3` a vector loaded from that pointer.\n+// a pointer to a vector, and `%1` a vector loaded from that pointer.\n // This is controlled by the target spec option `simd_types_indirect`.\n-// The same applies to `%{{y|_4}}` as well.\n+// The same applies to `%{{y|2}}` as well.\n \n // CHECK-LABEL: @sadd_i8x2\n #[no_mangle]\n pub unsafe fn sadd_i8x2(x: i8x2, y: i8x2) -> i8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.sadd.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.sadd.sat.v2i8(<2 x i8> %{{x|1}}, <2 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x4\n #[no_mangle]\n pub unsafe fn sadd_i8x4(x: i8x4, y: i8x4) -> i8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.sadd.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.sadd.sat.v4i8(<4 x i8> %{{x|1}}, <4 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x8\n #[no_mangle]\n pub unsafe fn sadd_i8x8(x: i8x8, y: i8x8) -> i8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.sadd.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.sadd.sat.v8i8(<8 x i8> %{{x|1}}, <8 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x16\n #[no_mangle]\n pub unsafe fn sadd_i8x16(x: i8x16, y: i8x16) -> i8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.sadd.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.sadd.sat.v16i8(<16 x i8> %{{x|1}}, <16 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x32\n #[no_mangle]\n pub unsafe fn sadd_i8x32(x: i8x32, y: i8x32) -> i8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.sadd.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.sadd.sat.v32i8(<32 x i8> %{{x|1}}, <32 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x64\n #[no_mangle]\n pub unsafe fn sadd_i8x64(x: i8x64, y: i8x64) -> i8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.sadd.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.sadd.sat.v64i8(<64 x i8> %{{x|1}}, <64 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x2\n #[no_mangle]\n pub unsafe fn sadd_i16x2(x: i16x2, y: i16x2) -> i16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.sadd.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.sadd.sat.v2i16(<2 x i16> %{{x|1}}, <2 x i16> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x4\n #[no_mangle]\n pub unsafe fn sadd_i16x4(x: i16x4, y: i16x4) -> i16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.sadd.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.sadd.sat.v4i16(<4 x i16> %{{x|1}}, <4 x i16> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x8\n #[no_mangle]\n pub unsafe fn sadd_i16x8(x: i16x8, y: i16x8) -> i16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.sadd.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.sadd.sat.v8i16(<8 x i16> %{{x|1}}, <8 x i16> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x16\n #[no_mangle]\n pub unsafe fn sadd_i16x16(x: i16x16, y: i16x16) -> i16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.sadd.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.sadd.sat.v16i16(<16 x i16> %{{x|1}}, <16 x i16> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x32\n #[no_mangle]\n pub unsafe fn sadd_i16x32(x: i16x32, y: i16x32) -> i16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.sadd.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.sadd.sat.v32i16(<32 x i16> %{{x|1}}, <32 x i16> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x2\n #[no_mangle]\n pub unsafe fn sadd_i32x2(x: i32x2, y: i32x2) -> i32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.sadd.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.sadd.sat.v2i32(<2 x i32> %{{x|1}}, <2 x i32> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x4\n #[no_mangle]\n pub unsafe fn sadd_i32x4(x: i32x4, y: i32x4) -> i32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.sadd.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.sadd.sat.v4i32(<4 x i32> %{{x|1}}, <4 x i32> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x8\n #[no_mangle]\n pub unsafe fn sadd_i32x8(x: i32x8, y: i32x8) -> i32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.sadd.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.sadd.sat.v8i32(<8 x i32> %{{x|1}}, <8 x i32> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x16\n #[no_mangle]\n pub unsafe fn sadd_i32x16(x: i32x16, y: i32x16) -> i32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.sadd.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.sadd.sat.v16i32(<16 x i32> %{{x|1}}, <16 x i32> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i64x2\n #[no_mangle]\n pub unsafe fn sadd_i64x2(x: i64x2, y: i64x2) -> i64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.sadd.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.sadd.sat.v2i64(<2 x i64> %{{x|1}}, <2 x i64> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i64x4\n #[no_mangle]\n pub unsafe fn sadd_i64x4(x: i64x4, y: i64x4) -> i64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.sadd.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.sadd.sat.v4i64(<4 x i64> %{{x|1}}, <4 x i64> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i64x8\n #[no_mangle]\n pub unsafe fn sadd_i64x8(x: i64x8, y: i64x8) -> i64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.sadd.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.sadd.sat.v8i64(<8 x i64> %{{x|1}}, <8 x i64> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i128x2\n #[no_mangle]\n pub unsafe fn sadd_i128x2(x: i128x2, y: i128x2) -> i128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.sadd.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.sadd.sat.v2i128(<2 x i128> %{{x|1}}, <2 x i128> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i128x4\n #[no_mangle]\n pub unsafe fn sadd_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.sadd.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.sadd.sat.v4i128(<4 x i128> %{{x|1}}, <4 x i128> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n@@ -268,140 +268,140 @@ pub unsafe fn sadd_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n // CHECK-LABEL: @uadd_u8x2\n #[no_mangle]\n pub unsafe fn uadd_u8x2(x: u8x2, y: u8x2) -> u8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.uadd.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.uadd.sat.v2i8(<2 x i8> %{{x|1}}, <2 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x4\n #[no_mangle]\n pub unsafe fn uadd_u8x4(x: u8x4, y: u8x4) -> u8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.uadd.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.uadd.sat.v4i8(<4 x i8> %{{x|1}}, <4 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x8\n #[no_mangle]\n pub unsafe fn uadd_u8x8(x: u8x8, y: u8x8) -> u8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.uadd.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.uadd.sat.v8i8(<8 x i8> %{{x|1}}, <8 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x16\n #[no_mangle]\n pub unsafe fn uadd_u8x16(x: u8x16, y: u8x16) -> u8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.uadd.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.uadd.sat.v16i8(<16 x i8> %{{x|1}}, <16 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x32\n #[no_mangle]\n pub unsafe fn uadd_u8x32(x: u8x32, y: u8x32) -> u8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.uadd.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.uadd.sat.v32i8(<32 x i8> %{{x|1}}, <32 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x64\n #[no_mangle]\n pub unsafe fn uadd_u8x64(x: u8x64, y: u8x64) -> u8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.uadd.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.uadd.sat.v64i8(<64 x i8> %{{x|1}}, <64 x i8> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x2\n #[no_mangle]\n pub unsafe fn uadd_u16x2(x: u16x2, y: u16x2) -> u16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.uadd.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.uadd.sat.v2i16(<2 x i16> %{{x|1}}, <2 x i16> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x4\n #[no_mangle]\n pub unsafe fn uadd_u16x4(x: u16x4, y: u16x4) -> u16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.uadd.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.uadd.sat.v4i16(<4 x i16> %{{x|1}}, <4 x i16> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x8\n #[no_mangle]\n pub unsafe fn uadd_u16x8(x: u16x8, y: u16x8) -> u16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.uadd.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.uadd.sat.v8i16(<8 x i16> %{{x|1}}, <8 x i16> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x16\n #[no_mangle]\n pub unsafe fn uadd_u16x16(x: u16x16, y: u16x16) -> u16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.uadd.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.uadd.sat.v16i16(<16 x i16> %{{x|1}}, <16 x i16> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x32\n #[no_mangle]\n pub unsafe fn uadd_u16x32(x: u16x32, y: u16x32) -> u16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.uadd.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.uadd.sat.v32i16(<32 x i16> %{{x|1}}, <32 x i16> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x2\n #[no_mangle]\n pub unsafe fn uadd_u32x2(x: u32x2, y: u32x2) -> u32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.uadd.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.uadd.sat.v2i32(<2 x i32> %{{x|1}}, <2 x i32> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x4\n #[no_mangle]\n pub unsafe fn uadd_u32x4(x: u32x4, y: u32x4) -> u32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.uadd.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.uadd.sat.v4i32(<4 x i32> %{{x|1}}, <4 x i32> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x8\n #[no_mangle]\n pub unsafe fn uadd_u32x8(x: u32x8, y: u32x8) -> u32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.uadd.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.uadd.sat.v8i32(<8 x i32> %{{x|1}}, <8 x i32> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x16\n #[no_mangle]\n pub unsafe fn uadd_u32x16(x: u32x16, y: u32x16) -> u32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.uadd.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.uadd.sat.v16i32(<16 x i32> %{{x|1}}, <16 x i32> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u64x2\n #[no_mangle]\n pub unsafe fn uadd_u64x2(x: u64x2, y: u64x2) -> u64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.uadd.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.uadd.sat.v2i64(<2 x i64> %{{x|1}}, <2 x i64> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u64x4\n #[no_mangle]\n pub unsafe fn uadd_u64x4(x: u64x4, y: u64x4) -> u64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.uadd.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.uadd.sat.v4i64(<4 x i64> %{{x|1}}, <4 x i64> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u64x8\n #[no_mangle]\n pub unsafe fn uadd_u64x8(x: u64x8, y: u64x8) -> u64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.uadd.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.uadd.sat.v8i64(<8 x i64> %{{x|1}}, <8 x i64> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u128x2\n #[no_mangle]\n pub unsafe fn uadd_u128x2(x: u128x2, y: u128x2) -> u128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.uadd.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.uadd.sat.v2i128(<2 x i128> %{{x|1}}, <2 x i128> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u128x4\n #[no_mangle]\n pub unsafe fn uadd_u128x4(x: u128x4, y: u128x4) -> u128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.uadd.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.uadd.sat.v4i128(<4 x i128> %{{x|1}}, <4 x i128> %{{y|2}})\n     simd_saturating_add(x, y)\n }\n \n@@ -412,140 +412,140 @@ pub unsafe fn uadd_u128x4(x: u128x4, y: u128x4) -> u128x4 {\n // CHECK-LABEL: @ssub_i8x2\n #[no_mangle]\n pub unsafe fn ssub_i8x2(x: i8x2, y: i8x2) -> i8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.ssub.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.ssub.sat.v2i8(<2 x i8> %{{x|1}}, <2 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x4\n #[no_mangle]\n pub unsafe fn ssub_i8x4(x: i8x4, y: i8x4) -> i8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.ssub.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.ssub.sat.v4i8(<4 x i8> %{{x|1}}, <4 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x8\n #[no_mangle]\n pub unsafe fn ssub_i8x8(x: i8x8, y: i8x8) -> i8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.ssub.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.ssub.sat.v8i8(<8 x i8> %{{x|1}}, <8 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x16\n #[no_mangle]\n pub unsafe fn ssub_i8x16(x: i8x16, y: i8x16) -> i8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.ssub.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.ssub.sat.v16i8(<16 x i8> %{{x|1}}, <16 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x32\n #[no_mangle]\n pub unsafe fn ssub_i8x32(x: i8x32, y: i8x32) -> i8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.ssub.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.ssub.sat.v32i8(<32 x i8> %{{x|1}}, <32 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x64\n #[no_mangle]\n pub unsafe fn ssub_i8x64(x: i8x64, y: i8x64) -> i8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.ssub.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.ssub.sat.v64i8(<64 x i8> %{{x|1}}, <64 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x2\n #[no_mangle]\n pub unsafe fn ssub_i16x2(x: i16x2, y: i16x2) -> i16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.ssub.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.ssub.sat.v2i16(<2 x i16> %{{x|1}}, <2 x i16> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x4\n #[no_mangle]\n pub unsafe fn ssub_i16x4(x: i16x4, y: i16x4) -> i16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.ssub.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.ssub.sat.v4i16(<4 x i16> %{{x|1}}, <4 x i16> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x8\n #[no_mangle]\n pub unsafe fn ssub_i16x8(x: i16x8, y: i16x8) -> i16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.ssub.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.ssub.sat.v8i16(<8 x i16> %{{x|1}}, <8 x i16> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x16\n #[no_mangle]\n pub unsafe fn ssub_i16x16(x: i16x16, y: i16x16) -> i16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.ssub.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.ssub.sat.v16i16(<16 x i16> %{{x|1}}, <16 x i16> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x32\n #[no_mangle]\n pub unsafe fn ssub_i16x32(x: i16x32, y: i16x32) -> i16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.ssub.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.ssub.sat.v32i16(<32 x i16> %{{x|1}}, <32 x i16> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x2\n #[no_mangle]\n pub unsafe fn ssub_i32x2(x: i32x2, y: i32x2) -> i32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.ssub.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.ssub.sat.v2i32(<2 x i32> %{{x|1}}, <2 x i32> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x4\n #[no_mangle]\n pub unsafe fn ssub_i32x4(x: i32x4, y: i32x4) -> i32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.ssub.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.ssub.sat.v4i32(<4 x i32> %{{x|1}}, <4 x i32> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x8\n #[no_mangle]\n pub unsafe fn ssub_i32x8(x: i32x8, y: i32x8) -> i32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.ssub.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.ssub.sat.v8i32(<8 x i32> %{{x|1}}, <8 x i32> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x16\n #[no_mangle]\n pub unsafe fn ssub_i32x16(x: i32x16, y: i32x16) -> i32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.ssub.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.ssub.sat.v16i32(<16 x i32> %{{x|1}}, <16 x i32> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i64x2\n #[no_mangle]\n pub unsafe fn ssub_i64x2(x: i64x2, y: i64x2) -> i64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.ssub.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.ssub.sat.v2i64(<2 x i64> %{{x|1}}, <2 x i64> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i64x4\n #[no_mangle]\n pub unsafe fn ssub_i64x4(x: i64x4, y: i64x4) -> i64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.ssub.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.ssub.sat.v4i64(<4 x i64> %{{x|1}}, <4 x i64> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i64x8\n #[no_mangle]\n pub unsafe fn ssub_i64x8(x: i64x8, y: i64x8) -> i64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.ssub.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.ssub.sat.v8i64(<8 x i64> %{{x|1}}, <8 x i64> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i128x2\n #[no_mangle]\n pub unsafe fn ssub_i128x2(x: i128x2, y: i128x2) -> i128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.ssub.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.ssub.sat.v2i128(<2 x i128> %{{x|1}}, <2 x i128> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i128x4\n #[no_mangle]\n pub unsafe fn ssub_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.ssub.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.ssub.sat.v4i128(<4 x i128> %{{x|1}}, <4 x i128> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n@@ -554,139 +554,139 @@ pub unsafe fn ssub_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n // CHECK-LABEL: @usub_u8x2\n #[no_mangle]\n pub unsafe fn usub_u8x2(x: u8x2, y: u8x2) -> u8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.usub.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.usub.sat.v2i8(<2 x i8> %{{x|1}}, <2 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x4\n #[no_mangle]\n pub unsafe fn usub_u8x4(x: u8x4, y: u8x4) -> u8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.usub.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.usub.sat.v4i8(<4 x i8> %{{x|1}}, <4 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x8\n #[no_mangle]\n pub unsafe fn usub_u8x8(x: u8x8, y: u8x8) -> u8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.usub.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.usub.sat.v8i8(<8 x i8> %{{x|1}}, <8 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x16\n #[no_mangle]\n pub unsafe fn usub_u8x16(x: u8x16, y: u8x16) -> u8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.usub.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.usub.sat.v16i8(<16 x i8> %{{x|1}}, <16 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x32\n #[no_mangle]\n pub unsafe fn usub_u8x32(x: u8x32, y: u8x32) -> u8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.usub.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.usub.sat.v32i8(<32 x i8> %{{x|1}}, <32 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x64\n #[no_mangle]\n pub unsafe fn usub_u8x64(x: u8x64, y: u8x64) -> u8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.usub.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.usub.sat.v64i8(<64 x i8> %{{x|1}}, <64 x i8> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x2\n #[no_mangle]\n pub unsafe fn usub_u16x2(x: u16x2, y: u16x2) -> u16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.usub.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.usub.sat.v2i16(<2 x i16> %{{x|1}}, <2 x i16> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x4\n #[no_mangle]\n pub unsafe fn usub_u16x4(x: u16x4, y: u16x4) -> u16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.usub.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.usub.sat.v4i16(<4 x i16> %{{x|1}}, <4 x i16> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x8\n #[no_mangle]\n pub unsafe fn usub_u16x8(x: u16x8, y: u16x8) -> u16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.usub.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.usub.sat.v8i16(<8 x i16> %{{x|1}}, <8 x i16> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x16\n #[no_mangle]\n pub unsafe fn usub_u16x16(x: u16x16, y: u16x16) -> u16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.usub.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.usub.sat.v16i16(<16 x i16> %{{x|1}}, <16 x i16> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x32\n #[no_mangle]\n pub unsafe fn usub_u16x32(x: u16x32, y: u16x32) -> u16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.usub.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.usub.sat.v32i16(<32 x i16> %{{x|1}}, <32 x i16> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x2\n #[no_mangle]\n pub unsafe fn usub_u32x2(x: u32x2, y: u32x2) -> u32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.usub.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.usub.sat.v2i32(<2 x i32> %{{x|1}}, <2 x i32> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x4\n #[no_mangle]\n pub unsafe fn usub_u32x4(x: u32x4, y: u32x4) -> u32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.usub.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.usub.sat.v4i32(<4 x i32> %{{x|1}}, <4 x i32> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x8\n #[no_mangle]\n pub unsafe fn usub_u32x8(x: u32x8, y: u32x8) -> u32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.usub.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.usub.sat.v8i32(<8 x i32> %{{x|1}}, <8 x i32> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x16\n #[no_mangle]\n pub unsafe fn usub_u32x16(x: u32x16, y: u32x16) -> u32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.usub.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.usub.sat.v16i32(<16 x i32> %{{x|1}}, <16 x i32> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u64x2\n #[no_mangle]\n pub unsafe fn usub_u64x2(x: u64x2, y: u64x2) -> u64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.usub.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.usub.sat.v2i64(<2 x i64> %{{x|1}}, <2 x i64> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u64x4\n #[no_mangle]\n pub unsafe fn usub_u64x4(x: u64x4, y: u64x4) -> u64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.usub.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.usub.sat.v4i64(<4 x i64> %{{x|1}}, <4 x i64> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u64x8\n #[no_mangle]\n pub unsafe fn usub_u64x8(x: u64x8, y: u64x8) -> u64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.usub.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.usub.sat.v8i64(<8 x i64> %{{x|1}}, <8 x i64> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u128x2\n #[no_mangle]\n pub unsafe fn usub_u128x2(x: u128x2, y: u128x2) -> u128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.usub.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.usub.sat.v2i128(<2 x i128> %{{x|1}}, <2 x i128> %{{y|2}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u128x4\n #[no_mangle]\n pub unsafe fn usub_u128x4(x: u128x4, y: u128x4) -> u128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.usub.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.usub.sat.v4i128(<4 x i128> %{{x|1}}, <4 x i128> %{{y|2}})\n     simd_saturating_sub(x, y)\n }"}, {"sha": "ea24569bd10c16698fe4a62ffa3d76266c5eb0ec", "filename": "tests/codegen/simd-intrinsic/simd-intrinsic-generic-bitmask.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-bitmask.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -26,16 +26,16 @@ extern \"platform-intrinsic\" {\n     fn simd_bitmask<T, U>(x: T) -> U;\n }\n \n-// NOTE(eddyb) `%{{x|_2}}` is used because on some targets (e.g. WASM)\n+// NOTE(eddyb) `%{{x|1}}` is used because on some targets (e.g. WASM)\n // SIMD vectors are passed directly, resulting in `%x` being a vector,\n // while on others they're passed indirectly, resulting in `%x` being\n-// a pointer to a vector, and `%_2` a vector loaded from that pointer.\n+// a pointer to a vector, and `%1` a vector loaded from that pointer.\n // This is controlled by the target spec option `simd_types_indirect`.\n \n // CHECK-LABEL: @bitmask_int\n #[no_mangle]\n pub unsafe fn bitmask_int(x: i32x2) -> u8 {\n-    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{x|_2}}, <i32 31, i32 31>\n+    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{x|1}}, <i32 31, i32 31>\n     // CHECK: [[B:%[0-9]+]] = trunc <2 x i32> [[A]] to <2 x i1>\n     // CHECK: [[C:%[0-9]+]] = bitcast <2 x i1> [[B]] to i2\n     // CHECK: %{{[0-9]+}} = zext i2 [[C]] to i8\n@@ -45,7 +45,7 @@ pub unsafe fn bitmask_int(x: i32x2) -> u8 {\n // CHECK-LABEL: @bitmask_uint\n #[no_mangle]\n pub unsafe fn bitmask_uint(x: u32x2) -> u8 {\n-    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{x|_2}}, <i32 31, i32 31>\n+    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{x|1}}, <i32 31, i32 31>\n     // CHECK: [[B:%[0-9]+]] = trunc <2 x i32> [[A]] to <2 x i1>\n     // CHECK: [[C:%[0-9]+]] = bitcast <2 x i1> [[B]] to i2\n     // CHECK: %{{[0-9]+}} = zext i2 [[C]] to i8\n@@ -55,7 +55,7 @@ pub unsafe fn bitmask_uint(x: u32x2) -> u8 {\n // CHECK-LABEL: @bitmask_int16\n #[no_mangle]\n pub unsafe fn bitmask_int16(x: i8x16) -> u16 {\n-    // CHECK: [[A:%[0-9]+]] = lshr <16 x i8> %{{x|_2}}, <i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7>\n+    // CHECK: [[A:%[0-9]+]] = lshr <16 x i8> %{{x|1|2}}, <i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7>\n     // CHECK: [[B:%[0-9]+]] = trunc <16 x i8> [[A]] to <16 x i1>\n     // CHECK: %{{[0-9]+}} = bitcast <16 x i1> [[B]] to i16\n     // CHECK-NOT: zext"}, {"sha": "80583dec195243723c7a8541859df2324d3cadd8", "filename": "tests/codegen/simd-intrinsic/simd-intrinsic-generic-extract-insert.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-extract-insert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-extract-insert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-extract-insert.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -21,27 +21,27 @@ extern \"platform-intrinsic\" {\n // CHECK-LABEL: @extract_m\n #[no_mangle]\n pub unsafe fn extract_m(v: M, i: u32) -> f32  {\n-    // CHECK: extractelement <4 x float> %{{v|_3}}, i32 %i\n+    // CHECK: extractelement <4 x float> %{{v|1|2}}, i32 %i\n     simd_extract(v, i)\n }\n \n // CHECK-LABEL: @extract_s\n #[no_mangle]\n pub unsafe fn extract_s(v: S<4>, i: u32) -> f32  {\n-    // CHECK: extractelement <4 x float> %{{v|_3}}, i32 %i\n+    // CHECK: extractelement <4 x float> %{{v|1|2}}, i32 %i\n     simd_extract(v, i)\n }\n \n // CHECK-LABEL: @insert_m\n #[no_mangle]\n pub unsafe fn insert_m(v: M, i: u32, j: f32) -> M  {\n-    // CHECK: insertelement <4 x float> %{{v|_4}}, float %j, i32 %i\n+    // CHECK: insertelement <4 x float> %{{v|1|2}}, float %j, i32 %i\n     simd_insert(v, i, j)\n }\n \n // CHECK-LABEL: @insert_s\n #[no_mangle]\n pub unsafe fn insert_s(v: S<4>, i: u32, j: f32) -> S<4>  {\n-    // CHECK: insertelement <4 x float> %{{v|_4}}, float %j, i32 %i\n+    // CHECK: insertelement <4 x float> %{{v|1|2}}, float %j, i32 %i\n     simd_insert(v, i, j)\n }"}, {"sha": "7c77398dfcce5f02bc992434be8cb2554fefc174", "filename": "tests/codegen/simd-intrinsic/simd-intrinsic-transmute-array.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-transmute-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-transmute-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-transmute-array.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -21,23 +21,20 @@ pub struct U(f32, f32, f32, f32);\n // CHECK-LABEL: @build_array_s\n #[no_mangle]\n pub fn build_array_s(x: [f32; 4]) -> S<4> {\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n     // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n     S::<4>(x)\n }\n \n // CHECK-LABEL: @build_array_t\n #[no_mangle]\n pub fn build_array_t(x: [f32; 4]) -> T {\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n     // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n     T(x)\n }\n \n // CHECK-LABEL: @build_array_u\n #[no_mangle]\n pub fn build_array_u(x: [f32; 4]) -> U {\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n     // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n     unsafe { std::mem::transmute(x) }\n }"}, {"sha": "f2333777391f1e87f821072c501167b400bf44eb", "filename": "tests/codegen/simd_arith_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fsimd_arith_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fcodegen%2Fsimd_arith_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsimd_arith_offset.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -21,6 +21,6 @@ pub struct Simd<T, const LANES: usize>([T; LANES]);\n // CHECK-LABEL: smoke\n #[no_mangle]\n pub fn smoke(ptrs: SimdConstPtr<u8, 8>, offsets: Simd<usize, 8>) -> SimdConstPtr<u8, 8> {\n-    // CHECK: getelementptr i8, <8 x {{i8\\*|ptr}}> %_3, <8 x i64> %_4\n+    // CHECK: getelementptr i8, <8 x {{i8\\*|ptr}}> %1, <8 x i64> %2\n     unsafe { simd_arith_offset(ptrs, offsets) }\n }"}, {"sha": "6ca73ffdde280fd1200a3159a1af98dc3a80273c", "filename": "tests/mir-opt/copy-prop/custom_move_arg.f.CopyProp.diff", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fcopy-prop%2Fcustom_move_arg.f.CopyProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fcopy-prop%2Fcustom_move_arg.f.CopyProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fcustom_move_arg.f.CopyProp.diff?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -0,0 +1,31 @@\n+- // MIR for `f` before CopyProp\n++ // MIR for `f` after CopyProp\n+  \n+  fn f(_1: NotCopy) -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/custom_move_arg.rs:+0:19: +0:19\n+      let mut _2: NotCopy;                 // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+      let mut _3: NotCopy;                 // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+  \n+      bb0: {\n+-         _2 = _1;                         // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+-         _0 = opaque::<NotCopy>(move _1) -> bb1; // scope 0 at $DIR/custom_move_arg.rs:+3:9: +3:41\n++         _0 = opaque::<NotCopy>(_1) -> bb1; // scope 0 at $DIR/custom_move_arg.rs:+3:9: +3:41\n+                                           // mir::Constant\n+                                           // + span: $DIR/custom_move_arg.rs:15:24: 15:30\n+                                           // + literal: Const { ty: fn(NotCopy) {opaque::<NotCopy>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+-         _3 = move _2;                    // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+-         _0 = opaque::<NotCopy>(_3) -> bb2; // scope 0 at $DIR/custom_move_arg.rs:+7:9: +7:35\n++         _0 = opaque::<NotCopy>(_1) -> bb2; // scope 0 at $DIR/custom_move_arg.rs:+7:9: +7:35\n+                                           // mir::Constant\n+                                           // + span: $DIR/custom_move_arg.rs:19:24: 19:30\n+                                           // + literal: Const { ty: fn(NotCopy) {opaque::<NotCopy>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb2: {\n+          return;                          // scope 0 at $DIR/custom_move_arg.rs:+10:9: +10:17\n+      }\n+  }\n+  "}, {"sha": "4a591146e619f950ea5c7f2dd6de55fe0c18873b", "filename": "tests/mir-opt/copy-prop/custom_move_arg.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fcopy-prop%2Fcustom_move_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fcopy-prop%2Fcustom_move_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fcustom_move_arg.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -0,0 +1,32 @@\n+// unit-test: CopyProp\n+\n+#![feature(custom_mir, core_intrinsics)]\n+#![allow(unused_assignments)]\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+struct NotCopy(bool);\n+\n+// EMIT_MIR custom_move_arg.f.CopyProp.diff\n+#[custom_mir(dialect = \"analysis\", phase = \"post-cleanup\")]\n+fn f(_1: NotCopy) {\n+    mir!({\n+        let _2 = _1;\n+        Call(RET, bb1, opaque(Move(_1)))\n+    }\n+    bb1 = {\n+        let _3 = Move(_2);\n+        Call(RET, bb2, opaque(_3))\n+    }\n+    bb2 = {\n+        Return()\n+    })\n+}\n+\n+#[inline(never)]\n+fn opaque<T>(_t: T) {}\n+\n+fn main() {\n+    f(NotCopy(true));\n+    println!(\"hi\");\n+}"}, {"sha": "33122f465fe4df3d47a3966db6e7da5dc8dc3b0e", "filename": "tests/mir-opt/dataflow-const-prop/inherit_overflow.main.DataflowConstProp.diff", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -10,19 +10,21 @@\n       scope 2 (inlined <u8 as Add>::add) { // at $DIR/inherit_overflow.rs:7:13: 7:47\n           debug self => _1;                // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n           debug other => _2;               // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          let mut _3: u8;                  // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          let mut _4: u8;                  // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          let mut _5: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          let mut _3: (u8, bool);          // in scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n       }\n   \n       bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           _1 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageLive(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           _2 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          _5 = CheckedAdd(const u8::MAX, const 1_u8); // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-          assert(!move (_5.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const u8::MAX, const 1_u8) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          _3 = CheckedAdd(const u8::MAX, const 1_u8); // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+          assert(!move (_3.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const u8::MAX, const 1_u8) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n       }\n   \n       bb1: {\n+          StorageDead(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n+          StorageDead(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           return;                          // scope 0 at $DIR/inherit_overflow.rs:+4:2: +4:2\n       }\n   }"}, {"sha": "c1a42a47ed218ceafc483acc7ead333e4e948b69", "filename": "tests/mir-opt/dont_yeet_assert.generic.InstCombine.diff", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fdont_yeet_assert.generic.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fdont_yeet_assert.generic.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdont_yeet_assert.generic.InstCombine.diff?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -0,0 +1,23 @@\n+- // MIR for `generic` before InstCombine\n++ // MIR for `generic` after InstCombine\n+  \n+  fn generic() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/dont_yeet_assert.rs:+0:21: +0:21\n+      let _1: ();                          // in scope 0 at $DIR/dont_yeet_assert.rs:+1:5: +1:61\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/dont_yeet_assert.rs:+1:5: +1:61\n+          _1 = assert_mem_uninitialized_valid::<&T>() -> bb1; // scope 0 at $DIR/dont_yeet_assert.rs:+1:5: +1:61\n+                                           // mir::Constant\n+                                           // + span: $DIR/dont_yeet_assert.rs:10:5: 10:59\n+                                           // + user_ty: UserType(0)\n+                                           // + literal: Const { ty: extern \"rust-intrinsic\" fn() {assert_mem_uninitialized_valid::<&T>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_1);                 // scope 0 at $DIR/dont_yeet_assert.rs:+1:61: +1:62\n+          _0 = const ();                   // scope 0 at $DIR/dont_yeet_assert.rs:+0:21: +2:2\n+          return;                          // scope 0 at $DIR/dont_yeet_assert.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "7cec761eabac1d7c79ddd77b081f9c6ba9bb7738", "filename": "tests/mir-opt/dont_yeet_assert.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fdont_yeet_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fdont_yeet_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdont_yeet_assert.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -0,0 +1,11 @@\n+// compile-flags: --crate-type=lib\n+// unit-test: InstCombine\n+\n+#![feature(core_intrinsics)]\n+\n+// Want to make sure this assertion isn't compiled away in generic code.\n+\n+// EMIT_MIR dont_yeet_assert.generic.InstCombine.diff\n+pub fn generic<T>() {\n+    core::intrinsics::assert_mem_uninitialized_valid::<&T>();\n+}"}, {"sha": "01f5052b6528702ff4b99e127b6222a8f5c978c3", "filename": "tests/mir-opt/inline/inline_generator.main.Inline.diff", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -7,29 +7,27 @@\n       let mut _2: std::pin::Pin<&mut [generator@$DIR/inline_generator.rs:15:5: 15:8]>; // in scope 0 at $DIR/inline_generator.rs:+1:14: +1:32\n       let mut _3: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 0 at $DIR/inline_generator.rs:+1:23: +1:31\n       let mut _4: [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 0 at $DIR/inline_generator.rs:+1:28: +1:31\n-+     let mut _7: bool;                    // in scope 0 at $DIR/inline_generator.rs:+1:33: +1:46\n++     let mut _5: bool;                    // in scope 0 at $DIR/inline_generator.rs:+1:33: +1:46\n       scope 1 {\n           debug _r => _1;                  // in scope 1 at $DIR/inline_generator.rs:+1:9: +1:11\n       }\n +     scope 2 (inlined g) {                // at $DIR/inline_generator.rs:9:28: 9:31\n +     }\n +     scope 3 (inlined Pin::<&mut [generator@$DIR/inline_generator.rs:15:5: 15:8]>::new) { // at $DIR/inline_generator.rs:9:14: 9:32\n +         debug pointer => _3;             // in scope 3 at $SRC_DIR/core/src/pin.rs:LL:COL\n-+         let mut _5: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 3 at $SRC_DIR/core/src/pin.rs:LL:COL\n +         scope 4 {\n +             scope 5 (inlined Pin::<&mut [generator@$DIR/inline_generator.rs:15:5: 15:8]>::new_unchecked) { // at $SRC_DIR/core/src/pin.rs:LL:COL\n-+                 debug pointer => _5;     // in scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n-+                 let mut _6: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n++                 debug pointer => _3;     // in scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n +             }\n +         }\n +     }\n +     scope 6 (inlined g::{closure#0}) {   // at $DIR/inline_generator.rs:9:33: 9:46\n-+         debug a => _7;                   // in scope 6 at $DIR/inline_generator.rs:15:6: 15:7\n-+         let mut _8: i32;                 // in scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n-+         let mut _9: u32;                 // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         debug a => _5;                   // in scope 6 at $DIR/inline_generator.rs:15:6: 15:7\n++         let mut _6: i32;                 // in scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n++         let mut _7: u32;                 // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         let mut _8: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         let mut _9: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n +         let mut _10: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         let mut _11: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         let mut _12: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n +     }\n   \n       bb0: {\n@@ -64,28 +62,22 @@\n -     }\n - \n -     bb2: {\n-+         StorageLive(_5);                 // scope 4 at $SRC_DIR/core/src/pin.rs:LL:COL\n-+         _5 = move _3;                    // scope 4 at $SRC_DIR/core/src/pin.rs:LL:COL\n-+         StorageLive(_6);                 // scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n-+         _6 = move _5;                    // scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n-+         _2 = Pin::<&mut [generator@$DIR/inline_generator.rs:15:5: 15:8]> { pointer: move _6 }; // scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n-+         StorageDead(_6);                 // scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n-+         StorageDead(_5);                 // scope 4 at $SRC_DIR/core/src/pin.rs:LL:COL\n++         _2 = Pin::<&mut [generator@$DIR/inline_generator.rs:15:5: 15:8]> { pointer: move _3 }; // scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n           StorageDead(_3);                 // scope 0 at $DIR/inline_generator.rs:+1:31: +1:32\n -         _1 = <[generator@$DIR/inline_generator.rs:15:5: 15:8] as Generator<bool>>::resume(move _2, const false) -> [return: bb3, unwind: bb4]; // scope 0 at $DIR/inline_generator.rs:+1:14: +1:46\n -                                          // mir::Constant\n -                                          // + span: $DIR/inline_generator.rs:9:33: 9:39\n -                                          // + literal: Const { ty: for<'a> fn(Pin<&'a mut [generator@$DIR/inline_generator.rs:15:5: 15:8]>, bool) -> GeneratorState<<[generator@$DIR/inline_generator.rs:15:5: 15:8] as Generator<bool>>::Yield, <[generator@$DIR/inline_generator.rs:15:5: 15:8] as Generator<bool>>::Return> {<[generator@$DIR/inline_generator.rs:15:5: 15:8] as Generator<bool>>::resume}, val: Value(<ZST>) }\n-+         StorageLive(_7);                 // scope 0 at $DIR/inline_generator.rs:+1:33: +1:46\n-+         _7 = const false;                // scope 0 at $DIR/inline_generator.rs:+1:33: +1:46\n-+         _10 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         _9 = discriminant((*_10));       // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         switchInt(move _9) -> [0: bb3, 1: bb8, 3: bb7, otherwise: bb9]; // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         StorageLive(_5);                 // scope 0 at $DIR/inline_generator.rs:+1:33: +1:46\n++         _5 = const false;                // scope 0 at $DIR/inline_generator.rs:+1:33: +1:46\n++         _8 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         _7 = discriminant((*_8));        // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         switchInt(move _7) -> [0: bb3, 1: bb8, 3: bb7, otherwise: bb9]; // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n       }\n   \n -     bb3: {\n +     bb1: {\n-+         StorageDead(_7);                 // scope 0 at $DIR/inline_generator.rs:+1:33: +1:46\n++         StorageDead(_5);                 // scope 0 at $DIR/inline_generator.rs:+1:33: +1:46\n           StorageDead(_2);                 // scope 0 at $DIR/inline_generator.rs:+1:45: +1:46\n           StorageDead(_4);                 // scope 0 at $DIR/inline_generator.rs:+1:46: +1:47\n           _0 = const ();                   // scope 0 at $DIR/inline_generator.rs:+0:11: +2:2\n@@ -99,33 +91,33 @@\n +     }\n + \n +     bb3: {\n-+         StorageLive(_8);                 // scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n-+         switchInt(_7) -> [0: bb5, otherwise: bb4]; // scope 6 at $DIR/inline_generator.rs:15:20: 15:21\n++         StorageLive(_6);                 // scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n++         switchInt(_5) -> [0: bb5, otherwise: bb4]; // scope 6 at $DIR/inline_generator.rs:15:20: 15:21\n +     }\n + \n +     bb4: {\n-+         _8 = const 7_i32;                // scope 6 at $DIR/inline_generator.rs:15:24: 15:25\n++         _6 = const 7_i32;                // scope 6 at $DIR/inline_generator.rs:15:24: 15:25\n +         goto -> bb6;                     // scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n +     }\n + \n +     bb5: {\n-+         _8 = const 13_i32;               // scope 6 at $DIR/inline_generator.rs:15:35: 15:37\n++         _6 = const 13_i32;               // scope 6 at $DIR/inline_generator.rs:15:35: 15:37\n +         goto -> bb6;                     // scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n +     }\n + \n +     bb6: {\n-+         _1 = GeneratorState::<i32, bool>::Yielded(move _8); // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n-+         _11 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n-+         discriminant((*_11)) = 3;        // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n++         _1 = GeneratorState::<i32, bool>::Yielded(move _6); // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n++         _9 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n++         discriminant((*_9)) = 3;         // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n +         goto -> bb1;                     // scope 0 at $DIR/inline_generator.rs:15:11: 15:39\n +     }\n + \n +     bb7: {\n-+         StorageLive(_8);                 // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         StorageDead(_8);                 // scope 6 at $DIR/inline_generator.rs:15:38: 15:39\n-+         _1 = GeneratorState::<i32, bool>::Complete(_7); // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n-+         _12 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n-+         discriminant((*_12)) = 1;        // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n++         StorageLive(_6);                 // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         StorageDead(_6);                 // scope 6 at $DIR/inline_generator.rs:15:38: 15:39\n++         _1 = GeneratorState::<i32, bool>::Complete(_5); // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n++         _10 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n++         discriminant((*_10)) = 1;        // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n +         goto -> bb1;                     // scope 0 at $DIR/inline_generator.rs:15:41: 15:41\n +     }\n + "}, {"sha": "6db8e4d2664723cb08ef05acb1e33e088a974641", "filename": "tests/mir-opt/issue_101973.inner.ConstProp.diff", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -26,13 +26,12 @@\n       scope 3 (inlined core::num::<impl u32>::rotate_right) { // at $DIR/issue_101973.rs:14:18: 14:58\n           debug self => _4;                // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n           debug n => _6;                   // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-          let mut _15: u32;                // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-          let mut _16: u32;                // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n       }\n   \n       bb0: {\n           StorageLive(_2);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:65\n           StorageLive(_3);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:58\n+          StorageLive(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:17\n           StorageLive(_12);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n           StorageLive(_13);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n           _14 = CheckedShr(_1, const 0_i32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n@@ -62,13 +61,16 @@\n           StorageDead(_13);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n           _4 = BitOr(const 0_u32, move _12); // scope 2 at $DIR/issue_101973.rs:7:5: 7:27\n           StorageDead(_12);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n+          StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n           StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n           _10 = CheckedShr(_1, const 8_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n           assert(!move (_10.1: bool), \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       }\n   \n       bb4: {\n+          StorageDead(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:57: +1:58\n+          StorageDead(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:57: +1:58\n           _2 = move _3 as i32 (IntToInt);  // scope 0 at $DIR/issue_101973.rs:+1:5: +1:65\n           StorageDead(_3);                 // scope 0 at $DIR/issue_101973.rs:+1:64: +1:65\n           _0 = move _2 as i64 (IntToInt);  // scope 0 at $DIR/issue_101973.rs:+1:5: +1:72"}, {"sha": "291fc5063d28ce75a16988ec82e9c4c02fd9f429", "filename": "tests/mir-opt/issues/issue_59352.num_to_digit.PreCodegen.after.mir", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -5,15 +5,14 @@ fn num_to_digit(_1: char) -> u32 {\n     let mut _0: u32;                     // return place in scope 0 at $DIR/issue_59352.rs:+0:35: +0:38\n     let mut _2: std::option::Option<u32>; // in scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n     let mut _3: u32;                     // in scope 0 at $DIR/issue_59352.rs:+2:12: +2:23\n-    let mut _9: isize;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n     scope 1 (inlined char::methods::<impl char>::is_digit) { // at $DIR/issue_59352.rs:14:12: 14:23\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         debug radix => _3;               // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         let mut _4: &std::option::Option<u32>; // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         let _5: std::option::Option<u32>; // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        let mut _6: char;                // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         scope 2 (inlined Option::<u32>::is_some) { // at $SRC_DIR/core/src/char/methods.rs:LL:COL\n             debug self => _4;            // in scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n+            let mut _6: isize;           // in scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n         }\n     }\n     scope 3 (inlined #[track_caller] Option::<u32>::unwrap) { // at $DIR/issue_59352.rs:14:42: 14:50\n@@ -29,17 +28,15 @@ fn num_to_digit(_1: char) -> u32 {\n         StorageLive(_3);                 // scope 0 at $DIR/issue_59352.rs:+2:12: +2:23\n         StorageLive(_4);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         StorageLive(_5);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        StorageLive(_6);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        _6 = _1;                         // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        _5 = char::methods::<impl char>::to_digit(move _6, const 8_u32) -> bb5; // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        _5 = char::methods::<impl char>::to_digit(_1, const 8_u32) -> bb5; // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/char/methods.rs:LL:COL\n                                          // + literal: Const { ty: fn(char, u32) -> Option<u32> {char::methods::<impl char>::to_digit}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n         StorageLive(_2);                 // scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n-        _2 = char::methods::<impl char>::to_digit(move _1, const 8_u32) -> bb2; // scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n+        _2 = char::methods::<impl char>::to_digit(_1, const 8_u32) -> bb2; // scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n                                          // mir::Constant\n                                          // + span: $DIR/issue_59352.rs:14:30: 14:38\n                                          // + literal: Const { ty: fn(char, u32) -> Option<u32> {char::methods::<impl char>::to_digit}, val: Value(<ZST>) }\n@@ -61,12 +58,11 @@ fn num_to_digit(_1: char) -> u32 {\n \n     bb5: {\n         _4 = &_5;                        // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        StorageDead(_6);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        _9 = discriminant((*_4));        // scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n+        _6 = discriminant((*_4));        // scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n         StorageDead(_4);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         StorageDead(_5);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         StorageDead(_3);                 // scope 0 at $DIR/issue_59352.rs:+2:12: +2:23\n-        switchInt(move _9) -> [1: bb1, otherwise: bb3]; // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n+        switchInt(move _6) -> [1: bb1, otherwise: bb3]; // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n     }\n \n     bb6: {"}, {"sha": "cfcd43093c079c9dd1c62f933802ad14daed2aaf", "filename": "tests/mir-opt/separate_const_switch.identity.SeparateConstSwitch.diff", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -12,18 +12,18 @@\n       let mut _7: !;                       // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n       let mut _8: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n       let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+      let mut _16: i32;                    // in scope 0 at $SRC_DIR/core/src/result.rs:LL:COL\n       scope 1 {\n           debug residual => _6;            // in scope 1 at $DIR/separate_const_switch.rs:+1:9: +1:10\n           scope 2 {\n               scope 8 (inlined #[track_caller] <Result<i32, i32> as FromResidual<Result<Infallible, i32>>>::from_residual) { // at $DIR/separate_const_switch.rs:25:8: 25:10\n                   debug residual => _8;    // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let _16: i32;            // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _17: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _18: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+                  let _14: i32;            // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+                  let mut _15: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n                   scope 9 {\n-                      debug e => _16;      // in scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+                      debug e => _14;      // in scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n                       scope 10 (inlined <i32 as From<i32>>::from) { // at $SRC_DIR/core/src/result.rs:LL:COL\n-                          debug t => _18;  // in scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                          debug t => _16;  // in scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n                       }\n                   }\n               }\n@@ -38,15 +38,13 @@\n           debug self => _4;                // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n           let mut _10: isize;              // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n           let _11: i32;                    // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let mut _12: i32;                // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let _13: i32;                    // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let mut _14: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let mut _15: i32;                // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          let _12: i32;                    // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          let mut _13: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n           scope 6 {\n               debug v => _11;              // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n           }\n           scope 7 {\n-              debug e => _13;              // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+              debug e => _12;              // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n           }\n       }\n   \n@@ -55,11 +53,15 @@\n           StorageLive(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n           _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n+          StorageLive(_11);                // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+          StorageLive(_12);                // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           _10 = discriminant(_4);          // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n           switchInt(move _10) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   \n       bb1: {\n+          StorageDead(_12);                // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+          StorageDead(_11);                // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n           _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n@@ -85,16 +87,16 @@\n           _6 = ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>); // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n           StorageLive(_8);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n           _8 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          StorageLive(_16);                // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _16 = move ((_8 as Err).0: i32); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_17);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_18);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _18 = move _16;                  // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _17 = move _18;                  // scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-          StorageDead(_18);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _0 = Result::<i32, i32>::Err(move _17); // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_17);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_16);                // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageLive(_14);                // scope 2 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+          _14 = move ((_8 as Err).0: i32); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageLive(_15);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageLive(_16);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _16 = move _14;                  // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _15 = move _16;                  // scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+          StorageDead(_16);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _0 = Result::<i32, i32>::Err(move _15); // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageDead(_15);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageDead(_14);                // scope 2 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           StorageDead(_8);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n           StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n           StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:10: +1:11\n@@ -103,16 +105,11 @@\n       }\n   \n       bb5: {\n-          StorageLive(_13);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _13 = move ((_4 as Err).0: i32); // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_14);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_15);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _15 = move _13;                  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _14 = Result::<Infallible, i32>::Err(move _15); // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_15);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _3 = ControlFlow::<Result<Infallible, i32>, i32>::Break(move _14); // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_14);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_13);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _12 = move ((_4 as Err).0: i32); // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageLive(_13);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _13 = Result::<Infallible, i32>::Err(move _12); // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _3 = ControlFlow::<Result<Infallible, i32>, i32>::Break(move _13); // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageDead(_13);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n           goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   \n@@ -121,13 +118,8 @@\n       }\n   \n       bb7: {\n-          StorageLive(_11);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n           _11 = move ((_4 as Ok).0: i32);  // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_12);                // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _12 = move _11;                  // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _3 = ControlFlow::<Result<Infallible, i32>, i32>::Continue(move _12); // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_12);                // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_11);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _3 = ControlFlow::<Result<Infallible, i32>, i32>::Continue(move _11); // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n           goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   }"}, {"sha": "f908e8dd0c1f83ea66cb186e8cfd4cbea9590896", "filename": "tests/mir-opt/simplify_locals_fixedpoint.foo.SimplifyLocals-final.diff", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals-final.diff", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals-final.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals-final.diff?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -34,15 +34,10 @@\n       }\n   \n       bb2: {\n-          StorageLive(_6);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:18: +1:19\n           _6 = (((_1.0: std::option::Option<u8>) as Some).0: u8); // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:18: +1:19\n -         StorageLive(_7);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+2:12: +2:20\n--         StorageLive(_8);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+2:12: +2:13\n--         _8 = _6;                         // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+2:12: +2:13\n--         _7 = Gt(move _8, const 42_u8);   // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+2:12: +2:20\n--         StorageDead(_8);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+2:19: +2:20\n+-         _7 = Gt(_6, const 42_u8);        // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+2:12: +2:20\n -         StorageDead(_7);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+4:9: +4:10\n-          StorageDead(_6);                 // scope 0 at $DIR/simplify_locals_fixedpoint.rs:+5:5: +5:6\n           goto -> bb3;                     // scope 0 at $DIR/simplify_locals_fixedpoint.rs:+1:5: +5:6\n       }\n   "}, {"sha": "3bb0358ffe3e610569151c8294af15a727e2c89e", "filename": "tests/mir-opt/slice_filter.variant_a-{closure#0}.CopyProp.diff", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.CopyProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.CopyProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.CopyProp.diff?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -29,6 +29,14 @@\n       let mut _26: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n       let mut _27: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n       let mut _28: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n+      let mut _31: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+      let mut _32: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+      let mut _37: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+      let mut _38: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+      let mut _43: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+      let mut _44: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+      let mut _49: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+      let mut _50: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n       scope 1 {\n           debug a => _3;                   // in scope 1 at $DIR/slice_filter.rs:+0:27: +0:28\n           debug b => _4;                   // in scope 1 at $DIR/slice_filter.rs:+0:30: +0:31\n@@ -39,13 +47,11 @@\n               debug other => _10;          // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               let mut _29: &usize;         // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               let mut _30: &usize;         // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _31: &usize;         // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _32: &usize;         // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               scope 3 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _29;       // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _30;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => _31;       // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => _32;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-                 debug self => _31;       // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-                 debug other => _32;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++                 debug self => _29;       // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++                 debug other => _30;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n                   let mut _33: usize;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n                   let mut _34: usize;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               }\n@@ -55,13 +61,11 @@\n               debug other => _19;          // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               let mut _35: &usize;         // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               let mut _36: &usize;         // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _37: &usize;         // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _38: &usize;         // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               scope 5 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _35;       // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _36;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => _37;       // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => _38;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-                 debug self => _37;       // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-                 debug other => _38;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++                 debug self => _35;       // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++                 debug other => _36;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n                   let mut _39: usize;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n                   let mut _40: usize;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               }\n@@ -71,13 +75,11 @@\n               debug other => _14;          // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               let mut _41: &usize;         // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               let mut _42: &usize;         // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _43: &usize;         // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _44: &usize;         // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               scope 7 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _41;       // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _42;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => _43;       // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => _44;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-                 debug self => _43;       // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-                 debug other => _44;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++                 debug self => _41;       // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++                 debug other => _42;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n                   let mut _45: usize;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n                   let mut _46: usize;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               }\n@@ -87,13 +89,11 @@\n               debug other => _23;          // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               let mut _47: &usize;         // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               let mut _48: &usize;         // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _49: &usize;         // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _50: &usize;         // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               scope 9 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _47;       // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _48;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => _49;       // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => _50;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-                 debug self => _49;       // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-                 debug other => _50;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++                 debug self => _47;       // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++                 debug other => _48;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n                   let mut _51: usize;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n                   let mut _52: usize;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n               }\n@@ -121,23 +121,23 @@\n           StorageLive(_11);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n           _11 = _5;                        // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n           _10 = &_11;                      // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n--         StorageLive(_29);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _31 = deref_copy (*_9);          // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _29 = _31;                       // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_30);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _32 = deref_copy (*_10);         // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _30 = _32;                       // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+          _29 = deref_copy (*_9);          // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+          _30 = deref_copy (*_10);         // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageLive(_31);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _31 = _29;                       // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageLive(_32);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _32 = _30;                       // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageLive(_33);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _33 = (*_29);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _33 = (*_31);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _33 = (*_31);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++         _33 = (*_29);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageLive(_34);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _34 = (*_30);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _34 = (*_32);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _34 = (*_32);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++         _34 = (*_30);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           _8 = Le(move _33, move _34);     // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_34);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_33);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_30);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_29);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageDead(_32);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageDead(_31);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_11);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n           StorageDead(_10);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n           StorageDead(_9);                 // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n@@ -158,23 +158,23 @@\n           StorageLive(_20);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n           _20 = _3;                        // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n           _19 = &_20;                      // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n--         StorageLive(_35);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _37 = deref_copy (*_18);         // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _35 = _37;                       // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_36);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _38 = deref_copy (*_19);         // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _36 = _38;                       // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+          _35 = deref_copy (*_18);         // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+          _36 = deref_copy (*_19);         // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageLive(_37);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _37 = _35;                       // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageLive(_38);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _38 = _36;                       // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageLive(_39);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _39 = (*_35);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _39 = (*_37);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _39 = (*_37);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++         _39 = (*_35);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageLive(_40);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _40 = (*_36);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _40 = (*_38);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _40 = (*_38);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++         _40 = (*_36);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           _17 = Le(move _39, move _40);    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_40);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_39);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_36);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_35);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageDead(_38);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageDead(_37);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_20);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n           StorageDead(_19);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n           StorageDead(_18);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n@@ -206,23 +206,23 @@\n           StorageLive(_15);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n           _15 = _4;                        // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n           _14 = &_15;                      // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n--         StorageLive(_41);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _43 = deref_copy (*_13);         // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _41 = _43;                       // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_42);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _44 = deref_copy (*_14);         // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _42 = _44;                       // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+          _41 = deref_copy (*_13);         // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+          _42 = deref_copy (*_14);         // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageLive(_43);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _43 = _41;                       // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageLive(_44);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _44 = _42;                       // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageLive(_45);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _45 = (*_41);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _45 = (*_43);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _45 = (*_43);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++         _45 = (*_41);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageLive(_46);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _46 = (*_42);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _46 = (*_44);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _46 = (*_44);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++         _46 = (*_42);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           _12 = Le(move _45, move _46);    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_46);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_45);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_42);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_41);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageDead(_44);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageDead(_43);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_15);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n           StorageDead(_14);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n           StorageDead(_13);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n@@ -245,23 +245,23 @@\n           StorageLive(_24);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n           _24 = _6;                        // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n           _23 = &_24;                      // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n--         StorageLive(_47);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _49 = deref_copy (*_22);         // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _47 = _49;                       // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_48);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _50 = deref_copy (*_23);         // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _48 = _50;                       // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+          _47 = deref_copy (*_22);         // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+          _48 = deref_copy (*_23);         // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageLive(_49);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _49 = _47;                       // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageLive(_50);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _50 = _48;                       // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageLive(_51);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _51 = (*_47);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _51 = (*_49);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _51 = (*_49);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++         _51 = (*_47);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageLive(_52);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _52 = (*_48);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _52 = (*_50);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         _52 = (*_50);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n++         _52 = (*_48);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           _21 = Le(move _51, move _52);    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_52);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_51);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_48);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_47);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageDead(_50);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+-         StorageDead(_49);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n           StorageDead(_24);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n           StorageDead(_23);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n           StorageDead(_22);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76"}, {"sha": "e451cb03126ccc4ff036bf590491bce9c961a76f", "filename": "tests/run-make-fulldeps/issues-41478-43796/Makefile", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2FMakefile?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,8 +0,0 @@\n-include ../tools.mk\n-\n-all:\n-\t# Work in /tmp, because we need to create the `save-analysis-temp` folder.\n-\tcp a.rs $(TMPDIR)/\n-\tcd $(TMPDIR) && $(RUSTC) -Zsave-analysis $(TMPDIR)/a.rs 2> $(TMPDIR)/stderr.txt || ( cat $(TMPDIR)/stderr.txt && exit 1 )\n-\t[ ! -s $(TMPDIR)/stderr.txt ] || ( cat $(TMPDIR)/stderr.txt && exit 1 )\n-\t[ -f $(TMPDIR)/save-analysis/liba.json ] || ( ls -la $(TMPDIR) && exit 1 )"}, {"sha": "b072235b5bc5ad21f87ed52d5ca24bd4362ebd3e", "filename": "tests/run-make-fulldeps/issues-41478-43796/a.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fissues-41478-43796%2Fa.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,9 +0,0 @@\n-#![crate_type = \"lib\"]\n-pub struct V<S>(#[allow(unused_tuple_struct_fields)] S);\n-pub trait An {\n-    type U;\n-}\n-pub trait F<A> {\n-}\n-impl<A: An> F<A> for V<<A as An>::U> {\n-}"}, {"sha": "69a2b2746948bb9d801ae44862b1062b82a92bd9", "filename": "tests/run-make-fulldeps/save-analysis-fail/Makefile", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FMakefile?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,6 +0,0 @@\n-include ../tools.mk\n-all: code\n-krate2: krate2.rs\n-\t$(RUSTC) $<\n-code: foo.rs krate2\n-\t$(RUSTC) foo.rs -Zsave-analysis || exit 0"}, {"sha": "2c690d5f759d785263aaf0a7c30fdf319a76dcd4", "filename": "tests/run-make-fulldeps/save-analysis-fail/SameDir.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,5 +0,0 @@\n-// sub-module in the same directory as the main crate file\n-\n-pub struct SameStruct {\n-    pub name: String\n-}"}, {"sha": "fab03ee2e3d15d6dc55bea42c2d4abc7dea7fbb8", "filename": "tests/run-make-fulldeps/save-analysis-fail/SameDir3.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSameDir3.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,3 +0,0 @@\n-pub fn hello(x: isize) {\n-    println!(\"macro {} :-(\", x);\n-}"}, {"sha": "511721d92a350f4adede0e99a16c45b9373777d7", "filename": "tests/run-make-fulldeps/save-analysis-fail/SubDir/mod.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSubDir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSubDir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2FSubDir%2Fmod.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,27 +0,0 @@\n-// sub-module in a sub-directory\n-\n-use sub::sub2 as msalias;\n-use sub::sub2;\n-\n-static yy: usize = 25;\n-\n-mod sub {\n-    pub mod sub2 {\n-        pub mod sub3 {\n-            pub fn hello() {\n-                println!(\"hello from module 3\");\n-            }\n-        }\n-        pub fn hello() {\n-            println!(\"hello from a module\");\n-        }\n-\n-        pub struct nested_struct {\n-            pub field2: u32,\n-        }\n-    }\n-}\n-\n-pub struct SubStruct {\n-    pub name: String\n-}"}, {"sha": "c5a70605e04cb2c9a6839d060947cec8c6182f2c", "filename": "tests/run-make-fulldeps/save-analysis-fail/foo.rs", "status": "removed", "additions": 0, "deletions": 463, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Ffoo.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,463 +0,0 @@\n-#![crate_name = \"test\"]\n-#![feature(rustc_private)]\n-\n-extern crate rustc_graphviz;\n-// A simple rust project\n-\n-extern crate krate2;\n-extern crate krate2 as krate3;\n-\n-use rustc_graphviz::RenderOption;\n-use std::cell::RefCell;\n-use std::collections::{HashMap, HashSet};\n-use std::io::Write;\n-\n-use sub::sub2 as msalias;\n-use sub::sub2;\n-use sub::sub2::nested_struct as sub_struct;\n-\n-use std::mem::size_of;\n-\n-use std::char::from_u32;\n-\n-static uni: &'static str = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n-static yy: usize = 25;\n-\n-static bob: Option<graphviz::RenderOption> = None;\n-\n-// buglink test - see issue #1337.\n-\n-fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n-    let s = sub_struct { field2: 45u32 };\n-\n-    // import tests\n-    fn foo(x: &Write) {}\n-    let _: Option<_> = from_u32(45);\n-\n-    let x = 42usize;\n-\n-    krate2::hello();\n-    krate3::hello();\n-\n-    let x = (3isize, 4usize);\n-    let y = x.1;\n-}\n-\n-// Issue #37700\n-const LUT_BITS: usize = 3;\n-pub struct HuffmanTable {\n-    ac_lut: Option<[(i16, u8); 1 << LUT_BITS]>,\n-}\n-\n-struct TupStruct(isize, isize, Box<str>);\n-\n-fn test_tup_struct(x: TupStruct) -> isize {\n-    x.1\n-}\n-\n-fn println(s: &str) {\n-    std::io::stdout().write_all(s.as_bytes());\n-}\n-\n-mod sub {\n-    pub mod sub2 {\n-        use std::io::Write;\n-        pub mod sub3 {\n-            use std::io::Write;\n-            pub fn hello() {\n-                ::println(\"hello from module 3\");\n-            }\n-        }\n-        pub fn hello() {\n-            ::println(\"hello from a module\");\n-        }\n-\n-        pub struct nested_struct {\n-            pub field2: u32,\n-        }\n-\n-        pub enum nested_enum {\n-            Nest2 = 2,\n-            Nest3 = 3,\n-        }\n-    }\n-}\n-\n-pub mod SameDir;\n-pub mod SubDir;\n-\n-#[path = \"SameDir3.rs\"]\n-pub mod SameDir2;\n-\n-struct nofields;\n-\n-#[derive(Clone)]\n-struct some_fields {\n-    field1: u32,\n-}\n-\n-type SF = some_fields;\n-\n-trait SuperTrait {\n-    fn qux(&self) {\n-        panic!();\n-    }\n-}\n-\n-trait SomeTrait: SuperTrait {\n-    fn Method(&self, x: u32) -> u32;\n-\n-    fn prov(&self, x: u32) -> u32 {\n-        println(&x.to_string());\n-        42\n-    }\n-    fn provided_method(&self) -> u32 {\n-        42\n-    }\n-}\n-\n-trait SubTrait: SomeTrait {\n-    fn stat2(x: &Self) -> u32 {\n-        32\n-    }\n-}\n-\n-trait SizedTrait: Sized {}\n-\n-fn error(s: &SizedTrait) {\n-    let foo = 42;\n-    println!(\"Hello world! {}\", foo);\n-}\n-\n-impl SomeTrait for some_fields {\n-    fn Method(&self, x: u32) -> u32 {\n-        println(&x.to_string());\n-        self.field1\n-    }\n-}\n-\n-impl SuperTrait for some_fields {}\n-\n-impl SubTrait for some_fields {}\n-\n-impl some_fields {\n-    fn stat(x: u32) -> u32 {\n-        println(&x.to_string());\n-        42\n-    }\n-    fn stat2(x: &some_fields) -> u32 {\n-        42\n-    }\n-\n-    fn align_to<T>(&mut self) {}\n-\n-    fn test(&mut self) {\n-        self.align_to::<bool>();\n-    }\n-}\n-\n-impl SuperTrait for nofields {}\n-impl SomeTrait for nofields {\n-    fn Method(&self, x: u32) -> u32 {\n-        self.Method(x);\n-        43\n-    }\n-\n-    fn provided_method(&self) -> u32 {\n-        21\n-    }\n-}\n-\n-impl SubTrait for nofields {}\n-\n-impl SuperTrait for (Box<nofields>, Box<some_fields>) {}\n-\n-fn f_with_params<T: SomeTrait>(x: &T) {\n-    x.Method(41);\n-}\n-\n-type MyType = Box<some_fields>;\n-\n-enum SomeEnum<'a> {\n-    Ints(isize, isize),\n-    Floats(f64, f64),\n-    Strings(&'a str, &'a str, &'a str),\n-    MyTypes(MyType, MyType),\n-}\n-\n-#[derive(Copy, Clone)]\n-enum SomeOtherEnum {\n-    SomeConst1,\n-    SomeConst2,\n-    SomeConst3,\n-}\n-\n-enum SomeStructEnum {\n-    EnumStruct { a: isize, b: isize },\n-    EnumStruct2 { f1: MyType, f2: MyType },\n-    EnumStruct3 { f1: MyType, f2: MyType, f3: SomeEnum<'static> },\n-}\n-\n-fn matchSomeEnum(val: SomeEnum) {\n-    match val {\n-        SomeEnum::Ints(int1, int2) => {\n-            println(&(int1 + int2).to_string());\n-        }\n-        SomeEnum::Floats(float1, float2) => {\n-            println(&(float2 * float1).to_string());\n-        }\n-        SomeEnum::Strings(.., s3) => {\n-            println(s3);\n-        }\n-        SomeEnum::MyTypes(mt1, mt2) => {\n-            println(&(mt1.field1 - mt2.field1).to_string());\n-        }\n-    }\n-}\n-\n-fn matchSomeStructEnum(se: SomeStructEnum) {\n-    match se {\n-        SomeStructEnum::EnumStruct { a: a, .. } => println(&a.to_string()),\n-        SomeStructEnum::EnumStruct2 { f1: f1, f2: f_2 } => println(&f_2.field1.to_string()),\n-        SomeStructEnum::EnumStruct3 { f1, .. } => println(&f1.field1.to_string()),\n-    }\n-}\n-\n-fn matchSomeStructEnum2(se: SomeStructEnum) {\n-    use SomeStructEnum::*;\n-    match se {\n-        EnumStruct { a: ref aaa, .. } => println(&aaa.to_string()),\n-        EnumStruct2 { f1, f2: f2 } => println(&f1.field1.to_string()),\n-        EnumStruct3 { f1, f3: SomeEnum::Ints(..), f2 } => println(&f1.field1.to_string()),\n-        _ => {}\n-    }\n-}\n-\n-fn matchSomeOtherEnum(val: SomeOtherEnum) {\n-    use SomeOtherEnum::{SomeConst2, SomeConst3};\n-    match val {\n-        SomeOtherEnum::SomeConst1 => {\n-            println(\"I'm const1.\");\n-        }\n-        SomeConst2 | SomeConst3 => {\n-            println(\"I'm const2 or const3.\");\n-        }\n-    }\n-}\n-\n-fn hello<X: SomeTrait>((z, a): (u32, String), ex: X) {\n-    SameDir2::hello(43);\n-\n-    println(&yy.to_string());\n-    let (x, y): (u32, u32) = (5, 3);\n-    println(&x.to_string());\n-    println(&z.to_string());\n-    let x: u32 = x;\n-    println(&x.to_string());\n-    let x = \"hello\";\n-    println(x);\n-\n-    let x = 32.0f32;\n-    let _ = (x + ((x * x) + 1.0).sqrt()).ln();\n-\n-    let s: Box<SomeTrait> = Box::new(some_fields { field1: 43 });\n-    let s2: Box<some_fields> = Box::new(some_fields { field1: 43 });\n-    let s3 = Box::new(nofields);\n-\n-    s.Method(43);\n-    s3.Method(43);\n-    s2.Method(43);\n-\n-    ex.prov(43);\n-\n-    let y: u32 = 56;\n-    // static method on struct\n-    let r = some_fields::stat(y);\n-    // trait static method, calls default\n-    let r = SubTrait::stat2(&*s3);\n-\n-    let s4 = s3 as Box<SomeTrait>;\n-    s4.Method(43);\n-\n-    s4.provided_method();\n-    s2.prov(45);\n-\n-    let closure = |x: u32, s: &SomeTrait| {\n-        s.Method(23);\n-        return x + y;\n-    };\n-\n-    let z = closure(10, &*s);\n-}\n-\n-pub struct blah {\n-    used_link_args: RefCell<[&'static str; 0]>,\n-}\n-\n-#[macro_use]\n-mod macro_use_test {\n-    macro_rules! test_rec {\n-        (q, $src: expr) => {{\n-            print!(\"{}\", $src);\n-            test_rec!($src);\n-        }};\n-        ($src: expr) => {\n-            print!(\"{}\", $src);\n-        };\n-    }\n-\n-    macro_rules! internal_vars {\n-        ($src: ident) => {{\n-            let mut x = $src;\n-            x += 100;\n-        }};\n-    }\n-}\n-\n-fn main() {\n-    // foo\n-    let s = Box::new(some_fields { field1: 43 });\n-    hello((43, \"a\".to_string()), *s);\n-    sub::sub2::hello();\n-    sub2::sub3::hello();\n-\n-    let h = sub2::sub3::hello;\n-    h();\n-\n-    // utf8 chars\n-    let ut = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n-\n-    // For some reason, this pattern of macro_rules foiled our generated code\n-    // avoiding strategy.\n-    macro_rules! variable_str(($name:expr) => (\n-        some_fields {\n-            field1: $name,\n-        }\n-    ));\n-    let vs = variable_str!(32);\n-\n-    let mut candidates: RefCell<HashMap<&'static str, &'static str>> = RefCell::new(HashMap::new());\n-    let _ = blah { used_link_args: RefCell::new([]) };\n-    let s1 = nofields;\n-    let s2 = SF { field1: 55 };\n-    let s3: some_fields = some_fields { field1: 55 };\n-    let s4: msalias::nested_struct = sub::sub2::nested_struct { field2: 55 };\n-    let s4: msalias::nested_struct = sub2::nested_struct { field2: 55 };\n-    println(&s2.field1.to_string());\n-    let s5: MyType = Box::new(some_fields { field1: 55 });\n-    let s = SameDir::SameStruct { name: \"Bob\".to_string() };\n-    let s = SubDir::SubStruct { name: \"Bob\".to_string() };\n-    let s6: SomeEnum = SomeEnum::MyTypes(Box::new(s2.clone()), s5);\n-    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n-    matchSomeEnum(s6);\n-    matchSomeEnum(s7);\n-    let s8: SomeOtherEnum = SomeOtherEnum::SomeConst2;\n-    matchSomeOtherEnum(s8);\n-    let s9: SomeStructEnum =\n-        SomeStructEnum::EnumStruct2 { f1: Box::new(some_fields { field1: 10 }), f2: Box::new(s2) };\n-    matchSomeStructEnum(s9);\n-\n-    for x in &vec![1, 2, 3] {\n-        let _y = x;\n-    }\n-\n-    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n-    if let SomeEnum::Strings(..) = s7 {\n-        println!(\"hello!\");\n-    }\n-\n-    for i in 0..5 {\n-        foo_foo(i);\n-    }\n-\n-    if let Some(x) = None {\n-        foo_foo(x);\n-    }\n-\n-    if false {\n-    } else if let Some(y) = None {\n-        foo_foo(y);\n-    }\n-\n-    while let Some(z) = None {\n-        foo_foo(z);\n-    }\n-\n-    let mut x = 4;\n-    test_rec!(q, \"Hello\");\n-    assert_eq!(x, 4);\n-    internal_vars!(x);\n-}\n-\n-fn foo_foo(_: i32) {}\n-\n-impl Iterator for nofields {\n-    type Item = (usize, usize);\n-\n-    fn next(&mut self) -> Option<(usize, usize)> {\n-        panic!()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        panic!()\n-    }\n-}\n-\n-trait Pattern<'a> {\n-    type Searcher;\n-}\n-\n-struct CharEqPattern;\n-\n-impl<'a> Pattern<'a> for CharEqPattern {\n-    type Searcher = CharEqPattern;\n-}\n-\n-struct CharSearcher<'a>(<CharEqPattern as Pattern<'a>>::Searcher);\n-\n-pub trait Error {}\n-\n-impl Error + 'static {\n-    pub fn is<T: Error + 'static>(&self) -> bool {\n-        panic!()\n-    }\n-}\n-\n-impl Error + 'static + Send {\n-    pub fn is<T: Error + 'static>(&self) -> bool {\n-        <Error + 'static>::is::<T>(self)\n-    }\n-}\n-extern crate serialize;\n-#[derive(Clone, Copy, Hash, Encodable, Decodable, PartialEq, Eq, PartialOrd, Ord, Debug, Default)]\n-struct AllDerives(i32);\n-\n-fn test_format_args() {\n-    let x = 1;\n-    let y = 2;\n-    let name = \"Joe Blogg\";\n-    println!(\"Hello {}\", name);\n-    print!(\"Hello {0}\", name);\n-    print!(\"{0} + {} = {}\", x, y);\n-    print!(\"x is {}, y is {1}, name is {n}\", x, y, n = name);\n-}\n-\n-extern \"C\" {\n-    static EXTERN_FOO: u8;\n-    fn extern_foo(a: u8, b: i32) -> String;\n-}\n-\n-struct Rls699 {\n-    f: u32,\n-}\n-\n-fn new(f: u32) -> Rls699 {\n-    Rls699 { fs }\n-}\n-\n-fn invalid_tuple_struct_access() {\n-    bar.0;\n-\n-    struct S;\n-    S.0;\n-}"}, {"sha": "7d787e0c9871f4d760dca5403f17fa42da972932", "filename": "tests/run-make-fulldeps/save-analysis-fail/krate2.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Fkrate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Fkrate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-fail%2Fkrate2.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,8 +0,0 @@\n-#![ crate_name = \"krate2\" ]\n-#![ crate_type = \"lib\" ]\n-\n-use std::io::Write;\n-\n-pub fn hello() {\n-    std::io::stdout().write_all(b\"hello world!\\n\");\n-}"}, {"sha": "30f57034bba55b5acc1b5882cb6943c0c901c7a8", "filename": "tests/run-make-fulldeps/save-analysis-rfc2126/Makefile", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2FMakefile?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,8 +0,0 @@\n-include ../tools.mk\n-\n-all: extern_absolute_paths.rs krate2\n-\t$(RUSTC) extern_absolute_paths.rs -Zsave-analysis --edition=2018 --extern krate2\n-\tcat $(TMPDIR)/save-analysis/extern_absolute_paths.json | \"$(PYTHON)\" validate_json.py\n-\n-krate2: krate2.rs\n-\t$(RUSTC) $<"}, {"sha": "7a8e3fff098a01042e21b985b2f03718c5442270", "filename": "tests/run-make-fulldeps/save-analysis-rfc2126/extern_absolute_paths.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fextern_absolute_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fextern_absolute_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fextern_absolute_paths.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,6 +0,0 @@\n-use krate2::hello;\n-\n-fn main() {\n-    hello();\n-    ::krate2::hello();\n-}"}, {"sha": "d24c68862b074e905182b72a9c8a101bd9c620e6", "filename": "tests/run-make-fulldeps/save-analysis-rfc2126/krate2.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fkrate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fkrate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fkrate2.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,5 +0,0 @@\n-#![crate_name = \"krate2\"]\n-#![crate_type = \"lib\"]\n-\n-pub fn hello() {\n-}"}, {"sha": "882d29a8beb23a8963a6fa1d2a3d35a03d3e1687", "filename": "tests/run-make-fulldeps/save-analysis-rfc2126/validate_json.py", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fvalidate_json.py", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fvalidate_json.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis-rfc2126%2Fvalidate_json.py?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,7 +0,0 @@\n-#!/usr/bin/env python\n-\n-import sys\n-import json\n-\n-crates = json.loads(sys.stdin.readline().strip())[\"prelude\"][\"external_crates\"]\n-assert any(map(lambda c: c[\"id\"][\"name\"] == \"krate2\", crates))"}, {"sha": "b8b6be13dbd768a8375e994ca6d02c4e8780e44e", "filename": "tests/run-make-fulldeps/save-analysis/Makefile", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2FMakefile?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,6 +0,0 @@\n-include ../tools.mk\n-all: code\n-krate2: krate2.rs\n-\t$(RUSTC) $<\n-code: foo.rs krate2\n-\t$(RUSTC) foo.rs -Zsave-analysis"}, {"sha": "2c690d5f759d785263aaf0a7c30fdf319a76dcd4", "filename": "tests/run-make-fulldeps/save-analysis/SameDir.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,5 +0,0 @@\n-// sub-module in the same directory as the main crate file\n-\n-pub struct SameStruct {\n-    pub name: String\n-}"}, {"sha": "fab03ee2e3d15d6dc55bea42c2d4abc7dea7fbb8", "filename": "tests/run-make-fulldeps/save-analysis/SameDir3.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSameDir3.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,3 +0,0 @@\n-pub fn hello(x: isize) {\n-    println!(\"macro {} :-(\", x);\n-}"}, {"sha": "511721d92a350f4adede0e99a16c45b9373777d7", "filename": "tests/run-make-fulldeps/save-analysis/SubDir/mod.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSubDir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSubDir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2FSubDir%2Fmod.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,27 +0,0 @@\n-// sub-module in a sub-directory\n-\n-use sub::sub2 as msalias;\n-use sub::sub2;\n-\n-static yy: usize = 25;\n-\n-mod sub {\n-    pub mod sub2 {\n-        pub mod sub3 {\n-            pub fn hello() {\n-                println!(\"hello from module 3\");\n-            }\n-        }\n-        pub fn hello() {\n-            println!(\"hello from a module\");\n-        }\n-\n-        pub struct nested_struct {\n-            pub field2: u32,\n-        }\n-    }\n-}\n-\n-pub struct SubStruct {\n-    pub name: String\n-}"}, {"sha": "0605ca517ff3bdfaf4f613ef0a988ed61187a4d9", "filename": "tests/run-make-fulldeps/save-analysis/extra-docs.md", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fextra-docs.md", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fextra-docs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fextra-docs.md?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1 +0,0 @@\n-Extra docs for this struct."}, {"sha": "384589de3b4807b789679eca7020edfdd3006ad1", "filename": "tests/run-make-fulldeps/save-analysis/foo.rs", "status": "removed", "additions": 0, "deletions": 465, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2Ffoo.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,465 +0,0 @@\n-#![crate_name = \"test\"]\n-#![feature(rustc_private)]\n-#![feature(associated_type_defaults)]\n-\n-extern crate rustc_graphviz;\n-// A simple rust project\n-\n-// Necessary to pull in object code as the rest of the rustc crates are shipped only as rmeta\n-// files.\n-#[allow(unused_extern_crates)]\n-extern crate rustc_driver;\n-\n-extern crate krate2;\n-extern crate krate2 as krate3;\n-\n-use rustc_graphviz::RenderOption;\n-use std::cell::RefCell;\n-use std::collections::{HashMap, HashSet};\n-use std::io::Write;\n-\n-use sub::sub2 as msalias;\n-use sub::sub2;\n-use sub::sub2::nested_struct as sub_struct;\n-\n-use std::mem::size_of;\n-\n-use std::char::from_u32;\n-\n-static uni: &'static str = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n-static yy: usize = 25;\n-\n-static bob: Option<rustc_graphviz::RenderOption> = None;\n-\n-// buglink test - see issue #1337.\n-\n-fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n-    let s = sub_struct { field2: 45u32 };\n-\n-    // import tests\n-    fn foo(x: &Write) {}\n-    let _: Option<_> = from_u32(45);\n-\n-    let x = 42usize;\n-\n-    krate2::hello();\n-    krate3::hello();\n-\n-    let x = (3isize, 4usize);\n-    let y = x.1;\n-}\n-\n-// Issue #37700\n-const LUT_BITS: usize = 3;\n-pub struct HuffmanTable {\n-    ac_lut: Option<[(i16, u8); 1 << LUT_BITS]>,\n-}\n-\n-struct TupStruct(isize, isize, Box<str>);\n-\n-fn test_tup_struct(x: TupStruct) -> isize {\n-    x.1\n-}\n-\n-fn println(s: &str) {\n-    std::io::stdout().write_all(s.as_bytes());\n-}\n-\n-mod sub {\n-    pub mod sub2 {\n-        use std::io::Write;\n-        pub mod sub3 {\n-            use std::io::Write;\n-            pub fn hello() {\n-                ::println(\"hello from module 3\");\n-            }\n-        }\n-        pub fn hello() {\n-            ::println(\"hello from a module\");\n-        }\n-\n-        pub struct nested_struct {\n-            pub field2: u32,\n-        }\n-\n-        pub enum nested_enum {\n-            Nest2 = 2,\n-            Nest3 = 3,\n-        }\n-    }\n-}\n-\n-pub mod SameDir;\n-pub mod SubDir;\n-\n-#[path = \"SameDir3.rs\"]\n-pub mod SameDir2;\n-\n-struct nofields;\n-\n-#[derive(Clone)]\n-struct some_fields {\n-    field1: u32,\n-}\n-\n-type SF = some_fields;\n-\n-trait SuperTrait {\n-    fn qux(&self) {\n-        panic!();\n-    }\n-}\n-\n-trait SomeTrait: SuperTrait {\n-    fn Method(&self, x: u32) -> u32;\n-\n-    fn prov(&self, x: u32) -> u32 {\n-        println(&x.to_string());\n-        42\n-    }\n-    fn provided_method(&self) -> u32 {\n-        42\n-    }\n-}\n-\n-trait SubTrait: SomeTrait {\n-    fn stat2(x: &Self) -> u32 {\n-        32\n-    }\n-}\n-\n-impl SomeTrait for some_fields {\n-    fn Method(&self, x: u32) -> u32 {\n-        println(&x.to_string());\n-        self.field1\n-    }\n-}\n-\n-impl SuperTrait for some_fields {}\n-\n-impl SubTrait for some_fields {}\n-\n-impl some_fields {\n-    fn stat(x: u32) -> u32 {\n-        println(&x.to_string());\n-        42\n-    }\n-    fn stat2(x: &some_fields) -> u32 {\n-        42\n-    }\n-\n-    fn align_to<T>(&mut self) {}\n-\n-    fn test(&mut self) {\n-        self.align_to::<bool>();\n-    }\n-}\n-\n-impl SuperTrait for nofields {}\n-impl SomeTrait for nofields {\n-    fn Method(&self, x: u32) -> u32 {\n-        self.Method(x);\n-        43\n-    }\n-\n-    fn provided_method(&self) -> u32 {\n-        21\n-    }\n-}\n-\n-impl SubTrait for nofields {}\n-\n-impl SuperTrait for (Box<nofields>, Box<some_fields>) {}\n-\n-fn f_with_params<T: SomeTrait>(x: &T) {\n-    x.Method(41);\n-}\n-\n-type MyType = Box<some_fields>;\n-\n-enum SomeEnum<'a> {\n-    Ints(isize, isize),\n-    Floats(f64, f64),\n-    Strings(&'a str, &'a str, &'a str),\n-    MyTypes(MyType, MyType),\n-}\n-\n-#[derive(Copy, Clone)]\n-enum SomeOtherEnum {\n-    SomeConst1,\n-    SomeConst2,\n-    SomeConst3,\n-}\n-\n-enum SomeStructEnum {\n-    EnumStruct { a: isize, b: isize },\n-    EnumStruct2 { f1: MyType, f2: MyType },\n-    EnumStruct3 { f1: MyType, f2: MyType, f3: SomeEnum<'static> },\n-}\n-\n-fn matchSomeEnum(val: SomeEnum) {\n-    match val {\n-        SomeEnum::Ints(int1, int2) => {\n-            println(&(int1 + int2).to_string());\n-        }\n-        SomeEnum::Floats(float1, float2) => {\n-            println(&(float2 * float1).to_string());\n-        }\n-        SomeEnum::Strings(.., s3) => {\n-            println(s3);\n-        }\n-        SomeEnum::MyTypes(mt1, mt2) => {\n-            println(&(mt1.field1 - mt2.field1).to_string());\n-        }\n-    }\n-}\n-\n-fn matchSomeStructEnum(se: SomeStructEnum) {\n-    match se {\n-        SomeStructEnum::EnumStruct { a: a, .. } => println(&a.to_string()),\n-        SomeStructEnum::EnumStruct2 { f1: f1, f2: f_2 } => println(&f_2.field1.to_string()),\n-        SomeStructEnum::EnumStruct3 { f1, .. } => println(&f1.field1.to_string()),\n-    }\n-}\n-\n-fn matchSomeStructEnum2(se: SomeStructEnum) {\n-    use SomeStructEnum::*;\n-    match se {\n-        EnumStruct { a: ref aaa, .. } => println(&aaa.to_string()),\n-        EnumStruct2 { f1, f2: f2 } => println(&f1.field1.to_string()),\n-        EnumStruct3 { f1, f3: SomeEnum::Ints(..), f2 } => println(&f1.field1.to_string()),\n-        _ => {}\n-    }\n-}\n-\n-fn matchSomeOtherEnum(val: SomeOtherEnum) {\n-    use SomeOtherEnum::{SomeConst2, SomeConst3};\n-    match val {\n-        SomeOtherEnum::SomeConst1 => {\n-            println(\"I'm const1.\");\n-        }\n-        SomeConst2 | SomeConst3 => {\n-            println(\"I'm const2 or const3.\");\n-        }\n-    }\n-}\n-\n-fn hello<X: SomeTrait>((z, a): (u32, String), ex: X) {\n-    SameDir2::hello(43);\n-\n-    println(&yy.to_string());\n-    let (x, y): (u32, u32) = (5, 3);\n-    println(&x.to_string());\n-    println(&z.to_string());\n-    let x: u32 = x;\n-    println(&x.to_string());\n-    let x = \"hello\";\n-    println(x);\n-\n-    let x = 32.0f32;\n-    let _ = (x + ((x * x) + 1.0).sqrt()).ln();\n-\n-    let s: Box<SomeTrait> = Box::new(some_fields { field1: 43 });\n-    let s2: Box<some_fields> = Box::new(some_fields { field1: 43 });\n-    let s3 = Box::new(nofields);\n-\n-    s.Method(43);\n-    s3.Method(43);\n-    s2.Method(43);\n-\n-    ex.prov(43);\n-\n-    let y: u32 = 56;\n-    // static method on struct\n-    let r = some_fields::stat(y);\n-    // trait static method, calls default\n-    let r = SubTrait::stat2(&*s3);\n-\n-    let s4 = s3 as Box<SomeTrait>;\n-    s4.Method(43);\n-\n-    s4.provided_method();\n-    s2.prov(45);\n-\n-    let closure = |x: u32, s: &SomeTrait| {\n-        s.Method(23);\n-        return x + y;\n-    };\n-\n-    let z = closure(10, &*s);\n-}\n-\n-pub struct blah {\n-    used_link_args: RefCell<[&'static str; 0]>,\n-}\n-\n-#[macro_use]\n-mod macro_use_test {\n-    macro_rules! test_rec {\n-        (q, $src: expr) => {{\n-            print!(\"{}\", $src);\n-            test_rec!($src);\n-        }};\n-        ($src: expr) => {\n-            print!(\"{}\", $src);\n-        };\n-    }\n-\n-    macro_rules! internal_vars {\n-        ($src: ident) => {{\n-            let mut x = $src;\n-            x += 100;\n-        }};\n-    }\n-}\n-\n-fn main() {\n-    // foo\n-    let s = Box::new(some_fields { field1: 43 });\n-    hello((43, \"a\".to_string()), *s);\n-    sub::sub2::hello();\n-    sub2::sub3::hello();\n-\n-    let h = sub2::sub3::hello;\n-    h();\n-\n-    // utf8 chars\n-    let ut = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n-\n-    // For some reason, this pattern of macro_rules foiled our generated code\n-    // avoiding strategy.\n-    macro_rules! variable_str(($name:expr) => (\n-        some_fields {\n-            field1: $name,\n-        }\n-    ));\n-    let vs = variable_str!(32);\n-\n-    let mut candidates: RefCell<HashMap<&'static str, &'static str>> = RefCell::new(HashMap::new());\n-    let _ = blah { used_link_args: RefCell::new([]) };\n-    let s1 = nofields;\n-    let s2 = SF { field1: 55 };\n-    let s3: some_fields = some_fields { field1: 55 };\n-    let s4: msalias::nested_struct = sub::sub2::nested_struct { field2: 55 };\n-    let s4: msalias::nested_struct = sub2::nested_struct { field2: 55 };\n-    println(&s2.field1.to_string());\n-    let s5: MyType = Box::new(some_fields { field1: 55 });\n-    let s = SameDir::SameStruct { name: \"Bob\".to_string() };\n-    let s = SubDir::SubStruct { name: \"Bob\".to_string() };\n-    let s6: SomeEnum = SomeEnum::MyTypes(Box::new(s2.clone()), s5);\n-    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n-    matchSomeEnum(s6);\n-    matchSomeEnum(s7);\n-    let s8: SomeOtherEnum = SomeOtherEnum::SomeConst2;\n-    matchSomeOtherEnum(s8);\n-    let s9: SomeStructEnum =\n-        SomeStructEnum::EnumStruct2 { f1: Box::new(some_fields { field1: 10 }), f2: Box::new(s2) };\n-    matchSomeStructEnum(s9);\n-\n-    for x in &vec![1, 2, 3] {\n-        let _y = x;\n-    }\n-\n-    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n-    if let SomeEnum::Strings(..) = s7 {\n-        println!(\"hello!\");\n-    }\n-\n-    for i in 0..5 {\n-        foo_foo(i);\n-    }\n-\n-    if let Some(x) = None {\n-        foo_foo(x);\n-    }\n-\n-    if false {\n-    } else if let Some(y) = None {\n-        foo_foo(y);\n-    }\n-\n-    while let Some(z) = None {\n-        foo_foo(z);\n-    }\n-\n-    let mut x = 4;\n-    test_rec!(q, \"Hello\");\n-    assert_eq!(x, 4);\n-    internal_vars!(x);\n-}\n-\n-fn foo_foo(_: i32) {}\n-\n-impl Iterator for nofields {\n-    type Item = (usize, usize);\n-\n-    fn next(&mut self) -> Option<(usize, usize)> {\n-        panic!()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        panic!()\n-    }\n-}\n-\n-trait Pattern<'a> {\n-    type Searcher;\n-}\n-\n-struct CharEqPattern;\n-\n-impl<'a> Pattern<'a> for CharEqPattern {\n-    type Searcher = CharEqPattern;\n-}\n-\n-struct CharSearcher<'a>(<CharEqPattern as Pattern<'a>>::Searcher);\n-\n-pub trait Error {}\n-\n-impl Error + 'static {\n-    pub fn is<T: Error + 'static>(&self) -> bool {\n-        panic!()\n-    }\n-}\n-\n-impl Error + 'static + Send {\n-    pub fn is<T: Error + 'static>(&self) -> bool {\n-        <Error + 'static>::is::<T>(self)\n-    }\n-}\n-extern crate rustc_serialize;\n-#[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord, Debug, Default)]\n-struct AllDerives(i32);\n-\n-fn test_format_args() {\n-    let x = 1;\n-    let y = 2;\n-    let name = \"Joe Blogg\";\n-    println!(\"Hello {}\", name);\n-    print!(\"Hello {0}\", name);\n-    print!(\"{0} + {} = {}\", x, y);\n-    print!(\"x is {}, y is {1}, name is {n}\", x, y, n = name);\n-}\n-\n-union TestUnion {\n-    f1: u32,\n-}\n-\n-struct FrameBuffer;\n-\n-struct SilenceGenerator;\n-\n-impl Iterator for SilenceGenerator {\n-    type Item = FrameBuffer;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        panic!();\n-    }\n-}\n-\n-#[doc = include_str!(\"extra-docs.md\")]\n-struct StructWithDocs;\n-\n-trait Foo {\n-    type Bar = FrameBuffer;\n-}"}, {"sha": "7d787e0c9871f4d760dca5403f17fa42da972932", "filename": "tests/run-make-fulldeps/save-analysis/krate2.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fkrate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fkrate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsave-analysis%2Fkrate2.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,8 +0,0 @@\n-#![ crate_name = \"krate2\" ]\n-#![ crate_type = \"lib\" ]\n-\n-use std::io::Write;\n-\n-pub fn hello() {\n-    std::io::stdout().write_all(b\"hello world!\\n\");\n-}"}, {"sha": "9f36e5315ecc2dad431ebc5d898e5c457b0c3262", "filename": "tests/rustdoc-ui/issue-105742.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Frustdoc-ui%2Fissue-105742.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Frustdoc-ui%2Fissue-105742.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fissue-105742.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -3,38 +3,17 @@\n use std::ops::Index;\n \n pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n     let _ = s;\n }\n \n pub trait SVec: Index<\n     <Self as SVec>::Item,\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n     Output = <Index<<Self as SVec>::Item,\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n     Output = <Self as SVec>::Item> as SVec>::Item,\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n-//~^^^^^ ERROR\n-//~^^^^^^ ERROR\n-//~^^^^^^^ ERROR\n-//~^^^^^^^^ ERROR\n > {\n     type Item<'a, T>;\n \n     fn len(&self) -> <Self as SVec>::Item;\n     //~^ ERROR\n     //~^^ ERROR\n-    //~^^^ ERROR\n-    //~^^^^ ERROR\n }"}, {"sha": "4d2ee9726891797487dc818b7102baf9d919dcba", "filename": "tests/rustdoc-ui/issue-105742.stderr", "status": "modified", "additions": 6, "deletions": 356, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Frustdoc-ui%2Fissue-105742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Frustdoc-ui%2Fissue-105742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fissue-105742.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,360 +1,11 @@\n error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     <Self as SVec>::Item<'a>,\n-   |                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     <Self as SVec>::Item<T>,\n-   |                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<'a>,\n-   |                                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<T>,\n-   |                                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item<'a>> as SVec>::Item,\n-   |                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item<T>> as SVec>::Item,\n-   |                                  +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<'a>,\n-   |                                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<T>,\n-   |                                                  +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:5:40\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-   |                                        ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item<'_> = T, Output = T>) {\n-   |                                            ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:5:40\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-   |                                        ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item<T> = T, Output = T>) {\n-   |                                            +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     <Self as SVec>::Item<'a>,\n-   |                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     <Self as SVec>::Item<T>,\n-   |                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<'a>,\n-   |                                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<T>,\n-   |                                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item<'a>> as SVec>::Item,\n-   |                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item<T>> as SVec>::Item,\n-   |                                  +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<'a>,\n-   |                                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<T>,\n-   |                                                  +++\n-\n-error[E0038]: the trait `SVec` cannot be made into an object\n-  --> $DIR/issue-105742.rs:5:31\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `SVec` cannot be made into an object\n-   |\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-105742.rs:12:17\n-   |\n-LL |    pub trait SVec: Index<\n-   |  ____________----__^\n-   | |            |\n-   | |            this trait cannot be made into an object...\n-LL | |      <Self as SVec>::Item,\n-LL | |\n-LL | |\n-...  |\n-LL | |/     Output = <Index<<Self as SVec>::Item,\n-LL | ||\n-LL | ||\n-LL | ||\n-LL | ||\n-LL | ||     Output = <Self as SVec>::Item> as SVec>::Item,\n-   | ||_________________________________________________^ ...because it uses `Self` as a type parameter\n-...  |\n-LL | |\n-LL | |  > {\n-   | |__^ ...because it uses `Self` as a type parameter\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item;\n-   |                                      ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item<'_>;\n-   |                                          ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item;\n-   |                                      ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item<T>;\n-   |                                          +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n+  --> $DIR/issue-105742.rs:16:38\n    |\n LL |     fn len(&self) -> <Self as SVec>::Item;\n    |                                      ^^^^ expected 1 lifetime argument\n    |\n note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n+  --> $DIR/issue-105742.rs:14:10\n    |\n LL |     type Item<'a, T>;\n    |          ^^^^ --\n@@ -364,13 +15,13 @@ LL |     fn len(&self) -> <Self as SVec>::Item<'_>;\n    |                                          ++++\n \n error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n+  --> $DIR/issue-105742.rs:16:38\n    |\n LL |     fn len(&self) -> <Self as SVec>::Item;\n    |                                      ^^^^ expected 1 generic argument\n    |\n note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n+  --> $DIR/issue-105742.rs:14:10\n    |\n LL |     type Item<'a, T>;\n    |          ^^^^     -\n@@ -379,7 +30,6 @@ help: add missing generic argument\n LL |     fn len(&self) -> <Self as SVec>::Item<T>;\n    |                                          +++\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0038, E0107.\n-For more information about an error, try `rustc --explain E0038`.\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "8d0155151b8dfa9d5f4ebf782adaf7ae2308f85a", "filename": "tests/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fz-help.stdout?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -146,7 +146,6 @@\n     -Z          sanitizer-memory-track-origins=val -- enable origins tracking in MemorySanitizer\n     -Z                       sanitizer-recover=val -- enable recovery for selected sanitizers\n     -Z                  saturating-float-casts=val -- make float->int casts UB-free: numbers outside the integer type's range are clipped to the max/min integer respectively, and NaN is mapped to 0 (default: yes)\n-    -Z                           save-analysis=val -- write syntax and type analysis (in JSON format) information, in addition to normal output (default: no)\n     -Z                            self-profile=val -- run the self profiler and output the raw event data\n     -Z                    self-profile-counter=val -- counter used by the self profiler (default: `wall-time`), one of:\n         `wall-time` (monotonic clock, i.e. `std::time::Instant`)"}, {"sha": "ac589de2303f9c6f398eedfc3c2d767d9cd62b8c", "filename": "tests/ui/asm/issue-72570.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fasm%2Fissue-72570.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fasm%2Fissue-72570.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Fissue-72570.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,6 +1,4 @@\n-// compile-flags: -Zsave-analysis\n // needs-asm-support\n-// Also test for #72960\n \n use std::arch::asm;\n "}, {"sha": "49013a23ced2da7543e91ba1b35cb7e9f0013485", "filename": "tests/ui/asm/issue-72570.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fasm%2Fissue-72570.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fasm%2Fissue-72570.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasm%2Fissue-72570.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,5 +1,5 @@\n error: invalid register `invalid`: unknown register\n-  --> $DIR/issue-72570.rs:9:18\n+  --> $DIR/issue-72570.rs:7:18\n    |\n LL |         asm!(\"\", in(\"invalid\") \"\".len());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "08570d4a5d982e65ff4d362fac7cfcfc65d49796", "filename": "tests/ui/associated-consts/issue-105330.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fassociated-consts%2Fissue-105330.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fassociated-consts%2Fissue-105330.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-consts%2Fissue-105330.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -33,7 +33,7 @@ LL | fn main<A: TraitWAssocConst<A=32>>() {\n    = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n    = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in impl header\n   --> $DIR/issue-105330.rs:6:27\n    |\n LL | impl TraitWAssocConst for impl Demo {"}, {"sha": "b74b5e94e2b751ae00a03c7abedad480802cd9d8", "filename": "tests/ui/closures/2229_closure_analysis/migrations/auto_traits.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -26,7 +26,7 @@ fn test_send_trait() {\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0`\n-    } });\n+    } }).join().unwrap();\n }\n \n /* Test Sync Trait Migration */\n@@ -47,7 +47,7 @@ fn test_sync_trait() {\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0.0`\n-    } });\n+    } }).join().unwrap();\n }\n \n /* Test Clone Trait Migration */"}, {"sha": "e4965e33cc16fce2f117efe56ae8549063d29bf7", "filename": "tests/ui/closures/2229_closure_analysis/migrations/auto_traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -26,7 +26,7 @@ fn test_send_trait() {\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0`\n-    });\n+    }).join().unwrap();\n }\n \n /* Test Sync Trait Migration */\n@@ -47,7 +47,7 @@ fn test_sync_trait() {\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0.0`\n-    });\n+    }).join().unwrap();\n }\n \n /* Test Clone Trait Migration */"}, {"sha": "856ec4a5b9eb3fa7007409608e3640b642c65152", "filename": "tests/ui/closures/2229_closure_analysis/migrations/auto_traits.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -19,7 +19,7 @@ LL ~     thread::spawn(move || { let _ = &fptr; unsafe {\n LL |\n  ...\n LL |\n-LL ~     } });\n+LL ~     } }).join().unwrap();\n    |\n \n error: changes to closure capture in Rust 2021 will affect which traits the closure implements\n@@ -41,7 +41,7 @@ LL ~     thread::spawn(move || { let _ = &fptr; unsafe {\n LL |\n  ...\n LL |\n-LL ~     } });\n+LL ~     } }).join().unwrap();\n    |\n \n error: changes to closure capture in Rust 2021 will affect drop order and which traits the closure implements"}, {"sha": "bde8c7497310d76149bd2c341caca5771d7feae8", "filename": "tests/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -145,7 +145,7 @@ fn test_multi_traits_issues() {\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr1`, but in Rust 2021, it will only capture `fptr1.0.0`\n         *fptr2.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr2`, but in Rust 2021, it will only capture `fptr2.0`\n-    } });\n+    } }).join().unwrap();\n }\n \n fn main() {"}, {"sha": "584c52ea134303adecd8b6e7eba7cc4ff597125e", "filename": "tests/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -141,7 +141,7 @@ fn test_multi_traits_issues() {\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr1`, but in Rust 2021, it will only capture `fptr1.0.0`\n         *fptr2.0 = 20;\n         //~^ NOTE: in Rust 2018, this closure captures all of `fptr2`, but in Rust 2021, it will only capture `fptr2.0`\n-    });\n+    }).join().unwrap();\n }\n \n fn main() {"}, {"sha": "344bc662ee73feddf4236ba7c82f89658db804ae", "filename": "tests/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -111,7 +111,7 @@ LL ~     thread::spawn(move || { let _ = (&fptr1, &fptr2); unsafe {\n LL |\n  ...\n LL |\n-LL ~     } });\n+LL ~     } }).join().unwrap();\n    |\n \n error: aborting due to 5 previous errors"}, {"sha": "82030731cc17d3bb289d094be315e38d4a6c106e", "filename": "tests/ui/const-generics/const-argument-non-static-lifetime.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.min.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: a non-static lifetime is not allowed in a `const`\n-  --> $DIR/const-argument-non-static-lifetime.rs:15:17\n+  --> $DIR/const-argument-non-static-lifetime.rs:14:17\n    |\n LL |         let _: &'a ();\n    |                 ^^"}, {"sha": "0357e4ed59fdad95580e76b50c64f421cd82f8af", "filename": "tests/ui/const-generics/const-argument-non-static-lifetime.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fconst-argument-non-static-lifetime.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -2,7 +2,6 @@\n // revisions: full min\n \n // regression test for #78180\n-// compile-flags: -Zsave-analysis\n \n #![cfg_attr(full, feature(generic_const_exprs))]\n #![cfg_attr(full, allow(incomplete_features))]"}, {"sha": "b776f2017fae0d92e27c25acd2cb4fdba7251896", "filename": "tests/ui/const-generics/const-param-type-depends-on-type-param-ungated.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,6 +1,3 @@\n-// compile-flags: -Zsave-analysis\n-// Regression test for #69414 ^\n-\n use std::marker::PhantomData;\n \n struct B<T, const N: T>(PhantomData<[T; N]>);"}, {"sha": "9c5c97befd83663ca9d8be52634ec03201faa1ce", "filename": "tests/ui/const-generics/const-param-type-depends-on-type-param-ungated.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,5 +1,5 @@\n error[E0770]: the type of const parameters must not depend on other generic parameters\n-  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:6:22\n+  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:22\n    |\n LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n    |                      ^ the type must not depend on the parameter `T`"}, {"sha": "aa7ae90a36373bf1fe1a339f8bd8db3799ca8afc", "filename": "tests/ui/const-generics/issues/issue-73260.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zsave-analysis\n #![feature(generic_const_exprs)]\n #![allow(incomplete_features)]\n struct Arr<const N: usize>"}, {"sha": "f9ff0f28d51d23fd5685497af848b813e8263ba9", "filename": "tests/ui/const-generics/issues/issue-73260.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,13 +1,13 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-73260.rs:16:12\n+  --> $DIR/issue-73260.rs:15:12\n    |\n LL |     let x: Arr<{usize::MAX}> = Arr {};\n    |            ^^^^^^^^^^^^^^^^^ expected `false`, found `true`\n    |\n    = note: expected constant `false`\n               found constant `true`\n note: required by a bound in `Arr`\n-  --> $DIR/issue-73260.rs:6:37\n+  --> $DIR/issue-73260.rs:5:37\n    |\n LL | struct Arr<const N: usize>\n    |        --- required by a bound in this\n@@ -16,15 +16,15 @@ LL |     Assert::<{N < usize::MAX / 2}>: IsTrue,\n    |                                     ^^^^^^ required by this bound in `Arr`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-73260.rs:16:32\n+  --> $DIR/issue-73260.rs:15:32\n    |\n LL |     let x: Arr<{usize::MAX}> = Arr {};\n    |                                ^^^ expected `false`, found `true`\n    |\n    = note: expected constant `false`\n               found constant `true`\n note: required by a bound in `Arr`\n-  --> $DIR/issue-73260.rs:6:37\n+  --> $DIR/issue-73260.rs:5:37\n    |\n LL | struct Arr<const N: usize>\n    |        --- required by a bound in this"}, {"sha": "c9aaa6e558747f482244580b1136fcd971fdc6c6", "filename": "tests/ui/consts/const-eval/issue-91827-extern-types.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-91827-extern-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-91827-extern-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-91827-extern-types.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -28,7 +28,10 @@ pub struct ListImpl<T, const N: usize> {\n \n impl<T> List<T> {\n     const fn as_slice(&self) -> &[T] {\n-        unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len) }\n+        unsafe {\n+            let ptr = addr_of!(self.tail) as *const T;\n+            std::slice::from_raw_parts(ptr, self.len)\n+        }\n     }\n }\n "}, {"sha": "06658a49b83aaf7684e3c4eec57bb9cddedbce1e", "filename": "tests/ui/error-codes/E0520.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ferror-codes%2FE0520.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ferror-codes%2FE0520.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0520.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -15,7 +15,7 @@ LL | impl<T: Clone> SpaceLlama for T {\n    | ------------------------------- parent `impl` is here\n ...\n LL |     default fn fly(&self) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `fly`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `fly`\n    |\n    = note: to specialize, `fly` in the parent `impl` must be marked `default`\n "}, {"sha": "49fb10e6029599757f64ee086d9196d18631a9c9", "filename": "tests/ui/feature-gates/feature-gate-associated_type_bounds.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,6 +1,3 @@\n-// compile-flags: -Zsave-analysis\n-// This is also a regression test for #69415 and the above flag is needed.\n-\n use std::mem::ManuallyDrop;\n \n trait Tr1 { type As1: Copy; }"}, {"sha": "edbbf7db5657882c3e778047dba50056ccacefc4", "filename": "tests/ui/feature-gates/feature-gate-associated_type_bounds.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:15:22\n+  --> $DIR/feature-gate-associated_type_bounds.rs:12:22\n    |\n LL |     type A: Iterator<Item: Copy>;\n    |                      ^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL |     type A: Iterator<Item: Copy>;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:19:22\n+  --> $DIR/feature-gate-associated_type_bounds.rs:16:22\n    |\n LL |     type B: Iterator<Item: 'static>;\n    |                      ^^^^^^^^^^^^^\n@@ -17,7 +17,7 @@ LL |     type B: Iterator<Item: 'static>;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:23:20\n+  --> $DIR/feature-gate-associated_type_bounds.rs:20:20\n    |\n LL | struct _St1<T: Tr1<As1: Tr2>> {\n    |                    ^^^^^^^^\n@@ -26,7 +26,7 @@ LL | struct _St1<T: Tr1<As1: Tr2>> {\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:30:18\n+  --> $DIR/feature-gate-associated_type_bounds.rs:27:18\n    |\n LL | enum _En1<T: Tr1<As1: Tr2>> {\n    |                  ^^^^^^^^\n@@ -35,7 +35,7 @@ LL | enum _En1<T: Tr1<As1: Tr2>> {\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:37:19\n+  --> $DIR/feature-gate-associated_type_bounds.rs:34:19\n    |\n LL | union _Un1<T: Tr1<As1: Tr2>> {\n    |                   ^^^^^^^^\n@@ -44,7 +44,7 @@ LL | union _Un1<T: Tr1<As1: Tr2>> {\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:44:37\n+  --> $DIR/feature-gate-associated_type_bounds.rs:41:37\n    |\n LL | type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n    |                                     ^^^^^^^^^^\n@@ -53,7 +53,7 @@ LL | type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:47:22\n+  --> $DIR/feature-gate-associated_type_bounds.rs:44:22\n    |\n LL | fn _apit(_: impl Tr1<As1: Copy>) {}\n    |                      ^^^^^^^^^\n@@ -62,7 +62,7 @@ LL | fn _apit(_: impl Tr1<As1: Copy>) {}\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:49:26\n+  --> $DIR/feature-gate-associated_type_bounds.rs:46:26\n    |\n LL | fn _apit_dyn(_: &dyn Tr1<As1: Copy>) {}\n    |                          ^^^^^^^^^\n@@ -71,7 +71,7 @@ LL | fn _apit_dyn(_: &dyn Tr1<As1: Copy>) {}\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:52:24\n+  --> $DIR/feature-gate-associated_type_bounds.rs:49:24\n    |\n LL | fn _rpit() -> impl Tr1<As1: Copy> { S1 }\n    |                        ^^^^^^^^^\n@@ -80,7 +80,7 @@ LL | fn _rpit() -> impl Tr1<As1: Copy> { S1 }\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:55:31\n+  --> $DIR/feature-gate-associated_type_bounds.rs:52:31\n    |\n LL | fn _rpit_dyn() -> Box<dyn Tr1<As1: Copy>> { Box::new(S1) }\n    |                               ^^^^^^^^^\n@@ -89,7 +89,7 @@ LL | fn _rpit_dyn() -> Box<dyn Tr1<As1: Copy>> { Box::new(S1) }\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:58:23\n+  --> $DIR/feature-gate-associated_type_bounds.rs:55:23\n    |\n LL | const _cdef: impl Tr1<As1: Copy> = S1;\n    |                       ^^^^^^^^^\n@@ -98,7 +98,7 @@ LL | const _cdef: impl Tr1<As1: Copy> = S1;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:64:24\n+  --> $DIR/feature-gate-associated_type_bounds.rs:61:24\n    |\n LL | static _sdef: impl Tr1<As1: Copy> = S1;\n    |                        ^^^^^^^^^\n@@ -107,34 +107,34 @@ LL | static _sdef: impl Tr1<As1: Copy> = S1;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:71:21\n+  --> $DIR/feature-gate-associated_type_bounds.rs:68:21\n    |\n LL |     let _: impl Tr1<As1: Copy> = S1;\n    |                     ^^^^^^^^^\n    |\n    = note: see issue #52662 <https://github.com/rust-lang/rust/issues/52662> for more information\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n-  --> $DIR/feature-gate-associated_type_bounds.rs:58:14\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in const type\n+  --> $DIR/feature-gate-associated_type_bounds.rs:55:14\n    |\n LL | const _cdef: impl Tr1<As1: Copy> = S1;\n    |              ^^^^^^^^^^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n-  --> $DIR/feature-gate-associated_type_bounds.rs:64:15\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in const type\n+  --> $DIR/feature-gate-associated_type_bounds.rs:61:15\n    |\n LL | static _sdef: impl Tr1<As1: Copy> = S1;\n    |               ^^^^^^^^^^^^^^^^^^^\n \n error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in variable binding\n-  --> $DIR/feature-gate-associated_type_bounds.rs:71:12\n+  --> $DIR/feature-gate-associated_type_bounds.rs:68:12\n    |\n LL |     let _: impl Tr1<As1: Copy> = S1;\n    |            ^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `<<Self as _Tr3>::A as Iterator>::Item: Copy` is not satisfied\n-  --> $DIR/feature-gate-associated_type_bounds.rs:15:28\n+  --> $DIR/feature-gate-associated_type_bounds.rs:12:28\n    |\n LL |     type A: Iterator<Item: Copy>;\n    |                            ^^^^ the trait `Copy` is not implemented for `<<Self as _Tr3>::A as Iterator>::Item`"}, {"sha": "5613c1916c6cdcd62db21500fa10ba18f14b1095", "filename": "tests/ui/impl-trait/bound-normalization-pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,8 +1,6 @@\n // check-pass\n // edition:2018\n // revisions: default sa\n-//[sa] compile-flags: -Z save-analysis\n-//-^ To make this the regression test for #75962.\n \n #![feature(type_alias_impl_trait)]\n "}, {"sha": "f591c07bcf5f48f723c9fcd7af5fec630740680a", "filename": "tests/ui/impl-trait/issues/issue-58956.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-58956.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-58956.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-58956.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in const type\n   --> $DIR/issue-58956.rs:7:11\n    |\n LL | const _A: impl Lam = {"}, {"sha": "a227f0ba7d135416bb3749009a2aa8c79ea493ae", "filename": "tests/ui/impl-trait/issues/issue-83929-impl-trait-in-generic-default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-83929-impl-trait-in-generic-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-83929-impl-trait-in-generic-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-83929-impl-trait-in-generic-default.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,10 +1,10 @@\n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/issue-83929-impl-trait-in-generic-default.rs:1:16\n    |\n LL | struct Foo<T = impl Copy>(T);\n    |                ^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/issue-83929-impl-trait-in-generic-default.rs:4:20\n    |\n LL | type Result<T, E = impl std::error::Error> = std::result::Result<T, E>;"}, {"sha": "a137777840b31d8163e2766446465cd048e4a6c2", "filename": "tests/ui/impl-trait/issues/issue-86642.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86642.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86642.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86642.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in const type\n   --> $DIR/issue-86642.rs:1:11\n    |\n LL | static x: impl Fn(&str) -> Result<&str, ()> = move |source| {"}, {"sha": "201aba3adff969cb43bf8034c31de0c083a724ab", "filename": "tests/ui/impl-trait/where-allowed.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -115,31 +115,31 @@ error[E0562]: `impl Trait` only allowed in function and inherent method return t\n LL | fn in_Fn_return_in_generics<F: Fn() -> impl Debug> (_: F) { panic!() }\n    |                                        ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in field type\n   --> $DIR/where-allowed.rs:81:32\n    |\n LL | struct InBraceStructField { x: impl Debug }\n    |                                ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in path\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in field type\n   --> $DIR/where-allowed.rs:85:41\n    |\n LL | struct InAdtInBraceStructField { x: Vec<impl Debug> }\n    |                                         ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in field type\n   --> $DIR/where-allowed.rs:89:27\n    |\n LL | struct InTupleStructField(impl Debug);\n    |                           ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in field type\n   --> $DIR/where-allowed.rs:94:25\n    |\n LL |     InBraceVariant { x: impl Debug },\n    |                         ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in field type\n   --> $DIR/where-allowed.rs:96:20\n    |\n LL |     InTupleVariant(impl Debug),\n@@ -187,31 +187,31 @@ error[E0562]: `impl Trait` only allowed in function and inherent method return t\n LL | impl PartialEq<impl Debug> for () {\n    |                ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in impl header\n   --> $DIR/where-allowed.rs:166:24\n    |\n LL | impl PartialEq<()> for impl Debug {\n    |                        ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in impl header\n   --> $DIR/where-allowed.rs:171:6\n    |\n LL | impl impl Debug {\n    |      ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in impl header\n   --> $DIR/where-allowed.rs:177:24\n    |\n LL | impl InInherentImplAdt<impl Debug> {\n    |                        ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in bound\n   --> $DIR/where-allowed.rs:183:11\n    |\n LL |     where impl Debug: Debug\n    |           ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in bound\n   --> $DIR/where-allowed.rs:190:15\n    |\n LL |     where Vec<impl Debug>: Debug\n@@ -235,37 +235,37 @@ error[E0562]: `impl Trait` only allowed in function and inherent method return t\n LL |     where T: Fn() -> impl Debug\n    |                      ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:217:40\n    |\n LL | struct InStructGenericParamDefault<T = impl Debug>(T);\n    |                                        ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:221:36\n    |\n LL | enum InEnumGenericParamDefault<T = impl Debug> { Variant(T) }\n    |                                    ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:225:38\n    |\n LL | trait InTraitGenericParamDefault<T = impl Debug> {}\n    |                                      ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:229:41\n    |\n LL | type InTypeAliasGenericParamDefault<T = impl Debug> = T;\n    |                                         ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:233:11\n    |\n LL | impl <T = impl Debug> T {}\n    |           ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in generic parameter default\n   --> $DIR/where-allowed.rs:240:40\n    |\n LL | fn in_method_generic_param_default<T = impl Debug>(_: T) {}"}, {"sha": "2e72d39cb322b1b60f78722d18eb11f92a649ecf", "filename": "tests/ui/issues/issue-3763.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fissues%2Fissue-3763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fissues%2Fissue-3763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-3763.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,5 +1,4 @@\n-// compile-flags: -Zsave-analysis\n-// Also regression test for #69416\n+// Regression test for #3763\n \n mod my_mod {\n     pub struct MyStruct {"}, {"sha": "a09c8421bb7a174923f82308f17ff469740c1101", "filename": "tests/ui/issues/issue-3763.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fissues%2Fissue-3763.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fissues%2Fissue-3763.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-3763.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,17 +1,17 @@\n error[E0616]: field `priv_field` of struct `MyStruct` is private\n-  --> $DIR/issue-3763.rs:18:32\n+  --> $DIR/issue-3763.rs:17:32\n    |\n LL |     let _woohoo = (&my_struct).priv_field;\n    |                                ^^^^^^^^^^ private field\n \n error[E0616]: field `priv_field` of struct `MyStruct` is private\n-  --> $DIR/issue-3763.rs:21:41\n+  --> $DIR/issue-3763.rs:20:41\n    |\n LL |     let _woohoo = (Box::new(my_struct)).priv_field;\n    |                                         ^^^^^^^^^^ private field\n \n error[E0624]: associated function `happyfun` is private\n-  --> $DIR/issue-3763.rs:24:18\n+  --> $DIR/issue-3763.rs:23:18\n    |\n LL |         fn happyfun(&self) {}\n    |         ------------------ private associated function defined here\n@@ -20,7 +20,7 @@ LL |     (&my_struct).happyfun();\n    |                  ^^^^^^^^ private associated function\n \n error[E0624]: associated function `happyfun` is private\n-  --> $DIR/issue-3763.rs:26:27\n+  --> $DIR/issue-3763.rs:25:27\n    |\n LL |         fn happyfun(&self) {}\n    |         ------------------ private associated function defined here\n@@ -29,7 +29,7 @@ LL |     (Box::new(my_struct)).happyfun();\n    |                           ^^^^^^^^ private associated function\n \n error[E0616]: field `priv_field` of struct `MyStruct` is private\n-  --> $DIR/issue-3763.rs:27:26\n+  --> $DIR/issue-3763.rs:26:26\n    |\n LL |     let nope = my_struct.priv_field;\n    |                          ^^^^^^^^^^ private field"}, {"sha": "055173e9842dd994dd69c4f49aad9f3bc489cdf5", "filename": "tests/ui/lint/invalid_value-polymorphic.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Flint%2Finvalid_value-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Flint%2Finvalid_value-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Finvalid_value-polymorphic.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: --crate-type=lib -Zmir-enable-passes=+InstCombine\n+// build-pass\n+\n+#![feature(core_intrinsics)]\n+\n+pub fn generic<T>() {\n+    core::intrinsics::assert_mem_uninitialized_valid::<&T>();\n+}"}, {"sha": "71e40759c848be08a617af489f6875f15d874826", "filename": "tests/ui/methods/assign-to-method.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fmethods%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fmethods%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fassign-to-method.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,5 +1,4 @@\n-// compile-flags: -Zsave-analysis\n-// Also regression test for #69409\n+// Regression test for #69409\n \n struct Cat {\n     meows : usize,"}, {"sha": "a1fc57cae21329b4a4d2b5c769596fb4e20c31cc", "filename": "tests/ui/methods/assign-to-method.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fmethods%2Fassign-to-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fmethods%2Fassign-to-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fassign-to-method.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,13 +1,13 @@\n error[E0615]: attempted to take value of method `speak` on type `Cat`\n-  --> $DIR/assign-to-method.rs:22:10\n+  --> $DIR/assign-to-method.rs:21:10\n    |\n LL |     nyan.speak = || println!(\"meow\");\n    |          ^^^^^ method, not a field\n    |\n    = help: methods are immutable and cannot be assigned to\n \n error[E0615]: attempted to take value of method `speak` on type `Cat`\n-  --> $DIR/assign-to-method.rs:23:10\n+  --> $DIR/assign-to-method.rs:22:10\n    |\n LL |     nyan.speak += || println!(\"meow\");\n    |          ^^^^^ method, not a field"}, {"sha": "a1a1b8c63dac38cfc04ff8162cc2f536d560c84e", "filename": "tests/ui/save-analysis/emit-notifications.polonius.stderr", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Femit-notifications.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Femit-notifications.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Femit-notifications.polonius.stderr?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,2 +0,0 @@\n-{\"artifact\":\"$TEST_BUILD_DIR/save-analysis/emit-notifications.polonius/save-analysis/libemit_notifications.json\",\"emit\":\"save-analysis\"}\n-{\"artifact\":\"$TEST_BUILD_DIR/save-analysis/emit-notifications.polonius/libemit_notifications.rlib\",\"emit\":\"link\"}"}, {"sha": "9179944a6201d62cd56e64e303f9473c62d2bc37", "filename": "tests/ui/save-analysis/emit-notifications.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Femit-notifications.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Femit-notifications.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Femit-notifications.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,7 +0,0 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n-// compile-flags: -Zsave-analysis --json artifacts\n-// compile-flags: --crate-type rlib --error-format=json\n-// ignore-pass\n-// ^-- needed because otherwise, the .stderr file changes with --pass check\n-\n-pub fn foo() {}"}, {"sha": "e16f60f8b5faf146b398b2eb897f06fc38a03bfe", "filename": "tests/ui/save-analysis/emit-notifications.stderr", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Femit-notifications.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Femit-notifications.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Femit-notifications.stderr?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,2 +0,0 @@\n-{\"artifact\":\"$TEST_BUILD_DIR/save-analysis/emit-notifications/save-analysis/libemit_notifications.json\",\"emit\":\"save-analysis\"}\n-{\"artifact\":\"$TEST_BUILD_DIR/save-analysis/emit-notifications/libemit_notifications.rlib\",\"emit\":\"link\"}"}, {"sha": "2ba05a0a47e01dd9590b61f106d840f7f78e8f70", "filename": "tests/ui/save-analysis/issue-26459.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-26459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-26459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-26459.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,8 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-\n-fn main() {\n-    match 'a' {\n-        char{ch} => true\n-        //~^ ERROR expected struct, variant or union type, found builtin type `char`\n-    };\n-}"}, {"sha": "9f594990c6de8315252bb5ff0b718a83d231e70f", "filename": "tests/ui/save-analysis/issue-26459.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-26459.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-26459.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-26459.stderr?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,9 +0,0 @@\n-error[E0574]: expected struct, variant or union type, found builtin type `char`\n-  --> $DIR/issue-26459.rs:5:9\n-   |\n-LL |         char{ch} => true\n-   |         ^^^^ not a struct, variant or union type\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0574`."}, {"sha": "55f5c5a9581b12fb21982446dfb20baf062d4f35", "filename": "tests/ui/save-analysis/issue-37323.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-37323.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-37323.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-37323.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,20 +0,0 @@\n-// check-pass\n-// compile-flags: -Zsave-analysis\n-\n-#![feature(rustc_attrs)]\n-#![allow(warnings)]\n-\n-#[derive(Debug)]\n-struct Point {\n-}\n-\n-struct NestedA<'a, 'b> {\n-    x: &'a NestedB<'b>\n-}\n-\n-struct NestedB<'a> {\n-    x: &'a i32,\n-}\n-\n-fn main() {\n-}"}, {"sha": "a0871ca18094ed89d5377cb02fa01bbe670a5055", "filename": "tests/ui/save-analysis/issue-59134-0.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,12 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-\n-// Check that this doesn't ICE when processing associated const (field expr).\n-\n-pub fn f() {\n-    trait Trait {}\n-    impl dyn Trait {\n-        const FLAG: u32 = bogus.field; //~ ERROR cannot find value `bogus`\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "4e9b2e6fdeb4d94271d179c9bb6293c23525d7e4", "filename": "tests/ui/save-analysis/issue-59134-0.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-59134-0.stderr?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,9 +0,0 @@\n-error[E0425]: cannot find value `bogus` in this scope\n-  --> $DIR/issue-59134-0.rs:8:27\n-   |\n-LL |         const FLAG: u32 = bogus.field;\n-   |                           ^^^^^ not found in this scope\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0425`."}, {"sha": "3cb629777a497297c5945a99c13b89751c4677d8", "filename": "tests/ui/save-analysis/issue-59134-1.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,12 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-\n-// Check that this doesn't ICE when processing associated const (type).\n-\n-fn func() {\n-    trait Trait {\n-        type MyType;\n-        const CONST: Self::MyType = bogus.field; //~ ERROR cannot find value `bogus`\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "bdc335eaac041c0466f11829ff0f3aec301937b2", "filename": "tests/ui/save-analysis/issue-59134-1.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-59134-1.stderr?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,9 +0,0 @@\n-error[E0425]: cannot find value `bogus` in this scope\n-  --> $DIR/issue-59134-1.rs:8:37\n-   |\n-LL |         const CONST: Self::MyType = bogus.field;\n-   |                                     ^^^^^ not found in this scope\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0425`."}, {"sha": "92e85884f664dbcc43f88023f439d802f08e6009", "filename": "tests/ui/save-analysis/issue-63663.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-63663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-63663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-63663.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,28 +0,0 @@\n-// check-pass\n-// compile-flags: -Zsave-analysis\n-\n-pub trait Trait {\n-    type Assoc;\n-}\n-\n-pub struct A;\n-\n-trait Generic<T> {}\n-impl<T> Generic<T> for () {}\n-\n-// Don't ICE when resolving type paths in return type `impl Trait`\n-fn assoc_in_opaque_type_bounds<U: Trait>() -> impl Generic<U::Assoc> {}\n-\n-// Check that this doesn't ICE when processing associated const in formal\n-// argument and return type of functions defined inside function/method scope.\n-pub fn func() {\n-    fn _inner1<U: Trait>(_: U::Assoc) {}\n-    fn _inner2<U: Trait>() -> U::Assoc { unimplemented!() }\n-\n-    impl A {\n-        fn _inner1<U: Trait>(self, _: U::Assoc) {}\n-        fn _inner2<U: Trait>(self) -> U::Assoc { unimplemented!() }\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "a3d88a203778fbc8cda94e16648c117f48a582b2", "filename": "tests/ui/save-analysis/issue-64659.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-64659.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-64659.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-64659.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,10 +0,0 @@\n-// check-pass\n-// compile-flags: -Zsave-analysis\n-\n-trait Trait { type Assoc; }\n-\n-fn main() {\n-    struct Data<T: Trait> {\n-        x: T::Assoc,\n-    }\n-}"}, {"sha": "9e58b8da5d2717c84ec07f3629065cc4aab31beb", "filename": "tests/ui/save-analysis/issue-65411.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-65411.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-65411.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-65411.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,15 +0,0 @@\n-// check-pass\n-// compile-flags: -Zsave-analysis\n-\n-trait Trait { type Assoc; }\n-trait GenericTrait<T> {}\n-struct Wrapper<B> { b: B }\n-\n-fn func() {\n-    // Processing associated path in impl block definition inside a function\n-    // body does not ICE\n-    impl<B: Trait> GenericTrait<B::Assoc> for Wrapper<B> {}\n-}\n-\n-\n-fn main() {}"}, {"sha": "27874f8655e56c7bde9c5af7b305c75004c3d85c", "filename": "tests/ui/save-analysis/issue-65590.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-65590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-65590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-65590.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,21 +0,0 @@\n-// check-pass\n-// compile-flags: -Zsave-analysis\n-// edition:2018\n-\n-// Async desugaring for return types in (associated) functions introduces a\n-// separate definition internally, which we need to take into account\n-// (or else we ICE).\n-trait Trait { type Assoc; }\n-struct Struct;\n-\n-async fn foobar<T: Trait>() -> T::Assoc {\n-    unimplemented!()\n-}\n-\n-impl Struct {\n-    async fn foo<T: Trait>(&self) -> T::Assoc {\n-        unimplemented!()\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "30479580f11a3c0122291b0020d1738bf15406f4", "filename": "tests/ui/save-analysis/issue-68621.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-68621.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-68621.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-68621.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,17 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-\n-#![feature(type_alias_impl_trait)]\n-\n-trait Trait {}\n-\n-trait Service {\n-    type Future: Trait;\n-}\n-\n-struct Struct;\n-\n-impl Service for Struct {\n-    type Future = impl Trait; //~ ERROR: unconstrained opaque type\n-}\n-\n-fn main() {}"}, {"sha": "4452ee7915baab165d1b91332966d7859114ab24", "filename": "tests/ui/save-analysis/issue-68621.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-68621.stderr?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,10 +0,0 @@\n-error: unconstrained opaque type\n-  --> $DIR/issue-68621.rs:14:19\n-   |\n-LL |     type Future = impl Trait;\n-   |                   ^^^^^^^^^^\n-   |\n-   = note: `Future` must be used in combination with a concrete type within the same impl\n-\n-error: aborting due to previous error\n-"}, {"sha": "eea0a7fea0cefcc94b8074dae1c98840e9886000", "filename": "tests/ui/save-analysis/issue-72267.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-72267.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-72267.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-72267.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,7 +0,0 @@\n-// compile-flags: -Z save-analysis\n-\n-fn main() {\n-    let _: Box<(dyn ?Sized)>;\n-    //~^ ERROR `?Trait` is not permitted in trait object types\n-    //~| ERROR at least one trait is required for an object type\n-}"}, {"sha": "76fc6c57cbc36d30954cc2aab0699fdcd9e28784", "filename": "tests/ui/save-analysis/issue-72267.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-72267.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-72267.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-72267.stderr?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,15 +0,0 @@\n-error: `?Trait` is not permitted in trait object types\n-  --> $DIR/issue-72267.rs:4:21\n-   |\n-LL |     let _: Box<(dyn ?Sized)>;\n-   |                     ^^^^^^\n-\n-error[E0224]: at least one trait is required for an object type\n-  --> $DIR/issue-72267.rs:4:17\n-   |\n-LL |     let _: Box<(dyn ?Sized)>;\n-   |                 ^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0224`."}, {"sha": "87ce0933681c5d571d7a287de7959547aad76ed8", "filename": "tests/ui/save-analysis/issue-73020.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-73020.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-73020.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-73020.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,5 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-use {self}; //~ ERROR E0431\n-\n-fn main () {\n-}"}, {"sha": "5bb3aae99975c9dadb9abb33a22b78fcd84aefa6", "filename": "tests/ui/save-analysis/issue-73020.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-73020.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-73020.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-73020.stderr?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,9 +0,0 @@\n-error[E0431]: `self` import can only appear in an import list with a non-empty prefix\n-  --> $DIR/issue-73020.rs:2:6\n-   |\n-LL | use {self};\n-   |      ^^^^ can only appear in an import list with a non-empty prefix\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0431`."}, {"sha": "9ad89a319ba3b0601c54e72819e58b5bf7f46c71", "filename": "tests/ui/save-analysis/issue-73022.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-73022.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-73022.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-73022.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,13 +0,0 @@\n-// build-pass\n-// compile-flags: -Zsave-analysis\n-enum Enum2 {\n-    Variant8 { _field: bool },\n-}\n-\n-impl Enum2 {\n-    fn new_variant8() -> Enum2 {\n-        Self::Variant8 { _field: true }\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "c65e2d73fadec2040203464ab7c71631b26592c0", "filename": "tests/ui/save-analysis/issue-89066.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-89066.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-89066.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-89066.rs?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,28 +0,0 @@\n-// compile-flags: -Zsave-analysis\n-\n-// Check that this does not ICE.\n-// Stolen from tests/ui/const-generics/generic_arg_infer/infer-arg-test.rs\n-\n-#![feature(generic_arg_infer)]\n-\n-struct All<'a, T, const N: usize> {\n-  v: &'a T,\n-}\n-\n-struct BadInfer<_>;\n-//~^ ERROR expected identifier\n-//~| ERROR parameter `_` is never used\n-\n-fn all_fn<'a, T, const N: usize>() {}\n-\n-fn bad_infer_fn<_>() {}\n-//~^ ERROR expected identifier\n-\n-\n-fn main() {\n-  let a: All<_, _, _>;\n-  //~^ ERROR this struct takes 2 generic arguments but 3 generic arguments were supplied\n-  all_fn();\n-  let v: [u8; _];\n-  let v: [u8; 10] = [0; _];\n-}"}, {"sha": "5ef04936ea244b19b874c2005cdff16e87b0b77a", "filename": "tests/ui/save-analysis/issue-89066.stderr", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-89066.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ab39b60ef631da86a5069935fdc9ba2e5d0def/tests%2Fui%2Fsave-analysis%2Fissue-89066.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsave-analysis%2Fissue-89066.stderr?ref=f0ab39b60ef631da86a5069935fdc9ba2e5d0def", "patch": "@@ -1,39 +0,0 @@\n-error: expected identifier, found reserved identifier `_`\n-  --> $DIR/issue-89066.rs:12:17\n-   |\n-LL | struct BadInfer<_>;\n-   |                 ^ expected identifier, found reserved identifier\n-\n-error: expected identifier, found reserved identifier `_`\n-  --> $DIR/issue-89066.rs:18:17\n-   |\n-LL | fn bad_infer_fn<_>() {}\n-   |                 ^ expected identifier, found reserved identifier\n-\n-error[E0392]: parameter `_` is never used\n-  --> $DIR/issue-89066.rs:12:17\n-   |\n-LL | struct BadInfer<_>;\n-   |                 ^ unused parameter\n-   |\n-   = help: consider removing `_`, referring to it in a field, or using a marker such as `PhantomData`\n-   = help: if you intended `_` to be a const parameter, use `const _: usize` instead\n-\n-error[E0107]: this struct takes 2 generic arguments but 3 generic arguments were supplied\n-  --> $DIR/issue-89066.rs:23:10\n-   |\n-LL |   let a: All<_, _, _>;\n-   |          ^^^       - help: remove this generic argument\n-   |          |\n-   |          expected 2 generic arguments\n-   |\n-note: struct defined here, with 2 generic parameters: `T`, `N`\n-  --> $DIR/issue-89066.rs:8:8\n-   |\n-LL | struct All<'a, T, const N: usize> {\n-   |        ^^^     -  --------------\n-\n-error: aborting due to 4 previous errors\n-\n-Some errors have detailed explanations: E0107, E0392.\n-For more information about an error, try `rustc --explain E0107`."}, {"sha": "f9e62a99baee8e5b0db9e0ad3b32173bf088a772", "filename": "tests/ui/specialization/defaultimpl/specialization-no-default.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -15,7 +15,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn foo(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n@@ -26,7 +26,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn bar(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `bar`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `bar`\n    |\n    = note: to specialize, `bar` in the parent `impl` must be marked `default`\n \n@@ -37,7 +37,7 @@ LL | impl<T> Bar for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     type T = ();\n-   |     ^^^^^^^^^^^^ cannot specialize default item `T`\n+   |     ^^^^^^ cannot specialize default item `T`\n    |\n    = note: to specialize, `T` in the parent `impl` must be marked `default`\n \n@@ -48,7 +48,7 @@ LL | impl<T: Clone> Baz for T {\n    | ------------------------ parent `impl` is here\n ...\n LL |     fn baz(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `baz`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `baz`\n    |\n    = note: to specialize, `baz` in the parent `impl` must be marked `default`\n \n@@ -59,7 +59,7 @@ LL | impl<T: Clone> Redundant for T {\n    | ------------------------------ parent `impl` is here\n ...\n LL |     fn redundant(&self) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n+   |     ^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n    |\n    = note: to specialize, `redundant` in the parent `impl` must be marked `default`\n "}, {"sha": "3fc29fff230a33289f0c8c120489f8e2a914806a", "filename": "tests/ui/specialization/issue-50452-fail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fspecialization%2Fissue-50452-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fspecialization%2Fissue-50452-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fissue-50452-fail.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -12,7 +12,7 @@ error[E0520]: `foo` specializes an item from a parent `impl`, but that item is n\n   --> $DIR/issue-50452-fail.rs:10:5\n    |\n LL |     fn foo() {}\n-   |     ^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^ cannot specialize default item `foo`\n ...\n LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here"}, {"sha": "9d62a353da728a497f1ce96b5d2f5b452ab83bee", "filename": "tests/ui/specialization/non-defaulted-item-fail.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fspecialization%2Fnon-defaulted-item-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fspecialization%2Fnon-defaulted-item-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fnon-defaulted-item-fail.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -15,7 +15,7 @@ LL | impl<T> Foo for Box<T> {\n    | ---------------------- parent `impl` is here\n ...\n LL |     type Ty = Vec<()>;\n-   |     ^^^^^^^^^^^^^^^^^^ cannot specialize default item `Ty`\n+   |     ^^^^^^^ cannot specialize default item `Ty`\n    |\n    = note: to specialize, `Ty` in the parent `impl` must be marked `default`\n \n@@ -26,7 +26,7 @@ LL | impl<T> Foo for Box<T> {\n    | ---------------------- parent `impl` is here\n ...\n LL |     const CONST: u8 = 42;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n+   |     ^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n    |\n    = note: to specialize, `CONST` in the parent `impl` must be marked `default`\n \n@@ -37,7 +37,7 @@ LL | impl<T> Foo for Box<T> {\n    | ---------------------- parent `impl` is here\n ...\n LL |     fn foo(&self) -> bool { true }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n@@ -48,7 +48,7 @@ LL | impl<T> Foo for Vec<T> {}\n    | ---------------------- parent `impl` is here\n ...\n LL |     type Ty = Vec<()>;\n-   |     ^^^^^^^^^^^^^^^^^^ cannot specialize default item `Ty`\n+   |     ^^^^^^^ cannot specialize default item `Ty`\n    |\n    = note: to specialize, `Ty` in the parent `impl` must be marked `default`\n \n@@ -59,7 +59,7 @@ LL | impl<T> Foo for Vec<T> {}\n    | ---------------------- parent `impl` is here\n ...\n LL |     const CONST: u8 = 42;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n+   |     ^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n    |\n    = note: to specialize, `CONST` in the parent `impl` must be marked `default`\n \n@@ -70,7 +70,7 @@ LL | impl<T> Foo for Vec<T> {}\n    | ---------------------- parent `impl` is here\n ...\n LL |     fn foo(&self) -> bool { true }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n "}, {"sha": "695a3f6cc45d10c25a5d0a541140c3449889380c", "filename": "tests/ui/specialization/specialization-no-default.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fspecialization%2Fspecialization-no-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fspecialization%2Fspecialization-no-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fspecialization-no-default.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -15,7 +15,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn foo(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n@@ -26,7 +26,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn bar(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `bar`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `bar`\n    |\n    = note: to specialize, `bar` in the parent `impl` must be marked `default`\n \n@@ -37,7 +37,7 @@ LL | impl<T> Bar for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     type T = ();\n-   |     ^^^^^^^^^^^^ cannot specialize default item `T`\n+   |     ^^^^^^ cannot specialize default item `T`\n    |\n    = note: to specialize, `T` in the parent `impl` must be marked `default`\n \n@@ -48,7 +48,7 @@ LL | impl<T: Clone> Baz for T {\n    | ------------------------ parent `impl` is here\n ...\n LL |     fn baz(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `baz`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `baz`\n    |\n    = note: to specialize, `baz` in the parent `impl` must be marked `default`\n \n@@ -59,7 +59,7 @@ LL | impl<T: Clone> Redundant for T {\n    | ------------------------------ parent `impl` is here\n ...\n LL |     default fn redundant(&self) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n    |\n    = note: to specialize, `redundant` in the parent `impl` must be marked `default`\n "}, {"sha": "ae7ef47e1d4deaa24980d60beb99dcbf5ed38906", "filename": "tests/ui/suggestions/trait-hidden-method.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -0,0 +1,11 @@\n+// #107983 - testing that `__iterator_get_unchecked` isn't suggested\n+// HELP included so that compiletest errors on the bad suggestion\n+pub fn i_can_has_iterator() -> impl Iterator<Item = u32> {\n+    //~^ ERROR expected `Box<dyn Iterator>`\n+    //~| HELP consider constraining the associated type\n+    Box::new(1..=10) as Box<dyn Iterator>\n+    //~^ ERROR the value of the associated type `Item`\n+    //~| HELP specify the associated type\n+}\n+\n+fn main() {}"}, {"sha": "a5a65d193db062691dd50c431df6667f96b4a39c", "filename": "tests/ui/suggestions/trait-hidden-method.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftrait-hidden-method.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -0,0 +1,24 @@\n+error[E0191]: the value of the associated type `Item` (from trait `Iterator`) must be specified\n+  --> $DIR/trait-hidden-method.rs:6:33\n+   |\n+LL |     Box::new(1..=10) as Box<dyn Iterator>\n+   |                                 ^^^^^^^^ help: specify the associated type: `Iterator<Item = Type>`\n+\n+error[E0271]: expected `Box<dyn Iterator>` to be an iterator that yields `u32`, but it yields `<dyn Iterator as Iterator>::Item`\n+  --> $DIR/trait-hidden-method.rs:3:32\n+   |\n+LL | pub fn i_can_has_iterator() -> impl Iterator<Item = u32> {\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found `u32`\n+...\n+LL |     Box::new(1..=10) as Box<dyn Iterator>\n+   |     ------------------------------------- return type was inferred to be `Box<dyn Iterator>` here\n+   |\n+   = note: expected associated type `<dyn Iterator as Iterator>::Item`\n+                         found type `u32`\n+   = help: consider constraining the associated type `<dyn Iterator as Iterator>::Item` to `u32` or calling a method that returns `<dyn Iterator as Iterator>::Item`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0191, E0271.\n+For more information about an error, try `rustc --explain E0191`."}, {"sha": "dcb33b7a90af4f34ca326fc505fbe0e68abc73b0", "filename": "tests/ui/traits/alias/self-in-generics.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,9 +1,5 @@\n // astconv uses `FreshTy(0)` as a dummy `Self` type when instanciating trait objects.\n // This `FreshTy(0)` can leak into substs, causing ICEs in several places.\n-// Using `save-analysis` triggers type-checking `f` that would be normally skipped\n-// as `type_of` emitted an error.\n-//\n-// compile-flags: -Zsave-analysis\n \n #![feature(trait_alias)]\n "}, {"sha": "80af4e5aae33647860e45f2948d2ecbfd32ffec8", "filename": "tests/ui/traits/alias/self-in-generics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Falias%2Fself-in-generics.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,5 +1,5 @@\n error[E0038]: the trait alias `SelfInput` cannot be made into an object\n-  --> $DIR/self-in-generics.rs:12:19\n+  --> $DIR/self-in-generics.rs:8:19\n    |\n LL | pub fn f(_f: &dyn SelfInput) {}\n    |                   ^^^^^^^^^"}, {"sha": "040d9d14503f0f4dd332138db61d79e9bc21c326", "filename": "tests/ui/traits/negative-impls/no-items.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftraits%2Fnegative-impls%2Fno-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftraits%2Fnegative-impls%2Fno-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnegative-impls%2Fno-items.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -2,7 +2,7 @@ error[E0749]: negative impls cannot have any items\n   --> $DIR/no-items.rs:8:5\n    |\n LL |     type Foo = i32;\n-   |     ^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "0e46745c65cd605f91a4e4aa0626d496dd00867b", "filename": "tests/ui/type-alias-impl-trait/issue-63279.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,5 +1,3 @@\n-// compile-flags: -Zsave-analysis\n-\n #![feature(type_alias_impl_trait)]\n \n type Closure = impl FnOnce();"}, {"sha": "a4f6359b904c622231a2be6756988171ed6a8fce", "filename": "tests/ui/type-alias-impl-trait/issue-63279.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: expected a `FnOnce<()>` closure, found `()`\n-  --> $DIR/issue-63279.rs:7:11\n+  --> $DIR/issue-63279.rs:5:11\n    |\n LL | fn c() -> Closure {\n    |           ^^^^^^^ expected an `FnOnce<()>` closure, found `()`\n@@ -8,7 +8,7 @@ LL | fn c() -> Closure {\n    = note: wrap the `()` in a closure with no arguments: `|| { /* code */ }`\n \n error[E0277]: expected a `FnOnce<()>` closure, found `()`\n-  --> $DIR/issue-63279.rs:9:11\n+  --> $DIR/issue-63279.rs:7:11\n    |\n LL |     || -> Closure { || () }\n    |           ^^^^^^^ expected an `FnOnce<()>` closure, found `()`\n@@ -17,26 +17,26 @@ LL |     || -> Closure { || () }\n    = note: wrap the `()` in a closure with no arguments: `|| { /* code */ }`\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-63279.rs:9:21\n+  --> $DIR/issue-63279.rs:7:21\n    |\n LL |     || -> Closure { || () }\n    |                     ^^^^^ expected `()`, found closure\n    |\n    = note: expected unit type `()`\n-                found closure `[closure@$DIR/issue-63279.rs:9:21: 9:23]`\n+                found closure `[closure@$DIR/issue-63279.rs:7:21: 7:23]`\n help: use parentheses to call this closure\n    |\n LL |     || -> Closure { (|| ())() }\n    |                     +     +++\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-63279.rs:9:5\n+  --> $DIR/issue-63279.rs:7:5\n    |\n LL |     || -> Closure { || () }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found closure\n    |\n    = note: expected unit type `()`\n-                found closure `[closure@$DIR/issue-63279.rs:9:5: 9:18]`\n+                found closure `[closure@$DIR/issue-63279.rs:7:5: 7:18]`\n help: use parentheses to call this closure\n    |\n LL |     (|| -> Closure { || () })()"}, {"sha": "b91cbce3727f6de68be2b453fb44f6b50054d491", "filename": "tests/ui/type-alias-impl-trait/issue-65679-inst-opaque-ty-from-val-twice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zsave-analysis\n // check-pass\n \n #![feature(type_alias_impl_trait, rustc_attrs)]"}, {"sha": "7903e9e83cfb3e001865b0e8d5298fca155a1bd0", "filename": "tests/ui/type/type-check/point-at-inference-4.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -0,0 +1,21 @@\n+struct S<A, B>(Option<(A, B)>);\n+\n+impl<A, B> S<A, B> {\n+    fn infer(&self, a: A, b: B) {}\n+    //~^ NOTE associated function defined here\n+    //~| NOTE\n+    //~| NOTE\n+}\n+\n+fn main() {\n+    let s = S(None);\n+    s.infer(0i32);\n+    //~^ ERROR this method takes 2 arguments but 1 argument was supplied\n+    //~| NOTE an argument is missing\n+    //~| HELP provide the argument\n+    let t: S<u32, _> = s;\n+    //~^ ERROR mismatched types\n+    //~| NOTE expected `S<u32, _>`, found `S<i32, _>`\n+    //~| NOTE expected due to this\n+    //~| NOTE expected struct `S<u32, _>`\n+}"}, {"sha": "fac9701e4a11e87e4e09247987a96449a4d1ce1a", "filename": "tests/ui/type/type-check/point-at-inference-4.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -0,0 +1,31 @@\n+error[E0061]: this method takes 2 arguments but 1 argument was supplied\n+  --> $DIR/point-at-inference-4.rs:12:7\n+   |\n+LL |     s.infer(0i32);\n+   |       ^^^^^------ an argument is missing\n+   |\n+note: associated function defined here\n+  --> $DIR/point-at-inference-4.rs:4:8\n+   |\n+LL |     fn infer(&self, a: A, b: B) {}\n+   |        ^^^^^        ----  ----\n+help: provide the argument\n+   |\n+LL |     s.infer(0i32, /* b */);\n+   |            ~~~~~~~~~~~~~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-4.rs:16:24\n+   |\n+LL |     let t: S<u32, _> = s;\n+   |            ---------   ^ expected `S<u32, _>`, found `S<i32, _>`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected struct `S<u32, _>`\n+              found struct `S<i32, _>`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0061, E0308.\n+For more information about an error, try `rustc --explain E0061`."}, {"sha": "a3f92be6cf61fccbb4c549cdd76c0223dc31f135", "filename": "tests/ui/unsized/unsized3-rpass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Funsized%2Funsized3-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044aa87d7808f89c38a79d8c68d03249246bf9cb/tests%2Fui%2Funsized%2Funsized3-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsized%2Funsized3-rpass.rs?ref=044aa87d7808f89c38a79d8c68d03249246bf9cb", "patch": "@@ -59,7 +59,7 @@ pub fn main() {\n         }\n \n         let data: Box<Foo_<i32>> = Box::new(Foo_ { f: [1, 2, 3] });\n-        let x: &Foo<i32> = mem::transmute(slice::from_raw_parts(&*data, 3));\n+        let x: &Foo<i32> = mem::transmute(ptr::slice_from_raw_parts(&*data, 3));\n         assert_eq!(x.f.len(), 3);\n         assert_eq!(x.f[0], 1);\n \n@@ -70,7 +70,7 @@ pub fn main() {\n \n         let data: Box<_> =\n             Box::new(Baz_ { f1: 42, f2: ['a' as u8, 'b' as u8, 'c' as u8, 'd' as u8, 'e' as u8] });\n-        let x: &Baz = mem::transmute(slice::from_raw_parts(&*data, 5));\n+        let x: &Baz = mem::transmute(ptr::slice_from_raw_parts(&*data, 5));\n         assert_eq!(x.f1, 42);\n         let chs: Vec<char> = x.f2.chars().collect();\n         assert_eq!(chs.len(), 5);"}]}