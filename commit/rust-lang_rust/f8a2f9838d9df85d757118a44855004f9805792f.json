{"sha": "f8a2f9838d9df85d757118a44855004f9805792f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4YTJmOTgzOGQ5ZGY4NWQ3NTcxMThhNDQ4NTUwMDRmOTgwNTc5MmY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-12-03T22:28:30Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-01-03T19:50:18Z"}, "message": "coherence: move the builtin trait checks to their own module\n\nno functional changes", "tree": {"sha": "c4f102a965e55144c3ca4ff516b40eef6d33a03a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4f102a965e55144c3ca4ff516b40eef6d33a03a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8a2f9838d9df85d757118a44855004f9805792f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8a2f9838d9df85d757118a44855004f9805792f", "html_url": "https://github.com/rust-lang/rust/commit/f8a2f9838d9df85d757118a44855004f9805792f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8a2f9838d9df85d757118a44855004f9805792f/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f62c2920077eb5cb81323142fc5dbe6ae8813c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f62c2920077eb5cb81323142fc5dbe6ae8813c0", "html_url": "https://github.com/rust-lang/rust/commit/8f62c2920077eb5cb81323142fc5dbe6ae8813c0"}], "stats": {"total": 713, "additions": 361, "deletions": 352}, "files": [{"sha": "6fde18dbf82a43513b9955b3c7774ee014acf98e", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/f8a2f9838d9df85d757118a44855004f9805792f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8a2f9838d9df85d757118a44855004f9805792f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=f8a2f9838d9df85d757118a44855004f9805792f", "patch": "@@ -0,0 +1,357 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Check properties that are required by built-in traits and set\n+//! up data structures required by type-checking/translation.\n+\n+use rustc::middle::free_region::FreeRegionMap;\n+use rustc::middle::lang_items::UnsizeTraitLangItem;\n+\n+use rustc::traits::{self, ObligationCause, Reveal};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::ParameterEnvironment;\n+use rustc::ty::TypeFoldable;\n+use rustc::ty::subst::Subst;\n+use rustc::ty::util::CopyImplementationError;\n+use rustc::infer;\n+\n+use rustc::hir::map as hir_map;\n+use rustc::hir::{self, ItemImpl};\n+\n+pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    populate_destructors(tcx);\n+    check_implementations_of_copy(tcx);\n+    check_implementations_of_coerce_unsized(tcx);\n+}\n+\n+fn populate_destructors<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let drop_trait = match tcx.lang_items.drop_trait() {\n+        Some(id) => id,\n+        None => return,\n+    };\n+    tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n+    let drop_trait = tcx.lookup_trait_def(drop_trait);\n+\n+    drop_trait.for_each_impl(tcx, |impl_did| {\n+        let items = tcx.associated_item_def_ids(impl_did);\n+        if items.is_empty() {\n+            // We'll error out later. For now, just don't ICE.\n+            return;\n+        }\n+        let method_def_id = items[0];\n+\n+        let self_type = tcx.item_type(impl_did);\n+        match self_type.sty {\n+            ty::TyAdt(type_def, _) => {\n+                type_def.set_destructor(method_def_id);\n+            }\n+            _ => {\n+                // Destructors only work on nominal types.\n+                if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n+                    match tcx.map.find(impl_node_id) {\n+                        Some(hir_map::NodeItem(item)) => {\n+                            let span = match item.node {\n+                                ItemImpl(.., ref ty, _) => ty.span,\n+                                _ => item.span,\n+                            };\n+                            struct_span_err!(tcx.sess,\n+                                             span,\n+                                             E0120,\n+                                             \"the Drop trait may only be implemented on \\\n+                                              structures\")\n+                                    .span_label(span,\n+                                                &format!(\"implementing Drop requires a struct\"))\n+                                .emit();\n+                        }\n+                        _ => {\n+                            bug!(\"didn't find impl in ast map\");\n+                        }\n+                    }\n+                } else {\n+                    bug!(\"found external impl of Drop trait on \\\n+                          something other than a struct\");\n+                }\n+            }\n+        }\n+    });\n+}\n+\n+fn check_implementations_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let copy_trait = match tcx.lang_items.copy_trait() {\n+        Some(id) => id,\n+        None => return,\n+    };\n+    tcx.populate_implementations_for_trait_if_necessary(copy_trait);\n+    let copy_trait = tcx.lookup_trait_def(copy_trait);\n+\n+    copy_trait.for_each_impl(tcx, |impl_did| {\n+        debug!(\"check_implementations_of_copy: impl_did={:?}\", impl_did);\n+\n+        let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+            n\n+        } else {\n+            debug!(\"check_implementations_of_copy(): impl not in this \\\n+                    crate\");\n+            return;\n+        };\n+\n+        let self_type = tcx.item_type(impl_did);\n+        debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n+               self_type);\n+\n+        let span = tcx.map.span(impl_node_id);\n+        let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n+        let self_type = self_type.subst(tcx, &param_env.free_substs);\n+        assert!(!self_type.has_escaping_regions());\n+\n+        debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n+               self_type);\n+\n+        match param_env.can_type_implement_copy(tcx, self_type, span) {\n+            Ok(()) => {}\n+            Err(CopyImplementationError::InfrigingField(name)) => {\n+                struct_span_err!(tcx.sess,\n+                                 span,\n+                                 E0204,\n+                                 \"the trait `Copy` may not be implemented for this type\")\n+                    .span_label(span, &format!(\"field `{}` does not implement `Copy`\", name))\n+                    .emit()\n+            }\n+            Err(CopyImplementationError::InfrigingVariant(name)) => {\n+                let item = tcx.map.expect_item(impl_node_id);\n+                let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n+                    tr.path.span\n+                } else {\n+                    span\n+                };\n+\n+                struct_span_err!(tcx.sess,\n+                                 span,\n+                                 E0205,\n+                                 \"the trait `Copy` may not be implemented for this type\")\n+                    .span_label(span,\n+                                &format!(\"variant `{}` does not implement `Copy`\", name))\n+                    .emit()\n+            }\n+            Err(CopyImplementationError::NotAnAdt) => {\n+                let item = tcx.map.expect_item(impl_node_id);\n+                let span = if let ItemImpl(.., ref ty, _) = item.node {\n+                    ty.span\n+                } else {\n+                    span\n+                };\n+\n+                struct_span_err!(tcx.sess,\n+                                 span,\n+                                 E0206,\n+                                 \"the trait `Copy` may not be implemented for this type\")\n+                    .span_label(span, &format!(\"type is not a structure or enumeration\"))\n+                    .emit();\n+            }\n+            Err(CopyImplementationError::HasDestructor) => {\n+                struct_span_err!(tcx.sess,\n+                                 span,\n+                                 E0184,\n+                                 \"the trait `Copy` may not be implemented for this type; the \\\n+                                  type has a destructor\")\n+                        .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n+                    .emit();\n+            }\n+        }\n+    });\n+}\n+\n+fn check_implementations_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let coerce_unsized_trait = match tcx.lang_items.coerce_unsized_trait() {\n+        Some(id) => id,\n+        None => return,\n+    };\n+    let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n+        Ok(id) => id,\n+        Err(err) => {\n+            tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+        }\n+    };\n+\n+    let trait_def = tcx.lookup_trait_def(coerce_unsized_trait);\n+\n+    trait_def.for_each_impl(tcx, |impl_did| {\n+        debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n+               impl_did);\n+\n+        let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+            n\n+        } else {\n+            debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n+                    in this crate\");\n+            return;\n+        };\n+\n+        let source = tcx.item_type(impl_did);\n+        let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+        let target = trait_ref.substs.type_at(1);\n+        debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n+               source,\n+               target);\n+\n+        let span = tcx.map.span(impl_node_id);\n+        let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n+        let source = source.subst(tcx, &param_env.free_substs);\n+        let target = target.subst(tcx, &param_env.free_substs);\n+        assert!(!source.has_escaping_regions());\n+\n+        debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n+               source,\n+               target);\n+\n+        tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n+            let cause = ObligationCause::misc(span, impl_node_id);\n+            let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n+                               mt_b: ty::TypeAndMut<'tcx>,\n+                               mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+                if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n+                    infcx.report_mismatched_types(&cause,\n+                                                  mk_ptr(mt_b.ty),\n+                                                  target,\n+                                                  ty::error::TypeError::Mutability)\n+                         .emit();\n+                }\n+                (mt_a.ty, mt_b.ty, unsize_trait, None)\n+            };\n+            let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n+                (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n+\n+                (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n+                    infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n+                    check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n+                }\n+\n+                (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n+                (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n+                    check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+                }\n+\n+                (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b))\n+                    if def_a.is_struct() && def_b.is_struct() => {\n+                    if def_a != def_b {\n+                        let source_path = tcx.item_path_str(def_a.did);\n+                        let target_path = tcx.item_path_str(def_b.did);\n+                        span_err!(tcx.sess,\n+                                  span,\n+                                  E0377,\n+                                  \"the trait `CoerceUnsized` may only be implemented \\\n+                                   for a coercion between structures with the same \\\n+                                   definition; expected {}, found {}\",\n+                                  source_path,\n+                                  target_path);\n+                        return;\n+                    }\n+\n+                    let fields = &def_a.struct_variant().fields;\n+                    let diff_fields = fields.iter()\n+                        .enumerate()\n+                        .filter_map(|(i, f)| {\n+                            let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+\n+                            if tcx.item_type(f.did).is_phantom_data() {\n+                                // Ignore PhantomData fields\n+                                return None;\n+                            }\n+\n+                            // Ignore fields that aren't significantly changed\n+                            if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n+                                if ok.obligations.is_empty() {\n+                                    return None;\n+                                }\n+                            }\n+\n+                            // Collect up all fields that were significantly changed\n+                            // i.e. those that contain T in coerce_unsized T -> U\n+                            Some((i, a, b))\n+                        })\n+                        .collect::<Vec<_>>();\n+\n+                    if diff_fields.is_empty() {\n+                        span_err!(tcx.sess,\n+                                  span,\n+                                  E0374,\n+                                  \"the trait `CoerceUnsized` may only be implemented \\\n+                                   for a coercion between structures with one field \\\n+                                   being coerced, none found\");\n+                        return;\n+                    } else if diff_fields.len() > 1 {\n+                        let item = tcx.map.expect_item(impl_node_id);\n+                        let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n+                            t.path.span\n+                        } else {\n+                            tcx.map.span(impl_node_id)\n+                        };\n+\n+                        let mut err = struct_span_err!(tcx.sess,\n+                                                       span,\n+                                                       E0375,\n+                                                       \"implementing the trait \\\n+                                                        `CoerceUnsized` requires multiple \\\n+                                                        coercions\");\n+                        err.note(\"`CoerceUnsized` may only be implemented for \\\n+                                  a coercion between structures with one field being coerced\");\n+                        err.note(&format!(\"currently, {} fields need coercions: {}\",\n+                                          diff_fields.len(),\n+                                          diff_fields.iter()\n+                                          .map(|&(i, a, b)| {\n+                                              format!(\"{} ({} to {})\", fields[i].name, a, b)\n+                                          })\n+                                          .collect::<Vec<_>>()\n+                                          .join(\", \")));\n+                        err.span_label(span, &format!(\"requires multiple coercions\"));\n+                        err.emit();\n+                        return;\n+                    }\n+\n+                    let (i, a, b) = diff_fields[0];\n+                    let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n+                    (a, b, coerce_unsized_trait, Some(kind))\n+                }\n+\n+                _ => {\n+                    span_err!(tcx.sess,\n+                              span,\n+                              E0376,\n+                              \"the trait `CoerceUnsized` may only be implemented \\\n+                               for a coercion between structures\");\n+                    return;\n+                }\n+            };\n+\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+\n+            // Register an obligation for `A: Trait<B>`.\n+            let cause = traits::ObligationCause::misc(span, impl_node_id);\n+            let predicate =\n+                tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n+            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+\n+            // Check that all transitive obligations are satisfied.\n+            if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n+                infcx.report_fulfillment_errors(&errors);\n+            }\n+\n+            // Finally, resolve all regions.\n+            let mut free_regions = FreeRegionMap::new();\n+            free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n+                                                             .caller_bounds);\n+            infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n+\n+            if let Some(kind) = kind {\n+                tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n+            }\n+        });\n+    });\n+}"}, {"sha": "3293818348a94e34375a707eb281ab0c32fc9d21", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 352, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/f8a2f9838d9df85d757118a44855004f9805792f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8a2f9838d9df85d757118a44855004f9805792f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=f8a2f9838d9df85d757118a44855004f9805792f", "patch": "@@ -16,28 +16,23 @@\n // mappings. That mapping code resides here.\n \n use hir::def_id::DefId;\n-use middle::lang_items::UnsizeTraitLangItem;\n-use rustc::ty::subst::Subst;\n+use rustc::traits::Reveal;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n-use rustc::traits::{self, ObligationCause, Reveal};\n-use rustc::ty::ParameterEnvironment;\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyAdt, TyDynamic, TyNever, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n use rustc::ty::{TyProjection, TyAnon};\n-use rustc::ty::util::CopyImplementationError;\n-use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n-use rustc::infer::{self, InferCtxt};\n+use rustc::infer::{InferCtxt};\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n-use rustc::hir::map as hir_map;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n \n+mod builtin;\n mod orphan;\n mod overlap;\n mod unsafety;\n@@ -96,18 +91,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         self.crate_context.tcx.visit_all_item_likes_in_krate(\n             DepNode::CoherenceCheckImpl,\n             &mut CoherenceCheckVisitor { cc: self });\n-\n-        // Populate the table of destructors. It might seem a bit strange to\n-        // do this here, but it's actually the most convenient place, since\n-        // the coherence tables contain the trait -> type mappings.\n-        self.populate_destructors();\n-\n-        // Check to make sure implementations of `Copy` are legal.\n-        self.check_implementations_of_copy();\n-\n-        // Check to make sure implementations of `CoerceUnsized` are legal\n-        // and collect the necessary information from them.\n-        self.check_implementations_of_coerce_unsized();\n+        builtin::check(self.crate_context.tcx);\n     }\n \n     fn check_implementation(&self, item: &Item) {\n@@ -161,338 +145,6 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         let trait_def = self.crate_context.tcx.lookup_trait_def(impl_trait_ref.def_id);\n         trait_def.record_local_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n-\n-    // Destructors\n-    //\n-\n-    fn populate_destructors(&self) {\n-        let tcx = self.crate_context.tcx;\n-        let drop_trait = match tcx.lang_items.drop_trait() {\n-            Some(id) => id,\n-            None => return,\n-        };\n-        tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n-        let drop_trait = tcx.lookup_trait_def(drop_trait);\n-\n-        drop_trait.for_each_impl(tcx, |impl_did| {\n-            let items = tcx.associated_item_def_ids(impl_did);\n-            if items.is_empty() {\n-                // We'll error out later. For now, just don't ICE.\n-                return;\n-            }\n-            let method_def_id = items[0];\n-\n-            let self_type = tcx.item_type(impl_did);\n-            match self_type.sty {\n-                ty::TyAdt(type_def, _) => {\n-                    type_def.set_destructor(method_def_id);\n-                }\n-                _ => {\n-                    // Destructors only work on nominal types.\n-                    if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n-                        match tcx.map.find(impl_node_id) {\n-                            Some(hir_map::NodeItem(item)) => {\n-                                let span = match item.node {\n-                                    ItemImpl(.., ref ty, _) => ty.span,\n-                                    _ => item.span,\n-                                };\n-                                struct_span_err!(tcx.sess,\n-                                                 span,\n-                                                 E0120,\n-                                                 \"the Drop trait may only be implemented on \\\n-                                                  structures\")\n-                                    .span_label(span,\n-                                                &format!(\"implementing Drop requires a struct\"))\n-                                    .emit();\n-                            }\n-                            _ => {\n-                                bug!(\"didn't find impl in ast map\");\n-                            }\n-                        }\n-                    } else {\n-                        bug!(\"found external impl of Drop trait on \\\n-                              something other than a struct\");\n-                    }\n-                }\n-            }\n-        });\n-    }\n-\n-    /// Ensures that implementations of the built-in trait `Copy` are legal.\n-    fn check_implementations_of_copy(&self) {\n-        let tcx = self.crate_context.tcx;\n-        let copy_trait = match tcx.lang_items.copy_trait() {\n-            Some(id) => id,\n-            None => return,\n-        };\n-        tcx.populate_implementations_for_trait_if_necessary(copy_trait);\n-        let copy_trait = tcx.lookup_trait_def(copy_trait);\n-\n-        copy_trait.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_copy: impl_did={:?}\", impl_did);\n-\n-            let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n-                n\n-            } else {\n-                debug!(\"check_implementations_of_copy(): impl not in this \\\n-                        crate\");\n-                return;\n-            };\n-\n-            let self_type = tcx.item_type(impl_did);\n-            debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n-                   self_type);\n-\n-            let span = tcx.map.span(impl_node_id);\n-            let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-            let self_type = self_type.subst(tcx, &param_env.free_substs);\n-            assert!(!self_type.has_escaping_regions());\n-\n-            debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n-                   self_type);\n-\n-            match param_env.can_type_implement_copy(tcx, self_type, span) {\n-                Ok(()) => {}\n-                Err(CopyImplementationError::InfrigingField(name)) => {\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0204,\n-                                     \"the trait `Copy` may not be implemented for this type\")\n-                        .span_label(span, &format!(\"field `{}` does not implement `Copy`\", name))\n-                        .emit()\n-                }\n-                Err(CopyImplementationError::InfrigingVariant(name)) => {\n-                    let item = tcx.map.expect_item(impl_node_id);\n-                    let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n-                        tr.path.span\n-                    } else {\n-                        span\n-                    };\n-\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0205,\n-                                     \"the trait `Copy` may not be implemented for this type\")\n-                        .span_label(span,\n-                                    &format!(\"variant `{}` does not implement `Copy`\", name))\n-                        .emit()\n-                }\n-                Err(CopyImplementationError::NotAnAdt) => {\n-                    let item = tcx.map.expect_item(impl_node_id);\n-                    let span = if let ItemImpl(.., ref ty, _) = item.node {\n-                        ty.span\n-                    } else {\n-                        span\n-                    };\n-\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0206,\n-                                     \"the trait `Copy` may not be implemented for this type\")\n-                        .span_label(span, &format!(\"type is not a structure or enumeration\"))\n-                        .emit();\n-                }\n-                Err(CopyImplementationError::HasDestructor) => {\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0184,\n-                                     \"the trait `Copy` may not be implemented for this type; the \\\n-                                      type has a destructor\")\n-                        .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n-                        .emit();\n-                }\n-            }\n-        });\n-    }\n-\n-    /// Process implementations of the built-in trait `CoerceUnsized`.\n-    fn check_implementations_of_coerce_unsized(&self) {\n-        let tcx = self.crate_context.tcx;\n-        let coerce_unsized_trait = match tcx.lang_items.coerce_unsized_trait() {\n-            Some(id) => id,\n-            None => return,\n-        };\n-        let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n-            Ok(id) => id,\n-            Err(err) => {\n-                tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n-            }\n-        };\n-\n-        let trait_def = tcx.lookup_trait_def(coerce_unsized_trait);\n-\n-        trait_def.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n-                   impl_did);\n-\n-            let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n-                n\n-            } else {\n-                debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n-                        in this crate\");\n-                return;\n-            };\n-\n-            let source = tcx.item_type(impl_did);\n-            let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n-            let target = trait_ref.substs.type_at(1);\n-            debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n-                   source,\n-                   target);\n-\n-            let span = tcx.map.span(impl_node_id);\n-            let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-            let source = source.subst(tcx, &param_env.free_substs);\n-            let target = target.subst(tcx, &param_env.free_substs);\n-            assert!(!source.has_escaping_regions());\n-\n-            debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n-                   source,\n-                   target);\n-\n-            tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n-                let cause = ObligationCause::misc(span, impl_node_id);\n-                let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n-                                   mt_b: ty::TypeAndMut<'gcx>,\n-                                   mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n-                    if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n-                        infcx.report_mismatched_types(&cause,\n-                                                      mk_ptr(mt_b.ty),\n-                                                      target,\n-                                                      ty::error::TypeError::Mutability).emit();\n-                    }\n-                    (mt_a.ty, mt_b.ty, unsize_trait, None)\n-                };\n-                let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n-                    (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n-\n-                    (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n-                        infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n-                        check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n-                    }\n-\n-                    (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n-                    (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n-                        check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n-                    }\n-\n-                    (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b))\n-                        if def_a.is_struct() && def_b.is_struct() => {\n-                        if def_a != def_b {\n-                            let source_path = tcx.item_path_str(def_a.did);\n-                            let target_path = tcx.item_path_str(def_b.did);\n-                            span_err!(tcx.sess,\n-                                      span,\n-                                      E0377,\n-                                      \"the trait `CoerceUnsized` may only be implemented \\\n-                                       for a coercion between structures with the same \\\n-                                       definition; expected {}, found {}\",\n-                                      source_path,\n-                                      target_path);\n-                            return;\n-                        }\n-\n-                        let fields = &def_a.struct_variant().fields;\n-                        let diff_fields = fields.iter()\n-                            .enumerate()\n-                            .filter_map(|(i, f)| {\n-                                let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n-\n-                                if tcx.item_type(f.did).is_phantom_data() {\n-                                    // Ignore PhantomData fields\n-                                    return None;\n-                                }\n-\n-                                // Ignore fields that aren't significantly changed\n-                                if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n-                                    if ok.obligations.is_empty() {\n-                                        return None;\n-                                    }\n-                                }\n-\n-                                // Collect up all fields that were significantly changed\n-                                // i.e. those that contain T in coerce_unsized T -> U\n-                                Some((i, a, b))\n-                            })\n-                            .collect::<Vec<_>>();\n-\n-                        if diff_fields.is_empty() {\n-                            span_err!(tcx.sess,\n-                                      span,\n-                                      E0374,\n-                                      \"the trait `CoerceUnsized` may only be implemented \\\n-                                       for a coercion between structures with one field \\\n-                                       being coerced, none found\");\n-                            return;\n-                        } else if diff_fields.len() > 1 {\n-                            let item = tcx.map.expect_item(impl_node_id);\n-                            let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n-                                t.path.span\n-                            } else {\n-                                tcx.map.span(impl_node_id)\n-                            };\n-\n-                            let mut err = struct_span_err!(tcx.sess,\n-                                                           span,\n-                                                           E0375,\n-                                                           \"implementing the trait \\\n-                                                            `CoerceUnsized` requires multiple \\\n-                                                            coercions\");\n-                            err.note(\"`CoerceUnsized` may only be implemented for \\\n-                                      a coercion between structures with one field being coerced\");\n-                            err.note(&format!(\"currently, {} fields need coercions: {}\",\n-                                              diff_fields.len(),\n-                                              diff_fields.iter()\n-                                                  .map(|&(i, a, b)| {\n-                                                      format!(\"{} ({} to {})\", fields[i].name, a, b)\n-                                                  })\n-                                                  .collect::<Vec<_>>()\n-                                                  .join(\", \")));\n-                            err.span_label(span, &format!(\"requires multiple coercions\"));\n-                            err.emit();\n-                            return;\n-                        }\n-\n-                        let (i, a, b) = diff_fields[0];\n-                        let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n-                        (a, b, coerce_unsized_trait, Some(kind))\n-                    }\n-\n-                    _ => {\n-                        span_err!(tcx.sess,\n-                                  span,\n-                                  E0376,\n-                                  \"the trait `CoerceUnsized` may only be implemented \\\n-                                   for a coercion between structures\");\n-                        return;\n-                    }\n-                };\n-\n-                let mut fulfill_cx = traits::FulfillmentContext::new();\n-\n-                // Register an obligation for `A: Trait<B>`.\n-                let cause = traits::ObligationCause::misc(span, impl_node_id);\n-                let predicate =\n-                    tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-\n-                // Check that all transitive obligations are satisfied.\n-                if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n-                    infcx.report_fulfillment_errors(&errors);\n-                }\n-\n-                // Finally, resolve all regions.\n-                let mut free_regions = FreeRegionMap::new();\n-                free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n-                    .caller_bounds);\n-                infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n-\n-                if let Some(kind) = kind {\n-                    tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n-                }\n-            });\n-        });\n-    }\n }\n \n fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: DefId) {"}]}