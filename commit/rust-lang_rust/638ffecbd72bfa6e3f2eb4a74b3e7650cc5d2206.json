{"sha": "638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzOGZmZWNiZDcyYmZhNmUzZjJlYjRhNzRiM2U3NjUwY2M1ZDIyMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-04T11:10:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-04T11:10:16Z"}, "message": "Auto merge of #26728 - arielb1:assoc-maybe, r=nrc\n\nr? @nrc", "tree": {"sha": "282bc78a385126bec9081dce88c3269301b6e013", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/282bc78a385126bec9081dce88c3269301b6e013"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206", "html_url": "https://github.com/rust-lang/rust/commit/638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dc08240ea755679e3daec3832a04b22a8fc90bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dc08240ea755679e3daec3832a04b22a8fc90bf", "html_url": "https://github.com/rust-lang/rust/commit/0dc08240ea755679e3daec3832a04b22a8fc90bf"}, {"sha": "6b27005f2f8b20834838828588233b877a29d509", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b27005f2f8b20834838828588233b877a29d509", "html_url": "https://github.com/rust-lang/rust/commit/6b27005f2f8b20834838828588233b877a29d509"}], "stats": {"total": 237, "additions": 122, "deletions": 115}, "files": [{"sha": "9704bef6487749b1968c84d6dc5eaa613e762fad", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 94, "deletions": 114, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206", "patch": "@@ -846,128 +846,82 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Locate trait methods\n     let tcx = ccx.tcx;\n     let trait_items = tcx.trait_items(impl_trait_ref.def_id);\n+    let mut overridden_associated_type = None;\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n+        let ty_impl_item = ccx.tcx.impl_or_trait_item(local_def(impl_item.id));\n+        let ty_trait_item = trait_items.iter()\n+            .find(|ac| ac.name() == ty_impl_item.name())\n+            .unwrap_or_else(|| {\n+                // This is checked by resolve\n+                tcx.sess.span_bug(impl_item.span,\n+                                  &format!(\"impl-item `{}` is not a member of `{:?}`\",\n+                                           token::get_name(ty_impl_item.name()),\n+                                           impl_trait_ref));\n+            });\n         match impl_item.node {\n             ast::ConstImplItem(..) => {\n-                let impl_const_def_id = local_def(impl_item.id);\n-                let impl_const_ty = ccx.tcx.impl_or_trait_item(impl_const_def_id);\n+                let impl_const = match ty_impl_item {\n+                    ty::ConstTraitItem(ref cti) => cti,\n+                    _ => tcx.sess.span_bug(impl_item.span, \"non-const impl-item for const\")\n+                };\n \n                 // Find associated const definition.\n-                let opt_associated_const =\n-                    trait_items.iter()\n-                               .find(|ac| ac.name() == impl_const_ty.name());\n-                match opt_associated_const {\n-                    Some(associated_const) => {\n-                        match (associated_const, &impl_const_ty) {\n-                            (&ty::ConstTraitItem(ref const_trait),\n-                             &ty::ConstTraitItem(ref const_impl)) => {\n-                                compare_const_impl(ccx.tcx,\n-                                                   &const_impl,\n-                                                   impl_item.span,\n-                                                   &const_trait,\n-                                                   &*impl_trait_ref);\n-                            }\n-                            _ => {\n-                                span_err!(tcx.sess, impl_item.span, E0323,\n-                                          \"item `{}` is an associated const, \\\n-                                          which doesn't match its trait `{:?}`\",\n-                                          token::get_name(impl_const_ty.name()),\n-                                          impl_trait_ref)\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        // This is `span_bug` as it should have already been\n-                        // caught in resolve.\n-                        tcx.sess.span_bug(\n-                            impl_item.span,\n-                            &format!(\n-                                \"associated const `{}` is not a member of \\\n-                                 trait `{:?}`\",\n-                                token::get_name(impl_const_ty.name()),\n-                                impl_trait_ref));\n-                    }\n+                if let &ty::ConstTraitItem(ref trait_const) = ty_trait_item {\n+                    compare_const_impl(ccx.tcx,\n+                                       &impl_const,\n+                                       impl_item.span,\n+                                       trait_const,\n+                                       &*impl_trait_ref);\n+                } else {\n+                    span_err!(tcx.sess, impl_item.span, E0323,\n+                              \"item `{}` is an associated const, \\\n+                              which doesn't match its trait `{:?}`\",\n+                              token::get_name(impl_const.name),\n+                              impl_trait_ref)\n                 }\n             }\n             ast::MethodImplItem(ref sig, ref body) => {\n                 check_trait_fn_not_const(ccx, impl_item.span, sig.constness);\n \n-                let impl_method_def_id = local_def(impl_item.id);\n-                let impl_item_ty = ccx.tcx.impl_or_trait_item(impl_method_def_id);\n-\n-                // If this is an impl of a trait method, find the\n-                // corresponding method definition in the trait.\n-                let opt_trait_method_ty =\n-                    trait_items.iter()\n-                               .find(|ti| ti.name() == impl_item_ty.name());\n-                match opt_trait_method_ty {\n-                    Some(trait_method_ty) => {\n-                        match (trait_method_ty, &impl_item_ty) {\n-                            (&ty::MethodTraitItem(ref trait_method_ty),\n-                             &ty::MethodTraitItem(ref impl_method_ty)) => {\n-                                compare_impl_method(ccx.tcx,\n-                                                    &**impl_method_ty,\n-                                                    impl_item.span,\n-                                                    body.id,\n-                                                    &**trait_method_ty,\n-                                                    &*impl_trait_ref);\n-                            }\n-                            _ => {\n-                                span_err!(tcx.sess, impl_item.span, E0324,\n-                                          \"item `{}` is an associated method, \\\n-                                          which doesn't match its trait `{:?}`\",\n-                                          token::get_name(impl_item_ty.name()),\n-                                          impl_trait_ref)\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        // This is span_bug as it should have already been\n-                        // caught in resolve.\n-                        tcx.sess.span_bug(\n-                            impl_item.span,\n-                            &format!(\"method `{}` is not a member of trait `{:?}`\",\n-                                     token::get_name(impl_item_ty.name()),\n-                                     impl_trait_ref));\n-                    }\n+                let impl_method = match ty_impl_item {\n+                    ty::MethodTraitItem(ref mti) => mti,\n+                    _ => tcx.sess.span_bug(impl_item.span, \"non-method impl-item for method\")\n+                };\n+\n+                if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n+                    compare_impl_method(ccx.tcx,\n+                                        &impl_method,\n+                                        impl_item.span,\n+                                        body.id,\n+                                        &trait_method,\n+                                        &impl_trait_ref);\n+                } else {\n+                    span_err!(tcx.sess, impl_item.span, E0324,\n+                              \"item `{}` is an associated method, \\\n+                              which doesn't match its trait `{:?}`\",\n+                              token::get_name(impl_method.name),\n+                              impl_trait_ref)\n                 }\n             }\n             ast::TypeImplItem(_) => {\n-                let typedef_def_id = local_def(impl_item.id);\n-                let typedef_ty = ccx.tcx.impl_or_trait_item(typedef_def_id);\n-\n-                // If this is an impl of an associated type, find the\n-                // corresponding type definition in the trait.\n-                let opt_associated_type =\n-                    trait_items.iter()\n-                               .find(|ti| ti.name() == typedef_ty.name());\n-                match opt_associated_type {\n-                    Some(associated_type) => {\n-                        match (associated_type, &typedef_ty) {\n-                            (&ty::TypeTraitItem(_), &ty::TypeTraitItem(_)) => {}\n-                            _ => {\n-                                span_err!(tcx.sess, impl_item.span, E0325,\n-                                          \"item `{}` is an associated type, \\\n-                                          which doesn't match its trait `{:?}`\",\n-                                          token::get_name(typedef_ty.name()),\n-                                          impl_trait_ref)\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        // This is `span_bug` as it should have already been\n-                        // caught in resolve.\n-                        tcx.sess.span_bug(\n-                            impl_item.span,\n-                            &format!(\n-                                \"associated type `{}` is not a member of \\\n-                                 trait `{:?}`\",\n-                                token::get_name(typedef_ty.name()),\n-                                impl_trait_ref));\n+                let impl_type = match ty_impl_item {\n+                    ty::TypeTraitItem(ref tti) => tti,\n+                    _ => tcx.sess.span_bug(impl_item.span, \"non-type impl-item for type\")\n+                };\n+\n+                if let &ty::TypeTraitItem(ref at) = ty_trait_item {\n+                    if let Some(_) = at.ty {\n+                        overridden_associated_type = Some(impl_item);\n                     }\n+                } else {\n+                    span_err!(tcx.sess, impl_item.span, E0325,\n+                              \"item `{}` is an associated type, \\\n+                              which doesn't match its trait `{:?}`\",\n+                              token::get_name(impl_type.name),\n+                              impl_trait_ref)\n                 }\n             }\n             ast::MacImplItem(_) => tcx.sess.span_bug(impl_item.span,\n@@ -979,6 +933,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let provided_methods = tcx.provided_trait_methods(impl_trait_ref.def_id);\n     let associated_consts = tcx.associated_consts(impl_trait_ref.def_id);\n     let mut missing_items = Vec::new();\n+    let mut invalidated_items = Vec::new();\n+    let associated_type_overridden = overridden_associated_type.is_some();\n     for trait_item in trait_items.iter() {\n         match *trait_item {\n             ty::ConstTraitItem(ref associated_const) => {\n@@ -993,9 +949,12 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let is_provided =\n                     associated_consts.iter().any(|ac| ac.default.is_some() &&\n                                                  ac.name == associated_const.name);\n-                if !is_implemented && !is_provided {\n-                    missing_items.push(format!(\"`{}`\",\n-                                               token::get_name(associated_const.name)));\n+                if !is_implemented {\n+                    if !is_provided {\n+                        missing_items.push(associated_const.name);\n+                    } else if associated_type_overridden {\n+                        invalidated_items.push(associated_const.name);\n+                    }\n                 }\n             }\n             ty::MethodTraitItem(ref trait_method) => {\n@@ -1010,8 +969,12 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     });\n                 let is_provided =\n                     provided_methods.iter().any(|m| m.name == trait_method.name);\n-                if !is_implemented && !is_provided {\n-                    missing_items.push(format!(\"`{}`\", token::get_name(trait_method.name)));\n+                if !is_implemented {\n+                    if !is_provided {\n+                        missing_items.push(trait_method.name);\n+                    } else if associated_type_overridden {\n+                        invalidated_items.push(trait_method.name);\n+                    }\n                 }\n             }\n             ty::TypeTraitItem(ref associated_type) => {\n@@ -1024,17 +987,34 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     }\n                 });\n                 let is_provided = associated_type.ty.is_some();\n-                if !is_implemented && !is_provided {\n-                    missing_items.push(format!(\"`{}`\", token::get_name(associated_type.name)));\n+                if !is_implemented {\n+                    if !is_provided {\n+                        missing_items.push(associated_type.name);\n+                    } else if associated_type_overridden {\n+                        invalidated_items.push(associated_type.name);\n+                    }\n                 }\n             }\n         }\n     }\n \n     if !missing_items.is_empty() {\n         span_err!(tcx.sess, impl_span, E0046,\n-            \"not all trait items implemented, missing: {}\",\n-            missing_items.connect(\", \"));\n+            \"not all trait items implemented, missing: `{}`\",\n+            missing_items.iter()\n+                  .map(<ast::Name>::as_str)\n+                  .collect::<Vec<_>>().connect(\"`, `\"))\n+    }\n+\n+    if !invalidated_items.is_empty() {\n+        let invalidator = overridden_associated_type.unwrap();\n+        span_err!(tcx.sess, invalidator.span, E0399,\n+                  \"the following trait items need to be reimplemented \\\n+                   as `{}` was overridden: `{}`\",\n+                  invalidator.ident.as_str(),\n+                  invalidated_items.iter()\n+                                   .map(<ast::Name>::as_str)\n+                                   .collect::<Vec<_>>().connect(\"`, `\"))\n     }\n }\n "}, {"sha": "549c89599ecd82cc955e1b60d5aabac58693c7af", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206", "patch": "@@ -2066,6 +2066,8 @@ register_diagnostics! {\n            // `#[lang = \\\"{}\\\"]` is allowed for the `{}` primitive\n     E0391, // unsupported cyclic reference between types/traits detected\n     E0392, // parameter `{}` is never used\n-    E0393  // the type parameter `{}` must be explicitly specified in an object\n+    E0393, // the type parameter `{}` must be explicitly specified in an object\n            // type because its default value `{}` references the type `Self`\"\n+    E0399  // trait items need to be implemented because the associated\n+           // type `{}` was overridden\n }"}, {"sha": "eb519e79006d2c8dd9e66a75a193c35ae341cf7a", "filename": "src/test/compile-fail/associated-types-overridden-default.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206/src%2Ftest%2Fcompile-fail%2Fassociated-types-overridden-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206/src%2Ftest%2Fcompile-fail%2Fassociated-types-overridden-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-overridden-default.rs?ref=638ffecbd72bfa6e3f2eb4a74b3e7650cc5d2206", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+pub trait Tr {\n+    type Assoc = u8;\n+    type Assoc2 = Self::Assoc;\n+    const C: u8 = 11;\n+    fn foo(&self) {}\n+}\n+\n+impl Tr for () {\n+    type Assoc = ();\n+    //~^ ERROR need to be reimplemented as `Assoc` was overridden: `Assoc2`, `C`, `foo`\n+}\n+\n+fn main() {}"}]}