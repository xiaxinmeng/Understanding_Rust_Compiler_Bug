{"sha": "85d50ce1c72dc577fad26a81acea390c60bb48c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZDUwY2UxYzcyZGM1NzdmYWQyNmE4MWFjZWEzOTBjNjBiYjQ4YzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-24T10:06:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-24T10:06:09Z"}, "message": "Auto merge of #46012 - Gankro:float-conv-transmute, r=sfackler\n\nMake float::from_bits transmute\n\nSee commit message for details.\n\nSee also this discussion here: https://github.com/rust-lang/rust/issues/40470#issuecomment-343803381\n\n(may require libs team discussion before merging)", "tree": {"sha": "ad98dd938ce683c7a769ce33219faab69d248b7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad98dd938ce683c7a769ce33219faab69d248b7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85d50ce1c72dc577fad26a81acea390c60bb48c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85d50ce1c72dc577fad26a81acea390c60bb48c2", "html_url": "https://github.com/rust-lang/rust/commit/85d50ce1c72dc577fad26a81acea390c60bb48c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85d50ce1c72dc577fad26a81acea390c60bb48c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb44c89641f6b570d2ec934f5b43f865b31d7dcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb44c89641f6b570d2ec934f5b43f865b31d7dcb", "html_url": "https://github.com/rust-lang/rust/commit/eb44c89641f6b570d2ec934f5b43f865b31d7dcb"}, {"sha": "439576fd7bedf741db5fb6a21c902e858d51f2a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/439576fd7bedf741db5fb6a21c902e858d51f2a0", "html_url": "https://github.com/rust-lang/rust/commit/439576fd7bedf741db5fb6a21c902e858d51f2a0"}], "stats": {"total": 162, "additions": 86, "deletions": 76}, "files": [{"sha": "e5b1394f0709abff3569440a0ca0cea51a4ba3db", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 43, "deletions": 48, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/85d50ce1c72dc577fad26a81acea390c60bb48c2/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d50ce1c72dc577fad26a81acea390c60bb48c2/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=85d50ce1c72dc577fad26a81acea390c60bb48c2", "patch": "@@ -998,10 +998,13 @@ impl f32 {\n \n     /// Raw transmutation to `u32`.\n     ///\n-    /// Converts the `f32` into its raw memory representation,\n-    /// similar to the `transmute` function.\n+    /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms.\n     ///\n-    /// Note that this function is distinct from casting.\n+    /// See `from_bits` for some discussion of the portability of this operation\n+    /// (there are almost no issues).\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n     ///\n     /// # Examples\n     ///\n@@ -1018,17 +1021,33 @@ impl f32 {\n \n     /// Raw transmutation from `u32`.\n     ///\n-    /// Converts the given `u32` containing the float's raw memory\n-    /// representation into the `f32` type, similar to the\n-    /// `transmute` function.\n+    /// This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n+    /// It turns out this is incredibly portable, for two reasons:\n+    ///\n+    /// * Floats and Ints have the same endianess on all supported platforms.\n+    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    ///\n+    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n+    /// (notably x86 and ARM) picked the interpretation that was ultimately\n+    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n+    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n+    ///\n+    /// Rather than trying to preserve signaling-ness cross-platform, this\n+    /// implementation favours preserving the exact bits. This means that\n+    /// any payloads encoded in NaNs will be preserved even if the result of\n+    /// this method is sent over the network from an x86 machine to a MIPS one.\n+    ///\n+    /// If the results of this method are only manipulated by the same\n+    /// architecture that produced them, then there is no portability concern.\n+    ///\n+    /// If the input isn't NaN, then there is no portability concern.\n     ///\n-    /// There is only one difference to a bare `transmute`:\n-    /// Due to the implications onto Rust's safety promises being\n-    /// uncertain, if the representation of a signaling NaN \"sNaN\" float\n-    /// is passed to the function, the implementation is allowed to\n-    /// return a quiet NaN instead.\n+    /// If you don't care about signalingness (very likely), then there is no\n+    /// portability concern.\n     ///\n-    /// Note that this function is distinct from casting.\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n     ///\n     /// # Examples\n     ///\n@@ -1037,25 +1056,11 @@ impl f32 {\n     /// let v = f32::from_bits(0x41480000);\n     /// let difference = (v - 12.5).abs();\n     /// assert!(difference <= 1e-5);\n-    /// // Example for a signaling NaN value:\n-    /// let snan = 0x7F800001;\n-    /// assert_ne!(f32::from_bits(snan).to_bits(), snan);\n     /// ```\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n-    pub fn from_bits(mut v: u32) -> Self {\n-        const EXP_MASK: u32   = 0x7F800000;\n-        const FRACT_MASK: u32 = 0x007FFFFF;\n-        if v & EXP_MASK == EXP_MASK && v & FRACT_MASK != 0 {\n-            // While IEEE 754-2008 specifies encodings for quiet NaNs\n-            // and signaling ones, certain MIPS and PA-RISC\n-            // CPUs treat signaling NaNs differently.\n-            // Therefore to be safe, we pass a known quiet NaN\n-            // if v is any kind of NaN.\n-            // The check above only assumes IEEE 754-1985 to be\n-            // valid.\n-            v = unsafe { ::mem::transmute(NAN) };\n-        }\n+    pub fn from_bits(v: u32) -> Self {\n+        // It turns out the safety issues with sNaN were overblown! Hooray!\n         unsafe { ::mem::transmute(v) }\n     }\n }\n@@ -1646,25 +1651,15 @@ mod tests {\n         assert_approx_eq!(f32::from_bits(0x41480000), 12.5);\n         assert_approx_eq!(f32::from_bits(0x44a72000), 1337.0);\n         assert_approx_eq!(f32::from_bits(0xc1640000), -14.25);\n-    }\n-    #[test]\n-    fn test_snan_masking() {\n-        // NOTE: this test assumes that our current platform\n-        // implements IEEE 754-2008 that specifies the difference\n-        // in encoding of quiet and signaling NaNs.\n-        // If you are porting Rust to a platform that does not\n-        // implement IEEE 754-2008 (but e.g. IEEE 754-1985, which\n-        // only says that \"Signaling NaNs shall be reserved operands\"\n-        // but doesn't specify the actual setup), feel free to\n-        // cfg out this test.\n-        let snan: u32 = 0x7F801337;\n-        const QNAN_MASK: u32  = 0x00400000;\n-        let nan_masked_fl = f32::from_bits(snan);\n-        let nan_masked = nan_masked_fl.to_bits();\n-        // Ensure that signaling NaNs don't stay the same\n-        assert_ne!(nan_masked, snan);\n-        // Ensure that we have a quiet NaN\n-        assert_ne!(nan_masked & QNAN_MASK, 0);\n-        assert!(nan_masked_fl.is_nan());\n+\n+        // Check that NaNs roundtrip their bits regardless of signalingness\n+        // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+        let masked_nan1 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n+        let masked_nan2 = f32::NAN.to_bits() ^ 0x0055_5555;\n+        assert!(f32::from_bits(masked_nan1).is_nan());\n+        assert!(f32::from_bits(masked_nan2).is_nan());\n+\n+        assert_eq!(f32::from_bits(masked_nan1).to_bits(), masked_nan1);\n+        assert_eq!(f32::from_bits(masked_nan2).to_bits(), masked_nan2);\n     }\n }"}, {"sha": "f4d804fd50823636bde6faac2738ab7154c7cfdd", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/85d50ce1c72dc577fad26a81acea390c60bb48c2/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85d50ce1c72dc577fad26a81acea390c60bb48c2/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=85d50ce1c72dc577fad26a81acea390c60bb48c2", "patch": "@@ -953,10 +953,13 @@ impl f64 {\n \n     /// Raw transmutation to `u64`.\n     ///\n-    /// Converts the `f64` into its raw memory representation,\n-    /// similar to the `transmute` function.\n+    /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms.\n     ///\n-    /// Note that this function is distinct from casting.\n+    /// See `from_bits` for some discussion of the portability of this operation\n+    /// (there are almost no issues).\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n     ///\n     /// # Examples\n     ///\n@@ -973,17 +976,33 @@ impl f64 {\n \n     /// Raw transmutation from `u64`.\n     ///\n-    /// Converts the given `u64` containing the float's raw memory\n-    /// representation into the `f64` type, similar to the\n-    /// `transmute` function.\n+    /// This is currently identical to `transmute::<u64, f64>(v)` on all platforms.\n+    /// It turns out this is incredibly portable, for two reasons:\n+    ///\n+    /// * Floats and Ints have the same endianess on all supported platforms.\n+    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    ///\n+    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n+    /// (notably x86 and ARM) picked the interpretation that was ultimately\n+    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n+    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n+    ///\n+    /// Rather than trying to preserve signaling-ness cross-platform, this\n+    /// implementation favours preserving the exact bits. This means that\n+    /// any payloads encoded in NaNs will be preserved even if the result of\n+    /// this method is sent over the network from an x86 machine to a MIPS one.\n+    ///\n+    /// If the results of this method are only manipulated by the same\n+    /// architecture that produced them, then there is no portability concern.\n     ///\n-    /// There is only one difference to a bare `transmute`:\n-    /// Due to the implications onto Rust's safety promises being\n-    /// uncertain, if the representation of a signaling NaN \"sNaN\" float\n-    /// is passed to the function, the implementation is allowed to\n-    /// return a quiet NaN instead.\n+    /// If the input isn't NaN, then there is no portability concern.\n     ///\n-    /// Note that this function is distinct from casting.\n+    /// If you don't care about signalingness (very likely), then there is no\n+    /// portability concern.\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n     ///\n     /// # Examples\n     ///\n@@ -992,25 +1011,11 @@ impl f64 {\n     /// let v = f64::from_bits(0x4029000000000000);\n     /// let difference = (v - 12.5).abs();\n     /// assert!(difference <= 1e-5);\n-    /// // Example for a signaling NaN value:\n-    /// let snan = 0x7FF0000000000001;\n-    /// assert_ne!(f64::from_bits(snan).to_bits(), snan);\n     /// ```\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n-    pub fn from_bits(mut v: u64) -> Self {\n-        const EXP_MASK: u64   = 0x7FF0000000000000;\n-        const FRACT_MASK: u64 = 0x000FFFFFFFFFFFFF;\n-        if v & EXP_MASK == EXP_MASK && v & FRACT_MASK != 0 {\n-            // While IEEE 754-2008 specifies encodings for quiet NaNs\n-            // and signaling ones, certain MIPS and PA-RISC\n-            // CPUs treat signaling NaNs differently.\n-            // Therefore to be safe, we pass a known quiet NaN\n-            // if v is any kind of NaN.\n-            // The check above only assumes IEEE 754-1985 to be\n-            // valid.\n-            v = unsafe { ::mem::transmute(NAN) };\n-        }\n+    pub fn from_bits(v: u64) -> Self {\n+        // It turns out the safety issues with sNaN were overblown! Hooray!\n         unsafe { ::mem::transmute(v) }\n     }\n }\n@@ -1597,5 +1602,15 @@ mod tests {\n         assert_approx_eq!(f64::from_bits(0x4029000000000000), 12.5);\n         assert_approx_eq!(f64::from_bits(0x4094e40000000000), 1337.0);\n         assert_approx_eq!(f64::from_bits(0xc02c800000000000), -14.25);\n+\n+        // Check that NaNs roundtrip their bits regardless of signalingness\n+        // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+        let masked_nan1 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n+        let masked_nan2 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n+        assert!(f64::from_bits(masked_nan1).is_nan());\n+        assert!(f64::from_bits(masked_nan2).is_nan());\n+\n+        assert_eq!(f64::from_bits(masked_nan1).to_bits(), masked_nan1);\n+        assert_eq!(f64::from_bits(masked_nan2).to_bits(), masked_nan2);\n     }\n }"}]}