{"sha": "f9f4707469c2bc44ba3d643c805c8f3f62db7bd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZjQ3MDc0NjljMmJjNDRiYTNkNjQzYzgwNWM4ZjNmNjJkYjdiZDU=", "commit": {"author": {"name": "Alex Burka", "email": "alex@alexburka.com", "date": "2017-04-21T23:54:38Z"}, "committer": {"name": "Alex Burka", "email": "alex@alexburka.com", "date": "2017-07-11T20:31:22Z"}, "message": "let #[allow_internal_unstable] cover :vis", "tree": {"sha": "053e3b20242408e6b84154599e868952f280e5ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/053e3b20242408e6b84154599e868952f280e5ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9f4707469c2bc44ba3d643c805c8f3f62db7bd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f4707469c2bc44ba3d643c805c8f3f62db7bd5", "html_url": "https://github.com/rust-lang/rust/commit/f9f4707469c2bc44ba3d643c805c8f3f62db7bd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9f4707469c2bc44ba3d643c805c8f3f62db7bd5/comments", "author": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e7c4888b717a24dfc68f47c5dde00334fed2317", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e7c4888b717a24dfc68f47c5dde00334fed2317", "html_url": "https://github.com/rust-lang/rust/commit/8e7c4888b717a24dfc68f47c5dde00334fed2317"}], "stats": {"total": 27, "additions": 19, "deletions": 8}, "files": [{"sha": "f786b1abb8a1b4252670e836d2d88bb811d7ec28", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9f4707469c2bc44ba3d643c805c8f3f62db7bd5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f4707469c2bc44ba3d643c805c8f3f62db7bd5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=f9f4707469c2bc44ba3d643c805c8f3f62db7bd5", "patch": "@@ -222,7 +222,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n                         let tt = quoted::parse(tt.clone().into(), true, sess).pop().unwrap();\n-                        valid &= check_lhs_nt_follows(sess, features, &tt);\n+                        valid &= check_lhs_nt_follows(sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n                 }\n@@ -272,11 +272,12 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n \n fn check_lhs_nt_follows(sess: &ParseSess,\n                         features: &RefCell<Features>,\n+                        attrs: &[ast::Attribute],\n                         lhs: &quoted::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     if let quoted::TokenTree::Delimited(_, ref tts) = *lhs {\n-        check_matcher(sess, features, &tts.tts)\n+        check_matcher(sess, features, attrs, &tts.tts)\n     } else {\n         let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n         sess.span_diagnostic.span_err(lhs.span(), msg);\n@@ -328,11 +329,12 @@ fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool {\n \n fn check_matcher(sess: &ParseSess,\n                  features: &RefCell<Features>,\n+                 attrs: &[ast::Attribute],\n                  matcher: &[quoted::TokenTree]) -> bool {\n     let first_sets = FirstSets::new(matcher);\n     let empty_suffix = TokenSet::empty();\n     let err = sess.span_diagnostic.err_count();\n-    check_matcher_core(sess, features, &first_sets, matcher, &empty_suffix);\n+    check_matcher_core(sess, features, attrs, &first_sets, matcher, &empty_suffix);\n     err == sess.span_diagnostic.err_count()\n }\n \n@@ -575,6 +577,7 @@ impl TokenSet {\n // see `FirstSets::new`.\n fn check_matcher_core(sess: &ParseSess,\n                       features: &RefCell<Features>,\n+                      attrs: &[ast::Attribute],\n                       first_sets: &FirstSets,\n                       matcher: &[quoted::TokenTree],\n                       follow: &TokenSet) -> TokenSet {\n@@ -605,7 +608,7 @@ fn check_matcher_core(sess: &ParseSess,\n         match *token {\n             TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => {\n                 let can_be_followed_by_any;\n-                if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, token) {\n+                if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, attrs, token) {\n                     let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n                     sess.span_diagnostic.struct_span_err(token.span(), &msg)\n                         .help(\"valid fragment specifiers are `ident`, `block`, `stmt`, `expr`, \\\n@@ -631,7 +634,7 @@ fn check_matcher_core(sess: &ParseSess,\n             }\n             TokenTree::Delimited(span, ref d) => {\n                 let my_suffix = TokenSet::singleton(d.close_tt(span));\n-                check_matcher_core(sess, features, first_sets, &d.tts, &my_suffix);\n+                check_matcher_core(sess, features, attrs, first_sets, &d.tts, &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n \n@@ -663,7 +666,12 @@ fn check_matcher_core(sess: &ParseSess,\n                 // At this point, `suffix_first` is built, and\n                 // `my_suffix` is some TokenSet that we can use\n                 // for checking the interior of `seq_rep`.\n-                let next = check_matcher_core(sess, features, first_sets, &seq_rep.tts, my_suffix);\n+                let next = check_matcher_core(sess,\n+                                              features,\n+                                              attrs,\n+                                              first_sets,\n+                                              &seq_rep.tts,\n+                                              my_suffix);\n                 if next.maybe_empty {\n                     last.add_all(&next);\n                 } else {\n@@ -836,12 +844,13 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n \n fn has_legal_fragment_specifier(sess: &ParseSess,\n                                 features: &RefCell<Features>,\n+                                attrs: &[ast::Attribute],\n                                 tok: &quoted::TokenTree) -> Result<(), String> {\n     debug!(\"has_legal_fragment_specifier({:?})\", tok);\n     if let quoted::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n         let frag_name = frag_spec.name.as_str();\n         let frag_span = tok.span();\n-        if !is_legal_fragment_specifier(sess, features, &frag_name, frag_span) {\n+        if !is_legal_fragment_specifier(sess, features, attrs, &frag_name, frag_span) {\n             return Err(frag_name.to_string());\n         }\n     }\n@@ -850,13 +859,15 @@ fn has_legal_fragment_specifier(sess: &ParseSess,\n \n fn is_legal_fragment_specifier(sess: &ParseSess,\n                                features: &RefCell<Features>,\n+                               attrs: &[ast::Attribute],\n                                frag_name: &str,\n                                frag_span: Span) -> bool {\n     match frag_name {\n         \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" |\n         \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"\" => true,\n         \"vis\" => {\n-            if !features.borrow().macro_vis_matcher {\n+            if     !features.borrow().macro_vis_matcher\n+                && !attr::contains_name(attrs, \"allow_internal_unstable\") {\n                 let explain = feature_gate::EXPLAIN_VIS_MATCHER;\n                 emit_feature_err(sess,\n                                  \"macro_vis_matcher\","}]}