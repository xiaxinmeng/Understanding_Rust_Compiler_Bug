{"sha": "a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YTVjMzJlMGViY2Q0NDRmNWFiMjc0ZWRiNTUzMWQzNzQ5OTM2YTM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T12:13:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-25T12:13:23Z"}, "message": "Rollup merge of #39953 - keeperofdakeys:macro-error, r=jseyfried\n\nProvide suggestions for unknown macros imported with `use`\n\ncc https://github.com/rust-lang/rust/issues/30197\n\nr? @jseyfried", "tree": {"sha": "21b4c3047b13df8dff1500bbd81e026925742054", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21b4c3047b13df8dff1500bbd81e026925742054"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "html_url": "https://github.com/rust-lang/rust/commit/a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be66a607da258614e2593486df75ee561206b0fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/be66a607da258614e2593486df75ee561206b0fc", "html_url": "https://github.com/rust-lang/rust/commit/be66a607da258614e2593486df75ee561206b0fc"}, {"sha": "da6dc5331f258f550691c9c66f2f54960b54a164", "url": "https://api.github.com/repos/rust-lang/rust/commits/da6dc5331f258f550691c9c66f2f54960b54a164", "html_url": "https://github.com/rust-lang/rust/commit/da6dc5331f258f550691c9c66f2f54960b54a164"}], "stats": {"total": 135, "additions": 92, "deletions": 43}, "files": [{"sha": "aedb8fef2885cf461cca140334147a030940e891", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "patch": "@@ -11,6 +11,7 @@\n use hir::def_id::DefId;\n use util::nodemap::NodeMap;\n use syntax::ast;\n+use syntax::ext::base::MacroKind;\n use hir;\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -53,7 +54,7 @@ pub enum Def {\n     Label(ast::NodeId),\n \n     // Macro namespace\n-    Macro(DefId),\n+    Macro(DefId, MacroKind),\n \n     // Both namespaces\n     Err,\n@@ -141,7 +142,7 @@ impl Def {\n             Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) | Def::TyAlias(id) |\n             Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n-            Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) | Def::Macro(id) => {\n+            Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) | Def::Macro(id, ..) => {\n                 id\n             }\n "}, {"sha": "53883e50a5be283e5b0c1e92fef21f6531e72c6b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "patch": "@@ -39,6 +39,7 @@ use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast;\n use syntax::codemap;\n+use syntax::ext::base::MacroKind;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n@@ -434,7 +435,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Variant(_) => Def::Variant(did),\n             EntryKind::Trait(_) => Def::Trait(did),\n             EntryKind::Enum(..) => Def::Enum(did),\n-            EntryKind::MacroDef(_) => Def::Macro(did),\n+            EntryKind::MacroDef(_) => Def::Macro(did, MacroKind::Bang),\n \n             EntryKind::ForeignMod |\n             EntryKind::Impl(_) |\n@@ -483,9 +484,11 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_def(&self, index: DefIndex) -> Option<Def> {\n-        match self.is_proc_macro(index) {\n-            true => Some(Def::Macro(self.local_def_id(index))),\n-            false => self.entry(index).kind.to_def(self.local_def_id(index)),\n+        if !self.is_proc_macro(index) {\n+            self.entry(index).kind.to_def(self.local_def_id(index))\n+        } else {\n+            let kind = self.proc_macros.as_ref().unwrap()[index.as_usize() - 1].1.kind();\n+            Some(Def::Macro(self.local_def_id(index), kind))\n         }\n     }\n \n@@ -688,8 +691,14 @@ impl<'a, 'tcx> CrateMetadata {\n     {\n         if let Some(ref proc_macros) = self.proc_macros {\n             if id == CRATE_DEF_INDEX {\n-                for (id, &(name, _)) in proc_macros.iter().enumerate() {\n-                    let def = Def::Macro(DefId { krate: self.cnum, index: DefIndex::new(id + 1) });\n+                for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n+                    let def = Def::Macro(\n+                        DefId {\n+                            krate: self.cnum,\n+                            index: DefIndex::new(id + 1)\n+                        },\n+                        ext.kind()\n+                    );\n                     callback(def::Export { name: name, def: def });\n                 }\n             }"}, {"sha": "ec02e9235beaf93b2b26fc14b3de68a0d316bc84", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "patch": "@@ -495,7 +495,7 @@ impl<'a> Resolver<'a> {\n \n     pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> {\n         let def_id = match def {\n-            Def::Macro(def_id) => def_id,\n+            Def::Macro(def_id, ..) => def_id,\n             _ => panic!(\"Expected Def::Macro(..)\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n@@ -537,7 +537,6 @@ impl<'a> Resolver<'a> {\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n-        self.macro_names.insert(name);\n         if self.builtin_macros.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note ="}, {"sha": "eefe83d7da6f59b20d2ed0f26ba1e4e2cbce073a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "patch": "@@ -1265,7 +1265,7 @@ impl<'a> Resolver<'a> {\n             ribs: PerNS {\n                 value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n                 type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                macro_ns: None,\n+                macro_ns: Some(vec![Rib::new(ModuleRibKind(graph_root))]),\n             },\n             label_ribs: Vec::new(),\n \n@@ -2328,10 +2328,13 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n         }\n-        if primary_ns != MacroNS && path.len() == 1 &&\n-                self.macro_names.contains(&path[0].name) {\n+        let is_builtin = self.builtin_macros.get(&path[0].name).cloned()\n+            .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n+        if primary_ns != MacroNS && (is_builtin || self.macro_names.contains(&path[0].name)) {\n             // Return some dummy definition, it's enough for error reporting.\n-            return Some(PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX))));\n+            return Some(\n+                PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n+            );\n         }\n         fin_res\n     }"}, {"sha": "b7068f4b09f5fcca3359b955d6e1d279736755c7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "patch": "@@ -23,7 +23,7 @@ use syntax::ast::{self, Name, Ident};\n use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n-use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n+use syntax::ext::base::{Resolver as SyntaxResolver, SyntaxExtension};\n use syntax::ext::base::MacroKind;\n use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n@@ -152,16 +152,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n-        if let NormalTT(..) = *ext {\n-            self.macro_names.insert(ident.name);\n-        }\n         let def_id = DefId {\n             krate: BUILTIN_MACROS_CRATE,\n             index: DefIndex::new(self.macro_map.len()),\n         };\n+        let kind = ext.kind();\n         self.macro_map.insert(def_id, ext);\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Def(Def::Macro(def_id)),\n+            kind: NameBindingKind::Def(Def::Macro(def_id, kind)),\n             span: DUMMY_SP,\n             vis: ty::Visibility::Invisible,\n             expansion: Mark::root(),\n@@ -470,24 +468,40 @@ impl<'a> Resolver<'a> {\n \n     fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n                           err: &mut DiagnosticBuilder<'a>) {\n-        let suggestion = match kind {\n-            MacroKind::Bang =>\n-                find_best_match_for_name(self.macro_names.iter(), name, None),\n-            MacroKind::Attr |\n-            MacroKind::Derive => {\n-                // Find a suggestion from the legacy namespace.\n-                // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n-                let builtin_macros = self.builtin_macros.clone();\n-                let names = builtin_macros.iter().filter_map(|(name, binding)| {\n-                    if binding.get_macro(self).kind() == kind {\n-                        Some(name)\n-                    } else {\n-                        None\n-                    }\n-                });\n-                find_best_match_for_name(names, name, None)\n+        // First check if this is a locally-defined bang macro.\n+        let suggestion = if let MacroKind::Bang = kind {\n+            find_best_match_for_name(self.macro_names.iter(), name, None)\n+        } else {\n+            None\n+        // Then check builtin macros.\n+        }.or_else(|| {\n+            // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n+            let builtin_macros = self.builtin_macros.clone();\n+            let names = builtin_macros.iter().filter_map(|(name, binding)| {\n+                if binding.get_macro(self).kind() == kind {\n+                    Some(name)\n+                } else {\n+                    None\n+                }\n+            });\n+            find_best_match_for_name(names, name, None)\n+        // Then check modules.\n+        }).or_else(|| {\n+            if !self.use_extern_macros {\n+                return None;\n             }\n-        };\n+            let is_macro = |def| {\n+                if let Def::Macro(_, def_kind) = def {\n+                    def_kind == kind\n+                } else {\n+                    false\n+                }\n+            };\n+            let ident = Ident::from_str(name);\n+            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro)\n+                .as_ref().map(|s| Symbol::intern(s))\n+        });\n+\n         if let Some(suggestion) = suggestion {\n             if suggestion != name {\n                 if let MacroKind::Bang = kind {\n@@ -566,7 +580,7 @@ impl<'a> Resolver<'a> {\n             });\n             self.macro_exports.push(Export {\n                 name: def.ident.name,\n-                def: Def::Macro(self.definitions.local_def_id(def.id)),\n+                def: Def::Macro(self.definitions.local_def_id(def.id), MacroKind::Bang),\n             });\n             self.exported_macros.push(def);\n         }"}, {"sha": "6667a3199a8096ef5f4dd603d91465b8fa3d9c3d", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "patch": "@@ -336,7 +336,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Def::AssociatedTy(..) |\n             Def::AssociatedConst(..) |\n             Def::PrimTy(_) |\n-            Def::Macro(_) |\n+            Def::Macro(..) |\n             Def::Err => {\n                span_bug!(span,\n                          \"process_def_kind for unexpected item: {:?}\","}, {"sha": "64f37925a98e283c797fdc32de2dee5a03f15cf6", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "patch": "@@ -199,7 +199,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         self.inside_public_path = orig_inside_public_path;\n         if let Some(exports) = self.cx.export_map.get(&id) {\n             for export in exports {\n-                if let Def::Macro(def_id) = export.def {\n+                if let Def::Macro(def_id, ..) = export.def {\n                     if def_id.krate == LOCAL_CRATE {\n                         continue // These are `krate.exported_macros`, handled in `self.visit()`.\n                     }"}, {"sha": "666e2205b4a2680722ef2d340cb0f2b54dd98253", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "patch": "@@ -475,7 +475,7 @@ pub type BuiltinDeriveFn =\n     for<'cx> fn(&'cx mut ExtCtxt, Span, &MetaItem, &Annotatable, &mut FnMut(Annotatable));\n \n /// Represents different kinds of macro invocations that can be resolved.\n-#[derive(Clone, Copy, PartialEq, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MacroKind {\n     /// A bang macro - foo!()\n     Bang,"}, {"sha": "eac0be6f84874ca8fdf9e81259ed1dc16df56848", "filename": "src/test/compile-fail-fulldeps/proc-macro/resolve-error.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a5c32e0ebcd444f5ab274edb5531d3749936a3/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs?ref=a6a5c32e0ebcd444f5ab274edb5531d3749936a3", "patch": "@@ -22,15 +22,24 @@ extern crate attr_proc_macro;\n \n use attr_proc_macro::attr_proc_macro;\n \n-#[derive(FooWithLongNam)]\n-//~^ ERROR cannot find derive macro `FooWithLongNam` in this scope\n+macro_rules! FooWithLongNam {\n+    () => {}\n+}\n+\n+#[derive(FooWithLongNan)]\n+//~^ ERROR cannot find derive macro `FooWithLongNan` in this scope\n //~^^ HELP did you mean `FooWithLongName`?\n struct Foo;\n \n #[attr_proc_macra]\n //~^ ERROR cannot find attribute macro `attr_proc_macra` in this scope\n+//~^^ HELP did you mean `attr_proc_macro`?\n struct Bar;\n \n+#[FooWithLongNan]\n+//~^ ERROR cannot find attribute macro `FooWithLongNan` in this scope\n+struct Asdf;\n+\n #[derive(Dlone)]\n //~^ ERROR cannot find derive macro `Dlone` in this scope\n //~^^ HELP did you mean `Clone`?\n@@ -41,4 +50,18 @@ struct A;\n //~^^ HELP did you mean `Clona`?\n struct B;\n \n-fn main() {}\n+#[derive(attr_proc_macra)]\n+//~^ ERROR cannot find derive macro `attr_proc_macra` in this scope\n+struct C;\n+\n+fn main() {\n+    FooWithLongNama!();\n+    //~^ ERROR cannot find macro `FooWithLongNama!` in this scope\n+    //~^^ HELP did you mean `FooWithLongNam!`?\n+\n+    attr_proc_macra!();\n+    //~^ ERROR cannot find macro `attr_proc_macra!` in this scope\n+\n+    Dlona!();\n+    //~^ ERROR cannot find macro `Dlona!` in this scope\n+}"}]}