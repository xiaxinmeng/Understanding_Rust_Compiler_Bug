{"sha": "dbc9da7962b7282c5752a7bc2c9907694b7c158c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYzlkYTc5NjJiNzI4MmM1NzUyYTdiYzJjOTkwNzY5NGI3YzE1OGM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-06-17T10:10:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-06-17T10:10:38Z"}, "message": "WIP: Find the imports that were used to reach a method\n\nAnd add tests for some corner cases we have to consider.", "tree": {"sha": "38d91788173cec42c9d5ca4f13534bd2eeedcae2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38d91788173cec42c9d5ca4f13534bd2eeedcae2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc9da7962b7282c5752a7bc2c9907694b7c158c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc9da7962b7282c5752a7bc2c9907694b7c158c", "html_url": "https://github.com/rust-lang/rust/commit/dbc9da7962b7282c5752a7bc2c9907694b7c158c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc9da7962b7282c5752a7bc2c9907694b7c158c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56108f67b13416636508fbfd15442a9e18a70e28", "url": "https://api.github.com/repos/rust-lang/rust/commits/56108f67b13416636508fbfd15442a9e18a70e28", "html_url": "https://github.com/rust-lang/rust/commit/56108f67b13416636508fbfd15442a9e18a70e28"}], "stats": {"total": 124, "additions": 118, "deletions": 6}, "files": [{"sha": "987ec032476d3eb1bd033c4334cb73bc938bdd4f", "filename": "compiler/rustc_typeck/src/check/method/prelude2021.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dbc9da7962b7282c5752a7bc2c9907694b7c158c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc9da7962b7282c5752a7bc2c9907694b7c158c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs?ref=dbc9da7962b7282c5752a7bc2c9907694b7c158c", "patch": "@@ -1,3 +1,5 @@\n+use hir::def_id::DefId;\n+use hir::HirId;\n use rustc_ast::Mutability;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -48,7 +50,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             call_expr.span,\n             |lint| {\n                 let sp = call_expr.span;\n-                let trait_name = self.tcx.def_path_str(pick.item.container.id());\n+                let trait_name =\n+                    self.trait_path_or_bare_name(call_expr.hir_id, pick.item.container.id());\n \n                 let mut lint = lint.build(&format!(\n                     \"trait method `{}` will become ambiguous in Rust 2021\",\n@@ -144,16 +147,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx.struct_span_lint_hir(FUTURE_PRELUDE_COLLISION, expr_id, span, |lint| {\n             // \"type\" refers to either a type or, more likely, a trait from which\n             // the associated function or method is from.\n-            let type_name = self.tcx.def_path_str(pick.item.container.id());\n-            let type_generics = self.tcx.generics_of(pick.item.container.id());\n+            let trait_path = self.trait_path_or_bare_name(expr_id, pick.item.container.id());\n+            let trait_generics = self.tcx.generics_of(pick.item.container.id());\n \n-            let parameter_count = type_generics.count() - (type_generics.has_self as usize);\n+            let parameter_count = trait_generics.count() - (trait_generics.has_self as usize);\n             let trait_name = if parameter_count == 0 {\n-                type_name\n+                trait_path\n             } else {\n                 format!(\n                     \"{}<{}>\",\n-                    type_name,\n+                    trait_path,\n                     std::iter::repeat(\"_\").take(parameter_count).collect::<Vec<_>>().join(\", \")\n                 )\n             };\n@@ -179,4 +182,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             lint.emit();\n         });\n     }\n+\n+    fn trait_path_or_bare_name(&self, expr_hir_id: HirId, trait_def_id: DefId) -> String {\n+        self.trait_path(expr_hir_id, trait_def_id).unwrap_or_else(|| {\n+            let key = self.tcx.def_key(trait_def_id);\n+            format!(\"{}\", key.disambiguated_data.data)\n+        })\n+    }\n+\n+    fn trait_path(&self, expr_hir_id: HirId, trait_def_id: DefId) -> Option<String> {\n+        let applicable_traits = self.tcx.in_scope_traits(expr_hir_id)?;\n+        let applicable_trait = applicable_traits.iter().find(|t| t.def_id == trait_def_id)?;\n+        if applicable_trait.import_ids.is_empty() {\n+            // The trait was declared within the module, we only need to use its name.\n+            return None;\n+        }\n+\n+        for &import_id in &applicable_trait.import_ids {\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(import_id);\n+            let item = self.tcx.hir().expect_item(hir_id);\n+            debug!(?item, ?import_id, \"import_id\");\n+        }\n+\n+        return None;\n+    }\n }"}, {"sha": "e85a0bd725d4243211bed12a539e714c3bd3bac8", "filename": "src/test/ui/rust-2021/future-prelude-collision-imported.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dbc9da7962b7282c5752a7bc2c9907694b7c158c/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc9da7962b7282c5752a7bc2c9907694b7c158c/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.rs?ref=dbc9da7962b7282c5752a7bc2c9907694b7c158c", "patch": "@@ -0,0 +1,52 @@\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![warn(future_prelude_collision)]\n+#![allow(dead_code)]\n+\n+mod m {\n+    pub trait TryIntoU32 {\n+        fn try_into(self) -> Result<u32, ()>;\n+    }\n+\n+    impl TryIntoU32 for u8 {\n+        fn try_into(self) -> Result<u32, ()> {\n+            Ok(self as u32)\n+        }\n+    }\n+\n+    pub trait AnotherTrick {}\n+}\n+\n+mod a {\n+    use crate::m::TryIntoU32;\n+\n+    fn main() {\n+        // In this case, we can just use `TryIntoU32`\n+        let _: u32 = 3u8.try_into().unwrap();\n+    }\n+}\n+\n+mod b {\n+    use crate::m::AnotherTrick as TryIntoU32;\n+    use crate::m::TryIntoU32 as _;\n+\n+    fn main() {\n+        // In this case, a `TryIntoU32::try_into` rewrite will not work, and we need to use\n+        // the path `crate::m::TryIntoU32` (with which it was imported).\n+        let _: u32 = 3u8.try_into().unwrap();\n+    }\n+}\n+\n+mod c {\n+    use super::m::TryIntoU32 as _;\n+    use crate::m::AnotherTrick as TryIntoU32;\n+\n+    fn main() {\n+        // In this case, a `TryIntoU32::try_into` rewrite will not work, and we need to use\n+        // the path `super::m::TryIntoU32` (with which it was imported).\n+        let _: u32 = 3u8.try_into().unwrap();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ef19cf4d1e6ade6487a6222efc143c3987451549", "filename": "src/test/ui/rust-2021/future-prelude-collision-shadow.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dbc9da7962b7282c5752a7bc2c9907694b7c158c/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc9da7962b7282c5752a7bc2c9907694b7c158c/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.rs?ref=dbc9da7962b7282c5752a7bc2c9907694b7c158c", "patch": "@@ -0,0 +1,33 @@\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![warn(future_prelude_collision)]\n+#![allow(dead_code)]\n+\n+mod m {\n+    pub trait TryIntoU32 {\n+        fn try_into(self) -> Result<u32, ()>;\n+    }\n+\n+    impl TryIntoU32 for u8 {\n+        fn try_into(self) -> Result<u32, ()> {\n+            Ok(self as u32)\n+        }\n+    }\n+\n+    pub trait AnotherTrick {}\n+}\n+\n+mod d {\n+    use crate::m::AnotherTrick as TryIntoU32;\n+    use crate::m::*;\n+\n+    fn main() {\n+        // Here, `TryIntoU32` is imported but shadowed, but in that case we don't permit its methods\n+        // to be available.\n+        let _: u32 = 3u8.try_into().unwrap();\n+        //~^ ERROR no method name `try_into` found\n+    }\n+}\n+\n+fn main() {}"}]}