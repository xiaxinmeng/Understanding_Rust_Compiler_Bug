{"sha": "7e1d866481aa6f11dbe96c4d47b6b61b276f07b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMWQ4NjY0ODFhYTZmMTFkYmU5NmM0ZDQ3YjZiNjFiMjc2ZjA3YjM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-19T12:51:46Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-21T08:27:01Z"}, "message": "add guide", "tree": {"sha": "53355cf1d99d2af3555dab3030c5efc88002a052", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53355cf1d99d2af3555dab3030c5efc88002a052"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e1d866481aa6f11dbe96c4d47b6b61b276f07b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e1d866481aa6f11dbe96c4d47b6b61b276f07b3", "html_url": "https://github.com/rust-lang/rust/commit/7e1d866481aa6f11dbe96c4d47b6b61b276f07b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e1d866481aa6f11dbe96c4d47b6b61b276f07b3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "237bb929f4332021d97b064dd8178518b30e1f32", "url": "https://api.github.com/repos/rust-lang/rust/commits/237bb929f4332021d97b064dd8178518b30e1f32", "html_url": "https://github.com/rust-lang/rust/commit/237bb929f4332021d97b064dd8178518b30e1f32"}], "stats": {"total": 364, "additions": 364, "deletions": 0}, "files": [{"sha": "beb8294ba30572bfc5776f1da598c2045ea75930", "filename": "guide.md", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/7e1d866481aa6f11dbe96c4d47b6b61b276f07b3/guide.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e1d866481aa6f11dbe96c4d47b6b61b276f07b3/guide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/guide.md?ref=7e1d866481aa6f11dbe96c4d47b6b61b276f07b3", "patch": "@@ -0,0 +1,364 @@\n+# Guide to rust-analyzer\n+\n+## About the guide\n+\n+This guide describes the current start of the rust-analyzer as of 2019-01-20\n+(commit hash guide-2019-01). Its purpose is to\n+document various problems and architectural solutions related to the problem of\n+building IDE-first compiler.\n+\n+## The big picture\n+\n+On the highest possible level, rust analyzer is a stateful component. Client may\n+apply changes to the analyzer (new contents of `foo.rs` file is \"fn main() {}\")\n+and it may ask semantic questions about the current state (what is the\n+definition of the identifier with offset 92 in file `bar.rs`?). Two important\n+properties hold:\n+\n+* Analyzer does not do any IO. It starts in an empty state and all input data is\n+  provided via `apply_change` API.\n+\n+* Only queries about the current state are supported. One can, of course,\n+  simulate undo and redo by keeping log of changes and inverse-changes.\n+\n+## IDE API\n+\n+To see this big picture, let's take a look at the [`AnalysisHost`] and\n+[`Analysis`] pair of types. `AnalysisHost` has three methods:\n+\n+* `default` for creating an empty analysis\n+* `apply_change(&mut self)` to make changes (this is how you get from an empty\n+  state to something interesting)\n+* `analysis(&self)` to get an instance of `Analysis`\n+\n+`Analysis` has a ton of methods for IDEs, like `goto_definition`, or\n+`completions`. Both inputs and outputs of `Analysis`' methods are formulated in\n+terms of files and offsets, and **not** in terms of Rust concepts like structs,\n+traits, etc. The \"typed\" API with Rust specific types is slightly lower in the\n+stack, we'll talk about it later.\n+\n+[`AnalysisHost`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L265-L284\n+[`Analysis`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L291-L478\n+\n+The reason for `Analysis` and `AnalysisHost` separation is that we want apply\n+changes \"uniquely\", but we might want to fork an `Analysis` and send it to\n+another thread for background processing. That is, there is only a single\n+`AnalysisHost`, but there may be several (equivalent) `Analysis`.\n+\n+Note that all of the `Analysis` API return `Cancelable<T>`. This is required to\n+be responsive in IDE setting. Sometimes a long-running query is being computed\n+and the user types something in the editor and asks for completion. In this\n+case, we cancel the long-running computation (so it returns `Err(Canceled)`),\n+apply the change and execute request for completion. We never use stale data to\n+answer requests. Under the cover, `AnalysisHost` \"remembers\" all outstanding\n+`Analysis` instances. `AnalysisHost::apply_change` method cancels all\n+`Analysis`es, blocks until of them are `Dropped` and then applies change\n+in-place. This is the familiar to rustaceans read-write lock interior\n+mutability.\n+\n+Next, lets talk about what are inputs to the Analysis, precisely.\n+\n+## Inputs\n+\n+Rust Analyzer never does any IO itself, all inputs get passed explicitly via\n+`AnalysisHost::apply_change` method, which accepts a single argument:\n+`AnalysisChange`. [`AnalysisChange`] is a builder for a single change\n+\"transaction\", so it suffices to study its methods to understand all of the\n+input data.\n+\n+[`AnalysisChange`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L119-L167\n+\n+The `(add|change|remove)_file` methods control the set of the input files, where\n+each file has an integer id (`FileId`, picked by the client), text (`String`)\n+and a filesystem path. Paths are tricky, they'll be explained in source roots\n+section, together with `add_root` method. `add_library` method allows to add a\n+group of files which are assumed to rarely change. It's mostly an optimization\n+and does not change fundamental picture.\n+\n+`set_crate_graph` method allows to control how the input files are partitioned\n+into compilation unites -- crates. It also controls (in theory, not implemented\n+yet) `cfg` flags. `CrateGraph` is a directed acyclic graph of crates. Each crate\n+has a root `FileId`, a set of active `cfg` flags and a set of dependencies. Each\n+dependency is a pair of a crate and a name. It is possible to have two crates\n+with the same root `FileId` but different `cfg`-flags/dependencies. This model\n+is lower than Cargo's model of packages: each Cargo package consists of several\n+targets, each of which is a separate crate (or several crates, if you try\n+different feature combinations).\n+\n+Procedural macros should become inputs as well, but currently they are not\n+supported. Procedural macro will be a black box `Box<dyn Fn(TokenStream) -> TokenStream>`\n+function, and will be inserted into the crate graph just like dependencies.\n+\n+Soon we'll talk how we build an LSP server on top of `Analysis`, but first,\n+let's deal with that paths issue.\n+\n+\n+## Source roots (aka filesystems are horrible)\n+\n+This is a non-essential section, feel free to skip.\n+\n+The previous section said that the file system path is an attribute of a file,\n+but this is not a whole truth. Making it an absolute `PathBuf` will be bad for\n+several reasons. First, file-systems are full of (platform-dependent) edge cases:\n+\n+* it's hard (requires a syscall) to decide if two paths are equivalent\n+* some file-systems are case-sensitive\n+* paths are not necessary UTF-8\n+* symlinks can form cycles\n+\n+Second, this might hurt reproducibility and hermeticity of builds. In theory,\n+moving a project from `/foo/bar/my-project` to `/spam/eggs/my-project` should\n+not change a bit in the output. However, if absolute path is a part of the\n+input, it is at least in theory observable, and *could* affect the output.\n+\n+Yet another problem is that we really-really want to avoid doing IO, but with\n+Rust the set of \"input\" files is not necessary known up-front. In theory, you\n+can have `#[path=\"/dev/random\"] mod foo;`.\n+\n+To solve (or explicitly refuse to solve) these problems rust analyzer uses the\n+concept of source root. Roughly speaking, source roots is a contents of a\n+directory on a file systems, like `/home/matklad/projects/rustraytracer/**.rs`.\n+\n+More precisely, all files (`FileId`s) are partitioned into disjoint\n+`SourceRoot`s. Each file has a relative utf-8 path within the `SourceRoot`.\n+`SourceRoot` has an identity (integer id). Crucially, the root path of the\n+source root itself is unknown to the analyzer: client is supposed to maintain a\n+mapping between SourceRoot ids (which are assigned by the client) and actual\n+`PathBuf`s. `SourceRoot`s give a sane tree model of the file system to the\n+analyzer.\n+\n+Note that `mod`, `#[path]` and `include!()` can only reference files from the\n+same source root. It is of course is possible to explicitly add extra files to\n+the source root, even `/dev/random`.\n+\n+## Language Server Protocol\n+\n+Now let's see how `Analysis` API is exposed via JSON RPC based LSP protocol. The\n+hard part here is managing changes (which can come either from the file system\n+or from the editor) and concurrency (we want to spawn background jobs for things\n+like syntax highlighting). We use the event loop pattern to manage the zoo, and\n+the loop is the [`main_loop_inner`] function. The [`main_loop`] does a one-time\n+initialization and tearing down of the resources.\n+\n+[`main_loop`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L51-L110\n+[`main_loop_inner`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L156-L258\n+\n+\n+Let's walk through a typical analyzer session!\n+\n+First, we need to figure out what to analyze. To do this, we run `cargo\n+metadata` to learn about Cargo packages for current workspace and dependencies,\n+and we run `rustc --print sysroot` and scan sysroot to learn about crates like\n+`std`. Currently we load this configuration once at the start of the server, but\n+it should be possible to dynamically reconfigure it later without restart.\n+\n+[main_loop.rs#L62-L70](https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L62-L70)\n+\n+The [`ProjectModel`] we get after this step is very Cargo and sysroot specific,\n+it needs to be lowered to get the input in the form of `AnalysisChange`. This\n+happens in [`ServerWorldState::new`] method. Specifically\n+\n+* Create a `SourceRoot` for each Cargo package and sysroot.\n+* Schedule a file system scan of the roots.\n+* Create an analyzer's `Crate` for each Cargo **target** and sysroot crate.\n+* Setup dependencies between the crates.\n+\n+[`ProjectModel`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/project_model.rs#L16-L20\n+[`ServerWorldState::new`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/server_world.rs#L38-L160\n+\n+The results of the scan (which may take a while) will be processed in the body\n+of the main loop, just like any other change. Here's where we handle\n+\n+* [File system changes](https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L194)\n+* [Changes from the editor](https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L377)\n+\n+After a single loop's turn, we group them into one `AnalysisChange` and\n+[apply] it. This always happens on the main thread and blocks the loop.\n+\n+[apply]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/server_world.rs#L216\n+\n+To handle requests, like [\"goto definition\"], we create an instance of the\n+`Analysis` and [`schedule`] the task (which consumes `Analysis`) onto\n+threadpool. [The task] calls the corresponding `Analysis` method, while\n+massaging the types into the LSP representation. Keep in mind that if we are\n+executing \"goto definition\" on the threadpool and a new change comes in, the\n+task will be canceled as soon as the main loop calls `apply_change` on the\n+`AnalysisHost`.\n+\n+[\"goto definition\"]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/server_world.rs#L216\n+[`schedule`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L426-L455\n+[The task]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop/handlers.rs#L205-L223\n+\n+This concludes the overview of the analyzer's programing *interface*. Next, lets\n+dig into the implementation!\n+\n+## Salsa\n+\n+The most straightforward way to implement \"apply change, get analysis, repeat\"\n+API would be to maintain the input state and to compute all possible analysis\n+information from scratch after every change. This works, but scales poorly with\n+the size of the project. To make this fast, we need to take advantage of the\n+fact that most of the changes are small, and that analysis results are unlikely\n+to change significantly between invocations.\n+\n+To do this we use [salsa]: a framework for incremental on-demand computation.\n+You can skip the rest of the section if you are familiar with rustc red-green\n+algorithm.\n+\n+[salsa]: https://github.com/salsa-rs/salsa\n+\n+It's better to refer to salsa's docs to learn about it. Here's a small excerpt:\n+\n+The key idea of salsa is that you define your program as a set of queries. Every\n+query is used like function K -> V that maps from some key of type K to a value\n+of type V. Queries come in two basic varieties:\n+\n+* **Inputs**: the base inputs to your system. You can change these whenever you\n+  like.\n+\n+* **Functions**: pure functions (no side effects) that transform your inputs\n+  into other values. The results of queries is memoized to avoid recomputing\n+  them a lot. When you make changes to the inputs, we'll figure out (fairly\n+  intelligently) when we can re-use these memoized values and when we have to\n+  recompute them.\n+\n+\n+For further discussion, its important to understand one bit of \"fairly\n+intelligently\". Suppose we have to functions, `f1` and `f2`, and one input, `i`.\n+We call `f1(X)` which in turn calls `f2(Y)` which inspects `i(Z)`. `i(Z)`\n+returns some value `V1`, `f2` uses that and returns `R1`, `f1` uses that and\n+returns `O`. Now, let's change `i` at `Z` to `V2` from `V1` and try to compute\n+`f1(X)` again. Because `f1(X)` (transitively) depends on `i(Z)`, we can't just\n+reuse its value as is. However, if `f2(Y)` is *still* equal to `R1` (despite the\n+`i`'s change), we, in fact, *can* reuse `O` as result of `f1(X)`. And that's how\n+salsa works: it recomputes results in *reverse* order, starting from inputs and\n+progressing towards outputs, stopping as soon as it sees an intermediate value\n+that hasn't changed.\n+\n+## Salsa Input Queries\n+\n+All analyzer information is stored in a salsa database. `Analysis` and\n+`AnalysisHost` types are newtype wrappers for [`RootDatabase`] -- a salsa\n+database.\n+\n+[`RootDatabase`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/db.rs#L88-L134\n+\n+Salsa input queries are defined in [`FilesDatabase`] (which is a part of\n+`RootDatabase`). They closely mirror the familiar `AnalysisChange` structure:\n+indeed, what `apply_change` does is it sets the values of input queries.\n+\n+[`FilesDatabase`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_db/src/input.rs#L150-L174\n+\n+## From text to semantic model\n+\n+The bulk of the rust-analyzer is transforming input text into semantic model of\n+Rust code: a web of entities like modules, structs, functions and traits.\n+\n+An important fact to realize is that (unlike most other languages like C# or\n+Java) there isn't a one-to-one mapping between source code and semantic model. A\n+single function definition in the source code might result in several semantic\n+functions: for example, the same source file might be included as a module into\n+several crate, or a single \"crate\" might be present in the compilation DAG\n+several times, with different sets of `cfg`s enabled.\n+\n+The semantic interface is declared in [`code_model_api`] module. Each entity is\n+identified by integer id and has a bunch of methods which take a salsa database\n+as an argument and returns other entities (which are ids). Internally, this\n+methods invoke various queries on the database to build the model on demand.\n+Here's [the list of queries].\n+\n+[`code_model_api`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/code_model_api.rs\n+[the list of queries]: https://github.com/rust-analyzer/rust-analyzer/blob/7e84440e25e19529e4ff8a66e521d1b06349c6ec/crates/ra_hir/src/db.rs#L20-L106\n+\n+The first step of building the model is parsing the source code.\n+\n+## Syntax trees\n+\n+An important property of the Rust language is that each file can be parsed in\n+isolation. Unlike, say, `C++`, an `include` can't change the meaning of the\n+syntax. For this reason, Rust analyzer can build a syntax tree for each \"source\n+file\", which could then be reused by several semantic models if this file\n+happens to be a part of several crates.\n+\n+Rust analyzer uses a similar representation of syntax trees to that of `Roslyn`\n+and Swift's new\n+[libsyntax](https://github.com/apple/swift/tree/5e2c815edfd758f9b1309ce07bfc01c4bc20ec23/lib/Syntax).\n+Swift's docs give an excellent overview of the approach, so I skip this part\n+here and instead outline the main characteristics of the syntax trees:\n+\n+* Syntax trees are fully lossless. Converting **any** text to a syntax tree and\n+  back is a total identity function. All whitespace and comments are explicitly\n+  represented in the tree.\n+\n+* Syntax nodes have generic `(next|previous)_sibling`, `parent`,\n+  `(first|last)_child` functions. You can get from any one node to any other\n+  node in the file using only these functions.\n+\n+* Syntax nodes know their range (start offset and length) in the file.\n+\n+* Syntax nodes share the ownership of their syntax tree: if you keep a reference\n+  to a single function, the whole enclosing file is alive.\n+\n+* Syntax trees are immutable and the cost of replacing the subtree is\n+  proportional to the depth of the subtree. Read Swift's docs to learn how\n+  immutable + parent pointers + cheap modification is possible.\n+\n+* Syntax trees are build on best-effort basis. All accessor methods return\n+  `Option`s. The tree for `fn foo` will contain a function declaration with\n+  `None` for parameter list and body.\n+\n+* Syntax trees do not know the file they are build from, they only know about\n+  the text.\n+\n+The implementation is based on the generic [rowan] crate on top of which a\n+[rust-specific] AST is generated.\n+\n+[rowan]: https://github.com/rust-analyzer/rowan/tree/100a36dc820eb393b74abe0d20ddf99077b61f88\n+[rust-specific]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_syntax/src/ast/generated.rs\n+\n+The next step in constructing the semantic model is ...\n+\n+## Building a Module Tree\n+\n+The algorithm for building a tree of modules is to start with a crate root\n+(remember, each `Crate` from a `CrateGraph` has a `FileId`), collect all mod\n+declarations and recursively process child modules. This is handled by the\n+[`module_tree_query`](https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/module_tree.rs#L116-L123),\n+with a two slight variations.\n+\n+First, rust analyzer builds a module tree for all crates in a source root\n+simultaneously. The main reason for this is historical (`module_tree` predates\n+`CrateGraph`), but this approach also allows to account for files which are not\n+part of any crate. That is, if you create a file but do not include it as a\n+submodule anywhere, you still get semantic completion, and you get a warning\n+about free-floating module (the actual warning is not implemented yet).\n+\n+The second difference is that `module_tree_query` does not *directly* depend on\n+the \"parse\" query (which is confusingly called `source_file`). Why would calling\n+the parse directly be bad? Suppose the user changes the file slightly, by adding\n+an insignificant whitespace. Adding whitespace changes the parse tree (because\n+it includes whitespace), and that means recomputing the whole module tree.\n+\n+We deal with this problem by introducing an intermediate [`submodules_query`].\n+This query processes the syntax tree an extract a set of declared submodule\n+names. Now, changing the whitespace results in `submodules_query` being\n+re-executed for a *single* module, but because the result of this query stays\n+the same, we don't have to re-execute [`module_tree_query`]. In fact, we only\n+need to re-execute it when we add/remove new files or when we change mod\n+declarations,\n+\n+[`submodules_query`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/module_tree.rs#L41)\n+\n+\n+\n+\n+\n+## Location Interner pattern\n+\n+## Macros and recursive locations\n+\n+## Name resolution\n+\n+## Source Map pattern\n+\n+## Tying it all together: completion"}]}