{"sha": "7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNTU4M2I3Zjg4YzYwOTQ5MmJmNGY3YjNhMDgzMTNiYzUwMWIwYWQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-11T09:01:29Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-11T09:01:29Z"}, "message": "Merge remote-tracking branch 'origin/master' into miri", "tree": {"sha": "e23b45097d08976bd6f288402d6ec2ddbd8a982e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e23b45097d08976bd6f288402d6ec2ddbd8a982e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlouSWwACgkQpp+NIls6\n19lJYQ//TgijnHH9f30OVfINHCVI7gmSmG2CZiLHpsAuhT6w8k3uMCf6kcGdPR2W\nrIjkI28PN6QUVS4nilcETm3NPtS//l/7o9nDKKbRa/i2486o5RXOviVNPYYZc7KR\nXqvIHCVEXlfS/7KTMIvYB3X7BBWF4UrJo+Q3/okMjCP7MifNod32tyrIqmKCZyvp\nA6LPXYw2zWiANQx31+BMtoCCvISAT5tAvAA1G8EY9UeSbNyD0iSBWFqTpejvm6yo\n8myJFmyK10gwDL9DTE/SyT199qD4OfT//bvJj68PhIP4o1fOiElHpQYuP1FbQWuT\n/qiaS2CDiDXl/FnS7e+h1KKi86+iQn+7Z9fM8hr3727TvHAYwnpPpPF/qSpf3HkW\nbi5mTGXyjp0tEjp5egTkl673WMUNa+QW/6BzDsm2eJW1YT2aa4ecYWuV0ZSVNT1I\nG3J8hVVY3S9VPxGmJjKbsAnrw33c5GFkATGyklVAlCNd4gxIYvaYdcwBmkP7X8BE\nJA16NIhTsy/2kZN9Fz7nhXoxnOH1wknNsDD9LrRt3BZpVZsQAyjlqpxlGb3LCnQU\n5avXcip1/3xNrQH3nXuPrs6hYnz9tYmjE0NDT742O8K55BhzNrBBLVoSU652N8rK\nA5LBUPhI83a4hTq4nRzJdbqjQsmuHQkFBCVb4VwN4MqrwGfhvhg=\n=ztrk\n-----END PGP SIGNATURE-----", "payload": "tree e23b45097d08976bd6f288402d6ec2ddbd8a982e\nparent 0f6b5b0423fed8c630f1b97968c3aebbed816f60\nparent 5f3bd73d8143f093c58f367b46434c2d555ef62d\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1512982889 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1512982889 +0100\n\nMerge remote-tracking branch 'origin/master' into miri\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "html_url": "https://github.com/rust-lang/rust/commit/7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f6b5b0423fed8c630f1b97968c3aebbed816f60", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f6b5b0423fed8c630f1b97968c3aebbed816f60", "html_url": "https://github.com/rust-lang/rust/commit/0f6b5b0423fed8c630f1b97968c3aebbed816f60"}, {"sha": "5f3bd73d8143f093c58f367b46434c2d555ef62d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f3bd73d8143f093c58f367b46434c2d555ef62d", "html_url": "https://github.com/rust-lang/rust/commit/5f3bd73d8143f093c58f367b46434c2d555ef62d"}], "stats": {"total": 15102, "additions": 11741, "deletions": 3361}, "files": [{"sha": "2b4f3d472632a356d67f5a01cdf7daa047a5f002", "filename": ".gitattributes", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -7,3 +7,4 @@\n src/etc/installer/gfx/* binary\n *.woff binary\n src/vendor/** -text\n+Cargo.lock -merge"}, {"sha": "b8fea40090fab3b172d8ee669d777b9885bbd2c4", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -336,7 +336,7 @@ will run all the tests on every platform we support. If it all works out,\n \n Speaking of tests, Rust has a comprehensive test suite. More information about\n it can be found\n-[here](https://github.com/rust-lang/rust-wiki-backup/blob/master/Note-testsuite.md).\n+[here](https://github.com/rust-lang/rust/blob/master/src/test/COMPILER_TESTS.md).\n \n ### External Dependencies\n [external-dependencies]: #external-dependencies"}, {"sha": "f404aa046c1aecf52bb34b3e4d14d2eae7c9a8ce", "filename": "src/doc/not_found.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fdoc%2Fnot_found.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fdoc%2Fnot_found.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnot_found.md?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -13,20 +13,20 @@ Some things that might be helpful to you though:\n \n # Search\n \n-* <form action=\"https://duckduckgo.com/\">\n+<form action=\"https://duckduckgo.com/\">\n     <input type=\"text\" id=\"site-search\" name=\"q\" size=\"80\"></input>\n-    <input type=\"submit\" value=\"Search DuckDuckGo\">\n-</form>\n-* Rust doc search: <span id=\"core-search\"></span>\n+    <input type=\"submit\" value=\"Search DuckDuckGo\"></form>\n+\n+Rust doc search: <span id=\"core-search\"></span>\n \n # Reference\n \n-* [The Rust official site](https://www.rust-lang.org)\n-* [The Rust reference](https://doc.rust-lang.org/reference/index.html)\n+ * [The Rust official site](https://www.rust-lang.org)\n+ * [The Rust reference](https://doc.rust-lang.org/reference/index.html)\n \n # Docs\n \n-* [The standard library](https://doc.rust-lang.org/std/)\n+[The standard library](https://doc.rust-lang.org/std/)\n \n <script>\n function get_url_fragments() {"}, {"sha": "c2a8f5f8ff957e5004b9b2cf95ea0cb4d6dfe448", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -217,14 +217,8 @@ impl Layout {\n     /// On arithmetic overflow, returns `None`.\n     #[inline]\n     pub fn repeat(&self, n: usize) -> Option<(Self, usize)> {\n-        let padded_size = match self.size.checked_add(self.padding_needed_for(self.align)) {\n-            None => return None,\n-            Some(padded_size) => padded_size,\n-        };\n-        let alloc_size = match padded_size.checked_mul(n) {\n-            None => return None,\n-            Some(alloc_size) => alloc_size,\n-        };\n+        let padded_size = self.size.checked_add(self.padding_needed_for(self.align))?;\n+        let alloc_size = padded_size.checked_mul(n)?;\n \n         // We can assume that `self.align` is a power-of-two that does\n         // not exceed 2<sup>31</sup>. Furthermore, `alloc_size` has already been\n@@ -246,26 +240,14 @@ impl Layout {\n     /// On arithmetic overflow, returns `None`.\n     pub fn extend(&self, next: Self) -> Option<(Self, usize)> {\n         let new_align = cmp::max(self.align, next.align);\n-        let realigned = match Layout::from_size_align(self.size, new_align) {\n-            None => return None,\n-            Some(l) => l,\n-        };\n+        let realigned = Layout::from_size_align(self.size, new_align)?;\n \n         let pad = realigned.padding_needed_for(next.align);\n \n-        let offset = match self.size.checked_add(pad) {\n-            None => return None,\n-            Some(offset) => offset,\n-        };\n-        let new_size = match offset.checked_add(next.size) {\n-            None => return None,\n-            Some(new_size) => new_size,\n-        };\n+        let offset = self.size.checked_add(pad)?;\n+        let new_size = offset.checked_add(next.size)?;\n \n-        let layout = match Layout::from_size_align(new_size, new_align) {\n-            None => return None,\n-            Some(l) => l,\n-        };\n+        let layout = Layout::from_size_align(new_size, new_align)?;\n         Some((layout, offset))\n     }\n \n@@ -282,11 +264,7 @@ impl Layout {\n     ///\n     /// On arithmetic overflow, returns `None`.\n     pub fn repeat_packed(&self, n: usize) -> Option<Self> {\n-        let size = match self.size().checked_mul(n) {\n-            None => return None,\n-            Some(scaled) => scaled,\n-        };\n-\n+        let size = self.size().checked_mul(n)?;\n         Layout::from_size_align(size, self.align)\n     }\n \n@@ -306,14 +284,8 @@ impl Layout {\n     ///\n     /// On arithmetic overflow, returns `None`.\n     pub fn extend_packed(&self, next: Self) -> Option<(Self, usize)> {\n-        let new_size = match self.size().checked_add(next.size()) {\n-            None => return None,\n-            Some(new_size) => new_size,\n-        };\n-        let layout = match Layout::from_size_align(new_size, self.align) {\n-            None => return None,\n-            Some(l) => l,\n-        };\n+        let new_size = self.size().checked_add(next.size())?;\n+        let layout = Layout::from_size_align(new_size, self.align)?;\n         Some((layout, self.size()))\n     }\n "}, {"sha": "20b9091a07bfc130edaf6a1c56b953c1d1700dc9", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -12,7 +12,7 @@\n use std::iter::Iterator;\n use std::vec::Vec;\n use std::collections::BTreeMap;\n-use std::__rand::{Rng, thread_rng};\n+use rand::{Rng, thread_rng};\n use test::{Bencher, black_box};\n \n macro_rules! map_insert_rand_bench {"}, {"sha": "17538d885f8f4753f327b3a2b3bdcb812bf29338", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::__rand::{thread_rng};\n+use rand::{thread_rng};\n use std::mem;\n use std::ptr;\n "}, {"sha": "580d2dbb623e6f64e581c3d08305f013c08e5321", "filename": "src/liballoc/btree/set.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1067,21 +1067,15 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            let o_cmp = match (self.a.peek(), self.b.peek()) {\n-                (None, _) => None,\n-                (_, None) => None,\n-                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n-            };\n-            match o_cmp {\n-                None => return None,\n-                Some(Less) => {\n+            match Ord::cmp(self.a.peek()?, self.b.peek()?) {\n+                Less => {\n                     self.a.next();\n                 }\n-                Some(Equal) => {\n+                Equal => {\n                     self.b.next();\n                     return self.a.next();\n                 }\n-                Some(Greater) => {\n+                Greater => {\n                     self.b.next();\n                 }\n             }"}, {"sha": "3ac5a85d721a14d8bcdd8bfc6c41ab4dc88d5853", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1071,6 +1071,15 @@ impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n     }\n }\n \n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T, F> Drop for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        for _ in self { }\n+    }\n+}\n+\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n impl<'a, T: 'a + fmt::Debug, F> fmt::Debug for DrainFilter<'a, T, F>\n     where F: FnMut(&mut T) -> bool"}, {"sha": "ca493ab27e3ad67003d5655416eee41da0711aa6", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1044,10 +1044,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<char> {\n-        let ch = match self.chars().rev().next() {\n-            Some(ch) => ch,\n-            None => return None,\n-        };\n+        let ch = self.chars().rev().next()?;\n         let newlen = self.len() - ch.len_utf8();\n         unsafe {\n             self.vec.set_len(newlen);"}, {"sha": "9c7c865771606607d03a2ecc5f6bb5d6e1b17c65", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1423,10 +1423,7 @@ impl<T: PartialEq> Vec<T> {\n     /// ```\n     #[unstable(feature = \"vec_remove_item\", reason = \"recently added\", issue = \"40062\")]\n     pub fn remove_item(&mut self, item: &T) -> Option<T> {\n-        let pos = match self.iter().position(|x| *x == *item) {\n-            Some(x) => x,\n-            None => return None,\n-        };\n+        let pos = self.iter().position(|x| *x == *item)?;\n         Some(self.remove(pos))\n     }\n }"}, {"sha": "93cfc845b1f3497db950ce23741104f717fd3ffa", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1084,9 +1084,11 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     pub fn map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>\n         where F: FnOnce(&mut T) -> &mut U\n     {\n+        // FIXME(nll-rfc#40): fix borrow-check\n+        let RefMut { value, borrow } = orig;\n         RefMut {\n-            value: f(orig.value),\n-            borrow: orig.borrow,\n+            value: f(value),\n+            borrow: borrow,\n         }\n     }\n }"}, {"sha": "06c29b47bf9217db2fe131db59099d0f807e6fc8", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1776,12 +1776,18 @@ impl<I: Iterator> Iterator for Peekable<I> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            // the .take() below is just to avoid \"move into pattern guard\"\n-            Some(ref mut v) if n == 0 => v.take(),\n-            Some(None) => None,\n-            Some(Some(_)) => self.iter.nth(n - 1),\n-            None => self.iter.nth(n),\n+        // FIXME(#6393): merge these when borrow-checking gets better.\n+        if n == 0 {\n+            match self.peeked.take() {\n+                Some(v) => v,\n+                None => self.iter.nth(n),\n+            }\n+        } else {\n+            match self.peeked.take() {\n+                Some(None) => None,\n+                Some(Some(_)) => self.iter.nth(n - 1),\n+                None => self.iter.nth(n),\n+            }\n         }\n     }\n "}, {"sha": "948ad104cdf2f2e409ad6e5a40c87235f689d4be", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -596,9 +596,9 @@ mod builtin {\n \n     /// Unconditionally causes compilation to fail with the given error message when encountered.\n     ///\n-    /// For more information, see the [RFC].\n+    /// For more information, see the documentation for [`std::compile_error!`].\n     ///\n-    /// [RFC]: https://github.com/rust-lang/rfcs/blob/master/text/1695-add-error-macro.md\n+    /// [`std::compile_error!`]: ../std/macro.compile_error.html\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n@@ -736,7 +736,7 @@ mod builtin {\n     #[cfg(dox)]\n     macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n \n-    /// Boolean evaluation of configuration flags.\n+    /// Boolean evaluation of configuration flags, at compile-time.\n     ///\n     /// For more information, see the documentation for [`std::cfg!`].\n     ///"}, {"sha": "d8f3ec38cf38c4a2297d592ab9b1d2c6c78652b5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -338,6 +338,12 @@ impl<T> Option<T> {\n \n     /// Returns the contained value or a default.\n     ///\n+    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n+    /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n+    /// which is lazily evaluated.\n+    ///\n+    /// [`unwrap_or_else`]: #method.unwrap_or_else\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -451,11 +457,16 @@ impl<T> Option<T> {\n     /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n     /// [`Ok(v)`] and [`None`] to [`Err(err)`].\n     ///\n+    /// Arguments passed to `ok_or` are eagerly evaluated; if you are passing the\n+    /// result of a function call, it is recommended to use [`ok_or_else`], which is\n+    /// lazily evaluated.\n+    ///\n     /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n     /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n     /// [`Err(err)`]: ../../std/result/enum.Result.html#variant.Err\n     /// [`None`]: #variant.None\n     /// [`Some(v)`]: #variant.Some\n+    /// [`ok_or_else`]: #method.ok_or_else\n     ///\n     /// # Examples\n     ///\n@@ -644,6 +655,12 @@ impl<T> Option<T> {\n \n     /// Returns the option if it contains a value, otherwise returns `optb`.\n     ///\n+    /// Arguments passed to `or` are eagerly evaluated; if you are passing the\n+    /// result of a function call, it is recommended to use [`or_else`], which is\n+    /// lazily evaluated.\n+    ///\n+    /// [`or_else`]: #method.or_else\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "20f054f5a77f291ea547713764f8d95bcc58406f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -91,15 +91,53 @@ pub const fn null<T>() -> *const T { 0 as *const T }\n pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n /// Swaps the values at two mutable locations of the same type, without\n-/// deinitializing either. They may overlap, unlike `mem::swap` which is\n-/// otherwise equivalent.\n+/// deinitializing either.\n+///\n+/// The values pointed at by `x` and `y` may overlap, unlike `mem::swap` which\n+/// is otherwise equivalent. If the values do overlap, then the overlapping\n+/// region of memory from `x` will be used. This is demonstrated in the\n+/// examples section below.\n ///\n /// # Safety\n ///\n /// This function copies the memory through the raw pointers passed to it\n /// as arguments.\n ///\n /// Ensure that these pointers are valid before calling `swap`.\n+///\n+/// # Examples\n+///\n+/// Swapping two non-overlapping regions:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let mut array = [0, 1, 2, 3];\n+///\n+/// let x = array[0..].as_mut_ptr() as *mut [u32; 2];\n+/// let y = array[2..].as_mut_ptr() as *mut [u32; 2];\n+///\n+/// unsafe {\n+///     ptr::swap(x, y);\n+///     assert_eq!([2, 3, 0, 1], array);\n+/// }\n+/// ```\n+///\n+/// Swapping two overlapping regions:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let mut array = [0, 1, 2, 3];\n+///\n+/// let x = array[0..].as_mut_ptr() as *mut [u32; 3];\n+/// let y = array[1..].as_mut_ptr() as *mut [u32; 3];\n+///\n+/// unsafe {\n+///     ptr::swap(x, y);\n+///     assert_eq!([1, 0, 1, 2], array);\n+/// }\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {"}, {"sha": "2ace3d2aee8739fc4671637a7c467f0b0dea34b0", "filename": "src/libcore/result.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -153,12 +153,12 @@\n //! }\n //! ```\n //!\n-//! # The `?` syntax\n+//! # The question mark operator, `?`\n //!\n //! When writing code that calls many functions that return the\n-//! [`Result`] type, the error handling can be tedious. The [`?`]\n-//! syntax hides some of the boilerplate of propagating errors up the\n-//! call stack.\n+//! [`Result`] type, the error handling can be tedious. The question mark\n+//! operator, [`?`], hides some of the boilerplate of propagating errors\n+//! up the call stack.\n //!\n //! It replaces this:\n //!\n@@ -625,8 +625,13 @@ impl<T, E> Result<T, E> {\n \n     /// Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n     ///\n+    /// Arguments passed to `or` are eagerly evaluated; if you are passing the\n+    /// result of a function call, it is recommended to use [`or_else`], which is\n+    /// lazily evaluated.\n+    ///\n     /// [`Ok`]: enum.Result.html#variant.Ok\n     /// [`Err`]: enum.Result.html#variant.Err\n+    /// [`or_else`]: #method.or_else\n     ///\n     /// # Examples\n     ///\n@@ -690,8 +695,13 @@ impl<T, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an [`Ok`].\n     /// Else, it returns `optb`.\n     ///\n+    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n+    /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n+    /// which is lazily evaluated.\n+    ///\n     /// [`Ok`]: enum.Result.html#variant.Ok\n     /// [`Err`]: enum.Result.html#variant.Err\n+    /// [`unwrap_or_else`]: #method.unwrap_or_else\n     ///\n     /// # Examples\n     ///"}, {"sha": "1ca995cae6d971675494ff005e1040df7ed24588", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -494,11 +494,10 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n #[inline]\n pub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n     // Decode UTF-8\n-    let x = match bytes.next() {\n-        None => return None,\n-        Some(&next_byte) if next_byte < 128 => return Some(next_byte as u32),\n-        Some(&next_byte) => next_byte,\n-    };\n+    let x = *bytes.next()?;\n+    if x < 128 {\n+        return Some(x as u32)\n+    }\n \n     // Multibyte case follows\n     // Decode from a byte combination out of: [[[x y] z] w]"}, {"sha": "85ae529ae329a62cb152aa068563f1c4a9837d3a", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1641,14 +1641,14 @@ impl Foo {\n These attributes do not work on typedefs, since typedefs are just aliases.\n \n Representations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the\n-discriminant size for C-like enums (when there is no associated data, e.g.\n-`enum Color {Red, Blue, Green}`), effectively setting the size of the enum to\n+discriminant size for enums with no data fields on any of the variants, e.g.\n+`enum Color {Red, Blue, Green}`, effectively setting the size of the enum to\n the size of the provided type. Such an enum can be cast to a value of the same\n type as well. In short, `#[repr(u8)]` makes the enum behave like an integer\n with a constrained set of allowed values.\n \n-Only C-like enums can be cast to numerical primitives, so this attribute will\n-not apply to structs.\n+Only field-less enums can be cast to numerical primitives, so this attribute\n+will not apply to structs.\n \n `#[repr(packed)]` reduces padding to make the struct size smaller. The\n representation of enums isn't strictly defined in Rust, and this attribute"}, {"sha": "8969528dd1949d4e903f5ad7a656e9e305b0cfb3", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -978,9 +978,8 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n         // chain, then returns `None`.\n         fn find_first_mod_parent<'a>(map: &'a Map, mut id: NodeId) -> Option<(NodeId, Name)> {\n             loop {\n-                match map.find(id) {\n-                    None => return None,\n-                    Some(NodeItem(item)) if item_is_mod(&item) =>\n+                match map.find(id)? {\n+                    NodeItem(item) if item_is_mod(&item) =>\n                         return Some((id, item.name)),\n                     _ => {}\n                 }"}, {"sha": "0ef42177c14a80038ea9fd764519cce4d792fee6", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 3, "deletions": 62, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -14,7 +14,6 @@ use hir::map::DefPathHash;\n use hir::map::definitions::Definitions;\n use ich::{self, CachingCodemapView};\n use middle::cstore::CrateStore;\n-use session::config::DebugInfoLevel::NoDebugInfo;\n use ty::{TyCtxt, fast_reject};\n use session::Session;\n \n@@ -24,7 +23,7 @@ use std::cell::RefCell;\n use std::collections::HashMap;\n \n use syntax::ast;\n-use syntax::attr;\n+\n use syntax::codemap::CodeMap;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n@@ -51,7 +50,6 @@ pub struct StableHashingContext<'gcx> {\n     body_resolver: BodyResolver<'gcx>,\n     hash_spans: bool,\n     hash_bodies: bool,\n-    overflow_checks_enabled: bool,\n     node_id_hashing_mode: NodeIdHashingMode,\n \n     // Very often, we are hashing something that does not need the\n@@ -89,8 +87,7 @@ impl<'gcx> StableHashingContext<'gcx> {\n                definitions: &'gcx Definitions,\n                cstore: &'gcx CrateStore)\n                -> Self {\n-        let hash_spans_initial = sess.opts.debuginfo != NoDebugInfo;\n-        let check_overflow_initial = sess.overflow_checks();\n+        let hash_spans_initial = !sess.opts.debugging_opts.incremental_ignore_spans;\n \n         debug_assert!(ich::IGNORED_ATTRIBUTES.len() > 0);\n         IGNORED_ATTR_NAMES.with(|names| {\n@@ -110,7 +107,6 @@ impl<'gcx> StableHashingContext<'gcx> {\n             raw_codemap: sess.codemap(),\n             hash_spans: hash_spans_initial,\n             hash_bodies: true,\n-            overflow_checks_enabled: check_overflow_initial,\n             node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n         }\n     }\n@@ -120,11 +116,6 @@ impl<'gcx> StableHashingContext<'gcx> {\n         self.sess\n     }\n \n-    pub fn force_span_hashing(mut self) -> Self {\n-        self.hash_spans = true;\n-        self\n-    }\n-\n     #[inline]\n     pub fn while_hashing_hir_bodies<F: FnOnce(&mut Self)>(&mut self,\n                                                           hash_bodies: bool,\n@@ -174,11 +165,6 @@ impl<'gcx> StableHashingContext<'gcx> {\n         self.definitions.node_to_hir_id(node_id)\n     }\n \n-    #[inline]\n-    pub fn hash_spans(&self) -> bool {\n-        self.hash_spans\n-    }\n-\n     #[inline]\n     pub fn hash_bodies(&self) -> bool {\n         self.hash_bodies\n@@ -204,58 +190,13 @@ impl<'gcx> StableHashingContext<'gcx> {\n         })\n     }\n \n-    pub fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self,\n-                                                    item_attrs: &[ast::Attribute],\n-                                                    is_const: bool,\n-                                                    f: F) {\n-        let prev_overflow_checks = self.overflow_checks_enabled;\n-        if is_const || attr::contains_name(item_attrs, \"rustc_inherit_overflow_checks\") {\n-            self.overflow_checks_enabled = true;\n-        }\n+    pub fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self, f: F) {\n         let prev_hash_node_ids = self.node_id_hashing_mode;\n         self.node_id_hashing_mode = NodeIdHashingMode::Ignore;\n \n         f(self);\n \n         self.node_id_hashing_mode = prev_hash_node_ids;\n-        self.overflow_checks_enabled = prev_overflow_checks;\n-    }\n-\n-    #[inline]\n-    pub fn binop_can_panic_at_runtime(&self, binop: hir::BinOp_) -> bool\n-    {\n-        match binop {\n-            hir::BiAdd |\n-            hir::BiSub |\n-            hir::BiShl |\n-            hir::BiShr |\n-            hir::BiMul => self.overflow_checks_enabled,\n-\n-            hir::BiDiv |\n-            hir::BiRem => true,\n-\n-            hir::BiAnd |\n-            hir::BiOr |\n-            hir::BiBitXor |\n-            hir::BiBitAnd |\n-            hir::BiBitOr |\n-            hir::BiEq |\n-            hir::BiLt |\n-            hir::BiLe |\n-            hir::BiNe |\n-            hir::BiGe |\n-            hir::BiGt => false\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn unop_can_panic_at_runtime(&self, unop: hir::UnOp) -> bool\n-    {\n-        match unop {\n-            hir::UnDeref |\n-            hir::UnNot => false,\n-            hir::UnNeg => self.overflow_checks_enabled,\n-        }\n     }\n }\n "}, {"sha": "1533e37d7f759d8f4631b398579dbcaf2dd43473", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 100, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -529,63 +529,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Expr {\n                 ref attrs\n             } = *self;\n \n-            let spans_always_on = match *node {\n-                hir::ExprBox(..)        |\n-                hir::ExprArray(..)      |\n-                hir::ExprCall(..)       |\n-                hir::ExprLit(..)        |\n-                hir::ExprCast(..)       |\n-                hir::ExprType(..)       |\n-                hir::ExprIf(..)         |\n-                hir::ExprWhile(..)      |\n-                hir::ExprLoop(..)       |\n-                hir::ExprMatch(..)      |\n-                hir::ExprClosure(..)    |\n-                hir::ExprBlock(..)      |\n-                hir::ExprAssign(..)     |\n-                hir::ExprTupField(..)   |\n-                hir::ExprAddrOf(..)     |\n-                hir::ExprBreak(..)      |\n-                hir::ExprAgain(..)      |\n-                hir::ExprRet(..)        |\n-                hir::ExprYield(..)      |\n-                hir::ExprInlineAsm(..)  |\n-                hir::ExprRepeat(..)     |\n-                hir::ExprTup(..)        |\n-                hir::ExprMethodCall(..) |\n-                hir::ExprPath(..)       |\n-                hir::ExprStruct(..)     |\n-                hir::ExprField(..)      => {\n-                    // For these we only hash the span when debuginfo is on.\n-                    false\n-                }\n-                // For the following, spans might be significant because of\n-                // panic messages indicating the source location.\n-                hir::ExprBinary(op, ..) => {\n-                    hcx.binop_can_panic_at_runtime(op.node)\n-                }\n-                hir::ExprUnary(op, _) => {\n-                    hcx.unop_can_panic_at_runtime(op)\n-                }\n-                hir::ExprAssignOp(op, ..) => {\n-                    hcx.binop_can_panic_at_runtime(op.node)\n-                }\n-                hir::ExprIndex(..) => {\n-                    true\n-                }\n-            };\n-\n-            if spans_always_on {\n-                hcx.while_hashing_spans(true, |hcx| {\n-                    span.hash_stable(hcx, hasher);\n-                    node.hash_stable(hcx, hasher);\n-                    attrs.hash_stable(hcx, hasher);\n-                });\n-            } else {\n-                span.hash_stable(hcx, hasher);\n-                node.hash_stable(hcx, hasher);\n-                attrs.hash_stable(hcx, hasher);\n-            }\n+            span.hash_stable(hcx, hasher);\n+            node.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n         })\n     }\n }\n@@ -712,15 +658,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n             span\n         } = *self;\n \n-        let is_const = match *node {\n-            hir::TraitItemKind::Const(..) |\n-            hir::TraitItemKind::Type(..) => true,\n-            hir::TraitItemKind::Method(hir::MethodSig { constness, .. }, _) => {\n-                constness == hir::Constness::Const\n-            }\n-        };\n-\n-        hcx.hash_hir_item_like(attrs, is_const, |hcx| {\n+        hcx.hash_hir_item_like(|hcx| {\n             name.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n             generics.hash_stable(hcx, hasher);\n@@ -757,15 +695,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n             span\n         } = *self;\n \n-        let is_const = match *node {\n-            hir::ImplItemKind::Const(..) |\n-            hir::ImplItemKind::Type(..) => true,\n-            hir::ImplItemKind::Method(hir::MethodSig { constness, .. }, _) => {\n-                constness == hir::Constness::Const\n-            }\n-        };\n-\n-        hcx.hash_hir_item_like(attrs, is_const, |hcx| {\n+        hcx.hash_hir_item_like(|hcx| {\n             name.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             defaultness.hash_stable(hcx, hasher);\n@@ -884,30 +814,6 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Item {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        let is_const = match self.node {\n-            hir::ItemStatic(..)      |\n-            hir::ItemConst(..)       => {\n-                true\n-            }\n-            hir::ItemFn(_, _, constness, ..) => {\n-                constness == hir::Constness::Const\n-            }\n-            hir::ItemUse(..)         |\n-            hir::ItemExternCrate(..) |\n-            hir::ItemForeignMod(..)  |\n-            hir::ItemGlobalAsm(..)   |\n-            hir::ItemMod(..)         |\n-            hir::ItemAutoImpl(..) |\n-            hir::ItemTrait(..)       |\n-            hir::ItemImpl(..)        |\n-            hir::ItemTy(..)          |\n-            hir::ItemEnum(..)        |\n-            hir::ItemStruct(..)      |\n-            hir::ItemUnion(..)       => {\n-                false\n-            }\n-        };\n-\n         let hir::Item {\n             name,\n             ref attrs,\n@@ -918,7 +824,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Item {\n             span\n         } = *self;\n \n-        hcx.hash_hir_item_like(attrs, is_const, |hcx| {\n+        hcx.hash_hir_item_like(|hcx| {\n             name.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n             node.hash_stable(hcx, hasher);"}, {"sha": "32577ac46f3b13f071e86390dfdd38ccd45a4b31", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 16, "deletions": 41, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -55,48 +55,11 @@ for mir::UnsafetyViolationKind {\n         }\n     }\n }\n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n-for mir::Terminator<'gcx> {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let mir::Terminator {\n-            ref kind,\n-            ref source_info,\n-        } = *self;\n-\n-        let hash_spans_unconditionally = match *kind {\n-            mir::TerminatorKind::Assert { .. } => {\n-                // Assert terminators generate a panic message that contains the\n-                // source location, so we always have to feed its span into the\n-                // ICH.\n-                true\n-            }\n-            mir::TerminatorKind::Goto { .. } |\n-            mir::TerminatorKind::SwitchInt { .. } |\n-            mir::TerminatorKind::Resume |\n-            mir::TerminatorKind::Return |\n-            mir::TerminatorKind::GeneratorDrop |\n-            mir::TerminatorKind::Unreachable |\n-            mir::TerminatorKind::Drop { .. } |\n-            mir::TerminatorKind::DropAndReplace { .. } |\n-            mir::TerminatorKind::Yield { .. } |\n-            mir::TerminatorKind::Call { .. } |\n-            mir::TerminatorKind::FalseEdges { .. } => false,\n-        };\n-\n-        if hash_spans_unconditionally {\n-            hcx.while_hashing_spans(true, |hcx| {\n-                source_info.hash_stable(hcx, hasher);\n-            })\n-        } else {\n-            source_info.hash_stable(hcx, hasher);\n-        }\n \n-        kind.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct mir::Terminator<'tcx> {\n+    kind,\n+    source_info\n+});\n \n impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for mir::ClearCrossCrate<T>\n     where T: HashStable<StableHashingContext<'gcx>>\n@@ -572,3 +535,15 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Literal<'gcx> {\n }\n \n impl_stable_hash_for!(struct mir::Location { block, statement_index });\n+\n+impl_stable_hash_for!(struct mir::ClosureRegionRequirements {\n+    num_external_vids,\n+    outlives_requirements\n+});\n+\n+impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement {\n+    free_region,\n+    outlived_free_region,\n+    blame_span\n+});\n+"}, {"sha": "2655e2acbbdfb369f19437a1c9c35bff1e53149a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -84,6 +84,16 @@ for ty::RegionKind {\n     }\n }\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::RegionVid {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::adjustment::AutoBorrow<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "7f58d03906026ee0a79f23334f48c86d63d111b7", "filename": "src/librustc/infer/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Finfer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Finfer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2FREADME.md?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -141,7 +141,7 @@ will make the permanent. Snapshots can be nested as long as you follow\n a stack-like discipline.\n \n Rather than use snapshots directly, it is often helpful to use the\n-methods like `commit_if_ok` or `probe` that encapsulte higher-level\n+methods like `commit_if_ok` or `probe` that encapsulate higher-level\n patterns.\n \n ## Subtyping obligations"}, {"sha": "6d198601447b089ca342e79cdaee250caa7af886", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -91,10 +91,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         .iter()\n                         .enumerate()\n                         .filter_map(|(index, arg)| {\n-                            let ty = match tables.borrow().node_id_to_type_opt(arg.hir_id) {\n-                                Some(v) => v,\n-                                None => return None, // sometimes the tables are not yet populated\n-                            };\n+                            // May return None; sometimes the tables are not yet populated.\n+                            let ty = tables.borrow().node_id_to_type_opt(arg.hir_id)?;\n                             let mut found_anon_region = false;\n                             let new_arg_ty = self.tcx\n                                 .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {"}, {"sha": "f5595d07340bb88024ce595ba64038fe81274b28", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1062,6 +1062,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_region(ty::ReVar(self.borrow_region_constraints().new_region_var(origin)))\n     }\n \n+    /// Number of region variables created so far.\n+    pub fn num_region_vars(&self) -> usize {\n+        self.borrow_region_constraints().var_origins().len()\n+    }\n+\n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n     pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin)\n                                -> ty::Region<'tcx> {\n@@ -1475,38 +1480,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n-    /// Obtain the signature of a function or closure.\n-    /// For closures, unlike `tcx.fn_sig(def_id)`, this method will\n-    /// work during the type-checking of the enclosing function and\n-    /// return the closure signature in its partially inferred state.\n-    pub fn fn_sig(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n-        // Do we have an in-progress set of tables we are inferring?\n-        if let Some(tables) = self.in_progress_tables {\n-            // Is this a local item?\n-            if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                // Is it a local *closure*?\n-                if self.tcx.is_closure(def_id) {\n-                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n-                    // Is this local closure contained within the tables we are inferring?\n-                    if tables.borrow().local_id_root == Some(DefId::local(hir_id.owner)) {\n-                        // if so, extract signature from there.\n-                        let closure_ty = tables.borrow().node_id_to_type(hir_id);\n-                        let (closure_def_id, closure_substs) = match closure_ty.sty {\n-                            ty::TyClosure(closure_def_id, closure_substs) =>\n-                                (closure_def_id, closure_substs),\n-                            _ =>\n-                                bug!(\"closure with non-closure type: {:?}\", closure_ty),\n-                        };\n-                        assert_eq!(def_id, closure_def_id);\n-                        let closure_sig_ty = closure_substs.closure_sig_ty(def_id, self.tcx);\n-                        let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n-                        return closure_sig_ty.fn_sig(self.tcx);\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.tcx.fn_sig(def_id)\n+    /// Obtain the signature of a closure.  For closures, unlike\n+    /// `tcx.fn_sig(def_id)`, this method will work during the\n+    /// type-checking of the enclosing function and return the closure\n+    /// signature in its partially inferred state.\n+    pub fn closure_sig(\n+        &self,\n+        def_id: DefId,\n+        substs: ty::ClosureSubsts<'tcx>\n+    ) -> ty::PolyFnSig<'tcx> {\n+        let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n+        let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n+        closure_sig_ty.fn_sig(self.tcx)\n     }\n \n     /// Normalizes associated types in `value`, potentially returning"}, {"sha": "d352d359e2021f123952fc2a59d0a638e063b057", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -204,6 +204,12 @@ declare_lint! {\n     \"detects generic lifetime arguments in path segments with late bound lifetime parameters\"\n }\n \n+declare_lint! {\n+    pub INCOHERENT_FUNDAMENTAL_IMPLS,\n+    Warn,\n+    \"potentially-conflicting impls were erroneously allowed\"\n+}\n+\n declare_lint! {\n     pub DEPRECATED,\n     Warn,\n@@ -267,6 +273,7 @@ impl LintPass for HardwiredLints {\n             MISSING_FRAGMENT_SPECIFIER,\n             PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n             LATE_BOUND_LIFETIME_ARGUMENTS,\n+            INCOHERENT_FUNDAMENTAL_IMPLS,\n             DEPRECATED,\n             UNUSED_UNSAFE,\n             UNUSED_MUT,"}, {"sha": "f0761ce61786551380ecc3abea6be57be09521ea", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -37,7 +37,7 @@ use errors::{DiagnosticBuilder, DiagnosticId};\n use hir::def_id::{CrateNum, LOCAL_CRATE};\n use hir::intravisit::{self, FnKind};\n use hir;\n-use session::Session;\n+use session::{Session, DiagnosticMessageId};\n use std::hash;\n use syntax::ast;\n use syntax::codemap::MultiSpan;\n@@ -423,7 +423,7 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         LintSource::Default => {\n             sess.diag_note_once(\n                 &mut err,\n-                lint,\n+                DiagnosticMessageId::from(lint),\n                 &format!(\"#[{}({})] on by default\", level.as_str(), name));\n         }\n         LintSource::CommandLine(lint_flag_val) => {\n@@ -437,24 +437,25 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n             if lint_flag_val.as_str() == name {\n                 sess.diag_note_once(\n                     &mut err,\n-                    lint,\n+                    DiagnosticMessageId::from(lint),\n                     &format!(\"requested on the command line with `{} {}`\",\n                              flag, hyphen_case_lint_name));\n             } else {\n                 let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n                 sess.diag_note_once(\n                     &mut err,\n-                    lint,\n+                    DiagnosticMessageId::from(lint),\n                     &format!(\"`{} {}` implied by `{} {}`\",\n                              flag, hyphen_case_lint_name, flag,\n                              hyphen_case_flag_val));\n             }\n         }\n         LintSource::Node(lint_attr_name, src) => {\n-            sess.diag_span_note_once(&mut err, lint, src, \"lint level defined here\");\n+            sess.diag_span_note_once(&mut err, DiagnosticMessageId::from(lint),\n+                                     src, \"lint level defined here\");\n             if lint_attr_name.as_str() != name {\n                 let level_str = level.as_str();\n-                sess.diag_note_once(&mut err, lint,\n+                sess.diag_note_once(&mut err, DiagnosticMessageId::from(lint),\n                                     &format!(\"#[{}({})] implied by #[{}({})]\",\n                                              level_str, name, level_str, lint_attr_name));\n             }"}, {"sha": "c61e776c6157c9e5ebf4f1c44962429851172337", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1790,6 +1790,75 @@ pub struct GeneratorLayout<'tcx> {\n     pub fields: Vec<LocalDecl<'tcx>>,\n }\n \n+/// After we borrow check a closure, we are left with various\n+/// requirements that we have inferred between the free regions that\n+/// appear in the closure's signature or on its field types.  These\n+/// requirements are then verified and proved by the closure's\n+/// creating function. This struct encodes those requirements.\n+///\n+/// The requirements are listed as being between various\n+/// `RegionVid`. The 0th region refers to `'static`; subsequent region\n+/// vids refer to the free regions that appear in the closure (or\n+/// generator's) type, in order of appearance. (This numbering is\n+/// actually defined by the `UniversalRegions` struct in the NLL\n+/// region checker. See for example\n+/// `UniversalRegions::closure_mapping`.) Note that we treat the free\n+/// regions in the closure's type \"as if\" they were erased, so their\n+/// precise identity is not important, only their position.\n+///\n+/// Example: If type check produces a closure with the closure substs:\n+///\n+/// ```\n+/// ClosureSubsts = [\n+///     i8,                                  // the \"closure kind\"\n+///     for<'x> fn(&'a &'x u32) -> &'x u32,  // the \"closure signature\"\n+///     &'a String,                          // some upvar\n+/// ]\n+/// ```\n+///\n+/// here, there is one unique free region (`'a`) but it appears\n+/// twice. We would \"renumber\" each occurence to a unique vid, as follows:\n+///\n+/// ```\n+/// ClosureSubsts = [\n+///     i8,                                  // the \"closure kind\"\n+///     for<'x> fn(&'1 &'x u32) -> &'x u32,  // the \"closure signature\"\n+///     &'2 String,                          // some upvar\n+/// ]\n+/// ```\n+///\n+/// Now the code might impose a requirement like `'1: '2`. When an\n+/// instance of the closure is created, the corresponding free regions\n+/// can be extracted from its type and constrained to have the given\n+/// outlives relationship.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct ClosureRegionRequirements {\n+    /// The number of external regions defined on the closure.  In our\n+    /// example above, it would be 3 -- one for `'static`, then `'1`\n+    /// and `'2`. This is just used for a sanity check later on, to\n+    /// make sure that the number of regions we see at the callsite\n+    /// matches.\n+    pub num_external_vids: usize,\n+\n+    /// Requirements between the various free regions defined in\n+    /// indices.\n+    pub outlives_requirements: Vec<ClosureOutlivesRequirement>,\n+}\n+\n+/// Indicates an outlives constraint between two free-regions declared\n+/// on the closure.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub struct ClosureOutlivesRequirement {\n+    // This region ...\n+    pub free_region: ty::RegionVid,\n+\n+    // .. must outlive this one.\n+    pub outlived_free_region: ty::RegionVid,\n+\n+    // If not, report an error here.\n+    pub blame_span: Span,\n+}\n+\n /*\n  * TypeFoldable implementations for MIR types\n  */"}, {"sha": "0dcd3e80810801f1228c9c39f56cdbcd2a7e9e32", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1084,6 +1084,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"dump hash information in textual format to stdout\"),\n     incremental_verify_ich: bool = (false, parse_bool, [UNTRACKED],\n         \"verify incr. comp. hashes of green query instances\"),\n+    incremental_ignore_spans: bool = (false, parse_bool, [UNTRACKED],\n+        \"ignore spans during ICH computation -- used for testing\"),\n     dump_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "36c1966bdc8348442b270216d1e71ddfe8f46a08", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -161,6 +161,7 @@ pub struct PerfStats {\n enum DiagnosticBuilderMethod {\n     Note,\n     SpanNote,\n+    SpanSuggestion(String), // suggestion\n     // add more variants as needed to support one-time diagnostics\n }\n \n@@ -173,6 +174,12 @@ pub enum DiagnosticMessageId {\n     StabilityId(u32) // issue number\n }\n \n+impl From<&'static lint::Lint> for DiagnosticMessageId {\n+    fn from(lint: &'static lint::Lint) -> Self {\n+        DiagnosticMessageId::LintId(lint::LintId::of(lint))\n+    }\n+}\n+\n impl Session {\n     pub fn local_crate_disambiguator(&self) -> CrateDisambiguator {\n         match *self.crate_disambiguator.borrow() {\n@@ -358,33 +365,50 @@ impl Session {\n     fn diag_once<'a, 'b>(&'a self,\n                          diag_builder: &'b mut DiagnosticBuilder<'a>,\n                          method: DiagnosticBuilderMethod,\n-                         lint: &'static lint::Lint, message: &str, span: Option<Span>) {\n+                         msg_id: DiagnosticMessageId,\n+                         message: &str,\n+                         span_maybe: Option<Span>) {\n \n-        let lint_id = DiagnosticMessageId::LintId(lint::LintId::of(lint));\n-        let id_span_message = (lint_id, span, message.to_owned());\n+        let id_span_message = (msg_id, span_maybe, message.to_owned());\n         let fresh = self.one_time_diagnostics.borrow_mut().insert(id_span_message);\n         if fresh {\n             match method {\n                 DiagnosticBuilderMethod::Note => {\n                     diag_builder.note(message);\n                 },\n                 DiagnosticBuilderMethod::SpanNote => {\n-                    diag_builder.span_note(span.expect(\"span_note expects a span\"), message);\n+                    let span = span_maybe.expect(\"span_note needs a span\");\n+                    diag_builder.span_note(span, message);\n+                },\n+                DiagnosticBuilderMethod::SpanSuggestion(suggestion) => {\n+                    let span = span_maybe.expect(\"span_suggestion needs a span\");\n+                    diag_builder.span_suggestion(span, message, suggestion);\n                 }\n             }\n         }\n     }\n \n     pub fn diag_span_note_once<'a, 'b>(&'a self,\n                                        diag_builder: &'b mut DiagnosticBuilder<'a>,\n-                                       lint: &'static lint::Lint, span: Span, message: &str) {\n-        self.diag_once(diag_builder, DiagnosticBuilderMethod::SpanNote, lint, message, Some(span));\n+                                       msg_id: DiagnosticMessageId, span: Span, message: &str) {\n+        self.diag_once(diag_builder, DiagnosticBuilderMethod::SpanNote,\n+                       msg_id, message, Some(span));\n     }\n \n     pub fn diag_note_once<'a, 'b>(&'a self,\n                                   diag_builder: &'b mut DiagnosticBuilder<'a>,\n-                                  lint: &'static lint::Lint, message: &str) {\n-        self.diag_once(diag_builder, DiagnosticBuilderMethod::Note, lint, message, None);\n+                                  msg_id: DiagnosticMessageId, message: &str) {\n+        self.diag_once(diag_builder, DiagnosticBuilderMethod::Note, msg_id, message, None);\n+    }\n+\n+    pub fn diag_span_suggestion_once<'a, 'b>(&'a self,\n+                                             diag_builder: &'b mut DiagnosticBuilder<'a>,\n+                                             msg_id: DiagnosticMessageId,\n+                                             span: Span,\n+                                             message: &str,\n+                                             suggestion: String) {\n+        self.diag_once(diag_builder, DiagnosticBuilderMethod::SpanSuggestion(suggestion),\n+                       msg_id, message, Some(span));\n     }\n \n     pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {"}, {"sha": "7d1f3b31bfc27141be5e0a5147d06b67a0f70eda", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 192, "deletions": 57, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -13,14 +13,27 @@\n use hir::def_id::{DefId, LOCAL_CRATE};\n use syntax_pos::DUMMY_SP;\n use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause, Reveal};\n+use traits::IntercrateMode;\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, Ty, TyCtxt};\n+use ty::fold::TypeFoldable;\n use ty::subst::Subst;\n \n use infer::{InferCtxt, InferOk};\n \n-#[derive(Copy, Clone)]\n-struct InferIsLocal(bool);\n+/// Whether we do the orphan check relative to this crate or\n+/// to some remote crate.\n+#[derive(Copy, Clone, Debug)]\n+enum InCrate {\n+    Local,\n+    Remote\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum Conflict {\n+    Upstream,\n+    Downstream { used_to_be_broken: bool }\n+}\n \n pub struct OverlapResult<'tcx> {\n     pub impl_header: ty::ImplHeader<'tcx>,\n@@ -31,16 +44,19 @@ pub struct OverlapResult<'tcx> {\n /// `ImplHeader` with those types substituted\n pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n                                           impl1_def_id: DefId,\n-                                          impl2_def_id: DefId)\n+                                          impl2_def_id: DefId,\n+                                          intercrate_mode: IntercrateMode)\n                                           -> Option<OverlapResult<'tcx>>\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n-           impl2_def_id={:?})\",\n+           impl2_def_id={:?},\n+           intercrate_mode={:?})\",\n            impl1_def_id,\n-           impl2_def_id);\n+           impl2_def_id,\n+           intercrate_mode);\n \n-    let selcx = &mut SelectionContext::intercrate(infcx);\n+    let selcx = &mut SelectionContext::intercrate(infcx, intercrate_mode);\n     overlap(selcx, impl1_def_id, impl2_def_id)\n }\n \n@@ -126,32 +142,49 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n }\n \n pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                             trait_ref: ty::TraitRef<'tcx>) -> bool\n+                                             trait_ref: ty::TraitRef<'tcx>)\n+                                             -> Option<Conflict>\n {\n     debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n-\n-    // if the orphan rules pass, that means that no ancestor crate can\n-    // impl this, so it's up to us.\n-    if orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(false)).is_ok() {\n-        debug!(\"trait_ref_is_knowable: orphan check passed\");\n-        return true;\n+    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Remote).is_ok() {\n+        // A downstream or cousin crate is allowed to implement some\n+        // substitution of this trait-ref.\n+\n+        // A trait can be implementable for a trait ref by both the current\n+        // crate and crates downstream of it. Older versions of rustc\n+        // were not aware of this, causing incoherence (issue #43355).\n+        let used_to_be_broken =\n+            orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok();\n+        if used_to_be_broken {\n+            debug!(\"trait_ref_is_knowable({:?}) - USED TO BE BROKEN\", trait_ref);\n+        }\n+        return Some(Conflict::Downstream { used_to_be_broken });\n     }\n \n-    // if the trait is not marked fundamental, then it's always possible that\n-    // an ancestor crate will impl this in the future, if they haven't\n-    // already\n-    if !trait_ref_is_local_or_fundamental(tcx, trait_ref) {\n-        debug!(\"trait_ref_is_knowable: trait is neither local nor fundamental\");\n-        return false;\n+    if trait_ref_is_local_or_fundamental(tcx, trait_ref) {\n+        // This is a local or fundamental trait, so future-compatibility\n+        // is no concern. We know that downstream/cousin crates are not\n+        // allowed to implement a substitution of this trait ref, which\n+        // means impls could only come from dependencies of this crate,\n+        // which we already know about.\n+        return None;\n     }\n \n-    // find out when some downstream (or cousin) crate could impl this\n-    // trait-ref, presuming that all the parameters were instantiated\n-    // with downstream types. If not, then it could only be\n-    // implemented by an upstream crate, which means that the impl\n-    // must be visible to us, and -- since the trait is fundamental\n-    // -- we can test.\n-    orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(true)).is_err()\n+    // This is a remote non-fundamental trait, so if another crate\n+    // can be the \"final owner\" of a substitution of this trait-ref,\n+    // they are allowed to implement it future-compatibly.\n+    //\n+    // However, if we are a final owner, then nobody else can be,\n+    // and if we are an intermediate owner, then we don't care\n+    // about future-compatibility, which means that we're OK if\n+    // we are an owner.\n+    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok() {\n+        debug!(\"trait_ref_is_knowable: orphan check passed\");\n+        return None;\n+    } else {\n+        debug!(\"trait_ref_is_knowable: nonlocal, nonfundamental, unowned\");\n+        return Some(Conflict::Upstream);\n+    }\n }\n \n pub fn trait_ref_is_local_or_fundamental<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -189,30 +222,123 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         return Ok(());\n     }\n \n-    orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(false))\n+    orphan_check_trait_ref(tcx, trait_ref, InCrate::Local)\n }\n \n+/// Check whether a trait-ref is potentially implementable by a crate.\n+///\n+/// The current rule is that a trait-ref orphan checks in a crate C:\n+///\n+/// 1. Order the parameters in the trait-ref in subst order - Self first,\n+///    others linearly (e.g. `<U as Foo<V, W>>` is U < V < W).\n+/// 2. Of these type parameters, there is at least one type parameter\n+///    in which, walking the type as a tree, you can reach a type local\n+///    to C where all types in-between are fundamental types. Call the\n+///    first such parameter the \"local key parameter\".\n+///     - e.g. `Box<LocalType>` is OK, because you can visit LocalType\n+///       going through `Box`, which is fundamental.\n+///     - similarly, `FundamentalPair<Vec<()>, Box<LocalType>>` is OK for\n+///       the same reason.\n+///     - but (knowing that `Vec<T>` is non-fundamental, and assuming it's\n+///       not local), `Vec<LocalType>` is bad, because `Vec<->` is between\n+///       the local type and the type parameter.\n+/// 3. Every type parameter before the local key parameter is fully known in C.\n+///     - e.g. `impl<T> T: Trait<LocalType>` is bad, because `T` might be\n+///       an unknown type.\n+///     - but `impl<T> LocalType: Trait<T>` is OK, because `LocalType`\n+///       occurs before `T`.\n+/// 4. Every type in the local key parameter not known in C, going\n+///    through the parameter's type tree, must appear only as a subtree of\n+///    a type local to C, with only fundamental types between the type\n+///    local to C and the local key parameter.\n+///     - e.g. `Vec<LocalType<T>>>` (or equivalently `Box<Vec<LocalType<T>>>`)\n+///     is bad, because the only local type with `T` as a subtree is\n+///     `LocalType<T>`, and `Vec<->` is between it and the type parameter.\n+///     - similarly, `FundamentalPair<LocalType<T>, T>` is bad, because\n+///     the second occurence of `T` is not a subtree of *any* local type.\n+///     - however, `LocalType<Vec<T>>` is OK, because `T` is a subtree of\n+///     `LocalType<Vec<T>>`, which is local and has no types between it and\n+///     the type parameter.\n+///\n+/// The orphan rules actually serve several different purposes:\n+///\n+/// 1. They enable link-safety - i.e. 2 mutually-unknowing crates (where\n+///    every type local to one crate is unknown in the other) can't implement\n+///    the same trait-ref. This follows because it can be seen that no such\n+///    type can orphan-check in 2 such crates.\n+///\n+///    To check that a local impl follows the orphan rules, we check it in\n+///    InCrate::Local mode, using type parameters for the \"generic\" types.\n+///\n+/// 2. They ground negative reasoning for coherence. If a user wants to\n+///    write both a conditional blanket impl and a specific impl, we need to\n+///    make sure they do not overlap. For example, if we write\n+///    ```\n+///    impl<T> IntoIterator for Vec<T>\n+///    impl<T: Iterator> IntoIterator for T\n+///    ```\n+///    We need to be able to prove that `Vec<$0>: !Iterator` for every type $0.\n+///    We can observe that this holds in the current crate, but we need to make\n+///    sure this will also hold in all unknown crates (both \"independent\" crates,\n+///    which we need for link-safety, and also child crates, because we don't want\n+///    child crates to get error for impl conflicts in a *dependency*).\n+///\n+///    For that, we only allow negative reasoning if, for every assignment to the\n+///    inference variables, every unknown crate would get an orphan error if they\n+///    try to implement this trait-ref. To check for this, we use InCrate::Remote\n+///    mode. That is sound because we already know all the impls from known crates.\n+///\n+/// 3. For non-#[fundamental] traits, they guarantee that parent crates can\n+///    add \"non-blanket\" impls without breaking negative reasoning in dependent\n+///    crates. This is the \"rebalancing coherence\" (RFC 1023) restriction.\n+///\n+///    For that, we only a allow crate to perform negative reasoning on\n+///    non-local-non-#[fundamental] only if there's a local key parameter as per (2).\n+///\n+///    Because we never perform negative reasoning generically (coherence does\n+///    not involve type parameters), this can be interpreted as doing the full\n+///    orphan check (using InCrate::Local mode), substituting non-local known\n+///    types for all inference variables.\n+///\n+///    This allows for crates to future-compatibly add impls as long as they\n+///    can't apply to types with a key parameter in a child crate - applying\n+///    the rules, this basically means that every type parameter in the impl\n+///    must appear behind a non-fundamental type (because this is not a\n+///    type-system requirement, crate owners might also go for \"semantic\n+///    future-compatibility\" involving things such as sealed traits, but\n+///    the above requirement is sufficient, and is necessary in \"open world\"\n+///    cases).\n+///\n+/// Note that this function is never called for types that have both type\n+/// parameters and inference variables.\n fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n                                 trait_ref: ty::TraitRef<'tcx>,\n-                                infer_is_local: InferIsLocal)\n+                                in_crate: InCrate)\n                                 -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"orphan_check_trait_ref(trait_ref={:?}, infer_is_local={})\",\n-           trait_ref, infer_is_local.0);\n+    debug!(\"orphan_check_trait_ref(trait_ref={:?}, in_crate={:?})\",\n+           trait_ref, in_crate);\n+\n+    if trait_ref.needs_infer() && trait_ref.needs_subst() {\n+        bug!(\"can't orphan check a trait ref with both params and inference variables {:?}\",\n+             trait_ref);\n+    }\n \n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n     // Find the first input type that either references a type parameter OR\n     // some local type.\n     for input_ty in trait_ref.input_types() {\n-        if ty_is_local(tcx, input_ty, infer_is_local) {\n+        if ty_is_local(tcx, input_ty, in_crate) {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n \n             // First local input type. Check that there are no\n             // uncovered type parameters.\n-            let uncovered_tys = uncovered_tys(tcx, input_ty, infer_is_local);\n+            let uncovered_tys = uncovered_tys(tcx, input_ty, in_crate);\n             for uncovered_ty in uncovered_tys {\n-                if let Some(param) = uncovered_ty.walk().find(|t| is_type_parameter(t)) {\n+                if let Some(param) = uncovered_ty.walk()\n+                    .find(|t| is_possibly_remote_type(t, in_crate))\n+                {\n                     debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n                     return Err(OrphanCheckErr::UncoveredTy(param));\n                 }\n@@ -224,11 +350,11 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n \n         // Otherwise, enforce invariant that there are no type\n         // parameters reachable.\n-        if !infer_is_local.0 {\n-            if let Some(param) = input_ty.walk().find(|t| is_type_parameter(t)) {\n-                debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n-                return Err(OrphanCheckErr::UncoveredTy(param));\n-            }\n+        if let Some(param) = input_ty.walk()\n+            .find(|t| is_possibly_remote_type(t, in_crate))\n+        {\n+            debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n+            return Err(OrphanCheckErr::UncoveredTy(param));\n         }\n     }\n \n@@ -237,29 +363,29 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n     return Err(OrphanCheckErr::NoLocalInputType);\n }\n \n-fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, infer_is_local: InferIsLocal)\n+fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, in_crate: InCrate)\n                        -> Vec<Ty<'tcx>> {\n-    if ty_is_local_constructor(ty, infer_is_local) {\n+    if ty_is_local_constructor(ty, in_crate) {\n         vec![]\n     } else if fundamental_ty(tcx, ty) {\n         ty.walk_shallow()\n-          .flat_map(|t| uncovered_tys(tcx, t, infer_is_local))\n+          .flat_map(|t| uncovered_tys(tcx, t, in_crate))\n           .collect()\n     } else {\n         vec![ty]\n     }\n }\n \n-fn is_type_parameter(ty: Ty) -> bool {\n+fn is_possibly_remote_type(ty: Ty, _in_crate: InCrate) -> bool {\n     match ty.sty {\n         ty::TyProjection(..) | ty::TyParam(..) => true,\n         _ => false,\n     }\n }\n \n-fn ty_is_local(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal) -> bool {\n-    ty_is_local_constructor(ty, infer_is_local) ||\n-        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, infer_is_local))\n+fn ty_is_local(tcx: TyCtxt, ty: Ty, in_crate: InCrate) -> bool {\n+    ty_is_local_constructor(ty, in_crate) ||\n+        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, in_crate))\n }\n \n fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n@@ -273,7 +399,16 @@ fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     }\n }\n \n-fn ty_is_local_constructor(ty: Ty, infer_is_local: InferIsLocal)-> bool {\n+fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n+    match in_crate {\n+        // The type is local to *this* crate - it will not be\n+        // local in any other crate.\n+        InCrate::Remote => false,\n+        InCrate::Local => def_id.is_local()\n+    }\n+}\n+\n+fn ty_is_local_constructor(ty: Ty, in_crate: InCrate) -> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {\n@@ -296,20 +431,20 @@ fn ty_is_local_constructor(ty: Ty, infer_is_local: InferIsLocal)-> bool {\n             false\n         }\n \n-        ty::TyInfer(..) => {\n-            infer_is_local.0\n-        }\n+        ty::TyInfer(..) => match in_crate {\n+            InCrate::Local => false,\n+            // The inference variable might be unified with a local\n+            // type in that remote crate.\n+            InCrate::Remote => true,\n+        },\n \n-        ty::TyAdt(def, _) => {\n-            def.did.is_local()\n-        }\n-\n-        ty::TyForeign(did) => {\n-            did.is_local()\n-        }\n+        ty::TyAdt(def, _) => def_id_is_local(def.did, in_crate),\n+        ty::TyForeign(did) => def_id_is_local(did, in_crate),\n \n         ty::TyDynamic(ref tt, ..) => {\n-            tt.principal().map_or(false, |p| p.def_id().is_local())\n+            tt.principal().map_or(false, |p| {\n+                def_id_is_local(p.def_id(), in_crate)\n+            })\n         }\n \n         ty::TyError => {"}, {"sha": "94605d895a5545c399843428bbe9b8aacc25b0fe", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -60,6 +60,13 @@ mod structural_impls;\n pub mod trans;\n mod util;\n \n+// Whether to enable bug compatibility with issue #43355\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum IntercrateMode {\n+    Issue43355,\n+    Fixed\n+}\n+\n /// An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n /// which the vtable must be found.  The process of finding a vtable is\n /// called \"resolving\" the `Obligation`. This process consists of"}, {"sha": "3342d13dd6e5fa230b691ef6def7d6eebf13ccb9", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1339,26 +1339,27 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>)\n     -> Progress<'tcx>\n {\n-    let closure_typer = selcx.closure_typer();\n-    let closure_type = closure_typer.fn_sig(vtable.closure_def_id)\n-        .subst(selcx.tcx(), vtable.substs.substs);\n+    let tcx = selcx.tcx();\n+    let infcx = selcx.infcx();\n+    let closure_sig_ty = vtable.substs.closure_sig_ty(vtable.closure_def_id, tcx);\n+    let closure_sig = infcx.shallow_resolve(&closure_sig_ty).fn_sig(tcx);\n     let Normalized {\n-        value: closure_type,\n+        value: closure_sig,\n         obligations\n     } = normalize_with_depth(selcx,\n                              obligation.param_env,\n                              obligation.cause.clone(),\n                              obligation.recursion_depth+1,\n-                             &closure_type);\n+                             &closure_sig);\n \n-    debug!(\"confirm_closure_candidate: obligation={:?},closure_type={:?},obligations={:?}\",\n+    debug!(\"confirm_closure_candidate: obligation={:?},closure_sig={:?},obligations={:?}\",\n            obligation,\n-           closure_type,\n+           closure_sig,\n            obligations);\n \n     confirm_callable_candidate(selcx,\n                                obligation,\n-                               closure_type,\n+                               closure_sig,\n                                util::TupleArgumentsFlag::No)\n         .with_addl_obligations(vtable.nested)\n         .with_addl_obligations(obligations)"}, {"sha": "e70de0e566e41c3daa75ad43c6aa911147fac00e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 61, "deletions": 41, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -13,8 +13,9 @@\n use self::SelectionCandidate::*;\n use self::EvaluationResult::*;\n \n-use super::coherence;\n+use super::coherence::{self, Conflict};\n use super::DerivedObligationCause;\n+use super::IntercrateMode;\n use super::project;\n use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n@@ -87,7 +88,7 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// other words, we consider `$0 : Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n-    intercrate: bool,\n+    intercrate: Option<IntercrateMode>,\n \n     inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n \n@@ -111,21 +112,24 @@ impl IntercrateAmbiguityCause {\n     /// See #23980 for details.\n     pub fn add_intercrate_ambiguity_hint<'a, 'tcx>(&self,\n                                                    err: &mut ::errors::DiagnosticBuilder) {\n+        err.note(&self.intercrate_ambiguity_hint());\n+    }\n+\n+    pub fn intercrate_ambiguity_hint(&self) -> String {\n         match self {\n             &IntercrateAmbiguityCause::DownstreamCrate { ref trait_desc, ref self_desc } => {\n                 let self_desc = if let &Some(ref ty) = self_desc {\n                     format!(\" for type `{}`\", ty)\n                 } else { \"\".to_string() };\n-                err.note(&format!(\"downstream crates may implement trait `{}`{}\",\n-                                  trait_desc, self_desc));\n+                format!(\"downstream crates may implement trait `{}`{}\", trait_desc, self_desc)\n             }\n             &IntercrateAmbiguityCause::UpstreamCrateUpdate { ref trait_desc, ref self_desc } => {\n                 let self_desc = if let &Some(ref ty) = self_desc {\n                     format!(\" for type `{}`\", ty)\n                 } else { \"\".to_string() };\n-                err.note(&format!(\"upstream crates may add new impl of trait `{}`{} \\\n-                                  in future versions\",\n-                                  trait_desc, self_desc));\n+                format!(\"upstream crates may add new impl of trait `{}`{} \\\n+                         in future versions\",\n+                        trait_desc, self_desc)\n             }\n         }\n     }\n@@ -417,17 +421,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: false,\n+            intercrate: None,\n             inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: Vec::new(),\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+                      mode: IntercrateMode) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+        debug!(\"intercrate({:?})\", mode);\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: true,\n+            intercrate: Some(mode),\n             inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: Vec::new(),\n         }\n@@ -758,7 +764,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_trait_predicate_recursively({:?})\",\n                obligation);\n \n-        if !self.intercrate && obligation.is_global() {\n+        if !self.intercrate.is_some() && obligation.is_global() {\n             // If a param env is consistent, global obligations do not depend on its particular\n             // value in order to work, so we can clear out the param env and get better\n             // caching. (If the current param env is inconsistent, we don't care what happens).\n@@ -814,7 +820,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n         let unbound_input_types = stack.fresh_trait_ref.input_types().any(|ty| ty.is_fresh());\n-        if unbound_input_types && self.intercrate {\n+        // this check was an imperfect workaround for a bug n the old\n+        // intercrate mode, it should be removed when that goes away.\n+        if unbound_input_types &&\n+            self.intercrate == Some(IntercrateMode::Issue43355)\n+        {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n                    stack.fresh_trait_ref);\n             // Heuristics: show the diagnostics when there are no candidates in crate.\n@@ -1077,28 +1087,32 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(None);\n         }\n \n-        if !self.is_knowable(stack) {\n-            debug!(\"coherence stage: not knowable\");\n-            // Heuristics: show the diagnostics when there are no candidates in crate.\n-            let candidate_set = self.assemble_candidates(stack)?;\n-            if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n-                let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                let self_ty = trait_ref.self_ty();\n-                let trait_desc = trait_ref.to_string();\n-                let self_desc = if self_ty.has_concrete_skeleton() {\n-                    Some(self_ty.to_string())\n-                } else {\n-                    None\n-                };\n-                let cause = if !coherence::trait_ref_is_local_or_fundamental(self.tcx(),\n-                                                                             trait_ref) {\n-                    IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n-                } else {\n-                    IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n-                };\n-                self.intercrate_ambiguity_causes.push(cause);\n+        match self.is_knowable(stack) {\n+            None => {}\n+            Some(conflict) => {\n+                debug!(\"coherence stage: not knowable\");\n+                // Heuristics: show the diagnostics when there are no candidates in crate.\n+                let candidate_set = self.assemble_candidates(stack)?;\n+                if !candidate_set.ambiguous && candidate_set.vec.iter().all(|c| {\n+                    !self.evaluate_candidate(stack, &c).may_apply()\n+                }) {\n+                    let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                    let self_ty = trait_ref.self_ty();\n+                    let trait_desc = trait_ref.to_string();\n+                    let self_desc = if self_ty.has_concrete_skeleton() {\n+                        Some(self_ty.to_string())\n+                    } else {\n+                        None\n+                    };\n+                    let cause = if let Conflict::Upstream = conflict {\n+                        IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n+                    } else {\n+                        IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n+                    };\n+                    self.intercrate_ambiguity_causes.push(cause);\n+                }\n+                return Ok(None);\n             }\n-            return Ok(None);\n         }\n \n         let candidate_set = self.assemble_candidates(stack)?;\n@@ -1205,12 +1219,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     fn is_knowable<'o>(&mut self,\n                        stack: &TraitObligationStack<'o, 'tcx>)\n-                       -> bool\n+                       -> Option<Conflict>\n     {\n-        debug!(\"is_knowable(intercrate={})\", self.intercrate);\n+        debug!(\"is_knowable(intercrate={:?})\", self.intercrate);\n \n-        if !self.intercrate {\n-            return true;\n+        if !self.intercrate.is_some() {\n+            return None;\n         }\n \n         let obligation = &stack.obligation;\n@@ -1221,7 +1235,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // bound regions\n         let trait_ref = predicate.skip_binder().trait_ref;\n \n-        coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n+        let result = coherence::trait_ref_is_knowable(self.tcx(), trait_ref);\n+        if let (Some(Conflict::Downstream { used_to_be_broken: true }),\n+                Some(IntercrateMode::Issue43355)) = (result, self.intercrate) {\n+            debug!(\"is_knowable: IGNORING conflict to be bug-compatible with #43355\");\n+            None\n+        } else {\n+            result\n+        }\n     }\n \n     /// Returns true if the global caches can be used.\n@@ -1246,7 +1267,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // the master cache. Since coherence executes pretty quickly,\n         // it's not worth going to more trouble to increase the\n         // hit-rate I don't think.\n-        if self.intercrate {\n+        if self.intercrate.is_some() {\n             return false;\n         }\n \n@@ -3162,8 +3183,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                       substs: ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n-        let closure_type = self.infcx.fn_sig(closure_def_id)\n-            .subst(self.tcx(), substs.substs);\n+        let closure_type = self.infcx.closure_sig(closure_def_id, substs);\n         let ty::Binder((trait_ref, _)) =\n             self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n                                                          obligation.predicate.0.self_ty(), // (1)"}, {"sha": "6a96d01d5f92a498c272e82cb3ecb34b4de47f54", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -30,6 +30,8 @@ use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n use std::rc::Rc;\n \n+use lint;\n+\n pub mod specialization_graph;\n \n /// Information pertinent to an overlapping impl error.\n@@ -325,16 +327,33 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n             // This is where impl overlap checking happens:\n             let insert_result = sg.insert(tcx, impl_def_id);\n             // Report error if there was one.\n-            if let Err(overlap) = insert_result {\n-                let mut err = struct_span_err!(tcx.sess,\n-                                               tcx.span_of_impl(impl_def_id).unwrap(),\n-                                               E0119,\n-                                               \"conflicting implementations of trait `{}`{}:\",\n-                                               overlap.trait_desc,\n-                                               overlap.self_desc.clone().map_or(String::new(),\n-                                                                                |ty| {\n-                    format!(\" for type `{}`\", ty)\n-                }));\n+            let (overlap, used_to_be_allowed) = match insert_result {\n+                Err(overlap) => (Some(overlap), false),\n+                Ok(opt_overlap) => (opt_overlap, true)\n+            };\n+\n+            if let Some(overlap) = overlap {\n+                let msg = format!(\"conflicting implementations of trait `{}`{}:{}\",\n+                    overlap.trait_desc,\n+                    overlap.self_desc.clone().map_or(\n+                        String::new(), |ty| {\n+                            format!(\" for type `{}`\", ty)\n+                        }),\n+                    if used_to_be_allowed { \" (E0119)\" } else { \"\" }\n+                );\n+                let mut err = if used_to_be_allowed {\n+                    tcx.struct_span_lint_node(\n+                        lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                        tcx.hir.as_local_node_id(impl_def_id).unwrap(),\n+                        tcx.span_of_impl(impl_def_id).unwrap(),\n+                        &msg)\n+                } else {\n+                    struct_span_err!(tcx.sess,\n+                                     tcx.span_of_impl(impl_def_id).unwrap(),\n+                                     E0119,\n+                                     \"{}\",\n+                                     msg)\n+                };\n \n                 match tcx.span_of_impl(overlap.with_impl) {\n                     Ok(span) => {"}, {"sha": "834389e5d009c62145d41e7fd88b2d0698e62265", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -68,7 +68,7 @@ struct Children {\n /// The result of attempting to insert an impl into a group of children.\n enum Inserted {\n     /// The impl was inserted as a new child in this group of children.\n-    BecameNewSibling,\n+    BecameNewSibling(Option<OverlapError>),\n \n     /// The impl replaced an existing impl that specializes it.\n     Replaced(DefId),\n@@ -105,17 +105,39 @@ impl<'a, 'gcx, 'tcx> Children {\n               simplified_self: Option<SimplifiedType>)\n               -> Result<Inserted, OverlapError>\n     {\n+        let mut last_lint = None;\n+\n         for slot in match simplified_self {\n             Some(sty) => self.filtered_mut(sty),\n             None => self.iter_mut(),\n         } {\n             let possible_sibling = *slot;\n \n+            let overlap_error = |overlap: traits::coherence::OverlapResult| {\n+                // overlap, but no specialization; error out\n+                let trait_ref = overlap.impl_header.trait_ref.unwrap();\n+                let self_ty = trait_ref.self_ty();\n+                OverlapError {\n+                    with_impl: possible_sibling,\n+                    trait_desc: trait_ref.to_string(),\n+                    // only report the Self type if it has at least\n+                    // some outer concrete shell; otherwise, it's\n+                    // not adding much information.\n+                    self_desc: if self_ty.has_concrete_skeleton() {\n+                        Some(self_ty.to_string())\n+                    } else {\n+                        None\n+                    },\n+                    intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n+                }\n+            };\n+\n             let tcx = tcx.global_tcx();\n             let (le, ge) = tcx.infer_ctxt().enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n-                                                        impl_def_id);\n+                                                        impl_def_id,\n+                                                        traits::IntercrateMode::Issue43355);\n                 if let Some(overlap) = overlap {\n                     if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n                         return Ok((false, false));\n@@ -125,22 +147,7 @@ impl<'a, 'gcx, 'tcx> Children {\n                     let ge = tcx.specializes((possible_sibling, impl_def_id));\n \n                     if le == ge {\n-                        // overlap, but no specialization; error out\n-                        let trait_ref = overlap.impl_header.trait_ref.unwrap();\n-                        let self_ty = trait_ref.self_ty();\n-                        Err(OverlapError {\n-                            with_impl: possible_sibling,\n-                            trait_desc: trait_ref.to_string(),\n-                            // only report the Self type if it has at least\n-                            // some outer concrete shell; otherwise, it's\n-                            // not adding much information.\n-                            self_desc: if self_ty.has_concrete_skeleton() {\n-                                Some(self_ty.to_string())\n-                            } else {\n-                                None\n-                            },\n-                            intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n-                        })\n+                        Err(overlap_error(overlap))\n                     } else {\n                         Ok((le, ge))\n                     }\n@@ -163,14 +170,27 @@ impl<'a, 'gcx, 'tcx> Children {\n                     *slot = impl_def_id;\n                 return Ok(Inserted::Replaced(possible_sibling));\n             } else {\n+                if !tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n+                    tcx.infer_ctxt().enter(|infcx| {\n+                        if let Some(overlap) = traits::overlapping_impls(\n+                            &infcx,\n+                            possible_sibling,\n+                            impl_def_id,\n+                            traits::IntercrateMode::Fixed)\n+                        {\n+                            last_lint = Some(overlap_error(overlap));\n+                        }\n+                    });\n+                }\n+\n                 // no overlap (error bailed already via ?)\n             }\n         }\n \n         // no overlap with any potential siblings, so add as a new sibling\n         debug!(\"placing as new sibling\");\n         self.insert_blindly(tcx, impl_def_id);\n-        Ok(Inserted::BecameNewSibling)\n+        Ok(Inserted::BecameNewSibling(last_lint))\n     }\n \n     fn iter_mut(&'a mut self) -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n@@ -199,7 +219,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n     pub fn insert(&mut self,\n                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   impl_def_id: DefId)\n-                  -> Result<(), OverlapError> {\n+                  -> Result<Option<OverlapError>, OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -220,10 +240,11 @@ impl<'a, 'gcx, 'tcx> Graph {\n             self.parent.insert(impl_def_id, trait_def_id);\n             self.children.entry(trait_def_id).or_insert(Children::new())\n                 .insert_blindly(tcx, impl_def_id);\n-            return Ok(());\n+            return Ok(None);\n         }\n \n         let mut parent = trait_def_id;\n+        let mut last_lint = None;\n         let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false);\n \n         // Descend the specialization tree, where `parent` is the current parent node\n@@ -234,7 +255,8 @@ impl<'a, 'gcx, 'tcx> Graph {\n                 .insert(tcx, impl_def_id, simplified)?;\n \n             match insert_result {\n-                BecameNewSibling => {\n+                BecameNewSibling(opt_lint) => {\n+                    last_lint = opt_lint;\n                     break;\n                 }\n                 Replaced(new_child) => {\n@@ -251,7 +273,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n         }\n \n         self.parent.insert(impl_def_id, parent);\n-        Ok(())\n+        Ok(last_lint)\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent."}, {"sha": "61b19227744c10f97cf242e1a512ef0956068912", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def_id::DefId;\n use ty::{self, Ty, TypeFoldable, Substs, TyCtxt};\n-use ty::subst::{Kind, Subst};\n+use ty::subst::Kind;\n use traits;\n use syntax::abi::Abi;\n use util::ppaux;\n@@ -311,7 +311,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     let self_ty = tcx.mk_closure_from_closure_substs(\n         closure_did, substs);\n \n-    let sig = tcx.fn_sig(closure_did).subst(tcx, substs.substs);\n+    let sig = substs.closure_sig(closure_did, tcx);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     assert_eq!(sig.inputs().len(), 1);\n     let substs = tcx.mk_substs(["}, {"sha": "2d0a3799178a5c90f1fde58cb17f49364f2fe334", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -27,14 +27,15 @@ pub trait QueryConfig {\n pub(super) trait QueryDescription<'tcx>: QueryConfig {\n     fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n \n+    #[inline]\n     fn cache_on_disk(_: Self::Key) -> bool {\n         false\n     }\n \n     fn try_load_from_disk(_: TyCtxt<'_, 'tcx, 'tcx>,\n                           _: SerializedDepNodeIndex)\n                           -> Option<Self::Value> {\n-        bug!(\"QueryDescription::load_from_disk() called for unsupport query.\")\n+        bug!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n     }\n }\n \n@@ -166,6 +167,18 @@ impl<'tcx> QueryDescription<'tcx> for queries::symbol_name<'tcx> {\n     fn describe(_tcx: TyCtxt, instance: ty::Instance<'tcx>) -> String {\n         format!(\"computing the symbol for `{}`\", instance)\n     }\n+\n+    #[inline]\n+    fn cache_on_disk(_: Self::Key) -> bool {\n+        true\n+    }\n+\n+    #[inline]\n+    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              id: SerializedDepNodeIndex)\n+                              -> Option<Self::Value> {\n+        tcx.on_disk_query_result_cache.try_load_query_result(tcx, id)\n+    }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::describe_def<'tcx> {\n@@ -234,6 +247,18 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_sta\n         format!(\"const checking if rvalue is promotable to static `{}`\",\n             tcx.item_path_str(def_id))\n     }\n+\n+    #[inline]\n+    fn cache_on_disk(_: Self::Key) -> bool {\n+        true\n+    }\n+\n+    #[inline]\n+    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          id: SerializedDepNodeIndex)\n+                          -> Option<Self::Value> {\n+        tcx.on_disk_query_result_cache.try_load_query_result(tcx, id)\n+    }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::rvalue_promotable_map<'tcx> {\n@@ -254,6 +279,18 @@ impl<'tcx> QueryDescription<'tcx> for queries::trans_fulfill_obligation<'tcx> {\n     fn describe(tcx: TyCtxt, key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> String {\n         format!(\"checking if `{}` fulfills its obligations\", tcx.item_path_str(key.1.def_id()))\n     }\n+\n+    #[inline]\n+    fn cache_on_disk(_: Self::Key) -> bool {\n+        true\n+    }\n+\n+    #[inline]\n+    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              id: SerializedDepNodeIndex)\n+                              -> Option<Self::Value> {\n+        tcx.on_disk_query_result_cache.try_load_query_result(tcx, id)\n+    }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::trait_impls_of<'tcx> {\n@@ -567,3 +604,42 @@ impl<'tcx> QueryDescription<'tcx> for queries::typeck_tables_of<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::optimized_mir<'tcx> {\n+    #[inline]\n+    fn cache_on_disk(def_id: Self::Key) -> bool {\n+        def_id.is_local()\n+    }\n+\n+    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          id: SerializedDepNodeIndex)\n+                          -> Option<Self::Value> {\n+        let mir: Option<::mir::Mir<'tcx>> = tcx.on_disk_query_result_cache\n+                                               .try_load_query_result(tcx, id);\n+        mir.map(|x| tcx.alloc_mir(x))\n+    }\n+}\n+\n+macro_rules! impl_disk_cacheable_query(\n+    ($query_name:ident, |$key:tt| $cond:expr) => {\n+        impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {\n+            #[inline]\n+            fn cache_on_disk($key: Self::Key) -> bool {\n+                $cond\n+            }\n+\n+            #[inline]\n+            fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      id: SerializedDepNodeIndex)\n+                                      -> Option<Self::Value> {\n+                tcx.on_disk_query_result_cache.try_load_query_result(tcx, id)\n+            }\n+        }\n+    }\n+);\n+\n+impl_disk_cacheable_query!(unsafety_check_result, |def_id| def_id.is_local());\n+impl_disk_cacheable_query!(borrowck, |def_id| def_id.is_local());\n+impl_disk_cacheable_query!(mir_borrowck, |def_id| def_id.is_local());\n+impl_disk_cacheable_query!(mir_const_qualif, |def_id| def_id.is_local());\n+impl_disk_cacheable_query!(contains_extern_indicator, |_| true);\n+impl_disk_cacheable_query!(def_symbol_name, |_| true);"}, {"sha": "848d2a0a7def71d9a7adef2bca3fcaa72eff0fd2", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -190,8 +190,10 @@ define_maps! { <'tcx>\n     [] fn coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n     [] fn borrowck: BorrowCheck(DefId) -> Rc<BorrowCheckResult>,\n-    // FIXME: shouldn't this return a `Result<(), BorrowckErrors>` instead?\n-    [] fn mir_borrowck: MirBorrowCheck(DefId) -> (),\n+\n+    /// Borrow checks the function body. If this is a closure, returns\n+    /// additional requirements that the closure's creator must verify.\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> Option<mir::ClosureRegionRequirements>,\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence."}, {"sha": "079b518efd8981b49dc64c9e487e55529338028f", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -207,6 +207,16 @@ impl<'sess> OnDiskCache<'sess> {\n \n             // Encode TypeckTables\n             encode_query_results::<typeck_tables_of, _>(tcx, enc, qri)?;\n+            encode_query_results::<optimized_mir, _>(tcx, enc, qri)?;\n+            encode_query_results::<unsafety_check_result, _>(tcx, enc, qri)?;\n+            encode_query_results::<borrowck, _>(tcx, enc, qri)?;\n+            encode_query_results::<mir_borrowck, _>(tcx, enc, qri)?;\n+            encode_query_results::<mir_const_qualif, _>(tcx, enc, qri)?;\n+            encode_query_results::<def_symbol_name, _>(tcx, enc, qri)?;\n+            encode_query_results::<const_is_rvalue_promotable_to_static, _>(tcx, enc, qri)?;\n+            encode_query_results::<contains_extern_indicator, _>(tcx, enc, qri)?;\n+            encode_query_results::<symbol_name, _>(tcx, enc, qri)?;\n+            encode_query_results::<trans_fulfill_obligation, _>(tcx, enc, qri)?;\n         }\n \n         // Encode diagnostics"}, {"sha": "ec6d190b8bde9478011fc353bed8a6adf1a1b782", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -974,4 +974,7 @@ impl_load_from_cache!(\n     BorrowCheck => borrowck,\n     MirBorrowCheck => mir_borrowck,\n     MirConstQualif => mir_const_qualif,\n+    SymbolName => def_symbol_name,\n+    ConstIsRvaluePromotableToStatic => const_is_rvalue_promotable_to_static,\n+    ContainsExternIndicator => contains_extern_indicator,\n );"}, {"sha": "4f733b8f68a3604a0464c23d693f0575180d06c2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -356,13 +356,17 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// Returns the closure kind for this closure; only usable outside\n     /// of an inference context, because in that context we know that\n     /// there are no type variables.\n+    ///\n+    /// If you have an inference context, use `infcx.closure_kind()`.\n     pub fn closure_kind(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::ClosureKind {\n         self.split(def_id, tcx).closure_kind_ty.to_opt_closure_kind().unwrap()\n     }\n \n     /// Extracts the signature from the closure; only usable outside\n     /// of an inference context, because in that context we know that\n     /// there are no type variables.\n+    ///\n+    /// If you have an inference context, use `infcx.closure_sig()`.\n     pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n         match self.closure_sig_ty(def_id, tcx).sty {\n             ty::TyFnPtr(sig) => sig,\n@@ -646,6 +650,17 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n pub struct Binder<T>(pub T);\n \n impl<T> Binder<T> {\n+    /// Wraps `value` in a binder, asserting that `value` does not\n+    /// contain any bound regions that would be bound by the\n+    /// binder. This is commonly used to 'inject' a value T into a\n+    /// different binding level.\n+    pub fn dummy<'tcx>(value: T) -> Binder<T>\n+        where T: TypeFoldable<'tcx>\n+    {\n+        assert!(!value.has_escaping_regions());\n+        Binder(value)\n+    }\n+\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// debruijn indices and the like. It is usually better to\n@@ -700,6 +715,32 @@ impl<T> Binder<T> {\n             Some(self.skip_binder().clone())\n         }\n     }\n+\n+    /// Given two things that have the same binder level,\n+    /// and an operation that wraps on their contents, execute the operation\n+    /// and then wrap its result.\n+    ///\n+    /// `f` should consider bound regions at depth 1 to be free, and\n+    /// anything it produces with bound regions at depth 1 will be\n+    /// bound in the resulting return value.\n+    pub fn fuse<U,F,R>(self, u: Binder<U>, f: F) -> Binder<R>\n+        where F: FnOnce(T, U) -> R\n+    {\n+        ty::Binder(f(self.0, u.0))\n+    }\n+\n+    /// Split the contents into two things that share the same binder\n+    /// level as the original, returning two distinct binders.\n+    ///\n+    /// `f` should consider bound regions at depth 1 to be free, and\n+    /// anything it produces with bound regions at depth 1 will be\n+    /// bound in the resulting return values.\n+    pub fn split<U,V,F>(self, f: F) -> (Binder<U>, Binder<V>)\n+        where F: FnOnce(T) -> (U, V)\n+    {\n+        let (u, v) = f(self.0);\n+        (ty::Binder(u), ty::Binder(v))\n+    }\n }\n \n /// Represents the projection of an associated type. In explicit UFCS\n@@ -799,6 +840,9 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])\n     }\n+    pub fn inputs_and_output(&self) -> ty::Binder<&'tcx Slice<Ty<'tcx>>> {\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs_and_output)\n+    }\n     pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.output().clone())\n     }"}, {"sha": "2e9e45c9ffe16b9b436be9210dcb25f2f7ff5656", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -439,12 +439,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         });\n \n-        let dtor_did = match dtor_did {\n-            Some(dtor) => dtor,\n-            None => return None,\n-        };\n-\n-        Some(ty::Destructor { did: dtor_did })\n+        Some(ty::Destructor { did: dtor_did? })\n     }\n \n     /// Return the set of types that are required to be alive in"}, {"sha": "76d3494dbf08209c87726743bdd6cb2207eae3e3", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -215,24 +215,18 @@ pub fn record_time<T, F>(accu: &Cell<Duration>, f: F) -> T where\n     rv\n }\n \n-// Like std::macros::try!, but for Option<>.\n-#[cfg(unix)]\n-macro_rules! option_try(\n-    ($e:expr) => (match $e { Some(e) => e, None => return None })\n-);\n-\n // Memory reporting\n #[cfg(unix)]\n fn get_resident() -> Option<usize> {\n     use std::fs::File;\n     use std::io::Read;\n \n     let field = 1;\n-    let mut f = option_try!(File::open(\"/proc/self/statm\").ok());\n+    let mut f = File::open(\"/proc/self/statm\").ok()?;\n     let mut contents = String::new();\n-    option_try!(f.read_to_string(&mut contents).ok());\n-    let s = option_try!(contents.split_whitespace().nth(field));\n-    let npages = option_try!(s.parse::<usize>().ok());\n+    f.read_to_string(&mut contents).ok()?;\n+    let s = contents.split_whitespace().nth(field)?;\n+    let npages = s.parse::<usize>().ok()?;\n     Some(npages * 4096)\n }\n "}, {"sha": "5d7139507b33f9427e0eb4048893596e0f98818a", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -291,10 +291,8 @@ impl<'a, T: Idx> Iterator for Iter<'a, T> {\n                 }\n             }\n \n-            match self.iter.next() {\n-                Some((i, word)) => self.cur = Some((*word, word_bits * i)),\n-                None => return None,\n-            }\n+            let (i, word) = self.iter.next()?;\n+            self.cur = Some((*word, word_bits * i));\n         }\n     }\n }"}, {"sha": "b0f61e9a19177cfe21bcce6ff29b57b2f1708879", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1069,7 +1069,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(control: &CompileController,\n \n         time(time_passes,\n              \"MIR borrow checking\",\n-             || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id) });\n+             || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id); });\n \n         time(time_passes,\n              \"MIR effect checking\","}, {"sha": "d9b67e2d27f0c96b869032e63a51068e2be4fc4f", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -982,7 +982,7 @@ Available lint options:\n     println!(\"Lint groups provided by rustc:\\n\");\n     println!(\"    {}  {}\", padded(\"name\"), \"sub-lints\");\n     println!(\"    {}  {}\", padded(\"----\"), \"---------\");\n-    println!(\"    {}  {}\", padded(\"warnings\"), \"all built-in lints\");\n+    println!(\"    {}  {}\", padded(\"warnings\"), \"all lints that are set to issue warnings\");\n \n     let print_lint_groups = |lints: Vec<(&'static str, Vec<lint::LintId>)>| {\n         for (name, to) in lints {"}, {"sha": "2c33f80520360a83fa741b114d4f7d56c3b4c46d", "filename": "src/librustc_errors/styled_buffer.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_errors%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_errors%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fstyled_buffer.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -27,10 +27,21 @@ impl StyledBuffer {\n     }\n \n     fn replace_tabs(&mut self) {\n-        for line in self.text.iter_mut() {\n-            for c in line.iter_mut() {\n+        for (line_pos, line) in self.text.iter_mut().enumerate() {\n+            let mut tab_pos = vec![];\n+            for (pos, c) in line.iter().enumerate() {\n                 if *c == '\\t' {\n-                    *c = ' ';\n+                    tab_pos.push(pos);\n+                }\n+            }\n+            // start with the tabs at the end of the line to replace them with 4 space chars\n+            for pos in tab_pos.iter().rev() {\n+                assert_eq!(line.remove(*pos), '\\t');\n+                // fix the position of the style to match up after replacing the tabs\n+                let s = self.styles[line_pos].remove(*pos);\n+                for _ in 0..4 {\n+                    line.insert(*pos, ' ');\n+                    self.styles[line_pos].insert(*pos, s);\n                 }\n             }\n         }"}, {"sha": "8b41dd62742ce278fe51f92ed5f570b330daa810", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -247,11 +247,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(SAFE_PACKED_BORROWS),\n             reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(INCOHERENT_FUNDAMENTAL_IMPLS),\n+            reference: \"issue #46205 <https://github.com/rust-lang/rust/issues/46205>\",\n+        },\n         FutureIncompatibleInfo {\n             id: LintId::of(COERCE_NEVER),\n             reference: \"issue #46325 <https://github.com/rust-lang/rust/issues/46325>\",\n         },\n-\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "71b15643cbcef3de45140ad0785ff53f402e7be4", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -47,9 +47,7 @@ impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n             let mut hasher = StableHasher::new();\n \n             hcx.while_hashing_hir_bodies(true, |hcx| {\n-                hcx.while_hashing_spans(false, |hcx| {\n-                    body.hash_stable(hcx, &mut hasher);\n-                });\n+                body.hash_stable(hcx, &mut hasher);\n             });\n \n             hasher.finish()"}, {"sha": "264c15bcd0b76ee8f93431665a09be3f89db86c5", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -385,10 +385,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn load(&mut self, locate_ctxt: &mut locator::Context) -> Option<LoadResult> {\n-        let library = match locate_ctxt.maybe_load_library_crate() {\n-            Some(lib) => lib,\n-            None => return None,\n-        };\n+        let library = locate_ctxt.maybe_load_library_crate()?;\n \n         // In the case that we're loading a crate, but not matching\n         // against a hash, we could load a crate which has the same hash"}, {"sha": "3be99e9722361b213330dfb6cf7d825fc863e597", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -273,25 +273,23 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let lo = BytePos::decode(self)?;\n         let hi = BytePos::decode(self)?;\n \n+        if lo == BytePos(0) && hi == BytePos(0) {\n+            // Don't try to rebase DUMMY_SP. Otherwise it will look like a valid\n+            // Span again.\n+            return Ok(DUMMY_SP)\n+        }\n+\n+        if hi < lo {\n+            // Consistently map invalid spans to DUMMY_SP.\n+            return Ok(DUMMY_SP)\n+        }\n+\n         let sess = if let Some(sess) = self.sess {\n             sess\n         } else {\n             bug!(\"Cannot decode Span without Session.\")\n         };\n \n-        let (lo, hi) = if lo > hi {\n-            // Currently macro expansion sometimes produces invalid Span values\n-            // where lo > hi. In order not to crash the compiler when trying to\n-            // translate these values, let's transform them into something we\n-            // can handle (and which will produce useful debug locations at\n-            // least some of the time).\n-            // This workaround is only necessary as long as macro expansion is\n-            // not fixed. FIXME(#23480)\n-            (lo, lo)\n-        } else {\n-            (lo, hi)\n-        };\n-\n         let imported_filemaps = self.cdata().imported_filemaps(&sess.codemap());\n         let filemap = {\n             // Optimize for the case that most spans within a translated item\n@@ -321,6 +319,16 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             }\n         };\n \n+        // Make sure our binary search above is correct.\n+        debug_assert!(lo >= filemap.original_start_pos &&\n+                      lo <= filemap.original_end_pos);\n+\n+        if hi < filemap.original_start_pos || hi > filemap.original_end_pos {\n+            // `hi` points to a different FileMap than `lo` which is invalid.\n+            // Again, map invalid Spans to DUMMY_SP.\n+            return Ok(DUMMY_SP)\n+        }\n+\n         let lo = (lo + filemap.translated_filemap.start_pos) - filemap.original_start_pos;\n         let hi = (hi + filemap.translated_filemap.start_pos) - filemap.original_start_pos;\n "}, {"sha": "3edb9c16023a3dee2690877c33f535505bf1e13c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 462, "deletions": 101, "changes": 563, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -12,12 +12,14 @@\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n use rustc::ty::{self, ParamEnv, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Local, Location, Place};\n use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n+use rustc::mir::ClosureRegionRequirements;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n@@ -36,6 +38,9 @@ use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MoveOutIndex, MovePathIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n+use std::fmt;\n+use std::iter;\n+\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n pub(crate) mod nll;\n@@ -47,29 +52,34 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn mir_borrowck<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> Option<ClosureRegionRequirements> {\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n     if {\n         !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.sess.opts.borrowck_mode.use_mir()\n             && !tcx.sess.opts.debugging_opts.nll\n     } {\n-        return;\n+        return None;\n     }\n \n-    tcx.infer_ctxt().enter(|infcx| {\n+    let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_mir: &Mir = &input_mir.borrow();\n-        do_mir_borrowck(&infcx, input_mir, def_id);\n+        do_mir_borrowck(&infcx, input_mir, def_id)\n     });\n     debug!(\"mir_borrowck done\");\n+\n+    opt_closure_req\n }\n \n fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     input_mir: &Mir<'gcx>,\n     def_id: DefId,\n-) {\n+) -> Option<ClosureRegionRequirements> {\n     let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n@@ -87,7 +97,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         let mir = &mut mir;\n \n         // Replace all regions with fresh inference variables.\n-        Some(nll::replace_regions_in_mir(infcx, def_id, mir))\n+        Some(nll::replace_regions_in_mir(infcx, def_id, param_env, mir))\n     };\n     let mir = &mir;\n \n@@ -128,6 +138,12 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         move_data: move_data,\n         param_env: param_env,\n     };\n+    let body_id = match tcx.def_key(def_id).disambiguated_data.data {\n+        DefPathData::StructCtor |\n+        DefPathData::EnumVariant(_) => None,\n+        _ => Some(tcx.hir.body_owned_by(id))\n+    };\n+\n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n     let mut flow_inits = FlowInProgress::new(do_dataflow(\n         tcx,\n@@ -167,19 +183,20 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     ));\n \n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n-    let opt_regioncx = if let Some(free_regions) = free_regions {\n-        Some(nll::compute_regions(\n+    let (opt_regioncx, opt_closure_req) = if let Some(free_regions) = free_regions {\n+        let (regioncx, opt_closure_req) = nll::compute_regions(\n             infcx,\n             def_id,\n             free_regions,\n             mir,\n             param_env,\n             &mut flow_inits,\n             &mdpe.move_data,\n-        ))\n+        );\n+        (Some(regioncx), opt_closure_req)\n     } else {\n         assert!(!tcx.sess.opts.debugging_opts.nll);\n-        None\n+        (None, None)\n     };\n     let flow_inits = flow_inits; // remove mut\n \n@@ -189,6 +206,11 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         node_id: id,\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n+        locals_are_invalidated_at_exit: match tcx.hir.body_owner_kind(id) {\n+            hir::BodyOwnerKind::Const |\n+            hir::BodyOwnerKind::Static(_) => false,\n+            hir::BodyOwnerKind::Fn => true,\n+        },\n         storage_dead_or_drop_error_reported: FxHashSet(),\n     };\n \n@@ -198,7 +220,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, mir, opt_regioncx),\n+        Borrows::new(tcx, mir, opt_regioncx, def_id, body_id),\n         |bd, i| bd.location(i),\n     ));\n \n@@ -211,6 +233,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     );\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n+\n+    opt_closure_req\n }\n \n #[allow(dead_code)]\n@@ -220,6 +244,13 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     node_id: ast::NodeId,\n     move_data: &'cx MoveData<'tcx>,\n     param_env: ParamEnv<'gcx>,\n+    /// This keeps track of whether local variables are free-ed when the function\n+    /// exits even without a `StorageDead`, which appears to be the case for\n+    /// constants.\n+    ///\n+    /// I'm not sure this is the right approach - @eddyb could you try and\n+    /// figure this out?\n+    locals_are_invalidated_at_exit: bool,\n     /// This field keeps track of when storage dead or drop errors are reported\n     /// in order to stop duplicate error reporting and identify the conditions required\n     /// for a \"temporary value dropped here while still borrowed\" error. See #45360.\n@@ -306,8 +337,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n     }\n \n     fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n-        let summary = flow_state.summary();\n-        debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, summary);\n+        debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, flow_state);\n     }\n \n     fn visit_statement_entry(\n@@ -316,12 +346,11 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         stmt: &Statement<'tcx>,\n         flow_state: &Self::FlowState,\n     ) {\n-        let summary = flow_state.summary();\n         debug!(\n             \"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\",\n             location,\n             stmt,\n-            summary\n+            flow_state\n         );\n         let span = stmt.source_info.span;\n         match stmt.kind {\n@@ -423,12 +452,11 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         flow_state: &Self::FlowState,\n     ) {\n         let loc = location;\n-        let summary = flow_state.summary();\n         debug!(\n             \"MirBorrowckCtxt::process_terminator({:?}, {:?}): {}\",\n             location,\n             term,\n-            summary\n+            flow_state\n         );\n         let span = term.source_info.span;\n         match term.kind {\n@@ -540,14 +568,13 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n \n                         if self.place_is_invalidated_at_exit(&borrow.place) {\n                             debug!(\"borrow conflicts at exit {:?}\", borrow);\n-                            let borrow_span = self.mir.source_info(borrow.location).span;\n                             // FIXME: should be talking about the region lifetime instead\n                             // of just a span here.\n                             let end_span = domain.opt_region_end_span(&borrow.region);\n \n                             self.report_borrowed_value_does_not_live_long_enough(\n                                 ContextKind::StorageDead.new(loc),\n-                                (&borrow.place, borrow_span),\n+                            (&borrow.place, end_span.unwrap_or(span)),\n                                 end_span,\n                             )\n                         }\n@@ -641,8 +668,9 @@ enum WriteKind {\n /// - Take flow state into consideration in `is_assignable()` for local variables\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum LocalMutationIsAllowed {\n+    Move,\n     Yes,\n-    No,\n+    No\n }\n \n #[derive(Copy, Clone)]\n@@ -710,7 +738,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context,\n             (sd, place_span.0),\n             flow_state,\n-            |this, _index, borrow, common_prefix| match (rw, borrow.kind) {\n+            |this, _index, borrow| match (rw, borrow.kind) {\n                 (Read(_), BorrowKind::Shared) => Control::Continue,\n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut) => {\n                     match kind {\n@@ -727,7 +755,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             error_reported = true;\n                             this.report_conflicting_borrow(\n                                 context,\n-                                common_prefix,\n                                 place_span,\n                                 bk,\n                                 &borrow,\n@@ -748,7 +775,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             error_reported = true;\n                             this.report_conflicting_borrow(\n                                 context,\n-                                common_prefix,\n                                 place_span,\n                                 bk,\n                                 &borrow,\n@@ -934,7 +960,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     context,\n                     (place, span),\n                     (Deep, Write(WriteKind::Move)),\n-                    LocalMutationIsAllowed::Yes,\n+                    LocalMutationIsAllowed::Move,\n                     flow_state,\n                 );\n \n@@ -952,14 +978,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Returns whether a borrow of this place is invalidated when the function\n     /// exits\n-    fn place_is_invalidated_at_exit(&self, place: &Place<'tcx>) -> bool {\n+    fn place_is_invalidated_at_exit(&mut self, place: &Place<'tcx>) -> bool {\n         debug!(\"place_is_invalidated_at_exit({:?})\", place);\n         let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n         // we'll have a memory leak) and assume that all statics have a destructor.\n-        let (might_be_alive, will_be_dropped) = match root_place {\n+        //\n+        // FIXME: allow thread-locals to borrow other thread locals?\n+        let (might_be_alive, will_be_dropped, local) = match root_place {\n             Place::Static(statik) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n@@ -968,12 +996,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     .iter()\n                     .any(|attr| attr.check_name(\"thread_local\"));\n \n-                (true, is_thread_local)\n+                (true, is_thread_local, None)\n             }\n-            Place::Local(_) => {\n+            Place::Local(local) => {\n                 // Locals are always dropped at function exit, and if they\n                 // have a destructor it would've been called already.\n-                (false, true)\n+                (false, self.locals_are_invalidated_at_exit, Some(*local))\n             }\n             Place::Projection(..) => {\n                 bug!(\"root of {:?} is a projection ({:?})?\", place, root_place)\n@@ -996,8 +1024,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             PrefixSet::Shallow\n         };\n \n-        self.prefixes(place, prefix_set)\n-            .any(|prefix| prefix == root_place)\n+        let result =\n+            self.prefixes(place, prefix_set).any(|prefix| prefix == root_place);\n+\n+        if result {\n+            if let Some(local) = local {\n+                if let Some(_) = self.storage_dead_or_drop_error_reported.replace(local) {\n+                    debug!(\"place_is_invalidated_at_exit({:?}) - suppressed\", place);\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        result\n     }\n }\n \n@@ -1343,7 +1382,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n-                        LocalMutationIsAllowed::Yes => Ok(()),\n+                        LocalMutationIsAllowed::Yes |\n+                        LocalMutationIsAllowed::Move => Ok(()),\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n                     Mutability::Mut => Ok(()),\n@@ -1368,10 +1408,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        if self.is_upvar_field_projection(&proj.base).is_some() {\n-                                            self.is_mutable(&proj.base, is_local_mutation_allowed)\n-                                        } else {\n-                                            self.is_unique(&proj.base)\n+                                        match self.is_upvar_field_projection(&proj.base) {\n+                                            Some(field) if {\n+                                                self.mir.upvar_decls[field.index()].by_ref\n+                                            } => {\n+                                                self.is_mutable(&proj.base,\n+                                                                is_local_mutation_allowed)\n+                                            }\n+                                            _ => self.is_unique(&proj.base)\n                                         }\n                                     }\n                                 }\n@@ -1387,7 +1431,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n                             _ if base_ty.is_box() => {\n-                                self.is_mutable(&proj.base, LocalMutationIsAllowed::No)\n+                                self.is_mutable(&proj.base, is_local_mutation_allowed)\n                             }\n                             // Deref should only be for reference, pointers or boxes\n                             _ => bug!(\"Deref of unexpected type: {:?}\", base_ty),\n@@ -1404,14 +1448,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                         if let Some(field) = field_projection {\n                             let decl = &self.mir.upvar_decls[field.index()];\n-\n-                            return match decl.mutability {\n-                                Mutability::Mut => self.is_unique(&proj.base),\n-                                Mutability::Not => Err(place),\n+                            debug!(\"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n+                                   decl, is_local_mutation_allowed, place);\n+                            return match (decl.mutability, is_local_mutation_allowed) {\n+                                (Mutability::Not, LocalMutationIsAllowed::No) |\n+                                (Mutability::Not, LocalMutationIsAllowed::Yes) => Err(place),\n+                                (Mutability::Not, LocalMutationIsAllowed::Move) |\n+                                (Mutability::Mut, _) => self.is_unique(&proj.base),\n                             };\n                         }\n \n-                        self.is_mutable(&proj.base, LocalMutationIsAllowed::No)\n+                        self.is_mutable(&proj.base, is_local_mutation_allowed)\n                     }\n                 }\n             }\n@@ -1425,9 +1472,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // Local variables are unique\n                 Ok(())\n             }\n-            Place::Static(..) => {\n-                // Static variables are not\n-                Err(place)\n+            Place::Static(ref static_) => {\n+                if !self.tcx.is_static_mut(static_.def_id) {\n+                    Err(place)\n+                } else {\n+                    Ok(())\n+                }\n             }\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n@@ -1478,15 +1528,358 @@ enum NoMovePathFound {\n     ReachedStatic,\n }\n \n+/// The degree of overlap between 2 places for borrow-checking.\n+enum Overlap {\n+    /// The places might partially overlap - in this case, we give\n+    /// up and say that they might conflict. This occurs when\n+    /// different fields of a union are borrowed. For example,\n+    /// if `u` is a union, we have no way of telling how disjoint\n+    /// `u.a.x` and `a.b.y` are.\n+    Arbitrary,\n+    /// The places have the same type, and are either completely disjoint\n+    /// or equal - i.e. they can't \"partially\" overlap as can occur with\n+    /// unions. This is the \"base case\" on which we recur for extensions\n+    /// of the place.\n+    EqualOrDisjoint,\n+    /// The places are disjoint, so we know all extensions of them\n+    /// will also be disjoint.\n+    Disjoint,\n+}\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    // Given that the bases of `elem1` and `elem2` are always either equal\n+    // or disjoint (and have the same type!), return the overlap situation\n+    // between `elem1` and `elem2`.\n+    fn place_element_conflict(&self,\n+                               elem1: &Place<'tcx>,\n+                               elem2: &Place<'tcx>)\n+                               -> Overlap\n+    {\n+        match (elem1, elem2) {\n+            (Place::Local(l1), Place::Local(l2)) => {\n+                if l1 == l2 {\n+                    // the same local - base case, equal\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n+                    Overlap::EqualOrDisjoint\n+                } else {\n+                    // different locals - base case, disjoint\n+                    debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n+                    Overlap::Disjoint\n+                }\n+            }\n+            (Place::Static(..), Place::Static(..)) => {\n+                // Borrows of statics do not have to be tracked here.\n+                debug!(\"place_element_conflict: IGNORED-STATIC\");\n+                Overlap::Disjoint\n+            }\n+            (Place::Local(_), Place::Static(_)) |\n+            (Place::Static(_), Place::Local(_)) => {\n+                debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n+                Overlap::Disjoint\n+            }\n+            (Place::Projection(pi1), Place::Projection(pi2)) => {\n+                match (&pi1.elem, &pi2.elem) {\n+                    (ProjectionElem::Deref, ProjectionElem::Deref) => {\n+                        // derefs (e.g. `*x` vs. `*x`) - recur.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n+                        Overlap::EqualOrDisjoint\n+                    }\n+                    (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n+                        if f1 == f2 {\n+                            // same field (e.g. `a.y` vs. `a.y`) - recur.\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                            Overlap::EqualOrDisjoint\n+                        } else {\n+                            let ty = pi1.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                            match ty.sty {\n+                                ty::TyAdt(def, _) if def.is_union() => {\n+                                    // Different fields of a union, we are basically stuck.\n+                                    debug!(\"place_element_conflict: STUCK-UNION\");\n+                                    Overlap::Arbitrary\n+                                }\n+                                _ => {\n+                                    // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n+                                    debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                                    Overlap::Disjoint\n+                                }\n+                            }\n+                        }\n+                    }\n+                    (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n+                        // different variants are treated as having disjoint fields,\n+                        // even if they occupy the same \"space\", because it's\n+                        // impossible for 2 variants of the same enum to exist\n+                        // (and therefore, to be borrowed) at the same time.\n+                        //\n+                        // Note that this is different from unions - we *do* allow\n+                        // this code to compile:\n+                        //\n+                        // ```\n+                        // fn foo(x: &mut Result<i32, i32>) {\n+                        //     let mut v = None;\n+                        //     if let Ok(ref mut a) = *x {\n+                        //         v = Some(a);\n+                        //     }\n+                        //     // here, you would *think* that the\n+                        //     // *entirety* of `x` would be borrowed,\n+                        //     // but in fact only the `Ok` variant is,\n+                        //     // so the `Err` variant is *entirely free*:\n+                        //     if let Err(ref mut a) = *x {\n+                        //         v = Some(a);\n+                        //     }\n+                        //     drop(v);\n+                        // }\n+                        // ```\n+                        if v1 == v2 {\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                            Overlap::EqualOrDisjoint\n+                        } else {\n+                            debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                            Overlap::Disjoint\n+                        }\n+                    }\n+                    (ProjectionElem::Index(..), ProjectionElem::Index(..)) |\n+                    (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. }) |\n+                    (ProjectionElem::Index(..), ProjectionElem::Subslice { .. }) |\n+                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..)) |\n+                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::ConstantIndex { .. }) |\n+                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. }) |\n+                    (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..)) |\n+                    (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. }) |\n+                    (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                        // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n+                        // (if the indexes differ) or equal (if they are the same), so this\n+                        // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n+                        //\n+                        // Note that by construction, MIR at borrowck can't subdivide\n+                        // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n+                        // are only present in slice patterns, and we \"merge together\" nested\n+                        // slice patterns. That means we don't have to think about these. It's\n+                        // probably a good idea to assert this somewhere, but I'm too lazy.\n+                        //\n+                        // FIXME(#8636) we might want to return Disjoint if\n+                        // both projections are constant and disjoint.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n+                        Overlap::EqualOrDisjoint\n+                    }\n+\n+                    (ProjectionElem::Deref, _) |\n+                    (ProjectionElem::Field(..), _) |\n+                    (ProjectionElem::Index(..), _) |\n+                    (ProjectionElem::ConstantIndex { .. }, _) |\n+                    (ProjectionElem::Subslice { .. }, _) |\n+                    (ProjectionElem::Downcast(..), _) => {\n+                        bug!(\"mismatched projections in place_element_conflict: {:?} and {:?}\",\n+\n+                             elem1, elem2)\n+                    }\n+                }\n+            }\n+            (Place::Projection(_), _) |\n+            (_, Place::Projection(_)) => {\n+                bug!(\"unexpected elements in place_element_conflict: {:?} and {:?}\",\n+                     elem1, elem2)\n+            }\n+        }\n+    }\n+    fn borrow_conflicts_with_place(&mut self,\n+                                    borrow: &BorrowData<'tcx>,\n+                                    place: &Place<'tcx>,\n+                                    access: ShallowOrDeep)\n+                                    -> bool\n+    {\n+        debug!(\"borrow_conflicts_with_place({:?},{:?},{:?})\", borrow, place, access);\n+\n+        // Return all the prefixes of `place` in reverse order, including\n+        // downcasts.\n+        fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>>\n+        {\n+            let mut result = vec![];\n+            let mut place = place;\n+            loop {\n+                result.push(place);\n+                match place {\n+                    Place::Projection(interior) => {\n+                        place = &interior.base;\n+                    }\n+                    Place::Local(_) | Place::Static(_) => {\n+                        result.reverse();\n+                        return result;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let borrow_components = place_elements(&borrow.place);\n+        let access_components = place_elements(place);\n+        debug!(\"borrow_conflicts_with_place: components {:?} / {:?}\",\n+               borrow_components, access_components);\n+\n+        let borrow_components = borrow_components.into_iter()\n+             .map(Some).chain(iter::repeat(None));\n+        let access_components = access_components.into_iter()\n+             .map(Some).chain(iter::repeat(None));\n+        // The borrowck rules for proving disjointness are applied from the \"root\" of the\n+        // borrow forwards, iterating over \"similar\" projections in lockstep until\n+        // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n+        // a monoid and report a conflict if the product ends up not being `Disjoint`.\n+        //\n+        // At each step, if we didn't run out of borrow or place, we know that our elements\n+        // have the same type, and that they only overlap if they are the identical.\n+        //\n+        // For example, if we are comparing these:\n+        // BORROW:  (*x1[2].y).z.a\n+        // ACCESS:  (*x1[i].y).w.b\n+        //\n+        // Then our steps are:\n+        //       x1         |   x1          -- places are the same\n+        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+        //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n+        //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n+        //\n+        // Because `zip` does potentially bad things to the iterator inside, this loop\n+        // also handles the case where the access might be a *prefix* of the borrow, e.g.\n+        //\n+        // BORROW:  (*x1[2].y).z.a\n+        // ACCESS:  x1[i].y\n+        //\n+        // Then our steps are:\n+        //       x1         |   x1          -- places are the same\n+        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+        //\n+        // -- here we run out of access - the borrow can access a part of it. If this\n+        // is a full deep access, then we *know* the borrow conflicts with it. However,\n+        // if the access is shallow, then we can proceed:\n+        //\n+        //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n+        //                                     are disjoint\n+        //\n+        // Our invariant is, that at each step of the iteration:\n+        //  - If we didn't run out of access to match, our borrow and access are comparable\n+        //    and either equal or disjoint.\n+        //  - If we did run out of accesss, the borrow can access a part of it.\n+        for (borrow_c, access_c) in borrow_components.zip(access_components) {\n+            // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n+            debug!(\"borrow_conflicts_with_place: {:?} vs. {:?}\", borrow_c, access_c);\n+            match (borrow_c, access_c) {\n+                (None, _) => {\n+                    // If we didn't run out of access, the borrow can access all of our\n+                    // place (e.g. a borrow of `a.b` with an access to `a.b.c`),\n+                    // so we have a conflict.\n+                    //\n+                    // If we did, then we still know that the borrow can access a *part*\n+                    // of our place that our access cares about (a borrow of `a.b.c`\n+                    // with an access to `a.b`), so we still have a conflict.\n+                    //\n+                    // FIXME: Differs from AST-borrowck; includes drive-by fix\n+                    // to #38899. Will probably need back-compat mode flag.\n+                    debug!(\"borrow_conflict_with_place: full borrow, CONFLICT\");\n+                    return true;\n+                }\n+                (Some(borrow_c), None) => {\n+                    // We know that the borrow can access a part of our place. This\n+                    // is a conflict if that is a part our access cares about.\n+\n+                    let (base, elem) = match borrow_c {\n+                        Place::Projection(box Projection { base, elem }) => (base, elem),\n+                        _ => bug!(\"place has no base?\")\n+                    };\n+                    let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+\n+                    match (elem, &base_ty.sty, access) {\n+                        (_, _, Shallow(Some(ArtificialField::Discriminant))) |\n+                        (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                            // The discriminant and array length are like\n+                            // additional fields on the type; they do not\n+                            // overlap any existing data there. Furthermore,\n+                            // they cannot actually be a prefix of any\n+                            // borrowed place (at least in MIR as it is\n+                            // currently.)\n+                            //\n+                            // e.g. a (mutable) borrow of `a[5]` while we read the\n+                            // array length of `a`.\n+                            debug!(\"borrow_conflicts_with_place: implicit field\");\n+                            return false;\n+                        }\n+\n+                        (ProjectionElem::Deref, _, Shallow(None)) => {\n+                            // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n+                            // prefix thereof - the shallow access can't touch anything behind\n+                            // the pointer.\n+                            debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n+                            return false;\n+                        }\n+                        (ProjectionElem::Deref, ty::TyRef(_, ty::TypeAndMut {\n+                            ty: _, mutbl: hir::MutImmutable\n+                        }), _) => {\n+                            // the borrow goes through a dereference of a shared reference.\n+                            //\n+                            // I'm not sure why we are tracking these borrows - shared\n+                            // references can *always* be aliased, which means the\n+                            // permission check already account for this borrow.\n+                            debug!(\"borrow_conflicts_with_place: behind a shared ref\");\n+                            return false;\n+                        }\n+\n+                        (ProjectionElem::Deref, _, Deep) |\n+                        (ProjectionElem::Field { .. }, _, _) |\n+                        (ProjectionElem::Index { ..}, _, _) |\n+                        (ProjectionElem::ConstantIndex { .. }, _, _) |\n+                        (ProjectionElem::Subslice { .. }, _, _) |\n+                        (ProjectionElem::Downcast { .. }, _, _) => {\n+                            // Recursive case. This can still be disjoint on a\n+                            // further iteration if this a shallow access and\n+                            // there's a deref later on, e.g. a borrow\n+                            // of `*x.y` while accessing `x`.\n+                        }\n+                    }\n+                }\n+                (Some(borrow_c), Some(access_c)) => {\n+                    match self.place_element_conflict(&borrow_c, access_c) {\n+                        Overlap::Arbitrary => {\n+                            // We have encountered different fields of potentially\n+                            // the same union - the borrow now partially overlaps.\n+                            //\n+                            // There is no *easy* way of comparing the fields\n+                            // further on, because they might have different types\n+                            // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n+                            // `.y` come from different structs).\n+                            //\n+                            // We could try to do some things here - e.g. count\n+                            // dereferences - but that's probably not a good\n+                            // idea, at least for now, so just give up and\n+                            // report a conflict. This is unsafe code anyway so\n+                            // the user could always use raw pointers.\n+                            debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n+                            return true;\n+                        }\n+                        Overlap::EqualOrDisjoint => {\n+                            // This is the recursive case - proceed to the next element.\n+                        }\n+                        Overlap::Disjoint => {\n+                            // We have proven the borrow disjoint - further\n+                            // projections will remain disjoint.\n+                            debug!(\"borrow_conflicts_with_place: disjoint\");\n+                            return false;\n+                        }\n+                    }\n+\n+                }\n+            }\n+        }\n+        unreachable!(\"iter::repeat returned None\")\n+    }\n+\n     fn each_borrow_involving_path<F>(\n         &mut self,\n         _context: Context,\n         access_place: (ShallowOrDeep, &Place<'tcx>),\n         flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n         mut op: F,\n     ) where\n-        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Place<'tcx>) -> Control,\n+        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,\n     {\n         let (access, place) = access_place;\n \n@@ -1501,47 +1894,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         'next_borrow: for i in flow_state.borrows.elems_incoming() {\n             let borrowed = &data[i];\n \n-            // Is `place` (or a prefix of it) already borrowed? If\n-            // so, that's relevant.\n-            //\n-            // FIXME: Differs from AST-borrowck; includes drive-by fix\n-            // to #38899. Will probably need back-compat mode flag.\n-            for accessed_prefix in self.prefixes(place, PrefixSet::All) {\n-                if *accessed_prefix == borrowed.place {\n-                    // FIXME: pass in enum describing case we are in?\n-                    let ctrl = op(self, i, borrowed, accessed_prefix);\n-                    if ctrl == Control::Break {\n-                        return;\n-                    }\n-                }\n-            }\n-\n-            // Is `place` a prefix (modulo access type) of the\n-            // `borrowed.place`? If so, that's relevant.\n-\n-            let prefix_kind = match access {\n-                Shallow(Some(ArtificialField::Discriminant)) |\n-                Shallow(Some(ArtificialField::ArrayLength)) => {\n-                    // The discriminant and array length are like\n-                    // additional fields on the type; they do not\n-                    // overlap any existing data there. Furthermore,\n-                    // they cannot actually be a prefix of any\n-                    // borrowed place (at least in MIR as it is\n-                    // currently.)\n-                    continue 'next_borrow;\n-                }\n-                Shallow(None) => PrefixSet::Shallow,\n-                Deep => PrefixSet::Supporting,\n-            };\n-\n-            for borrowed_prefix in self.prefixes(&borrowed.place, prefix_kind) {\n-                if borrowed_prefix == place {\n-                    // FIXME: pass in enum describing case we are in?\n-                    let ctrl = op(self, i, borrowed, borrowed_prefix);\n-                    if ctrl == Control::Break {\n-                        return;\n-                    }\n-                }\n+            if self.borrow_conflicts_with_place(borrowed, place, access) {\n+                let ctrl = op(self, i, borrowed);\n+                if ctrl == Control::Break { return; }\n             }\n         }\n     }\n@@ -1595,6 +1950,7 @@ mod prefixes {\n     }\n \n     #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+    #[allow(dead_code)]\n     pub(super) enum PrefixSet {\n         /// Doesn't stop until it returns the base case (a Local or\n         /// Static prefix).\n@@ -1626,10 +1982,7 @@ mod prefixes {\n     impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n         type Item = &'cx Place<'tcx>;\n         fn next(&mut self) -> Option<Self::Item> {\n-            let mut cursor = match self.next {\n-                None => return None,\n-                Some(place) => place,\n-            };\n+            let mut cursor = self.next?;\n \n             // Post-processing `place`: Enqueue any remaining\n             // work. Also, `place` may not be a prefix itself, but\n@@ -1907,17 +2260,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_conflicting_borrow(\n         &mut self,\n         context: Context,\n-        common_prefix: &Place<'tcx>,\n         (place, span): (&Place<'tcx>, Span),\n         gen_borrow_kind: BorrowKind,\n         issued_borrow: &BorrowData,\n         end_issued_loan_span: Option<Span>,\n     ) {\n-        use self::prefixes::IsPrefixOf;\n-\n-        assert!(common_prefix.is_prefix_of(place));\n-        assert!(common_prefix.is_prefix_of(&issued_borrow.place));\n-\n         let issued_span = self.retrieve_borrow_span(issued_borrow);\n \n         let new_closure_span = self.find_closure_span(span, context.loc);\n@@ -1984,12 +2331,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Origin::Mir,\n             ),\n \n-            (_, _, _, BorrowKind::Unique, _, _) => self.tcx\n+            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => self.tcx\n                 .cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,\n-                    \"it\",\n                     \"\",\n+                    lft,\n+                    issued_span,\n+                    \"\",\n+                    end_issued_loan_span,\n+                    Origin::Mir,\n+                ),\n+\n+            (BorrowKind::Mut, _, lft, BorrowKind::Unique, _, _) => self.tcx\n+                .cannot_reborrow_already_uniquely_borrowed(\n+                    span,\n+                    &desc_place,\n+                    \"\",\n+                    lft,\n                     issued_span,\n                     \"\",\n                     end_issued_loan_span,\n@@ -2373,8 +2732,10 @@ impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n         xform_move_outs(&mut self.move_outs);\n         xform_ever_inits(&mut self.ever_inits);\n     }\n+}\n \n-    fn summary(&self) -> String {\n+impl<'b, 'gcx, 'tcx> fmt::Display for InProgress<'b, 'gcx, 'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut s = String::new();\n \n         s.push_str(\"borrows in effect: [\");\n@@ -2451,7 +2812,7 @@ impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n         });\n         s.push_str(\"]\");\n \n-        return s;\n+        fmt::Display::fmt(&s, fmt)\n     }\n }\n "}, {"sha": "4ff299efb95558f26dc24f86e7eebf0710be94ab", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 125, "deletions": 22, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -9,11 +9,12 @@\n // except according to those terms.\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::Mir;\n+use rustc::mir::{ClosureRegionRequirements, Mir};\n use rustc::infer::InferCtxt;\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n use std::collections::BTreeSet;\n+use std::io;\n use transform::MirSource;\n use transform::type_check;\n use util::liveness::{self, LivenessMode, LivenessResult, LocalSet};\n@@ -22,6 +23,7 @@ use dataflow::MaybeInitializedLvals;\n use dataflow::move_paths::MoveData;\n \n use util as mir_util;\n+use util::pretty::{self, ALIGN};\n use self::mir_util::PassWhere;\n \n mod constraint_generation;\n@@ -35,20 +37,26 @@ use self::region_infer::RegionInferenceContext;\n mod renumber;\n \n /// Rewrites the regions in the MIR to use NLL variables, also\n-/// scraping out the set of free regions (e.g., region parameters)\n+/// scraping out the set of universal regions (e.g., region parameters)\n /// declared on the function. That set will need to be given to\n /// `compute_regions`.\n pub(in borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     def_id: DefId,\n+    param_env: ty::ParamEnv<'tcx>,\n     mir: &mut Mir<'tcx>,\n ) -> UniversalRegions<'tcx> {\n-    // Compute named region information.\n-    let universal_regions = universal_regions::universal_regions(infcx, def_id);\n+    debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n-    // Replace all regions with fresh inference variables.\n+    // Compute named region information. This also renumbers the inputs/outputs.\n+    let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n+\n+    // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, &universal_regions, mir);\n \n+    let source = MirSource::item(def_id);\n+    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, mir, |_, _| Ok(()));\n+\n     universal_regions\n }\n \n@@ -63,21 +71,19 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n-) -> RegionInferenceContext<'tcx> {\n+) -> (\n+    RegionInferenceContext<'tcx>,\n+    Option<ClosureRegionRequirements>,\n+) {\n     // Run the MIR type-checker.\n     let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let constraint_sets = &type_check::type_check(infcx, mir_node_id, param_env, mir);\n \n     // Create the region inference context, taking ownership of the region inference\n     // data that was contained in `infcx`.\n     let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, &universal_regions, mir);\n-    subtype_constraint_generation::generate(\n-        &mut regioncx,\n-        &universal_regions,\n-        mir,\n-        constraint_sets,\n-    );\n+    let mut regioncx = RegionInferenceContext::new(var_origins, universal_regions, mir);\n+    subtype_constraint_generation::generate(&mut regioncx, mir, constraint_sets);\n \n     // Compute what is live where.\n     let liveness = &LivenessResults {\n@@ -110,13 +116,24 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     );\n \n     // Solve the region constraints.\n-    regioncx.solve(infcx, &mir);\n+    let closure_region_requirements = regioncx.solve(infcx, &mir, def_id);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n-    // write unit-tests.\n-    dump_mir_results(infcx, liveness, MirSource::item(def_id), &mir, &regioncx);\n+    // write unit-tests, as well as helping with debugging.\n+    dump_mir_results(\n+        infcx,\n+        liveness,\n+        MirSource::item(def_id),\n+        &mir,\n+        &regioncx,\n+        &closure_region_requirements,\n+    );\n \n-    regioncx\n+    // We also have a `#[rustc_nll]` annotation that causes us to dump\n+    // information\n+    dump_annotation(infcx, &mir, def_id, &regioncx, &closure_region_requirements);\n+\n+    (regioncx, closure_region_requirements)\n }\n \n struct LivenessResults {\n@@ -130,6 +147,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     regioncx: &RegionInferenceContext,\n+    closure_region_requirements: &Option<ClosureRegionRequirements>,\n ) {\n     if !mir_util::dump_enabled(infcx.tcx, \"nll\", source) {\n         return;\n@@ -164,9 +182,17 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n     mir_util::dump_mir(infcx.tcx, None, \"nll\", &0, source, mir, |pass_where, out| {\n         match pass_where {\n             // Before the CFG, dump out the values for each region variable.\n-            PassWhere::BeforeCFG => for region in regioncx.regions() {\n-                writeln!(out, \"| {:?}: {}\", region, regioncx.region_value_str(region))?;\n-            },\n+            PassWhere::BeforeCFG => {\n+                regioncx.dump_mir(out)?;\n+\n+                if let Some(closure_region_requirements) = closure_region_requirements {\n+                    writeln!(out, \"|\")?;\n+                    writeln!(out, \"| Free Region Constraints\")?;\n+                    for_each_region_constraint(closure_region_requirements, &mut |msg| {\n+                        writeln!(out, \"| {}\", msg)\n+                    })?;\n+                }\n+            }\n \n             // Before each basic block, dump out the values\n             // that are live on entry to the basic block.\n@@ -180,19 +206,96 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n                     &regular_liveness_per_location[&location],\n                     &drop_liveness_per_location[&location],\n                 );\n-                writeln!(out, \"            | Live variables at {:?}: {}\", location, s)?;\n+                writeln!(\n+                    out,\n+                    \"{:ALIGN$} | Live variables on entry to {:?}: {}\",\n+                    \"\",\n+                    location,\n+                    s,\n+                    ALIGN = ALIGN\n+                )?;\n             }\n \n             PassWhere::AfterLocation(_) | PassWhere::AfterCFG => {}\n         }\n         Ok(())\n     });\n+\n+    // Also dump the inference graph constraints as a graphviz file.\n+    let _: io::Result<()> = do catch {\n+        let mut file =\n+            pretty::create_dump_file(infcx.tcx, \"regioncx.dot\", None, \"nll\", &0, source)?;\n+        regioncx.dump_graphviz(&mut file)\n+    };\n+}\n+\n+fn dump_annotation<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    mir_def_id: DefId,\n+    regioncx: &RegionInferenceContext,\n+    closure_region_requirements: &Option<ClosureRegionRequirements>,\n+) {\n+    let tcx = infcx.tcx;\n+    let base_def_id = tcx.closure_base_def_id(mir_def_id);\n+    if !tcx.has_attr(base_def_id, \"rustc_regions\") {\n+        return;\n+    }\n+\n+    // When the enclosing function is tagged with `#[rustc_regions]`,\n+    // we dump out various bits of state as warnings. This is useful\n+    // for verifying that the compiler is behaving as expected.  These\n+    // warnings focus on the closure region requirements -- for\n+    // viewing the intraprocedural state, the -Zdump-mir output is\n+    // better.\n+\n+    if let Some(closure_region_requirements) = closure_region_requirements {\n+        let mut err = tcx.sess\n+            .diagnostic()\n+            .span_note_diag(mir.span, \"External requirements\");\n+\n+        regioncx.annotate(&mut err);\n+\n+        err.note(&format!(\n+            \"number of external vids: {}\",\n+            closure_region_requirements.num_external_vids\n+        ));\n+\n+        // Dump the region constraints we are imposing *between* those\n+        // newly created variables.\n+        for_each_region_constraint(closure_region_requirements, &mut |msg| {\n+            err.note(msg);\n+            Ok(())\n+        }).unwrap();\n+\n+        err.emit();\n+    } else {\n+        let mut err = tcx.sess\n+            .diagnostic()\n+            .span_note_diag(mir.span, \"No external requirements\");\n+        regioncx.annotate(&mut err);\n+        err.emit();\n+    }\n+}\n+\n+fn for_each_region_constraint(\n+    closure_region_requirements: &ClosureRegionRequirements,\n+    with_msg: &mut FnMut(&str) -> io::Result<()>,\n+) -> io::Result<()> {\n+    for req in &closure_region_requirements.outlives_requirements {\n+        with_msg(&format!(\n+            \"where {:?}: {:?}\",\n+            req.free_region,\n+            req.outlived_free_region,\n+        ))?;\n+    }\n+    Ok(())\n }\n \n /// Right now, we piggy back on the `ReVar` to store our NLL inference\n /// regions. These are indexed with `RegionVid`. This method will\n /// assert that the region is a `ReVar` and extract its interal index.\n-/// This is reasonable because in our MIR we replace all free regions\n+/// This is reasonable because in our MIR we replace all universal regions\n /// with inference variables.\n pub trait ToRegionVid {\n     fn to_region_vid(&self) -> RegionVid;"}, {"sha": "906efaef887c38c54131781c3c726a55c09e98db", "filename": "src/librustc_mir/borrow_check/nll/region_infer/annotation.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! As part of the NLL unit tests, you can annotate a function with\n+//! `#[rustc_regions]`, and we will emit information about the region\n+//! inference context and -- in particular -- the external constraints\n+//! that this region imposes on others. The methods in this file\n+//! handle the part about dumping the inference context internal\n+//! state.\n+\n+use rustc::ty;\n+use rustc_errors::DiagnosticBuilder;\n+use super::RegionInferenceContext;\n+\n+impl<'gcx, 'tcx> RegionInferenceContext<'tcx> {\n+    /// Write out our state into the `.mir` files.\n+    pub(crate) fn annotate(&self, err: &mut DiagnosticBuilder<'_>) {\n+        match self.universal_regions.defining_ty.sty {\n+            ty::TyClosure(def_id, substs) => {\n+                err.note(&format!(\n+                    \"defining type: {:?} with closure substs {:#?}\",\n+                    def_id,\n+                    &substs.substs[..]\n+                ));\n+            }\n+            ty::TyFnDef(def_id, substs) => {\n+                err.note(&format!(\n+                    \"defining type: {:?} with substs {:#?}\",\n+                    def_id,\n+                    &substs[..]\n+                ));\n+            }\n+            _ => {\n+                err.note(&format!(\n+                    \"defining type: {:?}\",\n+                    self.universal_regions.defining_ty\n+                ));\n+            }\n+        }\n+    }\n+}"}, {"sha": "5477308bde948e7904862ce9bc22341015c2cdab", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! As part of generating the regions, if you enable `-Zdump-mir=nll`,\n+//! we will generate an annotated copy of the MIR that includes the\n+//! state of region inference. This code handles emitting the region\n+//! context internal state.\n+\n+use std::io::{self, Write};\n+use super::{Constraint, RegionInferenceContext};\n+\n+// Room for \"'_#NNNNr\" before things get misaligned.\n+// Easy enough to fix if this ever doesn't seem like\n+// enough.\n+const REGION_WIDTH: usize = 8;\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Write out our state into the `.mir` files.\n+    pub(crate) fn dump_mir(&self, out: &mut Write) -> io::Result<()> {\n+        writeln!(out, \"| Free Region Mapping\")?;\n+\n+        for region in self.regions() {\n+            if self.definitions[region].is_universal {\n+                let classification = self.universal_regions.region_classification(region).unwrap();\n+                let outlived_by = self.universal_regions.regions_outlived_by(region);\n+                writeln!(\n+                    out,\n+                    \"| {r:rw$} | {c:cw$} | {ob}\",\n+                    r = format!(\"{:?}\", region),\n+                    rw = REGION_WIDTH,\n+                    c = format!(\"{:?}\", classification),\n+                    cw = 8, // \"External\" at most\n+                    ob = format!(\"{:?}\", outlived_by)\n+                )?;\n+            }\n+        }\n+\n+        writeln!(out, \"|\")?;\n+        writeln!(out, \"| Inferred Region Values\")?;\n+        for region in self.regions() {\n+            writeln!(\n+                out,\n+                \"| {r:rw$} | {v}\",\n+                r = format!(\"{:?}\", region),\n+                rw = REGION_WIDTH,\n+                v = self.region_value_str(region),\n+            )?;\n+        }\n+\n+        writeln!(out, \"|\")?;\n+        writeln!(out, \"| Inference Constraints\")?;\n+        self.for_each_constraint(&mut |msg| writeln!(out, \"| {}\", msg))?;\n+\n+        Ok(())\n+    }\n+\n+    /// Debugging aid: Invokes the `with_msg` callback repeatedly with\n+    /// our internal region constraints.  These are dumped into the\n+    /// -Zdump-mir file so that we can figure out why the region\n+    /// inference resulted in the values that it did when debugging.\n+    fn for_each_constraint(\n+        &self,\n+        with_msg: &mut FnMut(&str) -> io::Result<()>,\n+    ) -> io::Result<()> {\n+        for region in self.definitions.indices() {\n+            let value = self.region_value_str_from_matrix(&self.liveness_constraints, region);\n+            if value != \"{}\" {\n+                with_msg(&format!(\"{:?} live at {}\", region, value))?;\n+            }\n+        }\n+\n+        let mut constraints: Vec<_> = self.constraints.iter().collect();\n+        constraints.sort();\n+        for constraint in &constraints {\n+            let Constraint {\n+                sup,\n+                sub,\n+                point,\n+                span,\n+            } = constraint;\n+            with_msg(&format!(\n+                \"{:?}: {:?} @ {:?} due to {:?}\",\n+                sup,\n+                sub,\n+                point,\n+                span\n+            ))?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+"}, {"sha": "7923b159d80dc44ffed9f54a29035f7459d3fb53", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module provides linkage between RegionInferenceContext and\n+//! libgraphviz traits, specialized to attaching borrowck analysis\n+//! data to rendered labels.\n+\n+use dot::{self, IntoCow};\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::borrow::Cow;\n+use std::io::{self, Write};\n+use super::*;\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Write out the region constraint graph.\n+    pub(crate) fn dump_graphviz(&self, mut w: &mut Write) -> io::Result<()> {\n+        dot::render(self, &mut w)\n+    }\n+}\n+\n+impl<'this, 'tcx> dot::Labeller<'this> for RegionInferenceContext<'tcx> {\n+    type Node = RegionVid;\n+    type Edge = Constraint;\n+\n+    fn graph_id(&'this self) -> dot::Id<'this> {\n+        dot::Id::new(format!(\"RegionInferenceContext\")).unwrap()\n+    }\n+    fn node_id(&'this self, n: &RegionVid) -> dot::Id<'this> {\n+        dot::Id::new(format!(\"r{}\", n.index())).unwrap()\n+    }\n+    fn node_shape(&'this self, _node: &RegionVid) -> Option<dot::LabelText<'this>> {\n+        Some(dot::LabelText::LabelStr(Cow::Borrowed(\"box\")))\n+    }\n+    fn node_label(&'this self, n: &RegionVid) -> dot::LabelText<'this> {\n+        dot::LabelText::LabelStr(format!(\"{:?}\", n).into_cow())\n+    }\n+    fn edge_label(&'this self, e: &Constraint) -> dot::LabelText<'this> {\n+        dot::LabelText::LabelStr(format!(\"{:?}\", e.point).into_cow())\n+    }\n+}\n+\n+impl<'this, 'tcx> dot::GraphWalk<'this> for RegionInferenceContext<'tcx> {\n+    type Node = RegionVid;\n+    type Edge = Constraint;\n+\n+    fn nodes(&'this self) -> dot::Nodes<'this, RegionVid> {\n+        let vids: Vec<RegionVid> = self.definitions.indices().collect();\n+        vids.into_cow()\n+    }\n+    fn edges(&'this self) -> dot::Edges<'this, Constraint> {\n+        (&self.constraints[..]).into_cow()\n+    }\n+\n+    // Render `a: b` as `a <- b`, indicating the flow\n+    // of data during inference.\n+\n+    fn source(&'this self, edge: &Constraint) -> RegionVid {\n+        edge.sub\n+    }\n+\n+    fn target(&'this self, edge: &Constraint) -> RegionVid {\n+        edge.sup\n+    }\n+}"}, {"sha": "b2e2ccc5d0b720d889fa3598b02d87627d8e66b3", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 239, "deletions": 66, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -9,12 +9,13 @@\n // except according to those terms.\n \n use super::universal_regions::UniversalRegions;\n+use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::infer::RegionVariableOrigin;\n use rustc::infer::NLLRegionVariableOrigin;\n+use rustc::infer::RegionVariableOrigin;\n+use rustc::infer::SubregionOrigin;\n use rustc::infer::region_constraints::VarOrigins;\n-use rustc::infer::outlives::free_region_map::FreeRegionMap;\n-use rustc::mir::{Location, Mir};\n+use rustc::mir::{ClosureOutlivesRequirement, ClosureRegionRequirements, Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n@@ -24,6 +25,10 @@ use std::collections::BTreeMap;\n use std::fmt;\n use syntax_pos::Span;\n \n+mod annotation;\n+mod dump_mir;\n+mod graphviz;\n+\n pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable.  Region\n     /// variables are identified by their index (`RegionVid`). The\n@@ -52,12 +57,9 @@ pub struct RegionInferenceContext<'tcx> {\n     /// the free regions.)\n     point_indices: BTreeMap<Location, usize>,\n \n-    /// Number of universally quantified regions. This is used to\n-    /// determine the meaning of the bits in `inferred_values` and\n-    /// friends.\n-    num_universal_regions: usize,\n-\n-    free_region_map: &'tcx FreeRegionMap<'tcx>,\n+    /// Information about the universally quantified regions in scope\n+    /// on this function and their (known) relations to one another.\n+    universal_regions: UniversalRegions<'tcx>,\n }\n \n struct RegionDefinition<'tcx> {\n@@ -67,9 +69,15 @@ struct RegionDefinition<'tcx> {\n     /// late-bound-regions).\n     origin: RegionVariableOrigin,\n \n-    /// If this is a free-region, then this is `Some(X)` where `X` is\n-    /// the name of the region.\n-    name: Option<ty::Region<'tcx>>,\n+    /// True if this is a universally quantified region. This means a\n+    /// lifetime parameter that appears in the function signature (or,\n+    /// in the case of a closure, in the closure environment, which of\n+    /// course is also in the function signature).\n+    is_universal: bool,\n+\n+    /// If this is 'static or an early-bound region, then this is\n+    /// `Some(X)` where `X` is the name of the region.\n+    external_name: Option<ty::Region<'tcx>>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -98,11 +106,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// regions defined in `universal_regions`.\n     pub fn new(\n         var_origins: VarOrigins,\n-        universal_regions: &UniversalRegions<'tcx>,\n+        universal_regions: UniversalRegions<'tcx>,\n         mir: &Mir<'tcx>,\n     ) -> Self {\n         let num_region_variables = var_origins.len();\n-        let num_universal_regions = universal_regions.indices.len();\n+        let num_universal_regions = universal_regions.len();\n \n         let mut num_points = 0;\n         let mut point_indices = BTreeMap::new();\n@@ -133,11 +141,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             inferred_values: None,\n             constraints: Vec::new(),\n             point_indices,\n-            num_universal_regions,\n-            free_region_map: universal_regions.free_region_map,\n+            universal_regions,\n         };\n \n-        result.init_universal_regions(universal_regions);\n+        result.init_universal_regions();\n \n         result\n     }\n@@ -159,25 +166,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///     R1 = { CFG, R0, R1 } // 'b\n     ///\n     /// Here, R0 represents `'a`, and it contains (a) the entire CFG\n-    /// and (b) any free regions that it outlives, which in this case\n-    /// is just itself. R1 (`'b`) in contrast also outlives `'a` and\n-    /// hence contains R0 and R1.\n-    fn init_universal_regions(&mut self, universal_regions: &UniversalRegions<'tcx>) {\n-        let UniversalRegions {\n-            indices,\n-            free_region_map: _,\n-        } = universal_regions;\n+    /// and (b) any universally quantified regions that it outlives,\n+    /// which in this case is just itself. R1 (`'b`) in contrast also\n+    /// outlives `'a` and hence contains R0 and R1.\n+    fn init_universal_regions(&mut self) {\n+        // Update the names (if any)\n+        for (external_name, variable) in self.universal_regions.named_universal_regions() {\n+            self.definitions[variable].external_name = Some(external_name);\n+        }\n \n         // For each universally quantified region X:\n-        for (free_region, &variable) in indices {\n+        for variable in self.universal_regions.universal_regions() {\n             // These should be free-region variables.\n             assert!(match self.definitions[variable].origin {\n                 RegionVariableOrigin::NLL(NLLRegionVariableOrigin::FreeRegion) => true,\n                 _ => false,\n             });\n \n-            // Initialize the name and a few other details.\n-            self.definitions[variable].name = Some(free_region);\n+            self.definitions[variable].is_universal = true;\n \n             // Add all nodes in the CFG to liveness constraints\n             for (_location, point_index) in &self.point_indices {\n@@ -196,6 +202,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.definitions.indices()\n     }\n \n+    /// Given a universal region in scope on the MIR, returns the\n+    /// corresponding index.\n+    ///\n+    /// (Panics if `r` is not a registered universal region.)\n+    pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n+        self.universal_regions.to_region_vid(r)\n+    }\n+\n     /// Returns true if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n@@ -237,19 +251,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n \n+        self.region_value_str_from_matrix(inferred_values, r)\n+    }\n+\n+    fn region_value_str_from_matrix(&self,\n+                                    matrix: &BitMatrix,\n+                                    r: RegionVid) -> String {\n         let mut result = String::new();\n         result.push_str(\"{\");\n         let mut sep = \"\";\n \n         for &point in self.point_indices.keys() {\n-            if self.region_contains_point_in_matrix(inferred_values, r, point) {\n+            if self.region_contains_point_in_matrix(matrix, r, point) {\n                 result.push_str(&format!(\"{}{:?}\", sep, point));\n                 sep = \", \";\n             }\n         }\n \n-        for fr in (0..self.num_universal_regions).map(RegionVid::new) {\n-            if self.region_contains_region_in_matrix(inferred_values, r, fr) {\n+        for fr in (0..self.universal_regions.len()).map(RegionVid::new) {\n+            if self.region_contains_region_in_matrix(matrix, r, fr) {\n                 result.push_str(&format!(\"{}{:?}\", sep, fr));\n                 sep = \", \";\n             }\n@@ -289,8 +309,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Perform region inference.\n-    pub(super) fn solve(&mut self, infcx: &InferCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) {\n+    pub(super) fn solve(\n+        &mut self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n+    ) -> Option<ClosureRegionRequirements> {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n+        let tcx = infcx.tcx;\n \n         // Find the minimal regions that can solve the constraints. This is infallible.\n         self.propagate_constraints(mir);\n@@ -310,57 +336,135 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // The universal regions are always found in a prefix of the\n         // full list.\n-        let free_region_definitions = self.definitions\n+        let universal_definitions = self.definitions\n             .iter_enumerated()\n-            .take_while(|(_, fr_definition)| fr_definition.name.is_some());\n+            .take_while(|(_, fr_definition)| fr_definition.is_universal);\n+\n+        // Go through each of the universal regions `fr` and check that\n+        // they did not grow too large, accumulating any requirements\n+        // for our caller into the `outlives_requirements` vector.\n+        let mut outlives_requirements = vec![];\n+        for (fr, _) in universal_definitions {\n+            self.check_universal_region(infcx, fr, &mut outlives_requirements);\n+        }\n \n-        for (fr, fr_definition) in free_region_definitions {\n-            self.check_free_region(infcx, fr, fr_definition);\n+        // If this is not a closure, then there is no caller to which we can\n+        // \"pass the buck\". So if there are any outlives-requirements that were\n+        // not satisfied, we just have to report a hard error here.\n+        if !tcx.is_closure(mir_def_id) {\n+            for outlives_requirement in outlives_requirements {\n+                self.report_error(\n+                    infcx,\n+                    outlives_requirement.free_region,\n+                    outlives_requirement.outlived_free_region,\n+                    outlives_requirement.blame_span,\n+                );\n+            }\n+            return None;\n         }\n+\n+        let num_external_vids = self.universal_regions.num_global_and_external_regions();\n+\n+        Some(ClosureRegionRequirements {\n+            num_external_vids,\n+            outlives_requirements,\n+        })\n     }\n \n-    fn check_free_region(\n+    /// Check the final value for the free region `fr` to see if it\n+    /// grew too large. In particular, examine what `end(X)` points\n+    /// wound up in `fr`'s final value; for each `end(X)` where `X !=\n+    /// fr`, we want to check that `fr: X`. If not, that's either an\n+    /// error, or something we have to propagate to our creator.\n+    ///\n+    /// Things that are to be propagated are accumulated into the\n+    /// `outlives_requirements` vector.\n+    fn check_universal_region(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         longer_fr: RegionVid,\n-        longer_definition: &RegionDefinition<'tcx>,\n+        outlives_requirements: &mut Vec<ClosureOutlivesRequirement>,\n     ) {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n-        let longer_name = longer_definition.name.unwrap();\n         let longer_value = inferred_values.iter(longer_fr.index());\n \n-        // Find every region `shorter` such that `longer: shorter`\n-        // (because `longer` includes `end(shorter)`).\n-        for shorter_fr in longer_value.take_while(|&i| i < self.num_universal_regions) {\n-            let shorter_fr = RegionVid::new(shorter_fr);\n+        debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n-            // `fr` includes `end(fr)`, that's not especially\n-            // interesting.\n-            if longer_fr == shorter_fr {\n+        // Find every region `o` such that `fr: o`\n+        // (because `fr` includes `end(o)`).\n+        let shorter_frs = longer_value\n+            .take_while(|&i| i < self.universal_regions.len())\n+            .map(RegionVid::new);\n+        for shorter_fr in shorter_frs {\n+            // If it is known that `fr: o`, carry on.\n+            if self.universal_regions.outlives(longer_fr, shorter_fr) {\n                 continue;\n             }\n \n-            let shorter_definition = &self.definitions[shorter_fr];\n-            let shorter_name = shorter_definition.name.unwrap();\n-\n-            // Check that `o <= fr`. If not, report an error.\n-            if !self.free_region_map\n-                .sub_free_regions(shorter_name, longer_name)\n-            {\n-                // FIXME: worst error msg ever\n-                let blame_span = self.blame_span(longer_fr, shorter_fr);\n-                infcx.tcx.sess.span_err(\n-                    blame_span,\n-                    &format!(\n-                        \"free region `{}` does not outlive `{}`\",\n-                        longer_name,\n-                        shorter_name\n-                    ),\n+            debug!(\n+                \"check_universal_region: fr={:?} does not outlive shorter_fr={:?}\",\n+                longer_fr,\n+                shorter_fr,\n+            );\n+\n+            let blame_span = self.blame_span(longer_fr, shorter_fr);\n+\n+            // Shrink `fr` until we find a non-local region (if we do).\n+            // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n+            if let Some(fr_minus) = self.universal_regions.non_local_lower_bound(longer_fr) {\n+                debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n+\n+                // Grow `shorter_fr` until we find a non-local\n+                // regon. (We always will.)  We'll call that\n+                // `shorter_fr+` -- it's ever so slightly larger than\n+                // `fr`.\n+                let shorter_fr_plus = self.universal_regions.non_local_upper_bound(shorter_fr);\n+                debug!(\n+                    \"check_universal_region: shorter_fr_plus={:?}\",\n+                    shorter_fr_plus\n                 );\n+\n+                // Push the constraint `fr-: shorter_fr+`\n+                outlives_requirements.push(ClosureOutlivesRequirement {\n+                    free_region: fr_minus,\n+                    outlived_free_region: shorter_fr_plus,\n+                    blame_span: blame_span,\n+                });\n+                return;\n             }\n+\n+            // If we could not shrink `fr` to something smaller that\n+            // the external users care about, then we can't pass the\n+            // buck; just report an error.\n+            self.report_error(infcx, longer_fr, shorter_fr, blame_span);\n         }\n     }\n \n+    fn report_error(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        fr: RegionVid,\n+        outlived_fr: RegionVid,\n+        blame_span: Span,\n+    ) {\n+        // Obviously uncool error reporting.\n+\n+        let fr_string = match self.definitions[fr].external_name {\n+            Some(r) => format!(\"free region `{}`\", r),\n+            None => format!(\"free region `{:?}`\", fr),\n+        };\n+\n+        let outlived_fr_string = match self.definitions[outlived_fr].external_name {\n+            Some(r) => format!(\"free region `{}`\", r),\n+            None => format!(\"free region `{:?}`\", outlived_fr),\n+        };\n+\n+        infcx.tcx.sess.span_err(\n+            blame_span,\n+            &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n+        );\n+    }\n+\n     /// Propagate the region constraints: this will grow the values\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n@@ -421,8 +525,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         stack.push(start_point);\n         while let Some(p) = stack.pop() {\n-            debug!(\"        copy: p={:?}\", p);\n-\n             if !self.region_contains_point_in_matrix(inferred_values, from_region, p) {\n                 debug!(\"            not in from-region\");\n                 continue;\n@@ -464,7 +566,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // and make sure they are included in the `to_region`.\n                 let universal_region_indices = inferred_values\n                     .iter(from_region.index())\n-                    .take_while(|&i| i < self.num_universal_regions)\n+                    .take_while(|&i| i < self.universal_regions.len())\n                     .collect::<Vec<_>>();\n                 for fr in &universal_region_indices {\n                     changed |= inferred_values.add(to_region.index(), *fr);\n@@ -535,7 +637,11 @@ impl<'tcx> RegionDefinition<'tcx> {\n         // Create a new region definition. Note that, for free\n         // regions, these fields get updated later in\n         // `init_universal_regions`.\n-        Self { origin, name: None }\n+        Self {\n+            origin,\n+            is_universal: false,\n+            external_name: None,\n+        }\n     }\n }\n \n@@ -551,3 +657,70 @@ impl fmt::Debug for Constraint {\n         )\n     }\n }\n+\n+pub trait ClosureRegionRequirementsExt {\n+    fn apply_requirements<'tcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        location: Location,\n+        closure_def_id: DefId,\n+        closure_substs: ty::ClosureSubsts<'tcx>,\n+    );\n+}\n+\n+impl ClosureRegionRequirementsExt for ClosureRegionRequirements {\n+    /// Given an instance T of the closure type, this method\n+    /// instantiates the \"extra\" requirements that we computed for the\n+    /// closure into the inference context. This has the effect of\n+    /// adding new subregion obligations to existing variables.\n+    ///\n+    /// As described on `ClosureRegionRequirements`, the extra\n+    /// requirements are expressed in terms of regionvids that index\n+    /// into the free regions that appear on the closure type. So, to\n+    /// do this, we first copy those regions out from the type T into\n+    /// a vector. Then we can just index into that vector to extract\n+    /// out the corresponding region from T and apply the\n+    /// requirements.\n+    fn apply_requirements<'tcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        location: Location,\n+        closure_def_id: DefId,\n+        closure_substs: ty::ClosureSubsts<'tcx>,\n+    ) {\n+        let tcx = infcx.tcx;\n+\n+        debug!(\n+            \"apply_requirements(location={:?}, closure_def_id={:?}, closure_substs={:?})\",\n+            location,\n+            closure_def_id,\n+            closure_substs\n+        );\n+\n+        // Get Tu.\n+        let user_closure_ty = tcx.mk_closure(closure_def_id, closure_substs);\n+        debug!(\"apply_requirements: user_closure_ty={:?}\", user_closure_ty);\n+\n+        // Extract the values of the free regions in `user_closure_ty`\n+        // into a vector.  These are the regions that we will be\n+        // relating to one another.\n+        let closure_mapping =\n+            UniversalRegions::closure_mapping(infcx, user_closure_ty, self.num_external_vids);\n+        debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n+\n+        // Create the predicates.\n+        for outlives_requirement in &self.outlives_requirements {\n+            let region = closure_mapping[outlives_requirement.free_region];\n+            let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n+            debug!(\n+                \"apply_requirements: region={:?} outlived_region={:?} outlives_requirements={:?}\",\n+                region,\n+                outlived_region,\n+                outlives_requirement\n+            );\n+            // FIXME, this origin is not entirely suitable.\n+            let origin = SubregionOrigin::CallRcvr(outlives_requirement.blame_span);\n+            infcx.sub_regions(origin, outlived_region, region);\n+        }\n+    }\n+}"}, {"sha": "1262c238a132cee55492a3b281fdc8b38c22784e", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, ClosureSubsts, RegionVid, Ty, TypeFoldable};\n+use rustc::ty::{self, ClosureSubsts, Ty, TypeFoldable};\n use rustc::mir::{BasicBlock, Local, Location, Mir, Statement, StatementKind};\n+use rustc::mir::RETURN_PLACE;\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n@@ -25,34 +26,31 @@ pub fn renumber_mir<'a, 'gcx, 'tcx>(\n     universal_regions: &UniversalRegions<'tcx>,\n     mir: &mut Mir<'tcx>,\n ) {\n-    // Create inference variables for each of the free regions\n-    // declared on the function signature.\n-    let free_region_inference_vars = (0..universal_regions.indices.len())\n-        .map(RegionVid::new)\n-        .map(|vid_expected| {\n-            let r = infcx.next_nll_region_var(NLLRegionVariableOrigin::FreeRegion);\n-            assert_eq!(vid_expected, r.to_region_vid());\n-            r\n-        })\n-        .collect();\n-\n     debug!(\"renumber_mir()\");\n-    debug!(\"renumber_mir: universal_regions={:#?}\", universal_regions);\n     debug!(\"renumber_mir: mir.arg_count={:?}\", mir.arg_count);\n \n+    // Update the return type and types of the arguments based on the\n+    // `universal_regions` computation.\n+    debug!(\"renumber_mir: output_ty={:?}\", universal_regions.output_ty);\n+    mir.local_decls[RETURN_PLACE].ty = universal_regions.output_ty;\n+    for (&input_ty, local) in universal_regions\n+        .input_tys\n+        .iter()\n+        .zip((1..).map(Local::new))\n+    {\n+        debug!(\"renumber_mir: input_ty={:?} local={:?}\", input_ty, local);\n+        mir.local_decls[local].ty = input_ty;\n+    }\n+\n     let mut visitor = NLLVisitor {\n         infcx,\n-        universal_regions,\n-        free_region_inference_vars,\n         arg_count: mir.arg_count,\n     };\n     visitor.visit_mir(mir);\n }\n \n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    universal_regions: &'a UniversalRegions<'tcx>,\n-    free_region_inference_vars: IndexVec<RegionVid, ty::Region<'tcx>>,\n     arg_count: usize,\n }\n \n@@ -74,20 +72,17 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n             })\n     }\n \n-    /// Renumbers the regions appearing in `value`, but those regions\n-    /// are expected to be free regions from the function signature.\n-    fn renumber_universal_regions<T>(&mut self, value: &T) -> T\n+    /// Checks that all the regions appearing in `value` have already\n+    /// been renumbered. `FreeRegions` code should have done this.\n+    fn assert_free_regions_are_renumbered<T>(&self, value: &T)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\"renumber_universal_regions(value={:?})\", value);\n+        debug!(\"assert_free_regions_are_renumbered(value={:?})\", value);\n \n-        self.infcx\n-            .tcx\n-            .fold_regions(value, &mut false, |region, _depth| {\n-                let index = self.universal_regions.indices[&region];\n-                self.free_region_inference_vars[index]\n-            })\n+        self.infcx.tcx.for_each_free_region(value, |region| {\n+            region.to_region_vid(); // will panic if `region` is not renumbered\n+        });\n     }\n \n     fn is_argument_or_return_slot(&self, local: Local) -> bool {\n@@ -110,12 +105,12 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n             ty_context\n         );\n \n-        let old_ty = *ty;\n-        *ty = if is_arg {\n-            self.renumber_universal_regions(&old_ty)\n+        if is_arg {\n+            self.assert_free_regions_are_renumbered(ty);\n         } else {\n-            self.renumber_regions(ty_context, &old_ty)\n-        };\n+            *ty = self.renumber_regions(ty_context, ty);\n+        }\n+\n         debug!(\"visit_ty: ty={:?}\", ty);\n     }\n \n@@ -138,6 +133,11 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_region: region={:?}\", region);\n     }\n \n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, location: Location) {\n+        let ty_context = TyContext::Location(location);\n+        *constant = self.renumber_regions(ty_context, &*constant);\n+    }\n+\n     fn visit_closure_substs(&mut self, substs: &mut ClosureSubsts<'tcx>, location: Location) {\n         debug!(\n             \"visit_closure_substs(substs={:?}, location={:?})\","}, {"sha": "c98a94fa8bc106b20a35d25102adec0aba6a435c", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -15,7 +15,6 @@ use rustc::ty;\n use transform::type_check::MirTypeckRegionConstraints;\n use transform::type_check::OutlivesSet;\n \n-use super::universal_regions::UniversalRegions;\n use super::region_infer::RegionInferenceContext;\n \n /// When the MIR type-checker executes, it validates all the types in\n@@ -25,20 +24,17 @@ use super::region_infer::RegionInferenceContext;\n /// them into the NLL `RegionInferenceContext`.\n pub(super) fn generate<'tcx>(\n     regioncx: &mut RegionInferenceContext<'tcx>,\n-    universal_regions: &UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n     constraints: &MirTypeckRegionConstraints<'tcx>,\n ) {\n     SubtypeConstraintGenerator {\n         regioncx,\n-        universal_regions,\n         mir,\n     }.generate(constraints);\n }\n \n struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n     regioncx: &'cx mut RegionInferenceContext<'tcx>,\n-    universal_regions: &'cx UniversalRegions<'tcx>,\n     mir: &'cx Mir<'tcx>,\n }\n \n@@ -106,7 +102,7 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n         if let ty::ReVar(vid) = r {\n             *vid\n         } else {\n-            self.universal_regions.indices[&r]\n+            self.regioncx.to_region_vid(r)\n         }\n     }\n }"}, {"sha": "857a620cead65ea12c90da1d8ffa8185114c7c6a", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 658, "deletions": 46, "changes": 704, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -22,69 +22,681 @@\n //! The code in this file doesn't *do anything* with those results; it\n //! just returns them for other code to use.\n \n+use rustc::hir::HirId;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::InferCtxt;\n-use rustc::infer::outlives::free_region_map::FreeRegionMap;\n-use rustc::ty::{self, RegionVid};\n+use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc::infer::region_constraints::GenericKind;\n+use rustc::infer::outlives::bounds::{self, OutlivesBound};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use std::iter;\n+use syntax::ast;\n+\n+use super::ToRegionVid;\n \n #[derive(Debug)]\n pub struct UniversalRegions<'tcx> {\n-    /// Given a universally quantified region defined on this function\n-    /// (either early- or late-bound), this maps it to its internal\n-    /// region index. When the region context is created, the first N\n-    /// variables will be created based on these indices.\n-    pub indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n-\n-    /// The map from the typeck tables telling us how to relate universal regions.\n-    pub free_region_map: &'tcx FreeRegionMap<'tcx>,\n+    indices: UniversalRegionIndices<'tcx>,\n+\n+    /// The vid assigned to `'static`\n+    pub fr_static: RegionVid,\n+\n+    /// We create region variables such that they are ordered by their\n+    /// `RegionClassification`. The first block are globals, then\n+    /// externals, then locals. So things from:\n+    /// - `FIRST_GLOBAL_INDEX..first_extern_index` are global;\n+    /// - `first_extern_index..first_local_index` are external; and\n+    /// - first_local_index..num_universals` are local.\n+    first_extern_index: usize,\n+\n+    /// See `first_extern_index`.\n+    first_local_index: usize,\n+\n+    /// The total number of universal region variables instantiated.\n+    num_universals: usize,\n+\n+    /// The \"defining\" type for this function, with all universal\n+    /// regions instantiated.  For a closure or generator, this is the\n+    /// closure type, but for a top-level function it's the `TyFnDef`.\n+    pub defining_ty: Ty<'tcx>,\n+\n+    /// The return type of this function, with all regions replaced\n+    /// by their universal `RegionVid` equivalents.\n+    pub output_ty: Ty<'tcx>,\n+\n+    /// The fully liberated input types of this function, with all\n+    /// regions replaced by their universal `RegionVid` equivalents.\n+    pub input_tys: &'tcx [Ty<'tcx>],\n+\n+    /// Each RBP `('a, GK)` indicates that `GK: 'a` can be assumed to\n+    /// be true. These encode relationships like `T: 'a` that are\n+    /// added via implicit bounds.\n+    ///\n+    /// Each region here is guaranteed to be a key in the `indices`\n+    /// map.  We use the \"original\" regions (i.e., the keys from the\n+    /// map, and not the values) because the code in\n+    /// `process_registered_region_obligations` has some special-cased\n+    /// logic expecting to see (e.g.) `ReStatic`, and if we supplied\n+    /// our special inference variable there, we would mess that up.\n+    pub region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n+\n+    relations: UniversalRegionRelations,\n+}\n+\n+#[derive(Debug)]\n+struct UniversalRegionIndices<'tcx> {\n+    /// For those regions that may appear in the parameter environment\n+    /// ('static and early-bound regions), we maintain a map from the\n+    /// `ty::Region` to the internal `RegionVid` we are using. This is\n+    /// used because trait matching and type-checking will feed us\n+    /// region constraints that reference those regions and we need to\n+    /// be able to map them our internal `RegionVid`. This is\n+    /// basically equivalent to a `Substs`, except that it also\n+    /// contains an entry for `ReStatic` -- it might be nice to just\n+    /// use a substs, and then handle `ReStatic` another way.\n+    indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n+}\n+\n+#[derive(Debug)]\n+struct UniversalRegionRelations {\n+    /// Stores the outlives relations that are known to hold from the\n+    /// implied bounds, in-scope where clauses, and that sort of\n+    /// thing.\n+    outlives: TransitiveRelation<RegionVid>,\n+\n+    /// This is the `<=` relation; that is, if `a: b`, then `b <= a`,\n+    /// and we store that here. This is useful when figuring out how\n+    /// to express some local region in terms of external regions our\n+    /// caller will understand.\n+    inverse_outlives: TransitiveRelation<RegionVid>,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum RegionClassification {\n+    /// A **global** region is one that can be named from\n+    /// anywhere. There is only one, `'static`.\n+    Global,\n+\n+    /// An **external** region is only relevant for closures. In that\n+    /// case, it refers to regions that are free in the closure type\n+    /// -- basically, something bound in the surrounding context.\n+    ///\n+    /// Consider this example:\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b>(a: &'a u32, b: &'b u32, c: &'static u32) {\n+    ///   let closure = for<'x> |x: &'x u32| { .. };\n+    ///                 ^^^^^^^ pretend this were legal syntax\n+    ///                         for declaring a late-bound region in\n+    ///                         a closure signature\n+    /// }\n+    /// ```\n+    ///\n+    /// Here, the lifetimes `'a` and `'b` would be **external** to the\n+    /// closure.\n+    ///\n+    /// If we are not analyzing a closure, there are no external\n+    /// lifetimes.\n+    External,\n+\n+    /// A **local** lifetime is one about which we know the full set\n+    /// of relevant constraints (that is, relationships to other named\n+    /// regions).  For a closure, this includes any region bound in\n+    /// the closure's signature.  For a fn item, this includes all\n+    /// regions other than global ones.\n+    ///\n+    /// Continuing with the example from `External`, if we were\n+    /// analyzing the closure, then `'x` would be local (and `'a` and\n+    /// `'b` are external).  If we are analyzing the function item\n+    /// `foo`, then `'a` and `'b` are local (and `'x` is not in\n+    /// scope).\n+    Local,\n }\n \n-pub fn universal_regions<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    item_def_id: DefId,\n-) -> UniversalRegions<'tcx> {\n-    debug!(\"universal_regions(item_def_id={:?})\", item_def_id);\n+const FIRST_GLOBAL_INDEX: usize = 0;\n+\n+impl<'tcx> UniversalRegions<'tcx> {\n+    /// Creates a new and fully initialized `UniversalRegions` that\n+    /// contains indices for all the free regions found in the given\n+    /// MIR -- that is, all the regions that appear in the function's\n+    /// signature. This will also compute the relationships that are\n+    /// known between those regions.\n+    pub fn new(\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir_def_id: DefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n+        let tcx = infcx.tcx;\n+        let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).unwrap();\n+        let mir_hir_id = tcx.hir.node_to_hir_id(mir_node_id);\n+        UniversalRegionsBuilder {\n+            infcx,\n+            mir_def_id,\n+            mir_node_id,\n+            mir_hir_id,\n+            param_env,\n+            region_bound_pairs: vec![],\n+            relations: UniversalRegionRelations {\n+                outlives: TransitiveRelation::new(),\n+                inverse_outlives: TransitiveRelation::new(),\n+            },\n+        }.build()\n+    }\n+\n+    /// Given a reference to a closure type, extracts all the values\n+    /// from its free regions and returns a vector with them. This is\n+    /// used when the closure's creator checks that the\n+    /// `ClosureRegionRequirements` are met. The requirements from\n+    /// `ClosureRegionRequirements` are expressed in terms of\n+    /// `RegionVid` entries that map into the returned vector `V`: so\n+    /// if the `ClosureRegionRequirements` contains something like\n+    /// `'1: '2`, then the caller would impose the constraint that\n+    /// `V[1]: V[2]`.\n+    pub fn closure_mapping(\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        closure_ty: Ty<'tcx>,\n+        expected_num_vars: usize,\n+    ) -> IndexVec<RegionVid, ty::Region<'tcx>> {\n+        let mut region_mapping = IndexVec::with_capacity(expected_num_vars);\n+        region_mapping.push(infcx.tcx.types.re_static);\n+        infcx.tcx.for_each_free_region(&closure_ty, |fr| {\n+            region_mapping.push(fr);\n+        });\n+\n+        assert_eq!(\n+            region_mapping.len(),\n+            expected_num_vars,\n+            \"index vec had unexpected number of variables\"\n+        );\n \n-    let mut indices = FxHashMap();\n+        region_mapping\n+    }\n \n-    // `'static` is always free.\n-    insert_free_region(&mut indices, infcx.tcx.types.re_static);\n+    /// True if `r` is a member of this set of universal regions.\n+    pub fn is_universal_region(&self, r: RegionVid) -> bool {\n+        (FIRST_GLOBAL_INDEX..self.num_universals).contains(r.index())\n+    }\n \n-    // Extract the early regions.\n-    let item_substs = Substs::identity_for_item(infcx.tcx, item_def_id);\n-    for item_subst in item_substs {\n-        if let Some(region) = item_subst.as_region() {\n-            insert_free_region(&mut indices, region);\n+    /// Classifies `r` as a universal region, returning `None` if this\n+    /// is not a member of this set of universal regions.\n+    pub fn region_classification(&self, r: RegionVid) -> Option<RegionClassification> {\n+        let index = r.index();\n+        if (FIRST_GLOBAL_INDEX..self.first_extern_index).contains(index) {\n+            Some(RegionClassification::Global)\n+        } else if (self.first_extern_index..self.first_local_index).contains(index) {\n+            Some(RegionClassification::External)\n+        } else if (self.first_local_index..self.num_universals).contains(index) {\n+            Some(RegionClassification::Local)\n+        } else {\n+            None\n         }\n     }\n \n-    // Extract the late-bound regions. Use the liberated fn sigs,\n-    // where the late-bound regions will have been converted into free\n-    // regions, and add them to the map.\n-    let item_id = infcx.tcx.hir.as_local_node_id(item_def_id).unwrap();\n-    let fn_hir_id = infcx.tcx.hir.node_to_hir_id(item_id);\n-    let tables = infcx.tcx.typeck_tables_of(item_def_id);\n-    let fn_sig = tables.liberated_fn_sigs()[fn_hir_id].clone();\n-    infcx\n-        .tcx\n-        .for_each_free_region(&fn_sig.inputs_and_output, |region| {\n-            if let ty::ReFree(_) = *region {\n-                insert_free_region(&mut indices, region);\n+    /// Returns an iterator over all the RegionVids corresponding to\n+    /// universally quantified free regions.\n+    pub fn universal_regions(&self) -> impl Iterator<Item = RegionVid> {\n+        (FIRST_GLOBAL_INDEX..self.num_universals).map(RegionVid::new)\n+    }\n+\n+    /// True if `r` is classied as a global region.\n+    pub fn is_global_free_region(&self, r: RegionVid) -> bool {\n+        self.region_classification(r) == Some(RegionClassification::Global)\n+    }\n+\n+    /// True if `r` is classied as an external region.\n+    pub fn is_extern_free_region(&self, r: RegionVid) -> bool {\n+        self.region_classification(r) == Some(RegionClassification::External)\n+    }\n+\n+    /// True if `r` is classied as an local region.\n+    pub fn is_local_free_region(&self, r: RegionVid) -> bool {\n+        self.region_classification(r) == Some(RegionClassification::Local)\n+    }\n+\n+    /// Returns the number of universal regions created in any category.\n+    pub fn len(&self) -> usize {\n+        self.num_universals\n+    }\n+\n+    /// Finds an \"upper bound\" for `fr` that is not local. In other\n+    /// words, returns the smallest (*) known region `fr1` that (a)\n+    /// outlives `fr` and (b) is not local. This cannot fail, because\n+    /// we will always find `'static` at worst.\n+    ///\n+    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n+    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n+    pub fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+        debug!(\"non_local_upper_bound(fr={:?})\", fr);\n+        self.non_local_bound(&self.relations.inverse_outlives, fr)\n+            .unwrap_or(self.fr_static)\n+    }\n+\n+    /// Finds a \"lower bound\" for `fr` that is not local. In other\n+    /// words, returns the largest (*) known region `fr1` that (a) is\n+    /// outlived by `fr` and (b) is not local. This cannot fail,\n+    /// because we will always find `'static` at worst.\n+    ///\n+    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n+    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n+    pub fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n+        debug!(\"non_local_lower_bound(fr={:?})\", fr);\n+        self.non_local_bound(&self.relations.outlives, fr)\n+    }\n+\n+    /// Returns the number of global plus external universal regions.\n+    /// For closures, these are the regions that appear free in the\n+    /// closure type (versus those bound in the closure\n+    /// signature). They are therefore the regions between which the\n+    /// closure may impose constraints that its creator must verify.\n+    pub fn num_global_and_external_regions(&self) -> usize {\n+        self.first_local_index\n+    }\n+\n+    /// Helper for `non_local_upper_bound` and\n+    /// `non_local_lower_bound`.  Repeatedly invokes `postdom_parent`\n+    /// until we find something that is not local. Returns None if we\n+    /// never do so.\n+    fn non_local_bound(\n+        &self,\n+        relation: &TransitiveRelation<RegionVid>,\n+        fr0: RegionVid,\n+    ) -> Option<RegionVid> {\n+        let mut external_parents = vec![];\n+        let mut queue = vec![&fr0];\n+\n+        // Keep expanding `fr` into its parents until we reach\n+        // non-local regions.\n+        while let Some(fr) = queue.pop() {\n+            if !self.is_local_free_region(*fr) {\n+                external_parents.push(fr);\n+                continue;\n             }\n-        });\n \n-    debug!(\"universal_regions: indices={:#?}\", indices);\n+            queue.extend(relation.parents(fr));\n+        }\n+\n+        debug!(\"non_local_bound: external_parents={:?}\", external_parents);\n+\n+        // In case we find more than one, reduce to one for\n+        // convenience.  This is to prevent us from generating more\n+        // complex constraints, but it will cause spurious errors.\n+        let post_dom = relation\n+            .mutual_immediate_postdominator(external_parents)\n+            .cloned();\n+\n+        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n+\n+        post_dom.and_then(|post_dom| {\n+            // If the mutual immediate postdom is not local, then\n+            // there is no non-local result we can return.\n+            if !self.is_local_free_region(post_dom) {\n+                Some(post_dom)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// True if fr1 is known to outlive fr2.\n+    ///\n+    /// This will only ever be true for universally quantified regions.\n+    pub fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n+        self.relations.outlives.contains(&fr1, &fr2)\n+    }\n+\n+    /// Returns a vector of free regions `x` such that `fr1: x` is\n+    /// known to hold.\n+    pub fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<&RegionVid> {\n+        self.relations.outlives.reachable_from(&fr1)\n+    }\n+\n+    /// Get an iterator over all the early-bound regions that have names.\n+    pub fn named_universal_regions<'s>(\n+        &'s self,\n+    ) -> impl Iterator<Item = (ty::Region<'tcx>, ty::RegionVid)> + 's {\n+        self.indices.indices.iter().map(|(&r, &v)| (r, v))\n+    }\n+\n+    /// See `UniversalRegionIndices::to_region_vid`.\n+    pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n+        self.indices.to_region_vid(r)\n+    }\n+}\n+\n+struct UniversalRegionsBuilder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    mir_def_id: DefId,\n+    mir_hir_id: HirId,\n+    mir_node_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n+    relations: UniversalRegionRelations,\n+}\n+\n+const FR: NLLRegionVariableOrigin = NLLRegionVariableOrigin::FreeRegion;\n+\n+impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n+    fn build(mut self) -> UniversalRegions<'tcx> {\n+        debug!(\"build(mir_def_id={:?})\", self.mir_def_id);\n+\n+        let param_env = self.param_env;\n+        debug!(\"build: param_env={:?}\", param_env);\n+\n+        assert_eq!(FIRST_GLOBAL_INDEX, self.infcx.num_region_vars());\n+\n+        // Create the \"global\" region that is always free in all contexts: 'static.\n+        let fr_static = self.infcx.next_nll_region_var(FR).to_region_vid();\n+\n+        // We've now added all the global regions. The next ones we\n+        // add will be external.\n+        let first_extern_index = self.infcx.num_region_vars();\n+\n+        let defining_ty = self.defining_ty();\n+        debug!(\"build: defining_ty={:?}\", defining_ty);\n+\n+        let indices = self.compute_indices(fr_static, defining_ty);\n+        debug!(\"build: indices={:?}\", indices);\n+\n+        let bound_inputs_and_output = self.compute_inputs_and_output(&indices, defining_ty);\n+\n+        // \"Liberate\" the late-bound regions. These correspond to\n+        // \"local\" free regions.\n+        let first_local_index = self.infcx.num_region_vars();\n+        let inputs_and_output = self.infcx\n+            .replace_bound_regions_with_nll_infer_vars(FR, &bound_inputs_and_output);\n+        let num_universals = self.infcx.num_region_vars();\n+\n+        // Insert the facts we know from the predicates. Why? Why not.\n+        self.add_outlives_bounds(&indices, bounds::explicit_outlives_bounds(param_env));\n+\n+        // Add the implied bounds from inputs and outputs.\n+        for ty in inputs_and_output {\n+            debug!(\"build: input_or_output={:?}\", ty);\n+            self.add_implied_bounds(&indices, ty);\n+        }\n+\n+        // Finally, outlives is reflexive, and static outlives every\n+        // other free region.\n+        for fr in (FIRST_GLOBAL_INDEX..num_universals).map(RegionVid::new) {\n+            debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n+            self.relations.relate_universal_regions(fr, fr);\n+            self.relations.relate_universal_regions(fr_static, fr);\n+        }\n+\n+        let (output_ty, input_tys) = inputs_and_output.split_last().unwrap();\n+\n+        // we should not have created any more variables\n+        assert_eq!(self.infcx.num_region_vars(), num_universals);\n+\n+        debug!(\"build: global regions = {}..{}\",\n+               FIRST_GLOBAL_INDEX,\n+               first_extern_index);\n+        debug!(\"build: extern regions = {}..{}\",\n+               first_extern_index,\n+               first_local_index);\n+        debug!(\"build: local regions  = {}..{}\",\n+               first_local_index,\n+               num_universals);\n+\n+        UniversalRegions {\n+            indices,\n+            fr_static,\n+            first_extern_index,\n+            first_local_index,\n+            num_universals,\n+            defining_ty,\n+            output_ty,\n+            input_tys,\n+            region_bound_pairs: self.region_bound_pairs,\n+            relations: self.relations,\n+        }\n+    }\n+\n+    fn defining_ty(&self) -> ty::Ty<'tcx> {\n+        let tcx = self.infcx.tcx;\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+\n+        let defining_ty = if self.mir_def_id == closure_base_def_id {\n+            tcx.type_of(closure_base_def_id)\n+        } else {\n+            let tables = tcx.typeck_tables_of(self.mir_def_id);\n+            tables.node_id_to_type(self.mir_hir_id)\n+        };\n+\n+        self.infcx\n+            .replace_free_regions_with_nll_infer_vars(FR, &defining_ty)\n+    }\n+\n+    fn compute_indices(\n+        &self,\n+        fr_static: RegionVid,\n+        defining_ty: Ty<'tcx>,\n+    ) -> UniversalRegionIndices<'tcx> {\n+        let tcx = self.infcx.tcx;\n+        let gcx = tcx.global_tcx();\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+        let identity_substs = Substs::identity_for_item(gcx, closure_base_def_id);\n+        let fr_substs = match defining_ty.sty {\n+            ty::TyClosure(_, substs) | ty::TyGenerator(_, substs, ..) => {\n+                // In the case of closures, we rely on the fact that\n+                // the first N elements in the ClosureSubsts are\n+                // inherited from the `closure_base_def_id`.\n+                // Therefore, when we zip together (below) with\n+                // `identity_substs`, we will get only those regions\n+                // that correspond to early-bound regions declared on\n+                // the `closure_base_def_id`.\n+                assert!(substs.substs.len() >= identity_substs.len());\n+                substs.substs\n+            }\n+            ty::TyFnDef(_, substs) => substs,\n+            _ => bug!(),\n+        };\n+\n+        let global_mapping = iter::once((gcx.types.re_static, fr_static));\n+        let subst_mapping = identity_substs\n+            .regions()\n+            .zip(fr_substs.regions().map(|r| r.to_region_vid()));\n+\n+        UniversalRegionIndices {\n+            indices: global_mapping.chain(subst_mapping).collect(),\n+        }\n+    }\n+\n+    fn compute_inputs_and_output(\n+        &self,\n+        indices: &UniversalRegionIndices<'tcx>,\n+        defining_ty: Ty<'tcx>,\n+    ) -> ty::Binder<&'tcx ty::Slice<Ty<'tcx>>> {\n+        let tcx = self.infcx.tcx;\n+        match defining_ty.sty {\n+            ty::TyClosure(def_id, substs) => {\n+                assert_eq!(self.mir_def_id, def_id);\n+                let closure_sig = substs.closure_sig_ty(def_id, tcx).fn_sig(tcx);\n+                let inputs_and_output = closure_sig.inputs_and_output();\n+                let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n+                ty::Binder::fuse(\n+                    closure_ty,\n+                    inputs_and_output,\n+                    |closure_ty, inputs_and_output| {\n+                        // The \"inputs\" of the closure in the\n+                        // signature appear as a tuple.  The MIR side\n+                        // flattens this tuple.\n+                        let (&output, tuplized_inputs) = inputs_and_output.split_last().unwrap();\n+                        assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n+                        let inputs = match tuplized_inputs[0].sty {\n+                            ty::TyTuple(inputs, _) => inputs,\n+                            _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n+                        };\n \n-    UniversalRegions { indices, free_region_map: &tables.free_region_map }\n+                        tcx.mk_type_list(\n+                            iter::once(closure_ty)\n+                                .chain(inputs.iter().cloned())\n+                                .chain(iter::once(output)),\n+                        )\n+                    },\n+                )\n+            }\n+\n+            ty::TyGenerator(def_id, substs, ..) => {\n+                assert_eq!(self.mir_def_id, def_id);\n+                let output = substs.generator_return_ty(def_id, tcx);\n+                let inputs_and_output = self.infcx.tcx.intern_type_list(&[defining_ty, output]);\n+                ty::Binder::dummy(inputs_and_output)\n+            }\n+\n+            ty::TyFnDef(def_id, _) => {\n+                let sig = tcx.fn_sig(def_id);\n+                let sig = indices.fold_to_region_vids(tcx, &sig);\n+                return sig.inputs_and_output();\n+            }\n+\n+            _ => span_bug!(\n+                tcx.def_span(self.mir_def_id),\n+                \"unexpected defining type: {:?}\",\n+                defining_ty\n+            ),\n+        }\n+    }\n+\n+    /// Update the type of a single local, which should represent\n+    /// either the return type of the MIR or one of its arguments. At\n+    /// the same time, compute and add any implied bounds that come\n+    /// from this local.\n+    ///\n+    /// Assumes that `universal_regions` indices map is fully constructed.\n+    fn add_implied_bounds(&mut self, indices: &UniversalRegionIndices<'tcx>, ty: Ty<'tcx>) {\n+        debug!(\"add_implied_bounds(ty={:?})\", ty);\n+        let span = self.infcx.tcx.def_span(self.mir_def_id);\n+        let bounds = self.infcx\n+            .implied_outlives_bounds(self.param_env, self.mir_node_id, ty, span);\n+        self.add_outlives_bounds(indices, bounds);\n+    }\n+\n+    /// Registers the `OutlivesBound` items from `outlives_bounds` in\n+    /// the outlives relation as well as the region-bound pairs\n+    /// listing.\n+    fn add_outlives_bounds<I>(&mut self, indices: &UniversalRegionIndices<'tcx>, outlives_bounds: I)\n+    where\n+        I: IntoIterator<Item = OutlivesBound<'tcx>>,\n+    {\n+        for outlives_bound in outlives_bounds {\n+            debug!(\"add_outlives_bounds(bound={:?})\", outlives_bound);\n+\n+            match outlives_bound {\n+                OutlivesBound::RegionSubRegion(r1, r2) => {\n+                    // The bound says that `r1 <= r2`; we store `r2: r1`.\n+                    let r1 = indices.to_region_vid(r1);\n+                    let r2 = indices.to_region_vid(r2);\n+                    self.relations.relate_universal_regions(r2, r1);\n+                }\n+\n+                OutlivesBound::RegionSubParam(r_a, param_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Param(param_b)));\n+                }\n+\n+                OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Projection(projection_b)));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl UniversalRegionRelations {\n+    /// Records in the `outlives_relation` (and\n+    /// `inverse_outlives_relation`) that `fr_a: fr_b`.\n+    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n+        debug!(\n+            \"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\",\n+            fr_a,\n+            fr_b\n+        );\n+        self.outlives.add(fr_a, fr_b);\n+        self.inverse_outlives.add(fr_b, fr_a);\n+    }\n+}\n+\n+pub(crate) trait InferCtxtExt<'tcx> {\n+    fn replace_free_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>;\n+\n+    fn replace_bound_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &ty::Binder<T>,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>;\n+}\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'gcx, 'tcx> {\n+    fn replace_free_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.tcx.fold_regions(\n+            value,\n+            &mut false,\n+            |_region, _depth| self.next_nll_region_var(origin),\n+        )\n+    }\n+\n+    fn replace_bound_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &ty::Binder<T>,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let (value, _map) = self.tcx\n+            .replace_late_bound_regions(value, |_br| self.next_nll_region_var(origin));\n+        value\n+    }\n }\n \n-fn insert_free_region<'tcx>(\n-    universal_regions: &mut FxHashMap<ty::Region<'tcx>, RegionVid>,\n-    region: ty::Region<'tcx>,\n-) {\n-    let next = RegionVid::new(universal_regions.len());\n-    universal_regions.entry(region).or_insert(next);\n+impl<'tcx> UniversalRegionIndices<'tcx> {\n+    /// Converts `r` into a local inference variable: `r` can either\n+    /// by a `ReVar` (i.e., already a reference to an inference\n+    /// variable) or it can be `'static` or some early-bound\n+    /// region. This is useful when taking the results from\n+    /// type-checking and trait-matching, which may sometimes\n+    /// reference those regions from the `ParamEnv`. It is also used\n+    /// during initialization. Relies on the `indices` map having been\n+    /// fully initialized.\n+    pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n+        match r {\n+            ty::ReEarlyBound(..) | ty::ReStatic => *self.indices.get(&r).unwrap(),\n+            ty::ReVar(..) => r.to_region_vid(),\n+            _ => bug!(\"cannot convert `{:?}` to a region vid\", r),\n+        }\n+    }\n+\n+    /// Replace all free regions in `value` with region vids, as\n+    /// returned by `to_region_vid`.\n+    pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        tcx.fold_regions(\n+            value,\n+            &mut false,\n+            |region, _| tcx.mk_region(ty::ReVar(self.to_region_vid(region))),\n+        )\n+    }\n }"}, {"sha": "932aad0bb1d84dcf68f12673d221547452081fac", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -51,6 +51,17 @@ impl<'tcx> CFG<'tcx> {\n                                              source_info: SourceInfo,\n                                              region_scope: region::Scope) {\n         if tcx.sess.emit_end_regions() {\n+            if let region::ScopeData::CallSite(_) = region_scope.data() {\n+                // The CallSite scope (aka the root scope) is sort of weird, in that it is\n+                // supposed to \"separate\" the \"interior\" and \"exterior\" of a closure. Being\n+                // that, it is not really a part of the region hierarchy, but for some\n+                // reason it *is* considered a part of it.\n+                //\n+                // It should die a hopefully painful death with NLL, so let's leave this hack\n+                // for now so that nobody can complain about soundness.\n+                return\n+            }\n+\n             self.push(block, Statement {\n                 source_info,\n                 kind: StatementKind::EndRegion(region_scope),"}, {"sha": "c27cb43eff77b8f92f8effd87052ffa8b5213559", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::middle::region;\n use rustc::mir::{self, Location, Mir};\n use rustc::mir::visit::Visitor;\n use rustc::ty::{self, Region, TyCtxt};\n@@ -27,16 +30,20 @@ use borrow_check::nll::ToRegionVid;\n use syntax_pos::Span;\n \n use std::fmt;\n+use std::rc::Rc;\n \n // `Borrows` maps each dataflow bit to an `Rvalue::Ref`, which can be\n // uniquely identified in the MIR by the `Location` of the assigment\n // statement in which it appears on the right hand side.\n pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n+    scope_tree: Rc<region::ScopeTree>,\n+    root_scope: Option<region::Scope>,\n     borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+    local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n     region_span_map: FxHashMap<RegionKind, Span>,\n     nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>,\n }\n@@ -69,22 +76,32 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>)\n+               nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>,\n+               def_id: DefId,\n+               body_id: Option<hir::BodyId>)\n                -> Self {\n+        let scope_tree = tcx.region_scope_tree(def_id);\n+        let root_scope = body_id.map(|body_id| {\n+            region::Scope::CallSite(tcx.hir.body(body_id).value.hir_id.local_id)\n+        });\n         let mut visitor = GatherBorrows {\n             tcx,\n             mir,\n             idx_vec: IndexVec::new(),\n             location_map: FxHashMap(),\n             region_map: FxHashMap(),\n+            local_map: FxHashMap(),\n             region_span_map: FxHashMap()\n         };\n         visitor.visit_mir(mir);\n         return Borrows { tcx: tcx,\n                          mir: mir,\n                          borrows: visitor.idx_vec,\n+                         scope_tree,\n+                         root_scope,\n                          location_map: visitor.location_map,\n                          region_map: visitor.region_map,\n+                         local_map: visitor.local_map,\n                          region_span_map: visitor.region_span_map,\n                          nonlexical_regioncx };\n \n@@ -94,13 +111,22 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n             location_map: FxHashMap<Location, BorrowIndex>,\n             region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+            local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n             region_span_map: FxHashMap<RegionKind, Span>,\n         }\n \n         impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             fn visit_rvalue(&mut self,\n                             rvalue: &mir::Rvalue<'tcx>,\n                             location: mir::Location) {\n+                fn root_local(mut p: &mir::Place<'_>) -> Option<mir::Local> {\n+                    loop { match p {\n+                        mir::Place::Projection(pi) => p = &pi.base,\n+                        mir::Place::Static(_) => return None,\n+                        mir::Place::Local(l) => return Some(*l)\n+                    }}\n+                }\n+\n                 if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n                     if is_unsafe_place(self.tcx, self.mir, place) { return; }\n \n@@ -109,8 +135,14 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                     };\n                     let idx = self.idx_vec.push(borrow);\n                     self.location_map.insert(location, idx);\n+\n                     let borrows = self.region_map.entry(region).or_insert(FxHashSet());\n                     borrows.insert(idx);\n+\n+                    if let Some(local) = root_local(place) {\n+                        let borrows = self.local_map.entry(local).or_insert(FxHashSet());\n+                        borrows.insert(idx);\n+                    }\n                 }\n             }\n \n@@ -199,7 +231,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::EndRegion(region_scope) => {\n                 if let Some(borrow_indexes) = self.region_map.get(&ReScope(region_scope)) {\n                     assert!(self.nonlexical_regioncx.is_none());\n-                    for idx in borrow_indexes { sets.kill(&idx); }\n+                    sets.kill_all(borrow_indexes);\n                 } else {\n                     // (if there is no entry, then there are no borrows to be tracked)\n                 }\n@@ -224,10 +256,19 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            mir::StatementKind::StorageDead(local) => {\n+                // Make sure there are no remaining borrows for locals that\n+                // are gone out of scope.\n+                //\n+                // FIXME: expand this to variables that are assigned over.\n+                if let Some(borrow_indexes) = self.local_map.get(&local) {\n+                    sets.kill_all(borrow_indexes);\n+                }\n+            }\n+\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::SetDiscriminant { .. } |\n             mir::StatementKind::StorageLive(..) |\n-            mir::StatementKind::StorageDead(..) |\n             mir::StatementKind::Validate(..) |\n             mir::StatementKind::Nop => {}\n \n@@ -253,8 +294,17 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 // like unwind paths, we do not always emit `EndRegion` statements, so we\n                 // add some kills here as a \"backup\" and to avoid spurious error messages.\n                 for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n-                    if let ReScope(..) = borrow_data.region {\n-                        sets.kill(&borrow_index);\n+                    if let ReScope(scope) = borrow_data.region {\n+                        // Check that the scope is not actually a scope from a function that is\n+                        // a parent of our closure. Note that the CallSite scope itself is\n+                        // *outside* of the closure, for some weird reason.\n+                        if let Some(root_scope) = self.root_scope {\n+                            if *scope != root_scope &&\n+                                self.scope_tree.is_subscope_of(*scope, root_scope)\n+                            {\n+                                sets.kill(&borrow_index);\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "db8ca0628c4ed2f44c347c1240049cb497cd1ebe", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 39, "deletions": 53, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -14,7 +14,6 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Mir, Location};\n-use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -504,7 +503,6 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n         let stmt = &mir[location.block].statements[location.statement_index];\n         let loc_map = &move_data.loc_map;\n         let path_map = &move_data.path_map;\n-        let bits_per_block = self.bits_per_block();\n \n         match stmt.kind {\n             // this analysis only tries to find moves explicitly\n@@ -515,21 +513,15 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n             _ => {\n                 debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n                        stmt, location, &loc_map[location]);\n-                for move_index in &loc_map[location] {\n-                    // Every path deinitialized by a *particular move*\n-                    // has corresponding bit, \"gen'ed\" (i.e. set)\n-                    // here, in dataflow vector\n-                    zero_to_one(sets.gen_set.words_mut(), *move_index);\n-                }\n+                // Every path deinitialized by a *particular move*\n+                // has corresponding bit, \"gen'ed\" (i.e. set)\n+                // here, in dataflow vector\n+                sets.gen_all_and_assert_dead(&loc_map[location]);\n             }\n         }\n \n         for_location_inits(tcx, mir, move_data, location,\n-            |mpi| for moi in &path_map[mpi] {\n-                assert!(moi.index() < bits_per_block);\n-                sets.kill_set.add(&moi);\n-            }\n-        );\n+                           |mpi| sets.kill_all(&path_map[mpi]));\n     }\n \n     fn terminator_effect(&self,\n@@ -543,18 +535,10 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n \n         debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n                term, location, &loc_map[location]);\n-        let bits_per_block = self.bits_per_block();\n-        for move_index in &loc_map[location] {\n-            assert!(move_index.index() < bits_per_block);\n-            zero_to_one(sets.gen_set.words_mut(), *move_index);\n-        }\n+        sets.gen_all_and_assert_dead(&loc_map[location]);\n \n         for_location_inits(tcx, mir, move_data, location,\n-            |mpi| for moi in &path_map[mpi] {\n-                assert!(moi.index() < bits_per_block);\n-                sets.kill_set.add(&moi);\n-            }\n-        );\n+                           |mpi| sets.kill_all(&path_map[mpi]));\n     }\n \n     fn propagate_call_return(&self,\n@@ -585,11 +569,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n \n     fn start_block_effect(&self, sets: &mut BlockSets<InitIndex>) {\n-        let bits_per_block = self.bits_per_block();\n-        for init_index in (0..self.mir.arg_count).map(InitIndex::new) {\n-            assert!(init_index.index() < bits_per_block);\n-            sets.gen_set.add(&init_index);\n-        }\n+        sets.gen_all((0..self.mir.arg_count).map(InitIndex::new));\n     }\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<InitIndex>,\n@@ -599,26 +579,39 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n         let init_path_map = &move_data.init_path_map;\n         let init_loc_map = &move_data.init_loc_map;\n         let rev_lookup = &move_data.rev_lookup;\n-        let bits_per_block = self.bits_per_block();\n \n         debug!(\"statement {:?} at loc {:?} initializes move_indexes {:?}\",\n                stmt, location, &init_loc_map[location]);\n-        for init_index in &init_loc_map[location] {\n-            assert!(init_index.index() < bits_per_block);\n-            sets.gen_set.add(init_index);\n-        }\n+        sets.gen_all(&init_loc_map[location]);\n \n         match stmt.kind {\n-            mir::StatementKind::StorageDead(local) => {\n-                // End inits for StorageDead, so that an immutable variable can\n-                // be reinitialized on the next iteration of the loop.\n+            mir::StatementKind::StorageDead(local) |\n+            mir::StatementKind::StorageLive(local) => {\n+                // End inits for StorageDead and StorageLive, so that an immutable\n+                // variable can be reinitialized on the next iteration of the loop.\n+                //\n+                // FIXME(#46525): We *need* to do this for StorageLive as well as\n+                // StorageDead, because lifetimes of match bindings with guards are\n+                // weird - i.e. this code\n+                //\n+                // ```\n+                //     fn main() {\n+                //         match 0 {\n+                //             a | a\n+                //             if { println!(\"a={}\", a); false } => {}\n+                //             _ => {}\n+                //         }\n+                //     }\n+                // ```\n+                //\n+                // runs the guard twice, using the same binding for `a`, and only\n+                // storagedeads after everything ends, so if we don't regard the\n+                // storagelive as killing storage, we would have a multiple assignment\n+                // to immutable data error.\n                 if let LookupResult::Exact(mpi) = rev_lookup.find(&mir::Place::Local(local)) {\n                     debug!(\"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n-                        stmt, location, &init_path_map[mpi]);\n-                    for ii in &init_path_map[mpi] {\n-                        assert!(ii.index() < bits_per_block);\n-                        sets.kill_set.add(&ii);\n-                    }\n+                           stmt, location, &init_path_map[mpi]);\n+                    sets.kill_all(&init_path_map[mpi]);\n                 }\n             }\n             _ => {}\n@@ -634,13 +627,11 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n         let init_loc_map = &move_data.init_loc_map;\n         debug!(\"terminator {:?} at loc {:?} initializes move_indexes {:?}\",\n                term, location, &init_loc_map[location]);\n-        let bits_per_block = self.bits_per_block();\n-        for init_index in &init_loc_map[location] {\n-            if move_data.inits[*init_index].kind != InitKind::NonPanicPathOnly {\n-                assert!(init_index.index() < bits_per_block);\n-                sets.gen_set.add(init_index);\n-            }\n-        }\n+        sets.gen_all(\n+            init_loc_map[location].iter().filter(|init_index| {\n+                move_data.inits[**init_index].kind != InitKind::NonPanicPathOnly\n+            })\n+        );\n     }\n \n     fn propagate_call_return(&self,\n@@ -663,11 +654,6 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n-    let retval = bitvec.set_bit(move_index.index());\n-    assert!(retval);\n-}\n-\n impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {"}, {"sha": "12722979706fc6921eed8c696b738f71e5ffc30c", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,6 +18,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n use rustc::session::Session;\n \n+use std::borrow::Borrow;\n use std::fmt::{self, Debug};\n use std::io;\n use std::mem;\n@@ -492,10 +493,39 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n         self.gen_set.add(e);\n         self.kill_set.remove(e);\n     }\n+    fn gen_all<I>(&mut self, i: I)\n+        where I: IntoIterator,\n+              I::Item: Borrow<E>\n+    {\n+        for j in i {\n+            self.gen(j.borrow());\n+        }\n+    }\n+\n+    fn gen_all_and_assert_dead<I>(&mut self, i: I)\n+        where I: IntoIterator,\n+        I::Item: Borrow<E>\n+    {\n+        for j in i {\n+            let j = j.borrow();\n+            let retval = self.gen_set.add(j);\n+            self.kill_set.remove(j);\n+            assert!(retval);\n+        }\n+    }\n+\n     fn kill(&mut self, e: &E) {\n         self.gen_set.remove(e);\n         self.kill_set.add(e);\n     }\n+    fn kill_all<I>(&mut self, i: I)\n+        where I: IntoIterator,\n+              I::Item: Borrow<E>\n+    {\n+        for j in i {\n+            self.kill(j.borrow());\n+        }\n+    }\n }\n \n impl<E:Idx> AllSets<E> {"}, {"sha": "2b2323928efba23aeac1b5a8dfcfd53eb2f859da", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -41,6 +41,9 @@ use transform::{MirPass, MirSource};\n use super::promote_consts::{self, Candidate, TempState};\n \n bitflags! {\n+    // Borrows of temporaries can be promoted only if\n+    // they have none of these qualifications, with\n+    // the exception of `STATIC_REF` (in statics only).\n     struct Qualif: u8 {\n         // Constant containing interior mutability (UnsafeCell).\n         const MUTABLE_INTERIOR  = 1 << 0;\n@@ -65,10 +68,6 @@ bitflags! {\n         // promote_consts decided they weren't simple enough.\n         const NOT_PROMOTABLE    = 1 << 6;\n \n-        // Borrows of temporaries can be promoted only\n-        // if they have none of the above qualifications.\n-        const NEVER_PROMOTE     = 0b111_1111;\n-\n         // Const items can only have MUTABLE_INTERIOR\n         // and NOT_PROMOTABLE without producing an error.\n         const CONST_ERROR       = !Qualif::MUTABLE_INTERIOR.bits &\n@@ -197,7 +196,17 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         self.add(original);\n     }\n \n-    /// Check if an Place with the current qualifications could\n+    /// Check if a Local with the current qualifications is promotable.\n+    fn can_promote(&mut self) -> bool {\n+        // References to statics are allowed, but only in other statics.\n+        if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n+            (self.qualif - Qualif::STATIC_REF).is_empty()\n+        } else {\n+            self.qualif.is_empty()\n+        }\n+    }\n+\n+    /// Check if a Place with the current qualifications could\n     /// be consumed, by either an operand or a Deref projection.\n     fn try_consume(&mut self) -> bool {\n         if self.qualif.intersects(Qualif::STATIC) && self.mode != Mode::Fn {\n@@ -633,7 +642,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n                 // We might have a candidate for promotion.\n                 let candidate = Candidate::Ref(location);\n-                if !self.qualif.intersects(Qualif::NEVER_PROMOTE) {\n+                if self.can_promote() {\n                     // We can only promote direct borrows of temps.\n                     if let Place::Local(local) = *place {\n                         if self.mir.local_kind(local) == LocalKind::Temp {\n@@ -745,7 +754,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     this.visit_operand(arg, location);\n                     if is_shuffle && i == 2 && this.mode == Mode::Fn {\n                         let candidate = Candidate::ShuffleIndices(bb);\n-                        if !this.qualif.intersects(Qualif::NEVER_PROMOTE) {\n+                        if this.can_promote() {\n                             this.promotion_candidates.push(candidate);\n                         } else {\n                             span_err!(this.tcx.sess, this.span, E0526,"}, {"sha": "1a74f32700151c55e4567839372010801456b14b", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -11,6 +11,7 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n+use borrow_check::nll::region_infer::ClosureRegionRequirementsExt;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::traits::{self, FulfillmentContext};\n@@ -110,6 +111,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n+        self.sanitize_constant(constant, location);\n         self.sanitize_type(constant, constant.ty);\n     }\n \n@@ -159,6 +161,52 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Checks that the constant's `ty` field matches up with what\n+    /// would be expected from its literal.\n+    fn sanitize_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n+        debug!(\n+            \"sanitize_constant(constant={:?}, location={:?})\",\n+            constant,\n+            location\n+        );\n+\n+        let expected_ty = match constant.literal {\n+            Literal::Value { value } => value.ty,\n+            Literal::Promoted { .. } => {\n+                // FIXME -- promoted MIR return types reference\n+                // various \"free regions\" (e.g., scopes and things)\n+                // that they ought not to do. We have to figure out\n+                // how best to handle that -- probably we want treat\n+                // promoted MIR much like closures, renumbering all\n+                // their free regions and propagating constraints\n+                // upwards. We have the same acyclic guarantees, so\n+                // that should be possible. But for now, ignore them.\n+                //\n+                // let promoted_mir = &self.mir.promoted[index];\n+                // promoted_mir.return_ty()\n+                return;\n+            }\n+        };\n+\n+        debug!(\"sanitize_constant: expected_ty={:?}\", expected_ty);\n+\n+        if let Err(terr) = self.cx\n+            .eq_types(expected_ty, constant.ty, location.at_self())\n+        {\n+            span_mirbug!(\n+                self,\n+                constant,\n+                \"constant {:?} should have type {:?} but has {:?} ({:?})\",\n+                constant,\n+                expected_ty,\n+                constant.ty,\n+                terr,\n+            );\n+        }\n+    }\n+\n+    /// Checks that the types internal to the `place` match up with\n+    /// what would be expected.\n     fn sanitize_place(\n         &mut self,\n         place: &Place<'tcx>,\n@@ -1088,14 +1136,45 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         operands: &[Operand<'tcx>],\n         location: Location,\n     ) {\n+        let tcx = self.tcx();\n+\n         match aggregate_kind {\n             // tuple rvalue field type is always the type of the op. Nothing to check here.\n             AggregateKind::Tuple => return,\n+\n+            // For closures, we have some **extra requirements** we\n+            // have to check. In particular, in their upvars and\n+            // signatures, closures often reference various regions\n+            // from the surrounding function -- we call those the\n+            // closure's free regions. When we borrow-check (and hence\n+            // region-check) closures, we may find that the closure\n+            // requires certain relationships between those free\n+            // regions. However, because those free regions refer to\n+            // portions of the CFG of their caller, the closure is not\n+            // in a position to verify those relationships. In that\n+            // case, the requirements get \"propagated\" to us, and so\n+            // we have to solve them here where we instantiate the\n+            // closure.\n+            //\n+            // Despite the opacity of the previous parapgrah, this is\n+            // actually relatively easy to understand in terms of the\n+            // desugaring. A closure gets desugared to a struct, and\n+            // these extra requirements are basically like where\n+            // clauses on the struct.\n+            AggregateKind::Closure(def_id, substs) => {\n+                if let Some(closure_region_requirements) = tcx.mir_borrowck(*def_id) {\n+                    closure_region_requirements.apply_requirements(\n+                        self.infcx,\n+                        location,\n+                        *def_id,\n+                        *substs,\n+                    );\n+                }\n+            }\n+\n             _ => {}\n         }\n \n-        let tcx = self.tcx();\n-\n         for (i, operand) in operands.iter().enumerate() {\n             let field_ty = match self.aggregate_field_ty(aggregate_kind, i, location) {\n                 Ok(field_ty) => field_ty,"}, {"sha": "37f59773cd6f03b2295c4395b5b985b32349624f", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 114, "deletions": 26, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -11,7 +11,8 @@\n use rustc::hir;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::*;\n-use rustc::ty::TyCtxt;\n+use rustc::mir::visit::Visitor;\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::item_path;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -56,9 +57,19 @@ pub enum PassWhere {\n /// where `<filter>` takes the following forms:\n ///\n /// - `all` -- dump MIR for all fns, all passes, all everything\n-/// - `substring1&substring2,...` -- `&`-separated list of substrings\n-///   that can appear in the pass-name or the `item_path_str` for the given\n-///   node-id. If any one of the substrings match, the data is dumped out.\n+/// - a filter defined by a set of substrings combined with `&` and `|`\n+///   (`&` has higher precedence). At least one of the `|`-separated groups\n+///   must match; an `|`-separated group matches if all of its `&`-separated\n+///   substrings are matched.\n+///\n+/// Example:\n+///\n+/// - `nll` == match if `nll` appears in the name\n+/// - `foo & nll` == match if `foo` and `nll` both appear in the name\n+/// - `foo & nll | typeck` == match if `foo` and `nll` both appear in the name\n+///   or `typeck` appears in the name.\n+/// - `foo & nll | bar & typeck` == match if `foo` and `nll` both appear in the name\n+///   or `typeck` and `bar` both appear in the name.\n pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pass_num: Option<&Display>,\n@@ -103,8 +114,10 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(\n         // see notes on #41697 below\n         tcx.item_path_str(source.def_id)\n     });\n-    filters.split(\"&\").any(|filter| {\n-        filter == \"all\" || pass_name.contains(filter) || node_path.contains(filter)\n+    filters.split(\"|\").any(|or_filter| {\n+        or_filter.split(\"&\").all(|and_filter| {\n+            and_filter == \"all\" || pass_name.contains(and_filter) || node_path.contains(and_filter)\n+        })\n     })\n }\n \n@@ -125,14 +138,7 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n     F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n {\n     let _: io::Result<()> = do catch {\n-        let mut file = create_dump_file(\n-            tcx,\n-            \"mir\",\n-            pass_num,\n-            pass_name,\n-            disambiguator,\n-            source,\n-        )?;\n+        let mut file = create_dump_file(tcx, \"mir\", pass_num, pass_name, disambiguator, source)?;\n         writeln!(file, \"// MIR for `{}`\", node_path)?;\n         writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n@@ -148,15 +154,9 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n     };\n \n     if tcx.sess.opts.debugging_opts.dump_mir_graphviz {\n-    let _: io::Result<()> = do catch {\n-            let mut file = create_dump_file(\n-                tcx,\n-                \"dot\",\n-                pass_num,\n-                pass_name,\n-                disambiguator,\n-                source,\n-            )?;\n+        let _: io::Result<()> = do catch {\n+            let mut file =\n+                create_dump_file(tcx, \"dot\", pass_num, pass_name, disambiguator, source)?;\n             write_mir_fn_graphviz(tcx, source.def_id, mir, &mut file)?;\n             Ok(())\n         };\n@@ -297,10 +297,10 @@ where\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-pub fn write_basic_block<F>(\n-    tcx: TyCtxt,\n+pub fn write_basic_block<'cx, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     block: BasicBlock,\n-    mir: &Mir,\n+    mir: &Mir<'tcx>,\n     extra_data: &mut F,\n     w: &mut Write,\n ) -> io::Result<()>\n@@ -330,6 +330,11 @@ where\n             comment(tcx, statement.source_info),\n             A = ALIGN,\n         )?;\n+\n+        write_extra(tcx, w, |visitor| {\n+            visitor.visit_statement(current_location.block, statement, current_location);\n+        })?;\n+\n         extra_data(PassWhere::AfterLocation(current_location), w)?;\n \n         current_location.statement_index += 1;\n@@ -346,11 +351,94 @@ where\n         comment(tcx, data.terminator().source_info),\n         A = ALIGN,\n     )?;\n+\n+    write_extra(tcx, w, |visitor| {\n+        visitor.visit_terminator(current_location.block, data.terminator(), current_location);\n+    })?;\n+\n     extra_data(PassWhere::AfterLocation(current_location), w)?;\n \n     writeln!(w, \"{}}}\", INDENT)\n }\n \n+/// After we print the main statement, we sometimes dump extra\n+/// information. There's often a lot of little things \"nuzzled up\" in\n+/// a statement.\n+fn write_extra<'cx, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    write: &mut Write,\n+    mut visit_op: F,\n+) -> io::Result<()>\n+where\n+    F: FnMut(&mut ExtraComments<'cx, 'gcx, 'tcx>),\n+{\n+    let mut extra_comments = ExtraComments {\n+        _tcx: tcx,\n+        comments: vec![],\n+    };\n+    visit_op(&mut extra_comments);\n+    for comment in extra_comments.comments {\n+        writeln!(write, \"{:A$} // {}\", \"\", comment, A = ALIGN)?;\n+    }\n+    Ok(())\n+}\n+\n+struct ExtraComments<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    _tcx: TyCtxt<'cx, 'gcx, 'tcx>, // don't need it now, but bet we will soon\n+    comments: Vec<String>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> ExtraComments<'cx, 'gcx, 'tcx> {\n+    fn push(&mut self, lines: &str) {\n+        for line in lines.split(\"\\n\") {\n+            self.comments.push(line.to_string());\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n+    fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n+        self.super_constant(constant, location);\n+        let Constant { span, ty, literal } = constant;\n+        self.push(&format!(\"mir::Constant\"));\n+        self.push(&format!(\"\u2514 span: {:?}\", span));\n+        self.push(&format!(\"\u2514 ty: {:?}\", ty));\n+        self.push(&format!(\"\u2514 literal: {:?}\", literal));\n+    }\n+\n+    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n+        self.super_const(constant);\n+        let ty::Const { ty, val } = constant;\n+        self.push(&format!(\"ty::Const\"));\n+        self.push(&format!(\"\u2514 ty: {:?}\", ty));\n+        self.push(&format!(\"\u2514 val: {:?}\", val));\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n+        match rvalue {\n+            Rvalue::Aggregate(kind, _) => match **kind {\n+                AggregateKind::Closure(def_id, substs) => {\n+                    self.push(&format!(\"closure\"));\n+                    self.push(&format!(\"\u2514 def_id: {:?}\", def_id));\n+                    self.push(&format!(\"\u2514 substs: {:#?}\", substs));\n+                }\n+\n+                AggregateKind::Generator(def_id, substs, interior) => {\n+                    self.push(&format!(\"generator\"));\n+                    self.push(&format!(\"\u2514 def_id: {:?}\", def_id));\n+                    self.push(&format!(\"\u2514 substs: {:#?}\", substs));\n+                    self.push(&format!(\"\u2514 interior: {:?}\", interior));\n+                }\n+\n+                _ => {}\n+            },\n+\n+            _ => {}\n+        }\n+    }\n+}\n+\n fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n     format!(\n         \"scope {} at {}\","}, {"sha": "05ad1643619058e363c73418755f8873c5472529", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -21,6 +21,7 @@ use rustc::session::Session;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Spanned;\n+use syntax::parse::token;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n@@ -35,8 +36,16 @@ impl<'a> AstValidator<'a> {\n         &self.session.parse_sess.span_diagnostic\n     }\n \n+    fn check_lifetime(&self, lifetime: &Lifetime) {\n+        let valid_names = [keywords::StaticLifetime.name(), keywords::Invalid.name()];\n+        if !valid_names.contains(&lifetime.ident.name) &&\n+            token::Ident(lifetime.ident.without_first_quote()).is_reserved_ident() {\n+            self.err_handler().span_err(lifetime.span, \"lifetimes cannot use keyword names\");\n+        }\n+    }\n+\n     fn check_label(&self, label: Ident, span: Span) {\n-        if label.name == keywords::StaticLifetime.name() || label.name == \"'_\" {\n+        if token::Ident(label.without_first_quote()).is_reserved_ident() || label.name == \"'_\" {\n             self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n         }\n     }\n@@ -200,6 +209,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_use_tree(self, use_tree, id);\n     }\n \n+    fn visit_lifetime(&mut self, lifetime: &'a Lifetime) {\n+        self.check_lifetime(lifetime);\n+        visit::walk_lifetime(self, lifetime);\n+    }\n+\n     fn visit_item(&mut self, item: &'a Item) {\n         match item.node {\n             ItemKind::Impl(.., Some(..), _, ref impl_items) => {"}, {"sha": "d4a08d643ab6768dbd7a77df2594993777e9b305", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -21,6 +21,7 @@ use rustc::ty;\n use rustc::lint::builtin::PUB_USE_OF_PRIVATE_EXTERN_CRATE;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::*;\n+use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use syntax::ast::{Ident, Name, SpannedIdent, NodeId};\n@@ -72,7 +73,7 @@ impl<'a> ImportDirective<'a> {\n     }\n }\n \n-#[derive(Clone, Default)]\n+#[derive(Clone, Default, Debug)]\n /// Records information about the resolution of a name in a namespace of a module.\n pub struct NameResolution<'a> {\n     /// The single imports that define the name in the namespace.\n@@ -867,12 +868,59 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n \n             match binding.kind {\n-                NameBindingKind::Import { binding: orig_binding, .. } => {\n+                NameBindingKind::Import { binding: orig_binding, directive, .. } => {\n                     if ns == TypeNS && orig_binding.is_variant() &&\n-                       !orig_binding.vis.is_at_least(binding.vis, &*self) {\n-                        let msg = format!(\"variant `{}` is private, and cannot be reexported, \\\n-                                           consider declaring its enum as `pub`\", ident);\n-                        self.session.span_err(binding.span, &msg);\n+                        !orig_binding.vis.is_at_least(binding.vis, &*self) {\n+                            let msg = match directive.subclass {\n+                                ImportDirectiveSubclass::SingleImport { .. } => {\n+                                    format!(\"variant `{}` is private and cannot be reexported\",\n+                                            ident)\n+                                },\n+                                ImportDirectiveSubclass::GlobImport { .. } => {\n+                                    let msg = \"enum is private and its variants \\\n+                                               cannot be reexported\".to_owned();\n+                                    let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n+                                                    Some(binding.span),\n+                                                    msg.clone());\n+                                    let fresh = self.session.one_time_diagnostics\n+                                        .borrow_mut().insert(error_id);\n+                                    if !fresh {\n+                                        continue;\n+                                    }\n+                                    msg\n+                                },\n+                                ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n+                            };\n+                            let mut err = self.session.struct_span_err(binding.span, &msg);\n+\n+                            let imported_module = directive.imported_module.get()\n+                                .expect(\"module should exist\");\n+                            let resolutions = imported_module.parent.expect(\"parent should exist\")\n+                                .resolutions.borrow();\n+                            let enum_path_segment_index = directive.module_path.len() - 1;\n+                            let enum_ident = directive.module_path[enum_path_segment_index].node;\n+\n+                            let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n+                                .expect(\"resolution should exist\");\n+                            let enum_span = enum_resolution.borrow()\n+                                .binding.expect(\"binding should exist\")\n+                                .span;\n+                            let enum_def_span = self.session.codemap().def_span(enum_span);\n+                            let enum_def_snippet = self.session.codemap()\n+                                .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n+                            // potentially need to strip extant `crate`/`pub(path)` for suggestion\n+                            let after_vis_index = enum_def_snippet.find(\"enum\")\n+                                .expect(\"`enum` keyword should exist in snippet\");\n+                            let suggestion = format!(\"pub {}\",\n+                                                     &enum_def_snippet[after_vis_index..]);\n+\n+                            self.session\n+                                .diag_span_suggestion_once(&mut err,\n+                                                           DiagnosticMessageId::ErrorId(0),\n+                                                           enum_def_span,\n+                                                           \"consider making the enum public\",\n+                                                           suggestion);\n+                            err.emit();\n                     }\n                 }\n                 NameBindingKind::Ambiguity { b1, b2, .. }"}, {"sha": "609629bffb9dad4f48318015f89bcfdeea605850", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -120,10 +120,7 @@ impl<'a> ArchiveBuilder<'a> {\n         if let Some(ref a) = self.src_archive {\n             return a.as_ref()\n         }\n-        let src = match self.config.src {\n-            Some(ref src) => src,\n-            None => return None,\n-        };\n+        let src = self.config.src.as_ref()?;\n         self.src_archive = Some(ArchiveRO::open(src).ok());\n         self.src_archive.as_ref().unwrap().as_ref()\n     }"}, {"sha": "762cf7a0055d5f7010ace28986f386ea3bd02a4f", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -29,7 +29,7 @@ use value::Value;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n-use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::subst::{Kind, Substs};\n use rustc::hir;\n \n use libc::{c_uint, c_char};\n@@ -393,7 +393,7 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::TyFnPtr(_) => ty.fn_sig(ccx.tcx()),\n         ty::TyClosure(def_id, substs) => {\n             let tcx = ccx.tcx();\n-            let sig = tcx.fn_sig(def_id).subst(tcx, substs.substs);\n+            let sig = substs.closure_sig(def_id, tcx);\n \n             let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n             sig.map_bound(|sig| tcx.mk_fn_sig("}, {"sha": "800c7733c3d623a3cac3f037f71aa1b2b2525613", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -74,7 +74,7 @@ pub fn addr_of_mut(ccx: &CrateContext,\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n         set_global_alignment(ccx, gv, align);\n-        llvm::LLVMRustSetLinkage(gv, llvm::Linkage::InternalLinkage);\n+        llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n         SetUnnamedAddr(gv, true);\n         gv\n     }"}, {"sha": "0799a388a8becf207a37b58af9932ddc7a3dacdf", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -20,7 +20,7 @@ use rustc::mir::tcx::PlaceTy;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::subst::{Kind, Substs, Subst};\n+use rustc::ty::subst::{Kind, Substs};\n use rustc_apfloat::{ieee, Float, Status};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use base;\n@@ -658,8 +658,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     .find(|it| it.kind == ty::AssociatedKind::Method)\n                                     .unwrap().def_id;\n                                 // Now create its substs [Closure, Tuple]\n-                                let input = tcx.fn_sig(def_id)\n-                                    .subst(tcx, substs.substs).input(0);\n+                                let input = substs.closure_sig(def_id, tcx).input(0);\n                                 let input = tcx.erase_late_bound_regions_and_normalize(&input);\n                                 let substs = tcx.mk_substs([operand.ty, input]\n                                     .iter().cloned().map(Kind::from));"}, {"sha": "806aca54dc013528cdc7b2c02fb445b6154ef9fd", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -359,10 +359,10 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n     pub fn trans_set_discr(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize) {\n-            if self.layout.for_variant(bcx.ccx, variant_index).abi == layout::Abi::Uninhabited {\n-                return;\n-            }\n-            match self.layout.variants {\n+        if self.layout.for_variant(bcx.ccx, variant_index).abi == layout::Abi::Uninhabited {\n+            return;\n+        }\n+        match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 assert_eq!(index, variant_index);\n             }"}, {"sha": "d586d1ac31506aa63676a5350435b1e9085424e2", "filename": "src/librustc_trans_utils/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fmonomorphize.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::DropInPlaceFnLangItem;\n use rustc::traits;\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::ty::subst::{Kind, Subst};\n+use rustc::ty::subst::Kind;\n use rustc::ty::{self, Ty, TyCtxt};\n \n pub use rustc::ty::Instance;\n@@ -34,7 +34,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     let self_ty = tcx.mk_closure_from_closure_substs(\n         closure_did, substs);\n \n-    let sig = tcx.fn_sig(closure_did).subst(tcx, substs.substs);\n+    let sig = substs.closure_sig(closure_did, tcx);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     assert_eq!(sig.inputs().len(), 1);\n     let substs = tcx.mk_substs(["}, {"sha": "d075bf436792050c7322e748c05d3c26c2a38e2f", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -79,10 +79,8 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n         let (kind, new_ty) = if let Some(mt) = self.cur_ty.builtin_deref(false, NoPreference) {\n             (AutoderefKind::Builtin, mt.ty)\n         } else {\n-            match self.overloaded_deref_ty(self.cur_ty) {\n-                Some(ty) => (AutoderefKind::Overloaded, ty),\n-                _ => return None,\n-            }\n+            let ty = self.overloaded_deref_ty(self.cur_ty)?;\n+            (AutoderefKind::Overloaded, ty)\n         };\n \n         if new_ty.references_error() {\n@@ -108,10 +106,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n         // <cur_ty as Deref>\n         let trait_ref = TraitRef {\n-            def_id: match tcx.lang_items().deref_trait() {\n-                Some(f) => f,\n-                None => return None,\n-            },\n+            def_id: tcx.lang_items().deref_trait()?,\n             substs: tcx.mk_substs_trait(self.cur_ty, &[]),\n         };\n "}, {"sha": "df1694a601056b8e0c66414ef2753b9959599710", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -16,7 +16,6 @@ use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, TypeFoldable, LvaluePreference, Ty};\n-use rustc::ty::subst::Subst;\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use syntax::abi;\n use syntax::symbol::Symbol;\n@@ -109,7 +108,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // haven't yet decided on whether the closure is fn vs\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(def_id, substs).is_none() {\n-                    let closure_ty = self.fn_sig(def_id).subst(self.tcx, substs.substs);\n+                    let closure_ty = self.closure_sig(def_id, substs);\n                     let fn_sig = self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                    infer::FnCall,\n                                                                    &closure_ty)"}, {"sha": "dc5d3141d4ca29323a34412faf411d1bf6c3c758", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -74,7 +74,6 @@ use rustc::ty::{self, LvaluePreference, TypeAndMut,\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n-use rustc::ty::subst::Subst;\n use errors::DiagnosticBuilder;\n use syntax::abi;\n use syntax::feature_gate;\n@@ -670,7 +669,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n                 //     `fn(arg0,arg1,...) -> _`\n-                let sig = self.fn_sig(def_id_a).subst(self.tcx, substs_a.substs);\n+                let sig = self.closure_sig(def_id_a, substs_a);\n                 let converted_sig = sig.map_bound(|s| {\n                     let params_iter = match s.inputs()[0].sty {\n                         ty::TyTuple(params, _) => {"}, {"sha": "24ffc0ca542cf34d4c7452a068b4f80b0e0a1316", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -4194,7 +4194,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // type of the lvalue it is referencing, and not some\n             // supertype thereof.\n             let init_ty = self.check_expr_with_lvalue_pref(init, LvaluePreference::from_mutbl(m));\n-            self.demand_eqtype(init.span, init_ty, local_ty);\n+            self.demand_eqtype(init.span, local_ty, init_ty);\n             init_ty\n         } else {\n             self.check_expr_coercable_to_type(init, local_ty)"}, {"sha": "07d5f813cbbce76977700c569af80bdd868a8ea3", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -12,9 +12,11 @@ use namespace::Namespace;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::traits;\n+use rustc::traits::{self, IntercrateMode};\n use rustc::ty::TyCtxt;\n \n+use lint;\n+\n pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n@@ -28,7 +30,8 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n     fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n-                                       overlap: traits::OverlapResult) {\n+                                       overlap: traits::OverlapResult,\n+                                       used_to_be_allowed: bool) {\n \n         let name_and_namespace = |def_id| {\n             let item = self.tcx.associated_item(def_id);\n@@ -43,11 +46,21 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n-                    let mut err = struct_span_err!(self.tcx.sess,\n-                                                   self.tcx.span_of_impl(item1).unwrap(),\n-                                                   E0592,\n-                                                   \"duplicate definitions with name `{}`\",\n-                                                   name);\n+                    let node_id = self.tcx.hir.as_local_node_id(impl1);\n+                    let mut err = if used_to_be_allowed && node_id.is_some() {\n+                        self.tcx.struct_span_lint_node(\n+                            lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                            node_id.unwrap(),\n+                            self.tcx.span_of_impl(item1).unwrap(),\n+                            &format!(\"duplicate definitions with name `{}` (E0592)\", name)\n+                        )\n+                    } else {\n+                        struct_span_err!(self.tcx.sess,\n+                                         self.tcx.span_of_impl(item1).unwrap(),\n+                                         E0592,\n+                                         \"duplicate definitions with name `{}`\",\n+                                         name)\n+                    };\n \n                     err.span_label(self.tcx.span_of_impl(item1).unwrap(),\n                                    format!(\"duplicate definitions for `{}`\", name));\n@@ -69,12 +82,30 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt().enter(|infcx| {\n+                let used_to_be_allowed = self.tcx.infer_ctxt().enter(|infcx| {\n                     if let Some(overlap) =\n-                            traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n-                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id, overlap)\n+                        traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id,\n+                                                  IntercrateMode::Issue43355)\n+                    {\n+                        self.check_for_common_items_in_impls(\n+                            impl1_def_id, impl2_def_id, overlap, false);\n+                        false\n+                    } else {\n+                        true\n                     }\n                 });\n+\n+                if used_to_be_allowed {\n+                    self.tcx.infer_ctxt().enter(|infcx| {\n+                        if let Some(overlap) =\n+                            traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id,\n+                                                      IntercrateMode::Fixed)\n+                        {\n+                            self.check_for_common_items_in_impls(\n+                                impl1_def_id, impl2_def_id, overlap, true);\n+                        }\n+                    });\n+                }\n             }\n         }\n     }\n@@ -100,4 +131,3 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }\n-"}, {"sha": "85b926a707db3da1c8694bd4f6a3fef707a8da3e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1268,15 +1268,23 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ))\n         }\n \n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), hir_id, .. }) => {\n-            let tables = tcx.typeck_tables_of(def_id);\n-            match tables.node_id_to_type(hir_id).sty {\n-                ty::TyClosure(closure_def_id, closure_substs) => {\n-                    assert_eq!(def_id, closure_def_id);\n-                    return closure_substs.closure_sig(closure_def_id, tcx);\n-                }\n-                ref t => bug!(\"closure with non-closure type: {:?}\", t),\n-            }\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+            // Closure signatures are not like other function\n+            // signatures and cannot be accessed through `fn_sig`. For\n+            // example, a closure signature excludes the `self`\n+            // argument. In any case they are embedded within the\n+            // closure type as part of the `ClosureSubsts`.\n+            //\n+            // To get\n+            // the signature of a closure, you should use the\n+            // `closure_sig` method on the `ClosureSubsts`:\n+            //\n+            //    closure_substs.closure_sig(def_id, tcx)\n+            //\n+            // or, inside of an inference context, you can use\n+            //\n+            //    infcx.closure_sig(def_id, closure_substs)\n+            bug!(\"to get the signature of a closure, use `closure_sig()` not `fn_sig()`\");\n         }\n \n         x => {"}, {"sha": "16b5216d58d43f6366f296a2b7fb1cfcb52bc311", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -269,6 +269,7 @@ pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n         lang_items.char_impl(),\n         lang_items.str_impl(),\n         lang_items.slice_impl(),\n+        lang_items.slice_u8_impl(),\n         lang_items.const_ptr_impl(),\n         lang_items.mut_ptr_impl(),\n     ];"}, {"sha": "0e25d639e45d8eddff2d6c14a5e68a802916b7f7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1802,6 +1802,7 @@ pub enum PrimitiveType {\n     RawPointer,\n     Reference,\n     Fn,\n+    Never,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Copy, Debug)]\n@@ -1843,6 +1844,7 @@ impl Type {\n             RawPointer(..) => Some(PrimitiveType::RawPointer),\n             BorrowedRef { type_: box Generic(..), .. } => Some(PrimitiveType::Reference),\n             BareFunction(..) => Some(PrimitiveType::Fn),\n+            Never => Some(PrimitiveType::Never),\n             _ => None,\n         }\n     }\n@@ -1891,6 +1893,7 @@ impl GetDefId for Type {\n                 Primitive(PrimitiveType::Tuple).def_id()\n             },\n             BareFunction(..) => Primitive(PrimitiveType::Fn).def_id(),\n+            Never => Primitive(PrimitiveType::Never).def_id(),\n             Slice(..) => Primitive(PrimitiveType::Slice).def_id(),\n             Array(..) => Primitive(PrimitiveType::Array).def_id(),\n             RawPointer(..) => Primitive(PrimitiveType::RawPointer).def_id(),\n@@ -1927,6 +1930,7 @@ impl PrimitiveType {\n             \"pointer\" => Some(PrimitiveType::RawPointer),\n             \"reference\" => Some(PrimitiveType::Reference),\n             \"fn\" => Some(PrimitiveType::Fn),\n+            \"never\" => Some(PrimitiveType::Never),\n             _ => None,\n         }\n     }\n@@ -1958,6 +1962,7 @@ impl PrimitiveType {\n             RawPointer => \"pointer\",\n             Reference => \"reference\",\n             Fn => \"fn\",\n+            Never => \"never\",\n         }\n     }\n \n@@ -2521,7 +2526,7 @@ pub struct Span {\n }\n \n impl Span {\n-    fn empty() -> Span {\n+    pub fn empty() -> Span {\n         Span {\n             filename: \"\".to_string(),\n             loline: 0, locol: 0,\n@@ -2892,6 +2897,7 @@ fn build_deref_target_impls(cx: &DocContext,\n             RawPointer => tcx.lang_items().const_ptr_impl(),\n             Reference => None,\n             Fn => None,\n+            Never => None,\n         };\n         if let Some(did) = did {\n             if !did.is_local() {"}, {"sha": "53c10d101d0c45f88fe1bbf9ed9076b7acdd26a0", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -425,15 +425,13 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n         Some(&(ref fqp, shortty)) => {\n             (fqp, shortty, repeat(\"../\").take(loc.len()).collect())\n         }\n-        None => match cache.external_paths.get(&did) {\n-            Some(&(ref fqp, shortty)) => {\n-                (fqp, shortty, match cache.extern_locations[&did.krate] {\n-                    (.., render::Remote(ref s)) => s.to_string(),\n-                    (.., render::Local) => repeat(\"../\").take(loc.len()).collect(),\n-                    (.., render::Unknown) => return None,\n-                })\n-            }\n-            None => return None,\n+        None => {\n+            let &(ref fqp, shortty) = cache.external_paths.get(&did)?;\n+            (fqp, shortty, match cache.extern_locations[&did.krate] {\n+                (.., render::Remote(ref s)) => s.to_string(),\n+                (.., render::Local) => repeat(\"../\").take(loc.len()).collect(),\n+                (.., render::Unknown) => return None,\n+            })\n         }\n     };\n     for component in &fqp[..fqp.len() - 1] {\n@@ -638,7 +636,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n             fmt::Display::fmt(t, f)?;\n             primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n))\n         }\n-        clean::Never => f.write_str(\"!\"),\n+        clean::Never => primitive_link(f, PrimitiveType::Never, \"!\"),\n         clean::RawPointer(m, ref t) => {\n             match **t {\n                 clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {"}, {"sha": "61de5f4bc4c4500e9155024cb9edcb179ddf53a4", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -65,6 +65,7 @@ r##\"<!DOCTYPE html>\n     {before_content}\n \n     <nav class=\"sidebar\">\n+        <div class=\"sidebar-menu\">&#9776;</div>\n         {logo}\n         {sidebar}\n     </nav>"}, {"sha": "7e5f9b4e31115ae9faec82b8bcf959cb8f80a14a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -421,9 +421,19 @@ impl ToJson for IndexItemFunctionType {\n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> =\n                     RefCell::new(Vec::new()));\n-thread_local!(static USED_ID_MAP: RefCell<FxHashMap<String, usize>> =\n+thread_local!(pub static USED_ID_MAP: RefCell<FxHashMap<String, usize>> =\n                     RefCell::new(init_ids()));\n \n+pub fn render_text<F: FnMut(RenderType) -> String>(mut render: F) -> (String, String) {\n+    // Save the state of USED_ID_MAP so it only gets updated once even\n+    // though we're rendering twice.\n+    let orig_used_id_map = USED_ID_MAP.with(|map| map.borrow().clone());\n+    let hoedown_output = render(RenderType::Hoedown);\n+    USED_ID_MAP.with(|map| *map.borrow_mut() = orig_used_id_map);\n+    let pulldown_output = render(RenderType::Pulldown);\n+    (hoedown_output, pulldown_output)\n+}\n+\n fn init_ids() -> FxHashMap<String, usize> {\n     [\n      \"main\",\n@@ -699,7 +709,10 @@ fn print_message(msg: &str, intro_msg: &mut bool, span: &Span, text: &str) {\n     println!(\"{}\", msg);\n }\n \n-fn render_difference(diff: &html_diff::Difference, intro_msg: &mut bool, span: &Span, text: &str) {\n+pub fn render_difference(diff: &html_diff::Difference,\n+                         intro_msg: &mut bool,\n+                         span: &Span,\n+                         text: &str) {\n     match *diff {\n         html_diff::Difference::NodeType { ref elem, ref opposite_elem } => {\n             print_message(&format!(\"    {} Types differ: expected: `{}`, found: `{}`\",\n@@ -1659,11 +1672,8 @@ impl<'a> Item<'a> {\n         let mut path = String::new();\n         let (krate, path) = if self.item.def_id.is_local() {\n             let path = PathBuf::from(&self.item.source.filename);\n-            if let Some(path) = self.cx.shared.local_sources.get(&path) {\n-                (&self.cx.shared.layout.krate, path)\n-            } else {\n-                return None;\n-            }\n+            let path = self.cx.shared.local_sources.get(&path)?;\n+            (&self.cx.shared.layout.krate, path)\n         } else {\n             // Macros from other libraries get special filenames which we can\n             // safely ignore.\n@@ -1853,12 +1863,7 @@ fn render_markdown(w: &mut fmt::Formatter,\n                    prefix: &str,\n                    scx: &SharedContext)\n                    -> fmt::Result {\n-    // Save the state of USED_ID_MAP so it only gets updated once even\n-    // though we're rendering twice.\n-    let orig_used_id_map = USED_ID_MAP.with(|map| map.borrow().clone());\n-    let hoedown_output = format!(\"{}\", Markdown(md_text, RenderType::Hoedown));\n-    USED_ID_MAP.with(|map| *map.borrow_mut() = orig_used_id_map);\n-    let pulldown_output = format!(\"{}\", Markdown(md_text, RenderType::Pulldown));\n+    let (hoedown_output, pulldown_output) = render_text(|ty| format!(\"{}\", Markdown(md_text, ty)));\n     let mut differences = html_diff::get_differences(&pulldown_output, &hoedown_output);\n     differences.retain(|s| {\n         match *s {\n@@ -3542,6 +3547,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n         let cx = self.cx;\n         let it = self.item;\n         let parentlen = cx.current.len() - if it.is_mod() {1} else {0};\n+        let mut should_close = false;\n \n         if it.is_struct() || it.is_trait() || it.is_primitive() || it.is_union()\n             || it.is_enum() || it.is_mod() || it.is_typedef()\n@@ -3575,6 +3581,8 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                 }\n             }\n \n+            write!(fmt, \"<div class=\\\"sidebar-elems\\\">\")?;\n+            should_close = true;\n             match it.inner {\n                 clean::StructItem(ref s) => sidebar_struct(fmt, it, s)?,\n                 clean::TraitItem(ref t) => sidebar_trait(fmt, it, t)?,\n@@ -3625,6 +3633,10 @@ impl<'a> fmt::Display for Sidebar<'a> {\n             write!(fmt, \"<script defer src=\\\"{path}sidebar-items.js\\\"></script>\",\n                    path = relpath)?;\n         }\n+        if should_close {\n+            // Closes sidebar-elems div.\n+            write!(fmt, \"</div>\")?;\n+        }\n \n         Ok(())\n     }"}, {"sha": "06e9cbbdf9a71118c65cf6b9510f66b96c499215", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -106,6 +106,30 @@\n         return (elem.offsetParent === null)\n     }\n \n+    function showSidebar() {\n+        var elems = document.getElementsByClassName(\"sidebar-elems\")[0];\n+        if (elems) {\n+            elems.style.display = \"block\";\n+        }\n+        var sidebar = document.getElementsByClassName('sidebar')[0];\n+        sidebar.style.position = 'fixed';\n+        sidebar.style.width = '100%';\n+        sidebar.style.marginLeft = '0';\n+        document.getElementsByTagName(\"body\")[0].style.marginTop = '45px';\n+    }\n+\n+    function hideSidebar() {\n+        var elems = document.getElementsByClassName(\"sidebar-elems\")[0];\n+        if (elems) {\n+            elems.style.display = \"\";\n+        }\n+        var sidebar = document.getElementsByClassName('sidebar')[0];\n+        sidebar.style.position = '';\n+        sidebar.style.width = '';\n+        sidebar.style.marginLeft = '';\n+        document.getElementsByTagName(\"body\")[0].style.marginTop = '';\n+    }\n+\n     // used for special search precedence\n     var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n \n@@ -119,8 +143,7 @@\n             map(function(s) {\n                 var pair = s.split(\"=\");\n                 params[decodeURIComponent(pair[0])] =\n-                    typeof pair[1] === \"undefined\" ?\n-                            null : decodeURIComponent(pair[1]);\n+                    typeof pair[1] === \"undefined\" ? null : decodeURIComponent(pair[1]);\n             });\n         return params;\n     }\n@@ -131,6 +154,8 @@\n     }\n \n     function highlightSourceLines(ev) {\n+        // If we're in mobile mode, we should add the sidebar in any case.\n+        hideSidebar();\n         var search = document.getElementById(\"search\");\n         var i, from, to, match = window.location.hash.match(/^#?(\\d+)(?:-(\\d+))?$/);\n         if (match) {\n@@ -1460,7 +1485,7 @@\n \n     // delayed sidebar rendering.\n     function initSidebarItems(items) {\n-        var sidebar = document.getElementsByClassName('sidebar')[0];\n+        var sidebar = document.getElementsByClassName('sidebar-elems')[0];\n         var current = window.sidebarCurrent;\n \n         function block(shortty, longty) {\n@@ -1822,6 +1847,30 @@\n             }\n         };\n     }\n+\n+    var params = getQueryStringParams();\n+    if (params && params.search) {\n+        addClass(document.getElementById(\"main\"), \"hidden\");\n+        var search = document.getElementById(\"search\");\n+        removeClass(search, \"hidden\");\n+        search.innerHTML = '<h3 style=\"text-align: center;\">Loading search results...</h3>';\n+    }\n+\n+    var sidebar_menu = document.getElementsByClassName(\"sidebar-menu\")[0];\n+    if (sidebar_menu) {\n+        sidebar_menu.onclick = function() {\n+            var sidebar = document.getElementsByClassName('sidebar')[0];\n+            if (sidebar.style.position === \"fixed\") {\n+                hideSidebar();\n+            } else {\n+                showSidebar();\n+            }\n+        };\n+    }\n+\n+    window.onresize = function() {\n+        hideSidebar();\n+    };\n }());\n \n // Sets the focus on the search bar at the top of the page"}, {"sha": "99a0f8c3fb1ada0f9762f34ceec9319bc743bee0", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 55, "deletions": 39, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -179,7 +179,6 @@ nav.sub {\n \ttop: 0;\n \theight: 100vh;\n \toverflow: auto;\n-\tz-index: 1;\n }\n \n .sidebar .current {\n@@ -209,7 +208,7 @@ nav.sub {\n .sidebar .version {\n \tfont-size: 15px;\n \ttext-align: center;\n-\tborder-bottom: #DDDDDD 1px solid;\n+\tborder-bottom: 1px solid;\n \toverflow-wrap: break-word;\n \tword-wrap: break-word; /* deprecated */\n \tword-break: break-word; /* Chrome, non-standard */\n@@ -248,8 +247,8 @@ nav.sub {\n }\n \n .sidebar-title {\n-\tborder-top: 1px solid #777;\n-\tborder-bottom: 1px solid #777;\n+\tborder-top: 1px solid;\n+\tborder-bottom: 1px solid;\n \ttext-align: center;\n \tfont-size: 17px;\n \tmargin-bottom: 5px;\n@@ -264,6 +263,10 @@ nav.sub {\n \twidth: 100%;\n }\n \n+.sidebar-menu {\n+\tdisplay: none;\n+}\n+\n .content {\n \tpadding: 15px 0;\n }\n@@ -273,9 +276,19 @@ nav.sub {\n \toverflow: auto;\n \tpadding-left: 0;\n }\n+\n #search {\n \tmargin-left: 230px;\n+\tposition: relative;\n }\n+\n+#results {\n+\tposition: absolute;\n+\tright: 0;\n+\tleft: 0;\n+\toverflow: auto;\n+}\n+\n .content pre.line-numbers {\n \tfloat: left;\n \tborder: none;\n@@ -355,7 +368,6 @@ h4 > code, h3 > code, .invisible > code {\n }\n \n .invisible {\n-\tbackground: rgba(0, 0, 0, 0);\n \twidth: 100%;\n \tdisplay: inline-block;\n }\n@@ -435,7 +447,6 @@ h4 > code, h3 > code, .invisible > code {\n .content .fn .where,\n .content .where.fmt-newline {\n \tdisplay: block;\n-\tcolor: #4E4C4C;\n \tfont-size: 0.8em;\n }\n \n@@ -529,7 +540,6 @@ a {\n }\n \n .search-input:focus {\n-\tborder-color: #66afe9;\n \tborder-radius: 2px;\n \tborder: 0;\n \toutline: 0;\n@@ -551,7 +561,8 @@ a {\n .content .search-results td:first-child a { padding-right: 10px; }\n \n tr.result span.primitive::after {\n-\tcontent: ' (primitive type)'; font-style: italic; color: black;\n+\tcontent: ' (primitive type)';\n+\tfont-style: italic;\n }\n \n body.blur > :not(#help) {\n@@ -688,7 +699,6 @@ a.test-arrow:hover{\n \tfont-weight: 300;\n \tposition: absolute;\n \tleft: -23px;\n-\tcolor: #999;\n \ttop: 0;\n }\n \n@@ -814,7 +824,7 @@ span.since {\n \t\tposition: static;\n \t}\n \n-\t.sidebar .location {\n+\t.sidebar > .location {\n \t\tfloat: right;\n \t\tmargin: 0px;\n \t\tmargin-top: 2px;\n@@ -834,16 +844,33 @@ span.since {\n \t\tmargin-top: 5px;\n \t\tmargin-bottom: 5px;\n \t\tfloat: left;\n+\t\tmargin-left: 50px;\n \t}\n \n-\tnav.sub {\n-\t\tmargin: 0 auto;\n+\t.sidebar-menu {\n+\t\tposition: absolute;\n+\t\tfont-size: 2rem;\n+\t\tcursor: pointer;\n+\t\tmargin-top: 2px;\n+\t\tdisplay: block;\n \t}\n \n-\t.sidebar .block {\n+\t.sidebar-elems {\n+\t\tbackground-color: #F1F1F1;\n+\t\tposition: fixed;\n+\t\tz-index: 1;\n+\t\tleft: 0;\n+\t\ttop: 45px;\n+\t\tbottom: 0;\n+\t\toverflow-y: auto;\n+\t\tborder-right: 1px solid #000;\n \t\tdisplay: none;\n \t}\n \n+\tnav.sub {\n+\t\tmargin: 0 auto;\n+\t}\n+\n \t.content {\n \t\tmargin-left: 0px;\n \t}\n@@ -895,8 +922,6 @@ span.since {\n .tooltip .tooltiptext {\n \twidth: 120px;\n \tdisplay: none;\n-\tbackground-color: black;\n-\tcolor: #fff;\n \ttext-align: center;\n \tpadding: 5px 3px;\n \tborder-radius: 6px;\n@@ -918,13 +943,10 @@ span.since {\n \tmargin-top: -5px;\n \tborder-width: 5px;\n \tborder-style: solid;\n-\tborder-color: transparent black transparent transparent;\n }\n \n .important-traits .tooltip .tooltiptext {\n-\tbackground-color: white;\n-\tcolor: black;\n-\tborder: 1px solid #000;\n+\tborder: 1px solid;\n }\n \n pre.rust {\n@@ -944,22 +966,21 @@ pre.rust {\n \tfloat: left;\n \twidth: 33.3%;\n \ttext-align: center;\n-\tborder-bottom: 1px solid #ccc;\n+\tborder-bottom: 1px solid;\n \tfont-size: 18px;\n \tcursor: pointer;\n }\n \n #titles > div.selected {\n-\tborder-bottom: 3px solid #0078ee;\n+\tborder-bottom: 3px solid;\n }\n \n #titles > div:hover {\n-\tborder-bottom: 3px solid #0089ff;\n+\tborder-bottom: 3px solid;\n }\n \n #titles > div > div.count {\n \tdisplay: inline-block;\n-\tcolor: #888;\n \tfont-size: 16px;\n }\n \n@@ -974,11 +995,18 @@ h4 > .important-traits {\n \ttop: 2px;\n }\n \n+@media (max-width: 700px) {\n+\th4 > .important-traits {\n+\t\tposition: absolute;\n+\t\tleft: -22px;\n+\t\ttop: 24px;\n+\t}\n+}\n+\n .modal {\n \tposition: fixed;\n \twidth: 100vw;\n \theight: 100vh;\n-\tbackground-color: rgba(0,0,0,0.3);\n \tz-index: 10000;\n \ttop: 0;\n \tleft: 0;\n@@ -988,13 +1016,12 @@ h4 > .important-traits {\n \tdisplay: block;\n \tmax-width: 60%;\n \tmin-width: 200px;\n-\tbackground-color: #eee;\n \tpadding: 8px;\n \ttop: 40%;\n \tposition: absolute;\n \tleft: 50%;\n \ttransform: translate(-50%, -40%);\n-\tborder: 1px solid #999;\n+\tborder: 1px solid;\n \tborder-radius: 4px;\n \tborder-top-right-radius: 0;\n }\n@@ -1021,35 +1048,24 @@ h3.important {\n \tright: -25px;\n \ttop: -1px;\n \tfont-size: 18px;\n-\tbackground-color: #eee;\n \twidth: 25px;\n \tpadding-right: 2px;\n \tborder-top-right-radius: 5px;\n \tborder-bottom-right-radius: 5px;\n \ttext-align: center;\n-\tborder: 1px solid #999;\n+\tborder: 1px solid;\n \tborder-right: 0;\n \tcursor: pointer;\n }\n \n-.modal-content > .close:hover {\n-\tbackground-color: #ff1f1f;\n-\tcolor: white;\n-}\n-\n .modal-content > .whiter {\n \theight: 25px;\n \tposition: absolute;\n \twidth: 3px;\n-\tbackground-color: #eee;\n \tright: -2px;\n \ttop: 0px;\n }\n \n-.modal-content > .close:hover + .whiter {\n-\tbackground-color: #ff1f1f;\n-}\n-\n #main > div.important-traits {\n \tposition: absolute;\n \tleft: -24px;\n@@ -1060,4 +1076,4 @@ h3.important {\n \tposition: absolute;\n \tleft: -42px;\n \tmargin-top: 2px;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "5cace837a5557eab7ca296c728a8a86a28ecd3c3", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -31,6 +31,10 @@ h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.t\n \tbackground-color: white;\n }\n \n+.invisible {\n+\tbackground: rgba(0, 0, 0, 0);\n+}\n+\n .docblock code, .docblock-short code {\n \tbackground-color: #F5F5F5;\n }\n@@ -56,6 +60,15 @@ pre {\n \tcolor: #333;\n }\n \n+.sidebar .version {\n+\tborder-bottom-color: #DDD;\n+}\n+\n+.sidebar-title {\n+\tborder-top-color: #777;\n+\tborder-bottom-color: #777;\n+}\n+\n .block a:hover {\n \tbackground: #F5F5F5;\n }\n@@ -89,6 +102,12 @@ pre {\n \tbackground: #FDFFD3;\n }\n \n+.content .method .where,\n+.content .fn .where,\n+.content .where.fmt-newline {\n+\tcolor: #4E4C4C;\n+}\n+\n .content .highlighted {\n \tcolor: #000 !important;\n \tbackground-color: #ccc;\n@@ -152,12 +171,20 @@ a.test-arrow {\n \tcolor: #f5f5f5;\n }\n \n+.collapse-toggle {\n+\tcolor: #999;\n+}\n+\n .search-input {\n \tcolor: #555;\n \tbox-shadow: 0 0 0 1px #e0e0e0, 0 0 0 2px transparent;\n \tbackground-color: white;\n }\n \n+.search-input:focus {\n+\tborder-color: #66afe9;\n+}\n+\n .stab.unstable { background: #FFF5D6; border-color: #FFC600; }\n .stab.deprecated { background: #F3DFFF; border-color: #7F0087; }\n .stab.portability { background: #C4ECFF; border-color: #7BA5DB; }\n@@ -176,6 +203,10 @@ a.test-arrow {\n \tcolor: grey;\n }\n \n+tr.result span.primitive::after {\n+\tcolor: black;\n+}\n+\n .line-numbers :target { background-color: transparent; }\n \n /* Code highlighting */\n@@ -241,3 +272,61 @@ pre.ignore:hover, .information:hover + pre.ignore {\n .search-failed > a {\n \tcolor: #0089ff;\n }\n+\n+.tooltip .tooltiptext {\n+\tbackground-color: black;\n+\tcolor: #fff;\n+}\n+\n+.tooltip .tooltiptext::after {\n+\tborder-color: transparent black transparent transparent;\n+}\n+\n+.important-traits .tooltip .tooltiptext {\n+\tbackground-color: white;\n+\tcolor: black;\n+\tborder-color: black;\n+}\n+\n+#titles > div {\n+\tborder-bottom-color:  #ccc;\n+}\n+\n+#titles > div.selected {\n+\tborder-bottom-color: #0078ee;\n+}\n+\n+#titles > div:hover {\n+\tborder-bottom-color: #0089ff;\n+}\n+\n+#titles > div > div.count {\n+\tcolor: #888;\n+}\n+\n+.modal {\n+\tbackground-color: rgba(0,0,0,0.3);\n+}\n+\n+.modal-content {\n+\tbackground-color: #eee;\n+\tborder-color: #999;\n+}\n+\n+.modal-content > .close {\n+\tbackground-color: #eee;\n+\tborder-color: #999;\n+}\n+\n+.modal-content > .close:hover {\n+\tbackground-color: #ff1f1f;\n+\tcolor: white;\n+}\n+\n+.modal-content > .whiter {\n+\tbackground-color: #eee;\n+}\n+\n+.modal-content > .close:hover + .whiter {\n+\tbackground-color: #ff1f1f;\n+}"}, {"sha": "9b94e9918f85096d6191383eda844c64d3169cdd", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -19,10 +19,15 @@ use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::Externs;\n use syntax::codemap::DUMMY_SP;\n \n+use clean::Span;\n+\n use externalfiles::{ExternalHtml, LoadStringError, load_string};\n \n-use html::render::reset_ids;\n+use html_diff;\n+\n+use html::render::{render_text, reset_ids};\n use html::escape::Escape;\n+use html::render::render_difference;\n use html::markdown;\n use html::markdown::{Markdown, MarkdownWithToc, find_testable_code, old_find_testable_code};\n use html::markdown::RenderType;\n@@ -52,6 +57,10 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n               external_html: &ExternalHtml, include_toc: bool,\n               render_type: RenderType) -> isize {\n+    // Span used for markdown hoedown/pulldown differences.\n+    let mut span = Span::empty();\n+    span.filename = input.to_owned();\n+\n     let input_p = Path::new(input);\n     output.push(input_p.file_stem().unwrap());\n     output.set_extension(\"html\");\n@@ -89,12 +98,36 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n \n     reset_ids(false);\n \n-    let rendered = if include_toc {\n-        format!(\"{}\", MarkdownWithToc(text, render_type))\n+    let (hoedown_output, pulldown_output) = if include_toc {\n+        // Save the state of USED_ID_MAP so it only gets updated once even\n+        // though we're rendering twice.\n+        render_text(|ty| format!(\"{}\", MarkdownWithToc(text, ty)))\n     } else {\n-        format!(\"{}\", Markdown(text, render_type))\n+        // Save the state of USED_ID_MAP so it only gets updated once even\n+        // though we're rendering twice.\n+        render_text(|ty| format!(\"{}\", Markdown(text, ty)))\n     };\n \n+    let mut differences = html_diff::get_differences(&pulldown_output, &hoedown_output);\n+    differences.retain(|s| {\n+        match *s {\n+            html_diff::Difference::NodeText { ref elem_text,\n+                                              ref opposite_elem_text,\n+                                              .. }\n+                if elem_text.split_whitespace().eq(opposite_elem_text.split_whitespace()) => {\n+                    false\n+            }\n+            _ => true,\n+        }\n+    });\n+\n+    if !differences.is_empty() {\n+        let mut intro_msg = false;\n+        for diff in differences {\n+            render_difference(&diff, &mut intro_msg, &span, text);\n+        }\n+    }\n+\n     let err = write!(\n         &mut out,\n         r#\"<!DOCTYPE html>\n@@ -126,16 +159,16 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n         css = css,\n         in_header = external_html.in_header,\n         before_content = external_html.before_content,\n-        text = rendered,\n+        text = if render_type == RenderType::Pulldown { pulldown_output } else { hoedown_output },\n         after_content = external_html.after_content,\n-        );\n+    );\n \n     match err {\n         Err(e) => {\n             eprintln!(\"rustdoc: cannot write to `{}`: {}\", output.display(), e);\n             6\n         }\n-        Ok(_) => 0\n+        Ok(_) => 0,\n     }\n }\n "}, {"sha": "efdad7d801ab5ac83d074bf569ce572642647094", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1052,10 +1052,7 @@ impl Json {\n     pub fn find_path<'a>(&'a self, keys: &[&str]) -> Option<&'a Json>{\n         let mut target = self;\n         for key in keys {\n-            match target.find(*key) {\n-                Some(t) => { target = t; },\n-                None => return None\n-            }\n+            target = target.find(*key)?;\n         }\n         Some(target)\n     }"}, {"sha": "7f0e5a8d2aa22552810848e20befbd71de809a28", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1152,13 +1152,9 @@ impl<'a, T, S> Iterator for Intersection<'a, T, S>\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            match self.iter.next() {\n-                None => return None,\n-                Some(elt) => {\n-                    if self.other.contains(elt) {\n-                        return Some(elt);\n-                    }\n-                }\n+            let elt = self.iter.next()?;\n+            if self.other.contains(elt) {\n+                return Some(elt);\n             }\n         }\n     }\n@@ -1202,13 +1198,9 @@ impl<'a, T, S> Iterator for Difference<'a, T, S>\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            match self.iter.next() {\n-                None => return None,\n-                Some(elt) => {\n-                    if !self.other.contains(elt) {\n-                        return Some(elt);\n-                    }\n-                }\n+            let elt = self.iter.next()?;\n+            if !self.other.contains(elt) {\n+                return Some(elt);\n             }\n         }\n     }"}, {"sha": "f40aed2478a17845c0920c9c55f3859b3f9f9fb1", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 133, "deletions": 1, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -211,6 +211,115 @@ pub struct DirBuilder {\n     recursive: bool,\n }\n \n+/// Read the entire contents of a file into a bytes vector.\n+///\n+/// This is a convenience function for using [`File::open`] and [`read_to_end`]\n+/// with fewer imports and without an intermediate variable.\n+///\n+/// [`File::open`]: struct.File.html#method.open\n+/// [`read_to_end`]: ../io/trait.Read.html#method.read_to_end\n+///\n+/// # Errors\n+///\n+/// This function will return an error if `path` does not already exist.\n+/// Other errors may also be returned according to [`OpenOptions::open`].\n+///\n+/// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n+///\n+/// It will also return an error if it encounters while reading an error\n+/// of a kind other than [`ErrorKind::Interrupted`].\n+///\n+/// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// #![feature(fs_read_write)]\n+///\n+/// use std::fs;\n+/// use std::net::SocketAddr;\n+///\n+/// # fn foo() -> Result<(), Box<std::error::Error + 'static>> {\n+/// let foo: SocketAddr = String::from_utf8_lossy(&fs::read(\"address.txt\")?).parse()?;\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[unstable(feature = \"fs_read_write\", issue = \"46588\")]\n+pub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {\n+    let mut bytes = Vec::new();\n+    File::open(path)?.read_to_end(&mut bytes)?;\n+    Ok(bytes)\n+}\n+\n+/// Read the entire contents of a file into a string.\n+///\n+/// This is a convenience function for using [`File::open`] and [`read_to_string`]\n+/// with fewer imports and without an intermediate variable.\n+///\n+/// [`File::open`]: struct.File.html#method.open\n+/// [`read_to_string`]: ../io/trait.Read.html#method.read_to_string\n+///\n+/// # Errors\n+///\n+/// This function will return an error if `path` does not already exist.\n+/// Other errors may also be returned according to [`OpenOptions::open`].\n+///\n+/// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n+///\n+/// It will also return an error if it encounters while reading an error\n+/// of a kind other than [`ErrorKind::Interrupted`],\n+/// or if the contents of the file are not valid UTF-8.\n+///\n+/// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// #![feature(fs_read_write)]\n+///\n+/// use std::fs;\n+/// use std::net::SocketAddr;\n+///\n+/// # fn foo() -> Result<(), Box<std::error::Error + 'static>> {\n+/// let foo: SocketAddr = fs::read_string(\"address.txt\")?.parse()?;\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[unstable(feature = \"fs_read_write\", issue = \"46588\")]\n+pub fn read_string<P: AsRef<Path>>(path: P) -> io::Result<String> {\n+    let mut string = String::new();\n+    File::open(path)?.read_to_string(&mut string)?;\n+    Ok(string)\n+}\n+\n+/// Write a slice as the entire contents of a file.\n+///\n+/// This function will create a file if it does not exist,\n+/// and will entirely replace its contents if it does.\n+///\n+/// This is a convenience function for using [`File::create`] and [`write_all`]\n+/// with fewer imports.\n+///\n+/// [`File::create`]: struct.File.html#method.create\n+/// [`write_all`]: ../io/trait.Write.html#method.write_all\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// #![feature(fs_read_write)]\n+///\n+/// use std::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// fs::write(\"foo.txt\", b\"Lorem ipsum\")?;\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[unstable(feature = \"fs_read_write\", issue = \"46588\")]\n+pub fn write<P: AsRef<Path>, C: AsRef<[u8]>>(path: P, contents: C) -> io::Result<()> {\n+    File::create(path)?.write_all(contents.as_ref())\n+}\n+\n impl File {\n     /// Attempts to open a file in read-only mode.\n     ///\n@@ -1912,7 +2021,9 @@ mod tests {\n     ) }\n \n     #[cfg(unix)]\n-    macro_rules! error { ($e:expr, $s:expr) => (\n+    macro_rules! error { ($e:expr, $s:expr) => ( error_contains!($e, $s) ) }\n+\n+    macro_rules! error_contains { ($e:expr, $s:expr) => (\n         match $e {\n             Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n             Err(ref err) => assert!(err.to_string().contains($s),\n@@ -2921,6 +3032,27 @@ mod tests {\n         assert!(v == &bytes[..]);\n     }\n \n+    #[test]\n+    fn write_then_read() {\n+        let mut bytes = [0; 1024];\n+        StdRng::new().unwrap().fill_bytes(&mut bytes);\n+\n+        let tmpdir = tmpdir();\n+\n+        check!(fs::write(&tmpdir.join(\"test\"), &bytes[..]));\n+        let v = check!(fs::read(&tmpdir.join(\"test\")));\n+        assert!(v == &bytes[..]);\n+\n+        check!(fs::write(&tmpdir.join(\"not-utf8\"), &[0xFF]));\n+        error_contains!(fs::read_string(&tmpdir.join(\"not-utf8\")),\n+                        \"stream did not contain valid UTF-8\");\n+\n+        let s = \"\ud800\udc41\ud800\udc13\ud800\udc20\ud800\udc34\ud800\udc0d\";\n+        check!(fs::write(&tmpdir.join(\"utf8\"), s.as_bytes()));\n+        let string = check!(fs::read_string(&tmpdir.join(\"utf8\")));\n+        assert_eq!(string, s);\n+    }\n+\n     #[test]\n     fn file_try_clone() {\n         let tmpdir = tmpdir();"}, {"sha": "9c401d7663fd62d3d7528ec1ccb7461f73fd75f0", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -2019,10 +2019,9 @@ impl<R: Read> Iterator for Chars<R> {\n     type Item = result::Result<char, CharsError>;\n \n     fn next(&mut self) -> Option<result::Result<char, CharsError>> {\n-        let first_byte = match read_one_byte(&mut self.inner) {\n-            None => return None,\n-            Some(Ok(b)) => b,\n-            Some(Err(e)) => return Some(Err(CharsError::Other(e))),\n+        let first_byte = match read_one_byte(&mut self.inner)? {\n+            Ok(b) => b,\n+            Err(e) => return Some(Err(CharsError::Other(e))),\n         };\n         let width = core_str::utf8_char_width(first_byte);\n         if width == 1 { return Some(Ok(first_byte as char)) }"}, {"sha": "12e6231136e16d96ff272d81bda466a55deef3cb", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -260,6 +260,7 @@\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n+#![feature(fs_read_write)]\n #![feature(fixed_size_array)]\n #![feature(float_from_str_radix)]\n #![feature(fn_traits)]"}, {"sha": "de46fedaebb76e4e8c328c09d2304955dcf931a9", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -282,9 +282,34 @@ pub mod builtin {\n \n     /// Unconditionally causes compilation to fail with the given error message when encountered.\n     ///\n-    /// For more information, see the [RFC].\n+    /// This macro should be used when a crate uses a conditional compilation strategy to provide\n+    /// better error messages for errornous conditions.\n     ///\n-    /// [RFC]: https://github.com/rust-lang/rfcs/blob/master/text/1695-add-error-macro.md\n+    /// # Examples\n+    ///\n+    /// Two such examples are macros and `#[cfg]` environments.\n+    ///\n+    /// Emit better compiler error if a macro is passed invalid values.\n+    ///\n+    /// ```compile_fail\n+    /// macro_rules! give_me_foo_or_bar {\n+    ///     (foo) => {};\n+    ///     (bar) => {};\n+    ///     ($x:ident) => {\n+    ///         compile_error!(\"This macro only accepts `foo` or `bar`\");\n+    ///     }\n+    /// }\n+    ///\n+    /// give_me_foo_or_bar!(neither);\n+    /// // ^ will fail at compile time with message \"This macro only accepts `foo` or `bar`\"\n+    /// ```\n+    ///\n+    /// Emit compiler error if one of a number of features isn't available.\n+    ///\n+    /// ```compile_fail\n+    /// #[cfg(not(any(feature = \"foo\", feature = \"bar\")))]\n+    /// compile_error!(\"Either feature \\\"foo\\\" or \\\"bar\\\" must be enabled for this crate.\")\n+    /// ```\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n     #[macro_export]\n     macro_rules! compile_error { ($msg:expr) => ({ /* compiler built-in */ }) }\n@@ -606,7 +631,7 @@ pub mod builtin {\n     #[macro_export]\n     macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n \n-    /// Boolean evaluation of configuration flags.\n+    /// Boolean evaluation of configuration flags, at compile-time.\n     ///\n     /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n     /// boolean expression evaluation of configuration flags. This frequently"}, {"sha": "9f7125fb935f713b64b0d9b0febf5959e0efbe40", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -170,11 +170,7 @@ impl<'a> Parser<'a> {\n                 return None;\n             }\n \n-            let octet = self.read_number(10, 3, 0x100).map(|n| n as u8);\n-            match octet {\n-                Some(d) => bs[i] = d,\n-                None => return None,\n-            };\n+            bs[i] = self.read_number(10, 3, 0x100).map(|n| n as u8)?;\n             i += 1;\n         }\n         Some(Ipv4Addr::new(bs[0], bs[1], bs[2], bs[3]))"}, {"sha": "a456e4663418500b8ffbfa44357eaea4018c19fd", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -67,6 +67,134 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_bool { }\n \n+#[doc(primitive = \"never\")]\n+//\n+/// The `!` type, also called \"never\".\n+///\n+/// `!` represents the type of computations which never resolve to any value at all. For example,\n+/// the [`exit`] function `fn exit(code: i32) -> !` exits the process without ever returning, and\n+/// so returns `!`.\n+///\n+/// `break`, `continue` and `return` expressions also have type `!`. For example we are allowed to\n+/// write:\n+///\n+/// ```\n+/// #![feature(never_type)]\n+/// # fn foo() -> u32 {\n+/// let x: ! = {\n+///     return 123\n+/// };\n+/// # }\n+/// ```\n+///\n+/// Although the `let` is pointless here, it illustrates the meaning of `!`. Since `x` is never\n+/// assigned a value (because `return` returns from the entire function), `x` can be given type\n+/// `!`. We could also replace `return 123` with a `panic!` or a never-ending `loop` and this code\n+/// would still be valid.\n+///\n+/// A more realistic usage of `!` is in this code:\n+///\n+/// ```\n+/// # fn get_a_number() -> Option<u32> { None }\n+/// # loop {\n+/// let num: u32 = match get_a_number() {\n+///     Some(num) => num,\n+///     None => break,\n+/// };\n+/// # }\n+/// ```\n+///\n+/// Both match arms must produce values of type [`u32`], but since `break` never produces a value\n+/// at all we know it can never produce a value which isn't a [`u32`]. This illustrates another\n+/// behaviour of the `!` type - expressions with type `!` will coerce into any other type.\n+///\n+/// [`u32`]: primitive.str.html\n+/// [`exit`]: process/fn.exit.html\n+///\n+/// # `!` and generics\n+///\n+/// The main place you'll see `!` used explicitly is in generic code. Consider the [`FromStr`]\n+/// trait:\n+///\n+/// ```\n+/// trait FromStr: Sized {\n+///     type Err;\n+///     fn from_str(s: &str) -> Result<Self, Self::Err>;\n+/// }\n+/// ```\n+///\n+/// When implementing this trait for [`String`] we need to pick a type for [`Err`]. And since\n+/// converting a string into a string will never result in an error, the appropriate type is `!`.\n+/// (Currently the type actually used is an enum with no variants, though this is only because `!`\n+/// was added to Rust at a later date and it may change in the future). With an [`Err`] type of\n+/// `!`, if we have to call [`String::from_str`] for some reason the result will be a\n+/// [`Result<String, !>`] which we can unpack like this:\n+///\n+/// ```ignore (string-from-str-error-type-is-not-never-yet)\n+/// // NOTE: This does not work today!\n+/// let Ok(s) = String::from_str(\"hello\");\n+/// ```\n+///\n+/// Since the [`Err`] variant contains a `!`, it can never occur. So we can exhaustively match on\n+/// [`Result<T, !>`] by just taking the [`Ok`] variant. This illustrates another behaviour of `!` -\n+/// it can be used to \"delete\" certain enum variants from generic types like `Result`.\n+///\n+/// [`String::from_str`]: str/trait.FromStr.html#tymethod.from_str\n+/// [`Result<String, !>`]: result/enum.Result.html\n+/// [`Result<T, !>`]: result/enum.Result.html\n+/// [`Ok`]: result/enum.Result.html#variant.Ok\n+/// [`String`]: string/struct.String.html\n+/// [`Err`]: result/enum.Result.html#variant.Err\n+/// [`FromStr`]: str/trait.FromStr.html\n+///\n+/// # `!` and traits\n+///\n+/// When writing your own traits, `!` should have an `impl` whenever there is an obvious `impl`\n+/// which doesn't `panic!`. As is turns out, most traits can have an `impl` for `!`. Take [`Debug`]\n+/// for example:\n+///\n+/// ```\n+/// # #![feature(never_type)]\n+/// # use std::fmt;\n+/// # trait Debug {\n+/// # fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result;\n+/// # }\n+/// impl Debug for ! {\n+///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+///         *self\n+///     }\n+/// }\n+/// ```\n+///\n+/// Once again we're using `!`'s ability to coerce into any other type, in this case\n+/// [`fmt::Result`]. Since this method takes a `&!` as an argument we know that it can never be\n+/// called (because there is no value of type `!` for it to be called with). Writing `*self`\n+/// essentially tells the compiler \"We know that this code can never be run, so just treat the\n+/// entire function body has having type [`fmt::Result`]\". This pattern can be used a lot when\n+/// implementing traits for `!`. Generally, any trait which only has methods which take a `self`\n+/// parameter should have such as impl.\n+///\n+/// On the other hand, one trait which would not be appropriate to implement is [`Default`]:\n+///\n+/// ```\n+/// trait Default {\n+///     fn default() -> Self;\n+/// }\n+/// ```\n+///\n+/// Since `!` has no values, it has no default value either. It's true that we could write an\n+/// `impl` for this which simply panics, but the same is true for any type (we could `impl\n+/// Default` for (eg.) [`File`] by just making [`default()`] panic.)\n+///\n+/// [`fmt::Result`]: fmt/type.Result.html\n+/// [`File`]: fs/struct.File.html\n+/// [`Debug`]: fmt/trait.Debug.html\n+/// [`Default`]: default/trait.Default.html\n+/// [`default()`]: default/trait.Default.html#tymethod.default\n+///\n+#[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n+mod prim_never { }\n+\n #[doc(primitive = \"char\")]\n //\n /// A character type."}, {"sha": "cb249af4254083f57363afdc7f860cca846f6e49", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -255,10 +255,7 @@ pub mod guard {\n \n     pub unsafe fn init() -> Option<usize> {\n         let psize = os::page_size();\n-        let mut stackaddr = match get_stack_start() {\n-            Some(addr) => addr,\n-            None => return None,\n-        };\n+        let mut stackaddr = get_stack_start()?;\n \n         // Ensure stackaddr is page aligned! A parent process might\n         // have reset RLIMIT_STACK to be non-page aligned. The"}, {"sha": "c70b39995ebb0c45d3ae91a0c2959518baa79054", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -136,10 +136,7 @@ impl Iterator for LookupHost {\n     fn next(&mut self) -> Option<SocketAddr> {\n         loop {\n             unsafe {\n-                let cur = match self.cur.as_ref() {\n-                    None => return None,\n-                    Some(c) => c,\n-                };\n+                let cur = self.cur.as_ref()?;\n                 self.cur = cur.ai_next;\n                 match sockaddr_to_addr(mem::transmute(cur.ai_addr),\n                                        cur.ai_addrlen as usize)"}, {"sha": "b2fc559bb37f2954630fb19adbf6cffd956adfd8", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -578,10 +578,7 @@ impl Wtf8 {\n     fn next_surrogate(&self, mut pos: usize) -> Option<(usize, u16)> {\n         let mut iter = self.bytes[pos..].iter();\n         loop {\n-            let b = match iter.next() {\n-                None => return None,\n-                Some(&b) => b,\n-            };\n+            let b = *iter.next()?;\n             if b < 0x80 {\n                 pos += 1;\n             } else if b < 0xE0 {"}, {"sha": "293c66148ab1ca786b26def94fe026f47d5d575b", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1528,12 +1528,7 @@ impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n     fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n         let u = match self.buf.take() {\n             Some(buf) => buf,\n-            None => {\n-                match self.iter.next() {\n-                    Some(u) => u,\n-                    None => return None,\n-                }\n-            }\n+            None => self.iter.next()?\n         };\n \n         if u < 0xD800 || 0xDFFF < u {"}, {"sha": "e5e95002e107933e12be56e58fbf4d833cb17e14", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1123,10 +1123,7 @@ impl MetaItem {\n             _ => return None,\n         };\n         let list_closing_paren_pos = tokens.peek().map(|tt| tt.span().hi());\n-        let node = match MetaItemKind::from_tokens(tokens) {\n-            Some(node) => node,\n-            _ => return None,\n-        };\n+        let node = MetaItemKind::from_tokens(tokens)?;\n         let hi = match node {\n             MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n             MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(span.hi()),\n@@ -1182,10 +1179,8 @@ impl MetaItemKind {\n         let mut tokens = delimited.into_trees().peekable();\n         let mut result = Vec::new();\n         while let Some(..) = tokens.peek() {\n-            match NestedMetaItemKind::from_tokens(&mut tokens) {\n-                Some(item) => result.push(respan(item.span(), item)),\n-                None => return None,\n-            }\n+            let item = NestedMetaItemKind::from_tokens(&mut tokens)?;\n+            result.push(respan(item.span(), item));\n             match tokens.next() {\n                 None | Some(TokenTree::Token(_, Token::Comma)) => {}\n                 _ => return None,"}, {"sha": "22cef25320ed30317b824dbc592bc9c07c8ef8c2", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -284,10 +284,6 @@ declare_features! (\n     // Allows all literals in attribute lists and values of key-value pairs.\n     (active, attr_literals, \"1.13.0\", Some(34981)),\n \n-    // Allows the sysV64 ABI to be specified on all platforms\n-    // instead of just the platforms on which it is the C ABI\n-    (active, abi_sysv64, \"1.13.0\", Some(36167)),\n-\n     // Allows untagged unions `union U { ... }`\n     (active, untagged_unions, \"1.13.0\", Some(32836)),\n \n@@ -520,6 +516,9 @@ declare_features! (\n     (accepted, rvalue_static_promotion, \"1.21.0\", Some(38865)),\n     // Allow Drop types in constants (RFC 1440)\n     (accepted, drop_types_in_const, \"1.22.0\", Some(33156)),\n+    // Allows the sysV64 ABI to be specified on all platforms\n+    // instead of just the platforms on which it is the C ABI\n+    (accepted, abi_sysv64, \"1.24.0\", Some(36167)),\n );\n \n // If you change this, please modify src/doc/unstable-book as well. You must\n@@ -718,6 +717,12 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                       is just used for rustc unit tests \\\n                                       and will never be stable\",\n                                      cfg_fn!(rustc_attrs))),\n+    (\"rustc_regions\", Normal, Gated(Stability::Unstable,\n+                                    \"rustc_attrs\",\n+                                    \"the `#[rustc_regions]` attribute \\\n+                                     is just used for rustc unit tests \\\n+                                     and will never be stable\",\n+                                    cfg_fn!(rustc_attrs))),\n     (\"rustc_error\", Whitelisted, Gated(Stability::Unstable,\n                                        \"rustc_attrs\",\n                                        \"the `#[rustc_error]` attribute \\\n@@ -1246,10 +1251,6 @@ impl<'a> PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, unboxed_closures, span,\n                                    \"rust-call ABI is subject to change\");\n             },\n-            Abi::SysV64 => {\n-                gate_feature_post!(&self, abi_sysv64, span,\n-                                   \"sysv64 ABI is experimental and subject to change\");\n-            },\n             Abi::PtxKernel => {\n                 gate_feature_post!(&self, abi_ptx, span,\n                                    \"PTX ABIs are experimental and subject to change\");\n@@ -1272,6 +1273,7 @@ impl<'a> PostExpansionVisitor<'a> {\n             Abi::Fastcall |\n             Abi::Aapcs |\n             Abi::Win64 |\n+            Abi::SysV64 |\n             Abi::Rust |\n             Abi::C |\n             Abi::System => {}"}, {"sha": "d9c33fa50bd89ab8f0180b6884ec26399f0c48dd", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -14,7 +14,7 @@ use codemap::{CodeMap, FilePathMapping};\n use errors::{FatalError, DiagnosticBuilder};\n use parse::{token, ParseSess};\n use str::char_at;\n-use symbol::{Symbol, keywords};\n+use symbol::Symbol;\n use std_unicode::property::Pattern_White_Space;\n \n use std::borrow::Cow;\n@@ -1296,18 +1296,6 @@ impl<'a> StringReader<'a> {\n                         self.mk_ident(&format!(\"'{}\", lifetime_name))\n                     });\n \n-                    // Conjure up a \"keyword checking ident\" to make sure that\n-                    // the lifetime name is not a keyword.\n-                    let keyword_checking_ident = self.with_str_from(start, |lifetime_name| {\n-                        self.mk_ident(lifetime_name)\n-                    });\n-                    let keyword_checking_token = &token::Ident(keyword_checking_ident);\n-                    let last_bpos = self.pos;\n-                    if keyword_checking_token.is_reserved_ident() &&\n-                       !keyword_checking_token.is_keyword(keywords::Static) {\n-                        self.err_span_(start, last_bpos, \"lifetimes cannot use keyword names\");\n-                    }\n-\n                     return Ok(token::Lifetime(ident));\n                 }\n "}, {"sha": "726db7334824ec033a56ad98d5c38e4818564e35", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -5995,7 +5995,7 @@ impl<'a> Parser<'a> {\n         match any_disr {\n             Some(disr_span) if !all_nullary =>\n                 self.span_err(disr_span,\n-                    \"discriminator values can only be used with a c-like enum\"),\n+                    \"discriminator values can only be used with a field-less enum\"),\n             _ => ()\n         }\n "}, {"sha": "26f39f608807d9afc9786bcd302cf73b27e3f727", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -620,10 +620,7 @@ fn prepend_attrs(sess: &ParseSess,\n                  span: syntax_pos::Span)\n     -> Option<tokenstream::TokenStream>\n {\n-    let tokens = match tokens {\n-        Some(tokens) => tokens,\n-        None => return None,\n-    };\n+    let tokens = tokens?;\n     if attrs.len() == 0 {\n         return Some(tokens.clone())\n     }"}, {"sha": "0476d7d4fcc1c53b45d14f0e6f1e94187efafbd1", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 27, "deletions": 48, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,15 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! try_opt {\n-    ($e:expr) => {\n-        match $e {\n-            Some(v) => v,\n-            None => return None,\n-        }\n-    };\n-}\n-\n pub mod printf {\n     use super::strcursor::StrCursor as Cur;\n \n@@ -173,7 +164,7 @@ pub mod printf {\n             s.push_str(\"{\");\n \n             if let Some(arg) = self.parameter {\n-                try_opt!(write!(s, \"{}\", try_opt!(arg.checked_sub(1))).ok());\n+                write!(s, \"{}\", arg.checked_sub(1)?).ok()?;\n             }\n \n             if has_options {\n@@ -203,12 +194,12 @@ pub mod printf {\n                 }\n \n                 if let Some(width) = width {\n-                    try_opt!(width.translate(&mut s).ok());\n+                    width.translate(&mut s).ok()?;\n                 }\n \n                 if let Some(precision) = precision {\n                     s.push_str(\".\");\n-                    try_opt!(precision.translate(&mut s).ok());\n+                    precision.translate(&mut s).ok()?;\n                 }\n \n                 if let Some(type_) = type_ {\n@@ -277,13 +268,9 @@ pub mod printf {\n     impl<'a> Iterator for Substitutions<'a> {\n         type Item = Substitution<'a>;\n         fn next(&mut self) -> Option<Self::Item> {\n-            match parse_next_substitution(self.s) {\n-                Some((sub, tail)) => {\n-                    self.s = tail;\n-                    Some(sub)\n-                },\n-                None => None,\n-            }\n+            let (sub, tail) = parse_next_substitution(self.s)?;\n+            self.s = tail;\n+            Some(sub)\n         }\n     }\n \n@@ -303,11 +290,10 @@ pub mod printf {\n         use self::State::*;\n \n         let at = {\n-            let start = try_opt!(s.find('%'));\n-            match s[start+1..].chars().next() {\n-                Some('%') => return Some((Substitution::Escape, &s[start+2..])),\n-                Some(_) => {/* fall-through */},\n-                None => return None,\n+            let start = s.find('%')?;\n+            match s[start+1..].chars().next()? {\n+                '%' => return Some((Substitution::Escape, &s[start+2..])),\n+                _ => {/* fall-through */},\n             }\n \n             Cur::new_at_start(&s[start..])\n@@ -335,16 +321,16 @@ pub mod printf {\n         // Used to establish the full span at the end.\n         let start = at;\n         // The current position within the string.\n-        let mut at = try_opt!(at.at_next_cp());\n+        let mut at = at.at_next_cp()?;\n         // `c` is the next codepoint, `next` is a cursor after it.\n-        let (mut c, mut next) = try_opt!(at.next_cp());\n+        let (mut c, mut next) = at.next_cp()?;\n \n         // Update `at`, `c`, and `next`, exiting if we're out of input.\n         macro_rules! move_to {\n             ($cur:expr) => {\n                 {\n                     at = $cur;\n-                    let (c_, next_) = try_opt!(at.next_cp());\n+                    let (c_, next_) = at.next_cp()?;\n                     c = c_;\n                     next = next_;\n                 }\n@@ -801,31 +787,27 @@ pub mod shell {\n     /// Parse the next substitution from the input string.\n     pub fn parse_next_substitution(s: &str) -> Option<(Substitution, &str)> {\n         let at = {\n-            let start = try_opt!(s.find('$'));\n-            match s[start+1..].chars().next() {\n-                Some('$') => return Some((Substitution::Escape, &s[start+2..])),\n-                Some(c @ '0' ... '9') => {\n+            let start = s.find('$')?;\n+            match s[start+1..].chars().next()? {\n+                '$' => return Some((Substitution::Escape, &s[start+2..])),\n+                c @ '0' ... '9' => {\n                     let n = (c as u8) - b'0';\n                     return Some((Substitution::Ordinal(n), &s[start+2..]));\n                 },\n-                Some(_) => {/* fall-through */},\n-                None => return None,\n+                _ => {/* fall-through */},\n             }\n \n             Cur::new_at_start(&s[start..])\n         };\n \n-        let at = try_opt!(at.at_next_cp());\n-        match at.next_cp() {\n-            Some((c, inner)) => {\n-                if !is_ident_head(c) {\n-                    None\n-                } else {\n-                    let end = at_next_cp_while(inner, is_ident_tail);\n-                    Some((Substitution::Name(at.slice_between(end).unwrap()), end.slice_after()))\n-                }\n-            },\n-            _ => None\n+        let at = at.at_next_cp()?;\n+        let (c, inner) = at.next_cp()?;\n+\n+        if !is_ident_head(c) {\n+            None\n+        } else {\n+            let end = at_next_cp_while(inner, is_ident_tail);\n+            Some((Substitution::Name(at.slice_between(end).unwrap()), end.slice_after()))\n         }\n     }\n \n@@ -946,10 +928,7 @@ mod strcursor {\n         }\n \n         pub fn next_cp(mut self) -> Option<(char, StrCursor<'a>)> {\n-            let cp = match self.cp_after() {\n-                Some(cp) => cp,\n-                None => return None,\n-            };\n+            let cp = self.cp_after()?;\n             self.seek_right(cp.len_utf8());\n             Some((cp, self))\n         }"}, {"sha": "ec652b5607ec4421eca14527132b5d436955bf68", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -503,13 +503,16 @@ pub enum NonNarrowChar {\n     ZeroWidth(BytePos),\n     /// Represents a wide (fullwidth) character\n     Wide(BytePos),\n+    /// Represents a tab character, represented visually with a width of 4 characters\n+    Tab(BytePos),\n }\n \n impl NonNarrowChar {\n     fn new(pos: BytePos, width: usize) -> Self {\n         match width {\n             0 => NonNarrowChar::ZeroWidth(pos),\n             2 => NonNarrowChar::Wide(pos),\n+            4 => NonNarrowChar::Tab(pos),\n             _ => panic!(\"width {} given for non-narrow character\", width),\n         }\n     }\n@@ -518,7 +521,8 @@ impl NonNarrowChar {\n     pub fn pos(&self) -> BytePos {\n         match *self {\n             NonNarrowChar::ZeroWidth(p) |\n-            NonNarrowChar::Wide(p) => p,\n+            NonNarrowChar::Wide(p) |\n+            NonNarrowChar::Tab(p) => p,\n         }\n     }\n \n@@ -527,6 +531,7 @@ impl NonNarrowChar {\n         match *self {\n             NonNarrowChar::ZeroWidth(_) => 0,\n             NonNarrowChar::Wide(_) => 2,\n+            NonNarrowChar::Tab(_) => 4,\n         }\n     }\n }\n@@ -538,6 +543,7 @@ impl Add<BytePos> for NonNarrowChar {\n         match self {\n             NonNarrowChar::ZeroWidth(pos) => NonNarrowChar::ZeroWidth(pos + rhs),\n             NonNarrowChar::Wide(pos) => NonNarrowChar::Wide(pos + rhs),\n+            NonNarrowChar::Tab(pos) => NonNarrowChar::Tab(pos + rhs),\n         }\n     }\n }\n@@ -549,6 +555,7 @@ impl Sub<BytePos> for NonNarrowChar {\n         match self {\n             NonNarrowChar::ZeroWidth(pos) => NonNarrowChar::ZeroWidth(pos - rhs),\n             NonNarrowChar::Wide(pos) => NonNarrowChar::Wide(pos - rhs),\n+            NonNarrowChar::Tab(pos) => NonNarrowChar::Tab(pos - rhs),\n         }\n     }\n }\n@@ -868,8 +875,10 @@ impl FileMap {\n \n     pub fn record_width(&self, pos: BytePos, ch: char) {\n         let width = match ch {\n-            '\\t' | '\\n' =>\n-                // Tabs will consume one column.\n+            '\\t' =>\n+                // Tabs will consume 4 columns.\n+                4,\n+            '\\n' =>\n                 // Make newlines take one column so that displayed spans can point them.\n                 1,\n             ch =>"}, {"sha": "aafdd696b747df8567c5fae8baf6a67baca1cdee", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -35,6 +35,10 @@ impl Ident {\n         Ident::with_empty_ctxt(Symbol::intern(string))\n     }\n \n+    pub fn without_first_quote(&self) -> Ident {\n+        Ident { name: Symbol::from(self.name.as_str().trim_left_matches('\\'')), ctxt: self.ctxt }\n+    }\n+\n     pub fn modern(self) -> Ident {\n         Ident { name: self.name, ctxt: self.ctxt.modern() }\n     }\n@@ -123,7 +127,12 @@ impl<'a> From<&'a str> for Symbol {\n \n impl fmt::Debug for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}({})\", self, self.0)\n+        let is_gensymed = with_interner(|interner| interner.is_gensymed(*self));\n+        if is_gensymed {\n+            write!(f, \"{}({})\", self, self.0)\n+        } else {\n+            write!(f, \"{}\", self)\n+        }\n     }\n }\n \n@@ -201,6 +210,10 @@ impl Interner {\n         Symbol(!0 - self.gensyms.len() as u32 + 1)\n     }\n \n+    fn is_gensymed(&mut self, symbol: Symbol) -> bool {\n+        symbol.0 as usize >= self.strings.len()\n+    }\n+\n     pub fn get(&self, symbol: Symbol) -> &str {\n         match self.strings.get(symbol.0 as usize) {\n             Some(ref string) => string,\n@@ -428,4 +441,10 @@ mod tests {\n         // gensym of *existing* string gets new number:\n         assert_eq!(i.gensym(\"dog\"), Symbol(4294967293));\n     }\n+\n+    #[test]\n+    fn without_first_quote_test() {\n+        let i = Ident::from_str(\"'break\");\n+        assert_eq!(i.without_first_quote().name, keywords::Break.name());\n+    }\n }"}, {"sha": "492d26e625cbed84dfbbf5dea8316966b8fd6ddf", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -20,10 +20,7 @@ use std::path::PathBuf;\n #[allow(deprecated)]\n pub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n     let mut dirs_to_search = Vec::new();\n-    let first_char = match term.chars().next() {\n-        Some(c) => c,\n-        None => return None,\n-    };\n+    let first_char = term.chars().next()?;\n \n     // Find search directory\n     if let Some(dir) = env::var_os(\"TERMINFO\") {"}, {"sha": "bc96a5d6740c4ce417cf8dee257269e4b54ea5dc", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 13, "deletions": 62, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -150,9 +150,7 @@ impl<T, F: FnOnce(T) + Send + 'static> FnBox<T> for F {\n pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut Bencher)),\n-    StaticMetricFn(fn(&mut MetricMap)),\n     DynTestFn(Box<FnBox<()>>),\n-    DynMetricFn(Box<for<'a> FnBox<&'a mut MetricMap>>),\n     DynBenchFn(Box<TDynBenchFn + 'static>),\n }\n \n@@ -161,9 +159,7 @@ impl TestFn {\n         match *self {\n             StaticTestFn(..) => PadNone,\n             StaticBenchFn(..) => PadOnRight,\n-            StaticMetricFn(..) => PadOnRight,\n             DynTestFn(..) => PadNone,\n-            DynMetricFn(..) => PadOnRight,\n             DynBenchFn(..) => PadOnRight,\n         }\n     }\n@@ -174,9 +170,7 @@ impl fmt::Debug for TestFn {\n         f.write_str(match *self {\n             StaticTestFn(..) => \"StaticTestFn(..)\",\n             StaticBenchFn(..) => \"StaticBenchFn(..)\",\n-            StaticMetricFn(..) => \"StaticMetricFn(..)\",\n             DynTestFn(..) => \"DynTestFn(..)\",\n-            DynMetricFn(..) => \"DynMetricFn(..)\",\n             DynBenchFn(..) => \"DynBenchFn(..)\",\n         })\n     }\n@@ -245,16 +239,6 @@ impl Metric {\n     }\n }\n \n-#[derive(PartialEq)]\n-pub struct MetricMap(BTreeMap<String, Metric>);\n-\n-impl Clone for MetricMap {\n-    fn clone(&self) -> MetricMap {\n-        let MetricMap(ref map) = *self;\n-        MetricMap(map.clone())\n-    }\n-}\n-\n /// In case we want to add other options as well, just add them in this struct.\n #[derive(Copy, Clone, Debug)]\n pub struct Options {\n@@ -528,7 +512,6 @@ pub enum TestResult {\n     TrFailedMsg(String),\n     TrIgnored,\n     TrAllowedFail,\n-    TrMetrics(MetricMap),\n     TrBench(BenchSamples),\n }\n \n@@ -605,10 +588,6 @@ impl<T: Write> ConsoleTestState<T> {\n         self.write_short_result(\"FAILED (allowed)\", \"a\", term::color::YELLOW)\n     }\n \n-    pub fn write_metric(&mut self) -> io::Result<()> {\n-        self.write_pretty(\"metric\", term::color::CYAN)\n-    }\n-\n     pub fn write_bench(&mut self) -> io::Result<()> {\n         self.write_pretty(\"bench\", term::color::CYAN)\n     }\n@@ -688,10 +667,6 @@ impl<T: Write> ConsoleTestState<T> {\n             TrFailed | TrFailedMsg(_) => self.write_failed(),\n             TrIgnored => self.write_ignored(),\n             TrAllowedFail => self.write_allowed_fail(),\n-            TrMetrics(ref mm) => {\n-                self.write_metric()?;\n-                self.write_plain(&format!(\": {}\\n\", mm.fmt_metrics()))\n-            }\n             TrBench(ref bs) => {\n                 self.write_bench()?;\n                 self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n@@ -722,7 +697,6 @@ impl<T: Write> ConsoleTestState<T> {\n                         TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n                         TrIgnored => \"ignored\".to_owned(),\n                         TrAllowedFail => \"failed (allowed)\".to_owned(),\n-                        TrMetrics(ref mm) => mm.fmt_metrics(),\n                         TrBench(ref bs) => fmt_bench_samples(bs),\n                     },\n                     test.name))\n@@ -872,7 +846,6 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n \n     let mut ntest = 0;\n     let mut nbench = 0;\n-    let mut nmetric = 0;\n \n     for test in filter_tests(&opts, tests) {\n         use TestFn::*;\n@@ -882,7 +855,6 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n         let fntype = match testfn {\n             StaticTestFn(..) | DynTestFn(..) => { ntest += 1; \"test\" },\n             StaticBenchFn(..) | DynBenchFn(..) => { nbench += 1; \"benchmark\" },\n-            StaticMetricFn(..) | DynMetricFn(..) => { nmetric += 1; \"metric\" },\n         };\n \n         st.write_plain(format!(\"{}: {}\\n\", name, fntype))?;\n@@ -897,13 +869,12 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n     }\n \n     if !opts.quiet {\n-        if ntest != 0 || nbench != 0 || nmetric != 0 {\n+        if ntest != 0 || nbench != 0 {\n             st.write_plain(\"\\n\")?;\n         }\n-        st.write_plain(format!(\"{}, {}, {}\\n\",\n+        st.write_plain(format!(\"{}, {}\\n\",\n             plural(ntest, \"test\"),\n-            plural(nbench, \"benchmark\"),\n-            plural(nmetric, \"metric\")))?;\n+            plural(nbench, \"benchmark\")))?;\n     }\n \n     Ok(())\n@@ -928,15 +899,6 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n                     }\n                     TrIgnored => st.ignored += 1,\n                     TrAllowedFail => st.allowed_fail += 1,\n-                    TrMetrics(mm) => {\n-                        let tname = test.name;\n-                        let MetricMap(mm) = mm;\n-                        for (k, v) in &mm {\n-                            st.metrics\n-                              .insert_metric(&format!(\"{}.{}\", tname, k), v.value, v.noise);\n-                        }\n-                        st.measured += 1\n-                    }\n                     TrBench(bs) => {\n                         st.metrics.insert_metric(test.name.as_slice(),\n                                                  bs.ns_iter_summ.median,\n@@ -1095,7 +1057,7 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n \n     callback(TeFiltered(filtered_descs))?;\n \n-    let (filtered_tests, filtered_benchs_and_metrics): (Vec<_>, _) =\n+    let (filtered_tests, filtered_benchs): (Vec<_>, _) =\n         filtered_tests.into_iter().partition(|e| {\n             match e.testfn {\n                 StaticTestFn(_) | DynTestFn(_) => true,\n@@ -1182,8 +1144,7 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n \n     if opts.bench_benchmarks {\n         // All benchmarks run at the end, in serial.\n-        // (this includes metric fns)\n-        for b in filtered_benchs_and_metrics {\n+        for b in filtered_benchs {\n             callback(TeWait(b.desc.clone(), b.testfn.padding()))?;\n             run_test(opts, false, b, tx.clone());\n             let (test, result, stdout) = rx.recv().unwrap();\n@@ -1487,18 +1448,6 @@ pub fn run_test(opts: &TestOpts,\n             monitor_ch.send((desc, TrBench(bs), Vec::new())).unwrap();\n             return;\n         }\n-        DynMetricFn(f) => {\n-            let mut mm = MetricMap::new();\n-            f.call_box(&mut mm);\n-            monitor_ch.send((desc, TrMetrics(mm), Vec::new())).unwrap();\n-            return;\n-        }\n-        StaticMetricFn(f) => {\n-            let mut mm = MetricMap::new();\n-            f(&mut mm);\n-            monitor_ch.send((desc, TrMetrics(mm), Vec::new())).unwrap();\n-            return;\n-        }\n         DynTestFn(f) => {\n             let cb = move |()| {\n                 __rust_begin_short_backtrace(|| f.call_box(()))\n@@ -1540,6 +1489,9 @@ fn calc_result(desc: &TestDesc, task_result: Result<(), Box<Any + Send>>) -> Tes\n     }\n }\n \n+#[derive(Clone, PartialEq)]\n+pub struct MetricMap(BTreeMap<String, Metric>);\n+\n impl MetricMap {\n     pub fn new() -> MetricMap {\n         MetricMap(BTreeMap::new())\n@@ -1563,15 +1515,14 @@ impl MetricMap {\n             value,\n             noise,\n         };\n-        let MetricMap(ref mut map) = *self;\n-        map.insert(name.to_owned(), m);\n+        self.0.insert(name.to_owned(), m);\n     }\n \n     pub fn fmt_metrics(&self) -> String {\n-        let MetricMap(ref mm) = *self;\n-        let v: Vec<String> = mm.iter()\n-                               .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n-                               .collect();\n+        let v = self.0\n+                   .iter()\n+                   .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n+                   .collect::<Vec<_>>();\n         v.join(\", \")\n     }\n }"}, {"sha": "072a9144f17a18ab3bca4e777128ef1dc60abbb8", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -970,7 +970,7 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   std::set<GlobalValue::GUID> ExportedGUIDs;\n   for (auto &List : Ret->Index) {\n     for (auto &GVS: List.second) {\n-      if (!GlobalValue::isExternalLinkage(GVS->linkage()))\n+      if (GlobalValue::isLocalLinkage(GVS->linkage()))\n         continue;\n       auto GUID = GVS->getOriginalName();\n       if (!DeadSymbols.count(GUID))"}, {"sha": "920f5cbcca3f2b76463034e6ed8eb929935dee5e", "filename": "src/test/codegen/abi-sysv64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcodegen%2Fabi-sysv64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcodegen%2Fabi-sysv64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-sysv64.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,6 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(abi_sysv64)]\n \n // CHECK: define x86_64_sysvcc i64 @has_sysv64_abi\n #[no_mangle]"}, {"sha": "f7e246e8f0f41383b2e9186f3acffec03450de4b", "filename": "src/test/compile-fail/E0501.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2FE0501.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2FE0501.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0501.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,17 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n fn inside_closure(x: &mut i32) {\n }\n \n-fn outside_closure(x: &mut i32) {\n+fn outside_closure_1(x: &mut i32) {\n+}\n+\n+fn outside_closure_2(x: &i32) {\n }\n \n fn foo(a: &mut i32) {\n     let bar = || {\n         inside_closure(a)\n     };\n-    outside_closure(a); //~ ERROR E0501\n+    outside_closure_1(a); //[ast]~ ERROR cannot borrow `*a` as mutable because previous closure requires unique access\n+                         //[mir]~^ ERROR cannot borrow `*a` as mutable because previous closure requires unique access\n+\n+    outside_closure_2(a); //[ast]~ ERROR cannot borrow `*a` as immutable because previous closure requires unique access\n+                         //[mir]~^ ERROR cannot borrow `*a` as immutable because previous closure requires unique access\n }\n \n fn main() {"}, {"sha": "fa80a2efdf83dab89815ce3e28f4a7704e5afc2a", "filename": "src/test/compile-fail/borrowck/borrowck-local-borrow-outlives-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-outlives-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-outlives-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-outlives-fn.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -13,7 +13,7 @@\n \n fn cplusplus_mode(x: isize) -> &'static isize {\n     &x //[ast]~ ERROR `x` does not live long enough\n-       //[mir]~^ ERROR borrowed value does not live long enough\n }\n+//[mir]~^ ERROR borrowed value does not live long enough\n \n fn main() {}"}, {"sha": "78f0d321e0d3df7d88db773626de99327b03bba8", "filename": "src/test/compile-fail/borrowck/borrowck-local-borrow-with-panic-outlives-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-with-panic-outlives-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-with-panic-outlives-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-with-panic-outlives-fn.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -14,9 +14,9 @@\n fn cplusplus_mode_exceptionally_unsafe(x: &mut Option<&'static mut isize>) {\n     let mut z = (0, 0);\n     *x = Some(&mut z.1); //[ast]~ ERROR [E0597]\n-                         //[mir]~^ ERROR [E0597]\n     panic!(\"catch me for a dangling pointer!\")\n }\n+//[mir]~^ ERROR [E0597]\n \n fn main() {\n     cplusplus_mode_exceptionally_unsafe(&mut None);"}, {"sha": "2bd6f75df1b1ff138befe6bf9a9a9cbff91617f7", "filename": "src/test/compile-fail/borrowck/borrowck-move-moved-value-into-closure.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-moved-value-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-moved-value-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-moved-value-into-closure.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n #![feature(box_syntax)]\n \n fn call_f<F:FnOnce() -> isize>(f: F) -> isize {\n@@ -18,5 +21,6 @@ fn main() {\n     let t: Box<_> = box 3;\n \n     call_f(move|| { *t + 1 });\n-    call_f(move|| { *t + 1 }); //~ ERROR capture of moved value\n+    call_f(move|| { *t + 1 }); //[ast]~ ERROR capture of moved value\n+    //[mir]~^ ERROR use of moved value\n }"}, {"sha": "63bb04a0e4c3afd38716b3e7de834bbe298a963f", "filename": "src/test/compile-fail/borrowck/borrowck-mut-borrow-linear-errors.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -23,15 +23,9 @@ fn main() {\n             1 => { addr = &mut x; } //[ast]~ ERROR [E0499]\n             //[mir]~^ ERROR [E0499]\n             2 => { addr = &mut x; } //[ast]~ ERROR [E0499]\n-            //[mir]~^ ERROR [E0506]\n-            //[mir]~| ERROR [E0499]\n-            //[mir]~| ERROR [E0499]\n+            //[mir]~^ ERROR [E0499]\n             _ => { addr = &mut x; } //[ast]~ ERROR [E0499]\n-            //[mir]~^ ERROR [E0506]\n-            //[mir]~| ERROR [E0499]\n-            //[mir]~| ERROR [E0499]\n+            //[mir]~^ ERROR [E0499]\n         }\n     }\n }\n-\n-"}, {"sha": "df0a05dfaee0e6a15ed1a864cf8c45c32335471b", "filename": "src/test/compile-fail/borrowck/borrowck-thread-local-static-borrow-outlives-fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-test will be fixed later\n // revisions: ast mir\n //[mir]compile-flags: -Z borrowck=mir\n "}, {"sha": "0241b3870c7e64554f8a692b5c4bc8722dc60fc5", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -52,12 +52,12 @@ fn main() {\n         {\n             let ra = &u.a;\n             let rmb = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n-                                // FIXME Error for MIR (needs support for union)\n+                                //[mir]~^ ERROR cannot borrow `u.b` as mutable because it is also borrowed as immutable\n         }\n         {\n             let ra = &u.a;\n             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n-                     // FIXME Error for MIR (needs support for union)\n+                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n         }\n         // Mut borrow, same field\n         {\n@@ -84,22 +84,23 @@ fn main() {\n         {\n             let rma = &mut u.a;\n             let rb = &u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n-                           // FIXME Error for MIR (needs support for union)\n+                           //[mir]~^ ERROR cannot borrow `u.b` as immutable because it is also borrowed as mutable\n         }\n         {\n             let ra = &mut u.a;\n             let b = u.b; //[ast]~ ERROR cannot use `u.b` because it was mutably borrowed\n-                         // FIXME Error for MIR (needs support for union)\n+                         //[mir]~^ ERROR cannot use `u.b` because it was mutably borrowed\n+\n         }\n         {\n             let rma = &mut u.a;\n             let rmb2 = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n-                                 // FIXME Error for MIR (needs support for union)\n+                                 //[mir]~^ ERROR cannot borrow `u.b` as mutable more than once at a time\n         }\n         {\n             let rma = &mut u.a;\n             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n-                     // FIXME Error for MIR (needs support for union)\n+                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n         }\n     }\n }"}, {"sha": "94877b27d5888becd5ec91158c5f764e9da42aa8", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1,3 +1,4 @@\n+\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -22,7 +23,7 @@ fn main() {\n     println!(\"t[0]: {}\", t[0]);\n     a[2] = 0; //[ast]~ ERROR cannot assign to `a[..]` because it is borrowed\n               //[cmp]~^ ERROR cannot assign to `a[..]` because it is borrowed (Ast)\n-              // FIXME Error for MIR (error missed)\n+              //[cmp]~| ERROR cannot assign to `a[..]` because it is borrowed (Mir)\n     println!(\"t[0]: {}\", t[0]);\n     t[0];\n }"}, {"sha": "ee553730a35bc4ebca62138b8664b677394e1c36", "filename": "src/test/compile-fail/issue-10412.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only -Z continue-parse-after-error\n-\n-\n trait Serializable<'self, T> { //~ ERROR lifetimes cannot use keyword names\n-    fn serialize(val : &'self T) -> Vec<u8> ; //~ ERROR lifetimes cannot use keyword names\n+    fn serialize(val : &'self T) -> Vec<u8>; //~ ERROR lifetimes cannot use keyword names\n     fn deserialize(repr : &[u8]) -> &'self T; //~ ERROR lifetimes cannot use keyword names\n }\n \n impl<'self> Serializable<str> for &'self str { //~ ERROR lifetimes cannot use keyword names\n     //~^ ERROR lifetimes cannot use keyword names\n+    //~| ERROR missing lifetime specifier\n     fn serialize(val : &'self str) -> Vec<u8> { //~ ERROR lifetimes cannot use keyword names\n         vec![1]\n     }", "previous_filename": "src/test/parse-fail/issue-10412.rs"}, {"sha": "5f5a58ed759426b8e2b1c633e509d02ea31edfaf", "filename": "src/test/compile-fail/issue-25579.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -20,13 +20,9 @@ fn causes_ice(mut l: &mut Sexpression) {\n     loop { match l {\n         &mut Sexpression::Num(ref mut n) => {},\n         &mut Sexpression::Cons(ref mut expr) => { //[ast]~ ERROR [E0499]\n-                                                  //[mir]~^ ERROR [E0506]\n-                                                  //[mir]~| ERROR [E0499]\n+                                                  //[mir]~^ ERROR [E0499]\n             l = &mut **expr; //[ast]~ ERROR [E0506]\n                              //[mir]~^ ERROR [E0506]\n-                             //[mir]~| ERROR [E0506]\n-                             //[mir]~| ERROR [E0499]\n-                             //[mir]~| ERROR [E0499]\n         }\n     }}\n }"}, {"sha": "4db5c84df9a63d6f43d170da9fccb52170f8da00", "filename": "src/test/compile-fail/issue-43355.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(incoherent_fundamental_impls)]\n+\n+pub trait Trait1<X> {\n+    type Output;\n+}\n+\n+pub trait Trait2<X> {}\n+\n+pub struct A;\n+\n+impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+    type Output = ();\n+}\n+\n+impl<X> Trait1<Box<X>> for A {\n+//~^ ERROR conflicting implementations of trait\n+//~| hard error\n+//~| downstream crates may implement trait `Trait2<std::boxed::Box<_>>` for type `A`\n+    type Output = i32;\n+}\n+\n+fn main() {}"}, {"sha": "5b23e5e815053467be7ce0150b11917460e587a0", "filename": "src/test/compile-fail/issue-46209-private-enum-variant-reexport.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fissue-46209-private-enum-variant-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fissue-46209-private-enum-variant-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-46209-private-enum-variant-reexport.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(crate_visibility_modifier)]\n+\n+mod rank {\n+    pub use self::Professor::*;\n+    //~^ ERROR enum is private and its variants cannot be reexported\n+    pub use self::Lieutenant::{JuniorGrade, Full};\n+    //~^ ERROR variant `JuniorGrade` is private and cannot be reexported\n+    //~| ERROR variant `Full` is private and cannot be reexported\n+    pub use self::PettyOfficer::*;\n+    //~^ ERROR enum is private and its variants cannot be reexported\n+    pub use self::Crewman::*;\n+    //~^ ERROR enum is private and its variants cannot be reexported\n+\n+    enum Professor {\n+        Adjunct,\n+        Assistant,\n+        Associate,\n+        Full\n+    }\n+\n+    enum Lieutenant {\n+        JuniorGrade,\n+        Full,\n+    }\n+\n+    pub(in rank) enum PettyOfficer {\n+        SecondClass,\n+        FirstClass,\n+        Chief,\n+        MasterChief\n+    }\n+\n+    crate enum Crewman {\n+        Recruit,\n+        Apprentice,\n+        Full\n+    }\n+\n+}\n+\n+fn main() {}"}, {"sha": "82f55f2c14241b6f8e613a6273735266b7ff1611", "filename": "src/test/compile-fail/issue-46311.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fissue-46311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fissue-46311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-46311.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-no_core\n-\n-#![no_core] //~ ERROR no_core is experimental\n-\n-fn main() {}\n+fn main() {\n+    'break: loop { //~ ERROR invalid label name `'break`\n+    }\n+}", "previous_filename": "src/test/compile-fail/no-core-gated.rs"}, {"sha": "d583c4fc6c6b8461c5ef4d3ce89d4f7a3c5ab359", "filename": "src/test/compile-fail/lifetime-no-keyword.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only -Z continue-parse-after-error\n-\n fn foo<'a>(a: &'a isize) { }\n fn bar(a: &'static isize) { }\n-fn baz(a: &'let isize) { } //~ ERROR lifetimes cannot use keyword names\n-fn zab(a: &'self isize) { } //~ ERROR lifetimes cannot use keyword names\n-\n+fn baz<'let>(a: &'let isize) { } //~ ERROR lifetimes cannot use keyword names\n+//~^ ERROR lifetimes cannot use keyword names\n+fn zab<'self>(a: &'self isize) { } //~ ERROR lifetimes cannot use keyword names\n+//~^ ERROR lifetimes cannot use keyword names\n fn main() { }", "previous_filename": "src/test/parse-fail/lifetime-no-keyword.rs"}, {"sha": "1280aba3076abbb3654f79619cbeadff461c64a2", "filename": "src/test/compile-fail/private-variant-reexport.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fprivate-variant-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fprivate-variant-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-variant-reexport.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -9,19 +9,19 @@\n // except according to those terms.\n \n mod m1 {\n-    pub use ::E::V; //~ ERROR variant `V` is private, and cannot be reexported\n+    pub use ::E::V; //~ ERROR variant `V` is private and cannot be reexported\n }\n \n mod m2 {\n-    pub use ::E::{V}; //~ ERROR variant `V` is private, and cannot be reexported\n+    pub use ::E::{V}; //~ ERROR variant `V` is private and cannot be reexported\n }\n \n mod m3 {\n-    pub use ::E::V::{self}; //~ ERROR variant `V` is private, and cannot be reexported\n+    pub use ::E::V::{self}; //~ ERROR variant `V` is private and cannot be reexported\n }\n \n mod m4 {\n-    pub use ::E::*; //~ ERROR variant `V` is private, and cannot be reexported\n+    pub use ::E::*; //~ ERROR enum is private and its variants cannot be reexported\n }\n \n enum E { V }"}, {"sha": "a4dc00bd2b1e77acc4869230fb0839ddf28f45ae", "filename": "src/test/compile-fail/region-borrow-params-issue-29793-big.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-big.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -16,6 +16,10 @@\n // behavior (because the improperly accepted closure was actually\n // able to be invoked).\n \n+// ignore-tidy-linelength\n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n struct WrapA<F>(Option<F>);\n \n impl<F> WrapA<F> {\n@@ -75,9 +79,11 @@ impl<F, T> WrapA<F>\n fn main() {\n     let mut w = WrapA::new().set(|x: usize, y: usize| {\n         WrapB::new().set(|t: bool| if t { x } else { y }) // (separate errors for `x` vs `y`)\n-            //~^ ERROR `x` does not live long enough\n-            //~| ERROR `y` does not live long enough\n+            //[ast]~^ ERROR `x` does not live long enough\n+            //[ast]~| ERROR `y` does not live long enough\n     });\n+    //[mir]~^ ERROR borrowed value does not live long enough\n+    //[mir]~| ERROR borrowed value does not live long enough\n \n     w.handle(); // This works\n     // w.handle_ref(); // This doesn't"}, {"sha": "9de8ca196f8ce9a021cf37d99607ec25da4f721a", "filename": "src/test/compile-fail/regions-static-bound.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,17 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ll nll\n+//[nll] compile-flags: -Znll -Zborrowck=mir\n+\n fn static_id<'a,'b>(t: &'a ()) -> &'static ()\n     where 'a: 'static { t }\n fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static ()\n     where 'a: 'b, 'b: 'static { t }\n fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n-    t //~ ERROR E0312\n+    t //[ll]~ ERROR E0312\n+        //[nll]~^ WARNING not reporting region error due to -Znll\n+        //[nll]~| ERROR free region `'a` does not outlive free region `'static`\n }\n \n fn error(u: &(), v: &()) {\n-    static_id(&u); //~ ERROR cannot infer an appropriate lifetime\n-    static_id_indirect(&v); //~ ERROR cannot infer an appropriate lifetime\n+    static_id(&u); //[ll]~ ERROR cannot infer an appropriate lifetime\n+    //[nll]~^ WARNING not reporting region error due to -Znll\n+    static_id_indirect(&v); //[ll]~ ERROR cannot infer an appropriate lifetime\n+    //[nll]~^ WARNING not reporting region error due to -Znll\n+\n+    // FIXME(#45827) -- MIR type checker shortcomings mean we don't\n+    // see these errors (yet) in nll mode.\n }\n \n fn main() {}"}, {"sha": "da8a62a976508703ad465d08827db178bd91f256", "filename": "src/test/incremental/hashes/call_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n \n #![allow(warnings)]"}, {"sha": "d8a87da5918a9bae800b8c969bff1effdfb7f296", "filename": "src/test/incremental/hashes/closure_expressions.rs", "status": "modified", "additions": 25, "deletions": 37, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n@@ -27,34 +27,30 @@\n \n // Change closure body ---------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_closure_body() {\n+pub fn change_closure_body() {\n     let _ = || 1u32;\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_closure_body() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_closure_body() {\n     let _ = || 3u32;\n }\n \n \n \n // Add parameter ---------------------------------------------------------------\n #[cfg(cfail1)]\n-fn add_parameter() {\n+pub fn add_parameter() {\n     let x = 0u32;\n     let _ = || x + 1;\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_parameter() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_parameter() {\n     let x = 0u32;\n     let _ = |x: u32| x + 1;\n }\n@@ -63,51 +59,45 @@ fn add_parameter() {\n \n // Change parameter pattern ----------------------------------------------------\n #[cfg(cfail1)]\n-fn change_parameter_pattern() {\n+pub fn change_parameter_pattern() {\n     let _ = |x: &u32| x;\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_parameter_pattern() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_parameter_pattern() {\n     let _ = |&x: &u32| x;\n }\n \n \n \n // Add `move` to closure -------------------------------------------------------\n #[cfg(cfail1)]\n-fn add_move() {\n+pub fn add_move() {\n     let _ = || 1;\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_move() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_move() {\n     let _ = move || 1;\n }\n \n \n \n // Add type ascription to parameter --------------------------------------------\n #[cfg(cfail1)]\n-fn add_type_ascription_to_parameter() {\n+pub fn add_type_ascription_to_parameter() {\n     let closure = |x| x + 1u32;\n     let _: u32 = closure(1);\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_type_ascription_to_parameter() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_type_ascription_to_parameter() {\n     let closure = |x: u32| x + 1u32;\n     let _: u32 = closure(1);\n }\n@@ -116,17 +106,15 @@ fn add_type_ascription_to_parameter() {\n \n // Change parameter type -------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_parameter_type() {\n+pub fn change_parameter_type() {\n     let closure = |x: u32| (x as u64) + 1;\n     let _ = closure(1);\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_parameter_type() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_parameter_type() {\n     let closure = |x: u16| (x as u64) + 1;\n     let _ = closure(1);\n }"}, {"sha": "47f5a2d2bbe85a7c9f855ea3311695714826c839", "filename": "src/test/incremental/hashes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "541261f1d80dd59d8c860ea86648b5096013e507", "filename": "src/test/incremental/hashes/enum_constructors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "02746785856cc6fe5e93abf6b4eddc3863f54151", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -23,7 +23,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "a796c87f19bbf10cc8234c241c570eafc94a89bd", "filename": "src/test/incremental/hashes/exported_vs_not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -10,7 +10,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "bcdd5661e71817ba050336ad2fee672ccf7efe0d", "filename": "src/test/incremental/hashes/extern_mods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "105afd30d28ab9a1d6ae6f264a564ac69548c4a7", "filename": "src/test/incremental/hashes/for_loops.rs", "status": "modified", "additions": 45, "deletions": 67, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n@@ -27,7 +27,7 @@\n \n // Change loop body ------------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_loop_body() {\n+pub fn change_loop_body() {\n     let mut _x = 0;\n     for _ in 0..1 {\n         _x = 1;\n@@ -36,11 +36,9 @@ fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_loop_body() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_loop_body() {\n     let mut _x = 0;\n     for _ in 0..1 {\n         _x = 2;\n@@ -52,7 +50,7 @@ fn change_loop_body() {\n \n // Change iteration variable name ----------------------------------------------\n #[cfg(cfail1)]\n-fn change_iteration_variable_name() {\n+pub fn change_iteration_variable_name() {\n     let mut _x = 0;\n     for _i in 0..1 {\n         _x = 1;\n@@ -61,11 +59,9 @@ fn change_iteration_variable_name() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_iteration_variable_name() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_iteration_variable_name() {\n     let mut _x = 0;\n     for _a in 0..1 {\n         _x = 1;\n@@ -77,7 +73,7 @@ fn change_iteration_variable_name() {\n \n // Change iteration variable pattern -------------------------------------------\n #[cfg(cfail1)]\n-fn change_iteration_variable_pattern() {\n+pub fn change_iteration_variable_pattern() {\n     let mut _x = 0;\n     for _i in &[0, 1, 2] {\n         _x = 1;\n@@ -86,11 +82,9 @@ fn change_iteration_variable_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_iteration_variable_pattern() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_iteration_variable_pattern() {\n     let mut _x = 0;\n     for &_i in &[0, 1, 2] {\n         _x = 1;\n@@ -102,7 +96,7 @@ fn change_iteration_variable_pattern() {\n \n // Change iterable -------------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_iterable() {\n+pub fn change_iterable() {\n     let mut _x = 0;\n     for _ in &[0, 1, 2] {\n         _x = 1;\n@@ -111,11 +105,9 @@ fn change_iterable() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_iterable() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_iterable() {\n     let mut _x = 0;\n     for _ in &[0, 1, 3] {\n         _x = 1;\n@@ -127,19 +119,17 @@ fn change_iterable() {\n \n // Add break -------------------------------------------------------------------\n #[cfg(cfail1)]\n-fn add_break() {\n+pub fn add_break() {\n     let mut _x = 0;\n     for _ in 0..1 {\n         _x = 1;\n     }\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_break() {\n     let mut _x = 0;\n     for _ in 0..1 {\n         _x = 1;\n@@ -151,7 +141,7 @@ fn add_break() {\n \n // Add loop label --------------------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label() {\n+pub fn add_loop_label() {\n     let mut _x = 0;\n     for _ in 0..1 {\n         _x = 1;\n@@ -160,11 +150,9 @@ fn add_loop_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label() {\n     let mut _x = 0;\n     'label: for _ in 0..1 {\n         _x = 1;\n@@ -176,7 +164,7 @@ fn add_loop_label() {\n \n // Add loop label to break -----------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label_to_break() {\n+pub fn add_loop_label_to_break() {\n     let mut _x = 0;\n     'label: for _ in 0..1 {\n         _x = 1;\n@@ -185,11 +173,9 @@ fn add_loop_label_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label_to_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label_to_break() {\n     let mut _x = 0;\n     'label: for _ in 0..1 {\n         _x = 1;\n@@ -201,7 +187,7 @@ fn add_loop_label_to_break() {\n \n // Change break label ----------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_break_label() {\n+pub fn change_break_label() {\n     let mut _x = 0;\n     'outer: for _ in 0..1 {\n         'inner: for _ in 0..1 {\n@@ -212,11 +198,9 @@ fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_break_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_break_label() {\n     let mut _x = 0;\n     'outer: for _ in 0..1 {\n         'inner: for _ in 0..1 {\n@@ -230,7 +214,7 @@ fn change_break_label() {\n \n // Add loop label to continue --------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label_to_continue() {\n+pub fn add_loop_label_to_continue() {\n     let mut _x = 0;\n     'label: for _ in 0..1 {\n         _x = 1;\n@@ -239,11 +223,9 @@ fn add_loop_label_to_continue() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label_to_continue() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label_to_continue() {\n     let mut _x = 0;\n     'label: for _ in 0..1 {\n         _x = 1;\n@@ -255,7 +237,7 @@ fn add_loop_label_to_continue() {\n \n // Change continue label ----------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_continue_label() {\n+pub fn change_continue_label() {\n     let mut _x = 0;\n     'outer: for _ in 0..1 {\n         'inner: for _ in 0..1 {\n@@ -266,11 +248,9 @@ fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_continue_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_continue_label() {\n     let mut _x = 0;\n     'outer: for _ in 0..1 {\n         'inner: for _ in 0..1 {\n@@ -284,7 +264,7 @@ fn change_continue_label() {\n \n // Change continue to break ----------------------------------------------------\n #[cfg(cfail1)]\n-fn change_continue_to_break() {\n+pub fn change_continue_to_break() {\n     let mut _x = 0;\n     for _ in 0..1 {\n         _x = 1;\n@@ -293,11 +273,9 @@ fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_continue_to_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_continue_to_break() {\n     let mut _x = 0;\n     for _ in 0..1 {\n         _x = 1;"}, {"sha": "abe0586efcd7fd654eef5205e73d858e5d758875", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 125, "deletions": 111, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,331 +18,345 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n \n #![allow(warnings)]\n #![feature(conservative_impl_trait)]\n #![feature(intrinsics)]\n #![feature(linkage)]\n #![feature(rustc_attrs)]\n-#![crate_type=\"rlib\"]\n+#![crate_type = \"rlib\"]\n \n \n // Add Parameter ---------------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn add_parameter() {}\n+pub fn add_parameter() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn add_parameter(p: i32) {}\n+#[rustc_clean(cfg = \"cfail2\",\n+              except = \"Hir, HirBody, MirValidated, MirOptimized, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn add_parameter(p: i32) {}\n \n \n // Add Return Type -------------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn add_return_type() {}\n+pub fn add_return_type() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn add_return_type() -> () {}\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn add_return_type() -> () {}\n \n \n // Change Parameter Type -------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn type_of_parameter(p: i32) {}\n+pub fn type_of_parameter(p: i32) {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn type_of_parameter(p: i64) {}\n+#[rustc_clean(cfg = \"cfail2\",\n+              except = \"Hir, HirBody, MirValidated, MirOptimized, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn type_of_parameter(p: i64) {}\n \n \n // Change Parameter Type Reference ---------------------------------------------\n \n #[cfg(cfail1)]\n-fn type_of_parameter_ref(p: &i32) {}\n+pub fn type_of_parameter_ref(p: &i32) {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn type_of_parameter_ref(p: &mut i32) {}\n+#[rustc_clean(cfg = \"cfail2\",\n+              except = \"Hir, HirBody, MirValidated, MirOptimized, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn type_of_parameter_ref(p: &mut i32) {}\n \n \n // Change Parameter Order ------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn order_of_parameters(p1: i32, p2: i64) {}\n+pub fn order_of_parameters(p1: i32, p2: i64) {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn order_of_parameters(p2: i64, p1: i32) {}\n+#[rustc_clean(cfg = \"cfail2\",\n+              except = \"Hir, HirBody, MirValidated, MirOptimized, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn order_of_parameters(p2: i64, p1: i32) {}\n \n \n // Unsafe ----------------------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn make_unsafe() {}\n+pub fn make_unsafe() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-unsafe fn make_unsafe() {}\n+#[rustc_clean(cfg = \"cfail2\",\n+              except = \"Hir, HirBody, MirValidated, MirOptimized, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub unsafe fn make_unsafe() {}\n \n \n // Extern ----------------------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn make_extern() {}\n+pub fn make_extern() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-extern fn make_extern() {}\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub extern \"C\" fn make_extern() {}\n \n \n // Extern C Extern Rust-Intrinsic ----------------------------------------------\n \n #[cfg(cfail1)]\n-extern \"C\" fn make_intrinsic() {}\n+pub extern \"C\" fn make_intrinsic() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-extern \"rust-intrinsic\" fn make_intrinsic() {}\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub extern \"rust-intrinsic\" fn make_intrinsic() {}\n \n \n // Type Parameter --------------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn type_parameter() {}\n+pub fn type_parameter() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn type_parameter<T>() {}\n+#[rustc_clean(cfg = \"cfail2\",\n+              except = \"Hir, HirBody, GenericsOfItem, TypeOfItem, PredicatesOfItem\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn type_parameter<T>() {}\n \n \n // Lifetime Parameter ----------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn lifetime_parameter() {}\n+pub fn lifetime_parameter() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn lifetime_parameter<'a>() {}\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, GenericsOfItem\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn lifetime_parameter<'a>() {}\n \n \n // Trait Bound -----------------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn trait_bound<T>() {}\n+pub fn trait_bound<T>() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn trait_bound<T: Eq>() {}\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, PredicatesOfItem\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn trait_bound<T: Eq>() {}\n \n \n // Builtin Bound ---------------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn builtin_bound<T>() {}\n+pub fn builtin_bound<T>() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn builtin_bound<T: Send>() {}\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, PredicatesOfItem\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn builtin_bound<T: Send>() {}\n \n \n // Lifetime Bound --------------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn lifetime_bound<'a, T>() {}\n+pub fn lifetime_bound<'a, T>() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn lifetime_bound<'a, T: 'a>() {}\n+#[rustc_clean(cfg = \"cfail2\",\n+              except = \"Hir, HirBody, GenericsOfItem, TypeOfItem, PredicatesOfItem\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn lifetime_bound<'a, T: 'a>() {}\n \n \n // Second Trait Bound ----------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn second_trait_bound<T: Eq>() {}\n+pub fn second_trait_bound<T: Eq>() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn second_trait_bound<T: Eq + Clone>() {}\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, PredicatesOfItem\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn second_trait_bound<T: Eq + Clone>() {}\n \n \n // Second Builtin Bound --------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn second_builtin_bound<T: Send>() {}\n+pub fn second_builtin_bound<T: Send>() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn second_builtin_bound<T: Send + Sized>() {}\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, PredicatesOfItem\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn second_builtin_bound<T: Send + Sized>() {}\n \n \n // Second Lifetime Bound -------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn second_lifetime_bound<'a, 'b, T: 'a>() {}\n+pub fn second_lifetime_bound<'a, 'b, T: 'a>() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn second_lifetime_bound<'a, 'b, T: 'a + 'b>() {}\n+#[rustc_clean(cfg = \"cfail2\",\n+              except = \"Hir, HirBody, GenericsOfItem, TypeOfItem, PredicatesOfItem\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn second_lifetime_bound<'a, 'b, T: 'a + 'b>() {}\n \n \n // Inline ----------------------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn inline() {}\n+pub fn inline() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n #[inline]\n-fn inline() {}\n+pub fn inline() {}\n \n \n // Inline Never ----------------------------------------------------------------\n \n #[cfg(cfail1)]\n #[inline(always)]\n-fn inline_never() {}\n+pub fn inline_never() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n #[inline(never)]\n-fn inline_never() {}\n+pub fn inline_never() {}\n \n \n // No Mangle -------------------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn no_mangle() {}\n+pub fn no_mangle() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n #[no_mangle]\n-fn no_mangle() {}\n+pub fn no_mangle() {}\n \n \n // Linkage ---------------------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn linkage() {}\n+pub fn linkage() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[linkage=\"weak_odr\"]\n-fn linkage() {}\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+#[linkage = \"weak_odr\"]\n+pub fn linkage() {}\n \n \n // Return Impl Trait -----------------------------------------------------------\n \n #[cfg(cfail1)]\n-fn return_impl_trait() -> i32 {\n+pub fn return_impl_trait() -> i32 {\n     0\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn return_impl_trait() -> impl Clone {\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn return_impl_trait() -> impl Clone {\n     0\n }\n \n \n // Change Return Impl Trait ----------------------------------------------------\n \n #[cfg(cfail1)]\n-fn change_return_impl_trait() -> impl Clone {\n+pub fn change_return_impl_trait() -> impl Clone {\n     0u32\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-fn change_return_impl_trait() -> impl Copy {\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody\")]\n+#[rustc_clean(cfg = \"cfail3\")]\n+pub fn change_return_impl_trait() -> impl Copy {\n     0u32\n }\n \n \n // Change Return Type Indirectly -----------------------------------------------\n \n-struct ReferencedType1;\n-struct ReferencedType2;\n+pub struct ReferencedType1;\n+pub struct ReferencedType2;\n \n-mod change_return_type_indirectly {\n+pub mod change_return_type_indirectly {\n     #[cfg(cfail1)]\n     use super::ReferencedType1 as ReturnType;\n     #[cfg(not(cfail1))]\n     use super::ReferencedType2 as ReturnType;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    fn indirect_return_type() -> ReturnType {\n+    #[rustc_clean(cfg = \"cfail2\",\n+                  except = \"Hir, HirBody, MirValidated, MirOptimized, TypeckTables, FnSignature\")]\n+    #[rustc_clean(cfg = \"cfail3\")]\n+    pub fn indirect_return_type() -> ReturnType {\n         ReturnType {}\n     }\n }\n \n \n // Change Parameter Type Indirectly --------------------------------------------\n \n-mod change_parameter_type_indirectly {\n+pub mod change_parameter_type_indirectly {\n     #[cfg(cfail1)]\n     use super::ReferencedType1 as ParameterType;\n     #[cfg(not(cfail1))]\n     use super::ReferencedType2 as ParameterType;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    fn indirect_parameter_type(p: ParameterType) {}\n+    #[rustc_clean(cfg = \"cfail2\",\n+                  except = \"Hir, HirBody, MirValidated, MirOptimized, TypeckTables, FnSignature\")]\n+    #[rustc_clean(cfg = \"cfail3\")]\n+    pub fn indirect_parameter_type(p: ParameterType) {}\n }\n \n \n // Change Trait Bound Indirectly -----------------------------------------------\n \n-trait ReferencedTrait1 {}\n-trait ReferencedTrait2 {}\n+pub trait ReferencedTrait1 {}\n+pub trait ReferencedTrait2 {}\n \n-mod change_trait_bound_indirectly {\n+pub mod change_trait_bound_indirectly {\n     #[cfg(cfail1)]\n     use super::ReferencedTrait1 as Trait;\n     #[cfg(not(cfail1))]\n     use super::ReferencedTrait2 as Trait;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    fn indirect_trait_bound<T: Trait>(p: T) {}\n+    #[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, PredicatesOfItem\")]\n+    #[rustc_clean(cfg = \"cfail3\")]\n+    pub fn indirect_trait_bound<T: Trait>(p: T) {}\n }\n \n \n // Change Trait Bound Indirectly In Where Clause -------------------------------\n \n-mod change_trait_bound_indirectly_in_where_clause {\n+pub mod change_trait_bound_indirectly_in_where_clause {\n     #[cfg(cfail1)]\n     use super::ReferencedTrait1 as Trait;\n     #[cfg(not(cfail1))]\n     use super::ReferencedTrait2 as Trait;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    fn indirect_trait_bound_where<T>(p: T) where T: Trait {}\n+    #[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, PredicatesOfItem\")]\n+    #[rustc_clean(cfg = \"cfail3\")]\n+    pub fn indirect_trait_bound_where<T>(p: T)\n+    where\n+        T: Trait,\n+    {\n+    }\n }"}, {"sha": "426c58c834defad7a2ec8efe2208f415768471eb", "filename": "src/test/incremental/hashes/if_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n \n #![allow(warnings)]"}, {"sha": "e66e239b33c9571fa4f73840da1cea10a9d3a202", "filename": "src/test/incremental/hashes/indexing_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "93aba4a3ee11e5a696660fb720cc714078ce3b00", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n \n #![allow(warnings)]"}, {"sha": "b93a96566031c50f55f8b7948f16f4355de2cac9", "filename": "src/test/incremental/hashes/inline_asm.rs", "status": "modified", "additions": 25, "deletions": 37, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n@@ -30,7 +30,7 @@\n // Change template -------------------------------------------------------------\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_template(a: i32) -> i32 {\n+pub fn change_template(a: i32) -> i32 {\n     let c: i32;\n     unsafe {\n         asm!(\"add 1, $0\"\n@@ -44,12 +44,10 @@ fn change_template(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_template(a: i32) -> i32 {\n+pub fn change_template(a: i32) -> i32 {\n     let c: i32;\n     unsafe {\n         asm!(\"add 2, $0\"\n@@ -67,7 +65,7 @@ fn change_template(a: i32) -> i32 {\n // Change output -------------------------------------------------------------\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_output(a: i32) -> i32 {\n+pub fn change_output(a: i32) -> i32 {\n     let mut _out1: i32 = 0;\n     let mut _out2: i32 = 0;\n     unsafe {\n@@ -82,12 +80,10 @@ fn change_output(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_output(a: i32) -> i32 {\n+pub fn change_output(a: i32) -> i32 {\n     let mut _out1: i32 = 0;\n     let mut _out2: i32 = 0;\n     unsafe {\n@@ -106,7 +102,7 @@ fn change_output(a: i32) -> i32 {\n // Change input -------------------------------------------------------------\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_input(_a: i32, _b: i32) -> i32 {\n+pub fn change_input(_a: i32, _b: i32) -> i32 {\n     let _out;\n     unsafe {\n         asm!(\"add 1, $0\"\n@@ -120,12 +116,10 @@ fn change_input(_a: i32, _b: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_input(_a: i32, _b: i32) -> i32 {\n+pub fn change_input(_a: i32, _b: i32) -> i32 {\n     let _out;\n     unsafe {\n         asm!(\"add 1, $0\"\n@@ -143,7 +137,7 @@ fn change_input(_a: i32, _b: i32) -> i32 {\n // Change input constraint -----------------------------------------------------\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n+pub fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n     let _out;\n     unsafe {\n         asm!(\"add 1, $0\"\n@@ -157,12 +151,10 @@ fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n+pub fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n     let _out;\n     unsafe {\n         asm!(\"add 1, $0\"\n@@ -180,7 +172,7 @@ fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n // Change clobber --------------------------------------------------------------\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_clobber(_a: i32) -> i32 {\n+pub fn change_clobber(_a: i32) -> i32 {\n     let _out;\n     unsafe {\n         asm!(\"add 1, $0\"\n@@ -194,12 +186,10 @@ fn change_clobber(_a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_clobber(_a: i32) -> i32 {\n+pub fn change_clobber(_a: i32) -> i32 {\n     let _out;\n     unsafe {\n         asm!(\"add 1, $0\"\n@@ -217,7 +207,7 @@ fn change_clobber(_a: i32) -> i32 {\n // Change options --------------------------------------------------------------\n #[cfg(cfail1)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_options(_a: i32) -> i32 {\n+pub fn change_options(_a: i32) -> i32 {\n     let _out;\n     unsafe {\n         asm!(\"add 1, $0\"\n@@ -231,12 +221,10 @@ fn change_options(_a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn change_options(_a: i32) -> i32 {\n+pub fn change_options(_a: i32) -> i32 {\n     let _out;\n     unsafe {\n         asm!(\"add 1, $0\""}, {"sha": "851b13c705516783e8f564880ce32723dd6451d8", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n \n #![allow(warnings)]"}, {"sha": "dcb937fd867abce00e4b62f5755d196df92d4768", "filename": "src/test/incremental/hashes/loop_expressions.rs", "status": "modified", "additions": 33, "deletions": 49, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n@@ -27,7 +27,7 @@\n \n // Change loop body ------------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_loop_body() {\n+pub fn change_loop_body() {\n     let mut _x = 0;\n     loop {\n         _x = 1;\n@@ -36,11 +36,9 @@ fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_loop_body() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_loop_body() {\n     let mut _x = 0;\n     loop {\n         _x = 2;\n@@ -52,19 +50,17 @@ fn change_loop_body() {\n \n // Add break -------------------------------------------------------------------\n #[cfg(cfail1)]\n-fn add_break() {\n+pub fn add_break() {\n     let mut _x = 0;\n     loop {\n         _x = 1;\n     }\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_break() {\n     let mut _x = 0;\n     loop {\n         _x = 1;\n@@ -76,7 +72,7 @@ fn add_break() {\n \n // Add loop label --------------------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label() {\n+pub fn add_loop_label() {\n     let mut _x = 0;\n     loop {\n         _x = 1;\n@@ -85,11 +81,9 @@ fn add_loop_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label() {\n     let mut _x = 0;\n     'label: loop {\n         _x = 1;\n@@ -101,7 +95,7 @@ fn add_loop_label() {\n \n // Add loop label to break -----------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label_to_break() {\n+pub fn add_loop_label_to_break() {\n     let mut _x = 0;\n     'label: loop {\n         _x = 1;\n@@ -110,11 +104,9 @@ fn add_loop_label_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label_to_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label_to_break() {\n     let mut _x = 0;\n     'label: loop {\n         _x = 1;\n@@ -126,7 +118,7 @@ fn add_loop_label_to_break() {\n \n // Change break label ----------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_break_label() {\n+pub fn change_break_label() {\n     let mut _x = 0;\n     'outer: loop {\n         'inner: loop {\n@@ -137,11 +129,9 @@ fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_break_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_break_label() {\n     let mut _x = 0;\n     'outer: loop {\n         'inner: loop {\n@@ -155,7 +145,7 @@ fn change_break_label() {\n \n // Add loop label to continue --------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label_to_continue() {\n+pub fn add_loop_label_to_continue() {\n     let mut _x = 0;\n     'label: loop {\n         _x = 1;\n@@ -164,11 +154,9 @@ fn add_loop_label_to_continue() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label_to_continue() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label_to_continue() {\n     let mut _x = 0;\n     'label: loop {\n         _x = 1;\n@@ -180,7 +168,7 @@ fn add_loop_label_to_continue() {\n \n // Change continue label ----------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_continue_label() {\n+pub fn change_continue_label() {\n     let mut _x = 0;\n     'outer: loop {\n         'inner: loop {\n@@ -191,11 +179,9 @@ fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_continue_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_continue_label() {\n     let mut _x = 0;\n     'outer: loop {\n         'inner: loop {\n@@ -209,7 +195,7 @@ fn change_continue_label() {\n \n // Change continue to break ----------------------------------------------------\n #[cfg(cfail1)]\n-fn change_continue_to_break() {\n+pub fn change_continue_to_break() {\n     let mut _x = 0;\n     loop {\n         _x = 1;\n@@ -218,11 +204,9 @@ fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_continue_to_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_continue_to_break() {\n     let mut _x = 0;\n     loop {\n         _x = 1;"}, {"sha": "263901f402540b46ce63b65df8b0e8efa7e1910d", "filename": "src/test/incremental/hashes/match_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n \n #![allow(warnings)]"}, {"sha": "2b6a140be32a90920847b6a8c8bfcfa93c191b0e", "filename": "src/test/incremental/hashes/panic_exprs.rs", "status": "modified", "additions": 72, "deletions": 93, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -28,155 +28,134 @@\n \n \n // Indexing expression ---------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn indexing(slice: &[u8]) -> u8 {\n-    slice[100]\n-}\n-\n-#[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn indexing(slice: &[u8]) -> u8 {\n-    slice[100]\n+    #[cfg(cfail1)]\n+    {\n+        slice[100]\n+    }\n+    #[cfg(not(cfail1))]\n+    {\n+        slice[100]\n+    }\n }\n \n \n // Arithmetic overflow plus ----------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n-    val + 1\n-}\n-\n-#[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n-    val + 1\n+    #[cfg(cfail1)]\n+    {\n+        val + 1\n+    }\n+    #[cfg(not(cfail1))]\n+    {\n+        val + 1\n+    }\n }\n \n \n // Arithmetic overflow minus ----------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n-    val - 1\n-}\n-\n-#[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n-    val - 1\n+    #[cfg(cfail1)]\n+    {\n+        val - 1\n+    }\n+    #[cfg(not(cfail1))]\n+    {\n+        val - 1\n+    }\n }\n \n \n // Arithmetic overflow mult ----------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n-    val * 2\n-}\n-\n-#[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n-    val * 2\n+    #[cfg(cfail1)]\n+    {\n+        val * 2\n+    }\n+    #[cfg(not(cfail1))]\n+    {\n+        val * 2\n+    }\n }\n \n \n // Arithmetic overflow negation ------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n-    -val\n-}\n-\n-#[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n-    -val\n+    #[cfg(cfail1)]\n+    {\n+        -val\n+    }\n+    #[cfg(not(cfail1))]\n+    {\n+        -val\n+    }\n }\n \n \n // Division by zero ------------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn division_by_zero(val: i32) -> i32 {\n-    2 / val\n-}\n-\n-#[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn division_by_zero(val: i32) -> i32 {\n-    2 / val\n+    #[cfg(cfail1)]\n+    {\n+        2 / val\n+    }\n+    #[cfg(not(cfail1))]\n+    {\n+        2 / val\n+    }\n }\n \n // Division by zero ------------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn mod_by_zero(val: i32) -> i32 {\n-    2 % val\n-}\n-\n-#[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn mod_by_zero(val: i32) -> i32 {\n-    2 % val\n+    #[cfg(cfail1)]\n+    {\n+        2 % val\n+    }\n+    #[cfg(not(cfail1))]\n+    {\n+        2 % val\n+    }\n }\n \n \n // shift left ------------------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn shift_left(val: i32, shift: usize) -> i32 {\n-    val << shift\n-}\n-\n-#[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn shift_left(val: i32, shift: usize) -> i32 {\n-    val << shift\n+    #[cfg(cfail1)]\n+    {\n+        val << shift\n+    }\n+    #[cfg(not(cfail1))]\n+    {\n+        val << shift\n+    }\n }\n \n \n // shift right ------------------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn shift_right(val: i32, shift: usize) -> i32 {\n-    val >> shift\n-}\n-\n-#[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn shift_right(val: i32, shift: usize) -> i32 {\n-    val >> shift\n-}\n-\n-\n-// THE FOLLOWING ITEMS SHOULD NOT BE INFLUENCED BY THEIR SOURCE LOCATION\n-\n-// bitwise ---------------------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn bitwise(val: i32) -> i32 {\n-    !val & 0x101010101 | 0x45689 ^ 0x2372382\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-pub fn bitwise(val: i32) -> i32 {\n-    !val & 0x101010101 | 0x45689 ^ 0x2372382\n-}\n-\n-\n-// logical ---------------------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n-    val1 && val2 || val3\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n-    val1 && val2 || val3\n+    #[cfg(cfail1)]\n+    {\n+        val >> shift\n+    }\n+    #[cfg(not(cfail1))]\n+    {\n+        val >> shift\n+    }\n }"}, {"sha": "8402da04091ece13929b08973878c89b50346b59", "filename": "src/test/incremental/hashes/panic_exprs_no_overflow_checks.rs", "status": "removed", "additions": 0, "deletions": 225, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,225 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This test case tests the incremental compilation hash (ICH) implementation\n-// for exprs that can panic at runtime (e.g. because of bounds checking). For\n-// these expressions an error message containing their source location is\n-// generated, so their hash must always depend on their location in the source\n-// code, not just when debuginfo is enabled.\n-\n-// As opposed to the panic_exprs.rs test case, this test case checks that things\n-// behave as expected when overflow checks are off:\n-//\n-// - Addition, subtraction, and multiplication do not change the ICH, unless\n-//   the function containing them is marked with rustc_inherit_overflow_checks.\n-// - Division by zero and bounds checks always influence the ICH\n-\n-// The general pattern followed here is: Change one thing between rev1 and rev2\n-// and make sure that the hash has changed, then change nothing between rev2 and\n-// rev3 and make sure that the hash has not changed.\n-\n-// must-compile-successfully\n-// revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph -Z force-overflow-checks=off\n-\n-#![allow(warnings)]\n-#![feature(rustc_attrs)]\n-#![crate_type=\"rlib\"]\n-\n-\n-// Indexing expression ---------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn indexing(slice: &[u8]) -> u8 {\n-    slice[100]\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-pub fn indexing(slice: &[u8]) -> u8 {\n-    slice[100]\n-}\n-\n-\n-// Arithmetic overflow plus ----------------------------------------------------\n-#[cfg(cfail1)]\n-#[rustc_inherit_overflow_checks]\n-pub fn arithmetic_overflow_plus_inherit(val: i32) -> i32 {\n-    val + 1\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_inherit_overflow_checks]\n-pub fn arithmetic_overflow_plus_inherit(val: i32) -> i32 {\n-    val + 1\n-}\n-\n-\n-// Arithmetic overflow minus ----------------------------------------------------\n-#[cfg(cfail1)]\n-#[rustc_inherit_overflow_checks]\n-pub fn arithmetic_overflow_minus_inherit(val: i32) -> i32 {\n-    val - 1\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_inherit_overflow_checks]\n-pub fn arithmetic_overflow_minus_inherit(val: i32) -> i32 {\n-    val - 1\n-}\n-\n-\n-// Arithmetic overflow mult ----------------------------------------------------\n-#[cfg(cfail1)]\n-#[rustc_inherit_overflow_checks]\n-pub fn arithmetic_overflow_mult_inherit(val: i32) -> i32 {\n-    val * 2\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_inherit_overflow_checks]\n-pub fn arithmetic_overflow_mult_inherit(val: i32) -> i32 {\n-    val * 2\n-}\n-\n-\n-// Arithmetic overflow negation ------------------------------------------------\n-#[cfg(cfail1)]\n-#[rustc_inherit_overflow_checks]\n-pub fn arithmetic_overflow_negation_inherit(val: i32) -> i32 {\n-    -val\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_inherit_overflow_checks]\n-pub fn arithmetic_overflow_negation_inherit(val: i32) -> i32 {\n-    -val\n-}\n-\n-\n-// Division by zero ------------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn division_by_zero(val: i32) -> i32 {\n-    2 / val\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-pub fn division_by_zero(val: i32) -> i32 {\n-    2 / val\n-}\n-\n-// Division by zero ------------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn mod_by_zero(val: i32) -> i32 {\n-    2 % val\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-pub fn mod_by_zero(val: i32) -> i32 {\n-    2 % val\n-}\n-\n-\n-\n-// THE FOLLOWING ITEMS SHOULD NOT BE INFLUENCED BY THEIR SOURCE LOCATION\n-\n-// bitwise ---------------------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn bitwise(val: i32) -> i32 {\n-    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-pub fn bitwise(val: i32) -> i32 {\n-    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n-}\n-\n-\n-// logical ---------------------------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n-    val1 && val2 || val3\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n-    val1 && val2 || val3\n-}\n-\n-// Arithmetic overflow plus ----------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n-    val + 1\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n-    val + 1\n-}\n-\n-\n-// Arithmetic overflow minus ----------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n-    val - 1\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n-    val - 1\n-}\n-\n-\n-// Arithmetic overflow mult ----------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n-    val * 2\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n-    val * 2\n-}\n-\n-\n-// Arithmetic overflow negation ------------------------------------------------\n-#[cfg(cfail1)]\n-pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n-    -val\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\")]\n-#[rustc_clean(cfg=\"cfail3\")]\n-pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n-    -val\n-}"}, {"sha": "b9616d8c6b53e3af731f3319282f6dc695dda539", "filename": "src/test/incremental/hashes/statics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "3cdaf0e468a7a4844dcabfe64b9fd4120ff2dfbe", "filename": "src/test/incremental/hashes/struct_constructors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "d7b70720418d800a31281ee5f4380609d00a7e31", "filename": "src/test/incremental/hashes/struct_defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -23,7 +23,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n \n #![allow(warnings)]"}, {"sha": "0816d6e5f452cf097d8b9963e5395dde3909f0c9", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -23,7 +23,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "a232883f7a9b4fa4c5131d7f4b50f4f17c92fcc7", "filename": "src/test/incremental/hashes/trait_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n \n #![allow(warnings)]"}, {"sha": "c5521d2fae2ebea53bddb9af6ada38e5e0d10c5d", "filename": "src/test/incremental/hashes/type_defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -23,7 +23,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "85f6ef60c5dc0c5d1a891b6dcf53b7e8d193d412", "filename": "src/test/incremental/hashes/unary_and_binary_exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph -Z force-overflow-checks=off\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "d04ed03eb6670048bcf6081e97817c4db51e4922", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "modified", "additions": 37, "deletions": 55, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n@@ -27,7 +27,7 @@\n \n // Change loop body ------------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_loop_body() {\n+pub fn change_loop_body() {\n     let mut _x = 0;\n     while let Some(0u32) = None {\n         _x = 1;\n@@ -36,11 +36,9 @@ fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_loop_body() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_loop_body() {\n     let mut _x = 0;\n     while let Some(0u32) = None {\n         _x = 2;\n@@ -52,7 +50,7 @@ fn change_loop_body() {\n \n // Change loop body ------------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_loop_condition() {\n+pub fn change_loop_condition() {\n     let mut _x = 0;\n     while let Some(0u32) = None {\n         _x = 1;\n@@ -61,11 +59,9 @@ fn change_loop_condition() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_loop_condition() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_loop_condition() {\n     let mut _x = 0;\n     while let Some(1u32) = None {\n         _x = 1;\n@@ -77,19 +73,17 @@ fn change_loop_condition() {\n \n // Add break -------------------------------------------------------------------\n #[cfg(cfail1)]\n-fn add_break() {\n+pub fn add_break() {\n     let mut _x = 0;\n     while let Some(0u32) = None {\n         _x = 1;\n     }\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_break() {\n     let mut _x = 0;\n     while let Some(0u32) = None {\n         _x = 1;\n@@ -101,7 +95,7 @@ fn add_break() {\n \n // Add loop label --------------------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label() {\n+pub fn add_loop_label() {\n     let mut _x = 0;\n     while let Some(0u32) = None {\n         _x = 1;\n@@ -110,11 +104,9 @@ fn add_loop_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label() {\n     let mut _x = 0;\n     'label: while let Some(0u32) = None {\n         _x = 1;\n@@ -126,7 +118,7 @@ fn add_loop_label() {\n \n // Add loop label to break -----------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label_to_break() {\n+pub fn add_loop_label_to_break() {\n     let mut _x = 0;\n     'label: while let Some(0u32) = None {\n         _x = 1;\n@@ -135,11 +127,9 @@ fn add_loop_label_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label_to_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label_to_break() {\n     let mut _x = 0;\n     'label: while let Some(0u32) = None {\n         _x = 1;\n@@ -151,7 +141,7 @@ fn add_loop_label_to_break() {\n \n // Change break label ----------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_break_label() {\n+pub fn change_break_label() {\n     let mut _x = 0;\n     'outer: while let Some(0u32) = None {\n         'inner: while let Some(0u32) = None {\n@@ -162,11 +152,9 @@ fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_break_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_break_label() {\n     let mut _x = 0;\n     'outer: while let Some(0u32) = None {\n         'inner: while let Some(0u32) = None {\n@@ -180,7 +168,7 @@ fn change_break_label() {\n \n // Add loop label to continue --------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label_to_continue() {\n+pub fn add_loop_label_to_continue() {\n     let mut _x = 0;\n     'label: while let Some(0u32) = None {\n         _x = 1;\n@@ -189,11 +177,9 @@ fn add_loop_label_to_continue() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label_to_continue() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label_to_continue() {\n     let mut _x = 0;\n     'label: while let Some(0u32) = None {\n         _x = 1;\n@@ -205,7 +191,7 @@ fn add_loop_label_to_continue() {\n \n // Change continue label ----------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_continue_label() {\n+pub fn change_continue_label() {\n     let mut _x = 0;\n     'outer: while let Some(0u32) = None {\n         'inner: while let Some(0u32) = None {\n@@ -216,11 +202,9 @@ fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_continue_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_continue_label() {\n     let mut _x = 0;\n     'outer: while let Some(0u32) = None {\n         'inner: while let Some(0u32) = None {\n@@ -234,7 +218,7 @@ fn change_continue_label() {\n \n // Change continue to break ----------------------------------------------------\n #[cfg(cfail1)]\n-fn change_continue_to_break() {\n+pub fn change_continue_to_break() {\n     let mut _x = 0;\n     while let Some(0u32) = None {\n         _x = 1;\n@@ -243,11 +227,9 @@ fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_continue_to_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_continue_to_break() {\n     let mut _x = 0;\n     while let Some(0u32) = None {\n         _x = 1;"}, {"sha": "7f2bbebde8047ab587655896c763b5bd90984480", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "modified", "additions": 37, "deletions": 55, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -18,7 +18,7 @@\n \n // must-compile-successfully\n // revisions: cfail1 cfail2 cfail3\n-// compile-flags: -Z query-dep-graph\n+// compile-flags: -Z query-dep-graph -Zincremental-ignore-spans\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n@@ -27,7 +27,7 @@\n \n // Change loop body ------------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_loop_body() {\n+pub fn change_loop_body() {\n     let mut _x = 0;\n     while true {\n         _x = 1;\n@@ -36,11 +36,9 @@ fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_loop_body() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_loop_body() {\n     let mut _x = 0;\n     while true {\n         _x = 2;\n@@ -52,7 +50,7 @@ fn change_loop_body() {\n \n // Change loop body ------------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_loop_condition() {\n+pub fn change_loop_condition() {\n     let mut _x = 0;\n     while true {\n         _x = 1;\n@@ -61,11 +59,9 @@ fn change_loop_condition() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_loop_condition() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_loop_condition() {\n     let mut _x = 0;\n     while false {\n         _x = 1;\n@@ -77,19 +73,17 @@ fn change_loop_condition() {\n \n // Add break -------------------------------------------------------------------\n #[cfg(cfail1)]\n-fn add_break() {\n+pub fn add_break() {\n     let mut _x = 0;\n     while true {\n         _x = 1;\n     }\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_break() {\n     let mut _x = 0;\n     while true {\n         _x = 1;\n@@ -101,7 +95,7 @@ fn add_break() {\n \n // Add loop label --------------------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label() {\n+pub fn add_loop_label() {\n     let mut _x = 0;\n     while true {\n         _x = 1;\n@@ -110,11 +104,9 @@ fn add_loop_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label() {\n     let mut _x = 0;\n     'label: while true {\n         _x = 1;\n@@ -126,7 +118,7 @@ fn add_loop_label() {\n \n // Add loop label to break -----------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label_to_break() {\n+pub fn add_loop_label_to_break() {\n     let mut _x = 0;\n     'label: while true {\n         _x = 1;\n@@ -135,11 +127,9 @@ fn add_loop_label_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label_to_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label_to_break() {\n     let mut _x = 0;\n     'label: while true {\n         _x = 1;\n@@ -151,7 +141,7 @@ fn add_loop_label_to_break() {\n \n // Change break label ----------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_break_label() {\n+pub fn change_break_label() {\n     let mut _x = 0;\n     'outer: while true {\n         'inner: while true {\n@@ -162,11 +152,9 @@ fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_break_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_break_label() {\n     let mut _x = 0;\n     'outer: while true {\n         'inner: while true {\n@@ -180,7 +168,7 @@ fn change_break_label() {\n \n // Add loop label to continue --------------------------------------------------\n #[cfg(cfail1)]\n-fn add_loop_label_to_continue() {\n+pub fn add_loop_label_to_continue() {\n     let mut _x = 0;\n     'label: while true {\n         _x = 1;\n@@ -189,11 +177,9 @@ fn add_loop_label_to_continue() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn add_loop_label_to_continue() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn add_loop_label_to_continue() {\n     let mut _x = 0;\n     'label: while true {\n         _x = 1;\n@@ -205,7 +191,7 @@ fn add_loop_label_to_continue() {\n \n // Change continue label ----------------------------------------------------------\n #[cfg(cfail1)]\n-fn change_continue_label() {\n+pub fn change_continue_label() {\n     let mut _x = 0;\n     'outer: while true {\n         'inner: while true {\n@@ -216,11 +202,9 @@ fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_continue_label() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_continue_label() {\n     let mut _x = 0;\n     'outer: while true {\n         'inner: while true {\n@@ -234,7 +218,7 @@ fn change_continue_label() {\n \n // Change continue to break ----------------------------------------------------\n #[cfg(cfail1)]\n-fn change_continue_to_break() {\n+pub fn change_continue_to_break() {\n     let mut _x = 0;\n     while true {\n         _x = 1;\n@@ -243,11 +227,9 @@ fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-fn change_continue_to_break() {\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n+pub fn change_continue_to_break() {\n     let mut _x = 0;\n     while true {\n         _x = 1;"}, {"sha": "996c9ed21cf678ded4b26c32177493bae0b25a8a", "filename": "src/test/incremental/ich_method_call_trait_scope.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -30,21 +30,10 @@ trait Trait2 {\n \n impl Trait2 for () { }\n \n-#[cfg(rpass1)]\n mod mod3 {\n+    #[cfg(rpass1)]\n     use Trait1;\n-\n-    fn bar() {\n-        ().method();\n-    }\n-\n-    fn baz() {\n-        22; // no method call, traits in scope don't matter\n-    }\n-}\n-\n-#[cfg(rpass2)]\n-mod mod3 {\n+    #[cfg(rpass2)]\n     use Trait2;\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]"}, {"sha": "8566a24c84b26a968629ea7c9b0528f9e6f7f0bb", "filename": "src/test/incremental/ich_nested_items.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fich_nested_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fich_nested_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_nested_items.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -17,23 +17,18 @@\n #![crate_type = \"rlib\"]\n #![feature(rustc_attrs)]\n \n-#[cfg(cfail1)]\n-pub fn foo() {\n-    pub fn bar() { }\n-    pub fn baz() { }\n-}\n-\n-#[cfg(cfail2)]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n pub fn foo() {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[cfg(cfail1)]\n     pub fn baz() { } // order is different...\n \n     #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n     pub fn bar() { } // but that doesn't matter.\n \n+    #[cfg(cfail2)]\n+    pub fn baz() { } // order is different...\n+\n     pub fn bap() { } // neither does adding a new item\n }"}, {"sha": "9e5b51f3e7a01dc624b3da6702bbf9fda82c5ee2", "filename": "src/test/incremental/ich_resolve_results.rs", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fich_resolve_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fich_resolve_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_resolve_results.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -25,49 +25,29 @@ mod mod2 {\n     pub struct Foo(pub i64);\n }\n \n-#[cfg(rpass1)]\n mod mod3 {\n-    use test;\n+    #[cfg(rpass1)]\n     use mod1::Foo;\n-\n-    fn in_expr() {\n-        Foo(0);\n-    }\n-\n-    fn in_type() {\n-        test::<Foo>();\n-    }\n-}\n-\n-#[cfg(rpass2)]\n-mod mod3 {\n-    use mod1::Foo; // <-- Nothing changed, but reordered!\n     use test;\n \n-    #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n-    fn in_expr() {\n-        Foo(0);\n-    }\n+    // In rpass2 we move the use declaration.\n+    #[cfg(rpass2)]\n+    use mod1::Foo;\n+\n+    // In rpass3 we let the declaration point to something else.\n+    #[cfg(rpass3)]\n+    use mod2::Foo;\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n     #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n-    fn in_type() {\n-        test::<Foo>();\n-    }\n-}\n-\n-#[cfg(rpass3)]\n-mod mod3 {\n-    use test;\n-    use mod2::Foo; // <-- This changed!\n-\n     #[rustc_clean(label=\"Hir\", cfg=\"rpass3\")]\n     #[rustc_dirty(label=\"HirBody\", cfg=\"rpass3\")]\n     fn in_expr() {\n         Foo(0);\n     }\n \n+    #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"rpass3\")]\n     #[rustc_dirty(label=\"HirBody\", cfg=\"rpass3\")]\n     fn in_type() {"}, {"sha": "3f669ae3fc86018527c60578602478e72ddbd0c1", "filename": "src/test/incremental/source_loc_macros.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fsource_loc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fsource_loc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fsource_loc_macros.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -35,28 +35,30 @@ fn file_same() {\n     let _ = file!();\n }\n \n-#[cfg(rpass1)]\n-fn line_different() {\n-    let _ = line!();\n-}\n-\n-#[cfg(rpass2)]\n #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n #[rustc_dirty(label=\"HirBody\", cfg=\"rpass2\")]\n fn line_different() {\n-    let _ = line!();\n-}\n-\n-#[cfg(rpass1)]\n-fn col_different() {\n-    let _ = column!();\n+    #[cfg(rpass1)]\n+    {\n+        let _ = line!();\n+    }\n+    #[cfg(rpass2)]\n+    {\n+        let _ = line!();\n+    }\n }\n \n-#[cfg(rpass2)]\n #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n #[rustc_dirty(label=\"HirBody\", cfg=\"rpass2\")]\n fn col_different() {\n-    let _ =        column!();\n+    #[cfg(rpass1)]\n+    {\n+        let _ = column!();\n+    }\n+    #[cfg(rpass2)]\n+    {\n+        let _ =        column!();\n+    }\n }\n \n fn main() {"}, {"sha": "90ec4a9d55831bb9b4ea4cd9dfa4ebc5392c6322", "filename": "src/test/incremental/spans_insignificant_w_o_debuginfo.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Fincremental%2Fspans_insignificant_w_o_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Fincremental%2Fspans_insignificant_w_o_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspans_insignificant_w_o_debuginfo.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This test makes sure that just changing a definition's location in the\n-// source file does *not* change its incr. comp. hash, if debuginfo is disabled.\n-\n-// revisions:rpass1 rpass2\n-\n-// compile-flags: -Z query-dep-graph\n-\n-#![feature(rustc_attrs)]\n-\n-#[cfg(rpass1)]\n-pub fn main() {}\n-\n-#[cfg(rpass2)]\n-#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n-pub fn main() {}"}, {"sha": "1fefec7a0a799969722c85c2ed63aa1081fbabfe", "filename": "src/test/incremental/spans_significant_w_panic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fspans_significant_w_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fincremental%2Fspans_significant_w_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspans_significant_w_panic.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -23,8 +23,7 @@ pub fn main() {\n }\n \n #[cfg(rpass2)]\n-#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"MirOptimized\", cfg=\"rpass2\")]\n pub fn main() {\n     let _ = 0u8 + 1;\n }"}, {"sha": "09288cf69ff586064efc7116894ccf6d5257dc89", "filename": "src/test/mir-opt/nll/liveness-call-subtlety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -28,18 +28,18 @@ fn main() {\n // START rustc.main.nll.0.mir\n //    | Live variables on entry to bb0: []\n //    bb0: {\n-//            | Live variables at bb0[0]: []\n+//            | Live variables on entry to bb0[0]: []\n //        StorageLive(_1);\n-//            | Live variables at bb0[1]: []\n+//            | Live variables on entry to bb0[1]: []\n //        _1 = const <std::boxed::Box<T>>::new(const 22usize) -> [return: bb2, unwind: bb1];\n //    }\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n //    | Live variables on entry to bb2: [_1 (drop)]\n //    bb2: {\n-//            | Live variables at bb2[0]: [_1 (drop)]\n+//            | Live variables on entry to bb2[0]: [_1 (drop)]\n //        StorageLive(_2);\n-//            | Live variables at bb2[1]: [_1 (drop)]\n+//            | Live variables on entry to bb2[1]: [_1 (drop)]\n //        _2 = const can_panic() -> [return: bb3, unwind: bb4];\n //    }\n // END rustc.main.nll.0.mir"}, {"sha": "b060222a95f1701ea42b1c9a5c7ec44b91db1556", "filename": "src/test/mir-opt/nll/liveness-drop-intra-block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -27,15 +27,15 @@ fn main() {\n // START rustc.main.nll.0.mir\n //    | Live variables on entry to bb2: []\n //    bb2: {\n-//            | Live variables at bb2[0]: []\n+//            | Live variables on entry to bb2[0]: []\n //        _1 = const 55usize;\n-//            | Live variables at bb2[1]: [_1]\n+//            | Live variables on entry to bb2[1]: [_1]\n //        StorageLive(_3);\n-//            | Live variables at bb2[2]: [_1]\n+//            | Live variables on entry to bb2[2]: [_1]\n //        StorageLive(_4);\n-//            | Live variables at bb2[3]: [_1]\n+//            | Live variables on entry to bb2[3]: [_1]\n //        _4 = _1;\n-//            | Live variables at bb2[4]: [_4]\n+//            | Live variables on entry to bb2[4]: [_4]\n //        _3 = const use_x(move _4) -> [return: bb3, unwind: bb1];\n //    }\n // END rustc.main.nll.0.mir"}, {"sha": "671f5e5292aa439029b6e98221ed7e51bb9da502", "filename": "src/test/mir-opt/nll/liveness-interblock.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -31,18 +31,18 @@ fn main() {\n // START rustc.main.nll.0.mir\n //     | Live variables on entry to bb3: [_1]\n //     bb3: {\n-//             | Live variables at bb3[0]: [_1]\n+//             | Live variables on entry to bb3[0]: [_1]\n //         StorageLive(_4);\n-//             | Live variables at bb3[1]: [_1]\n+//             | Live variables on entry to bb3[1]: [_1]\n //         _4 = _1;\n-//             | Live variables at bb3[2]: [_4]\n+//             | Live variables on entry to bb3[2]: [_4]\n //         _3 = const make_live(move _4) -> [return: bb5, unwind: bb1];\n //     }\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n //     | Live variables on entry to bb4: []\n //     bb4: {\n-//             | Live variables at bb4[0]: []\n+//             | Live variables on entry to bb4[0]: []\n //         _5 = const make_dead() -> [return: bb6, unwind: bb1];\n //     }\n // END rustc.main.nll.0.mir"}, {"sha": "0c42585a528e0c3d4c4f927109af14aeb9c2e5f4", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -26,9 +26,18 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.use_x.nll.0.mir\n-// | '_#0r: {bb0[0], bb0[1], '_#0r}\n-// | '_#1r: {bb0[0], bb0[1], '_#1r}\n-// | '_#2r: {bb0[0], bb0[1], '_#2r}\n-// | '_#3r: {bb0[0], bb0[1], '_#3r}\n+// | Free Region Mapping\n+// | '_#0r    | Global   | ['_#2r, '_#1r, '_#0r, '_#3r]\n+// | '_#1r    | External | ['_#1r]\n+// | '_#2r    | External | ['_#2r, '_#1r]\n+// | '_#3r    | Local    | ['_#3r]\n+// |\n+// | Inferred Region Values\n+// | '_#0r    | {bb0[0], bb0[1], '_#0r}\n+// | '_#1r    | {bb0[0], bb0[1], '_#1r}\n+// | '_#2r    | {bb0[0], bb0[1], '_#2r}\n+// | '_#3r    | {bb0[0], bb0[1], '_#3r}\n+// |\n+// ...\n // fn use_x(_1: &'_#1r mut i32, _2: &'_#2r u32, _3: &'_#1r u32, _4: &'_#3r u32) -> bool {\n // END rustc.use_x.nll.0.mir"}, {"sha": "d203472f20c737d5bb29a556a32abf17c7b3b41b", "filename": "src/test/mir-opt/nll/reborrow-basic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -28,11 +28,10 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#6r: {bb0[6], bb0[7], bb0[8], bb0[9], bb0[10], bb0[11], bb0[12], bb0[13], bb0[14]}\n+// | '_#6r    | {bb0[6], bb0[7], bb0[8], bb0[9], bb0[10], bb0[11], bb0[12], bb0[13], bb0[14]}\n+// ...\n+// | '_#8r    | {bb0[11], bb0[12], bb0[13], bb0[14]}\n // ...\n-// | '_#8r: {bb0[11], bb0[12], bb0[13], bb0[14]}\n-// END rustc.main.nll.0.mir\n-// START rustc.main.nll.0.mir\n // let _2: &'_#6r mut i32;\n // ...\n // let _4: &'_#8r mut i32;"}, {"sha": "c04cedbc04b4d95e1de5163bb4e1138c0489ee8e", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -31,26 +31,26 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[0], bb2[1], bb3[0], bb3[1]}\n-// | '_#2r: {bb2[1], bb3[0], bb3[1]}\n+// | '_#1r    | {bb2[0], bb2[1], bb3[0], bb3[1]}\n+// | '_#2r    | {bb2[1], bb3[0], bb3[1]}\n // ...\n //             let _2: &'_#2r usize;\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n //    bb2: {\n-//            | Live variables at bb2[0]: [_1, _3]\n+//            | Live variables on entry to bb2[0]: [_1, _3]\n //        _2 = &'_#1r _1[_3];\n-//            | Live variables at bb2[1]: [_2]\n+//            | Live variables on entry to bb2[1]: [_2]\n //        switchInt(const true) -> [0u8: bb4, otherwise: bb3];\n //    }\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n //    bb3: {\n-//            | Live variables at bb3[0]: [_2]\n+//            | Live variables on entry to bb3[0]: [_2]\n //        StorageLive(_7);\n-//            | Live variables at bb3[1]: [_2]\n+//            | Live variables on entry to bb3[1]: [_2]\n //        _7 = (*_2);\n-//            | Live variables at bb3[2]: [_7]\n+//            | Live variables on entry to bb3[2]: [_7]\n //        _6 = const use_x(move _7) -> [return: bb5, unwind: bb1];\n //    }\n // END rustc.main.nll.0.mir"}, {"sha": "e2ad49a443625f57c6b88e7c77622b1c7040bdf6", "filename": "src/test/mir-opt/nll/region-liveness-drop-may-dangle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -44,5 +44,5 @@ unsafe impl<#[may_dangle] T> Drop for Wrap<T> {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#5r: {bb2[3], bb2[4], bb2[5], bb3[0], bb3[1]}\n+// | '_#5r    | {bb2[3], bb2[4], bb2[5], bb3[0], bb3[1]}\n // END rustc.main.nll.0.mir"}, {"sha": "e0272a51d03d996459411d05db1d4ece24598c81", "filename": "src/test/mir-opt/nll/region-liveness-drop-no-may-dangle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -46,5 +46,5 @@ impl<T> Drop for Wrap<T> {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#5r: {bb2[3], bb2[4], bb2[5], bb3[0], bb3[1], bb3[2], bb4[0], bb5[0], bb5[1], bb5[2], bb6[0], bb7[0], bb7[1], bb8[0]}\n+// | '_#5r    | {bb2[3], bb2[4], bb2[5], bb3[0], bb3[1], bb3[2], bb4[0], bb5[0], bb5[1], bb5[2], bb6[0], bb7[0], bb7[1], bb8[0]}\n // END rustc.main.nll.0.mir"}, {"sha": "8aa0eb1a3a90eb0f15e403a8f9233f26e01728c5", "filename": "src/test/mir-opt/nll/region-liveness-two-disjoint-uses.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -36,10 +36,10 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[0], bb2[1], bb3[0], bb3[1]}\n+// | '_#1r    | {bb2[0], bb2[1], bb3[0], bb3[1]}\n // ...\n-// | '_#3r: {bb8[1], bb8[2], bb8[3], bb8[4]}\n-// | '_#4r: {bb2[1], bb3[0], bb3[1], bb8[2], bb8[3], bb8[4]}\n+// | '_#3r    | {bb8[1], bb8[2], bb8[3], bb8[4]}\n+// | '_#4r    | {bb2[1], bb3[0], bb3[1], bb8[2], bb8[3], bb8[4]}\n // ...\n // let mut _2: &'_#4r usize;\n // ..."}, {"sha": "2bc165bd3c4a3a6d6d47d602538fd2b507602c21", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -32,9 +32,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[0], bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n-// | '_#2r: {bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n-// | '_#3r: {bb2[5], bb2[6], bb3[0], bb3[1]}\n+// | '_#1r    | {bb2[0], bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n+// | '_#2r    | {bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n+// | '_#3r    | {bb2[5], bb2[6], bb3[0], bb3[1]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n // let _2: &'_#2r usize;"}, {"sha": "48f629fd82873d345a3088fa886f73f6514e0d34", "filename": "src/test/parse-fail/issue-17383.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fparse-fail%2Fissue-17383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fparse-fail%2Fissue-17383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-17383.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -12,7 +12,7 @@\n \n enum X {\n     A =\n-        b'a' //~ ERROR discriminator values can only be used with a c-like enum\n+        b'a' //~ ERROR discriminator values can only be used with a field-less enum\n     ,\n     B(isize)\n }"}, {"sha": "2d86589285c1aaad49f995008108430b3bcb1b1a", "filename": "src/test/parse-fail/tag-variant-disr-non-nullary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fparse-fail%2Ftag-variant-disr-non-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fparse-fail%2Ftag-variant-disr-non-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftag-variant-disr-non-nullary.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-//error-pattern: discriminator values can only be used with a c-like enum\n+//error-pattern: discriminator values can only be used with a field-less enum\n \n enum color {\n     red = 0xff0000,"}, {"sha": "4ec3f16f7af6da6ee3f300f9bf0a4acd32d0a686", "filename": "src/test/run-pass/abi-sysv64-arg-passing.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fabi-sysv64-arg-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fabi-sysv64-arg-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fabi-sysv64-arg-passing.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -39,7 +39,6 @@\n \n // note: windows is ignored as rust_test_helpers does not have the sysv64 abi on windows\n \n-#![feature(abi_sysv64)]\n #[allow(dead_code)]\n #[allow(improper_ctypes)]\n "}, {"sha": "1cae86712668b114e38b5152912ea69f85903f5e", "filename": "src/test/run-pass/abi-sysv64-register-usage.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fabi-sysv64-register-usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fabi-sysv64-register-usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fabi-sysv64-register-usage.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -15,7 +15,6 @@\n // ignore-arm\n // ignore-aarch64\n \n-#![feature(abi_sysv64)]\n #![feature(asm)]\n \n #[cfg(target_arch = \"x86_64\")]"}, {"sha": "22e40822eecfc8b52055dbeece2d9b99e58e88e4", "filename": "src/test/run-pass/auxiliary/svh-a-comment.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-comment.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `svh-a-*.rs` files are all deviations from the base file\n-//! svh-a-base.rs with some difference (usually in `fn foo`) that\n-//! should not affect the strict version hash (SVH) computation\n-//! (#14132).\n-\n-#![crate_name = \"a\"]\n-\n-macro_rules! three {\n-    () => { 3 }\n-}\n-\n-pub trait U {}\n-pub trait V {}\n-impl U for () {}\n-impl V for () {}\n-\n-static A_CONSTANT : isize = 2;\n-\n-pub fn foo<T:U>(_: isize) -> isize {\n-    // a comment does not affect the svh\n-    3\n-}\n-\n-pub fn an_unused_name() -> isize {\n-    4\n-}"}, {"sha": "3d8a728967a4a64bcc274b11818dedc1690d5a2f", "filename": "src/test/run-pass/auxiliary/svh-a-doc.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-doc.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `svh-a-*.rs` files are all deviations from the base file\n-//! svh-a-base.rs with some difference (usually in `fn foo`) that\n-//! should not affect the strict version hash (SVH) computation\n-//! (#14132).\n-\n-#![crate_name = \"a\"]\n-\n-macro_rules! three {\n-    () => { 3 }\n-}\n-\n-pub trait U {}\n-pub trait V {}\n-impl U for () {}\n-impl V for () {}\n-\n-static A_CONSTANT : isize = 2;\n-\n-// Adding some documentation does not affect the svh.\n-\n-/// foo always returns three.\n-pub fn foo<T:U>(_: isize) -> isize {\n-    3\n-}\n-\n-pub fn an_unused_name() -> isize {\n-    4\n-}"}, {"sha": "41d7eb7b18645f3ee181fee3406ec62aaea899fd", "filename": "src/test/run-pass/auxiliary/svh-a-macro.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-macro.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `svh-a-*.rs` files are all deviations from the base file\n-//! svh-a-base.rs with some difference (usually in `fn foo`) that\n-//! should not affect the strict version hash (SVH) computation\n-//! (#14132).\n-\n-#![crate_name = \"a\"]\n-\n-macro_rules! three {\n-    () => { 3 }\n-}\n-\n-pub trait U {}\n-pub trait V {}\n-impl U for () {}\n-impl V for () {}\n-\n-static A_CONSTANT : isize = 2;\n-\n-pub fn foo<T:U>(_: isize) -> isize {\n-    // a macro invocation in a function body does not affect the svh,\n-    // as long as it yields the same code.\n-    three!()\n-}\n-\n-pub fn an_unused_name() -> isize {\n-    4\n-}"}, {"sha": "31a97f695f06cdbfcf20cd27edf87cb961020bb0", "filename": "src/test/run-pass/auxiliary/svh-a-no-change.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-no-change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-no-change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-no-change.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `svh-a-*.rs` files are all deviations from the base file\n-//! svh-a-base.rs with some difference (usually in `fn foo`) that\n-//! should not affect the strict version hash (SVH) computation\n-//! (#14132).\n-\n-#![crate_name = \"a\"]\n-\n-macro_rules! three {\n-    () => { 3 }\n-}\n-\n-pub trait U {}\n-pub trait V {}\n-impl U for () {}\n-impl V for () {}\n-\n-static A_CONSTANT : isize = 2;\n-\n-pub fn foo<T:U>(_: isize) -> isize {\n-    3\n-}\n-\n-pub fn an_unused_name() -> isize {\n-    4\n-}"}, {"sha": "e405c337abe4aeb7ef7214625a275c5fc4931b75", "filename": "src/test/run-pass/auxiliary/svh-a-redundant-cfg.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-redundant-cfg.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `svh-a-*.rs` files are all deviations from the base file\n-//! svh-a-base.rs with some difference (usually in `fn foo`) that\n-//! should not affect the strict version hash (SVH) computation\n-//! (#14132).\n-\n-#![crate_name = \"a\"]\n-\n-macro_rules! three {\n-    () => { 3 }\n-}\n-\n-pub trait U {}\n-pub trait V {}\n-impl U for () {}\n-impl V for () {}\n-\n-static A_CONSTANT : isize = 2;\n-\n-// cfg attribute does not affect the svh, as long as it yields the same code.\n-#[cfg(not(an_unused_name))]\n-pub fn foo<T:U>(_: isize) -> isize {\n-    3\n-}\n-\n-pub fn an_unused_name() -> isize {\n-    4\n-}"}, {"sha": "9ef788c98427392bfa95bf1156149d7df9a99232", "filename": "src/test/run-pass/auxiliary/svh-a-whitespace.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-a-whitespace.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `svh-a-*.rs` files are all deviations from the base file\n-//! svh-a-base.rs with some difference (usually in `fn foo`) that\n-//! should not affect the strict version hash (SVH) computation\n-//! (#14132).\n-\n-#![crate_name = \"a\"]\n-\n-macro_rules! three {\n-    () => { 3 }\n-}\n-\n-pub trait U {}\n-pub trait V {}\n-impl U for () {}\n-impl V for () {}\n-\n-static A_CONSTANT : isize = 2;\n-\n-pub fn foo<T:U>(_: isize) -> isize {\n-\n-    3\n-\n-}\n-\n-pub fn an_unused_name() -> isize {\n-    4\n-}"}, {"sha": "213ee1edff4e89b03300c725400e6b24e638eeaa", "filename": "src/test/run-pass/hygiene/issue-44128.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fhygiene%2Fissue-44128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fhygiene%2Fissue-44128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene%2Fissue-44128.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+pub macro create_struct($a:ident) {\n+    struct $a;\n+    impl Clone for $a {\n+        fn clone(&self) -> Self {\n+            $a\n+        }\n+    }\n+}\n+\n+fn main() {\n+    create_struct!(Test);\n+    Test.clone();\n+}"}, {"sha": "19431a6a429239eb98eb03f52047701a5ac2be2f", "filename": "src/test/run-pass/issue-43355.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fissue-43355.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fissue-43355.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-43355.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the code for issue #43355 can run without an ICE, please remove\n+// this test when it becomes an hard error.\n+\n+pub trait Trait1<X> {\n+    type Output;\n+}\n+pub trait Trait2<X> {}\n+\n+impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+    type Output = ();\n+}\n+impl<X> Trait1<Box<X>> for A {\n+    type Output = i32;\n+}\n+\n+pub struct A;\n+\n+fn f<X, T: Trait1<Box<X>>>() {\n+    println!(\"k: {}\", ::std::mem::size_of::<<T as Trait1<Box<X>>>::Output>());\n+}\n+\n+pub fn g<X, T: Trait2<Box<X>>>() {\n+    f::<X, T>();\n+}\n+\n+fn main() {}"}, {"sha": "d0f8ed96f4cb345b517d0ba897d7349ad4d32c8f", "filename": "src/test/run-pass/issue-44373.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fissue-44373.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fissue-44373.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-44373.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z borrowck=compare\n+\n struct Foo(bool);\n \n struct Container(&'static [&'static Foo]);"}, {"sha": "9592da77a1b583cb329e6171994892395a71e942", "filename": "src/test/run-pass/match-pipe-binding.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z borrowck=compare\n \n fn test1() {\n     // from issue 6338"}, {"sha": "ea07ebe364661a01fad995170177a26aed84aad8", "filename": "src/test/run-pass/svh-add-doc.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fsvh-add-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fsvh-add-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsvh-add-doc.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// note that these aux-build directives must be in this order\n-// aux-build:svh-a-base.rs\n-// aux-build:svh-b.rs\n-// aux-build:svh-a-doc.rs\n-\n-// pretty-expanded FIXME #23616\n-\n-extern crate a;\n-extern crate b;\n-\n-fn main() {\n-    b::foo()\n-}"}, {"sha": "4e0192c40c230af5858937426a264beaa32db283", "filename": "src/test/run-pass/svh-add-macro.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fsvh-add-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fsvh-add-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsvh-add-macro.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// note that these aux-build directives must be in this order\n-// aux-build:svh-a-base.rs\n-// aux-build:svh-b.rs\n-// aux-build:svh-a-macro.rs\n-\n-// pretty-expanded FIXME #23616\n-\n-extern crate a;\n-extern crate b;\n-\n-fn main() {\n-    b::foo()\n-}"}, {"sha": "aca50859b6eda9cc7f18ad6bf5080fb8b11a86af", "filename": "src/test/run-pass/svh-add-nothing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fsvh-add-nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fsvh-add-nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsvh-add-nothing.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -11,7 +11,7 @@\n // note that these aux-build directives must be in this order\n // aux-build:svh-a-base.rs\n // aux-build:svh-b.rs\n-// aux-build:svh-a-no-change.rs\n+// aux-build:svh-a-base.rs\n \n // pretty-expanded FIXME #23616\n "}, {"sha": "2da3004aaf1e527a108a62fc3885a3e83b555cee", "filename": "src/test/run-pass/svh-add-redundant-cfg.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fsvh-add-redundant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fsvh-add-redundant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsvh-add-redundant-cfg.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// note that these aux-build directives must be in this order\n-// aux-build:svh-a-base.rs\n-// aux-build:svh-b.rs\n-// aux-build:svh-a-redundant-cfg.rs\n-\n-// pretty-expanded FIXME #23616\n-\n-extern crate a;\n-extern crate b;\n-\n-fn main() {\n-    b::foo()\n-}"}, {"sha": "bfc676bde263adaf28c533e10a4b04307cfd4b74", "filename": "src/test/run-pass/svh-add-whitespace.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fsvh-add-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6b5b0423fed8c630f1b97968c3aebbed816f60/src%2Ftest%2Frun-pass%2Fsvh-add-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsvh-add-whitespace.rs?ref=0f6b5b0423fed8c630f1b97968c3aebbed816f60", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// note that these aux-build directives must be in this order\n-// aux-build:svh-a-base.rs\n-// aux-build:svh-b.rs\n-// aux-build:svh-a-whitespace.rs\n-\n-// pretty-expanded FIXME #23616\n-\n-extern crate a;\n-extern crate b;\n-\n-fn main() {\n-    b::foo()\n-}"}, {"sha": "b9719e04f34470b6e67804bf5e95a58be11a7a2f", "filename": "src/test/run-pass/thinlto/weak-works.rs", "status": "renamed", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fthinlto%2Fweak-works.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Frun-pass%2Fthinlto%2Fweak-works.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthinlto%2Fweak-works.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,16 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// note that these aux-build directives must be in this order\n-// aux-build:svh-a-base.rs\n-// aux-build:svh-b.rs\n-// aux-build:svh-a-comment.rs\n+// compile-flags: -C codegen-units=8 -Z thinlto\n+// ignore-windows\n+// min-llvm-version 4.0\n \n-// pretty-expanded FIXME #23616\n+#![feature(linkage)]\n \n-extern crate a;\n-extern crate b;\n+pub mod foo {\n+    #[linkage = \"weak\"]\n+    #[no_mangle]\n+    pub extern \"C\" fn FOO() -> i32 {\n+        0\n+    }\n+}\n+\n+mod bar {\n+    extern \"C\" {\n+        fn FOO() -> i32;\n+    }\n+\n+    pub fn bar() -> i32 {\n+        unsafe { FOO() }\n+    }\n+}\n \n fn main() {\n-    b::foo()\n+    bar::bar();\n }", "previous_filename": "src/test/run-pass/svh-add-comment.rs"}, {"sha": "d1971a5e1aea40403f0a486d23d25285de263685", "filename": "src/test/ui/auxiliary/cfg-target-thread-local.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Fauxiliary%2Fcfg-target-thread-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Fauxiliary%2Fcfg-target-thread-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Fcfg-target-thread-local.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/auxiliary/cfg-target-thread-local.rs"}, {"sha": "e95078f25474aed374fae6fe79e9643002a7d45c", "filename": "src/test/ui/codemap_tests/tab.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1,16 +1,16 @@\n error[E0425]: cannot find value `bar` in this scope\n   --> $DIR/tab.rs:14:2\n    |\n-14 |  bar; //~ ERROR cannot find value `bar`\n-   |  ^^^ not found in this scope\n+14 |     bar; //~ ERROR cannot find value `bar`\n+   |     ^^^ not found in this scope\n \n error[E0308]: mismatched types\n   --> $DIR/tab.rs:18:2\n    |\n 17 | fn foo() {\n    |          - help: try adding a return type: `-> &'static str `\n-18 |  \"bar   boo\" //~ ERROR mismatched types\n-   |  ^^^^^^^^^^^ expected (), found reference\n+18 |     \"bar            boo\" //~ ERROR mismatched types\n+   |     ^^^^^^^^^^^^^^^^^^^^ expected (), found reference\n    |\n    = note: expected type `()`\n               found type `&'static str`"}, {"sha": "34c49d97562229e9ed0828945e251c7eae7c3e8b", "filename": "src/test/ui/codemap_tests/tab_2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_2.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1,8 +1,8 @@\n error: unterminated double quote string\n   --> $DIR/tab_2.rs:14:7\n    |\n-14 |       \"\"\"; //~ ERROR unterminated double quote\n-   |  _______^\n+14 |                   \"\"\"; //~ ERROR unterminated double quote\n+   |  ___________________^\n 15 | | }\n    | |__^\n "}, {"sha": "322020626639b65116334167da1fab0b17d7ad47", "filename": "src/test/ui/codemap_tests/tab_3.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -1,11 +1,11 @@\n error[E0382]: use of moved value: `some_vec`\n   --> $DIR/tab_3.rs:17:20\n    |\n-15 |  some_vec.into_iter();\n-   |  -------- value moved here\n-16 |  {\n-17 |   println!(\"{:?}\", some_vec); //~ ERROR use of moved\n-   |                    ^^^^^^^^ value used here after move\n+15 |     some_vec.into_iter();\n+   |     -------- value moved here\n+16 |     {\n+17 |         println!(\"{:?}\", some_vec); //~ ERROR use of moved\n+   |                          ^^^^^^^^ value used here after move\n    |\n    = note: move occurs because `some_vec` has type `std::vec::Vec<&str>`, which does not implement the `Copy` trait\n "}, {"sha": "030e37475c0a8fd70d2249164252a15f5e4ffc68", "filename": "src/test/ui/feature-gate-abi-msp430-interrupt.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi-msp430-interrupt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi-msp430-interrupt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-abi-msp430-interrupt.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-abi-msp430-interrupt.rs"}, {"sha": "b05be6e4391b4c363080f831b5ce1d9cdba85fa5", "filename": "src/test/ui/feature-gate-abi-msp430-interrupt.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi-msp430-interrupt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi-msp430-interrupt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-abi-msp430-interrupt.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: msp430-interrupt ABI is experimental and subject to change (see issue #38487)\n+  --> $DIR/feature-gate-abi-msp430-interrupt.rs:14:1\n+   |\n+14 | extern \"msp430-interrupt\" fn foo() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_msp430_interrupt)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "45c715f51fe4810f8ca8868d5e8842519a185def", "filename": "src/test/ui/feature-gate-abi.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-abi.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-abi.rs"}, {"sha": "7d2ad0be391c134a0ba42c94bd122842998da52a", "filename": "src/test/ui/feature-gate-abi.stderr", "status": "added", "additions": 450, "deletions": 0, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-abi.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,450 @@\n+error: intrinsics are subject to change\n+  --> $DIR/feature-gate-abi.rs:19:1\n+   |\n+19 | extern \"rust-intrinsic\" fn f1() {} //~ ERROR intrinsics are subject to change\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(intrinsics)] to the crate attributes to enable\n+\n+error: platform intrinsics are experimental and possibly buggy (see issue #27731)\n+  --> $DIR/feature-gate-abi.rs:20:1\n+   |\n+20 | extern \"platform-intrinsic\" fn f2() {} //~ ERROR platform intrinsics are experimental\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(platform_intrinsics)] to the crate attributes to enable\n+\n+error: vectorcall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:21:1\n+   |\n+21 | extern \"vectorcall\" fn f3() {} //~ ERROR vectorcall is experimental and subject to change\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_vectorcall)] to the crate attributes to enable\n+\n+error: rust-call ABI is subject to change (see issue #29625)\n+  --> $DIR/feature-gate-abi.rs:22:1\n+   |\n+22 | extern \"rust-call\" fn f4() {} //~ ERROR rust-call ABI is subject to change\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(unboxed_closures)] to the crate attributes to enable\n+\n+error: msp430-interrupt ABI is experimental and subject to change (see issue #38487)\n+  --> $DIR/feature-gate-abi.rs:23:1\n+   |\n+23 | extern \"msp430-interrupt\" fn f5() {} //~ ERROR msp430-interrupt ABI is experimental\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_msp430_interrupt)] to the crate attributes to enable\n+\n+error: PTX ABIs are experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:24:1\n+   |\n+24 | extern \"ptx-kernel\" fn f6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_ptx)] to the crate attributes to enable\n+\n+error: x86-interrupt ABI is experimental and subject to change (see issue #40180)\n+  --> $DIR/feature-gate-abi.rs:25:1\n+   |\n+25 | extern \"x86-interrupt\" fn f7() {} //~ ERROR x86-interrupt ABI is experimental\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable\n+\n+error: thiscall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:26:1\n+   |\n+26 | extern \"thiscall\" fn f8() {} //~ ERROR thiscall is experimental and subject to change\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_thiscall)] to the crate attributes to enable\n+\n+error: intrinsics are subject to change\n+  --> $DIR/feature-gate-abi.rs:30:5\n+   |\n+30 |     extern \"rust-intrinsic\" fn m1(); //~ ERROR intrinsics are subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(intrinsics)] to the crate attributes to enable\n+\n+error: platform intrinsics are experimental and possibly buggy (see issue #27731)\n+  --> $DIR/feature-gate-abi.rs:31:5\n+   |\n+31 |     extern \"platform-intrinsic\" fn m2(); //~ ERROR platform intrinsics are experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(platform_intrinsics)] to the crate attributes to enable\n+\n+error: vectorcall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:32:5\n+   |\n+32 |     extern \"vectorcall\" fn m3(); //~ ERROR vectorcall is experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_vectorcall)] to the crate attributes to enable\n+\n+error: rust-call ABI is subject to change (see issue #29625)\n+  --> $DIR/feature-gate-abi.rs:33:5\n+   |\n+33 |     extern \"rust-call\" fn m4(); //~ ERROR rust-call ABI is subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(unboxed_closures)] to the crate attributes to enable\n+\n+error: msp430-interrupt ABI is experimental and subject to change (see issue #38487)\n+  --> $DIR/feature-gate-abi.rs:34:5\n+   |\n+34 |     extern \"msp430-interrupt\" fn m5(); //~ ERROR msp430-interrupt ABI is experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_msp430_interrupt)] to the crate attributes to enable\n+\n+error: PTX ABIs are experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:35:5\n+   |\n+35 |     extern \"ptx-kernel\" fn m6(); //~ ERROR PTX ABIs are experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_ptx)] to the crate attributes to enable\n+\n+error: x86-interrupt ABI is experimental and subject to change (see issue #40180)\n+  --> $DIR/feature-gate-abi.rs:36:5\n+   |\n+36 |     extern \"x86-interrupt\" fn m7(); //~ ERROR x86-interrupt ABI is experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable\n+\n+error: thiscall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:37:5\n+   |\n+37 |     extern \"thiscall\" fn m8(); //~ ERROR thiscall is experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_thiscall)] to the crate attributes to enable\n+\n+error: intrinsics are subject to change\n+  --> $DIR/feature-gate-abi.rs:39:5\n+   |\n+39 |     extern \"rust-intrinsic\" fn dm1() {} //~ ERROR intrinsics are subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(intrinsics)] to the crate attributes to enable\n+\n+error: platform intrinsics are experimental and possibly buggy (see issue #27731)\n+  --> $DIR/feature-gate-abi.rs:40:5\n+   |\n+40 |     extern \"platform-intrinsic\" fn dm2() {} //~ ERROR platform intrinsics are experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(platform_intrinsics)] to the crate attributes to enable\n+\n+error: vectorcall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:41:5\n+   |\n+41 |     extern \"vectorcall\" fn dm3() {} //~ ERROR vectorcall is experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_vectorcall)] to the crate attributes to enable\n+\n+error: rust-call ABI is subject to change (see issue #29625)\n+  --> $DIR/feature-gate-abi.rs:42:5\n+   |\n+42 |     extern \"rust-call\" fn dm4() {} //~ ERROR rust-call ABI is subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(unboxed_closures)] to the crate attributes to enable\n+\n+error: msp430-interrupt ABI is experimental and subject to change (see issue #38487)\n+  --> $DIR/feature-gate-abi.rs:43:5\n+   |\n+43 |     extern \"msp430-interrupt\" fn dm5() {} //~ ERROR msp430-interrupt ABI is experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_msp430_interrupt)] to the crate attributes to enable\n+\n+error: PTX ABIs are experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:44:5\n+   |\n+44 |     extern \"ptx-kernel\" fn dm6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_ptx)] to the crate attributes to enable\n+\n+error: x86-interrupt ABI is experimental and subject to change (see issue #40180)\n+  --> $DIR/feature-gate-abi.rs:45:5\n+   |\n+45 |     extern \"x86-interrupt\" fn dm7() {} //~ ERROR x86-interrupt ABI is experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable\n+\n+error: thiscall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:46:5\n+   |\n+46 |     extern \"thiscall\" fn dm8() {} //~ ERROR thiscall is experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_thiscall)] to the crate attributes to enable\n+\n+error: intrinsics are subject to change\n+  --> $DIR/feature-gate-abi.rs:53:5\n+   |\n+53 |     extern \"rust-intrinsic\" fn m1() {} //~ ERROR intrinsics are subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(intrinsics)] to the crate attributes to enable\n+\n+error: platform intrinsics are experimental and possibly buggy (see issue #27731)\n+  --> $DIR/feature-gate-abi.rs:54:5\n+   |\n+54 |     extern \"platform-intrinsic\" fn m2() {} //~ ERROR platform intrinsics are experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(platform_intrinsics)] to the crate attributes to enable\n+\n+error: vectorcall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:55:5\n+   |\n+55 |     extern \"vectorcall\" fn m3() {} //~ ERROR vectorcall is experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_vectorcall)] to the crate attributes to enable\n+\n+error: rust-call ABI is subject to change (see issue #29625)\n+  --> $DIR/feature-gate-abi.rs:56:5\n+   |\n+56 |     extern \"rust-call\" fn m4() {} //~ ERROR rust-call ABI is subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(unboxed_closures)] to the crate attributes to enable\n+\n+error: msp430-interrupt ABI is experimental and subject to change (see issue #38487)\n+  --> $DIR/feature-gate-abi.rs:57:5\n+   |\n+57 |     extern \"msp430-interrupt\" fn m5() {} //~ ERROR msp430-interrupt ABI is experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_msp430_interrupt)] to the crate attributes to enable\n+\n+error: PTX ABIs are experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:58:5\n+   |\n+58 |     extern \"ptx-kernel\" fn m6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_ptx)] to the crate attributes to enable\n+\n+error: x86-interrupt ABI is experimental and subject to change (see issue #40180)\n+  --> $DIR/feature-gate-abi.rs:59:5\n+   |\n+59 |     extern \"x86-interrupt\" fn m7() {} //~ ERROR x86-interrupt ABI is experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable\n+\n+error: thiscall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:60:5\n+   |\n+60 |     extern \"thiscall\" fn m8() {} //~ ERROR thiscall is experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_thiscall)] to the crate attributes to enable\n+\n+error: intrinsics are subject to change\n+  --> $DIR/feature-gate-abi.rs:65:5\n+   |\n+65 |     extern \"rust-intrinsic\" fn im1() {} //~ ERROR intrinsics are subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(intrinsics)] to the crate attributes to enable\n+\n+error: platform intrinsics are experimental and possibly buggy (see issue #27731)\n+  --> $DIR/feature-gate-abi.rs:66:5\n+   |\n+66 |     extern \"platform-intrinsic\" fn im2() {} //~ ERROR platform intrinsics are experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(platform_intrinsics)] to the crate attributes to enable\n+\n+error: vectorcall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:67:5\n+   |\n+67 |     extern \"vectorcall\" fn im3() {} //~ ERROR vectorcall is experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_vectorcall)] to the crate attributes to enable\n+\n+error: rust-call ABI is subject to change (see issue #29625)\n+  --> $DIR/feature-gate-abi.rs:68:5\n+   |\n+68 |     extern \"rust-call\" fn im4() {} //~ ERROR rust-call ABI is subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(unboxed_closures)] to the crate attributes to enable\n+\n+error: msp430-interrupt ABI is experimental and subject to change (see issue #38487)\n+  --> $DIR/feature-gate-abi.rs:69:5\n+   |\n+69 |     extern \"msp430-interrupt\" fn im5() {} //~ ERROR msp430-interrupt ABI is experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_msp430_interrupt)] to the crate attributes to enable\n+\n+error: PTX ABIs are experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:70:5\n+   |\n+70 |     extern \"ptx-kernel\" fn im6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_ptx)] to the crate attributes to enable\n+\n+error: x86-interrupt ABI is experimental and subject to change (see issue #40180)\n+  --> $DIR/feature-gate-abi.rs:71:5\n+   |\n+71 |     extern \"x86-interrupt\" fn im7() {} //~ ERROR x86-interrupt ABI is experimental\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable\n+\n+error: thiscall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:72:5\n+   |\n+72 |     extern \"thiscall\" fn im8() {} //~ ERROR thiscall is experimental and subject to change\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_thiscall)] to the crate attributes to enable\n+\n+error: intrinsics are subject to change\n+  --> $DIR/feature-gate-abi.rs:76:11\n+   |\n+76 | type A1 = extern \"rust-intrinsic\" fn(); //~ ERROR intrinsics are subject to change\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(intrinsics)] to the crate attributes to enable\n+\n+error: platform intrinsics are experimental and possibly buggy (see issue #27731)\n+  --> $DIR/feature-gate-abi.rs:77:11\n+   |\n+77 | type A2 = extern \"platform-intrinsic\" fn(); //~ ERROR platform intrinsics are experimental\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(platform_intrinsics)] to the crate attributes to enable\n+\n+error: vectorcall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:78:11\n+   |\n+78 | type A3 = extern \"vectorcall\" fn(); //~ ERROR vectorcall is experimental and subject to change\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_vectorcall)] to the crate attributes to enable\n+\n+error: rust-call ABI is subject to change (see issue #29625)\n+  --> $DIR/feature-gate-abi.rs:79:11\n+   |\n+79 | type A4 = extern \"rust-call\" fn(); //~ ERROR rust-call ABI is subject to change\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(unboxed_closures)] to the crate attributes to enable\n+\n+error: msp430-interrupt ABI is experimental and subject to change (see issue #38487)\n+  --> $DIR/feature-gate-abi.rs:80:11\n+   |\n+80 | type A5 = extern \"msp430-interrupt\" fn(); //~ ERROR msp430-interrupt ABI is experimental\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_msp430_interrupt)] to the crate attributes to enable\n+\n+error: PTX ABIs are experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:81:11\n+   |\n+81 | type A6 = extern \"ptx-kernel\" fn (); //~ ERROR PTX ABIs are experimental and subject to change\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_ptx)] to the crate attributes to enable\n+\n+error: x86-interrupt ABI is experimental and subject to change (see issue #40180)\n+  --> $DIR/feature-gate-abi.rs:82:11\n+   |\n+82 | type A7 = extern \"x86-interrupt\" fn(); //~ ERROR x86-interrupt ABI is experimental\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable\n+\n+error: thiscall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:83:11\n+   |\n+83 | type A8 = extern \"thiscall\" fn(); //~ ERROR thiscall is experimental and subject to change\n+   |           ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_thiscall)] to the crate attributes to enable\n+\n+error: intrinsics are subject to change\n+  --> $DIR/feature-gate-abi.rs:86:1\n+   |\n+86 | extern \"rust-intrinsic\" {} //~ ERROR intrinsics are subject to change\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(intrinsics)] to the crate attributes to enable\n+\n+error: platform intrinsics are experimental and possibly buggy (see issue #27731)\n+  --> $DIR/feature-gate-abi.rs:87:1\n+   |\n+87 | extern \"platform-intrinsic\" {} //~ ERROR platform intrinsics are experimental\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(platform_intrinsics)] to the crate attributes to enable\n+\n+error: vectorcall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:88:1\n+   |\n+88 | extern \"vectorcall\" {} //~ ERROR vectorcall is experimental and subject to change\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_vectorcall)] to the crate attributes to enable\n+\n+error: rust-call ABI is subject to change (see issue #29625)\n+  --> $DIR/feature-gate-abi.rs:89:1\n+   |\n+89 | extern \"rust-call\" {} //~ ERROR rust-call ABI is subject to change\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(unboxed_closures)] to the crate attributes to enable\n+\n+error: msp430-interrupt ABI is experimental and subject to change (see issue #38487)\n+  --> $DIR/feature-gate-abi.rs:90:1\n+   |\n+90 | extern \"msp430-interrupt\" {} //~ ERROR msp430-interrupt ABI is experimental\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_msp430_interrupt)] to the crate attributes to enable\n+\n+error: PTX ABIs are experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:91:1\n+   |\n+91 | extern \"ptx-kernel\" {} //~ ERROR PTX ABIs are experimental and subject to change\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_ptx)] to the crate attributes to enable\n+\n+error: x86-interrupt ABI is experimental and subject to change (see issue #40180)\n+  --> $DIR/feature-gate-abi.rs:92:1\n+   |\n+92 | extern \"x86-interrupt\" {} //~ ERROR x86-interrupt ABI is experimental\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable\n+\n+error: thiscall is experimental and subject to change\n+  --> $DIR/feature-gate-abi.rs:93:1\n+   |\n+93 | extern \"thiscall\" {} //~ ERROR thiscall is experimental and subject to change\n+   | ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(abi_thiscall)] to the crate attributes to enable\n+\n+error: aborting due to 56 previous errors\n+"}, {"sha": "501f4451ed8d51b6982f001ec10ddc214210001c", "filename": "src/test/ui/feature-gate-abi_unadjusted.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi_unadjusted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi_unadjusted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-abi_unadjusted.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-abi_unadjusted\n-\n extern \"unadjusted\" fn foo() {\n //~^ ERROR: unadjusted ABI is an implementation detail and perma-unstable\n }", "previous_filename": "src/test/compile-fail/unadjusted-unstable.rs"}, {"sha": "3cc43847156a1d6fba3c5e943987f183e5e9284b", "filename": "src/test/ui/feature-gate-abi_unadjusted.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi_unadjusted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-abi_unadjusted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-abi_unadjusted.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,12 @@\n+error: unadjusted ABI is an implementation detail and perma-unstable\n+  --> $DIR/feature-gate-abi_unadjusted.rs:11:1\n+   |\n+11 | / extern \"unadjusted\" fn foo() {\n+12 | | //~^ ERROR: unadjusted ABI is an implementation detail and perma-unstable\n+13 | | }\n+   | |_^\n+   |\n+   = help: add #![feature(abi_unadjusted)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "dc9b4e634ab723952797879d048cdca3ff91656c", "filename": "src/test/ui/feature-gate-advanced-slice-features.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-advanced-slice-features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-advanced-slice-features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-advanced-slice-features.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-advanced-slice-features.rs"}, {"sha": "815593d07a5f4de3329fdc8e29dd393cecaf2f72", "filename": "src/test/ui/feature-gate-advanced-slice-features.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-advanced-slice-features.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-advanced-slice-features.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-advanced-slice-features.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,18 @@\n+error: multiple-element slice matches anywhere but at the end of a slice (e.g. `[0, ..xs, 0]`) are experimental (see issue #23121)\n+  --> $DIR/feature-gate-advanced-slice-features.rs:18:9\n+   |\n+18 |         [ xs.., 4, 5 ] => {}    //~ ERROR multiple-element slice matches\n+   |         ^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(advanced_slice_patterns)] to the crate attributes to enable\n+\n+error: multiple-element slice matches anywhere but at the end of a slice (e.g. `[0, ..xs, 0]`) are experimental (see issue #23121)\n+  --> $DIR/feature-gate-advanced-slice-features.rs:19:9\n+   |\n+19 |         [ 1, xs.., 5 ] => {}    //~ ERROR multiple-element slice matches\n+   |         ^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(advanced_slice_patterns)] to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "b519a985ec5e7f3ed359caca12590922ae5d9f0d", "filename": "src/test/ui/feature-gate-allocator_internals.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allocator_internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allocator_internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allocator_internals.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-allocator_internals.rs"}, {"sha": "f1f4705b3bbc1154c8420b4bb90cecaef178f0d1", "filename": "src/test/ui/feature-gate-allocator_internals.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allocator_internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allocator_internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allocator_internals.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: the `#[default_lib_allocator]` attribute is an experimental feature\n+  --> $DIR/feature-gate-allocator_internals.rs:11:1\n+   |\n+11 | #![default_lib_allocator] //~ ERROR: attribute is an experimental feature\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(allocator_internals)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "590dc619f2f1aa3bc32f110f964cc82ba8dee167", "filename": "src/test/ui/feature-gate-allow-internal-unsafe-nested-macro.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unsafe-nested-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unsafe-nested-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unsafe-nested-macro.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-allow-internal-unsafe-nested-macro.rs"}, {"sha": "40bdde37ee8cecc80a427e80aa03892ab2f425e9", "filename": "src/test/ui/feature-gate-allow-internal-unsafe-nested-macro.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unsafe-nested-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unsafe-nested-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unsafe-nested-macro.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,13 @@\n+error: allow_internal_unsafe side-steps the unsafe_code lint\n+  --> $DIR/feature-gate-allow-internal-unsafe-nested-macro.rs:18:9\n+   |\n+18 |         #[allow_internal_unsafe] //~ ERROR allow_internal_unsafe side-steps\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+25 | bar!();\n+   | ------- in this macro invocation\n+   |\n+   = help: add #![feature(allow_internal_unsafe)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "9af501b141955f97d777a210afcf40c1e0a4914e", "filename": "src/test/ui/feature-gate-allow-internal-unstable-nested-macro.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-nested-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-nested-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-nested-macro.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-allow-internal-unstable-nested-macro.rs"}, {"sha": "60d72fbc3b3356d9165da7321173dc9faf5f8d7f", "filename": "src/test/ui/feature-gate-allow-internal-unstable-nested-macro.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-nested-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-nested-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-nested-macro.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,13 @@\n+error: allow_internal_unstable side-steps feature gating and stability checks\n+  --> $DIR/feature-gate-allow-internal-unstable-nested-macro.rs:18:9\n+   |\n+18 |         #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+25 | bar!();\n+   | ------- in this macro invocation\n+   |\n+   = help: add #![feature(allow_internal_unstable)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "b186278ef8b7b200d5909b880d5c910a95a34c61", "filename": "src/test/ui/feature-gate-allow-internal-unstable-struct.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-struct.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-allow-internal-unstable-struct.rs"}, {"sha": "2fb86ce8f4e5b2913e1dae1e6f1c8d43ee5c25c2", "filename": "src/test/ui/feature-gate-allow-internal-unstable-struct.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable-struct.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: allow_internal_unstable side-steps feature gating and stability checks\n+  --> $DIR/feature-gate-allow-internal-unstable-struct.rs:14:1\n+   |\n+14 | #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(allow_internal_unstable)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "61a362cb37fb2c0d8d674447ba9af2b348bcf586", "filename": "src/test/ui/feature-gate-allow-internal-unstable.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-allow-internal-unstable.rs"}, {"sha": "a5740a1a78927578ebab874f279ea9456d3253f9", "filename": "src/test/ui/feature-gate-allow-internal-unstable.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allow-internal-unstable.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: allow_internal_unstable side-steps feature gating and stability checks\n+  --> $DIR/feature-gate-allow-internal-unstable.rs:13:1\n+   |\n+13 | #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(allow_internal_unstable)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "1124740280960de2f7a63106294cec0df364f7b4", "filename": "src/test/ui/feature-gate-allow_fail.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allow_fail.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-allow_fail.rs"}, {"sha": "65cd137459ae8c5b1d4b685ed18db3f52b58c109", "filename": "src/test/ui/feature-gate-allow_fail.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-allow_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-allow_fail.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: allow_fail attribute is currently unstable (see issue #42219)\n+  --> $DIR/feature-gate-allow_fail.rs:13:1\n+   |\n+13 | #[allow_fail] //~ ERROR allow_fail attribute is currently unstable\n+   | ^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(allow_fail)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "ff0306f199310c271a112045bf5073571661f927", "filename": "src/test/ui/feature-gate-arbitrary-self-types.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-arbitrary-self-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-arbitrary-self-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-arbitrary-self-types.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-arbitrary-self-types.rs"}, {"sha": "2ef517cc9e1317a95c209da210377a0c9108e99a", "filename": "src/test/ui/feature-gate-arbitrary-self-types.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-arbitrary-self-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-arbitrary-self-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-arbitrary-self-types.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,29 @@\n+error: arbitrary `self` types are unstable (see issue #44874)\n+  --> $DIR/feature-gate-arbitrary-self-types.rs:14:18\n+   |\n+14 |     fn foo(self: Rc<Box<Self>>); //~ ERROR arbitrary `self` types are unstable\n+   |                  ^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(arbitrary_self_types)] to the crate attributes to enable\n+   = help: consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\n+\n+error: arbitrary `self` types are unstable (see issue #44874)\n+  --> $DIR/feature-gate-arbitrary-self-types.rs:20:18\n+   |\n+20 |     fn foo(self: Rc<Box<Self>>) {} //~ ERROR arbitrary `self` types are unstable\n+   |                  ^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(arbitrary_self_types)] to the crate attributes to enable\n+   = help: consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\n+\n+error: arbitrary `self` types are unstable (see issue #44874)\n+  --> $DIR/feature-gate-arbitrary-self-types.rs:24:18\n+   |\n+24 |     fn bar(self: Box<Rc<Self>>) {} //~ ERROR arbitrary `self` types are unstable\n+   |                  ^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(arbitrary_self_types)] to the crate attributes to enable\n+   = help: consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "8d053bdae789b1e3358a87a286a628eaefeca326", "filename": "src/test/ui/feature-gate-asm.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-asm.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-asm\n-\n fn main() {\n     unsafe {\n         asm!(\"\"); //~ ERROR inline assembly is not stable enough", "previous_filename": "src/test/compile-fail/asm-gated.rs"}, {"sha": "ff68a4fb23ee11c5983ad42c8e2f89c3cd18fad8", "filename": "src/test/ui/feature-gate-asm.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-asm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-asm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-asm.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: inline assembly is not stable enough for use and is subject to change (see issue #29722)\n+  --> $DIR/feature-gate-asm.rs:13:9\n+   |\n+13 |         asm!(\"\"); //~ ERROR inline assembly is not stable enough\n+   |         ^^^^^^^^^\n+   |\n+   = help: add #![feature(asm)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "222190de9fe9c4a25651f78858bc413f5f8bc245", "filename": "src/test/ui/feature-gate-asm2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-asm2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-asm2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-asm2.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/asm-gated2.rs"}, {"sha": "1e02cede61dc710bf149ca756a75f548c55245d8", "filename": "src/test/ui/feature-gate-asm2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-asm2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-asm2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-asm2.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: inline assembly is not stable enough for use and is subject to change (see issue #29722)\n+  --> $DIR/feature-gate-asm2.rs:15:24\n+   |\n+15 |         println!(\"{}\", asm!(\"\")); //~ ERROR inline assembly is not stable\n+   |                        ^^^^^^^^\n+   |\n+   = help: add #![feature(asm)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "de3521eb0f20bc8d54616b922542fb90b0b5cdf6", "filename": "src/test/ui/feature-gate-assoc-type-defaults.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-assoc-type-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-assoc-type-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-assoc-type-defaults.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-assoc-type-defaults.rs"}, {"sha": "5e2884691682d45a78d6af339d3d51c8569aadf6", "filename": "src/test/ui/feature-gate-assoc-type-defaults.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-assoc-type-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-assoc-type-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-assoc-type-defaults.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: associated type defaults are unstable (see issue #29661)\n+  --> $DIR/feature-gate-assoc-type-defaults.rs:14:5\n+   |\n+14 |     type Bar = u8; //~ ERROR associated type defaults are unstable\n+   |     ^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_defaults)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "65d437d0c0d31861834129994b39ca5c14639f62", "filename": "src/test/ui/feature-gate-box-expr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-box-expr.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-box-expr.rs"}, {"sha": "cef5adbd15a7dc0511a8d5c77f4c067220db3385", "filename": "src/test/ui/feature-gate-box-expr.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-box-expr.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: box expression syntax is experimental; you can call `Box::new` instead. (see issue #27779)\n+  --> $DIR/feature-gate-box-expr.rs:22:13\n+   |\n+22 |     let x = box 'c'; //~ ERROR box expression syntax is experimental\n+   |             ^^^^^^^\n+   |\n+   = help: add #![feature(box_syntax)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "e64081823e74c444ba225ee9fc5853e190e0ee2a", "filename": "src/test/ui/feature-gate-box_patterns.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-box_patterns.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-box_patterns\n-\n fn main() {\n     let box x = Box::new('c'); //~ ERROR box pattern syntax is experimental\n     println!(\"x: {}\", x);", "previous_filename": "src/test/compile-fail/feature-gate-box-pat.rs"}, {"sha": "0a30de58a1fcece7d0961d2ce46734e3d20a4869", "filename": "src/test/ui/feature-gate-box_patterns.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-box_patterns.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: box pattern syntax is experimental (see issue #29641)\n+  --> $DIR/feature-gate-box_patterns.rs:12:9\n+   |\n+12 |     let box x = Box::new('c'); //~ ERROR box pattern syntax is experimental\n+   |         ^^^^^\n+   |\n+   = help: add #![feature(box_patterns)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "a2643fe02b8f72bdc6fdd0594b73238386d01297", "filename": "src/test/ui/feature-gate-box_syntax.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-box_syntax.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -10,8 +10,6 @@\n \n // Test that the use of the box syntax is gated by `box_syntax` feature gate.\n \n-// gate-test-box_syntax\n-\n fn main() {\n     let x = box 3;\n     //~^ ERROR box expression syntax is experimental; you can call `Box::new` instead.", "previous_filename": "src/test/compile-fail/gated-box-syntax.rs"}, {"sha": "9b21dd03051bff3f4a1960166ace19fb4f178f7d", "filename": "src/test/ui/feature-gate-box_syntax.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box_syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-box_syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-box_syntax.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: box expression syntax is experimental; you can call `Box::new` instead. (see issue #27779)\n+  --> $DIR/feature-gate-box_syntax.rs:14:13\n+   |\n+14 |     let x = box 3;\n+   |             ^^^^^\n+   |\n+   = help: add #![feature(box_syntax)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "5568a5cf0aac267e8bfe79374206c997ccee4df1", "filename": "src/test/ui/feature-gate-catch_expr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-catch_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-catch_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-catch_expr.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-catch_expr.rs"}, {"sha": "f486373d225c3fc82dc602de1dc87cdaf383b774", "filename": "src/test/ui/feature-gate-catch_expr.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-catch_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-catch_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-catch_expr.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,14 @@\n+error: `catch` expression is experimental (see issue #31436)\n+  --> $DIR/feature-gate-catch_expr.rs:12:24\n+   |\n+12 |       let catch_result = do catch { //~ ERROR `catch` expression is experimental\n+   |  ________________________^\n+13 | |         let x = 5;\n+14 | |         x\n+15 | |     };\n+   | |_____^\n+   |\n+   = help: add #![feature(catch_expr)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "7832e1c7c51520e7978b491b2bad1426d52f65c2", "filename": "src/test/ui/feature-gate-cfg-target-feature.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-feature.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-cfg-target-feature.rs"}, {"sha": "60dc6fbb57e969ecb0469c973cdf2344077d7aef", "filename": "src/test/ui/feature-gate-cfg-target-feature.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-feature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-feature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-feature.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,34 @@\n+error: `cfg(target_feature)` is experimental and subject to change (see issue #29717)\n+  --> $DIR/feature-gate-cfg-target-feature.rs:12:12\n+   |\n+12 | #[cfg_attr(target_feature = \"x\", x)] //~ ERROR `cfg(target_feature)` is experimental\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_feature)] to the crate attributes to enable\n+\n+error: `cfg(target_feature)` is experimental and subject to change (see issue #29717)\n+  --> $DIR/feature-gate-cfg-target-feature.rs:11:7\n+   |\n+11 | #[cfg(target_feature = \"x\")] //~ ERROR `cfg(target_feature)` is experimental\n+   |       ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_feature)] to the crate attributes to enable\n+\n+error: `cfg(target_feature)` is experimental and subject to change (see issue #29717)\n+  --> $DIR/feature-gate-cfg-target-feature.rs:15:19\n+   |\n+15 | #[cfg(not(any(all(target_feature = \"x\"))))] //~ ERROR `cfg(target_feature)` is experimental\n+   |                   ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_feature)] to the crate attributes to enable\n+\n+error: `cfg(target_feature)` is experimental and subject to change (see issue #29717)\n+  --> $DIR/feature-gate-cfg-target-feature.rs:19:10\n+   |\n+19 |     cfg!(target_feature = \"x\");\n+   |          ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_feature)] to the crate attributes to enable\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "aa27f8922c005d7a77af19294583b7c2e77e42ba", "filename": "src/test/ui/feature-gate-cfg-target-has-atomic.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-has-atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-has-atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-has-atomic.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-cfg-target-has-atomic.rs"}, {"sha": "5daf5de7123d5b1e6d585afeea963919727f56ef", "filename": "src/test/ui/feature-gate-cfg-target-has-atomic.stderr", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-has-atomic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-has-atomic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-has-atomic.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,122 @@\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:23:7\n+   |\n+23 | #[cfg(target_has_atomic = \"8\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:29:7\n+   |\n+29 | #[cfg(target_has_atomic = \"8\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:34:7\n+   |\n+34 | #[cfg(target_has_atomic = \"16\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:39:7\n+   |\n+39 | #[cfg(target_has_atomic = \"16\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:44:7\n+   |\n+44 | #[cfg(target_has_atomic = \"32\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:49:7\n+   |\n+49 | #[cfg(target_has_atomic = \"32\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:54:7\n+   |\n+54 | #[cfg(target_has_atomic = \"64\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:59:7\n+   |\n+59 | #[cfg(target_has_atomic = \"64\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:64:7\n+   |\n+64 | #[cfg(target_has_atomic = \"ptr\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:69:7\n+   |\n+69 | #[cfg(target_has_atomic = \"ptr\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:76:10\n+   |\n+76 |     cfg!(target_has_atomic = \"8\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:78:10\n+   |\n+78 |     cfg!(target_has_atomic = \"16\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:80:10\n+   |\n+80 |     cfg!(target_has_atomic = \"32\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:82:10\n+   |\n+82 |     cfg!(target_has_atomic = \"64\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: `cfg(target_has_atomic)` is experimental and subject to change (see issue #32976)\n+  --> $DIR/feature-gate-cfg-target-has-atomic.rs:84:10\n+   |\n+84 |     cfg!(target_has_atomic = \"ptr\");\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_has_atomic)] to the crate attributes to enable\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "985bd8320e05938d9449dc6b75b970d909ab16e4", "filename": "src/test/ui/feature-gate-cfg-target-thread-local.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-thread-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-thread-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-thread-local.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-cfg-target-thread-local.rs"}, {"sha": "9e2eea6e0a48eae5f3bd63e563258ad9b59acba5", "filename": "src/test/ui/feature-gate-cfg-target-thread-local.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-thread-local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-thread-local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-thread-local.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: `cfg(target_thread_local)` is experimental and subject to change (see issue #29594)\n+  --> $DIR/feature-gate-cfg-target-thread-local.rs:19:16\n+   |\n+19 |     #[cfg_attr(target_thread_local, thread_local)]\n+   |                ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_thread_local)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "e68a84d35534f4d46112c2df65b716e1db532fcf", "filename": "src/test/ui/feature-gate-cfg-target-vendor.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-vendor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-vendor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-vendor.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-cfg-target-vendor.rs"}, {"sha": "c5709600dba70b628de170a15bf6ca72365090ff", "filename": "src/test/ui/feature-gate-cfg-target-vendor.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-vendor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-vendor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-cfg-target-vendor.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,34 @@\n+error: `cfg(target_vendor)` is experimental and subject to change (see issue #29718)\n+  --> $DIR/feature-gate-cfg-target-vendor.rs:12:12\n+   |\n+12 | #[cfg_attr(target_vendor = \"x\", x)] //~ ERROR `cfg(target_vendor)` is experimental\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_vendor)] to the crate attributes to enable\n+\n+error: `cfg(target_vendor)` is experimental and subject to change (see issue #29718)\n+  --> $DIR/feature-gate-cfg-target-vendor.rs:11:7\n+   |\n+11 | #[cfg(target_vendor = \"x\")] //~ ERROR `cfg(target_vendor)` is experimental\n+   |       ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_vendor)] to the crate attributes to enable\n+\n+error: `cfg(target_vendor)` is experimental and subject to change (see issue #29718)\n+  --> $DIR/feature-gate-cfg-target-vendor.rs:15:19\n+   |\n+15 | #[cfg(not(any(all(target_vendor = \"x\"))))] //~ ERROR `cfg(target_vendor)` is experimental\n+   |                   ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_vendor)] to the crate attributes to enable\n+\n+error: `cfg(target_vendor)` is experimental and subject to change (see issue #29718)\n+  --> $DIR/feature-gate-cfg-target-vendor.rs:19:10\n+   |\n+19 |     cfg!(target_vendor = \"x\");\n+   |          ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(cfg_target_vendor)] to the crate attributes to enable\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "a15153ea7bf0ab947bbd0b04b0288bfc4899ef1d", "filename": "src/test/ui/feature-gate-clone-closures.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-clone-closures.rs"}, {"sha": "3e07aa17440806fefbdd7f903d670622ca215899", "filename": "src/test/ui/feature-gate-clone-closures.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error[E0599]: no method named `clone` found for type `[closure@$DIR/feature-gate-clone-closures.rs:16:17: 18:6 a:_]` in the current scope\n+  --> $DIR/feature-gate-clone-closures.rs:20:23\n+   |\n+20 |     let hello = hello.clone(); //~ ERROR no method named `clone` found for type\n+   |                       ^^^^^\n+   |\n+   = note: hello is a function, perhaps you wish to call it\n+\n+error: aborting due to previous error\n+"}, {"sha": "f9334f1d3b072ca7372c6b20a968b07b7803ada0", "filename": "src/test/ui/feature-gate-compiler-builtins.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-compiler-builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-compiler-builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-compiler-builtins.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-compiler-builtins.rs"}, {"sha": "ebf42b2bdd8944493361ea199e17151a526ff995", "filename": "src/test/ui/feature-gate-compiler-builtins.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-compiler-builtins.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-compiler-builtins.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-compiler-builtins.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: the `#[compiler_builtins]` attribute is used to identify the `compiler_builtins` crate which contains compiler-rt intrinsics and will never be stable\n+  --> $DIR/feature-gate-compiler-builtins.rs:11:1\n+   |\n+11 | #![compiler_builtins] //~ ERROR the `#[compiler_builtins]` attribute is\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(compiler_builtins)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "f4d97445725cd37de1a6b5f6f57e62e78e146ad7", "filename": "src/test/ui/feature-gate-concat_idents.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-concat_idents.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-concat_idents\n-\n const XY_1: i32 = 10;\n \n fn main() {", "previous_filename": "src/test/compile-fail/concat_idents-gate.rs"}, {"sha": "c980668c298b42cbb6bdb51c56f914a7d8dacb79", "filename": "src/test/ui/feature-gate-concat_idents.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-concat_idents.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,18 @@\n+error: `concat_idents` is not stable enough for use and is subject to change (see issue #29599)\n+  --> $DIR/feature-gate-concat_idents.rs:15:13\n+   |\n+15 |     let a = concat_idents!(X, Y_1); //~ ERROR `concat_idents` is not stable\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(concat_idents)] to the crate attributes to enable\n+\n+error: `concat_idents` is not stable enough for use and is subject to change (see issue #29599)\n+  --> $DIR/feature-gate-concat_idents.rs:16:13\n+   |\n+16 |     let b = concat_idents!(X, Y_2); //~ ERROR `concat_idents` is not stable\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(concat_idents)] to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "af288a97904400eecdda6f45010f0c43fe003aa0", "filename": "src/test/ui/feature-gate-concat_idents2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-concat_idents2.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/gated-concat_idents.rs"}, {"sha": "9cfd954eec8606732a5f7bd588d28e5d397460ca", "filename": "src/test/ui/feature-gate-concat_idents2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-concat_idents2.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: `concat_idents` is not stable enough for use and is subject to change (see issue #29599)\n+  --> $DIR/feature-gate-concat_idents2.rs:14:5\n+   |\n+14 |     concat_idents!(a, b); //~ ERROR `concat_idents` is not stable enough\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(concat_idents)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "5a9ffe98c93cae0b8834dce062fd09cf3b0f8a45", "filename": "src/test/ui/feature-gate-concat_idents3.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-concat_idents3.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/concat_idents-gate2.rs"}, {"sha": "8399ca3c5018cd83f0bc25b0ccc6a2ac332f9145", "filename": "src/test/ui/feature-gate-concat_idents3.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-concat_idents3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-concat_idents3.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,18 @@\n+error: `concat_idents` is not stable enough for use and is subject to change (see issue #29599)\n+  --> $DIR/feature-gate-concat_idents3.rs:17:20\n+   |\n+17 |     assert_eq!(10, concat_idents!(X, Y_1)); //~ ERROR `concat_idents` is not stable\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(concat_idents)] to the crate attributes to enable\n+\n+error: `concat_idents` is not stable enough for use and is subject to change (see issue #29599)\n+  --> $DIR/feature-gate-concat_idents3.rs:18:20\n+   |\n+18 |     assert_eq!(20, concat_idents!(X, Y_2)); //~ ERROR `concat_idents` is not stable\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(concat_idents)] to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7a3ae639bfc8927ddddcc13207fa423dd535d40f", "filename": "src/test/ui/feature-gate-conservative_impl_trait.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-conservative_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-conservative_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-conservative_impl_trait.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-conservative_impl_trait\n-\n fn foo() -> impl Fn() { || {} }\n //~^ ERROR `impl Trait` in return position is experimental\n ", "previous_filename": "src/test/compile-fail/impl-trait/feature-gate.rs"}, {"sha": "72a4f52926a6c842fc81ecfbfb344da177a8cfa3", "filename": "src/test/ui/feature-gate-conservative_impl_trait.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-conservative_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-conservative_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-conservative_impl_trait.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: `impl Trait` in return position is experimental (see issue #34511)\n+  --> $DIR/feature-gate-conservative_impl_trait.rs:11:13\n+   |\n+11 | fn foo() -> impl Fn() { || {} }\n+   |             ^^^^^^^^^\n+   |\n+   = help: add #![feature(conservative_impl_trait)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "0d61878cd8073b25164202a1c41aa42803df15e5", "filename": "src/test/ui/feature-gate-const-indexing.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-const-indexing.rs"}, {"sha": "bc4b687800d755150d666f07db940d656ea4a664", "filename": "src/test/ui/feature-gate-const-indexing.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,8 @@\n+error[E0080]: constant evaluation error\n+  --> $DIR/feature-gate-const-indexing.rs:16:24\n+   |\n+16 |     const BLUB: [i32; (ARR[0] - 41) as usize] = [5]; //~ ERROR constant evaluation error\n+   |                        ^^^^^^ the index operation on const values is unstable\n+\n+error: aborting due to previous error\n+"}, {"sha": "1d1dedddaaa3e72099f70dab571a40f976d0359e", "filename": "src/test/ui/feature-gate-const_fn.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-const_fn.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-const_fn\n-\n // Test use of const fn without feature gate.\n \n const fn foo() -> usize { 0 } //~ ERROR const fn is unstable", "previous_filename": "src/test/compile-fail/const-fn-stability.rs"}, {"sha": "c62229ac71bad16319afb9aace035c38113bba27", "filename": "src/test/ui/feature-gate-const_fn.stderr", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-const_fn.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,60 @@\n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/feature-gate-const_fn.rs:16:5\n+   |\n+16 |     const fn foo() -> u32; //~ ERROR const fn is unstable\n+   |     ^^^^^ trait fns cannot be const\n+\n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/feature-gate-const_fn.rs:18:5\n+   |\n+18 |     const fn bar() -> u32 { 0 } //~ ERROR const fn is unstable\n+   |     ^^^^^ trait fns cannot be const\n+\n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/feature-gate-const_fn.rs:27:5\n+   |\n+27 |     const fn foo() -> u32 { 0 } //~ ERROR const fn is unstable\n+   |     ^^^^^ trait fns cannot be const\n+\n+error: const fn is unstable (see issue #24111)\n+  --> $DIR/feature-gate-const_fn.rs:13:1\n+   |\n+13 | const fn foo() -> usize { 0 } //~ ERROR const fn is unstable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n+\n+error: const fn is unstable (see issue #24111)\n+  --> $DIR/feature-gate-const_fn.rs:16:5\n+   |\n+16 |     const fn foo() -> u32; //~ ERROR const fn is unstable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n+\n+error: const fn is unstable (see issue #24111)\n+  --> $DIR/feature-gate-const_fn.rs:18:5\n+   |\n+18 |     const fn bar() -> u32 { 0 } //~ ERROR const fn is unstable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n+\n+error: const fn is unstable (see issue #24111)\n+  --> $DIR/feature-gate-const_fn.rs:23:5\n+   |\n+23 |     const fn baz() -> u32 { 0 } //~ ERROR const fn is unstable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n+\n+error: const fn is unstable (see issue #24111)\n+  --> $DIR/feature-gate-const_fn.rs:27:5\n+   |\n+27 |     const fn foo() -> u32 { 0 } //~ ERROR const fn is unstable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "b11b09eb9fd9bfab6787d6dc53f5332d98ae1288", "filename": "src/test/ui/feature-gate-copy-closures.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-copy-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-copy-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-copy-closures.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-copy-closures.rs"}, {"sha": "9b324672f22466ed5b2f3231591519a1a04353cb", "filename": "src/test/ui/feature-gate-copy-closures.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-copy-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-copy-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-copy-closures.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,12 @@\n+error[E0382]: use of moved value: `hello`\n+  --> $DIR/feature-gate-copy-closures.rs:18:9\n+   |\n+17 |     let b = hello;\n+   |         - value moved here\n+18 |     let c = hello; //~ ERROR use of moved value: `hello` [E0382]\n+   |         ^ value used here after move\n+   |\n+   = note: move occurs because `hello` has type `[closure@$DIR/feature-gate-copy-closures.rs:13:17: 15:6 a:&i32]`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+"}, {"sha": "830ec5959b7027e18476d98996c551ba8f1bfa7d", "filename": "src/test/ui/feature-gate-crate_in_paths.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-crate_in_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-crate_in_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-crate_in_paths.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/rfc-2126-crate-paths/feature-gate-crate_in_paths.rs"}, {"sha": "b13c82ecfc9079a55f11b04f7cd08d6e8d8db1a5", "filename": "src/test/ui/feature-gate-crate_in_paths.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-crate_in_paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-crate_in_paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-crate_in_paths.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: `crate` in paths is experimental (see issue #45477)\n+  --> $DIR/feature-gate-crate_in_paths.rs:14:15\n+   |\n+14 |     let _ = ::crate::S; //~ ERROR `crate` in paths is experimental\n+   |               ^^^^^\n+   |\n+   = help: add #![feature(crate_in_paths)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "a2937d6de31f3501a9db2d98872164a94810a744", "filename": "src/test/ui/feature-gate-crate_visibility_modifier.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-crate_visibility_modifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-crate_visibility_modifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-crate_visibility_modifier.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-crate_visibility_modifier.rs"}, {"sha": "0862744b87b329c9e1ad70e09dc56df1854afb0a", "filename": "src/test/ui/feature-gate-crate_visibility_modifier.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-crate_visibility_modifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-crate_visibility_modifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-crate_visibility_modifier.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: `crate` visibility modifier is experimental (see issue #45388)\n+  --> $DIR/feature-gate-crate_visibility_modifier.rs:11:1\n+   |\n+11 | crate struct Bender { //~ ERROR `crate` visibility modifier is experimental\n+   | ^^^^^\n+   |\n+   = help: add #![feature(crate_visibility_modifier)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "b54288035175d33c9a477d8279841fe374ad1c62", "filename": "src/test/ui/feature-gate-custom_attribute.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -10,8 +10,6 @@\n \n // Check that literals in attributes parse just fine.\n \n-// gate-test-custom_attribute\n-\n #![feature(rustc_attrs, attr_literals)]\n #![allow(dead_code)]\n #![allow(unused_variables)]", "previous_filename": "src/test/compile-fail/attr-literals.rs"}, {"sha": "866ebfe8f2f3a350ee97dc7708e22b7d93aec3bc", "filename": "src/test/ui/feature-gate-custom_attribute.stderr", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,106 @@\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:17:1\n+   |\n+17 | #[fake_attr] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:18:1\n+   |\n+18 | #[fake_attr(100)] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:19:1\n+   |\n+19 | #[fake_attr(1, 2, 3)] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:20:1\n+   |\n+20 | #[fake_attr(\"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:21:1\n+   |\n+21 | #[fake_attr(name = \"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:22:1\n+   |\n+22 | #[fake_attr(1, \"hi\", key = 12, true, false)] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:23:1\n+   |\n+23 | #[fake_attr(key = \"hello\", val = 10)] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:24:1\n+   |\n+24 | #[fake_attr(key(\"hello\"), val(10))] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:25:1\n+   |\n+25 | #[fake_attr(enabled = true, disabled = false)] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:26:1\n+   |\n+26 | #[fake_attr(true)] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:27:1\n+   |\n+27 | #[fake_attr(pi = 3.14159)] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:28:1\n+   |\n+28 | #[fake_attr(b\"hi\")] //~ ERROR attribute `fake_attr` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `fake_doc` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute.rs:29:1\n+   |\n+29 | #[fake_doc(r\"doc\")] //~ ERROR attribute `fake_doc` is currently unknown\n+   | ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "0d89c52d885f9022a85dfffaddd905ddd7914263", "filename": "src/test/ui/feature-gate-custom_attribute2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute2.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/attr-on-generic-formals-are-visited.rs"}, {"sha": "3e4ea58a7a3fb1e30e67ce5ad72d29937d3ad2d9", "filename": "src/test/ui/feature-gate-custom_attribute2.stderr", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-custom_attribute2.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,138 @@\n+error: The attribute `lt_struct` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:23:13\n+   |\n+23 | struct StLt<#[lt_struct] 'a>(&'a u32);\n+   |             ^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `ty_struct` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:25:13\n+   |\n+25 | struct StTy<#[ty_struct] I>(I);\n+   |             ^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `lt_enum` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:28:11\n+   |\n+28 | enum EnLt<#[lt_enum] 'b> { A(&'b u32), B }\n+   |           ^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `ty_enum` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:30:11\n+   |\n+30 | enum EnTy<#[ty_enum] J> { A(J), B }\n+   |           ^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `lt_trait` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:33:12\n+   |\n+33 | trait TrLt<#[lt_trait] 'c> { fn foo(&self, _: &'c [u32]) -> &'c u32; }\n+   |            ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `ty_trait` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:35:12\n+   |\n+35 | trait TrTy<#[ty_trait] K> { fn foo(&self, _: K); }\n+   |            ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `lt_type` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:38:11\n+   |\n+38 | type TyLt<#[lt_type] 'd> = &'d u32;\n+   |           ^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `ty_type` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:40:11\n+   |\n+40 | type TyTy<#[ty_type] L> = (L, );\n+   |           ^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `lt_inherent` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:43:6\n+   |\n+43 | impl<#[lt_inherent] 'e> StLt<'e> { }\n+   |      ^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `ty_inherent` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:45:6\n+   |\n+45 | impl<#[ty_inherent] M> StTy<M> { }\n+   |      ^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `lt_impl_for` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:48:6\n+   |\n+48 | impl<#[lt_impl_for] 'f> TrLt<'f> for StLt<'f> {\n+   |      ^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `ty_impl_for` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:52:6\n+   |\n+52 | impl<#[ty_impl_for] N> TrTy<N> for StTy<N> {\n+   |      ^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `lt_fn` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:57:9\n+   |\n+57 | fn f_lt<#[lt_fn] 'g>(_: &'g [u32]) -> &'g u32 { loop { } }\n+   |         ^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `ty_fn` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:59:9\n+   |\n+59 | fn f_ty<#[ty_fn] O>(_: O) { }\n+   |         ^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `lt_meth` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:63:13\n+   |\n+63 |     fn m_lt<#[lt_meth] 'h>(_: &'h [u32]) -> &'h u32 { loop { } }\n+   |             ^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `ty_meth` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:65:13\n+   |\n+65 |     fn m_ty<#[ty_meth] P>(_: P) { }\n+   |             ^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: The attribute `lt_hof` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/feature-gate-custom_attribute2.rs:70:19\n+   |\n+70 |     where Q: for <#[lt_hof] 'i> Fn(&'i [u32]) -> &'i u32\n+   |                   ^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: aborting due to 17 previous errors\n+"}, {"sha": "0b1b3141f5bf7745e63496c1e0599399a2ba68c4", "filename": "src/test/ui/feature-gate-custom_derive.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-custom_derive.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-custom_derive\n-\n #[derive_Clone]\n //~^ ERROR attributes of the form `#[derive_*]` are reserved\n struct Test;", "previous_filename": "src/test/compile-fail/single-derive-attr.rs"}, {"sha": "e806c808631197e9509b9a4b8c2397e2b6880607", "filename": "src/test/ui/feature-gate-custom_derive.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-custom_derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-custom_derive.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: attributes of the form `#[derive_*]` are reserved for the compiler (see issue #29644)\n+  --> $DIR/feature-gate-custom_derive.rs:11:1\n+   |\n+11 | #[derive_Clone]\n+   | ^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_derive)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "c5c83977c77fd0ae0e820a8d209b37247b82e9c8", "filename": "src/test/ui/feature-gate-decl_macro.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-decl_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-decl_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-decl_macro.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-decl_macro.rs"}, {"sha": "49ce4eb10b615cd4d638ffc30d9b1694beccba71", "filename": "src/test/ui/feature-gate-decl_macro.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-decl_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-decl_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-decl_macro.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: `macro` is experimental (see issue #39412)\n+  --> $DIR/feature-gate-decl_macro.rs:13:1\n+   |\n+13 | macro m() {} //~ ERROR `macro` is experimental (see issue #39412)\n+   | ^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(decl_macro)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "ccc5ec49f1302500f1b7d8900468d2d599bcad4d", "filename": "src/test/ui/feature-gate-default_type_parameter_fallback.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-default_type_parameter_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-default_type_parameter_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-default_type_parameter_fallback.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-default_type_parameter_fallback\n-\n #![allow(unused)]\n \n fn avg<T=i32>(_: T) {}", "previous_filename": "src/test/compile-fail/type-parameter-invalid-lint.rs"}, {"sha": "d756a69e8c1ec944ef999defbe35add0d7cbc78c", "filename": "src/test/ui/feature-gate-default_type_parameter_fallback.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-default_type_parameter_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-default_type_parameter_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-default_type_parameter_fallback.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,21 @@\n+error: defaults for type parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions.\n+  --> $DIR/feature-gate-default_type_parameter_fallback.rs:13:8\n+   |\n+13 | fn avg<T=i32>(_: T) {}\n+   |        ^\n+   |\n+   = note: #[deny(invalid_type_param_default)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #36887 <https://github.com/rust-lang/rust/issues/36887>\n+\n+error: defaults for type parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions.\n+  --> $DIR/feature-gate-default_type_parameter_fallback.rs:18:6\n+   |\n+18 | impl<T=i32> S<T> {}\n+   |      ^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #36887 <https://github.com/rust-lang/rust/issues/36887>\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "1a77d918014572c3c4974867dec71738a8665d4a", "filename": "src/test/ui/feature-gate-doc_cfg.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-doc_cfg.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-doc_cfg.rs"}, {"sha": "c2d8a934ab8e42a91d573e9915cd696300b3345e", "filename": "src/test/ui/feature-gate-doc_cfg.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_cfg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_cfg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-doc_cfg.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: #[doc(cfg(...))] is experimental (see issue #43781)\n+  --> $DIR/feature-gate-doc_cfg.rs:11:1\n+   |\n+11 | #[doc(cfg(unix))] //~ ERROR: #[doc(cfg(...))] is experimental\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(doc_cfg)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "bb5be9d69710f947844ab4118e92a0e0176bdf32", "filename": "src/test/ui/feature-gate-doc_masked.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_masked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_masked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-doc_masked.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-doc_masked.rs"}, {"sha": "11020765304f754d858a4ce94858d9717e65e278", "filename": "src/test/ui/feature-gate-doc_masked.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_masked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_masked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-doc_masked.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: #[doc(masked)] is experimental (see issue #44027)\n+  --> $DIR/feature-gate-doc_masked.rs:11:1\n+   |\n+11 | #[doc(masked)] //~ ERROR: #[doc(masked)] is experimental\n+   | ^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(doc_masked)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "6369358538d50417bac4f2e58da643eb6fddf16c", "filename": "src/test/ui/feature-gate-doc_spotlight.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_spotlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_spotlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-doc_spotlight.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-doc_spotlight.rs"}, {"sha": "b743a1e94bc751e176c98848f0eee3478dd2a19e", "filename": "src/test/ui/feature-gate-doc_spotlight.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_spotlight.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-doc_spotlight.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-doc_spotlight.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: #[doc(spotlight)] is experimental (see issue #45040)\n+  --> $DIR/feature-gate-doc_spotlight.rs:11:1\n+   |\n+11 | #[doc(spotlight)] //~ ERROR: #[doc(spotlight)] is experimental\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(doc_spotlight)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "1fb139bf07f411fced6eb630d1594edce3b3e6ce", "filename": "src/test/ui/feature-gate-dotdoteq_in_patterns.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dotdoteq_in_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dotdoteq_in_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-dotdoteq_in_patterns.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-dotdoteq_in_patterns.rs"}, {"sha": "5319dcef2d5e697c897a1371bf7b55d93ec712b5", "filename": "src/test/ui/feature-gate-dotdoteq_in_patterns.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dotdoteq_in_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dotdoteq_in_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-dotdoteq_in_patterns.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: `..=` syntax in patterns is experimental (see issue #28237)\n+  --> $DIR/feature-gate-dotdoteq_in_patterns.rs:13:9\n+   |\n+13 |         0 ..= 3 => {} //~ ERROR `..=` syntax in patterns is experimental\n+   |         ^^^^^^^\n+   |\n+   = help: add #![feature(dotdoteq_in_patterns)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "70ec561439c61a314471ac2cebd4b230fadd1cd7", "filename": "src/test/ui/feature-gate-dropck-ugeh-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh-2.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-dropck-ugeh-2.rs"}, {"sha": "0555b485d4c0566905ffb8de9dbf7718e7e71c82", "filename": "src/test/ui/feature-gate-dropck-ugeh-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh-2.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,14 @@\n+error: use of deprecated attribute `dropck_parametricity`: unsafe_destructor_blind_to_params has been replaced by may_dangle and will be removed in the future. See https://github.com/rust-lang/rust/issues/34761\n+  --> $DIR/feature-gate-dropck-ugeh-2.rs:17:5\n+   |\n+17 |     #[unsafe_destructor_blind_to_params]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n+   |\n+note: lint level defined here\n+  --> $DIR/feature-gate-dropck-ugeh-2.rs:11:9\n+   |\n+11 | #![deny(deprecated)]\n+   |         ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "360895d30b0b7e39866ea4ba4e754299dbf1fb84", "filename": "src/test/ui/feature-gate-dropck-ugeh.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-dropck-ugeh.rs"}, {"sha": "b030ebcd8814178570b75637790d29612f587c81", "filename": "src/test/ui/feature-gate-dropck-ugeh.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-dropck-ugeh.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: unsafe_destructor_blind_to_params has been replaced by may_dangle and will be removed in the future (see issue #28498)\n+  --> $DIR/feature-gate-dropck-ugeh.rs:29:5\n+   |\n+29 |     #[unsafe_destructor_blind_to_params] // This is the UGEH attribute\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(dropck_parametricity)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "4b3803d019baa043e0a2038616ac4cffbd95f341", "filename": "src/test/ui/feature-gate-dyn-trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-dyn-trait.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-dyn-trait.rs"}, {"sha": "28ecfdf1131da74ea32fde6a1ef8c168e655f985", "filename": "src/test/ui/feature-gate-dyn-trait.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-dyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-dyn-trait.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: `dyn Trait` syntax is unstable (see issue #44662)\n+  --> $DIR/feature-gate-dyn-trait.rs:12:14\n+   |\n+12 | type A = Box<dyn Trait>; //~ ERROR `dyn Trait` syntax is unstable\n+   |              ^^^^^^^^^\n+   |\n+   = help: add #![feature(dyn_trait)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "e0b6d5986ff3734e07f5576eff8f4963a811aca1", "filename": "src/test/ui/feature-gate-exclusive-range-pattern.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-exclusive-range-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-exclusive-range-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-exclusive-range-pattern.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-exclusive-range-pattern.rs"}, {"sha": "c6785d6f29da407adc5b9643da99b7d16f6d162b", "filename": "src/test/ui/feature-gate-exclusive-range-pattern.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-exclusive-range-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-exclusive-range-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-exclusive-range-pattern.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: exclusive range pattern syntax is experimental (see issue #37854)\n+  --> $DIR/feature-gate-exclusive-range-pattern.rs:13:9\n+   |\n+13 |         0 .. 3 => {} //~ ERROR exclusive range pattern syntax is experimental\n+   |         ^^^^^^\n+   |\n+   = help: add #![feature(exclusive_range_pattern)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "1203b598df3c2e7800525ecf9dda1720ac6f215e", "filename": "src/test/ui/feature-gate-extern_types.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-extern_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-extern_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-extern_types.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-extern_types.rs"}, {"sha": "3815862e89912ac18e2937f94e80fd51b6693c33", "filename": "src/test/ui/feature-gate-extern_types.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-extern_types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-extern_types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-extern_types.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: extern types are experimental (see issue #43467)\n+  --> $DIR/feature-gate-extern_types.rs:12:5\n+   |\n+12 |     type T; //~ ERROR extern types are experimental\n+   |     ^^^^^^^\n+   |\n+   = help: add #![feature(extern_types)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "fa0a2a29078c556746a115418085ed214e71f085", "filename": "src/test/ui/feature-gate-external_doc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-external_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-external_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-external_doc.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-external_doc.rs"}, {"sha": "5479ab8bc912834a45e2615ed640de5d43beb99c", "filename": "src/test/ui/feature-gate-external_doc.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-external_doc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-external_doc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-external_doc.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,10 @@\n+error: #[doc(include = \"...\")] is experimental (see issue #44732)\n+  --> $DIR/feature-gate-external_doc.rs:11:1\n+   |\n+11 | #[doc(include=\"asdf.md\")] //~ ERROR: #[doc(include = \"...\")] is experimental\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(external_doc)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "b903b29658bbb6c2e243cc298415bbd27e0839b5", "filename": "src/test/ui/feature-gate-feature-gate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-feature-gate.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-feature-gate.rs"}, {"sha": "3d5f0d70bb2d745352a99bb6c4bb9e2aaaa34bdf", "filename": "src/test/ui/feature-gate-feature-gate.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-feature-gate.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,14 @@\n+error: unstable feature\n+  --> $DIR/feature-gate-feature-gate.rs:12:12\n+   |\n+12 | #![feature(intrinsics)] //~ ERROR unstable feature\n+   |            ^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/feature-gate-feature-gate.rs:11:11\n+   |\n+11 | #![forbid(unstable_features)]\n+   |           ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "1c04199c05f7c7ec60e1af295be21fe3de263d3e", "filename": "src/test/ui/feature-gate-fn_must_use-cap-lints-allow.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use-cap-lints-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use-cap-lints-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use-cap-lints-allow.rs?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "previous_filename": "src/test/compile-fail/feature-gate-fn_must_use-cap-lints-allow.rs"}, {"sha": "9b16e9be68ab33ff263fdfe9528a81375e4a7c93", "filename": "src/test/ui/feature-gate-fn_must_use-cap-lints-allow.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use-cap-lints-allow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e5583b7f88c609492bf4f7b3a08313bc501b0ad/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use-cap-lints-allow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use-cap-lints-allow.stderr?ref=7e5583b7f88c609492bf4f7b3a08313bc501b0ad", "patch": "@@ -0,0 +1,6 @@\n+error: compilation successful\n+  --> $DIR/feature-gate-fn_must_use-cap-lints-allow.rs:22:1\n+   |\n+22 | fn main() {} //~ ERROR compilation successful\n+   | ^^^^^^^^^^^^\n+"}]}