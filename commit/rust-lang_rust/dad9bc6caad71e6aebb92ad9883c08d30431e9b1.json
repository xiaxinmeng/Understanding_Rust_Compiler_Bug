{"sha": "dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZDliYzZjYWFkNzFlNmFlYmI5MmFkOTg4M2MwOGQzMDQzMWU5YjE=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-04T12:45:27Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-04T12:45:27Z"}, "message": "Merge branch 'master' into feature/themes", "tree": {"sha": "6495d47108bc56ab0fbb358125fe65ebece8934f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6495d47108bc56ab0fbb358125fe65ebece8934f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "html_url": "https://github.com/rust-lang/rust/commit/dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "html_url": "https://github.com/rust-lang/rust/commit/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2"}, {"sha": "cc2d75d0f88bdcb1b3e20db36decb6ee6eca517a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc2d75d0f88bdcb1b3e20db36decb6ee6eca517a", "html_url": "https://github.com/rust-lang/rust/commit/cc2d75d0f88bdcb1b3e20db36decb6ee6eca517a"}], "stats": {"total": 3122, "additions": 1810, "deletions": 1312}, "files": [{"sha": "183e9b521184ca8587588157def155945dfb7a4e", "filename": ".gitattributes", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1 +1,2 @@\n-crates/ra_syntax/tests/data/** -text\n+crates/ra_syntax/test_data/** -text eof=LF\n+crates/ra_ide_api/src/snapshots/** -text eof=LF"}, {"sha": "3879204d9e7a456e46052ac746c65c7e39f12ce1", "filename": "Cargo.lock", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -126,7 +126,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"chalk-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -136,52 +136,52 @@ dependencies = [\n [[package]]\n name = \"chalk-engine\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n dependencies = [\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stacker 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-macros\"\n version = \"0.1.1\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n dependencies = [\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-rust-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n dependencies = [\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -985,6 +985,7 @@ dependencies = [\n  \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"salsa 0.13.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"test_utils 0.1.0\",\n ]\n \n [[package]]\n@@ -1000,9 +1001,9 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n- \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1018,7 +1019,6 @@ dependencies = [\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_tt 0.1.0\",\n- \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n@@ -1027,6 +1027,7 @@ dependencies = [\n name = \"ra_hir_def\"\n version = \"0.1.0\"\n dependencies = [\n+ \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n@@ -1037,7 +1038,6 @@ dependencies = [\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_tt 0.1.0\",\n- \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n@@ -1077,7 +1077,6 @@ dependencies = [\n  \"ra_text_edit 0.1.0\",\n  \"rand 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rayon 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"superslice 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n@@ -1849,12 +1848,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cargo_metadata 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d2d1617e838936c0d2323a65cc151e03ae19a7678dd24f72bccf27119b90a5d\"\n \"checksum cc 1.0.46 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0213d356d3c4ea2c18c40b037c3be23cd639825c18f25ee670ac7813beeef99c\"\n \"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n-\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n-\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n-\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n-\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n-\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n+\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n+\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n+\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n+\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n+\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n+\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n \"checksum chrono 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8493056968583b0193c1bb04d6f7684586f3726992d6c573261941a895dbd68\"\n \"checksum clicolors-control 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90082ee5dcdd64dc4e9e0d37fbf3ee325419e39c0092191e0393df65518f741e\"\n \"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\""}, {"sha": "570a07a20c56620b83d4e3e7898d529ca758fa2c", "filename": "crates/ra_assists/src/assists/early_return.rs", "status": "modified", "additions": 190, "deletions": 29, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -3,9 +3,10 @@ use std::ops::RangeInclusive;\n use hir::db::HirDatabase;\n use ra_syntax::{\n     algo::replace_children,\n-    ast::{self, edit::IndentLevel, make},\n+    ast::{self, edit::IndentLevel, make, Block, Pat::TupleStructPat},\n     AstNode,\n     SyntaxKind::{FN_DEF, LOOP_EXPR, L_CURLY, R_CURLY, WHILE_EXPR, WHITESPACE},\n+    SyntaxNode,\n };\n \n use crate::{\n@@ -37,7 +38,23 @@ use crate::{\n // ```\n pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n-    let expr = if_expr.condition()?.expr()?;\n+    let cond = if_expr.condition()?;\n+    let mut if_let_ident: Option<String> = None;\n+\n+    // Check if there is an IfLet that we can handle.\n+    match cond.pat() {\n+        None => {} // No IfLet, supported.\n+        Some(TupleStructPat(ref pat)) if pat.args().count() == 1usize => match &pat.path() {\n+            Some(p) => match p.qualifier() {\n+                None => if_let_ident = Some(p.syntax().text().to_string()),\n+                _ => return None,\n+            },\n+            _ => return None,\n+        },\n+        _ => return None, // Unsupported IfLet.\n+    };\n+\n+    let expr = cond.expr()?;\n     let then_block = if_expr.then_branch()?.block()?;\n     if if_expr.else_branch().is_some() {\n         return None;\n@@ -63,8 +80,8 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n     let parent_container = parent_block.syntax().parent()?.parent()?;\n \n     let early_expression = match parent_container.kind() {\n-        WHILE_EXPR | LOOP_EXPR => Some(\"continue;\"),\n-        FN_DEF => Some(\"return;\"),\n+        WHILE_EXPR | LOOP_EXPR => Some(\"continue\"),\n+        FN_DEF => Some(\"return\"),\n         _ => None,\n     }?;\n \n@@ -77,34 +94,58 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n     ctx.add_assist(AssistId(\"convert_to_guarded_return\"), \"convert to guarded return\", |edit| {\n         let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n-        let new_if_expr =\n-            if_indent_level.increase_indent(make::if_expression(&expr, early_expression));\n-        let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n-        let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n-        let end_of_then =\n-            if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n-                end_of_then.prev_sibling_or_token().unwrap()\n-            } else {\n-                end_of_then\n-            };\n-        let mut new_if_and_then_statements = new_if_expr.syntax().children_with_tokens().chain(\n-            then_block_items\n-                .syntax()\n-                .children_with_tokens()\n-                .skip(1)\n-                .take_while(|i| *i != end_of_then),\n-        );\n-        let new_block = replace_children(\n-            &parent_block.syntax(),\n-            RangeInclusive::new(\n-                if_expr.clone().syntax().clone().into(),\n-                if_expr.syntax().clone().into(),\n-            ),\n-            &mut new_if_and_then_statements,\n-        );\n+        let new_block = match if_let_ident {\n+            None => {\n+                // If.\n+                let early_expression = &(early_expression.to_owned() + \";\");\n+                let new_expr =\n+                    if_indent_level.increase_indent(make::if_expression(&expr, early_expression));\n+                replace(new_expr, &then_block, &parent_block, &if_expr)\n+            }\n+            Some(if_let_ident) => {\n+                // If-let.\n+                let new_expr = if_indent_level.increase_indent(make::let_match_early(\n+                    expr,\n+                    &if_let_ident,\n+                    early_expression,\n+                ));\n+                replace(new_expr, &then_block, &parent_block, &if_expr)\n+            }\n+        };\n         edit.target(if_expr.syntax().text_range());\n         edit.replace_ast(parent_block, ast::Block::cast(new_block).unwrap());\n         edit.set_cursor(cursor_position);\n+\n+        fn replace(\n+            new_expr: impl AstNode,\n+            then_block: &Block,\n+            parent_block: &Block,\n+            if_expr: &ast::IfExpr,\n+        ) -> SyntaxNode {\n+            let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n+            let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n+            let end_of_then =\n+                if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n+                    end_of_then.prev_sibling_or_token().unwrap()\n+                } else {\n+                    end_of_then\n+                };\n+            let mut then_statements = new_expr.syntax().children_with_tokens().chain(\n+                then_block_items\n+                    .syntax()\n+                    .children_with_tokens()\n+                    .skip(1)\n+                    .take_while(|i| *i != end_of_then),\n+            );\n+            replace_children(\n+                &parent_block.syntax(),\n+                RangeInclusive::new(\n+                    if_expr.clone().syntax().clone().into(),\n+                    if_expr.syntax().clone().into(),\n+                ),\n+                &mut then_statements,\n+            )\n+        }\n     })\n }\n \n@@ -143,6 +184,68 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_let_inside_fn() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main(n: Option<String>) {\n+                bar();\n+                if<|> let Some(n) = n {\n+                    foo(n);\n+\n+                    //comment\n+                    bar();\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main(n: Option<String>) {\n+                bar();\n+                le<|>t n = match n {\n+                    Some(it) => it,\n+                    None => return,\n+                };\n+                foo(n);\n+\n+                //comment\n+                bar();\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_let_ok_inside_fn() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main(n: Option<String>) {\n+                bar();\n+                if<|> let Ok(n) = n {\n+                    foo(n);\n+\n+                    //comment\n+                    bar();\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main(n: Option<String>) {\n+                bar();\n+                le<|>t n = match n {\n+                    Ok(it) => it,\n+                    None => return,\n+                };\n+                foo(n);\n+\n+                //comment\n+                bar();\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn convert_inside_while() {\n         check_assist(\n@@ -171,6 +274,35 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_let_inside_while() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main() {\n+                while true {\n+                    if<|> let Some(n) = n {\n+                        foo(n);\n+                        bar();\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                while true {\n+                    le<|>t n = match n {\n+                        Some(it) => it,\n+                        None => continue,\n+                    };\n+                    foo(n);\n+                    bar();\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn convert_inside_loop() {\n         check_assist(\n@@ -199,6 +331,35 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_let_inside_loop() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main() {\n+                loop {\n+                    if<|> let Some(n) = n {\n+                        foo(n);\n+                        bar();\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                loop {\n+                    le<|>t n = match n {\n+                        Some(it) => it,\n+                        None => continue,\n+                    };\n+                    foo(n);\n+                    bar();\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn ignore_already_converted_if() {\n         check_assist_not_applicable("}, {"sha": "bf1f7920c583d8dfe92f2f400f52fa62f6bed961", "filename": "crates/ra_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2FCargo.toml?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -12,3 +12,4 @@ rustc-hash = \"1.0\"\n ra_syntax = { path = \"../ra_syntax\" }\n ra_cfg = { path = \"../ra_cfg\" }\n ra_prof = { path = \"../ra_prof\" }\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "f5dd59f8401134fa96adb9895f93c4b9ae14b033", "filename": "crates/ra_db/src/fixture.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -0,0 +1,186 @@\n+//! FIXME: write short doc here\n+\n+use std::sync::Arc;\n+\n+use ra_cfg::CfgOptions;\n+use rustc_hash::FxHashMap;\n+use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n+\n+use crate::{\n+    CrateGraph, Edition, FileId, FilePosition, RelativePathBuf, SourceDatabaseExt, SourceRoot,\n+    SourceRootId,\n+};\n+\n+pub const WORKSPACE: SourceRootId = SourceRootId(0);\n+\n+pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n+    fn with_single_file(text: &str) -> (Self, FileId) {\n+        let mut db = Self::default();\n+        let file_id = with_single_file(&mut db, text);\n+        (db, file_id)\n+    }\n+\n+    fn with_files(fixture: &str) -> Self {\n+        let mut db = Self::default();\n+        let pos = with_files(&mut db, fixture);\n+        assert!(pos.is_none());\n+        db\n+    }\n+\n+    fn with_position(fixture: &str) -> (Self, FilePosition) {\n+        let mut db = Self::default();\n+        let pos = with_files(&mut db, fixture);\n+        (db, pos.unwrap())\n+    }\n+}\n+\n+impl<DB: SourceDatabaseExt + Default + 'static> WithFixture for DB {}\n+\n+fn with_single_file(db: &mut dyn SourceDatabaseExt, text: &str) -> FileId {\n+    let file_id = FileId(0);\n+    let rel_path: RelativePathBuf = \"/main.rs\".into();\n+\n+    let mut source_root = SourceRoot::default();\n+    source_root.insert_file(rel_path.clone(), file_id);\n+\n+    let mut crate_graph = CrateGraph::default();\n+    crate_graph.add_crate_root(file_id, Edition::Edition2018, CfgOptions::default());\n+\n+    db.set_file_text(file_id, Arc::new(text.to_string()));\n+    db.set_file_relative_path(file_id, rel_path);\n+    db.set_file_source_root(file_id, WORKSPACE);\n+    db.set_source_root(WORKSPACE, Arc::new(source_root));\n+    db.set_crate_graph(Arc::new(crate_graph));\n+\n+    file_id\n+}\n+\n+fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosition> {\n+    let fixture = parse_fixture(fixture);\n+\n+    let mut crate_graph = CrateGraph::default();\n+    let mut crates = FxHashMap::default();\n+    let mut crate_deps = Vec::new();\n+    let mut default_crate_root: Option<FileId> = None;\n+\n+    let mut source_root = SourceRoot::default();\n+    let mut source_root_id = WORKSPACE;\n+    let mut source_root_prefix: RelativePathBuf = \"/\".into();\n+    let mut file_id = FileId(0);\n+\n+    let mut file_position = None;\n+\n+    for entry in fixture.iter() {\n+        let meta = match parse_meta(&entry.meta) {\n+            ParsedMeta::Root { path } => {\n+                let source_root = std::mem::replace(&mut source_root, SourceRoot::default());\n+                db.set_source_root(source_root_id, Arc::new(source_root));\n+                source_root_id.0 += 1;\n+                source_root_prefix = path;\n+                continue;\n+            }\n+            ParsedMeta::File(it) => it,\n+        };\n+        assert!(meta.path.starts_with(&source_root_prefix));\n+\n+        if let Some(krate) = meta.krate {\n+            let crate_id = crate_graph.add_crate_root(file_id, meta.edition, meta.cfg);\n+            let prev = crates.insert(krate.clone(), crate_id);\n+            assert!(prev.is_none());\n+            for dep in meta.deps {\n+                crate_deps.push((krate.clone(), dep))\n+            }\n+        } else if meta.path == \"/main.rs\" || meta.path == \"/lib.rs\" {\n+            assert!(default_crate_root.is_none());\n+            default_crate_root = Some(file_id);\n+        }\n+\n+        let text = if entry.text.contains(CURSOR_MARKER) {\n+            let (offset, text) = extract_offset(&entry.text);\n+            assert!(file_position.is_none());\n+            file_position = Some(FilePosition { file_id, offset });\n+            text.to_string()\n+        } else {\n+            entry.text.to_string()\n+        };\n+\n+        db.set_file_text(file_id, Arc::new(text));\n+        db.set_file_relative_path(file_id, meta.path.clone());\n+        db.set_file_source_root(file_id, source_root_id);\n+        source_root.insert_file(meta.path, file_id);\n+\n+        file_id.0 += 1;\n+    }\n+\n+    if crates.is_empty() {\n+        let crate_root = default_crate_root.unwrap();\n+        crate_graph.add_crate_root(crate_root, Edition::Edition2018, CfgOptions::default());\n+    } else {\n+        for (from, to) in crate_deps {\n+            let from_id = crates[&from];\n+            let to_id = crates[&to];\n+            crate_graph.add_dep(from_id, to.into(), to_id).unwrap();\n+        }\n+    }\n+\n+    db.set_source_root(source_root_id, Arc::new(source_root));\n+    db.set_crate_graph(Arc::new(crate_graph));\n+\n+    file_position\n+}\n+\n+enum ParsedMeta {\n+    Root { path: RelativePathBuf },\n+    File(FileMeta),\n+}\n+\n+struct FileMeta {\n+    path: RelativePathBuf,\n+    krate: Option<String>,\n+    deps: Vec<String>,\n+    cfg: CfgOptions,\n+    edition: Edition,\n+}\n+\n+//- /lib.rs crate:foo deps:bar,baz\n+fn parse_meta(meta: &str) -> ParsedMeta {\n+    let components = meta.split_ascii_whitespace().collect::<Vec<_>>();\n+\n+    if components[0] == \"root\" {\n+        let path: RelativePathBuf = components[1].into();\n+        assert!(path.starts_with(\"/\") && path.ends_with(\"/\"));\n+        return ParsedMeta::Root { path };\n+    }\n+\n+    let path: RelativePathBuf = components[0].into();\n+    assert!(path.starts_with(\"/\"));\n+\n+    let mut krate = None;\n+    let mut deps = Vec::new();\n+    let mut edition = Edition::Edition2018;\n+    let mut cfg = CfgOptions::default();\n+    for component in components[1..].iter() {\n+        let (key, value) = split1(component, ':').unwrap();\n+        match key {\n+            \"crate\" => krate = Some(value.to_string()),\n+            \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n+            \"edition\" => edition = Edition::from_string(&value),\n+            \"cfg\" => {\n+                for key in value.split(',') {\n+                    match split1(key, '=') {\n+                        None => cfg.insert_atom(key.into()),\n+                        Some((k, v)) => cfg.insert_key_value(k.into(), v.into()),\n+                    }\n+                }\n+            }\n+            _ => panic!(\"bad component: {:?}\", component),\n+        }\n+    }\n+\n+    ParsedMeta::File(FileMeta { path, krate, deps, edition, cfg })\n+}\n+\n+fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n+    let idx = haystack.find(delim)?;\n+    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n+}"}, {"sha": "60f7dc8815657298919581782f4a1b96e968c754", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -6,13 +6,14 @@\n //! actual IO. See `vfs` and `project_model` in the `ra_lsp_server` crate for how\n //! actual IO is done and lowered to input.\n \n-use relative_path::{RelativePath, RelativePathBuf};\n use rustc_hash::FxHashMap;\n \n use ra_cfg::CfgOptions;\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n \n+use crate::{RelativePath, RelativePathBuf};\n+\n /// `FileId` is an integer which uniquely identifies a file. File paths are\n /// messy and system-dependent, so most of the code should work directly with\n /// `FileId`, without inspecting the path. The mapping between `FileId` and path\n@@ -97,6 +98,7 @@ pub enum Edition {\n }\n \n impl Edition {\n+    //FIXME: replace with FromStr with proper error handling\n     pub fn from_string(s: &str) -> Edition {\n         match s {\n             \"2015\" => Edition::Edition2015,"}, {"sha": "b6bfd531de934029e4c19f81c8110ad0291735f1", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1,17 +1,18 @@\n //! ra_db defines basic database traits. The concrete DB is defined by ra_ide_api.\n mod cancellation;\n mod input;\n+pub mod fixture;\n \n use std::{panic, sync::Arc};\n \n use ra_prof::profile;\n use ra_syntax::{ast, Parse, SourceFile, TextRange, TextUnit};\n-use relative_path::{RelativePath, RelativePathBuf};\n \n pub use crate::{\n     cancellation::Canceled,\n     input::{CrateGraph, CrateId, Dependency, Edition, FileId, SourceRoot, SourceRootId},\n };\n+pub use relative_path::{RelativePath, RelativePathBuf};\n pub use salsa;\n \n pub trait CheckCanceled {"}, {"sha": "324961328487aa32c3b07b849e16c1694e1a0a01", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -7,7 +7,6 @@ authors = [\"rust-analyzer developers\"]\n [dependencies]\n arrayvec = \"0.5.1\"\n log = \"0.4.5\"\n-relative-path = \"1.0.0\"\n rustc-hash = \"1.0\"\n parking_lot = \"0.9.0\"\n ena = \"0.13\"\n@@ -24,9 +23,9 @@ hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n test_utils = { path = \"../test_utils\" }\n ra_prof = { path = \"../ra_prof\" }\n \n-chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"8314f2fcec8582a58c24b638f1a259d4145a0809\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"8314f2fcec8582a58c24b638f1a259d4145a0809\" }\n-chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"8314f2fcec8582a58c24b638f1a259d4145a0809\" }\n+chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n+chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n lalrpop-intern = \"0.15.1\"\n \n [dev-dependencies]"}, {"sha": "181c5d47afebd559a1c83dc071702331887fc3f9", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -9,28 +9,29 @@ use hir_def::{\n     adt::VariantData,\n     builtin_type::BuiltinType,\n     type_ref::{Mutability, TypeRef},\n-    CrateModuleId, LocalEnumVariantId, LocalStructFieldId, ModuleId,\n+    CrateModuleId, LocalEnumVariantId, LocalStructFieldId, ModuleId, UnionId,\n+};\n+use hir_expand::{\n+    diagnostics::DiagnosticSink,\n+    name::{self, AsName},\n };\n-use hir_expand::name::{self, AsName};\n use ra_db::{CrateId, Edition};\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n     adt::VariantDef,\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    diagnostics::DiagnosticSink,\n     expr::{validation::ExprValidator, Body, BodySourceMap},\n     generics::HasGenericParams,\n     ids::{\n         AstItemDef, ConstId, EnumId, FunctionId, MacroDefId, StaticId, StructId, TraitId,\n         TypeAliasId,\n     },\n     impl_block::ImplBlock,\n-    nameres::{ImportId, ModuleScope, Namespace},\n     resolve::{Resolver, Scope, TypeNs},\n     traits::TraitData,\n     ty::{InferenceResult, TraitRef},\n-    Either, HasSource, Name, Ty,\n+    Either, HasSource, Name, ScopeDef, Ty, {ImportId, Namespace},\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -64,7 +65,7 @@ impl Crate {\n     }\n \n     pub fn root_module(self, db: &impl DefDatabase) -> Option<Module> {\n-        let module_id = db.crate_def_map(self).root();\n+        let module_id = db.crate_def_map(self.crate_id).root();\n         Some(Module::new(self, module_id))\n     }\n \n@@ -118,7 +119,7 @@ impl Module {\n \n     /// Name of this module.\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let parent = def_map[self.id.module_id].parent?;\n         def_map[parent].children.iter().find_map(|(name, module_id)| {\n             if *module_id == self.id.module_id {\n@@ -149,20 +150,20 @@ impl Module {\n     /// might be missing `krate`. This can happen if a module's file is not included\n     /// in the module tree of any target in `Cargo.toml`.\n     pub fn crate_root(self, db: &impl DefDatabase) -> Module {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         self.with_module_id(def_map.root())\n     }\n \n     /// Finds a child module with the specified name.\n     pub fn child(self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let child_id = def_map[self.id.module_id].children.get(name)?;\n         Some(self.with_module_id(*child_id))\n     }\n \n     /// Iterates over all child modules.\n     pub fn children(self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let children = def_map[self.id.module_id]\n             .children\n             .iter()\n@@ -173,7 +174,7 @@ impl Module {\n \n     /// Finds a parent module.\n     pub fn parent(self, db: &impl DefDatabase) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let parent_id = def_map[self.id.module_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n@@ -189,12 +190,16 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(self, db: &impl HirDatabase) -> ModuleScope {\n-        db.crate_def_map(self.krate())[self.id.module_id].scope.clone()\n+    pub fn scope(self, db: &impl HirDatabase) -> Vec<(Name, ScopeDef, Option<ImportId>)> {\n+        db.crate_def_map(self.id.krate)[self.id.module_id]\n+            .scope\n+            .entries()\n+            .map(|(name, res)| (name.clone(), res.def.into(), res.import))\n+            .collect()\n     }\n \n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n-        db.crate_def_map(self.krate()).add_diagnostics(db, self.id.module_id, sink);\n+        db.crate_def_map(self.id.krate).add_diagnostics(db, self.id.module_id, sink);\n         for decl in self.declarations(db) {\n             match decl {\n                 crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n@@ -218,19 +223,20 @@ impl Module {\n     }\n \n     pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         Resolver::default().push_module_scope(def_map, self.id.module_id)\n     }\n \n     pub fn declarations(self, db: &impl DefDatabase) -> Vec<ModuleDef> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         def_map[self.id.module_id]\n             .scope\n             .entries()\n             .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n             .flat_map(|per_ns| {\n                 per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n             })\n+            .map(ModuleDef::from)\n             .collect()\n     }\n \n@@ -334,12 +340,12 @@ impl Struct {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Union {\n-    pub(crate) id: StructId,\n+    pub(crate) id: UnionId,\n }\n \n impl Union {\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        db.struct_data(self.id).name.clone()\n+        db.union_data(self.id).name.clone()\n     }\n \n     pub fn module(self, db: &impl HirDatabase) -> Module {"}, {"sha": "6d116ee75c908f25391304922e7dd6dfac936ae4", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -10,7 +10,7 @@ use crate::{\n     ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n };\n \n-pub use hir_def::Source;\n+pub use hir_expand::Source;\n \n pub trait HasSource {\n     type Ast;\n@@ -22,7 +22,7 @@ pub trait HasSource {\n impl Module {\n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n     pub fn definition_source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ModuleSource> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let decl_id = def_map[self.id.module_id].declaration;\n         let file_id = def_map[self.id.module_id].definition;\n         let ast = ModuleSource::new(db, file_id, decl_id);\n@@ -36,7 +36,7 @@ impl Module {\n         self,\n         db: &(impl DefDatabase + AstDatabase),\n     ) -> Option<Source<ast::Module>> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let decl = def_map[self.id.module_id].declaration?;\n         let ast = decl.to_node(db);\n         Some(Source { file_id: decl.file_id(), ast })"}, {"sha": "eb66325f7f12624f32ba8650306386125424b0f4", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -11,20 +11,19 @@ use crate::{\n     ids,\n     impl_block::{ImplBlock, ImplSourceMap, ModuleImplBlocks},\n     lang_item::{LangItemTarget, LangItems},\n-    nameres::{CrateDefMap, Namespace},\n     traits::TraitData,\n     ty::{\n         method_resolution::CrateImplBlocks, traits::Impl, CallableDef, FnSig, GenericPredicate,\n         InferenceResult, Substs, Ty, TypableDef, TypeCtor,\n     },\n     type_alias::TypeAliasData,\n-    Const, ConstData, Crate, DefWithBody, ExprScopes, FnData, Function, Module, Static,\n+    Const, ConstData, Crate, DefWithBody, ExprScopes, FnData, Function, Module, Namespace, Static,\n     StructField, Trait, TypeAlias,\n };\n \n pub use hir_def::db::{\n-    DefDatabase2, DefDatabase2Storage, EnumDataQuery, InternDatabase, InternDatabaseStorage,\n-    RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n+    CrateDefMapQuery, DefDatabase2, DefDatabase2Storage, EnumDataQuery, InternDatabase,\n+    InternDatabaseStorage, RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n@@ -41,9 +40,6 @@ pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n     #[salsa::invoke(crate::traits::TraitItemsIndex::trait_items_index)]\n     fn trait_items_index(&self, module: Module) -> crate::traits::TraitItemsIndex;\n \n-    #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n-    fn crate_def_map(&self, krate: Crate) -> Arc<CrateDefMap>;\n-\n     #[salsa::invoke(ModuleImplBlocks::impls_in_module_with_source_map_query)]\n     fn impls_in_module_with_source_map(\n         &self,"}, {"sha": "1751e7be33a28a4a709d462847112bb0625dda9f", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 95, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1,82 +1,13 @@\n //! FIXME: write short doc here\n \n-use std::{any::Any, fmt};\n-\n-use ra_syntax::{ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr, TextRange};\n-use relative_path::RelativePathBuf;\n-\n-use crate::{db::HirDatabase, HirFileId, Name, Source};\n-\n-/// Diagnostic defines hir API for errors and warnings.\n-///\n-/// It is used as a `dyn` object, which you can downcast to a concrete\n-/// diagnostic. DiagnosticSink are structured, meaning that they include rich\n-/// information which can be used by IDE to create fixes. DiagnosticSink are\n-/// expressed in terms of macro-expanded syntax tree nodes (so, it's a bad idea\n-/// to diagnostic in a salsa value).\n-///\n-/// Internally, various subsystems of hir produce diagnostics specific to a\n-/// subsystem (typically, an `enum`), which are safe to store in salsa but do not\n-/// include source locations. Such internal diagnostic are transformed into an\n-/// instance of `Diagnostic` on demand.\n-pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n-    fn message(&self) -> String;\n-    fn source(&self) -> Source<SyntaxNodePtr>;\n-    fn highlight_range(&self) -> TextRange {\n-        self.source().ast.range()\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static);\n-}\n-\n-pub trait AstDiagnostic {\n-    type AST;\n-    fn ast(&self, db: &impl HirDatabase) -> Self::AST;\n-}\n+use std::any::Any;\n \n-impl dyn Diagnostic {\n-    pub fn syntax_node(&self, db: &impl HirDatabase) -> SyntaxNode {\n-        let node = db.parse_or_expand(self.source().file_id).unwrap();\n-        self.source().ast.to_node(&node)\n-    }\n+use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n \n-    pub fn downcast_ref<D: Diagnostic>(&self) -> Option<&D> {\n-        self.as_any().downcast_ref()\n-    }\n-}\n+use crate::{db::AstDatabase, HirFileId, Name, Source};\n \n-pub struct DiagnosticSink<'a> {\n-    callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n-    default_callback: Box<dyn FnMut(&dyn Diagnostic) + 'a>,\n-}\n-\n-impl<'a> DiagnosticSink<'a> {\n-    pub fn new(cb: impl FnMut(&dyn Diagnostic) + 'a) -> DiagnosticSink<'a> {\n-        DiagnosticSink { callbacks: Vec::new(), default_callback: Box::new(cb) }\n-    }\n-\n-    pub fn on<D: Diagnostic, F: FnMut(&D) + 'a>(mut self, mut cb: F) -> DiagnosticSink<'a> {\n-        let cb = move |diag: &dyn Diagnostic| match diag.downcast_ref::<D>() {\n-            Some(d) => {\n-                cb(d);\n-                Ok(())\n-            }\n-            None => Err(()),\n-        };\n-        self.callbacks.push(Box::new(cb));\n-        self\n-    }\n-\n-    pub(crate) fn push(&mut self, d: impl Diagnostic) {\n-        let d: &dyn Diagnostic = &d;\n-        for cb in self.callbacks.iter_mut() {\n-            match cb(d) {\n-                Ok(()) => return,\n-                Err(()) => (),\n-            }\n-        }\n-        (self.default_callback)(d)\n-    }\n-}\n+pub use hir_def::diagnostics::UnresolvedModule;\n+pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n \n #[derive(Debug)]\n pub struct NoSuchField {\n@@ -98,25 +29,6 @@ impl Diagnostic for NoSuchField {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct UnresolvedModule {\n-    pub file: HirFileId,\n-    pub decl: AstPtr<ast::Module>,\n-    pub candidate: RelativePathBuf,\n-}\n-\n-impl Diagnostic for UnresolvedModule {\n-    fn message(&self) -> String {\n-        \"unresolved module\".to_string()\n-    }\n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, ast: self.decl.into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MissingFields {\n     pub file: HirFileId,\n@@ -139,7 +51,7 @@ impl Diagnostic for MissingFields {\n impl AstDiagnostic for MissingFields {\n     type AST = ast::RecordFieldList;\n \n-    fn ast(&self, db: &impl HirDatabase) -> Self::AST {\n+    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.source().file_id).unwrap();\n         let node = self.source().ast.to_node(&root);\n         ast::RecordFieldList::cast(node).unwrap()\n@@ -167,7 +79,7 @@ impl Diagnostic for MissingOkInTailExpr {\n impl AstDiagnostic for MissingOkInTailExpr {\n     type AST = ast::Expr;\n \n-    fn ast(&self, db: &impl HirDatabase) -> Self::AST {\n+    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.file).unwrap();\n         let node = self.source().ast.to_node(&root);\n         ast::Expr::cast(node).unwrap()"}, {"sha": "3054f1dcedf405270db5e98109734d55d5666e31", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -3,12 +3,13 @@\n use std::sync::Arc;\n \n use hir_def::path::known;\n+use hir_expand::diagnostics::DiagnosticSink;\n use ra_syntax::ast;\n use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n-    diagnostics::{DiagnosticSink, MissingFields, MissingOkInTailExpr},\n+    diagnostics::{MissingFields, MissingOkInTailExpr},\n     expr::AstPtr,\n     ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n     Adt, Function, Name, Path,"}, {"sha": "089dbc9084a454f09248d3f229e1366099f95a85", "filename": "crates/ra_hir/src/from_id.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -0,0 +1,63 @@\n+//! Utility module for converting between hir_def ids and code_model wrappers.\n+//!\n+//! It's unclear if we need this long-term, but it's definitelly useful while we\n+//! are splitting the hir.\n+\n+use hir_def::{AdtId, EnumVariantId, ModuleDefId};\n+\n+use crate::{Adt, EnumVariant, ModuleDef};\n+\n+macro_rules! from_id {\n+    ($(($id:path, $ty:path)),*) => {$(\n+        impl From<$id> for $ty {\n+            fn from(id: $id) -> $ty {\n+                $ty { id }\n+            }\n+        }\n+    )*}\n+}\n+\n+from_id![\n+    (hir_def::ModuleId, crate::Module),\n+    (hir_def::StructId, crate::Struct),\n+    (hir_def::UnionId, crate::Union),\n+    (hir_def::EnumId, crate::Enum),\n+    (hir_def::TypeAliasId, crate::TypeAlias),\n+    (hir_def::TraitId, crate::Trait),\n+    (hir_def::StaticId, crate::Static),\n+    (hir_def::ConstId, crate::Const),\n+    (hir_def::FunctionId, crate::Function),\n+    (hir_expand::MacroDefId, crate::MacroDef)\n+];\n+\n+impl From<AdtId> for Adt {\n+    fn from(id: AdtId) -> Self {\n+        match id {\n+            AdtId::StructId(it) => Adt::Struct(it.into()),\n+            AdtId::UnionId(it) => Adt::Union(it.into()),\n+            AdtId::EnumId(it) => Adt::Enum(it.into()),\n+        }\n+    }\n+}\n+\n+impl From<EnumVariantId> for EnumVariant {\n+    fn from(id: EnumVariantId) -> Self {\n+        EnumVariant { parent: id.parent.into(), id: id.local_id }\n+    }\n+}\n+\n+impl From<ModuleDefId> for ModuleDef {\n+    fn from(id: ModuleDefId) -> Self {\n+        match id {\n+            ModuleDefId::ModuleId(it) => ModuleDef::Module(it.into()),\n+            ModuleDefId::FunctionId(it) => ModuleDef::Function(it.into()),\n+            ModuleDefId::AdtId(it) => ModuleDef::Adt(it.into()),\n+            ModuleDefId::EnumVariantId(it) => ModuleDef::EnumVariant(it.into()),\n+            ModuleDefId::ConstId(it) => ModuleDef::Const(it.into()),\n+            ModuleDefId::StaticId(it) => ModuleDef::Static(it.into()),\n+            ModuleDefId::TraitId(it) => ModuleDef::Trait(it.into()),\n+            ModuleDefId::TypeAliasId(it) => ModuleDef::TypeAlias(it.into()),\n+            ModuleDefId::BuiltinType(it) => ModuleDef::BuiltinType(it),\n+        }\n+    }\n+}"}, {"sha": "9899bdbbce26af5ccc65ccacfcc3691cef3dd639", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -149,14 +149,20 @@ impl Module {\n             ModuleSource::SourceFile(_) => None,\n         };\n \n-        db.relevant_crates(src.file_id.original_file(db))\n-            .iter()\n-            .map(|&crate_id| Crate { crate_id })\n-            .find_map(|krate| {\n-                let def_map = db.crate_def_map(krate);\n-                let module_id = def_map.find_module_by_source(src.file_id, decl_id)?;\n-                Some(Module::new(krate, module_id))\n-            })\n+        db.relevant_crates(src.file_id.original_file(db)).iter().find_map(|&crate_id| {\n+            let def_map = db.crate_def_map(crate_id);\n+\n+            let (module_id, _module_data) =\n+                def_map.modules.iter().find(|(_module_id, module_data)| {\n+                    if decl_id.is_some() {\n+                        module_data.declaration == decl_id\n+                    } else {\n+                        module_data.definition.map(|it| it.into()) == Some(src.file_id)\n+                    }\n+                })?;\n+\n+            Some(Module::new(Crate { crate_id }, module_id))\n+        })\n     }\n }\n "}, {"sha": "3ba99d92d70313671925d31696b150e9bd90dd7d", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -34,7 +34,6 @@ pub mod mock;\n pub mod source_binder;\n \n mod ids;\n-mod nameres;\n mod adt;\n mod traits;\n mod type_alias;\n@@ -47,6 +46,7 @@ mod resolve;\n pub mod diagnostics;\n mod util;\n \n+mod from_id;\n mod code_model;\n \n pub mod from_source;\n@@ -62,7 +62,7 @@ pub use crate::{\n     adt::VariantDef,\n     code_model::{\n         docs::{DocDef, Docs, Documentation},\n-        src::{HasBodySource, HasSource, Source},\n+        src::{HasBodySource, HasSource},\n         Adt, AssocItem, Const, ConstData, Container, Crate, CrateDependency, DefWithBody, Enum,\n         EnumVariant, FieldSource, FnData, Function, HasBody, MacroDef, Module, ModuleDef,\n         ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n@@ -72,7 +72,6 @@ pub use crate::{\n     generics::{GenericDef, GenericParam, GenericParams, HasGenericParams},\n     ids::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile},\n     impl_block::ImplBlock,\n-    nameres::{ImportId, Namespace, PerNs},\n     resolve::ScopeDef,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     ty::{\n@@ -82,7 +81,11 @@ pub use crate::{\n \n pub use hir_def::{\n     builtin_type::BuiltinType,\n+    nameres::{\n+        per_ns::{Namespace, PerNs},\n+        raw::ImportId,\n+    },\n     path::{Path, PathKind},\n     type_ref::Mutability,\n };\n-pub use hir_expand::{either::Either, name::Name};\n+pub use hir_expand::{either::Either, name::Name, Source};"}, {"sha": "0d4fa5b67363cdbdeda636b0e7900e3444c7b389", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1,21 +1,10 @@\n //! See test_utils/src/marks.rs\n \n test_utils::marks!(\n-    bogus_paths\n-    // FIXME: restore this mark once hir is split\n-    name_res_works_for_broken_modules\n-    can_import_enum_variant\n     type_var_cycles_resolve_completely\n     type_var_cycles_resolve_as_possible\n     type_var_resolves_to_int_var\n-    glob_enum\n-    glob_across_crates\n-    std_prelude\n     match_ergonomics_ref\n     infer_while_let\n-    macro_rules_from_other_crates_are_visible_with_macro_use\n-    prelude_is_macro_use\n     coerce_merge_fail_fallback\n-    macro_dollar_crate_self\n-    macro_dollar_crate_other\n );"}, {"sha": "ab97a09b9114c7b901507d0520b9abf15d74f8a2", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 3, "deletions": 71, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -2,17 +2,17 @@\n \n use std::{panic, sync::Arc};\n \n+use hir_expand::diagnostics::DiagnosticSink;\n use parking_lot::Mutex;\n use ra_cfg::CfgOptions;\n use ra_db::{\n     salsa, CrateGraph, CrateId, Edition, FileId, FileLoader, FileLoaderDelegate, FilePosition,\n-    SourceDatabase, SourceDatabaseExt, SourceRoot, SourceRootId,\n+    RelativePath, RelativePathBuf, SourceDatabase, SourceDatabaseExt, SourceRoot, SourceRootId,\n };\n-use relative_path::{RelativePath, RelativePathBuf};\n use rustc_hash::FxHashMap;\n use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n \n-use crate::{db, debug::HirDebugHelper, diagnostics::DiagnosticSink};\n+use crate::{db, debug::HirDebugHelper};\n \n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n \n@@ -77,38 +77,13 @@ impl MockDatabase {\n         (db, source_root, file_id)\n     }\n \n-    pub fn with_position(fixture: &str) -> (MockDatabase, FilePosition) {\n-        let (db, position) = MockDatabase::from_fixture(fixture);\n-        let position = position.expect(\"expected a marker ( <|> )\");\n-        (db, position)\n-    }\n-\n     pub fn file_id_of(&self, path: &str) -> FileId {\n         match self.files.get(path) {\n             Some(it) => *it,\n             None => panic!(\"unknown file: {:?}\\nexisting files:\\n{:#?}\", path, self.files),\n         }\n     }\n \n-    pub fn set_crate_graph_from_fixture(&mut self, graph: CrateGraphFixture) {\n-        let mut ids = FxHashMap::default();\n-        let mut crate_graph = CrateGraph::default();\n-        for (crate_name, (crate_root, edition, cfg_options, _)) in graph.0.iter() {\n-            let crate_root = self.file_id_of(&crate_root);\n-            let crate_id = crate_graph.add_crate_root(crate_root, *edition, cfg_options.clone());\n-            Arc::make_mut(&mut self.crate_names).insert(crate_id, crate_name.clone());\n-            ids.insert(crate_name, crate_id);\n-        }\n-        for (crate_name, (_, _, _, deps)) in graph.0.iter() {\n-            let from = ids[crate_name];\n-            for dep in deps {\n-                let to = ids[dep];\n-                crate_graph.add_dep(from, dep.as_str().into(), to).unwrap();\n-            }\n-        }\n-        self.set_crate_graph(Arc::new(crate_graph))\n-    }\n-\n     pub fn diagnostics(&self) -> String {\n         let mut buf = String::new();\n         let mut files: Vec<FileId> = self.files.values().copied().collect();\n@@ -285,46 +260,3 @@ impl MockDatabase {\n             .collect()\n     }\n }\n-\n-#[derive(Default)]\n-pub struct CrateGraphFixture(pub Vec<(String, (String, Edition, CfgOptions, Vec<String>))>);\n-\n-#[macro_export]\n-macro_rules! crate_graph {\n-    ($(\n-        $crate_name:literal: (\n-            $crate_path:literal,\n-            $($edition:literal,)?\n-            [$($dep:literal),*]\n-            $(, cfg = {\n-                $($key:literal $(= $value:literal)?),*\n-                $(,)?\n-            })?\n-        ),\n-    )*) => {{\n-        let mut res = $crate::mock::CrateGraphFixture::default();\n-        $(\n-            #[allow(unused_mut, unused_assignments)]\n-            let mut edition = ra_db::Edition::Edition2018;\n-            $(edition = ra_db::Edition::from_string($edition);)?\n-            let cfg_options = {\n-                #[allow(unused_mut)]\n-                let mut cfg = ::ra_cfg::CfgOptions::default();\n-                $(\n-                    $(\n-                        if 0 == 0 $(+ { drop($value); 1})? {\n-                            cfg.insert_atom($key.into());\n-                        }\n-                        $(cfg.insert_key_value($key.into(), $value.into());)?\n-                    )*\n-                )?\n-                cfg\n-            };\n-            res.0.push((\n-                $crate_name.to_string(),\n-                ($crate_path.to_string(), edition, cfg_options, vec![$($dep.to_string()),*])\n-            ));\n-        )*\n-        res\n-    }}\n-}"}, {"sha": "7ba03182718cee0d579c3aa75844e330514c9215", "filename": "crates/ra_hir/src/nameres.rs", "status": "removed", "additions": 0, "deletions": 557, "changes": 557, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -1,557 +0,0 @@\n-//! This module implements import-resolution/macro expansion algorithm.\n-//!\n-//! The result of this module is `CrateDefMap`: a data structure which contains:\n-//!\n-//!   * a tree of modules for the crate\n-//!   * for each module, a set of items visible in the module (directly declared\n-//!     or imported)\n-//!\n-//! Note that `CrateDefMap` contains fully macro expanded code.\n-//!\n-//! Computing `CrateDefMap` can be partitioned into several logically\n-//! independent \"phases\". The phases are mutually recursive though, there's no\n-//! strict ordering.\n-//!\n-//! ## Collecting RawItems\n-//!\n-//!  This happens in the `raw` module, which parses a single source file into a\n-//!  set of top-level items. Nested imports are desugared to flat imports in\n-//!  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n-//!  TokenTree).\n-//!\n-//! ## Collecting Modules\n-//!\n-//! This happens in the `collector` module. In this phase, we recursively walk\n-//! tree of modules, collect raw items from submodules, populate module scopes\n-//! with defined items (so, we assign item ids in this phase) and record the set\n-//! of unresolved imports and macros.\n-//!\n-//! While we walk tree of modules, we also record macro_rules definitions and\n-//! expand calls to macro_rules defined macros.\n-//!\n-//! ## Resolving Imports\n-//!\n-//! We maintain a list of currently unresolved imports. On every iteration, we\n-//! try to resolve some imports from this list. If the import is resolved, we\n-//! record it, by adding an item to current module scope and, if necessary, by\n-//! recursively populating glob imports.\n-//!\n-//! ## Resolving Macros\n-//!\n-//! macro_rules from the same crate use a global mutable namespace. We expand\n-//! them immediately, when we collect modules.\n-//!\n-//! Macros from other crates (including proc-macros) can be used with\n-//! `foo::bar!` syntax. We handle them similarly to imports. There's a list of\n-//! unexpanded macros. On every iteration, we try to resolve each macro call\n-//! path and, upon success, we run macro expansion and \"collect module\" phase\n-//! on the result\n-\n-mod per_ns;\n-mod collector;\n-#[cfg(test)]\n-mod tests;\n-\n-use std::sync::Arc;\n-\n-use hir_def::{builtin_type::BuiltinType, CrateModuleId};\n-use once_cell::sync::Lazy;\n-use ra_arena::Arena;\n-use ra_db::{Edition, FileId};\n-use ra_prof::profile;\n-use ra_syntax::ast;\n-use rustc_hash::{FxHashMap, FxHashSet};\n-use test_utils::tested_by;\n-\n-use crate::{\n-    db::{AstDatabase, DefDatabase},\n-    diagnostics::DiagnosticSink,\n-    ids::MacroDefId,\n-    nameres::diagnostics::DefDiagnostic,\n-    Adt, AstId, Crate, HirFileId, MacroDef, Module, ModuleDef, Name, Path, PathKind, Trait,\n-};\n-\n-pub use self::per_ns::{Namespace, PerNs};\n-\n-pub use hir_def::nameres::raw::ImportId;\n-\n-/// Contains all top-level defs from a macro-expanded crate\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct CrateDefMap {\n-    krate: Crate,\n-    edition: Edition,\n-    /// The prelude module for this crate. This either comes from an import\n-    /// marked with the `prelude_import` attribute, or (in the normal case) from\n-    /// a dependency (`std` or `core`).\n-    prelude: Option<Module>,\n-    extern_prelude: FxHashMap<Name, ModuleDef>,\n-    root: CrateModuleId,\n-    modules: Arena<CrateModuleId, ModuleData>,\n-\n-    /// Some macros are not well-behavior, which leads to infinite loop\n-    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n-    /// We mark it down and skip it in collector\n-    ///\n-    /// FIXME:\n-    /// Right now it only handle a poison macro in a single crate,\n-    /// such that if other crate try to call that macro,\n-    /// the whole process will do again until it became poisoned in that crate.\n-    /// We should handle this macro set globally\n-    /// However, do we want to put it as a global variable?\n-    poison_macros: FxHashSet<MacroDefId>,\n-\n-    diagnostics: Vec<DefDiagnostic>,\n-}\n-\n-impl std::ops::Index<CrateModuleId> for CrateDefMap {\n-    type Output = ModuleData;\n-    fn index(&self, id: CrateModuleId) -> &ModuleData {\n-        &self.modules[id]\n-    }\n-}\n-\n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub struct ModuleData {\n-    pub(crate) parent: Option<CrateModuleId>,\n-    pub(crate) children: FxHashMap<Name, CrateModuleId>,\n-    pub(crate) scope: ModuleScope,\n-    /// None for root\n-    pub(crate) declaration: Option<AstId<ast::Module>>,\n-    /// None for inline modules.\n-    ///\n-    /// Note that non-inline modules, by definition, live inside non-macro file.\n-    pub(crate) definition: Option<FileId>,\n-}\n-\n-#[derive(Debug, Default, PartialEq, Eq, Clone)]\n-pub struct ModuleScope {\n-    items: FxHashMap<Name, Resolution>,\n-    /// Macros visable in current module in legacy textual scope\n-    ///\n-    /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first.\n-    /// If it yields no result, then it turns to module scoped `macros`.\n-    /// It macros with name quatified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n-    /// and only normal scoped `macros` will be searched in.\n-    ///\n-    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n-    ///\n-    /// Module scoped macros will be inserted into `items` instead of here.\n-    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n-    // be all resolved to the last one defined if shadowing happens.\n-    legacy_macros: FxHashMap<Name, MacroDef>,\n-}\n-\n-static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n-    BuiltinType::ALL\n-        .iter()\n-        .map(|(name, ty)| {\n-            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: None })\n-        })\n-        .collect()\n-});\n-\n-/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n-/// Other methods will only resolve values, types and module scoped macros only.\n-impl ModuleScope {\n-    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n-        //FIXME: shadowing\n-        self.items.iter().chain(BUILTIN_SCOPE.iter())\n-    }\n-\n-    /// Iterate over all module scoped macros\n-    pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDef)> + 'a {\n-        self.items\n-            .iter()\n-            .filter_map(|(name, res)| res.def.get_macros().map(|macro_| (name, macro_)))\n-    }\n-\n-    /// Iterate over all legacy textual scoped macros visable at the end of the module\n-    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDef)> + 'a {\n-        self.legacy_macros.iter().map(|(name, def)| (name, *def))\n-    }\n-\n-    /// Get a name from current module scope, legacy macros are not included\n-    pub fn get(&self, name: &Name) -> Option<&Resolution> {\n-        self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name))\n-    }\n-\n-    pub fn traits<'a>(&'a self) -> impl Iterator<Item = Trait> + 'a {\n-        self.items.values().filter_map(|r| match r.def.take_types() {\n-            Some(ModuleDef::Trait(t)) => Some(t),\n-            _ => None,\n-        })\n-    }\n-\n-    fn get_legacy_macro(&self, name: &Name) -> Option<MacroDef> {\n-        self.legacy_macros.get(name).copied()\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Default)]\n-pub struct Resolution {\n-    /// None for unresolved\n-    pub def: PerNs,\n-    /// ident by which this is imported into local scope.\n-    pub import: Option<ImportId>,\n-}\n-\n-impl Resolution {\n-    pub(crate) fn from_macro(macro_: MacroDef) -> Self {\n-        Resolution { def: PerNs::macros(macro_), import: None }\n-    }\n-}\n-\n-#[derive(Debug, Clone)]\n-struct ResolvePathResult {\n-    resolved_def: PerNs,\n-    segment_index: Option<usize>,\n-    reached_fixedpoint: ReachedFixedPoint,\n-}\n-\n-impl ResolvePathResult {\n-    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n-        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n-    }\n-\n-    fn with(\n-        resolved_def: PerNs,\n-        reached_fixedpoint: ReachedFixedPoint,\n-        segment_index: Option<usize>,\n-    ) -> ResolvePathResult {\n-        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum ResolveMode {\n-    Import,\n-    Other,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum ReachedFixedPoint {\n-    Yes,\n-    No,\n-}\n-\n-impl CrateDefMap {\n-    pub(crate) fn crate_def_map_query(\n-        // Note that this doesn't have `+ AstDatabase`!\n-        // This gurantess that `CrateDefMap` is stable across reparses.\n-        db: &impl DefDatabase,\n-        krate: Crate,\n-    ) -> Arc<CrateDefMap> {\n-        let _p = profile(\"crate_def_map_query\");\n-        let def_map = {\n-            let edition = krate.edition(db);\n-            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n-            let root = modules.alloc(ModuleData::default());\n-            CrateDefMap {\n-                krate,\n-                edition,\n-                extern_prelude: FxHashMap::default(),\n-                prelude: None,\n-                root,\n-                modules,\n-                poison_macros: FxHashSet::default(),\n-                diagnostics: Vec::new(),\n-            }\n-        };\n-        let def_map = collector::collect_defs(db, def_map);\n-        Arc::new(def_map)\n-    }\n-\n-    pub(crate) fn krate(&self) -> Crate {\n-        self.krate\n-    }\n-\n-    pub(crate) fn root(&self) -> CrateModuleId {\n-        self.root\n-    }\n-\n-    pub(crate) fn prelude(&self) -> Option<Module> {\n-        self.prelude\n-    }\n-\n-    pub(crate) fn extern_prelude(&self) -> &FxHashMap<Name, ModuleDef> {\n-        &self.extern_prelude\n-    }\n-\n-    pub(crate) fn add_diagnostics(\n-        &self,\n-        db: &(impl DefDatabase + AstDatabase),\n-        module: CrateModuleId,\n-        sink: &mut DiagnosticSink,\n-    ) {\n-        self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n-    }\n-\n-    pub(crate) fn find_module_by_source(\n-        &self,\n-        file_id: HirFileId,\n-        decl_id: Option<AstId<ast::Module>>,\n-    ) -> Option<CrateModuleId> {\n-        let (module_id, _module_data) = self.modules.iter().find(|(_module_id, module_data)| {\n-            if decl_id.is_some() {\n-                module_data.declaration == decl_id\n-            } else {\n-                module_data.definition.map(|it| it.into()) == Some(file_id)\n-            }\n-        })?;\n-        Some(module_id)\n-    }\n-\n-    pub(crate) fn resolve_path(\n-        &self,\n-        db: &impl DefDatabase,\n-        original_module: CrateModuleId,\n-        path: &Path,\n-    ) -> (PerNs, Option<usize>) {\n-        let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n-        (res.resolved_def, res.segment_index)\n-    }\n-\n-    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n-    // the result.\n-    fn resolve_path_fp_with_macro(\n-        &self,\n-        db: &impl DefDatabase,\n-        mode: ResolveMode,\n-        original_module: CrateModuleId,\n-        path: &Path,\n-    ) -> ResolvePathResult {\n-        let mut segments = path.segments.iter().enumerate();\n-        let mut curr_per_ns: PerNs = match path.kind {\n-            PathKind::DollarCrate(crate_id) => {\n-                let krate = Crate { crate_id };\n-                if krate == self.krate {\n-                    tested_by!(macro_dollar_crate_self);\n-                    PerNs::types(Module::new(self.krate, self.root).into())\n-                } else {\n-                    match krate.root_module(db) {\n-                        Some(module) => {\n-                            tested_by!(macro_dollar_crate_other);\n-                            PerNs::types(module.into())\n-                        }\n-                        None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                    }\n-                }\n-            }\n-            PathKind::Crate => PerNs::types(Module::new(self.krate, self.root).into()),\n-            PathKind::Self_ => PerNs::types(Module::new(self.krate, original_module).into()),\n-            // plain import or absolute path in 2015: crate-relative with\n-            // fallback to extern prelude (with the simplification in\n-            // rust-lang/rust#57745)\n-            // FIXME there must be a nicer way to write this condition\n-            PathKind::Plain | PathKind::Abs\n-                if self.edition == Edition::Edition2015\n-                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n-            {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n-                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n-            }\n-            PathKind::Plain => {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, &segment.name)\n-            }\n-            PathKind::Super => {\n-                if let Some(p) = self.modules[original_module].parent {\n-                    PerNs::types(Module::new(self.krate, p).into())\n-                } else {\n-                    log::debug!(\"super path in root module\");\n-                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-                }\n-            }\n-            PathKind::Abs => {\n-                // 2018-style absolute path -- only extern prelude\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                if let Some(def) = self.extern_prelude.get(&segment.name) {\n-                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    PerNs::types(*def)\n-                } else {\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n-                }\n-            }\n-            PathKind::Type(_) => {\n-                // This is handled in `infer::infer_path_expr`\n-                // The result returned here does not matter\n-                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-            }\n-        };\n-\n-        for (i, segment) in segments {\n-            let curr = match curr_per_ns.take_types() {\n-                Some(r) => r,\n-                None => {\n-                    // we still have path segments left, but the path so far\n-                    // didn't resolve in the types namespace => no resolution\n-                    // (don't break here because `curr_per_ns` might contain\n-                    // something in the value namespace, and it would be wrong\n-                    // to return that)\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                }\n-            };\n-            // resolve segment in curr\n-\n-            curr_per_ns = match curr {\n-                ModuleDef::Module(module) => {\n-                    if module.krate() != self.krate {\n-                        let path =\n-                            Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n-                        log::debug!(\"resolving {:?} in other crate\", path);\n-                        let defp_map = db.crate_def_map(module.krate());\n-                        let (def, s) = defp_map.resolve_path(db, module.id.module_id, &path);\n-                        return ResolvePathResult::with(\n-                            def,\n-                            ReachedFixedPoint::Yes,\n-                            s.map(|s| s + i),\n-                        );\n-                    }\n-\n-                    // Since it is a qualified path here, it should not contains legacy macros\n-                    match self[module.id.module_id].scope.get(&segment.name) {\n-                        Some(res) => res.def,\n-                        _ => {\n-                            log::debug!(\"path segment {:?} not found\", segment.name);\n-                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                        }\n-                    }\n-                }\n-                ModuleDef::Adt(Adt::Enum(e)) => {\n-                    // enum variant\n-                    tested_by!(can_import_enum_variant);\n-                    match e.variant(db, &segment.name) {\n-                        Some(variant) => PerNs::both(variant.into(), variant.into()),\n-                        None => {\n-                            return ResolvePathResult::with(\n-                                PerNs::types(e.into()),\n-                                ReachedFixedPoint::Yes,\n-                                Some(i),\n-                            );\n-                        }\n-                    }\n-                }\n-                s => {\n-                    // could be an inherent method call in UFCS form\n-                    // (`Struct::method`), or some other kind of associated item\n-                    log::debug!(\n-                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                        segment.name,\n-                        curr,\n-                    );\n-\n-                    return ResolvePathResult::with(\n-                        PerNs::types(s),\n-                        ReachedFixedPoint::Yes,\n-                        Some(i),\n-                    );\n-                }\n-            };\n-        }\n-        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n-    }\n-\n-    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs {\n-        let from_crate_root =\n-            self[self.root].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n-        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n-\n-        from_crate_root.or(from_extern_prelude)\n-    }\n-\n-    pub(crate) fn resolve_name_in_module(\n-        &self,\n-        db: &impl DefDatabase,\n-        module: CrateModuleId,\n-        name: &Name,\n-    ) -> PerNs {\n-        // Resolve in:\n-        //  - legacy scope of macro\n-        //  - current module / scope\n-        //  - extern prelude\n-        //  - std prelude\n-        let from_legacy_macro =\n-            self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n-        let from_scope = self[module].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n-        let from_extern_prelude =\n-            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n-        let from_prelude = self.resolve_in_prelude(db, name);\n-\n-        from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n-    }\n-\n-    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n-        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n-    }\n-\n-    fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs {\n-        if let Some(prelude) = self.prelude {\n-            let keep;\n-            let def_map = if prelude.krate() == self.krate {\n-                self\n-            } else {\n-                // Extend lifetime\n-                keep = db.crate_def_map(prelude.krate());\n-                &keep\n-            };\n-            def_map[prelude.id.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n-        } else {\n-            PerNs::none()\n-        }\n-    }\n-}\n-\n-mod diagnostics {\n-    use ra_syntax::{ast, AstPtr};\n-    use relative_path::RelativePathBuf;\n-\n-    use crate::{\n-        db::{AstDatabase, DefDatabase},\n-        diagnostics::{DiagnosticSink, UnresolvedModule},\n-        nameres::CrateModuleId,\n-        AstId,\n-    };\n-\n-    #[derive(Debug, PartialEq, Eq)]\n-    pub(super) enum DefDiagnostic {\n-        UnresolvedModule {\n-            module: CrateModuleId,\n-            declaration: AstId<ast::Module>,\n-            candidate: RelativePathBuf,\n-        },\n-    }\n-\n-    impl DefDiagnostic {\n-        pub(super) fn add_to(\n-            &self,\n-            db: &(impl DefDatabase + AstDatabase),\n-            target_module: CrateModuleId,\n-            sink: &mut DiagnosticSink,\n-        ) {\n-            match self {\n-                DefDiagnostic::UnresolvedModule { module, declaration, candidate } => {\n-                    if *module != target_module {\n-                        return;\n-                    }\n-                    let decl = declaration.to_node(db);\n-                    sink.push(UnresolvedModule {\n-                        file: declaration.file_id(),\n-                        decl: AstPtr::new(&decl),\n-                        candidate: candidate.clone(),\n-                    })\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "b932b0c8cdbca0000a12172da3c3cb978fe9995c", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 57, "deletions": 53, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -3,8 +3,9 @@ use std::sync::Arc;\n \n use hir_def::{\n     builtin_type::BuiltinType,\n+    nameres::CrateDefMap,\n     path::{Path, PathKind},\n-    CrateModuleId,\n+    AdtId, CrateModuleId, ModuleDefId,\n };\n use hir_expand::name::{self, Name};\n use rustc_hash::FxHashSet;\n@@ -18,8 +19,8 @@ use crate::{\n     },\n     generics::GenericParams,\n     impl_block::ImplBlock,\n-    nameres::{CrateDefMap, PerNs},\n-    Adt, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, Static, Struct, Trait, TypeAlias,\n+    Adt, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, PerNs, Static, Struct, Trait,\n+    TypeAlias,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -90,7 +91,7 @@ impl Resolver {\n     pub(crate) fn resolve_known_trait(&self, db: &impl HirDatabase, path: &Path) -> Option<Trait> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDef::Trait(it) => Some(it),\n+            ModuleDefId::TraitId(it) => Some(it.into()),\n             _ => None,\n         }\n     }\n@@ -103,7 +104,7 @@ impl Resolver {\n     ) -> Option<Struct> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDef::Adt(Adt::Struct(it)) => Some(it),\n+            ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it.into()),\n             _ => None,\n         }\n     }\n@@ -112,7 +113,7 @@ impl Resolver {\n     pub(crate) fn resolve_known_enum(&self, db: &impl HirDatabase, path: &Path) -> Option<Enum> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDef::Adt(Adt::Enum(it)) => Some(it),\n+            ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it.into()),\n             _ => None,\n         }\n     }\n@@ -166,18 +167,18 @@ impl Resolver {\n                 Scope::ModuleScope(m) => {\n                     let (module_def, idx) = m.crate_def_map.resolve_path(db, m.module_id, path);\n                     let res = match module_def.take_types()? {\n-                        ModuleDef::Adt(it) => TypeNs::Adt(it),\n-                        ModuleDef::EnumVariant(it) => TypeNs::EnumVariant(it),\n+                        ModuleDefId::AdtId(it) => TypeNs::Adt(it.into()),\n+                        ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariant(it.into()),\n \n-                        ModuleDef::TypeAlias(it) => TypeNs::TypeAlias(it),\n-                        ModuleDef::BuiltinType(it) => TypeNs::BuiltinType(it),\n+                        ModuleDefId::TypeAliasId(it) => TypeNs::TypeAlias(it.into()),\n+                        ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n \n-                        ModuleDef::Trait(it) => TypeNs::Trait(it),\n+                        ModuleDefId::TraitId(it) => TypeNs::Trait(it.into()),\n \n-                        ModuleDef::Function(_)\n-                        | ModuleDef::Const(_)\n-                        | ModuleDef::Static(_)\n-                        | ModuleDef::Module(_) => return None,\n+                        ModuleDefId::FunctionId(_)\n+                        | ModuleDefId::ConstId(_)\n+                        | ModuleDefId::StaticId(_)\n+                        | ModuleDefId::ModuleId(_) => return None,\n                     };\n                     return Some((res, idx));\n                 }\n@@ -261,33 +262,35 @@ impl Resolver {\n                     return match idx {\n                         None => {\n                             let value = match module_def.take_values()? {\n-                                ModuleDef::Function(it) => ValueNs::Function(it),\n-                                ModuleDef::Adt(Adt::Struct(it)) => ValueNs::Struct(it),\n-                                ModuleDef::EnumVariant(it) => ValueNs::EnumVariant(it),\n-                                ModuleDef::Const(it) => ValueNs::Const(it),\n-                                ModuleDef::Static(it) => ValueNs::Static(it),\n-\n-                                ModuleDef::Adt(Adt::Enum(_))\n-                                | ModuleDef::Adt(Adt::Union(_))\n-                                | ModuleDef::Trait(_)\n-                                | ModuleDef::TypeAlias(_)\n-                                | ModuleDef::BuiltinType(_)\n-                                | ModuleDef::Module(_) => return None,\n+                                ModuleDefId::FunctionId(it) => ValueNs::Function(it.into()),\n+                                ModuleDefId::AdtId(AdtId::StructId(it)) => {\n+                                    ValueNs::Struct(it.into())\n+                                }\n+                                ModuleDefId::EnumVariantId(it) => ValueNs::EnumVariant(it.into()),\n+                                ModuleDefId::ConstId(it) => ValueNs::Const(it.into()),\n+                                ModuleDefId::StaticId(it) => ValueNs::Static(it.into()),\n+\n+                                ModuleDefId::AdtId(AdtId::EnumId(_))\n+                                | ModuleDefId::AdtId(AdtId::UnionId(_))\n+                                | ModuleDefId::TraitId(_)\n+                                | ModuleDefId::TypeAliasId(_)\n+                                | ModuleDefId::BuiltinType(_)\n+                                | ModuleDefId::ModuleId(_) => return None,\n                             };\n                             Some(ResolveValueResult::ValueNs(value))\n                         }\n                         Some(idx) => {\n                             let ty = match module_def.take_types()? {\n-                                ModuleDef::Adt(it) => TypeNs::Adt(it),\n-                                ModuleDef::Trait(it) => TypeNs::Trait(it),\n-                                ModuleDef::TypeAlias(it) => TypeNs::TypeAlias(it),\n-                                ModuleDef::BuiltinType(it) => TypeNs::BuiltinType(it),\n-\n-                                ModuleDef::Module(_)\n-                                | ModuleDef::Function(_)\n-                                | ModuleDef::EnumVariant(_)\n-                                | ModuleDef::Const(_)\n-                                | ModuleDef::Static(_) => return None,\n+                                ModuleDefId::AdtId(it) => TypeNs::Adt(it.into()),\n+                                ModuleDefId::TraitId(it) => TypeNs::Trait(it.into()),\n+                                ModuleDefId::TypeAliasId(it) => TypeNs::TypeAlias(it.into()),\n+                                ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n+\n+                                ModuleDefId::ModuleId(_)\n+                                | ModuleDefId::FunctionId(_)\n+                                | ModuleDefId::EnumVariantId(_)\n+                                | ModuleDefId::ConstId(_)\n+                                | ModuleDefId::StaticId(_) => return None,\n                             };\n                             Some(ResolveValueResult::Partial(ty, idx))\n                         }\n@@ -315,7 +318,7 @@ impl Resolver {\n         path: &Path,\n     ) -> Option<MacroDef> {\n         let (item_map, module) = self.module()?;\n-        item_map.resolve_path(db, module, path).0.get_macros()\n+        item_map.resolve_path(db, module, path).0.get_macros().map(MacroDef::from)\n     }\n \n     pub(crate) fn process_all_names(\n@@ -333,10 +336,11 @@ impl Resolver {\n         for scope in &self.scopes {\n             if let Scope::ModuleScope(m) = scope {\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate());\n-                    traits.extend(prelude_def_map[prelude.id.module_id].scope.traits());\n+                    let prelude_def_map = db.crate_def_map(prelude.krate);\n+                    traits\n+                        .extend(prelude_def_map[prelude.module_id].scope.traits().map(Trait::from));\n                 }\n-                traits.extend(m.crate_def_map[m.module_id].scope.traits());\n+                traits.extend(m.crate_def_map[m.module_id].scope.traits().map(Trait::from));\n             }\n         }\n         traits\n@@ -351,7 +355,7 @@ impl Resolver {\n     }\n \n     pub(crate) fn krate(&self) -> Option<Crate> {\n-        self.module().map(|t| t.0.krate())\n+        self.module().map(|t| Crate { crate_id: t.0.krate() })\n     }\n \n     pub(crate) fn where_predicates_in_scope<'a>(\n@@ -420,8 +424,10 @@ impl From<PerNs> for ScopeDef {\n     fn from(def: PerNs) -> Self {\n         def.take_types()\n             .or_else(|| def.take_values())\n-            .map(ScopeDef::ModuleDef)\n-            .or_else(|| def.get_macros().map(ScopeDef::MacroDef))\n+            .map(|module_def_id| ScopeDef::ModuleDef(module_def_id.into()))\n+            .or_else(|| {\n+                def.get_macros().map(|macro_def_id| ScopeDef::MacroDef(macro_def_id.into()))\n+            })\n             .unwrap_or(ScopeDef::Unknown)\n     }\n }\n@@ -441,18 +447,16 @@ impl Scope {\n                     f(name.clone(), res.def.into());\n                 });\n                 m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n-                    f(name.clone(), ScopeDef::MacroDef(macro_));\n+                    f(name.clone(), ScopeDef::MacroDef(macro_.into()));\n                 });\n-                m.crate_def_map.extern_prelude().iter().for_each(|(name, def)| {\n-                    f(name.clone(), ScopeDef::ModuleDef(*def));\n+                m.crate_def_map.extern_prelude().iter().for_each(|(name, &def)| {\n+                    f(name.clone(), ScopeDef::ModuleDef(def.into()));\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate());\n-                    prelude_def_map[prelude.id.module_id].scope.entries().for_each(\n-                        |(name, res)| {\n-                            f(name.clone(), res.def.into());\n-                        },\n-                    );\n+                    let prelude_def_map = db.crate_def_map(prelude.krate);\n+                    prelude_def_map[prelude.module_id].scope.entries().for_each(|(name, res)| {\n+                        f(name.clone(), res.def.into());\n+                    });\n                 }\n             }\n             Scope::GenericParams(gp) => {"}, {"sha": "66cb4b357f886f6fbc9578b17a6126bb34b6ffd6", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -253,8 +253,11 @@ impl SourceAnalyzer {\n             Some(res)\n         });\n \n-        let items =\n-            self.resolver.resolve_module_path(db, &path).take_types().map(PathResolution::Def);\n+        let items = self\n+            .resolver\n+            .resolve_module_path(db, &path)\n+            .take_types()\n+            .map(|it| PathResolution::Def(it.into()));\n         types.or(values).or(items).or_else(|| {\n             self.resolver.resolve_path_as_macro(db, &path).map(|def| PathResolution::Macro(def))\n         })"}, {"sha": "2370e8d4f52fa5f7555ecc9a096186764480fb2d", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -25,7 +25,7 @@ use hir_def::{\n     path::known,\n     type_ref::{Mutability, TypeRef},\n };\n-use hir_expand::name;\n+use hir_expand::{diagnostics::DiagnosticSink, name};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n use test_utils::tested_by;\n@@ -40,7 +40,6 @@ use crate::{\n     adt::VariantDef,\n     code_model::TypeAlias,\n     db::HirDatabase,\n-    diagnostics::DiagnosticSink,\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n     resolve::{Resolver, TypeNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n@@ -719,12 +718,9 @@ impl Expectation {\n }\n \n mod diagnostics {\n-    use crate::{\n-        db::HirDatabase,\n-        diagnostics::{DiagnosticSink, NoSuchField},\n-        expr::ExprId,\n-        Function, HasSource,\n-    };\n+    use hir_expand::diagnostics::DiagnosticSink;\n+\n+    use crate::{db::HirDatabase, diagnostics::NoSuchField, expr::ExprId, Function, HasSource};\n \n     #[derive(Debug, PartialEq, Eq, Clone)]\n     pub(super) enum InferenceDiagnostic {"}, {"sha": "a09ef5c5d3afc09247f635dfdd577872eb9ec1ae", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -11,12 +11,11 @@ use crate::{\n     db::HirDatabase,\n     expr::{self, Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     generics::{GenericParams, HasGenericParams},\n-    nameres::Namespace,\n     ty::{\n         autoderef, method_resolution, op, primitive, CallableDef, InferTy, Mutability, Obligation,\n         ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n     },\n-    Adt, Name,\n+    Adt, Name, Namespace,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {"}, {"sha": "e29ab8492a5eed2a5bc107d34f76072661196229", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -23,15 +23,14 @@ use crate::{\n     db::HirDatabase,\n     generics::HasGenericParams,\n     generics::{GenericDef, WherePredicate},\n-    nameres::Namespace,\n     resolve::{Resolver, TypeNs},\n     ty::{\n         primitive::{FloatTy, IntTy},\n         Adt,\n     },\n     util::make_mut_slice,\n-    Const, Enum, EnumVariant, Function, ModuleDef, Path, Static, Struct, StructField, Trait,\n-    TypeAlias, Union,\n+    Const, Enum, EnumVariant, Function, ModuleDef, Namespace, Path, Static, Struct, StructField,\n+    Trait, TypeAlias, Union,\n };\n \n impl Ty {"}, {"sha": "4b7e34878acddbd5054ad0e327b131f77e1918e6", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 25, "deletions": 59, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -2,8 +2,7 @@ use std::fmt::Write;\n use std::sync::Arc;\n \n use insta::assert_snapshot;\n-\n-use ra_db::{salsa::Database, FilePosition, SourceDatabase};\n+use ra_db::{fixture::WithFixture, salsa::Database, FilePosition, SourceDatabase};\n use ra_syntax::{\n     algo,\n     ast::{self, AstNode},\n@@ -25,9 +24,9 @@ mod coercion;\n \n #[test]\n fn cfg_impl_block() {\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (db, pos) = MockDatabase::with_position(\n         r#\"\n-//- /main.rs\n+//- /main.rs crate:main deps:foo cfg:test\n use foo::S as T;\n struct S;\n \n@@ -46,7 +45,7 @@ fn test() {\n     t<|>;\n }\n \n-//- /foo.rs\n+//- /foo.rs crate:foo\n struct S;\n \n #[cfg(not(test))]\n@@ -60,18 +59,14 @@ impl S {\n }\n \"#,\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"foo\"], cfg = { \"test\" }),\n-        \"foo\": (\"/foo.rs\", []),\n-    });\n     assert_eq!(\"(i32, {unknown}, i32, {unknown})\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_await() {\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (db, pos) = MockDatabase::with_position(\n         r#\"\n-//- /main.rs\n+//- /main.rs crate:main deps:std\n \n struct IntFuture;\n \n@@ -85,7 +80,7 @@ fn test() {\n     v<|>;\n }\n \n-//- /std.rs\n+//- /std.rs crate:std\n #[prelude_import] use future::*;\n mod future {\n     trait Future {\n@@ -95,26 +90,22 @@ mod future {\n \n \"#,\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"std\"]),\n-        \"std\": (\"/std.rs\", []),\n-    });\n     assert_eq!(\"u64\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_box() {\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (db, pos) = MockDatabase::with_position(\n         r#\"\n-//- /main.rs\n+//- /main.rs crate:main deps:std\n \n fn test() {\n     let x = box 1;\n     let t = (x, box x, box &1, box [1]);\n     t<|>;\n }\n \n-//- /std.rs\n+//- /std.rs crate:std\n #[prelude_import] use prelude::*;\n mod prelude {}\n \n@@ -126,10 +117,6 @@ mod boxed {\n \n \"#,\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"std\"]),\n-        \"std\": (\"/std.rs\", []),\n-    });\n     assert_eq!(\"(Box<i32>, Box<Box<i32>>, Box<&i32>, Box<[i32;_]>)\", type_at_pos(&db, pos));\n }\n \n@@ -154,17 +141,17 @@ fn test() {\n \n #[test]\n fn infer_try() {\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (db, pos) = MockDatabase::with_position(\n         r#\"\n-//- /main.rs\n+//- /main.rs crate:main deps:std\n \n fn test() {\n     let r: Result<i32, u64> = Result::Ok(1);\n     let v = r?;\n     v<|>;\n }\n \n-//- /std.rs\n+//- /std.rs crate:std\n \n #[prelude_import] use ops::*;\n mod ops {\n@@ -189,18 +176,14 @@ mod result {\n \n \"#,\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"std\"]),\n-        \"std\": (\"/std.rs\", []),\n-    });\n     assert_eq!(\"i32\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_for_loop() {\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (db, pos) = MockDatabase::with_position(\n         r#\"\n-//- /main.rs\n+//- /main.rs crate:main deps:std\n \n use std::collections::Vec;\n \n@@ -212,7 +195,7 @@ fn test() {\n     }\n }\n \n-//- /std.rs\n+//- /std.rs crate:std\n \n #[prelude_import] use iter::*;\n mod iter {\n@@ -234,10 +217,6 @@ mod collections {\n }\n \"#,\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"std\"]),\n-        \"std\": (\"/std.rs\", []),\n-    });\n     assert_eq!(\"&str\", type_at_pos(&db, pos));\n }\n \n@@ -2505,15 +2484,15 @@ pub fn main_loop() {\n \n #[test]\n fn cross_crate_associated_method_call() {\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (db, pos) = MockDatabase::with_position(\n         r#\"\n-//- /main.rs\n+//- /main.rs crate:main deps:other_crate\n fn test() {\n     let x = other_crate::foo::S::thing();\n     x<|>;\n }\n \n-//- /lib.rs\n+//- /lib.rs crate:other_crate\n mod foo {\n     struct S;\n     impl S {\n@@ -2522,10 +2501,6 @@ mod foo {\n }\n \"#,\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"other_crate\"]),\n-        \"other_crate\": (\"/lib.rs\", []),\n-    });\n     assert_eq!(\"i128\", type_at_pos(&db, pos));\n }\n \n@@ -3403,16 +3378,15 @@ fn test() { S.foo()<|>; }\n \n #[test]\n fn infer_macro_with_dollar_crate_is_correct_in_expr() {\n-    covers!(macro_dollar_crate_other);\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (db, pos) = MockDatabase::with_position(\n         r#\"\n-//- /main.rs\n+//- /main.rs crate:main deps:foo\n fn test() {\n     let x = (foo::foo!(1), foo::foo!(2));\n     x<|>;\n }\n \n-//- /lib.rs\n+//- /lib.rs crate:foo\n #[macro_export]\n macro_rules! foo {\n     (1) => { $crate::bar!() };\n@@ -3427,10 +3401,6 @@ macro_rules! bar {\n pub fn baz() -> usize { 31usize }\n \"#,\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"foo\"]),\n-        \"foo\": (\"/lib.rs\", []),\n-    });\n     assert_eq!(\"(i32, usize)\", type_at_pos(&db, pos));\n }\n \n@@ -3512,17 +3482,17 @@ fn test() { (&S).foo()<|>; }\n \n #[test]\n fn method_resolution_trait_from_prelude() {\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (db, pos) = MockDatabase::with_position(\n         r#\"\n-//- /main.rs\n+//- /main.rs crate:main deps:other_crate\n struct S;\n impl Clone for S {}\n \n fn test() {\n     S.clone()<|>;\n }\n \n-//- /lib.rs\n+//- /lib.rs crate:other_crate\n #[prelude_import] use foo::*;\n \n mod foo {\n@@ -3532,10 +3502,6 @@ mod foo {\n }\n \"#,\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"other_crate\"]),\n-        \"other_crate\": (\"/lib.rs\", []),\n-    });\n     assert_eq!(\"S\", type_at_pos(&db, pos));\n }\n "}, {"sha": "21262be7959843e0b409aab32bf20c1fa81e8cea", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -7,7 +7,6 @@ authors = [\"rust-analyzer developers\"]\n [dependencies]\n log = \"0.4.5\"\n once_cell = \"1.0.1\"\n-relative-path = \"1.0.0\"\n rustc-hash = \"1.0\"\n \n ra_arena = { path = \"../ra_arena\" }\n@@ -19,3 +18,6 @@ test_utils = { path = \"../test_utils\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n ra_cfg = { path = \"../ra_cfg\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n+\n+[dev-dependencies]\n+insta = \"0.12.0\""}, {"sha": "8f41e55d26f9ab9e6bd88b6c7b5a6ff03d5bacea", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -8,7 +8,7 @@ use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n     db::DefDatabase2, type_ref::TypeRef, AstItemDef, EnumId, LocalEnumVariantId,\n-    LocalStructFieldId, StructId,\n+    LocalStructFieldId, StructId, UnionId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -56,6 +56,13 @@ impl StructData {\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n     }\n+    pub(crate) fn union_data_query(db: &impl DefDatabase2, struct_: UnionId) -> Arc<StructData> {\n+        let src = struct_.source(db);\n+        let name = src.ast.name().map(|n| n.as_name());\n+        let variant_data = VariantData::new(src.ast.kind());\n+        let variant_data = Arc::new(variant_data);\n+        Arc::new(StructData { name, variant_data })\n+    }\n }\n \n impl EnumData {\n@@ -74,6 +81,11 @@ impl EnumData {\n             .collect();\n         Arc::new(EnumData { name, variants })\n     }\n+\n+    pub(crate) fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n+        let (id, _) = self.variants.iter().find(|(_id, data)| data.name.as_ref() == Some(name))?;\n+        Some(id)\n+    }\n }\n \n impl VariantData {"}, {"sha": "a42348101b487a97988f150490bfc42555b1b272", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -2,13 +2,16 @@\n use std::sync::Arc;\n \n use hir_expand::{db::AstDatabase, HirFileId};\n-use ra_db::{salsa, SourceDatabase};\n+use ra_db::{salsa, CrateId, SourceDatabase};\n use ra_syntax::ast;\n \n use crate::{\n     adt::{EnumData, StructData},\n-    nameres::raw::{ImportSourceMap, RawItems},\n-    EnumId, StructId,\n+    nameres::{\n+        raw::{ImportSourceMap, RawItems},\n+        CrateDefMap,\n+    },\n+    EnumId, StructId, UnionId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n@@ -42,9 +45,15 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n     #[salsa::invoke(RawItems::raw_items_query)]\n     fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n \n+    #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n+    fn crate_def_map(&self, krate: CrateId) -> Arc<CrateDefMap>;\n+\n     #[salsa::invoke(StructData::struct_data_query)]\n     fn struct_data(&self, s: StructId) -> Arc<StructData>;\n \n+    #[salsa::invoke(StructData::union_data_query)]\n+    fn union_data(&self, s: UnionId) -> Arc<StructData>;\n+\n     #[salsa::invoke(EnumData::enum_data_query)]\n     fn enum_data(&self, e: EnumId) -> Arc<EnumData>;\n }"}, {"sha": "9843009a5dc6d5e0e7a37b7f8a49165b899778ac", "filename": "crates/ra_hir_def/src/diagnostics.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -0,0 +1,28 @@\n+//! Diagnostics produced by `hir_def`.\n+\n+use std::any::Any;\n+\n+use hir_expand::diagnostics::Diagnostic;\n+use ra_db::RelativePathBuf;\n+use ra_syntax::{ast, AstPtr, SyntaxNodePtr};\n+\n+use hir_expand::{HirFileId, Source};\n+\n+#[derive(Debug)]\n+pub struct UnresolvedModule {\n+    pub file: HirFileId,\n+    pub decl: AstPtr<ast::Module>,\n+    pub candidate: RelativePathBuf,\n+}\n+\n+impl Diagnostic for UnresolvedModule {\n+    fn message(&self) -> String {\n+        \"unresolved module\".to_string()\n+    }\n+    fn source(&self) -> Source<SyntaxNodePtr> {\n+        Source { file_id: self.file, ast: self.decl.into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}"}, {"sha": "63ed2a09833b77180a07e9fde83fa1abd9520c8e", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -13,25 +13,25 @@ pub mod path;\n pub mod type_ref;\n pub mod builtin_type;\n pub mod adt;\n+pub mod diagnostics;\n+\n+#[cfg(test)]\n+mod test_db;\n+#[cfg(test)]\n+mod marks;\n \n // FIXME: this should be private\n pub mod nameres;\n \n use std::hash::{Hash, Hasher};\n \n-use hir_expand::{ast_id_map::FileAstId, db::AstDatabase, AstId, HirFileId};\n+use hir_expand::{ast_id_map::FileAstId, db::AstDatabase, AstId, HirFileId, Source};\n use ra_arena::{impl_arena_id, RawId};\n use ra_db::{salsa, CrateId, FileId};\n use ra_syntax::{ast, AstNode, SyntaxNode};\n \n use crate::{builtin_type::BuiltinType, db::InternDatabase};\n \n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub struct Source<T> {\n-    pub file_id: HirFileId,\n-    pub ast: T,\n-}\n-\n pub enum ModuleSource {\n     SourceFile(ast::SourceFile),\n     Module(ast::Module),\n@@ -94,15 +94,6 @@ impl ModuleSource {\n     }\n }\n \n-impl<T> Source<T> {\n-    pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n-        Source { file_id: self.file_id, ast: f(self.ast) }\n-    }\n-    pub fn file_syntax(&self, db: &impl AstDatabase) -> SyntaxNode {\n-        db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {\n     pub krate: CrateId,\n@@ -252,8 +243,8 @@ impl AstItemDef<ast::EnumDef> for EnumId {\n // FIXME: rename to `VariantId`, only enums can ave variants\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct EnumVariantId {\n-    parent: EnumId,\n-    local_id: LocalEnumVariantId,\n+    pub parent: EnumId,\n+    pub local_id: LocalEnumVariantId,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "0b99eac7174990588cf791479d372f68d477e431", "filename": "crates/ra_hir_def/src/marks.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -0,0 +1,14 @@\n+//! See test_utils/src/marks.rs\n+\n+test_utils::marks!(\n+    bogus_paths\n+    name_res_works_for_broken_modules\n+    can_import_enum_variant\n+    glob_enum\n+    glob_across_crates\n+    std_prelude\n+    macro_rules_from_other_crates_are_visible_with_macro_use\n+    prelude_is_macro_use\n+    macro_dollar_crate_self\n+    macro_dollar_crate_other\n+);"}, {"sha": "433bdde48f7ff916012704c415dcefcc09e327bc", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 539, "deletions": 1, "changes": 540, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1,5 +1,543 @@\n-//! FIXME: write short doc here\n+//! This module implements import-resolution/macro expansion algorithm.\n+//!\n+//! The result of this module is `CrateDefMap`: a data structure which contains:\n+//!\n+//!   * a tree of modules for the crate\n+//!   * for each module, a set of items visible in the module (directly declared\n+//!     or imported)\n+//!\n+//! Note that `CrateDefMap` contains fully macro expanded code.\n+//!\n+//! Computing `CrateDefMap` can be partitioned into several logically\n+//! independent \"phases\". The phases are mutually recursive though, there's no\n+//! strict ordering.\n+//!\n+//! ## Collecting RawItems\n+//!\n+//!  This happens in the `raw` module, which parses a single source file into a\n+//!  set of top-level items. Nested imports are desugared to flat imports in\n+//!  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n+//!  TokenTree).\n+//!\n+//! ## Collecting Modules\n+//!\n+//! This happens in the `collector` module. In this phase, we recursively walk\n+//! tree of modules, collect raw items from submodules, populate module scopes\n+//! with defined items (so, we assign item ids in this phase) and record the set\n+//! of unresolved imports and macros.\n+//!\n+//! While we walk tree of modules, we also record macro_rules definitions and\n+//! expand calls to macro_rules defined macros.\n+//!\n+//! ## Resolving Imports\n+//!\n+//! We maintain a list of currently unresolved imports. On every iteration, we\n+//! try to resolve some imports from this list. If the import is resolved, we\n+//! record it, by adding an item to current module scope and, if necessary, by\n+//! recursively populating glob imports.\n+//!\n+//! ## Resolving Macros\n+//!\n+//! macro_rules from the same crate use a global mutable namespace. We expand\n+//! them immediately, when we collect modules.\n+//!\n+//! Macros from other crates (including proc-macros) can be used with\n+//! `foo::bar!` syntax. We handle them similarly to imports. There's a list of\n+//! unexpanded macros. On every iteration, we try to resolve each macro call\n+//! path and, upon success, we run macro expansion and \"collect module\" phase\n+//! on the result\n \n // FIXME: review privacy of submodules\n pub mod raw;\n+pub mod per_ns;\n+pub mod collector;\n pub mod mod_resolution;\n+\n+#[cfg(test)]\n+mod tests;\n+\n+use std::sync::Arc;\n+\n+use hir_expand::{diagnostics::DiagnosticSink, name::Name, MacroDefId};\n+use once_cell::sync::Lazy;\n+use ra_arena::Arena;\n+use ra_db::{CrateId, Edition, FileId};\n+use ra_prof::profile;\n+use ra_syntax::ast;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use test_utils::tested_by;\n+\n+use crate::{\n+    builtin_type::BuiltinType,\n+    db::DefDatabase2,\n+    nameres::{diagnostics::DefDiagnostic, per_ns::PerNs, raw::ImportId},\n+    path::{Path, PathKind},\n+    AdtId, AstId, CrateModuleId, EnumVariantId, ModuleDefId, ModuleId, TraitId,\n+};\n+\n+/// Contains all top-level defs from a macro-expanded crate\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct CrateDefMap {\n+    krate: CrateId,\n+    edition: Edition,\n+    /// The prelude module for this crate. This either comes from an import\n+    /// marked with the `prelude_import` attribute, or (in the normal case) from\n+    /// a dependency (`std` or `core`).\n+    prelude: Option<ModuleId>,\n+    extern_prelude: FxHashMap<Name, ModuleDefId>,\n+    root: CrateModuleId,\n+    pub modules: Arena<CrateModuleId, ModuleData>,\n+\n+    /// Some macros are not well-behavior, which leads to infinite loop\n+    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n+    /// We mark it down and skip it in collector\n+    ///\n+    /// FIXME:\n+    /// Right now it only handle a poison macro in a single crate,\n+    /// such that if other crate try to call that macro,\n+    /// the whole process will do again until it became poisoned in that crate.\n+    /// We should handle this macro set globally\n+    /// However, do we want to put it as a global variable?\n+    poison_macros: FxHashSet<MacroDefId>,\n+\n+    diagnostics: Vec<DefDiagnostic>,\n+}\n+\n+impl std::ops::Index<CrateModuleId> for CrateDefMap {\n+    type Output = ModuleData;\n+    fn index(&self, id: CrateModuleId) -> &ModuleData {\n+        &self.modules[id]\n+    }\n+}\n+\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub struct ModuleData {\n+    pub parent: Option<CrateModuleId>,\n+    pub children: FxHashMap<Name, CrateModuleId>,\n+    pub scope: ModuleScope,\n+    /// None for root\n+    pub declaration: Option<AstId<ast::Module>>,\n+    /// None for inline modules.\n+    ///\n+    /// Note that non-inline modules, by definition, live inside non-macro file.\n+    pub definition: Option<FileId>,\n+}\n+\n+#[derive(Debug, Default, PartialEq, Eq, Clone)]\n+pub struct ModuleScope {\n+    pub items: FxHashMap<Name, Resolution>,\n+    /// Macros visable in current module in legacy textual scope\n+    ///\n+    /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first.\n+    /// If it yields no result, then it turns to module scoped `macros`.\n+    /// It macros with name quatified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n+    /// and only normal scoped `macros` will be searched in.\n+    ///\n+    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n+    ///\n+    /// Module scoped macros will be inserted into `items` instead of here.\n+    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n+    // be all resolved to the last one defined if shadowing happens.\n+    legacy_macros: FxHashMap<Name, MacroDefId>,\n+}\n+\n+static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n+    BuiltinType::ALL\n+        .iter()\n+        .map(|(name, ty)| {\n+            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: None })\n+        })\n+        .collect()\n+});\n+\n+/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n+/// Other methods will only resolve values, types and module scoped macros only.\n+impl ModuleScope {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n+        //FIXME: shadowing\n+        self.items.iter().chain(BUILTIN_SCOPE.iter())\n+    }\n+\n+    /// Iterate over all module scoped macros\n+    pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+        self.items\n+            .iter()\n+            .filter_map(|(name, res)| res.def.get_macros().map(|macro_| (name, macro_)))\n+    }\n+\n+    /// Iterate over all legacy textual scoped macros visable at the end of the module\n+    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+        self.legacy_macros.iter().map(|(name, def)| (name, *def))\n+    }\n+\n+    /// Get a name from current module scope, legacy macros are not included\n+    pub fn get(&self, name: &Name) -> Option<&Resolution> {\n+        self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name))\n+    }\n+\n+    pub fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n+        self.items.values().filter_map(|r| match r.def.take_types() {\n+            Some(ModuleDefId::TraitId(t)) => Some(t),\n+            _ => None,\n+        })\n+    }\n+\n+    fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n+        self.legacy_macros.get(name).copied()\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Default)]\n+pub struct Resolution {\n+    /// None for unresolved\n+    pub def: PerNs,\n+    /// ident by which this is imported into local scope.\n+    pub import: Option<ImportId>,\n+}\n+\n+impl Resolution {\n+    pub(crate) fn from_macro(macro_: MacroDefId) -> Self {\n+        Resolution { def: PerNs::macros(macro_), import: None }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+struct ResolvePathResult {\n+    resolved_def: PerNs,\n+    segment_index: Option<usize>,\n+    reached_fixedpoint: ReachedFixedPoint,\n+}\n+\n+impl ResolvePathResult {\n+    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n+        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+    }\n+\n+    fn with(\n+        resolved_def: PerNs,\n+        reached_fixedpoint: ReachedFixedPoint,\n+        segment_index: Option<usize>,\n+    ) -> ResolvePathResult {\n+        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ResolveMode {\n+    Import,\n+    Other,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ReachedFixedPoint {\n+    Yes,\n+    No,\n+}\n+\n+impl CrateDefMap {\n+    pub(crate) fn crate_def_map_query(\n+        // Note that this doesn't have `+ AstDatabase`!\n+        // This gurantess that `CrateDefMap` is stable across reparses.\n+        db: &impl DefDatabase2,\n+        krate: CrateId,\n+    ) -> Arc<CrateDefMap> {\n+        let _p = profile(\"crate_def_map_query\");\n+        let def_map = {\n+            let crate_graph = db.crate_graph();\n+            let edition = crate_graph.edition(krate);\n+            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n+            let root = modules.alloc(ModuleData::default());\n+            CrateDefMap {\n+                krate,\n+                edition,\n+                extern_prelude: FxHashMap::default(),\n+                prelude: None,\n+                root,\n+                modules,\n+                poison_macros: FxHashSet::default(),\n+                diagnostics: Vec::new(),\n+            }\n+        };\n+        let def_map = collector::collect_defs(db, def_map);\n+        Arc::new(def_map)\n+    }\n+\n+    pub fn krate(&self) -> CrateId {\n+        self.krate\n+    }\n+\n+    pub fn root(&self) -> CrateModuleId {\n+        self.root\n+    }\n+\n+    pub fn prelude(&self) -> Option<ModuleId> {\n+        self.prelude\n+    }\n+\n+    pub fn extern_prelude(&self) -> &FxHashMap<Name, ModuleDefId> {\n+        &self.extern_prelude\n+    }\n+\n+    pub fn add_diagnostics(\n+        &self,\n+        db: &impl DefDatabase2,\n+        module: CrateModuleId,\n+        sink: &mut DiagnosticSink,\n+    ) {\n+        self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n+    }\n+\n+    pub fn resolve_path(\n+        &self,\n+        db: &impl DefDatabase2,\n+        original_module: CrateModuleId,\n+        path: &Path,\n+    ) -> (PerNs, Option<usize>) {\n+        let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n+        (res.resolved_def, res.segment_index)\n+    }\n+\n+    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n+    // the result.\n+    fn resolve_path_fp_with_macro(\n+        &self,\n+        db: &impl DefDatabase2,\n+        mode: ResolveMode,\n+        original_module: CrateModuleId,\n+        path: &Path,\n+    ) -> ResolvePathResult {\n+        let mut segments = path.segments.iter().enumerate();\n+        let mut curr_per_ns: PerNs = match path.kind {\n+            PathKind::DollarCrate(krate) => {\n+                if krate == self.krate {\n+                    tested_by!(macro_dollar_crate_self);\n+                    PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n+                } else {\n+                    let def_map = db.crate_def_map(krate);\n+                    let module = ModuleId { krate, module_id: def_map.root };\n+                    tested_by!(macro_dollar_crate_other);\n+                    PerNs::types(module.into())\n+                }\n+            }\n+            PathKind::Crate => {\n+                PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n+            }\n+            PathKind::Self_ => {\n+                PerNs::types(ModuleId { krate: self.krate, module_id: original_module }.into())\n+            }\n+            // plain import or absolute path in 2015: crate-relative with\n+            // fallback to extern prelude (with the simplification in\n+            // rust-lang/rust#57745)\n+            // FIXME there must be a nicer way to write this condition\n+            PathKind::Plain | PathKind::Abs\n+                if self.edition == Edition::Edition2015\n+                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n+            {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n+                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n+            }\n+            PathKind::Plain => {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in module\", segment);\n+                self.resolve_name_in_module(db, original_module, &segment.name)\n+            }\n+            PathKind::Super => {\n+                if let Some(p) = self.modules[original_module].parent {\n+                    PerNs::types(ModuleId { krate: self.krate, module_id: p }.into())\n+                } else {\n+                    log::debug!(\"super path in root module\");\n+                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+                }\n+            }\n+            PathKind::Abs => {\n+                // 2018-style absolute path -- only extern prelude\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                if let Some(def) = self.extern_prelude.get(&segment.name) {\n+                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n+                    PerNs::types(*def)\n+                } else {\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n+                }\n+            }\n+            PathKind::Type(_) => {\n+                // This is handled in `infer::infer_path_expr`\n+                // The result returned here does not matter\n+                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+            }\n+        };\n+\n+        for (i, segment) in segments {\n+            let curr = match curr_per_ns.take_types() {\n+                Some(r) => r,\n+                None => {\n+                    // we still have path segments left, but the path so far\n+                    // didn't resolve in the types namespace => no resolution\n+                    // (don't break here because `curr_per_ns` might contain\n+                    // something in the value namespace, and it would be wrong\n+                    // to return that)\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                }\n+            };\n+            // resolve segment in curr\n+\n+            curr_per_ns = match curr {\n+                ModuleDefId::ModuleId(module) => {\n+                    if module.krate != self.krate {\n+                        let path =\n+                            Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n+                        log::debug!(\"resolving {:?} in other crate\", path);\n+                        let defp_map = db.crate_def_map(module.krate);\n+                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n+                        return ResolvePathResult::with(\n+                            def,\n+                            ReachedFixedPoint::Yes,\n+                            s.map(|s| s + i),\n+                        );\n+                    }\n+\n+                    // Since it is a qualified path here, it should not contains legacy macros\n+                    match self[module.module_id].scope.get(&segment.name) {\n+                        Some(res) => res.def,\n+                        _ => {\n+                            log::debug!(\"path segment {:?} not found\", segment.name);\n+                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                        }\n+                    }\n+                }\n+                ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n+                    // enum variant\n+                    tested_by!(can_import_enum_variant);\n+                    let enum_data = db.enum_data(e);\n+                    match enum_data.variant(&segment.name) {\n+                        Some(local_id) => {\n+                            let variant = EnumVariantId { parent: e, local_id };\n+                            PerNs::both(variant.into(), variant.into())\n+                        }\n+                        None => {\n+                            return ResolvePathResult::with(\n+                                PerNs::types(e.into()),\n+                                ReachedFixedPoint::Yes,\n+                                Some(i),\n+                            );\n+                        }\n+                    }\n+                }\n+                s => {\n+                    // could be an inherent method call in UFCS form\n+                    // (`Struct::method`), or some other kind of associated item\n+                    log::debug!(\n+                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n+                        segment.name,\n+                        curr,\n+                    );\n+\n+                    return ResolvePathResult::with(\n+                        PerNs::types(s),\n+                        ReachedFixedPoint::Yes,\n+                        Some(i),\n+                    );\n+                }\n+            };\n+        }\n+        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n+    }\n+\n+    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs {\n+        let from_crate_root =\n+            self[self.root].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n+\n+        from_crate_root.or(from_extern_prelude)\n+    }\n+\n+    pub(crate) fn resolve_name_in_module(\n+        &self,\n+        db: &impl DefDatabase2,\n+        module: CrateModuleId,\n+        name: &Name,\n+    ) -> PerNs {\n+        // Resolve in:\n+        //  - legacy scope of macro\n+        //  - current module / scope\n+        //  - extern prelude\n+        //  - std prelude\n+        let from_legacy_macro =\n+            self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n+        let from_scope = self[module].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+        let from_extern_prelude =\n+            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+        let from_prelude = self.resolve_in_prelude(db, name);\n+\n+        from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n+    }\n+\n+    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n+        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n+    }\n+\n+    fn resolve_in_prelude(&self, db: &impl DefDatabase2, name: &Name) -> PerNs {\n+        if let Some(prelude) = self.prelude {\n+            let keep;\n+            let def_map = if prelude.krate == self.krate {\n+                self\n+            } else {\n+                // Extend lifetime\n+                keep = db.crate_def_map(prelude.krate);\n+                &keep\n+            };\n+            def_map[prelude.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n+        } else {\n+            PerNs::none()\n+        }\n+    }\n+}\n+\n+mod diagnostics {\n+    use hir_expand::diagnostics::DiagnosticSink;\n+    use ra_db::RelativePathBuf;\n+    use ra_syntax::{ast, AstPtr};\n+\n+    use crate::{db::DefDatabase2, diagnostics::UnresolvedModule, nameres::CrateModuleId, AstId};\n+\n+    #[derive(Debug, PartialEq, Eq)]\n+    pub(super) enum DefDiagnostic {\n+        UnresolvedModule {\n+            module: CrateModuleId,\n+            declaration: AstId<ast::Module>,\n+            candidate: RelativePathBuf,\n+        },\n+    }\n+\n+    impl DefDiagnostic {\n+        pub(super) fn add_to(\n+            &self,\n+            db: &impl DefDatabase2,\n+            target_module: CrateModuleId,\n+            sink: &mut DiagnosticSink,\n+        ) {\n+            match self {\n+                DefDiagnostic::UnresolvedModule { module, declaration, candidate } => {\n+                    if *module != target_module {\n+                        return;\n+                    }\n+                    let decl = declaration.to_node(db);\n+                    sink.push(UnresolvedModule {\n+                        file: declaration.file_id(),\n+                        decl: AstPtr::new(&decl),\n+                        candidate: candidate.clone(),\n+                    })\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3b61d9895bc3024817d9e1f87a1c964915ca570c", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "renamed", "additions": 84, "deletions": 77, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1,45 +1,49 @@\n //! FIXME: write short doc here\n \n-use hir_def::{\n-    attr::Attr,\n-    nameres::{mod_resolution::ModDir, raw},\n+use hir_expand::{\n+    name::{self, AsName, Name},\n+    HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFileKind,\n };\n-use hir_expand::name;\n use ra_cfg::CfgOptions;\n-use ra_db::FileId;\n+use ra_db::{CrateId, FileId};\n use ra_syntax::{ast, SmolStr};\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n-    db::DefDatabase,\n-    ids::{AstItemDef, LocationCtx, MacroCallId, MacroCallLoc, MacroDefId, MacroFileKind},\n+    attr::Attr,\n+    db::DefDatabase2,\n     nameres::{\n-        diagnostics::DefDiagnostic, Crate, CrateDefMap, CrateModuleId, ModuleData, ModuleDef,\n-        PerNs, ReachedFixedPoint, Resolution, ResolveMode,\n+        diagnostics::DefDiagnostic, mod_resolution::ModDir, per_ns::PerNs, raw, CrateDefMap,\n+        ModuleData, ReachedFixedPoint, Resolution, ResolveMode,\n     },\n-    Adt, AstId, Const, Enum, Function, HirFileId, MacroDef, Module, Name, Path, PathKind, Static,\n-    Struct, Trait, TypeAlias, Union,\n+    path::{Path, PathKind},\n+    AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionId,\n+    LocationCtx, ModuleDefId, ModuleId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n \n-pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n+pub(super) fn collect_defs(db: &impl DefDatabase2, mut def_map: CrateDefMap) -> CrateDefMap {\n+    let crate_graph = db.crate_graph();\n+\n     // populate external prelude\n-    for dep in def_map.krate.dependencies(db) {\n-        log::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.krate);\n-        if let Some(module) = dep.krate.root_module(db) {\n-            def_map.extern_prelude.insert(dep.name.clone(), module.into());\n-        }\n+    for dep in crate_graph.dependencies(def_map.krate) {\n+        let dep_def_map = db.crate_def_map(dep.crate_id);\n+        log::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.crate_id);\n+        def_map.extern_prelude.insert(\n+            dep.as_name(),\n+            ModuleId { krate: dep.crate_id, module_id: dep_def_map.root }.into(),\n+        );\n+\n         // look for the prelude\n         if def_map.prelude.is_none() {\n-            let map = db.crate_def_map(dep.krate);\n+            let map = db.crate_def_map(dep.crate_id);\n             if map.prelude.is_some() {\n                 def_map.prelude = map.prelude;\n             }\n         }\n     }\n \n-    let crate_graph = db.crate_graph();\n-    let cfg_options = crate_graph.cfg_options(def_map.krate().crate_id());\n+    let cfg_options = crate_graph.cfg_options(def_map.krate);\n \n     let mut collector = DefCollector {\n         db,\n@@ -101,11 +105,11 @@ struct DefCollector<'a, DB> {\n \n impl<DB> DefCollector<'_, DB>\n where\n-    DB: DefDatabase,\n+    DB: DefDatabase2,\n {\n     fn collect(&mut self) {\n         let crate_graph = self.db.crate_graph();\n-        let file_id = crate_graph.crate_root(self.def_map.krate.crate_id());\n+        let file_id = crate_graph.crate_root(self.def_map.krate);\n         let raw_items = self.db.raw_items(file_id.into());\n         let module_id = self.def_map.root;\n         self.def_map.modules[module_id].definition = Some(file_id);\n@@ -168,7 +172,7 @@ where\n         &mut self,\n         module_id: CrateModuleId,\n         name: Name,\n-        macro_: MacroDef,\n+        macro_: MacroDefId,\n         export: bool,\n     ) {\n         // Textual scoping\n@@ -189,7 +193,7 @@ where\n     /// the definition of current module.\n     /// And also, `macro_use` on a module will import all legacy macros visable inside to\n     /// current legacy scope, with possible shadowing.\n-    fn define_legacy_macro(&mut self, module_id: CrateModuleId, name: Name, macro_: MacroDef) {\n+    fn define_legacy_macro(&mut self, module_id: CrateModuleId, name: Name, macro_: MacroDefId) {\n         // Always shadowing\n         self.def_map.modules[module_id].scope.legacy_macros.insert(name, macro_);\n     }\n@@ -213,9 +217,9 @@ where\n                 .expect(\"extern crate should have been desugared to one-element path\"),\n         );\n \n-        if let Some(ModuleDef::Module(m)) = res.take_types() {\n+        if let Some(ModuleDefId::ModuleId(m)) = res.take_types() {\n             tested_by!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(current_module_id, m.krate());\n+            self.import_all_macros_exported(current_module_id, m.krate);\n         }\n     }\n \n@@ -224,7 +228,7 @@ where\n     /// Exported macros are just all macros in the root module scope.\n     /// Note that it contains not only all `#[macro_export]` macros, but also all aliases\n     /// created by `use` in the root module, ignoring the visibility of `use`.\n-    fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, krate: Crate) {\n+    fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, krate: CrateId) {\n         let def_map = self.db.crate_def_map(krate);\n         for (name, def) in def_map[def_map.root].scope.macros() {\n             // `macro_use` only bring things into legacy scope.\n@@ -288,15 +292,15 @@ where\n         if import.is_glob {\n             log::debug!(\"glob import: {:?}\", import);\n             match def.take_types() {\n-                Some(ModuleDef::Module(m)) => {\n+                Some(ModuleDefId::ModuleId(m)) => {\n                     if import.is_prelude {\n                         tested_by!(std_prelude);\n                         self.def_map.prelude = Some(m);\n-                    } else if m.krate() != self.def_map.krate {\n+                    } else if m.krate != self.def_map.krate {\n                         tested_by!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n-                        let item_map = self.db.crate_def_map(m.krate());\n-                        let scope = &item_map[m.id.module_id].scope;\n+                        let item_map = self.db.crate_def_map(m.krate);\n+                        let scope = &item_map[m.module_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -310,7 +314,7 @@ where\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n                         // additions\n-                        let scope = &self.def_map[m.id.module_id].scope;\n+                        let scope = &self.def_map[m.module_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -322,23 +326,25 @@ where\n                         self.update(module_id, Some(import_id), &items);\n                         // record the glob import in case we add further items\n                         self.glob_imports\n-                            .entry(m.id.module_id)\n+                            .entry(m.module_id)\n                             .or_default()\n                             .push((module_id, import_id));\n                     }\n                 }\n-                Some(ModuleDef::Adt(Adt::Enum(e))) => {\n+                Some(ModuleDefId::AdtId(AdtId::EnumId(e))) => {\n                     tested_by!(glob_enum);\n                     // glob import from enum => just import all the variants\n-                    let variants = e.variants(self.db);\n-                    let resolutions = variants\n-                        .into_iter()\n-                        .filter_map(|variant| {\n+                    let enum_data = self.db.enum_data(e);\n+                    let resolutions = enum_data\n+                        .variants\n+                        .iter()\n+                        .filter_map(|(local_id, variant_data)| {\n+                            let name = variant_data.name.clone()?;\n+                            let variant = EnumVariantId { parent: e, local_id };\n                             let res = Resolution {\n                                 def: PerNs::both(variant.into(), variant.into()),\n                                 import: Some(import_id),\n                             };\n-                            let name = variant.name(self.db)?;\n                             Some((name, res))\n                         })\n                         .collect::<Vec<_>>();\n@@ -451,8 +457,8 @@ where\n             );\n \n             if let Some(def) = resolved_res.resolved_def.get_macros() {\n-                let call_id = self.db.intern_macro(MacroCallLoc { def: def.id, ast_id: *ast_id });\n-                resolved.push((*module_id, call_id, def.id));\n+                let call_id = self.db.intern_macro(MacroCallLoc { def, ast_id: *ast_id });\n+                resolved.push((*module_id, call_id, def));\n                 res = ReachedFixedPoint::No;\n                 return false;\n             }\n@@ -517,7 +523,7 @@ struct ModCollector<'a, D> {\n \n impl<DB> ModCollector<'_, &'_ mut DefCollector<'_, DB>>\n where\n-    DB: DefDatabase,\n+    DB: DefDatabase2,\n {\n     fn collect(&mut self, items: &[raw::RawItem]) {\n         // Note: don't assert that inserted value is fresh: it's simply not true\n@@ -526,10 +532,9 @@ where\n \n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n-            if prelude_module.krate() != self.def_collector.def_map.krate {\n+            if prelude_module.krate != self.def_collector.def_map.krate {\n                 tested_by!(prelude_is_macro_use);\n-                self.def_collector\n-                    .import_all_macros_exported(self.module_id, prelude_module.krate());\n+                self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n             }\n         }\n \n@@ -635,38 +640,42 @@ where\n         modules[res].scope.legacy_macros = modules[self.module_id].scope.legacy_macros.clone();\n         modules[self.module_id].children.insert(name.clone(), res);\n         let resolution = Resolution {\n-            def: PerNs::types(Module::new(self.def_collector.def_map.krate, res).into()),\n+            def: PerNs::types(\n+                ModuleId { krate: self.def_collector.def_map.krate, module_id: res }.into(),\n+            ),\n             import: None,\n         };\n         self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n         res\n     }\n \n     fn define_def(&mut self, def: &raw::DefData) {\n-        let module = Module::new(self.def_collector.def_map.krate, self.module_id);\n-        let ctx = LocationCtx::new(self.def_collector.db, module.id, self.file_id);\n+        let module =\n+            ModuleId { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n+        let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n \n-        macro_rules! def {\n-            ($kind:ident, $ast_id:ident) => {\n-                $kind { id: AstItemDef::from_ast_id(ctx, $ast_id) }.into()\n-            };\n-        }\n         let name = def.name.clone();\n         let def: PerNs = match def.kind {\n-            raw::DefKind::Function(ast_id) => PerNs::values(def!(Function, ast_id)),\n+            raw::DefKind::Function(ast_id) => {\n+                PerNs::values(FunctionId::from_ast_id(ctx, ast_id).into())\n+            }\n             raw::DefKind::Struct(ast_id) => {\n-                let s = def!(Struct, ast_id);\n+                let s = StructId::from_ast_id(ctx, ast_id).into();\n                 PerNs::both(s, s)\n             }\n             raw::DefKind::Union(ast_id) => {\n-                let s = def!(Union, ast_id);\n+                let s = UnionId::from_ast_id(ctx, ast_id).into();\n                 PerNs::both(s, s)\n             }\n-            raw::DefKind::Enum(ast_id) => PerNs::types(def!(Enum, ast_id)),\n-            raw::DefKind::Const(ast_id) => PerNs::values(def!(Const, ast_id)),\n-            raw::DefKind::Static(ast_id) => PerNs::values(def!(Static, ast_id)),\n-            raw::DefKind::Trait(ast_id) => PerNs::types(def!(Trait, ast_id)),\n-            raw::DefKind::TypeAlias(ast_id) => PerNs::types(def!(TypeAlias, ast_id)),\n+            raw::DefKind::Enum(ast_id) => PerNs::types(EnumId::from_ast_id(ctx, ast_id).into()),\n+            raw::DefKind::Const(ast_id) => PerNs::values(ConstId::from_ast_id(ctx, ast_id).into()),\n+            raw::DefKind::Static(ast_id) => {\n+                PerNs::values(StaticId::from_ast_id(ctx, ast_id).into())\n+            }\n+            raw::DefKind::Trait(ast_id) => PerNs::types(TraitId::from_ast_id(ctx, ast_id).into()),\n+            raw::DefKind::TypeAlias(ast_id) => {\n+                PerNs::types(TypeAliasId::from_ast_id(ctx, ast_id).into())\n+            }\n         };\n         let resolution = Resolution { def, import: None };\n         self.def_collector.update(self.module_id, None, &[(name, resolution)])\n@@ -678,10 +687,8 @@ where\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                let macro_id =\n-                    MacroDefId { ast_id, krate: self.def_collector.def_map.krate.crate_id };\n-                let macro_ = MacroDef { id: macro_id };\n-                self.def_collector.define_macro(self.module_id, name.clone(), macro_, mac.export);\n+                let macro_id = MacroDefId { ast_id, krate: self.def_collector.def_map.krate };\n+                self.def_collector.define_macro(self.module_id, name.clone(), macro_id, mac.export);\n             }\n             return;\n         }\n@@ -691,10 +698,10 @@ where\n         if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n             self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n         }) {\n-            let def = macro_def.id;\n-            let macro_call_id = self.def_collector.db.intern_macro(MacroCallLoc { def, ast_id });\n+            let macro_call_id =\n+                self.def_collector.db.intern_macro(MacroCallLoc { def: macro_def, ast_id });\n \n-            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, def);\n+            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_def);\n             return;\n         }\n \n@@ -733,15 +740,16 @@ fn is_macro_rules(path: &Path) -> bool {\n \n #[cfg(test)]\n mod tests {\n-    use ra_db::SourceDatabase;\n-\n-    use super::*;\n-    use crate::{db::DefDatabase, mock::MockDatabase, Crate};\n     use ra_arena::Arena;\n+    use ra_db::{fixture::WithFixture, SourceDatabase};\n     use rustc_hash::FxHashSet;\n \n+    use crate::{db::DefDatabase2, test_db::TestDB};\n+\n+    use super::*;\n+\n     fn do_collect_defs(\n-        db: &impl DefDatabase,\n+        db: &impl DefDatabase2,\n         def_map: CrateDefMap,\n         monitor: MacroStackMonitor,\n     ) -> CrateDefMap {\n@@ -760,12 +768,11 @@ mod tests {\n     }\n \n     fn do_limited_resolve(code: &str, limit: u32, poison_limit: u32) -> CrateDefMap {\n-        let (db, _source_root, _) = MockDatabase::with_single_file(&code);\n-        let crate_id = db.crate_graph().iter().next().unwrap();\n-        let krate = Crate { crate_id };\n+        let (db, _file_id) = TestDB::with_single_file(&code);\n+        let krate = db.crate_graph().iter().next().unwrap();\n \n         let def_map = {\n-            let edition = krate.edition(&db);\n+            let edition = db.crate_graph().edition(krate);\n             let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n             let root = modules.alloc(ModuleData::default());\n             CrateDefMap {", "previous_filename": "crates/ra_hir/src/nameres/collector.rs"}, {"sha": "f6b0b8fb1ec6e67ff976b26ab601882d52b8bdfa", "filename": "crates/ra_hir_def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1,8 +1,7 @@\n //! This module resolves `mod foo;` declaration to file.\n use hir_expand::name::Name;\n-use ra_db::FileId;\n+use ra_db::{FileId, RelativePathBuf};\n use ra_syntax::SmolStr;\n-use relative_path::RelativePathBuf;\n \n use crate::{db::DefDatabase2, HirFileId};\n "}, {"sha": "298b0b0c724b302e6fb582a699b8a86382feaebc", "filename": "crates/ra_hir_def/src/nameres/per_ns.rs", "status": "renamed", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fper_ns.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1,6 +1,8 @@\n //! FIXME: write short doc here\n \n-use crate::{MacroDef, ModuleDef};\n+use hir_expand::MacroDefId;\n+\n+use crate::ModuleDefId;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum Namespace {\n@@ -12,11 +14,11 @@ pub enum Namespace {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct PerNs {\n-    pub types: Option<ModuleDef>,\n-    pub values: Option<ModuleDef>,\n+    pub types: Option<ModuleDefId>,\n+    pub values: Option<ModuleDefId>,\n     /// Since macros has different type, many methods simply ignore it.\n     /// We can only use special method like `get_macros` to access it.\n-    pub macros: Option<MacroDef>,\n+    pub macros: Option<MacroDefId>,\n }\n \n impl Default for PerNs {\n@@ -30,19 +32,19 @@ impl PerNs {\n         PerNs { types: None, values: None, macros: None }\n     }\n \n-    pub fn values(t: ModuleDef) -> PerNs {\n+    pub fn values(t: ModuleDefId) -> PerNs {\n         PerNs { types: None, values: Some(t), macros: None }\n     }\n \n-    pub fn types(t: ModuleDef) -> PerNs {\n+    pub fn types(t: ModuleDefId) -> PerNs {\n         PerNs { types: Some(t), values: None, macros: None }\n     }\n \n-    pub fn both(types: ModuleDef, values: ModuleDef) -> PerNs {\n+    pub fn both(types: ModuleDefId, values: ModuleDefId) -> PerNs {\n         PerNs { types: Some(types), values: Some(values), macros: None }\n     }\n \n-    pub fn macros(macro_: MacroDef) -> PerNs {\n+    pub fn macros(macro_: MacroDefId) -> PerNs {\n         PerNs { types: None, values: None, macros: Some(macro_) }\n     }\n \n@@ -54,15 +56,15 @@ impl PerNs {\n         self.types.is_some() && self.values.is_some() && self.macros.is_some()\n     }\n \n-    pub fn take_types(self) -> Option<ModuleDef> {\n+    pub fn take_types(self) -> Option<ModuleDefId> {\n         self.types\n     }\n \n-    pub fn take_values(self) -> Option<ModuleDef> {\n+    pub fn take_values(self) -> Option<ModuleDefId> {\n         self.values\n     }\n \n-    pub fn get_macros(&self) -> Option<MacroDef> {\n+    pub fn get_macros(&self) -> Option<MacroDefId> {\n         self.macros\n     }\n ", "previous_filename": "crates/ra_hir/src/nameres/per_ns.rs"}, {"sha": "cb47fa317d2d07a01f8555143a16ce3cfa5df076", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -14,6 +14,7 @@ use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n     AstNode, AstPtr, SourceFile,\n };\n+use test_utils::tested_by;\n \n use crate::{attr::Attr, db::DefDatabase2, path::Path, FileAstId, HirFileId, ModuleSource, Source};\n \n@@ -297,8 +298,7 @@ impl RawItemsCollector {\n             self.push_item(current_module, attrs, RawItemKind::Module(item));\n             return;\n         }\n-        // FIXME: restore this mark once we complete hir splitting\n-        // tested_by!(name_res_works_for_broken_modules);\n+        tested_by!(name_res_works_for_broken_modules);\n     }\n \n     fn add_use_item(&mut self, current_module: Option<Module>, use_item: ast::UseItem) {"}, {"sha": "52bd0aa91e8ce7ada8188c8e1a1ed545329b0301", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "renamed", "additions": 48, "deletions": 104, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1,35 +1,31 @@\n-mod macros;\n mod globs;\n mod incremental;\n-mod primitives;\n+mod macros;\n mod mod_resolution;\n+mod primitives;\n \n use std::sync::Arc;\n \n use insta::assert_snapshot;\n-use ra_db::SourceDatabase;\n+use ra_db::{fixture::WithFixture, SourceDatabase};\n use test_utils::covers;\n \n-use crate::{\n-    mock::{CrateGraphFixture, MockDatabase},\n-    Crate,\n-};\n+use crate::{db::DefDatabase2, nameres::*, test_db::TestDB, CrateModuleId};\n \n-use super::*;\n+fn def_map(fixtute: &str) -> String {\n+    let dm = compute_crate_def_map(fixtute);\n+    render_crate_def_map(&dm)\n+}\n \n-fn compute_crate_def_map(fixture: &str, graph: Option<CrateGraphFixture>) -> Arc<CrateDefMap> {\n-    let mut db = MockDatabase::with_files(fixture);\n-    if let Some(graph) = graph {\n-        db.set_crate_graph_from_fixture(graph);\n-    }\n-    let crate_id = db.crate_graph().iter().next().unwrap();\n-    let krate = Crate { crate_id };\n+fn compute_crate_def_map(fixture: &str) -> Arc<CrateDefMap> {\n+    let db = TestDB::with_files(fixture);\n+    let krate = db.crate_graph().iter().next().unwrap();\n     db.crate_def_map(krate)\n }\n \n fn render_crate_def_map(map: &CrateDefMap) -> String {\n     let mut buf = String::new();\n-    go(&mut buf, map, \"\\ncrate\", map.root);\n+    go(&mut buf, map, \"\\ncrate\", map.root());\n     return buf.trim().to_string();\n \n     fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: CrateModuleId) {\n@@ -70,16 +66,6 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n     }\n }\n \n-fn def_map(fixtute: &str) -> String {\n-    let dm = compute_crate_def_map(fixtute, None);\n-    render_crate_def_map(&dm)\n-}\n-\n-fn def_map_with_crate_graph(fixture: &str, graph: CrateGraphFixture) -> String {\n-    let dm = compute_crate_def_map(fixture, Some(graph));\n-    render_crate_def_map(&dm)\n-}\n-\n #[test]\n fn crate_def_map_smoke_test() {\n     let map = def_map(\n@@ -234,23 +220,19 @@ fn re_exports() {\n #[test]\n fn std_prelude() {\n     covers!(std_prelude);\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:test_crate\n         use Foo::*;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:test_crate\n         mod prelude;\n         #[prelude_import]\n         use prelude::*;\n \n         //- /prelude.rs\n         pub enum Foo { Bar, Baz };\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"test_crate\"]),\n-            \"test_crate\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n         \u22eecrate\n@@ -279,9 +261,9 @@ fn can_import_enum_variant() {\n \n #[test]\n fn edition_2015_imports() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:other_crate edition:2015\n         mod foo;\n         mod bar;\n \n@@ -292,13 +274,9 @@ fn edition_2015_imports() {\n         use bar::Bar;\n         use other_crate::FromLib;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:other_crate edition:2018\n         struct FromLib;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", \"2015\", [\"other_crate\"]),\n-            \"other_crate\": (\"/lib.rs\", \"2018\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -343,18 +321,14 @@ fn item_map_using_self() {\n \n #[test]\n fn item_map_across_crates() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:test_crate\n         use test_crate::Baz;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:test_crate\n         pub struct Baz;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"test_crate\"]),\n-            \"test_crate\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -365,9 +339,9 @@ fn item_map_across_crates() {\n \n #[test]\n fn extern_crate_rename() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:alloc\n         extern crate alloc as alloc_crate;\n \n         mod alloc;\n@@ -376,13 +350,9 @@ fn extern_crate_rename() {\n         //- /sync.rs\n         use alloc_crate::Arc;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:alloc\n         struct Arc;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"alloc\"]),\n-            \"alloc\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -397,9 +367,9 @@ fn extern_crate_rename() {\n \n #[test]\n fn extern_crate_rename_2015_edition() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:alloc edition:2015\n         extern crate alloc as alloc_crate;\n \n         mod alloc;\n@@ -408,13 +378,9 @@ fn extern_crate_rename_2015_edition() {\n         //- /sync.rs\n         use alloc_crate::Arc;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:alloc\n         struct Arc;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", \"2015\", [\"alloc\"]),\n-            \"alloc\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map,\n@@ -431,24 +397,21 @@ fn extern_crate_rename_2015_edition() {\n \n #[test]\n fn import_across_source_roots() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /lib.rs\n+        //- /main.rs crate:main deps:test_crate\n+        use test_crate::a::b::C;\n+\n+        //- root /test_crate/\n+\n+        //- /test_crate/lib.rs crate:test_crate\n         pub mod a {\n             pub mod b {\n                 pub struct C;\n             }\n         }\n \n-        //- root /main/\n-\n-        //- /main/main.rs\n-        use test_crate::a::b::C;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main/main.rs\", [\"test_crate\"]),\n-            \"test_crate\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -459,23 +422,19 @@ fn import_across_source_roots() {\n \n #[test]\n fn reexport_across_crates() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:test_crate\n         use test_crate::Baz;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:test_crate\n         pub use foo::Baz;\n \n         mod foo;\n \n         //- /foo.rs\n         pub struct Baz;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"test_crate\"]),\n-            \"test_crate\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -486,19 +445,15 @@ fn reexport_across_crates() {\n \n #[test]\n fn values_dont_shadow_extern_crates() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         fn foo() {}\n         use foo::Bar;\n \n-        //- /foo/lib.rs\n+        //- /foo/lib.rs crate:foo\n         pub struct Bar;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/foo/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -510,11 +465,12 @@ fn values_dont_shadow_extern_crates() {\n \n #[test]\n fn cfg_not_test() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         r#\"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:std\n         use {Foo, Bar, Baz};\n-        //- /lib.rs\n+\n+        //- /lib.rs crate:std\n         #[prelude_import]\n         pub use self::prelude::*;\n         mod prelude {\n@@ -526,10 +482,6 @@ fn cfg_not_test() {\n             pub struct Baz;\n         }\n         \"#,\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"std\"]),\n-            \"std\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -542,11 +494,12 @@ fn cfg_not_test() {\n \n #[test]\n fn cfg_test() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         r#\"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:std\n         use {Foo, Bar, Baz};\n-        //- /lib.rs\n+\n+        //- /lib.rs crate:std cfg:test,feature=foo,feature=bar,opt=42\n         #[prelude_import]\n         pub use self::prelude::*;\n         mod prelude {\n@@ -558,15 +511,6 @@ fn cfg_test() {\n             pub struct Baz;\n         }\n         \"#,\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"std\"]),\n-            \"std\": (\"/lib.rs\", [], cfg = {\n-                \"test\",\n-                \"feature\" = \"foo\",\n-                \"feature\" = \"bar\",\n-                \"opt\" = \"42\",\n-            }),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"", "previous_filename": "crates/ra_hir/src/nameres/tests.rs"}, {"sha": "5b03fe36504a46cc2475be629188112c06e545b4", "filename": "crates/ra_hir_def/src/nameres/tests/globs.rs", "status": "renamed", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -76,18 +76,14 @@ fn glob_2() {\n #[test]\n fn glob_across_crates() {\n     covers!(glob_across_crates);\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:test_crate\n         use test_crate::*;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:test_crate\n         pub struct Baz;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"test_crate\"]),\n-            \"test_crate\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate", "previous_filename": "crates/ra_hir/src/nameres/tests/globs.rs"}, {"sha": "80dcec62f0f99b3f0f008915a80ed943730b94e5", "filename": "crates/ra_hir_def/src/nameres/tests/incremental.rs", "status": "renamed", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1,13 +1,12 @@\n-use super::*;\n-\n use std::sync::Arc;\n \n use ra_db::{SourceDatabase, SourceDatabaseExt};\n \n+use super::*;\n+\n fn check_def_map_is_not_recomputed(initial: &str, file_change: &str) {\n-    let (mut db, pos) = MockDatabase::with_position(initial);\n-    let crate_id = db.crate_graph().iter().next().unwrap();\n-    let krate = Crate { crate_id };\n+    let (mut db, pos) = TestDB::with_position(initial);\n+    let krate = db.crate_graph().iter().next().unwrap();\n     {\n         let events = db.log_executed(|| {\n             db.crate_def_map(krate);\n@@ -92,7 +91,7 @@ fn adding_inner_items_should_not_invalidate_def_map() {\n \n #[test]\n fn typing_inside_a_macro_should_not_invalidate_def_map() {\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (mut db, pos) = TestDB::with_position(\n         \"\n         //- /lib.rs\n         macro_rules! m {\n@@ -112,29 +111,22 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         m!(X);\n         \",\n     );\n+    let krate = db.crate_graph().iter().next().unwrap();\n     {\n         let events = db.log_executed(|| {\n-            let src = crate::Source {\n-                file_id: pos.file_id.into(),\n-                ast: crate::ModuleSource::new(&db, Some(pos.file_id), None),\n-            };\n-            let module = crate::Module::from_definition(&db, src).unwrap();\n-            let decls = module.declarations(&db);\n-            assert_eq!(decls.len(), 18);\n+            let crate_def_map = db.crate_def_map(krate);\n+            let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n+            assert_eq!(module_data.scope.items.len(), 1);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }\n     db.set_file_text(pos.file_id, Arc::new(\"m!(Y);\".to_string()));\n \n     {\n         let events = db.log_executed(|| {\n-            let src = crate::Source {\n-                file_id: pos.file_id.into(),\n-                ast: crate::ModuleSource::new(&db, Some(pos.file_id), None),\n-            };\n-            let module = crate::Module::from_definition(&db, src).unwrap();\n-            let decls = module.declarations(&db);\n-            assert_eq!(decls.len(), 18);\n+            let crate_def_map = db.crate_def_map(krate);\n+            let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n+            assert_eq!(module_data.scope.items.len(), 1);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }", "previous_filename": "crates/ra_hir/src/nameres/tests/incremental.rs"}, {"sha": "704065633a5f329a0cb6a6b050e5b5918fc74a6b", "filename": "crates/ra_hir_def/src/nameres/tests/macros.rs", "status": "renamed", "additions": 25, "deletions": 58, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -71,27 +71,23 @@ fn macro_rules_can_define_modules() {\n \n #[test]\n fn macro_rules_from_other_crates_are_visible() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         foo::structs!(Foo, Bar)\n         mod bar;\n \n         //- /bar.rs\n         use crate::*;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         #[macro_export]\n         macro_rules! structs {\n             ($($i:ident),*) => {\n                 $(struct $i { field: u32 } )*\n             }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n@@ -108,27 +104,23 @@ fn macro_rules_from_other_crates_are_visible() {\n \n #[test]\n fn macro_rules_export_with_local_inner_macros_are_visible() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         foo::structs!(Foo, Bar)\n         mod bar;\n \n         //- /bar.rs\n         use crate::*;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         #[macro_export(local_inner_macros)]\n         macro_rules! structs {\n             ($($i:ident),*) => {\n                 $(struct $i { field: u32 } )*\n             }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n@@ -145,9 +137,9 @@ fn macro_rules_export_with_local_inner_macros_are_visible() {\n \n #[test]\n fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         macro_rules! baz {\n             () => {\n                 use foo::bar;\n@@ -158,7 +150,7 @@ fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n         bar!();\n         baz!();\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         #[macro_export]\n         macro_rules! foo {\n             () => {\n@@ -172,10 +164,6 @@ fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n             }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n@@ -188,9 +176,9 @@ fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n #[test]\n fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n     covers!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         structs!(Foo);\n         structs_priv!(Bar);\n         structs_not_exported!(MacroNotResolved1);\n@@ -205,7 +193,7 @@ fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n         structs!(Baz);\n         crate::structs!(MacroNotResolved3);\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         #[macro_export]\n         macro_rules! structs {\n             ($i:ident) => { struct $i; }\n@@ -222,10 +210,6 @@ fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n             }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n@@ -242,9 +226,9 @@ fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n #[test]\n fn prelude_is_macro_use() {\n     covers!(prelude_is_macro_use);\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         structs!(Foo);\n         structs_priv!(Bar);\n         structs_outside!(Out);\n@@ -256,7 +240,7 @@ fn prelude_is_macro_use() {\n         structs!(Baz);\n         crate::structs!(MacroNotResolved3);\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         #[prelude_import]\n         use self::prelude::*;\n \n@@ -279,10 +263,6 @@ fn prelude_is_macro_use() {\n             ($i:ident) => { struct $i; }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n@@ -447,16 +427,16 @@ fn type_value_macro_live_in_different_scopes() {\n \n #[test]\n fn macro_use_can_be_aliased() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         #[macro_use]\n         extern crate foo;\n \n         foo!(Direct);\n         bar!(Alias);\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         use crate::foo as bar;\n \n         mod m {\n@@ -466,10 +446,6 @@ fn macro_use_can_be_aliased() {\n             }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n         \u22eecrate\n@@ -533,9 +509,9 @@ fn path_qualified_macros() {\n fn macro_dollar_crate_is_correct_in_item() {\n     covers!(macro_dollar_crate_self);\n     covers!(macro_dollar_crate_other);\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         #[macro_use]\n         extern crate foo;\n \n@@ -554,7 +530,7 @@ fn macro_dollar_crate_is_correct_in_item() {\n         not_current1!();\n         foo::not_current2!();\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         mod m {\n             #[macro_export]\n             macro_rules! not_current1 {\n@@ -574,10 +550,6 @@ fn macro_dollar_crate_is_correct_in_item() {\n         struct Bar;\n         struct Baz;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n         \u22eecrate\n@@ -596,12 +568,12 @@ fn macro_dollar_crate_is_correct_in_item() {\n fn macro_dollar_crate_is_correct_in_indirect_deps() {\n     covers!(macro_dollar_crate_other);\n     // From std\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         r#\"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:std\n         foo!();\n \n-        //- /std.rs\n+        //- /std.rs crate:std deps:core\n         #[prelude_import]\n         use self::prelude::*;\n \n@@ -612,7 +584,7 @@ fn macro_dollar_crate_is_correct_in_indirect_deps() {\n         #[macro_use]\n         mod std_macros;\n \n-        //- /core.rs\n+        //- /core.rs crate:core\n         #[macro_export]\n         macro_rules! foo {\n             () => {\n@@ -622,11 +594,6 @@ fn macro_dollar_crate_is_correct_in_indirect_deps() {\n \n         pub struct bar;\n         \"#,\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"std\"]),\n-            \"std\": (\"/std.rs\", [\"core\"]),\n-            \"core\": (\"/core.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n         \u22eecrate", "previous_filename": "crates/ra_hir/src/nameres/tests/macros.rs"}, {"sha": "dee364a1422fb975ba5462d30385780e43944327", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "renamed", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n #[test]\n fn name_res_works_for_broken_modules() {\n-    // covers!(name_res_works_for_broken_modules);\n+    covers!(name_res_works_for_broken_modules);\n     let map = def_map(\n         \"\n         //- /lib.rs\n@@ -54,18 +54,15 @@ fn nested_module_resolution() {\n \n #[test]\n fn module_resolution_works_for_non_standard_filenames() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /my_library.rs\n+        //- /my_library.rs crate:my_library\n         mod foo;\n         use self::foo::Bar;\n \n         //- /foo/mod.rs\n         pub struct Bar;\n         \",\n-        crate_graph! {\n-            \"my_library\": (\"/my_library.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -650,19 +647,45 @@ fn module_resolution_decl_inside_inline_module_in_non_crate_root_2() {\n \n #[test]\n fn unresolved_module_diagnostics() {\n-    let diagnostics = MockDatabase::with_files(\n+    let db = TestDB::with_files(\n         r\"\n         //- /lib.rs\n         mod foo;\n         mod bar;\n         mod baz {}\n         //- /foo.rs\n         \",\n-    )\n-    .diagnostics();\n-\n-    assert_snapshot!(diagnostics, @r###\"\n-    \"mod bar;\": unresolved module\n+    );\n+    let krate = db.crate_graph().iter().next().unwrap();\n+\n+    let crate_def_map = db.crate_def_map(krate);\n+\n+    insta::assert_debug_snapshot!(\n+        crate_def_map.diagnostics,\n+        @r###\"\n+    [\n+        UnresolvedModule {\n+            module: CrateModuleId(\n+                0,\n+            ),\n+            declaration: AstId {\n+                file_id: HirFileId(\n+                    FileId(\n+                        FileId(\n+                            0,\n+                        ),\n+                    ),\n+                ),\n+                file_ast_id: FileAstId {\n+                    raw: ErasedFileAstId(\n+                        1,\n+                    ),\n+                    _ty: PhantomData,\n+                },\n+            },\n+            candidate: \"bar.rs\",\n+        },\n+    ]\n     \"###\n     );\n }", "previous_filename": "crates/ra_hir/src/nameres/tests/mod_resolution.rs"}, {"sha": "0e27086585c3635dcc2a84027f0073bff87c2322", "filename": "crates/ra_hir_def/src/nameres/tests/primitives.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "previous_filename": "crates/ra_hir/src/nameres/tests/primitives.rs"}, {"sha": "8ee8e40d08147ced6f98fddd89df26faf36948af", "filename": "crates/ra_hir_def/src/test_db.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -0,0 +1,75 @@\n+//! Database used for testing `hir_def`.\n+\n+use std::{\n+    panic,\n+    sync::{Arc, Mutex},\n+};\n+\n+use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath};\n+\n+#[salsa::database(\n+    ra_db::SourceDatabaseExtStorage,\n+    ra_db::SourceDatabaseStorage,\n+    hir_expand::db::AstDatabaseStorage,\n+    crate::db::InternDatabaseStorage,\n+    crate::db::DefDatabase2Storage\n+)]\n+#[derive(Debug, Default)]\n+pub struct TestDB {\n+    runtime: salsa::Runtime<TestDB>,\n+    events: Mutex<Option<Vec<salsa::Event<TestDB>>>>,\n+}\n+\n+impl salsa::Database for TestDB {\n+    fn salsa_runtime(&self) -> &salsa::Runtime<Self> {\n+        &self.runtime\n+    }\n+\n+    fn salsa_event(&self, event: impl Fn() -> salsa::Event<TestDB>) {\n+        let mut events = self.events.lock().unwrap();\n+        if let Some(events) = &mut *events {\n+            events.push(event());\n+        }\n+    }\n+}\n+\n+impl panic::RefUnwindSafe for TestDB {}\n+\n+impl FileLoader for TestDB {\n+    fn file_text(&self, file_id: FileId) -> Arc<String> {\n+        FileLoaderDelegate(self).file_text(file_id)\n+    }\n+    fn resolve_relative_path(\n+        &self,\n+        anchor: FileId,\n+        relative_path: &RelativePath,\n+    ) -> Option<FileId> {\n+        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n+    }\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+        FileLoaderDelegate(self).relevant_crates(file_id)\n+    }\n+}\n+\n+impl TestDB {\n+    pub fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<TestDB>> {\n+        *self.events.lock().unwrap() = Some(Vec::new());\n+        f();\n+        self.events.lock().unwrap().take().unwrap()\n+    }\n+\n+    pub fn log_executed(&self, f: impl FnOnce()) -> Vec<String> {\n+        let events = self.log(f);\n+        events\n+            .into_iter()\n+            .filter_map(|e| match e.kind {\n+                // This pretty horrible, but `Debug` is the only way to inspect\n+                // QueryDescriptor at the moment.\n+                salsa::EventKind::WillExecute { database_key } => {\n+                    Some(format!(\"{:?}\", database_key))\n+                }\n+                _ => None,\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "201884b95745ac21b1d52c613af8ba1345b40517", "filename": "crates/ra_hir_expand/src/diagnostics.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -0,0 +1,85 @@\n+//! Semantic errors and warnings.\n+//!\n+//! The `Diagnostic` trait defines a trait object which can represent any\n+//! diagnostic.\n+//!\n+//! `DiagnosticSink` struct is used as an emitter for diagnostic. When creating\n+//! a `DiagnosticSink`, you supply a callback which can react to a `dyn\n+//! Diagnostic` or to any concrete diagnostic (downcasting is sued internally).\n+//!\n+//! Because diagnostics store file offsets, it's a bad idea to store them\n+//! directly in salsa. For this reason, every hir subsytem defines it's own\n+//! strongly-typed closed set of diagnostics which use hir ids internally, are\n+//! stored in salsa and do *not* implement the `Diagnostic` trait. Instead, a\n+//! subsystem provides a separate, non-query-based API which can walk all stored\n+//! values and transform them into instances of `Diagnostic`.\n+\n+use std::{any::Any, fmt};\n+\n+use ra_syntax::{SyntaxNode, SyntaxNodePtr, TextRange};\n+\n+use crate::{db::AstDatabase, Source};\n+\n+pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n+    fn message(&self) -> String;\n+    fn source(&self) -> Source<SyntaxNodePtr>;\n+    fn highlight_range(&self) -> TextRange {\n+        self.source().ast.range()\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static);\n+}\n+\n+pub trait AstDiagnostic {\n+    type AST;\n+    fn ast(&self, db: &impl AstDatabase) -> Self::AST;\n+}\n+\n+impl dyn Diagnostic {\n+    pub fn syntax_node(&self, db: &impl AstDatabase) -> SyntaxNode {\n+        let node = db.parse_or_expand(self.source().file_id).unwrap();\n+        self.source().ast.to_node(&node)\n+    }\n+\n+    pub fn downcast_ref<D: Diagnostic>(&self) -> Option<&D> {\n+        self.as_any().downcast_ref()\n+    }\n+}\n+\n+pub struct DiagnosticSink<'a> {\n+    callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n+    default_callback: Box<dyn FnMut(&dyn Diagnostic) + 'a>,\n+}\n+\n+impl<'a> DiagnosticSink<'a> {\n+    /// FIXME: split `new` and `on` into a separate builder type\n+    pub fn new(cb: impl FnMut(&dyn Diagnostic) + 'a) -> DiagnosticSink<'a> {\n+        DiagnosticSink { callbacks: Vec::new(), default_callback: Box::new(cb) }\n+    }\n+\n+    pub fn on<D: Diagnostic, F: FnMut(&D) + 'a>(mut self, mut cb: F) -> DiagnosticSink<'a> {\n+        let cb = move |diag: &dyn Diagnostic| match diag.downcast_ref::<D>() {\n+            Some(d) => {\n+                cb(d);\n+                Ok(())\n+            }\n+            None => Err(()),\n+        };\n+        self.callbacks.push(Box::new(cb));\n+        self\n+    }\n+\n+    pub fn push(&mut self, d: impl Diagnostic) {\n+        let d: &dyn Diagnostic = &d;\n+        self._push(d);\n+    }\n+\n+    fn _push(&mut self, d: &dyn Diagnostic) {\n+        for cb in self.callbacks.iter_mut() {\n+            match cb(d) {\n+                Ok(()) => return,\n+                Err(()) => (),\n+            }\n+        }\n+        (self.default_callback)(d)\n+    }\n+}"}, {"sha": "dd07a16b4cad2296b7e00c55549673c627feda45", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -9,11 +9,15 @@ pub mod ast_id_map;\n pub mod either;\n pub mod name;\n pub mod hygiene;\n+pub mod diagnostics;\n \n use std::hash::{Hash, Hasher};\n \n use ra_db::{salsa, CrateId, FileId};\n-use ra_syntax::ast::{self, AstNode};\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    SyntaxNode,\n+};\n \n use crate::ast_id_map::FileAstId;\n \n@@ -151,3 +155,18 @@ impl<N: AstNode> AstId<N> {\n         db.ast_id_map(self.file_id).get(self.file_ast_id).to_node(&root)\n     }\n }\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub struct Source<T> {\n+    pub file_id: HirFileId,\n+    pub ast: T,\n+}\n+\n+impl<T> Source<T> {\n+    pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n+        Source { file_id: self.file_id, ast: f(self.ast) }\n+    }\n+    pub fn file_syntax(&self, db: &impl db::AstDatabase) -> SyntaxNode {\n+        db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n+    }\n+}"}, {"sha": "fa353b5dd8f2be805361b9a08aac4eadad13f220", "filename": "crates/ra_ide_api/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2FCargo.toml?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -12,7 +12,6 @@ format-buf = \"1.0.0\"\n itertools = \"0.8.0\"\n join_to_string = \"0.1.3\"\n log = \"0.4.5\"\n-relative-path = \"1.0.0\"\n rayon = \"1.0.2\"\n fst = { version = \"0.3.1\", default-features = false }\n rustc-hash = \"1.0\""}, {"sha": "4416421ae013837a85d55561dec7908ef5d61029", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -4,13 +4,13 @@ use std::{fmt, sync::Arc, time};\n \n use ra_db::{\n     salsa::{Database, Durability, SweepStrategy},\n-    CrateGraph, CrateId, FileId, SourceDatabase, SourceDatabaseExt, SourceRoot, SourceRootId,\n+    CrateGraph, CrateId, FileId, RelativePathBuf, SourceDatabase, SourceDatabaseExt, SourceRoot,\n+    SourceRootId,\n };\n use ra_prof::{memory_usage, profile, Bytes};\n use ra_syntax::SourceFile;\n #[cfg(not(feature = \"wasm\"))]\n use rayon::prelude::*;\n-use relative_path::RelativePathBuf;\n use rustc_hash::FxHashMap;\n \n use crate::{"}, {"sha": "09ca401794eae55df799242dbcac4e5f113273ec", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -18,15 +18,15 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n     match def {\n         hir::ModuleDef::Module(module) => {\n             let module_scope = module.scope(ctx.db);\n-            for (name, res) in module_scope.entries() {\n-                if let Some(hir::ModuleDef::BuiltinType(..)) = res.def.take_types() {\n+            for (name, def, import) in module_scope {\n+                if let hir::ScopeDef::ModuleDef(hir::ModuleDef::BuiltinType(..)) = def {\n                     if ctx.use_item_syntax.is_some() {\n                         tested_by!(dont_complete_primitive_in_use);\n                         continue;\n                     }\n                 }\n                 if Some(module) == ctx.module {\n-                    if let Some(import) = res.import {\n+                    if let Some(import) = import {\n                         if let Either::A(use_tree) = module.import_source(ctx.db, import) {\n                             if use_tree.syntax().text_range().contains_inclusive(ctx.offset) {\n                                 // for `use self::foo<|>`, don't suggest `foo` as a completion\n@@ -36,7 +36,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                         }\n                     }\n                 }\n-                acc.add_resolution(ctx, name.to_string(), &res.def.into());\n+                acc.add_resolution(ctx, name.to_string(), &def);\n             }\n         }\n         hir::ModuleDef::Adt(_) | hir::ModuleDef::TypeAlias(_) => {"}, {"sha": "0295b8101373f200632aef7fbb2c61cbde159e5d", "filename": "crates/ra_ide_api/src/completion/complete_record_literal.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -31,6 +31,34 @@ mod tests {\n         do_completion(code, CompletionKind::Reference)\n     }\n \n+    #[test]\n+    fn test_record_literal_deprecated_field() {\n+        let completions = complete(\n+            r\"\n+            struct A {\n+                #[deprecated]\n+                the_field: u32,\n+            }\n+            fn foo() {\n+               A { the<|> }\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+       \u22ee[\n+       \u22ee    CompletionItem {\n+       \u22ee        label: \"the_field\",\n+       \u22ee        source_range: [142; 145),\n+       \u22ee        delete: [142; 145),\n+       \u22ee        insert: \"the_field\",\n+       \u22ee        kind: Field,\n+       \u22ee        detail: \"u32\",\n+       \u22ee        deprecated: true,\n+       \u22ee    },\n+       \u22ee]\n+        \"###);\n+    }\n+\n     #[test]\n     fn test_record_literal_field() {\n         let completions = complete("}, {"sha": "93f336370915a11db85079b13285655faacbbefa", "filename": "crates/ra_ide_api/src/completion/completion_item.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -44,6 +44,9 @@ pub struct CompletionItem {\n     /// Additional info to show in the UI pop up.\n     detail: Option<String>,\n     documentation: Option<Documentation>,\n+\n+    /// Whether this item is marked as deprecated\n+    deprecated: bool,\n }\n \n // We use custom debug for CompletionItem to make `insta`'s diffs more readable.\n@@ -70,6 +73,9 @@ impl fmt::Debug for CompletionItem {\n         if let Some(documentation) = self.documentation() {\n             s.field(\"documentation\", &documentation);\n         }\n+        if self.deprecated {\n+            s.field(\"deprecated\", &true);\n+        }\n         s.finish()\n     }\n }\n@@ -132,6 +138,7 @@ impl CompletionItem {\n             lookup: None,\n             kind: None,\n             text_edit: None,\n+            deprecated: None,\n         }\n     }\n     /// What user sees in pop-up in the UI.\n@@ -166,6 +173,10 @@ impl CompletionItem {\n     pub fn kind(&self) -> Option<CompletionItemKind> {\n         self.kind\n     }\n+\n+    pub fn deprecated(&self) -> bool {\n+        self.deprecated\n+    }\n }\n \n /// A helper to make `CompletionItem`s.\n@@ -181,6 +192,7 @@ pub(crate) struct Builder {\n     lookup: Option<String>,\n     kind: Option<CompletionItemKind>,\n     text_edit: Option<TextEdit>,\n+    deprecated: Option<bool>,\n }\n \n impl Builder {\n@@ -208,6 +220,7 @@ impl Builder {\n             lookup: self.lookup,\n             kind: self.kind,\n             completion_kind: self.completion_kind,\n+            deprecated: self.deprecated.unwrap_or(false),\n         }\n     }\n     pub(crate) fn lookup_by(mut self, lookup: impl Into<String>) -> Builder {\n@@ -254,6 +267,10 @@ impl Builder {\n         self.documentation = docs.map(Into::into);\n         self\n     }\n+    pub(crate) fn set_deprecated(mut self, deprecated: bool) -> Builder {\n+        self.deprecated = Some(deprecated);\n+        self\n+    }\n }\n \n impl<'a> Into<CompletionItem> for Builder {"}, {"sha": "cb55d18751b39ba7ba55b8a38cef310e398b877f", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -2,7 +2,7 @@\n \n use hir::{db::HirDatabase, Docs, HasSource, HirDisplay, ScopeDef, Ty, TypeWalk};\n use join_to_string::join;\n-use ra_syntax::ast::NameOwner;\n+use ra_syntax::ast::{AttrsOwner, NameOwner};\n use test_utils::tested_by;\n \n use crate::completion::{\n@@ -18,6 +18,11 @@ impl Completions {\n         field: hir::StructField,\n         substs: &hir::Substs,\n     ) {\n+        let ast_node = field.source(ctx.db).ast;\n+        let is_deprecated = match ast_node {\n+            hir::FieldSource::Named(m) => is_deprecated(m),\n+            hir::FieldSource::Pos(m) => is_deprecated(m),\n+        };\n         CompletionItem::new(\n             CompletionKind::Reference,\n             ctx.source_range(),\n@@ -26,6 +31,7 @@ impl Completions {\n         .kind(CompletionItemKind::Field)\n         .detail(field.ty(ctx.db).subst(substs).display(ctx.db).to_string())\n         .set_documentation(field.docs(ctx.db))\n+        .set_deprecated(is_deprecated)\n         .add_to(self);\n     }\n \n@@ -179,6 +185,7 @@ impl Completions {\n             CompletionItem::new(CompletionKind::Reference, ctx.source_range(), &macro_declaration)\n                 .kind(CompletionItemKind::Macro)\n                 .set_documentation(docs.clone())\n+                .set_deprecated(is_deprecated(ast_node))\n                 .detail(detail);\n \n         builder = if ctx.use_item_syntax.is_some() {\n@@ -211,6 +218,7 @@ impl Completions {\n                     CompletionItemKind::Function\n                 })\n                 .set_documentation(func.docs(ctx.db))\n+                .set_deprecated(is_deprecated(ast_node))\n                 .detail(detail);\n \n         // Add `<>` for generic types\n@@ -242,6 +250,7 @@ impl Completions {\n         CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.text().to_string())\n             .kind(CompletionItemKind::Const)\n             .set_documentation(constant.docs(ctx.db))\n+            .set_deprecated(is_deprecated(ast_node))\n             .detail(detail)\n             .add_to(self);\n     }\n@@ -257,11 +266,13 @@ impl Completions {\n         CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.text().to_string())\n             .kind(CompletionItemKind::TypeAlias)\n             .set_documentation(type_alias.docs(ctx.db))\n+            .set_deprecated(is_deprecated(type_def))\n             .detail(detail)\n             .add_to(self);\n     }\n \n     pub(crate) fn add_enum_variant(&mut self, ctx: &CompletionContext, variant: hir::EnumVariant) {\n+        let is_deprecated = is_deprecated(variant.source(ctx.db).ast);\n         let name = match variant.name(ctx.db) {\n             Some(it) => it,\n             None => return,\n@@ -274,11 +285,16 @@ impl Completions {\n         CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n             .kind(CompletionItemKind::EnumVariant)\n             .set_documentation(variant.docs(ctx.db))\n+            .set_deprecated(is_deprecated)\n             .detail(detail)\n             .add_to(self);\n     }\n }\n \n+fn is_deprecated(node: impl AttrsOwner) -> bool {\n+    node.attrs().filter_map(|x| x.simple_name()).any(|x| x == \"deprecated\")\n+}\n+\n fn has_non_default_type_params(def: hir::GenericDef, db: &db::RootDatabase) -> bool {\n     let subst = db.generic_defaults(def);\n     subst.iter().any(|ty| ty == &Ty::Unknown)\n@@ -295,6 +311,56 @@ mod tests {\n         do_completion(code, CompletionKind::Reference)\n     }\n \n+    #[test]\n+    fn sets_deprecated_flag_in_completion_items() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r#\"\n+                #[deprecated]\n+                fn something_deprecated() {}\n+\n+                #[deprecated(since = \"1.0.0\")]\n+                fn something_else_deprecated() {}\n+\n+                fn main() { som<|> }\n+                \"#,\n+            ),\n+            @r###\"\n+            [\n+                CompletionItem {\n+                    label: \"main()\",\n+                    source_range: [203; 206),\n+                    delete: [203; 206),\n+                    insert: \"main()$0\",\n+                    kind: Function,\n+                    lookup: \"main\",\n+                    detail: \"fn main()\",\n+                },\n+                CompletionItem {\n+                    label: \"something_deprecated()\",\n+                    source_range: [203; 206),\n+                    delete: [203; 206),\n+                    insert: \"something_deprecated()$0\",\n+                    kind: Function,\n+                    lookup: \"something_deprecated\",\n+                    detail: \"fn something_deprecated()\",\n+                    deprecated: true,\n+                },\n+                CompletionItem {\n+                    label: \"something_else_deprecated()\",\n+                    source_range: [203; 206),\n+                    delete: [203; 206),\n+                    insert: \"something_else_deprecated()$0\",\n+                    kind: Function,\n+                    lookup: \"something_else_deprecated\",\n+                    detail: \"fn something_else_deprecated()\",\n+                    deprecated: true,\n+                },\n+            ]\n+            \"###\n+        );\n+    }\n+\n     #[test]\n     fn inserts_parens_for_function_calls() {\n         covers!(inserts_parens_for_function_calls);"}, {"sha": "c96465b6a3d94c07d733391482ec74106112c4dc", "filename": "crates/ra_ide_api/src/db.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdb.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -4,10 +4,9 @@ use std::sync::Arc;\n \n use ra_db::{\n     salsa::{self, Database, Durability},\n-    Canceled, CheckCanceled, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase,\n-    SourceDatabaseExt, SourceRootId,\n+    Canceled, CheckCanceled, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath,\n+    SourceDatabase, SourceDatabaseExt, SourceRootId,\n };\n-use relative_path::RelativePath;\n use rustc_hash::FxHashMap;\n \n use crate::{"}, {"sha": "2890a3d2b5191f2459bef47e362aada638ded435", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -4,15 +4,14 @@ use std::cell::RefCell;\n \n use hir::diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSink};\n use itertools::Itertools;\n-use ra_db::{SourceDatabase, SourceDatabaseExt};\n+use ra_db::{RelativePath, SourceDatabase, SourceDatabaseExt};\n use ra_prof::profile;\n use ra_syntax::{\n     algo,\n     ast::{self, make, AstNode},\n     Location, SyntaxNode, TextRange, T,\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n-use relative_path::RelativePath;\n \n use crate::{db::RootDatabase, Diagnostic, FileId, FileSystemEdit, SourceChange, SourceFileEdit};\n "}, {"sha": "2b1c96dbfd5bd89edc732b51b3a56fd5ab0f6f39", "filename": "crates/ra_ide_api/src/mock_analysis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n-use relative_path::RelativePathBuf;\n+use ra_db::RelativePathBuf;\n use test_utils::{extract_offset, extract_range, parse_fixture, CURSOR_MARKER};\n \n use crate::{"}, {"sha": "11f81cbb32f490b4f0678192288e3574fc7ea7a0", "filename": "crates/ra_ide_api/src/references/rename.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1,10 +1,9 @@\n //! FIXME: write short doc here\n \n use hir::ModuleSource;\n-use ra_db::{SourceDatabase, SourceDatabaseExt};\n+use ra_db::{RelativePath, RelativePathBuf, SourceDatabase, SourceDatabaseExt};\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SyntaxNode};\n use ra_text_edit::TextEdit;\n-use relative_path::{RelativePath, RelativePathBuf};\n \n use crate::{\n     db::RootDatabase, FileId, FilePosition, FileSystemEdit, RangeInfo, SourceChange,"}, {"sha": "f5f7f8807c4425c1661c323f207854e71241bf8d", "filename": "crates/ra_ide_api/src/source_change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -3,8 +3,8 @@\n //!\n //! It can be viewed as a dual for `AnalysisChange`.\n \n+use ra_db::RelativePathBuf;\n use ra_text_edit::TextEdit;\n-use relative_path::RelativePathBuf;\n \n use crate::{FileId, FilePosition, SourceRootId, TextUnit};\n "}, {"sha": "94ed619faeca131300f02ccbe8d2fa3934738cfd", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -127,6 +127,7 @@ impl ConvWith<(&LineIndex, LineEndings)> for CompletionItem {\n             text_edit: Some(text_edit),\n             additional_text_edits: Some(additional_text_edits),\n             documentation: self.documentation().map(|it| it.conv()),\n+            deprecated: Some(self.deprecated()),\n             ..Default::default()\n         };\n         res.insert_text_format = Some(match self.insert_text_format() {"}, {"sha": "95062ef6c467a92829924e02d6563540a6cb616f", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -110,6 +110,23 @@ pub fn match_arm_list(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchAr\n     }\n }\n \n+pub fn let_match_early(expr: ast::Expr, path: &str, early_expression: &str) -> ast::LetStmt {\n+    return from_text(&format!(\n+        r#\"let {} = match {} {{\n+    {}(it) => it,\n+    None => {},\n+}};\"#,\n+        expr.syntax().text(),\n+        expr.syntax().text(),\n+        path,\n+        early_expression\n+    ));\n+\n+    fn from_text(text: &str) -> ast::LetStmt {\n+        ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n+    }\n+}\n+\n pub fn where_pred(path: ast::Path, bounds: impl Iterator<Item = ast::TypeBound>) -> ast::WherePred {\n     let bounds = bounds.map(|b| b.syntax().to_string()).join(\" + \");\n     return from_text(&format!(\"{}: {}\", path.syntax(), bounds));"}, {"sha": "14b3f707df3b612df2539558f823c329beedddf7", "filename": "crates/ra_tt/src/buffer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_tt%2Fsrc%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/crates%2Fra_tt%2Fsrc%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Fbuffer.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -111,7 +111,7 @@ impl<'a> Cursor<'a> {\n \n     /// If the cursor is pointing at the end of a subtree, returns\n     /// the parent subtree\n-    pub fn end(self) -> Option<(&'a Subtree)> {\n+    pub fn end(self) -> Option<&'a Subtree> {\n         match self.entry() {\n             Some(Entry::End(Some(ptr))) => {\n                 let idx = ptr.1;\n@@ -127,7 +127,7 @@ impl<'a> Cursor<'a> {\n         }\n     }\n \n-    fn entry(self) -> Option<(&'a Entry<'a>)> {\n+    fn entry(self) -> Option<&'a Entry<'a>> {\n         self.buffer.entry(&self.ptr)\n     }\n "}, {"sha": "71007de81b9f6787ffb086f3f28aed70e6273f79", "filename": "rustfmt.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -1,3 +1,2 @@\n reorder_modules = false\n use_small_heuristics = \"Max\"\n-newline_style = \"Unix\""}, {"sha": "227937f462a626641beb929fe4402270f5c5f2f5", "filename": "xtask/tests/tidy-tests/docs.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad9bc6caad71e6aebb92ad9883c08d30431e9b1/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs?ref=dad9bc6caad71e6aebb92ad9883c08d30431e9b1", "patch": "@@ -36,6 +36,7 @@ fn is_hidden(entry: &DirEntry) -> bool {\n fn no_docs_comments() {\n     let crates = project_root().join(\"crates\");\n     let iter = WalkDir::new(crates);\n+    let mut missing_docs = Vec::new();\n     for f in iter.into_iter().filter_entry(|e| !is_hidden(e)) {\n         let f = f.unwrap();\n         if f.file_type().is_dir() {\n@@ -54,12 +55,14 @@ fn no_docs_comments() {\n         let mut line = String::new();\n         reader.read_line(&mut line).unwrap();\n         if !line.starts_with(\"//!\") {\n-            panic!(\n-                \"\\nMissing docs strings\\n\\\n-                 module: {}\\n\\\n-                 Need add doc for module\\n\",\n-                f.path().display()\n-            )\n+            missing_docs.push(f.path().display().to_string());\n         }\n     }\n+    if !missing_docs.is_empty() {\n+        panic!(\n+            \"\\nMissing docs strings\\n\\n\\\n+             modules:\\n{}\\n\\n\",\n+            missing_docs.join(\"\\n\")\n+        )\n+    }\n }"}]}