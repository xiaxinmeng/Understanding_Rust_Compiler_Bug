{"sha": "7e4e99123a68c92f684e5c4466101c1951e86895", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNGU5OTEyM2E2OGM5MmY2ODRlNWM0NDY2MTAxYzE5NTFlODY4OTU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-07-03T21:32:41Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-07-07T18:43:23Z"}, "message": "librustc (RFC #34): Implement the new `Index` and `IndexMut` traits.\n\nThis will break code that used the old `Index` trait. Change this code\nto use the new `Index` traits. For reference, here are their signatures:\n\n    pub trait Index<Index,Result> {\n        fn index<'a>(&'a self, index: &Index) -> &'a Result;\n    }\n    pub trait IndexMut<Index,Result> {\n        fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n    }\n\nCloses #6515.\n\n[breaking-change]", "tree": {"sha": "270c38b9308597595fc05b233e25ef8252628439", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/270c38b9308597595fc05b233e25ef8252628439"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e4e99123a68c92f684e5c4466101c1951e86895", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e4e99123a68c92f684e5c4466101c1951e86895", "html_url": "https://github.com/rust-lang/rust/commit/7e4e99123a68c92f684e5c4466101c1951e86895", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e4e99123a68c92f684e5c4466101c1951e86895/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f120e6bafe971452adfede158a7957b00562a4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f120e6bafe971452adfede158a7957b00562a4e", "html_url": "https://github.com/rust-lang/rust/commit/4f120e6bafe971452adfede158a7957b00562a4e"}], "stats": {"total": 600, "additions": 433, "deletions": 167}, "files": [{"sha": "6285eb6895df05e42ac6f54f601277239ada9bf7", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -65,7 +65,7 @@ syn keyword   rustTrait       Copy Send Sized Share\n syn keyword   rustTrait       Add Sub Mul Div Rem Neg Not\n syn keyword   rustTrait       BitAnd BitOr BitXor\n syn keyword   rustTrait       Drop Deref DerefMut\n-syn keyword   rustTrait       Shl Shr Index\n+syn keyword   rustTrait       Shl Shr Index IndexMut\n syn keyword   rustEnum        Option\n syn keyword   rustEnumVariant Some None\n syn keyword   rustEnum        Result"}, {"sha": "f01b1cf9815389f1ae628f981504c6b157a0c974", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -16,14 +16,36 @@ use core::cmp;\n use core::default::Default;\n use core::fmt;\n use core::iter::Take;\n-use core::ops;\n use core::slice;\n use core::uint;\n use std::hash;\n \n use {Collection, Mutable, Set, MutableSet};\n use vec::Vec;\n \n+#[cfg(not(stage0))]\n+use core::ops::Index;\n+\n+#[cfg(not(stage0))]\n+static TRUE: bool = true;\n+\n+#[cfg(not(stage0))]\n+static FALSE: bool = false;\n+\n+#[deriving(Clone)]\n+struct SmallBitv {\n+    /// only the lowest nbits of this value are used. the rest is undefined.\n+    bits: uint\n+}\n+\n+#[deriving(Clone)]\n+struct BigBitv {\n+    storage: Vec<uint>\n+}\n+\n+#[deriving(Clone)]\n+enum BitvVariant { Big(BigBitv), Small(SmallBitv) }\n+\n /// The bitvector type\n ///\n /// # Example\n@@ -58,6 +80,18 @@ pub struct Bitv {\n     nbits: uint\n }\n \n+#[cfg(not(stage0))]\n+impl Index<uint,bool> for Bitv {\n+    #[inline]\n+    fn index<'a>(&'a self, i: &uint) -> &'a bool {\n+        if self.get(*i) {\n+            &TRUE\n+        } else {\n+            &FALSE\n+        }\n+    }\n+}\n+\n struct MaskWords<'a> {\n     iter: slice::Items<'a, uint>,\n     next_word: Option<&'a uint>,\n@@ -268,7 +302,7 @@ impl Bitv {\n             if offset >= bitv.nbits {\n                 0\n             } else {\n-                bitv[offset] as u8 << (7 - bit)\n+                bitv.get(offset) as u8 << (7 - bit)\n             }\n         }\n \n@@ -286,6 +320,13 @@ impl Bitv {\n         )\n     }\n \n+    /**\n+     * Transform `self` into a `Vec<bool>` by turning each bit into a `bool`.\n+     */\n+    pub fn to_bools(&self) -> Vec<bool> {\n+        Vec::from_fn(self.nbits, |i| self.get(i))\n+    }\n+\n     /**\n      * Compare a bitvector to a vector of `bool`.\n      *\n@@ -504,13 +545,6 @@ impl Clone for Bitv {\n     }\n }\n \n-impl ops::Index<uint,bool> for Bitv {\n-    #[inline]\n-    fn index(&self, i: &uint) -> bool {\n-        self.get(*i)\n-    }\n-}\n-\n impl fmt::Show for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self.iter() {\n@@ -1369,9 +1403,9 @@ mod tests {\n         b2.set(1, true);\n         b2.set(2, true);\n         assert!(b1.difference(&b2));\n-        assert!(b1[0]);\n-        assert!(!b1[1]);\n-        assert!(!b1[2]);\n+        assert!(b1.get(0));\n+        assert!(!b1.get(1));\n+        assert!(!b1.get(2));\n     }\n \n     #[test]\n@@ -1383,9 +1417,9 @@ mod tests {\n         b2.set(40, true);\n         b2.set(80, true);\n         assert!(b1.difference(&b2));\n-        assert!(b1[0]);\n-        assert!(!b1[40]);\n-        assert!(!b1[80]);\n+        assert!(b1.get(0));\n+        assert!(!b1.get(40));\n+        assert!(!b1.get(80));\n     }\n \n     #[test]"}, {"sha": "fc37fdde8f5855682c43fc13f035f8d7a66385fe", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -613,7 +613,7 @@ shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n /**\n  *\n  * The `Index` trait is used to specify the functionality of indexing operations\n- * like `arr[idx]`.\n+ * like `arr[idx]` when used in an immutable context.\n  *\n  * # Example\n  *\n@@ -624,9 +624,9 @@ shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n  * struct Foo;\n  *\n  * impl Index<Foo, Foo> for Foo {\n- *     fn index(&self, _rhs: &Foo) -> Foo {\n+ *     fn index<'a>(&'a self, _rhs: &Foo) -> &'a Foo {\n  *         println!(\"Indexing!\");\n- *         *self\n+ *         self\n  *     }\n  * }\n  *\n@@ -636,9 +636,42 @@ shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n  * ```\n  */\n #[lang=\"index\"]\n+#[cfg(not(stage0))]\n pub trait Index<Index,Result> {\n     /// The method for the indexing (`Foo[Bar]`) operation\n-    fn index(&self, index: &Index) -> Result;\n+    fn index<'a>(&'a self, index: &Index) -> &'a Result;\n+}\n+\n+/**\n+ *\n+ * The `IndexMut` trait is used to specify the functionality of indexing\n+ * operations like `arr[idx]`, when used in a mutable context.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `IndexMut`. When `Foo[Foo]` happens, it ends up\n+ * calling `index`, and therefore, `main` prints `Indexing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl IndexMut<Foo, Foo> for Foo {\n+ *     fn index_mut<'a>(&'a mut self, _rhs: &Foo) -> &'a mut Foo {\n+ *         println!(\"Indexing!\");\n+ *         self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     &mut Foo[Foo];\n+ * }\n+ * ```\n+ */\n+#[lang=\"index_mut\"]\n+#[cfg(not(stage0))]\n+pub trait IndexMut<Index,Result> {\n+    /// The method for the indexing (`Foo[Bar]`) operation\n+    fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n }\n \n /**"}, {"sha": "f967a2a5fa5acb450695b549b2770eff7e6e9843", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -33,7 +33,9 @@ pub use kinds::{Copy, Send, Sized, Share};\n pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Drop, Deref, DerefMut};\n-pub use ops::{Shl, Shr, Index};\n+pub use ops::{Shl, Shr};\n+#[cfg(not(stage0))]\n+pub use ops::{Index, IndexMut};\n pub use option::{Option, Some, None};\n pub use result::{Result, Ok, Err};\n "}, {"sha": "1a1d47b254770bd87293fea411963c95af53abc0", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -234,6 +234,7 @@ lets_do_this! {\n     ShlTraitLangItem,                \"shl\",                     shl_trait;\n     ShrTraitLangItem,                \"shr\",                     shr_trait;\n     IndexTraitLangItem,              \"index\",                   index_trait;\n+    IndexMutTraitLangItem,           \"index_mut\",               index_mut_trait;\n \n     UnsafeTypeLangItem,              \"unsafe\",                  unsafe_type;\n "}, {"sha": "96716ce09e0dc282332d79cfc4d876ed82cc6e8e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -443,10 +443,6 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::ExprIndex(ref base, _) => {\n-            if self.typer.is_method_call(expr.id) {\n-                return Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty));\n-            }\n-\n             let base_cmt = if_ok!(self.cat_expr(&**base));\n             Ok(self.cat_index(expr, base_cmt, 0))\n           }\n@@ -759,7 +755,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_index<N:ast_node>(&self,\n                                  elt: &N,\n-                                 base_cmt: cmt,\n+                                 mut base_cmt: cmt,\n                                  derefs: uint)\n                                  -> cmt {\n         //! Creates a cmt for an indexing operation (`[]`); this\n@@ -793,14 +789,26 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         //! - `derefs`: the deref number to be used for\n         //!   the implicit index deref, if any (see above)\n \n-        let element_ty = match ty::array_element_ty(base_cmt.ty) {\n-          Some(ref mt) => mt.ty,\n-          None => {\n-            self.tcx().sess.span_bug(\n-                elt.span(),\n-                format!(\"Explicit index of non-index type `{}`\",\n-                        base_cmt.ty.repr(self.tcx())).as_slice());\n-          }\n+        let method_call = typeck::MethodCall::expr(elt.id());\n+        let method_ty = self.typer.node_method_ty(method_call);\n+\n+        let element_ty = match method_ty {\n+            Some(method_ty) => {\n+                let ref_ty = ty::ty_fn_ret(method_ty);\n+                base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n+                *ty::ty_fn_args(method_ty).get(0)\n+            }\n+            None => {\n+                match ty::array_element_ty(base_cmt.ty) {\n+                    Some(ref mt) => mt.ty,\n+                    None => {\n+                        self.tcx().sess.span_bug(\n+                            elt.span(),\n+                            format!(\"Explicit index of non-index type `{}`\",\n+                                    base_cmt.ty.repr(self.tcx())).as_slice());\n+                    }\n+                }\n+            }\n         };\n \n         return match deref_kind(self.tcx(), base_cmt.ty) {"}, {"sha": "85e85f8ab55e0272b0fd438240085112cb7f41f4", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 91, "deletions": 36, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -396,7 +396,7 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             trans_rec_field(bcx, &**base, ident.node)\n         }\n         ast::ExprIndex(ref base, ref idx) => {\n-            trans_index(bcx, expr, &**base, &**idx)\n+            trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n         }\n         ast::ExprVstore(ref contents, ast::ExprVstoreUniq) => {\n             fcx.push_ast_cleanup_scope(contents.id);\n@@ -467,51 +467,106 @@ fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n fn trans_index<'a>(bcx: &'a Block<'a>,\n                    index_expr: &ast::Expr,\n                    base: &ast::Expr,\n-                   idx: &ast::Expr)\n+                   idx: &ast::Expr,\n+                   method_call: MethodCall)\n                    -> DatumBlock<'a, Expr> {\n     //! Translates `base[idx]`.\n \n     let _icx = push_ctxt(\"trans_index\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n \n-    let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"index\"));\n-\n-    // Translate index expression and cast to a suitable LLVM integer.\n-    // Rust is less strict than LLVM in this regard.\n-    let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n-    let ix_val = ix_datum.to_llscalarish(bcx);\n-    let ix_size = machine::llbitsize_of_real(bcx.ccx(), val_ty(ix_val));\n-    let int_size = machine::llbitsize_of_real(bcx.ccx(), ccx.int_type);\n-    let ix_val = {\n-        if ix_size < int_size {\n-            if ty::type_is_signed(expr_ty(bcx, idx)) {\n-                SExt(bcx, ix_val, ccx.int_type)\n-            } else { ZExt(bcx, ix_val, ccx.int_type) }\n-        } else if ix_size > int_size {\n-            Trunc(bcx, ix_val, ccx.int_type)\n-        } else {\n-            ix_val\n-        }\n-    };\n+    // Check for overloaded index.\n+    let method_ty = ccx.tcx\n+                       .method_map\n+                       .borrow()\n+                       .find(&method_call)\n+                       .map(|method| method.ty);\n+    let elt_datum = match method_ty {\n+        Some(method_ty) => {\n+            let base_datum = unpack_datum!(bcx, trans(bcx, base));\n \n-    let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), base_datum.ty));\n-    base::maybe_name_value(bcx.ccx(), vt.llunit_size, \"unit_sz\");\n+            // Translate index expression.\n+            let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n \n-    let (base, len) = base_datum.get_vec_base_and_len(bcx);\n+            // Overloaded. Evaluate `trans_overloaded_op`, which will\n+            // invoke the user's index() method, which basically yields\n+            // a `&T` pointer.  We can then proceed down the normal\n+            // path (below) to dereference that `&T`.\n+            let val =\n+                unpack_result!(bcx,\n+                               trans_overloaded_op(bcx,\n+                                                   index_expr,\n+                                                   method_call,\n+                                                   base_datum,\n+                                                   Some((ix_datum, idx.id)),\n+                                                   None));\n+            let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty));\n+            let elt_ty = match ty::deref(ref_ty, true) {\n+                None => {\n+                    bcx.tcx().sess.span_bug(index_expr.span,\n+                                            \"index method didn't return a \\\n+                                             dereferenceable type?!\")\n+                }\n+                Some(elt_tm) => elt_tm.ty,\n+            };\n+            Datum::new(val, elt_ty, LvalueExpr)\n+        }\n+        None => {\n+            let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx,\n+                                                                base,\n+                                                                \"index\"));\n+\n+            // Translate index expression and cast to a suitable LLVM integer.\n+            // Rust is less strict than LLVM in this regard.\n+            let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n+            let ix_val = ix_datum.to_llscalarish(bcx);\n+            let ix_size = machine::llbitsize_of_real(bcx.ccx(),\n+                                                     val_ty(ix_val));\n+            let int_size = machine::llbitsize_of_real(bcx.ccx(),\n+                                                      ccx.int_type);\n+            let ix_val = {\n+                if ix_size < int_size {\n+                    if ty::type_is_signed(expr_ty(bcx, idx)) {\n+                        SExt(bcx, ix_val, ccx.int_type)\n+                    } else { ZExt(bcx, ix_val, ccx.int_type) }\n+                } else if ix_size > int_size {\n+                    Trunc(bcx, ix_val, ccx.int_type)\n+                } else {\n+                    ix_val\n+                }\n+            };\n \n-    debug!(\"trans_index: base {}\", bcx.val_to_str(base));\n-    debug!(\"trans_index: len {}\", bcx.val_to_str(len));\n+            let vt =\n+                tvec::vec_types(bcx,\n+                                ty::sequence_element_type(bcx.tcx(),\n+                                                          base_datum.ty));\n+            base::maybe_name_value(bcx.ccx(), vt.llunit_size, \"unit_sz\");\n+\n+            let (base, len) = base_datum.get_vec_base_and_len(bcx);\n+\n+            debug!(\"trans_index: base {}\", bcx.val_to_str(base));\n+            debug!(\"trans_index: len {}\", bcx.val_to_str(len));\n+\n+            let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n+            let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n+            let expected = Call(bcx,\n+                                expect,\n+                                [bounds_check, C_bool(ccx, false)],\n+                                []);\n+            bcx = with_cond(bcx, expected, |bcx| {\n+                controlflow::trans_fail_bounds_check(bcx,\n+                                                     index_expr.span,\n+                                                     ix_val,\n+                                                     len)\n+            });\n+            let elt = InBoundsGEP(bcx, base, [ix_val]);\n+            let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n+            Datum::new(elt, vt.unit_ty, LvalueExpr)\n+        }\n+    };\n \n-    let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n-    let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-    let expected = Call(bcx, expect, [bounds_check, C_bool(ccx, false)], []);\n-    let bcx = with_cond(bcx, expected, |bcx| {\n-            controlflow::trans_fail_bounds_check(bcx, index_expr.span, ix_val, len)\n-        });\n-    let elt = InBoundsGEP(bcx, base, [ix_val]);\n-    let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n-    DatumBlock::new(bcx, Datum::new(elt, vt.unit_ty, LvalueExpr))\n+    DatumBlock::new(bcx, elt_datum)\n }\n \n fn trans_def<'a>(bcx: &'a Block<'a>,\n@@ -1756,7 +1811,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n         Some(method_ty) => {\n             // Overloaded. Evaluate `trans_overloaded_op`, which will\n             // invoke the user's deref() method, which basically\n-            // converts from the `Shaht<T>` pointer that we have into\n+            // converts from the `Smaht<T>` pointer that we have into\n             // a `&T` pointer.  We can then proceed down the normal\n             // path (below) to dereference that `&T`.\n             let datum = match method_call.adjustment {"}, {"sha": "282ccf1155df0a5ab4d2fa15d508acd3388bc53f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -3030,6 +3030,9 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             // the deref method invoked for `*a` always yields an `&T`\n             ast::ExprUnary(ast::UnDeref, _) => LvalueExpr,\n \n+            // the index method invoked for `a[i]` always yields an `&T`\n+            ast::ExprIndex(..) => LvalueExpr,\n+\n             // in the general case, result could be any type, use DPS\n             _ => RvalueDpsExpr\n         };"}, {"sha": "a581783221290cee376bcef8273fdd9d99665393", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 98, "deletions": 22, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -1629,6 +1629,76 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n     }\n }\n \n+fn try_overloaded_index(fcx: &FnCtxt,\n+                        method_call: Option<MethodCall>,\n+                        expr: &ast::Expr,\n+                        base_expr: Gc<ast::Expr>,\n+                        base_ty: ty::t,\n+                        index_expr: Gc<ast::Expr>,\n+                        lvalue_pref: LvaluePreference)\n+                        -> Option<ty::mt> {\n+    // Try `IndexMut` first, if preferred.\n+    let method = match (lvalue_pref, fcx.tcx().lang_items.index_mut_trait()) {\n+        (PreferMutLvalue, Some(trait_did)) => {\n+            method::lookup_in_trait(fcx,\n+                                    expr.span,\n+                                    Some(&*base_expr),\n+                                    token::intern(\"index_mut\"),\n+                                    trait_did,\n+                                    base_ty,\n+                                    [],\n+                                    DontAutoderefReceiver,\n+                                    IgnoreStaticMethods)\n+        }\n+        _ => None,\n+    };\n+\n+    // Otherwise, fall back to `Index`.\n+    let method = match (method, fcx.tcx().lang_items.index_trait()) {\n+        (None, Some(trait_did)) => {\n+            method::lookup_in_trait(fcx,\n+                                    expr.span,\n+                                    Some(&*base_expr),\n+                                    token::intern(\"index\"),\n+                                    trait_did,\n+                                    base_ty,\n+                                    [],\n+                                    DontAutoderefReceiver,\n+                                    IgnoreStaticMethods)\n+        }\n+        (method, _) => method,\n+    };\n+\n+    // Regardless of whether the lookup succeeds, check the method arguments\n+    // so that we have *some* type for each argument.\n+    let method_type = match method {\n+        Some(ref method) => method.ty,\n+        None => ty::mk_err()\n+    };\n+    check_method_argument_types(fcx,\n+                                expr.span,\n+                                method_type,\n+                                expr,\n+                                [base_expr, index_expr],\n+                                DoDerefArgs,\n+                                DontTupleArguments);\n+\n+    match method {\n+        Some(method) => {\n+            let ref_ty = ty::ty_fn_ret(method.ty);\n+            match method_call {\n+                Some(method_call) => {\n+                    fcx.inh.method_map.borrow_mut().insert(method_call,\n+                                                           method);\n+                }\n+                None => {}\n+            }\n+            ty::deref(ref_ty, true)\n+        }\n+        None => None,\n+    }\n+}\n+\n fn check_method_argument_types(fcx: &FnCtxt,\n                                sp: Span,\n                                method_fn_ty: ty::t,\n@@ -3323,7 +3393,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           } else if ty::type_is_error(idx_t) || ty::type_is_bot(idx_t) {\n               fcx.write_ty(id, idx_t);\n           } else {\n-              let (base_t, autoderefs, field_ty) =\n+              let (_, autoderefs, field_ty) =\n                 autoderef(fcx, expr.span, raw_base_t, Some(base.id),\n                           lvalue_pref, |base_t, _| ty::index(base_t));\n               match field_ty {\n@@ -3333,27 +3403,33 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                       fcx.write_autoderef_adjustment(base.id, autoderefs);\n                   }\n                   None => {\n-                      let resolved = structurally_resolved_type(fcx,\n-                                                                expr.span,\n-                                                                raw_base_t);\n-                      let ret_ty = lookup_op_method(fcx,\n-                                                    expr,\n-                                                    resolved,\n-                                                    token::intern(\"index\"),\n-                                                    tcx.lang_items.index_trait(),\n-                                                    [base.clone(), idx.clone()],\n-                                                    AutoderefReceiver,\n-                                                    || {\n-                        fcx.type_error_message(expr.span,\n-                                               |actual| {\n-                                                    format!(\"cannot index a \\\n-                                                             value of type \\\n-                                                             `{}`\", actual)\n-                                               },\n-                                               base_t,\n-                                               None);\n-                      });\n-                      fcx.write_ty(id, ret_ty);\n+                      // This is an overloaded method.\n+                      let base_t = structurally_resolved_type(fcx,\n+                                                              expr.span,\n+                                                              raw_base_t);\n+                      let method_call = MethodCall::expr(expr.id);\n+                      match try_overloaded_index(fcx,\n+                                                 Some(method_call),\n+                                                 expr,\n+                                                 *base,\n+                                                 base_t,\n+                                                 *idx,\n+                                                 lvalue_pref) {\n+                          Some(mt) => fcx.write_ty(id, mt.ty),\n+                          None => {\n+                                fcx.type_error_message(expr.span,\n+                                                       |actual| {\n+                                                        format!(\"cannot \\\n+                                                                 index a \\\n+                                                                 value of \\\n+                                                                 type `{}`\",\n+                                                                actual)\n+                                                       },\n+                                                       base_t,\n+                                                       None);\n+                                fcx.write_ty(id, ty::mk_err())\n+                          }\n+                      }\n                   }\n               }\n           }"}, {"sha": "28cd7223b0ac6c1f3e3a78f80cbc8f816539cc6e", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -44,7 +44,8 @@\n #[doc(no_inline)] pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n #[doc(no_inline)] pub use ops::{BitAnd, BitOr, BitXor};\n #[doc(no_inline)] pub use ops::{Drop, Deref, DerefMut};\n-#[doc(no_inline)] pub use ops::{Shl, Shr, Index};\n+#[doc(no_inline)] pub use ops::{Shl, Shr};\n+#[doc(no_inline)] #[cfg(not(stage0))] pub use ops::{Index, IndexMut};\n #[doc(no_inline)] pub use option::{Option, Some, None};\n #[doc(no_inline)] pub use result::{Result, Ok, Err};\n "}, {"sha": "934c4f52af00d5f99f20f49f7dd9e8a6fedf4d21", "filename": "src/test/auxiliary/issue2378a.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f120e6bafe971452adfede158a7957b00562a4e/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f120e6bafe971452adfede158a7957b00562a4e/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378a.rs?ref=4f120e6bafe971452adfede158a7957b00562a4e", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_type = \"lib\"]\n-\n-pub enum maybe<T> { just(T), nothing }\n-\n-impl <T:Clone> Index<uint,T> for maybe<T> {\n-    fn index(&self, _idx: &uint) -> T {\n-        match self {\n-            &just(ref t) => (*t).clone(),\n-            &nothing => { fail!(); }\n-        }\n-    }\n-}"}, {"sha": "03f685c949a4bac02161c05a1a1e6fd8571e04a0", "filename": "src/test/auxiliary/issue2378b.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f120e6bafe971452adfede158a7957b00562a4e/src%2Ftest%2Fauxiliary%2Fissue2378b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f120e6bafe971452adfede158a7957b00562a4e/src%2Ftest%2Fauxiliary%2Fissue2378b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378b.rs?ref=4f120e6bafe971452adfede158a7957b00562a4e", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_type = \"lib\"]\n-\n-extern crate issue2378a;\n-\n-use issue2378a::maybe;\n-\n-pub struct two_maybes<T> {pub a: maybe<T>, pub b: maybe<T>}\n-\n-impl<T:Clone> Index<uint,(T,T)> for two_maybes<T> {\n-    fn index(&self, idx: &uint) -> (T, T) {\n-        (self.a[*idx], self.b[*idx])\n-    }\n-}"}, {"sha": "d34aa1cd9cbd3d031e7e9d9c2fd791c7730afaf4", "filename": "src/test/compile-fail/borrowck-overloaded-index.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+    x: int,\n+    y: int,\n+}\n+\n+impl Index<String,int> for Foo {\n+    fn index<'a>(&'a self, z: &String) -> &'a int {\n+        if z.as_slice() == \"x\" {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n+    }\n+}\n+\n+impl IndexMut<String,int> for Foo {\n+    fn index_mut<'a>(&'a mut self, z: &String) -> &'a mut int {\n+        if z.as_slice() == \"x\" {\n+            &mut self.x\n+        } else {\n+            &mut self.y\n+        }\n+    }\n+}\n+\n+struct Bar {\n+    x: int,\n+}\n+\n+impl Index<int,int> for Bar {\n+    fn index<'a>(&'a self, z: &int) -> &'a int {\n+        &self.x\n+    }\n+}\n+\n+fn main() {\n+    let mut f = Foo {\n+        x: 1,\n+        y: 2,\n+    };\n+    let mut s = \"hello\".to_string();\n+    let rs = &mut s;\n+    println!(\"{}\", f[s]);\n+    //~^ ERROR cannot borrow `s` as immutable because it is also borrowed as mutable\n+    f[s] = 10;\n+    //~^ ERROR cannot borrow `s` as immutable because it is also borrowed as mutable\n+    let s = Bar {\n+        x: 1,\n+    };\n+    s[2] = 20;\n+    //~^ ERROR cannot assign to immutable indexed content\n+}\n+\n+"}, {"sha": "10d6e0158f6f225ff2f69cfff12b88d85385b6c8", "filename": "src/test/run-pass/issue-11736.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11736.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -16,13 +16,13 @@ use std::collections::Bitv;\n fn main() {\n     // Generate sieve of Eratosthenes for n up to 1e6\n     let n = 1000000u;\n-    let sieve = Bitv::with_capacity(n+1, true);\n+    let mut sieve = Bitv::with_capacity(n+1, true);\n     let limit: uint = (n as f32).sqrt() as uint;\n     for i in range(2, limit+1) {\n         if sieve[i] {\n             let mut j = 0;\n             while i*i + j*i <= n {\n-                sieve[i*i+j*i] = false;\n+                sieve.set(i*i+j*i, false);\n                 j += 1;\n             }\n         }"}, {"sha": "c453a538c7e2baa874824dc565a4ba70ae6275a6", "filename": "src/test/run-pass/issue2378c.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f120e6bafe971452adfede158a7957b00562a4e/src%2Ftest%2Frun-pass%2Fissue2378c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f120e6bafe971452adfede158a7957b00562a4e/src%2Ftest%2Frun-pass%2Fissue2378c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue2378c.rs?ref=4f120e6bafe971452adfede158a7957b00562a4e", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// aux-build:issue2378a.rs\n-// aux-build:issue2378b.rs\n-\n-extern crate issue2378a;\n-extern crate issue2378b;\n-\n-use issue2378a::{just};\n-use issue2378b::{two_maybes};\n-\n-pub fn main() {\n-    let x = two_maybes{a: just(3i), b: just(5i)};\n-    assert_eq!(x[0u], (3, 5));\n-}"}, {"sha": "a36d8132b260a86cd50fed157f02e2184122c1d5", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -43,8 +43,12 @@ impl ops::Not<Point> for Point {\n }\n \n impl ops::Index<bool,int> for Point {\n-    fn index(&self, x: &bool) -> int {\n-        if *x { self.x } else { self.y }\n+    fn index<'a>(&'a self, x: &bool) -> &'a int {\n+        if *x {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n     }\n }\n "}, {"sha": "6b1ac0b821c44646d8adf570f2a3ee37050e9f4e", "filename": "src/test/run-pass/overload-index-operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -31,10 +31,10 @@ impl<K,V> AssociationList<K,V> {\n }\n \n impl<K:PartialEq,V:Clone> Index<K,V> for AssociationList<K,V> {\n-    fn index(&self, index: &K) -> V {\n+    fn index<'a>(&'a self, index: &K) -> &'a V {\n         for pair in self.pairs.iter() {\n             if pair.key == *index {\n-                return pair.value.clone();\n+                return &pair.value\n             }\n         }\n         fail!(\"No value found for key: {:?}\", index);"}, {"sha": "9d7c068cccd937e092988b3d0be7808ea9272248", "filename": "src/test/run-pass/overloaded-index.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4e99123a68c92f684e5c4466101c1951e86895/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index.rs?ref=7e4e99123a68c92f684e5c4466101c1951e86895", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+    x: int,\n+    y: int,\n+}\n+\n+impl Index<int,int> for Foo {\n+    fn index<'a>(&'a self, z: &int) -> &'a int {\n+        if *z == 0 {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n+    }\n+}\n+\n+impl IndexMut<int,int> for Foo {\n+    fn index_mut<'a>(&'a mut self, z: &int) -> &'a mut int {\n+        if *z == 0 {\n+            &mut self.x\n+        } else {\n+            &mut self.y\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut f = Foo {\n+        x: 1,\n+        y: 2,\n+    };\n+    assert_eq!(f[1], 2);\n+    f[0] = 3;\n+    assert_eq!(f[0], 3);\n+    {\n+        let p = &mut f[1];\n+        *p = 4;\n+    }\n+    {\n+        let p = &f[1];\n+        assert_eq!(*p, 4);\n+    }\n+}\n+"}]}