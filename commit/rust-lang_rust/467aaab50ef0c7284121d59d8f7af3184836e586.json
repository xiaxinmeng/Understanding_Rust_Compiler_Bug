{"sha": "467aaab50ef0c7284121d59d8f7af3184836e586", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2N2FhYWI1MGVmMGM3Mjg0MTIxZDU5ZDhmN2FmMzE4NDgzNmU1ODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-19T08:40:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-19T08:40:27Z"}, "message": "Auto merge of #41325 - eddyb:isolate-snapshots-for-good, r=arielb1\n\nBan registering obligations during InferCtxt snapshots.\n\nBack in #33852, a flag was added to `InferCtxt` to prevent rolling back a snapshot if obligations were added to some `FulfillmentContext` during the snapshot, to prevent leaking fresh inference variables (created during that snapshot, so their indices would get reused) in obligations, which could ICE or worse.\n\nBut that isn't enough in the long run, as type-checking ends up relying on success implying that eager side-effects are fine, and while stray obligations *do* get caught nowadays, those errors prevent, e.g. the speculative coercions from #37658, which *have to* be rolled back *even* if they succeed.\n\nWe can't just allow those obligations to stay around though, because we end up, again, in ICEs or worse.\nInstead, this PR modifies `lookup_method_in_trait_adjusted` to return `InferOk` containing the obligations that `Autoderef::finalize_as_infer_ok` can propagate to deref coercions.\n\nAs there shouldn't be *anything* left that registers obligations during snapshots, it's completely banned.\n\nr? @nikomatsakis @arielb1", "tree": {"sha": "c68f780aaf8b83de6b7cd5dc9fe7e68d9446e1ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c68f780aaf8b83de6b7cd5dc9fe7e68d9446e1ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/467aaab50ef0c7284121d59d8f7af3184836e586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/467aaab50ef0c7284121d59d8f7af3184836e586", "html_url": "https://github.com/rust-lang/rust/commit/467aaab50ef0c7284121d59d8f7af3184836e586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/467aaab50ef0c7284121d59d8f7af3184836e586/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f22d46e4bea4b5a335c671c61c96f00a5b3f554", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f22d46e4bea4b5a335c671c61c96f00a5b3f554", "html_url": "https://github.com/rust-lang/rust/commit/5f22d46e4bea4b5a335c671c61c96f00a5b3f554"}, {"sha": "cd64ff943889b1cda1029a4a0d906d934a47abeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd64ff943889b1cda1029a4a0d906d934a47abeb", "html_url": "https://github.com/rust-lang/rust/commit/cd64ff943889b1cda1029a4a0d906d934a47abeb"}], "stats": {"total": 396, "additions": 190, "deletions": 206}, "files": [{"sha": "a1bafe113e415cb90a30a0b2522c7df2b03ded98", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -199,10 +199,8 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // `tained_by_errors`) to avoid reporting certain kinds of errors.\n     err_count_on_creation: usize,\n \n-    // This flag is used for debugging, and is set to true if there are\n-    // any obligations set during the current snapshot. In that case, the\n-    // snapshot can't be rolled back.\n-    pub obligations_in_snapshot: Cell<bool>,\n+    // This flag is true while there is an active snapshot.\n+    in_snapshot: Cell<bool>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -507,7 +505,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             projection_mode: Reveal::UserFacing,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n-            obligations_in_snapshot: Cell::new(false),\n+            in_snapshot: Cell::new(false),\n         }\n     }\n }\n@@ -545,7 +543,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             projection_mode: projection_mode,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n-            obligations_in_snapshot: Cell::new(false),\n+            in_snapshot: Cell::new(false),\n         }))\n     }\n }\n@@ -573,7 +571,7 @@ pub struct CombinedSnapshot {\n     int_snapshot: unify::Snapshot<ty::IntVid>,\n     float_snapshot: unify::Snapshot<ty::FloatVid>,\n     region_vars_snapshot: RegionSnapshot,\n-    obligations_in_snapshot: bool,\n+    was_in_snapshot: bool,\n }\n \n /// Helper trait for shortening the lifetimes inside a\n@@ -734,6 +732,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.projection_mode\n     }\n \n+    pub fn is_in_snapshot(&self) -> bool {\n+        self.in_snapshot.get()\n+    }\n+\n     pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }\n@@ -861,46 +863,45 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n-    // Clear the \"obligations in snapshot\" flag, invoke the closure,\n+    // Clear the \"currently in a snapshot\" flag, invoke the closure,\n     // then restore the flag to its original value. This flag is a\n     // debugging measure designed to detect cases where we start a\n-    // snapshot, create type variables, register obligations involving\n-    // those type variables in the fulfillment cx, and then have to\n-    // unroll the snapshot, leaving \"dangling type variables\" behind.\n-    // In such cases, the flag will be set by the fulfillment cx, and\n-    // an assertion will fail when rolling the snapshot back.  Very\n-    // useful, much better than grovelling through megabytes of\n-    // RUST_LOG output.\n+    // snapshot, create type variables, and register obligations\n+    // which may involve those type variables in the fulfillment cx,\n+    // potentially leaving \"dangling type variables\" behind.\n+    // In such cases, an assertion will fail when attempting to\n+    // register obligations, within a snapshot. Very useful, much\n+    // better than grovelling through megabytes of RUST_LOG output.\n     //\n-    // HOWEVER, in some cases the flag is wrong. In particular, we\n+    // HOWEVER, in some cases the flag is unhelpful. In particular, we\n     // sometimes create a \"mini-fulfilment-cx\" in which we enroll\n     // obligations. As long as this fulfillment cx is fully drained\n     // before we return, this is not a problem, as there won't be any\n     // escaping obligations in the main cx. In those cases, you can\n     // use this function.\n-    pub fn save_and_restore_obligations_in_snapshot_flag<F, R>(&self, func: F) -> R\n+    pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n         where F: FnOnce(&Self) -> R\n     {\n-        let flag = self.obligations_in_snapshot.get();\n-        self.obligations_in_snapshot.set(false);\n+        let flag = self.in_snapshot.get();\n+        self.in_snapshot.set(false);\n         let result = func(self);\n-        self.obligations_in_snapshot.set(flag);\n+        self.in_snapshot.set(flag);\n         result\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n         debug!(\"start_snapshot()\");\n \n-        let obligations_in_snapshot = self.obligations_in_snapshot.get();\n-        self.obligations_in_snapshot.set(false);\n+        let in_snapshot = self.in_snapshot.get();\n+        self.in_snapshot.set(true);\n \n         CombinedSnapshot {\n             projection_cache_snapshot: self.projection_cache.borrow_mut().snapshot(),\n             type_snapshot: self.type_variables.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_vars_snapshot: self.region_vars.start_snapshot(),\n-            obligations_in_snapshot: obligations_in_snapshot,\n+            was_in_snapshot: in_snapshot,\n         }\n     }\n \n@@ -911,10 +912,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n-                               obligations_in_snapshot } = snapshot;\n+                               was_in_snapshot } = snapshot;\n \n-        assert!(!self.obligations_in_snapshot.get());\n-        self.obligations_in_snapshot.set(obligations_in_snapshot);\n+        self.in_snapshot.set(was_in_snapshot);\n \n         self.projection_cache\n             .borrow_mut()\n@@ -939,9 +939,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n-                               obligations_in_snapshot } = snapshot;\n+                               was_in_snapshot } = snapshot;\n \n-        self.obligations_in_snapshot.set(obligations_in_snapshot);\n+        self.in_snapshot.set(was_in_snapshot);\n \n         self.projection_cache\n             .borrow_mut()"}, {"sha": "d771be077ae3a403aeb830a216ea5a2d12f7f1fb", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n         debug!(\"register_predicate_obligation(obligation={:?})\", obligation);\n \n-        infcx.obligations_in_snapshot.set(true);\n+        assert!(!infcx.is_in_snapshot());\n \n         if infcx.tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n             debug!(\"register_predicate_obligation: duplicate\");"}, {"sha": "92b7c736d42fda8e676ad48cbaa0554ab83d4938", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -242,7 +242,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n \n-    infcx.save_and_restore_obligations_in_snapshot_flag(|infcx| {\n+    infcx.save_and_restore_in_snapshot_flag(|infcx| {\n         let mut fulfill_cx = FulfillmentContext::new();\n         for oblig in obligations.into_iter() {\n             fulfill_cx.register_predicate_obligation(&infcx, oblig);"}, {"sha": "9610477d8fd919f26e49a37c1130a4e4375eaef5", "filename": "src/librustc_typeck/check/assoc.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5f22d46e4bea4b5a335c671c61c96f00a5b3f554/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f22d46e4bea4b5a335c671c61c96f00a5b3f554/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=5f22d46e4bea4b5a335c671c61c96f00a5b3f554", "patch": "@@ -1,39 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::infer::InferCtxt;\n-use rustc::traits::{self, FulfillmentContext, Normalized, MiscObligation, SelectionContext,\n-                    ObligationCause};\n-use rustc::ty::fold::TypeFoldable;\n-use syntax::ast;\n-use syntax_pos::Span;\n-\n-// FIXME(@jroesch): Ideally we should be able to drop the fulfillment_cx argument.\n-pub fn normalize_associated_types_in<'a, 'gcx, 'tcx, T>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    fulfillment_cx: &mut FulfillmentContext<'tcx>,\n-    span: Span,\n-    body_id: ast::NodeId,\n-    value: &T) -> T\n-\n-    where T : TypeFoldable<'tcx>\n-{\n-    debug!(\"normalize_associated_types_in(value={:?})\", value);\n-    let mut selcx = SelectionContext::new(infcx);\n-    let cause = ObligationCause::new(span, body_id, MiscObligation);\n-    let Normalized { value: result, obligations } = traits::normalize(&mut selcx, cause, value);\n-    debug!(\"normalize_associated_types_in: result={:?} predicates={:?}\",\n-           result,\n-           obligations);\n-    for obligation in obligations {\n-        fulfillment_cx.register_predicate_obligation(infcx, obligation);\n-    }\n-    result\n-}"}, {"sha": "92fb02c6379dcea41f5507644e7ce53be53f47ea", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -149,22 +149,25 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         self.fcx.resolve_type_vars_if_possible(&self.cur_ty)\n     }\n \n-    pub fn finalize<E>(self, pref: LvaluePreference, exprs: &[E])\n-        where E: AsCoercionSite\n-    {\n+    pub fn finalize(self, pref: LvaluePreference, expr: &hir::Expr) {\n         let fcx = self.fcx;\n-        fcx.register_infer_ok_obligations(self.finalize_as_infer_ok(pref, exprs));\n+        fcx.register_infer_ok_obligations(self.finalize_as_infer_ok(pref, &[expr]));\n     }\n \n     pub fn finalize_as_infer_ok<E>(self, pref: LvaluePreference, exprs: &[E])\n                                    -> InferOk<'tcx, ()>\n         where E: AsCoercionSite\n     {\n-        let methods: Vec<_> = self.steps\n+        let Autoderef { fcx, span, mut obligations, steps, .. } = self;\n+        let methods: Vec<_> = steps\n             .iter()\n             .map(|&(ty, kind)| {\n                 if let AutoderefKind::Overloaded = kind {\n-                    self.fcx.try_overloaded_deref(self.span, None, ty, pref)\n+                    fcx.try_overloaded_deref(span, None, ty, pref)\n+                        .map(|InferOk { value, obligations: o }| {\n+                            obligations.extend(o);\n+                            value\n+                        })\n                 } else {\n                     None\n                 }\n@@ -174,22 +177,22 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         debug!(\"finalize({:?}) - {:?},{:?}\",\n                pref,\n                methods,\n-               self.obligations);\n+               obligations);\n \n         for expr in exprs {\n             let expr = expr.as_coercion_site();\n             debug!(\"finalize - finalizing #{} - {:?}\", expr.id, expr);\n             for (n, method) in methods.iter().enumerate() {\n                 if let &Some(method) = method {\n                     let method_call = MethodCall::autoderef(expr.id, n as u32);\n-                    self.fcx.tables.borrow_mut().method_map.insert(method_call, method);\n+                    fcx.tables.borrow_mut().method_map.insert(method_call, method);\n                 }\n             }\n         }\n \n         InferOk {\n             value: (),\n-            obligations: self.obligations\n+            obligations\n         }\n     }\n }\n@@ -211,7 +214,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 base_expr: Option<&hir::Expr>,\n                                 base_ty: Ty<'tcx>,\n                                 lvalue_pref: LvaluePreference)\n-                                -> Option<MethodCallee<'tcx>> {\n+                                -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(\"try_overloaded_deref({:?},{:?},{:?},{:?})\",\n                span,\n                base_expr,"}, {"sha": "32f130aca1cb91076725d4f659692fe6f6e9ddc2", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             })\n             .next();\n         let callee_ty = autoderef.unambiguous_final_ty();\n-        autoderef.finalize(LvaluePreference::NoPreference, &[callee_expr]);\n+        autoderef.finalize(LvaluePreference::NoPreference, callee_expr);\n \n         let output = match result {\n             None => {\n@@ -173,7 +173,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                        adjusted_ty,\n                                                        None) {\n                 None => continue,\n-                Some(method_callee) => {\n+                Some(ok) => {\n+                    let method_callee = self.register_infer_ok_obligations(ok);\n                     return Some(method_callee);\n                 }\n             }"}, {"sha": "c6a1f6cfc0d7fff01b72258e9ce19969dbd4ab55", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -711,16 +711,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n         let coerce = Coerce::new(self, cause);\n-        self.commit_if_ok(|_| {\n-            let ok = coerce.coerce(&[expr], source, target)?;\n-            let adjustment = self.register_infer_ok_obligations(ok);\n-            self.apply_adjustment(expr.id, adjustment);\n-\n-            // We should now have added sufficient adjustments etc to\n-            // ensure that the type of expression, post-adjustment, is\n-            // a subtype of target.\n-            Ok(target)\n-        })\n+        let ok = self.commit_if_ok(|_| coerce.coerce(&[expr], source, target))?;\n+\n+        let adjustment = self.register_infer_ok_obligations(ok);\n+        self.apply_adjustment(expr.id, adjustment);\n+\n+        // We should now have added sufficient adjustments etc to\n+        // ensure that the type of expression, post-adjustment, is\n+        // a subtype of target.\n+        Ok(target)\n     }\n \n     /// Given some expressions, their known unified type and another expression,"}, {"sha": "8a6853461a5e847d15c465fe14f494a6edead243", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 25, "deletions": 39, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -20,7 +20,6 @@ use rustc::util::common::ErrorReported;\n use syntax::ast;\n use syntax_pos::Span;\n \n-use super::assoc;\n use super::{Inherited, FnCtxt};\n use astconv::ExplicitSelf;\n \n@@ -227,7 +226,6 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.infer_ctxt(trait_param_env, Reveal::UserFacing).enter(|infcx| {\n         let inh = Inherited::new(infcx);\n         let infcx = &inh.infcx;\n-        let fulfillment_cx = &inh.fulfillment_cx;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\",\n                infcx.parameter_environment.caller_bounds);\n@@ -239,12 +237,11 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                        infer::HigherRankedType,\n                                                        &ty::Binder(impl_m_own_bounds.predicates));\n         for predicate in impl_m_own_bounds {\n-            let traits::Normalized { value: predicate, .. } =\n+            let traits::Normalized { value: predicate, obligations } =\n                 traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n \n-            fulfillment_cx.borrow_mut().register_predicate_obligation(\n-                &infcx,\n-                traits::Obligation::new(cause.clone(), predicate));\n+            inh.register_predicates(obligations);\n+            inh.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n         }\n \n         // We now need to check that the signature of the impl method is\n@@ -277,11 +274,9 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let impl_sig =\n             impl_sig.subst(tcx, impl_to_skol_substs);\n         let impl_sig =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &mut fulfillment_cx.borrow_mut(),\n-                                                 impl_m_span,\n-                                                 impl_m_body_id,\n-                                                 &impl_sig);\n+            inh.normalize_associated_types_in(impl_m_span,\n+                                              impl_m_body_id,\n+                                              &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n@@ -291,11 +286,9 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let trait_sig =\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &mut fulfillment_cx.borrow_mut(),\n-                                                 impl_m_span,\n-                                                 impl_m_body_id,\n-                                                 &trait_sig);\n+            inh.normalize_associated_types_in(impl_m_span,\n+                                              impl_m_body_id,\n+                                              &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder(trait_sig));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n@@ -344,7 +337,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        if let Err(ref errors) = fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n+        if let Err(ref errors) = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n             infcx.report_fulfillment_errors(errors);\n             return Err(ErrorReported);\n         }\n@@ -731,7 +724,8 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n-        let mut fulfillment_cx = traits::FulfillmentContext::new();\n+        let inh = Inherited::new(infcx);\n+        let infcx = &inh.infcx;\n \n         // The below is for the most part highly similar to the procedure\n         // for methods above. It is simpler in many respects, especially\n@@ -761,31 +755,21 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let trait_ty = tcx.item_type(trait_c.def_id).subst(tcx, trait_to_skol_substs);\n         let mut cause = ObligationCause::misc(impl_c_span, impl_c_node_id);\n \n-        let err = infcx.commit_if_ok(|_| {\n-            // There is no \"body\" here, so just pass dummy id.\n-            let impl_ty = assoc::normalize_associated_types_in(&infcx,\n-                                                               &mut fulfillment_cx,\n-                                                               impl_c_span,\n-                                                               ast::CRATE_NODE_ID,\n-                                                               &impl_ty);\n+        // There is no \"body\" here, so just pass dummy id.\n+        let impl_ty = inh.normalize_associated_types_in(impl_c_span,\n+                                                        impl_c_node_id,\n+                                                        &impl_ty);\n \n-            debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n+        debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n-            let trait_ty = assoc::normalize_associated_types_in(&infcx,\n-                                                                &mut fulfillment_cx,\n-                                                                impl_c_span,\n-                                                                ast::CRATE_NODE_ID,\n-                                                                &trait_ty);\n+        let trait_ty = inh.normalize_associated_types_in(impl_c_span,\n+                                                         impl_c_node_id,\n+                                                         &trait_ty);\n \n-            debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n+        debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-            infcx.sub_types(false, &cause, impl_ty, trait_ty)\n-                 .map(|InferOk { obligations, value: () }| {\n-                     for obligation in obligations {\n-                         fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                     }\n-                 })\n-        });\n+        let err = infcx.sub_types(false, &cause, impl_ty, trait_ty)\n+            .map(|ok| inh.register_infer_ok_obligations(ok));\n \n         if let Err(terr) = err {\n             debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n@@ -822,5 +806,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 &terr);\n             diag.emit();\n         }\n+\n+        // FIXME(#41323) Check the obligations in the fulfillment context.\n     });\n }"}, {"sha": "26ba965fe5cc6b60df81dea366bfa31edc0c1038", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         assert_eq!(n, pick.autoderefs);\n \n         autoderef.unambiguous_final_ty();\n-        autoderef.finalize(LvaluePreference::NoPreference, &[self.self_expr]);\n+        autoderef.finalize(LvaluePreference::NoPreference, self.self_expr);\n \n         let target = pick.unsize.unwrap_or(autoderefd_ty);\n         let target = target.adjust_for_autoref(self.tcx, autoref);\n@@ -445,7 +445,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                       \"expr was deref-able {} times but now isn't?\",\n                                       autoderefs);\n                         });\n-                        autoderef.finalize(PreferMutLvalue, &[expr]);\n+                        autoderef.finalize(PreferMutLvalue, expr);\n                     }\n                 }\n                 Some(_) | None => {}\n@@ -543,7 +543,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                                                Some(&base_expr),\n                                                                self.node_ty(base_expr.id),\n                                                                PreferMutLvalue);\n-                        let method = method.expect(\"re-trying deref failed\");\n+                        let ok = method.expect(\"re-trying deref failed\");\n+                        let method = self.register_infer_ok_obligations(ok);\n                         self.tables.borrow_mut().method_map.insert(method_call, method);\n                     }\n                 }"}, {"sha": "7dd2699a6eaf08b224d7cafdb785178cdde52817", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -17,7 +17,8 @@ use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n-use rustc::infer;\n+use rustc::ty::subst::Subst;\n+use rustc::infer::{self, InferOk};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -159,7 +160,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   trait_def_id: DefId,\n                                   self_ty: ty::Ty<'tcx>,\n                                   opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                  -> Option<ty::MethodCallee<'tcx>> {\n+                                  -> Option<InferOk<'tcx, ty::MethodCallee<'tcx>>> {\n         self.lookup_method_in_trait_adjusted(span,\n                                              self_expr,\n                                              m_name,\n@@ -190,7 +191,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            unsize: bool,\n                                            self_ty: ty::Ty<'tcx>,\n                                            opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                           -> Option<ty::MethodCallee<'tcx>> {\n+                                           -> Option<InferOk<'tcx, ty::MethodCallee<'tcx>>> {\n         debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_expr={:?}, \\\n                 m_name={}, trait_def_id={:?})\",\n                self_ty,\n@@ -236,6 +237,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert_eq!(generics.regions.len(), 0);\n \n         debug!(\"lookup_in_trait_adjusted: method_item={:?}\", method_item);\n+        let mut obligations = vec![];\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n@@ -248,10 +250,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n                                                                     infer::FnCall,\n                                                                     &fn_sig).0;\n-        let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n+        let fn_sig = fn_sig.subst(self.tcx, substs);\n+        let fn_sig = match self.normalize_associated_types_in_as_infer_ok(span, &fn_sig) {\n+            InferOk { value, obligations: o } => {\n+                obligations.extend(o);\n+                value\n+            }\n+        };\n         let transformed_self_ty = fn_sig.inputs()[0];\n-        let method_ty = tcx.mk_fn_def(def_id, trait_ref.substs,\n-                                     ty::Binder(fn_sig));\n+        let method_ty = tcx.mk_fn_def(def_id, substs, ty::Binder(fn_sig));\n \n         debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n                method_ty,\n@@ -265,18 +272,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // Note that as the method comes from a trait, it should not have\n         // any late-bound regions appearing in its bounds.\n-        let method_bounds = self.instantiate_bounds(span, def_id, trait_ref.substs);\n-        assert!(!method_bounds.has_escaping_regions());\n-        self.add_obligations_for_parameters(traits::ObligationCause::misc(span, self.body_id),\n-                                            &method_bounds);\n+        let bounds = self.tcx.item_predicates(def_id).instantiate(self.tcx, substs);\n+        let bounds = match self.normalize_associated_types_in_as_infer_ok(span, &bounds) {\n+            InferOk { value, obligations: o } => {\n+                obligations.extend(o);\n+                value\n+            }\n+        };\n+        assert!(!bounds.has_escaping_regions());\n \n-        // Also register an obligation for the method type being well-formed.\n-        self.register_wf_obligation(method_ty, span, traits::MiscObligation);\n+        let cause = traits::ObligationCause::misc(span, self.body_id);\n+        obligations.extend(traits::predicates_for_generics(cause.clone(), &bounds));\n \n-        // FIXME(#18653) -- Try to resolve obligations, giving us more\n-        // typing information, which can sometimes be needed to avoid\n-        // pathological region inference failures.\n-        self.select_obligations_where_possible();\n+        // Also add an obligation for the method type being well-formed.\n+        obligations.push(traits::Obligation::new(cause, ty::Predicate::WellFormed(method_ty)));\n \n         // Insert any adjustments needed (always an autoref of some mutability).\n         if let Some(self_expr) = self_expr {\n@@ -317,7 +326,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"callee = {:?}\", callee);\n \n-        Some(callee)\n+        Some(InferOk {\n+            obligations,\n+            value: callee\n+        })\n     }\n \n     pub fn resolve_ufcs(&self,"}, {"sha": "902cfb889f8c209faa304568f3f5387db65ce3c1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 63, "deletions": 47, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -128,7 +128,6 @@ use rustc_back::slice;\n use rustc::middle::const_val::eval_length;\n use rustc_const_math::ConstInt;\n \n-mod assoc;\n mod autoderef;\n pub mod dropck;\n pub mod _match;\n@@ -536,7 +535,7 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         Inherited {\n             infcx: infcx,\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n@@ -547,20 +546,55 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn register_predicate(&self, obligation: traits::PredicateObligation<'tcx>) {\n+        debug!(\"register_predicate({:?})\", obligation);\n+        if obligation.has_escaping_regions() {\n+            span_bug!(obligation.cause.span, \"escaping regions in predicate {:?}\",\n+                      obligation);\n+        }\n+        self.fulfillment_cx\n+            .borrow_mut()\n+            .register_predicate_obligation(self, obligation);\n+    }\n+\n+    fn register_predicates(&self, obligations: Vec<traits::PredicateObligation<'tcx>>) {\n+        for obligation in obligations {\n+            self.register_predicate(obligation);\n+        }\n+    }\n+\n+    fn register_infer_ok_obligations<T>(&self, infer_ok: InferOk<'tcx, T>) -> T {\n+        self.register_predicates(infer_ok.obligations);\n+        infer_ok.value\n+    }\n+\n     fn normalize_associated_types_in<T>(&self,\n                                         span: Span,\n                                         body_id: ast::NodeId,\n-                                        value: &T)\n-                                        -> T\n+                                        value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        assoc::normalize_associated_types_in(self,\n-                                             &mut self.fulfillment_cx.borrow_mut(),\n-                                             span,\n-                                             body_id,\n-                                             value)\n+        let ok = self.normalize_associated_types_in_as_infer_ok(span, body_id, value);\n+        self.register_infer_ok_obligations(ok)\n     }\n \n+    fn normalize_associated_types_in_as_infer_ok<T>(&self,\n+                                                    span: Span,\n+                                                    body_id: ast::NodeId,\n+                                                    value: &T)\n+                                                    -> InferOk<'tcx, T>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        debug!(\"normalize_associated_types_in(value={:?})\", value);\n+        let mut selcx = traits::SelectionContext::new(self);\n+        let cause = ObligationCause::misc(span, body_id);\n+        let traits::Normalized { value, obligations } =\n+            traits::normalize(&mut selcx, cause, value);\n+        debug!(\"normalize_associated_types_in: result={:?} predicates={:?}\",\n+            value,\n+            obligations);\n+        InferOk { value, obligations }\n+    }\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n@@ -1713,14 +1747,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           -> ty::InstantiatedPredicates<'tcx> {\n         let bounds = self.tcx.item_predicates(def_id);\n         let result = bounds.instantiate(self.tcx, substs);\n-        let result = self.normalize_associated_types_in(span, &result.predicates);\n+        let result = self.normalize_associated_types_in(span, &result);\n         debug!(\"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}\",\n                bounds,\n                substs,\n                result);\n-        ty::InstantiatedPredicates {\n-            predicates: result\n-        }\n+        result\n     }\n \n     /// Replace all anonymized types with fresh inference variables\n@@ -1763,7 +1795,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        self.inh.normalize_associated_types_in(span, self.body_id, value)\n+        let ok = self.normalize_associated_types_in_as_infer_ok(span, value);\n+        self.register_infer_ok_obligations(ok)\n+    }\n+\n+    fn normalize_associated_types_in_as_infer_ok<T>(&self, span: Span, value: &T)\n+                                                    -> InferOk<'tcx, T>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        self.inh.normalize_associated_types_in_as_infer_ok(span, self.body_id, value)\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n@@ -1804,32 +1844,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .register_bound(self, ty, def_id, cause);\n     }\n \n-    pub fn register_predicate(&self,\n-                              obligation: traits::PredicateObligation<'tcx>)\n-    {\n-        debug!(\"register_predicate({:?})\", obligation);\n-        if obligation.has_escaping_regions() {\n-            span_bug!(obligation.cause.span, \"escaping regions in predicate {:?}\",\n-                      obligation);\n-        }\n-        self.fulfillment_cx\n-            .borrow_mut()\n-            .register_predicate_obligation(self, obligation);\n-    }\n-\n-    pub fn register_predicates(&self,\n-                               obligations: Vec<traits::PredicateObligation<'tcx>>)\n-    {\n-        for obligation in obligations {\n-            self.register_predicate(obligation);\n-        }\n-    }\n-\n-    pub fn register_infer_ok_obligations<T>(&self, infer_ok: InferOk<'tcx, T>) -> T {\n-        self.register_predicates(infer_ok.obligations);\n-        infer_ok.value\n-    }\n-\n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n         let t = AstConv::ast_ty_to_ty(self, ast_t);\n         self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);\n@@ -2072,12 +2086,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 expr, base_expr, adj_ty, autoderefs,\n                 false, lvalue_pref, idx_ty)\n             {\n-                autoderef.finalize(lvalue_pref, &[base_expr]);\n+                autoderef.finalize(lvalue_pref, base_expr);\n                 return Some(final_mt);\n             }\n \n             if let ty::TyArray(element_ty, _) = adj_ty.sty {\n-                autoderef.finalize(lvalue_pref, &[base_expr]);\n+                autoderef.finalize(lvalue_pref, base_expr);\n                 let adjusted_ty = self.tcx.mk_slice(element_ty);\n                 return self.try_index_step(\n                     MethodCall::expr(expr.id), expr, base_expr,\n@@ -2161,8 +2175,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If some lookup succeeds, write callee into table and extract index/element\n         // type from the method signature.\n         // If some lookup succeeded, install method in table\n-        method.map(|method| {\n+        method.map(|ok| {\n             debug!(\"try_index_step: success, using overloaded indexing\");\n+            let method = self.register_infer_ok_obligations(ok);\n             self.tables.borrow_mut().method_map.insert(method_call, method);\n             (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n         })\n@@ -2586,7 +2601,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // we can.  We don't care if some things turn\n                         // out unconstrained or ambiguous, as we're\n                         // just trying to get hints here.\n-                        let result = self.save_and_restore_obligations_in_snapshot_flag(|_| {\n+                        let result = self.save_and_restore_in_snapshot_flag(|_| {\n                             let mut fulfill = FulfillmentContext::new();\n                             let ok = ok; // FIXME(#30046)\n                             for obligation in ok.obligations {\n@@ -2755,7 +2770,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if self.tcx.vis_is_accessible_from(field.vis, self.body_id) {\n-                            autoderef.finalize(lvalue_pref, &[base]);\n+                            autoderef.finalize(lvalue_pref, base);\n                             self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n \n                             self.tcx.check_stability(field.did, expr.id, expr.span);\n@@ -2879,7 +2894,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if let Some(field_ty) = field {\n-                autoderef.finalize(lvalue_pref, &[base]);\n+                autoderef.finalize(lvalue_pref, base);\n                 self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n                 return field_ty;\n             }\n@@ -3292,8 +3307,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         if let Some(mt) = oprnd_t.builtin_deref(true, NoPreference) {\n                             oprnd_t = mt.ty;\n-                        } else if let Some(method) = self.try_overloaded_deref(\n+                        } else if let Some(ok) = self.try_overloaded_deref(\n                                 expr.span, Some(&oprnd), oprnd_t, lvalue_pref) {\n+                            let method = self.register_infer_ok_obligations(ok);\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n                             self.tables.borrow_mut().method_map.insert(MethodCall::expr(expr.id),\n                                                                            method);"}, {"sha": "42296006b79d189c834ab26eb1f019042db97b84", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -398,20 +398,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let method = match trait_did {\n             Some(trait_did) => {\n-                self.lookup_method_in_trait_adjusted(expr.span,\n-                                                     Some(lhs_expr),\n-                                                     opname,\n-                                                     trait_did,\n-                                                     0,\n-                                                     false,\n-                                                     lhs_ty,\n-                                                     Some(other_tys))\n+                self.lookup_method_in_trait(expr.span,\n+                                            Some(lhs_expr),\n+                                            opname,\n+                                            trait_did,\n+                                            lhs_ty,\n+                                            Some(other_tys))\n             }\n             None => None\n         };\n \n         match method {\n-            Some(method) => {\n+            Some(ok) => {\n+                let method = self.register_infer_ok_obligations(ok);\n+                self.select_obligations_where_possible();\n+\n                 let method_ty = method.ty;\n \n                 // HACK(eddyb) Fully qualified path to work around a resolve bug."}, {"sha": "091e29dd18a6b68a70c0c74a67625adf6a57c70d", "filename": "src/test/run-pass/coerce-overloaded-autoderef.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Ftest%2Frun-pass%2Fcoerce-overloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467aaab50ef0c7284121d59d8f7af3184836e586/src%2Ftest%2Frun-pass%2Fcoerce-overloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-overloaded-autoderef.rs?ref=467aaab50ef0c7284121d59d8f7af3184836e586", "patch": "@@ -68,4 +68,8 @@ fn use_vec_ref(v: &Vec<u8>) {\n     use_slice(&&&mut &&&v);\n }\n \n+fn use_op_rhs(s: &mut String) {\n+    *s += {&String::from(\" \")};\n+}\n+\n pub fn main() {}"}]}