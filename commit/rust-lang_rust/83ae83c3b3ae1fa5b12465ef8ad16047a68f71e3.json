{"sha": "83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYWU4M2MzYjNhZTFmYTViMTI0NjVlZjhhZDE2MDQ3YTY4ZjcxZTM=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-17T19:05:04Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T22:23:22Z"}, "message": "uv::hl::get_global_loop() -> uv::global_loop::get()\n\n- moved global loop tests, as well.. will add tests in uv_hl that encompass\nrolling your own high_level_loop via uv::hl::run_high_level_loop()\n- also whitespace cleanups and misc warning cleanup..\n- doesn't work on 32bit linux", "tree": {"sha": "bd089b392b65da208ef256607d88866a1cecc07d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd089b392b65da208ef256607d88866a1cecc07d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3", "html_url": "https://github.com/rust-lang/rust/commit/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "253fad77883869511e2030352e86904ac2165d7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/253fad77883869511e2030352e86904ac2165d7c", "html_url": "https://github.com/rust-lang/rust/commit/253fad77883869511e2030352e86904ac2165d7c"}], "stats": {"total": 578, "additions": 304, "deletions": 274}, "files": [{"sha": "cd9dfdc7fd7f0dac4fcec27df360376a301eea50", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3", "patch": "@@ -28,6 +28,7 @@ mod net;\n mod uv;\n mod uv_ll;\n mod uv_hl;\n+mod uv_global_loop;\n \n \n // Utility modules"}, {"sha": "9d3ad9bf68d7713124b141b450c651f9321facbe", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3", "patch": "@@ -34,6 +34,9 @@ export ll;\n import hl = uv_hl;\n export hl;\n \n+import global_loop = uv_global_loop;\n+export global_loop;\n+\n #[nolink]\n native mod rustrt {\n     fn rust_uv_loop_new() -> *libc::c_void;"}, {"sha": "74cb9e4442ce7ad34c38650cae11d0f81ab1f504", "filename": "src/libstd/uv_global_loop.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3", "patch": "@@ -0,0 +1,237 @@\n+#[doc=\"\n+Process-wide, lazily started/stopped libuv event loop interaction.\n+\"];\n+\n+import ll = uv_ll;\n+import hl = uv_hl;\n+import get_gl = get;\n+\n+export get;\n+\n+native mod rustrt {\n+    fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n+    fn rust_uv_get_kernel_global_async_handle() -> *libc::uintptr_t;\n+    fn rust_compare_and_swap_ptr(address: *libc::uintptr_t,\n+                                 oldval: libc::uintptr_t,\n+                                 newval: libc::uintptr_t) -> bool;\n+}\n+\n+#[doc =\"\n+Race-free helper to get access to a global task where a libuv\n+loop is running.\n+\n+# Return\n+\n+* A `hl::high_level_loop` that encapsulates communication with the global\n+loop.\n+\"]\n+fn get() -> hl::high_level_loop {\n+    let global_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n+    log(debug, #fmt(\"ENTERING global_loop::get() loop chan: %?\",\n+       global_loop_chan_ptr));\n+\n+    let builder_fn = {||\n+        let builder = task::builder();\n+        let opts = {\n+            supervise: false,\n+            notify_chan: none,\n+            sched:\n+                some({mode: task::manual_threads(1u),\n+                      native_stack_size: none })\n+        };\n+        task::set_opts(builder, opts);\n+        builder\n+    };\n+    unsafe {\n+        log(debug, \"before priv::chan_from_global_ptr\");\n+        let chan = priv::chan_from_global_ptr::<hl::high_level_msg>(\n+            global_loop_chan_ptr,\n+            builder_fn) {|port|\n+\n+            // the actual body of our global loop lives here\n+            log(debug, \"initialized global port task!\");\n+            log(debug, \"GLOBAL initialized global port task!\");\n+            outer_global_loop_body(port);\n+        };\n+        log(debug, \"after priv::chan_from_global_ptr\");\n+        let handle = get_global_async_handle_native_representation()\n+            as **ll::uv_async_t;\n+        ret { async_handle: handle, op_chan: chan };\n+    }\n+}\n+\n+// INTERNAL API\n+\n+unsafe fn outer_global_loop_body(msg_po: comm::port<hl::high_level_msg>) {\n+    // we're going to use a single libuv-generated loop ptr\n+    // for the duration of the process\n+    let loop_ptr = ll::loop_new();\n+\n+    // data structure for loop goes here..\n+\n+    // immediately weaken the task this is running in.\n+    priv::weaken_task() {|weak_exit_po|\n+        // when we first enter this loop, we're going\n+        // to wait on stand-by to receive a request to\n+        // fire-up the libuv loop\n+        let mut continue = true;\n+        while continue {\n+            log(debug, \"in outer_loop...\");\n+            continue = either::either(\n+                {|left_val|\n+                    // bail out..\n+                    // if we catch this msg at this point,\n+                    // we should just be able to exit because\n+                    // the loop isn't active\n+                    log(debug, #fmt(\"weak_exit_po recv'd msg: %?\",\n+                                   left_val));\n+                    false\n+                }, {|right_val|\n+                    log(debug, \"about to enter inner loop\");\n+                    inner_global_loop_body(weak_exit_po, msg_po, loop_ptr,\n+                                          copy(right_val))\n+                }, comm::select2(weak_exit_po, msg_po));\n+            log(debug,#fmt(\"GLOBAL LOOP EXITED, WAITING TO RESTART? %?\",\n+                       continue));\n+        }\n+    };\n+\n+    ll::loop_delete(loop_ptr);\n+}\n+\n+unsafe fn inner_global_loop_body(weak_exit_po_in: comm::port<()>,\n+                          msg_po_in: comm::port<hl::high_level_msg>,\n+                          loop_ptr: *libc::c_void,\n+                          -first_interaction: hl::high_level_msg) -> bool {\n+    // resend the msg\n+    comm::send(comm::chan(msg_po_in), first_interaction);\n+\n+    // black magic\n+    let weak_exit_po_ptr = ptr::addr_of(weak_exit_po_in);\n+    hl::run_high_level_loop(\n+        loop_ptr,\n+        msg_po_in,\n+        // before_run\n+        {|async_handle|\n+            log(debug,#fmt(\"global_loop before_run: async_handle %?\",\n+                          async_handle));\n+            // set the handle as the global\n+            set_global_async_handle(0u as *ll::uv_async_t,\n+                                    async_handle);\n+            // when this is ran, our async_handle is set up, so let's\n+            // do an async_send with it\n+            ll::async_send(async_handle);\n+        },\n+        // before_msg_drain\n+        {|async_handle|\n+            log(debug,#fmt(\"global_loop before_msg_drain: async_handle %?\",\n+                          async_handle));\n+            let weak_exit_po = *weak_exit_po_ptr;\n+            if(comm::peek(weak_exit_po)) {\n+                // if this is true, immediately bail and return false, causing\n+                // the libuv loop to start tearing down\n+                log(debug,\"got weak_exit meg inside libuv loop\");\n+                comm::recv(weak_exit_po);\n+                false\n+            }\n+            // if no weak_exit_po msg is received, then we'll let the\n+            // loop continue\n+            else {\n+                true\n+            }\n+        },\n+        // before_tear_down\n+        {|async_handle|\n+            log(debug,#fmt(\"global_loop before_tear_down: async_handle %?\",\n+                          async_handle));\n+            set_global_async_handle(async_handle,\n+                                    0 as *ll::uv_async_t);\n+        });\n+    // supposed to return a bool to indicate to the enclosing loop whether\n+    // it should continue or not..\n+    ret true;\n+}\n+\n+unsafe fn get_global_async_handle_native_representation()\n+    -> *libc::uintptr_t {\n+    ret rustrt::rust_uv_get_kernel_global_async_handle();\n+}\n+\n+unsafe fn get_global_async_handle() -> *ll::uv_async_t {\n+    ret (*get_global_async_handle_native_representation()) as *ll::uv_async_t;\n+}\n+\n+unsafe fn set_global_async_handle(old: *ll::uv_async_t,\n+                           new_ptr: *ll::uv_async_t) {\n+    rustrt::rust_compare_and_swap_ptr(\n+        get_global_async_handle_native_representation(),\n+        old as libc::uintptr_t,\n+        new_ptr as libc::uintptr_t);\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    crust fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) unsafe {\n+        let exit_ch_ptr = ll::get_data_for_uv_handle(\n+            timer_ptr as *libc::c_void) as *comm::chan<bool>;\n+        let exit_ch = *exit_ch_ptr;\n+        comm::send(exit_ch, true);\n+        log(debug, #fmt(\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n+                       exit_ch_ptr));\n+    }\n+    crust fn simple_timer_cb(timer_ptr: *ll::uv_timer_t,\n+                             status: libc::c_int) unsafe {\n+        log(debug, \"in simple timer cb\");\n+        ll::timer_stop(timer_ptr);\n+        let hl_loop = get_gl();\n+        hl::interact(hl_loop) {|loop_ptr|\n+            log(debug, \"closing timer\");\n+            //ll::close(timer_ptr as *libc::c_void, simple_timer_close_cb);\n+            hl::unref_handle(hl_loop, timer_ptr, simple_timer_close_cb);\n+            log(debug, \"about to deref exit_ch_ptr\");\n+            log(debug, \"after msg sent on deref'd exit_ch\");\n+        };\n+        log(debug, \"exiting simple timer cb\");\n+    }\n+\n+    fn impl_uv_hl_simple_timer(hl_loop: hl::high_level_loop) unsafe {\n+        let exit_po = comm::port::<bool>();\n+        let exit_ch = comm::chan(exit_po);\n+        let exit_ch_ptr = ptr::addr_of(exit_ch);\n+        log(debug, #fmt(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n+                       exit_ch_ptr));\n+        let timer_handle = ll::timer_t();\n+        let timer_ptr = ptr::addr_of(timer_handle);\n+        hl::interact(hl_loop) {|loop_ptr|\n+            log(debug, \"user code inside interact loop!!!\");\n+            let init_status = ll::timer_init(loop_ptr, timer_ptr);\n+            if(init_status == 0i32) {\n+                hl::ref_handle(hl_loop, timer_ptr);\n+                ll::set_data_for_uv_handle(\n+                    timer_ptr as *libc::c_void,\n+                    exit_ch_ptr as *libc::c_void);\n+                let start_status = ll::timer_start(timer_ptr, simple_timer_cb,\n+                                                   1u, 0u);\n+                if(start_status == 0i32) {\n+                }\n+                else {\n+                    fail \"failure on ll::timer_start()\";\n+                }\n+            }\n+            else {\n+                fail \"failure on ll::timer_init()\";\n+            }\n+        };\n+        comm::recv(exit_po);\n+        log(debug, \"global_loop timer test: msg recv on exit_po, done..\");\n+    }\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_global_loop_high_level_global_timer() unsafe {\n+        let hl_loop = get_gl();\n+        task::spawn_sched(task::manual_threads(1u), {||\n+            impl_uv_hl_simple_timer(hl_loop);\n+        });\n+        impl_uv_hl_simple_timer(hl_loop);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "5cc58932c4bf6d0c69ab29bcf0d65f42f2ecd01c", "filename": "src/libstd/uv_hl.rs", "status": "modified", "additions": 63, "deletions": 274, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3/src%2Flibstd%2Fuv_hl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3/src%2Flibstd%2Fuv_hl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_hl.rs?ref=83ae83c3b3ae1fa5b12465ef8ad16047a68f71e3", "patch": "@@ -6,21 +6,11 @@ provide a high-level, abstracted interface to some set of\n libuv functionality.\n \"];\n \n-export high_level_loop;\n+export high_level_loop, high_level_msg;\n export run_high_level_loop, interact, ref_handle, unref_handle;\n-// this will eventually move into its own, unexported (from std) module\n-export get_global_loop;\n \n import ll = uv_ll;\n \n-native mod rustrt {\n-    fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n-    fn rust_uv_get_kernel_global_async_handle() -> *libc::uintptr_t;\n-    fn rust_compare_and_swap_ptr(address: *libc::uintptr_t,\n-                                 oldval: libc::uintptr_t,\n-                                 newval: libc::uintptr_t) -> bool;\n-}\n-\n #[doc = \"\n Used to abstract-away direct interaction with a libuv loop.\n \n@@ -37,77 +27,38 @@ type high_level_loop = {\n     op_chan: comm::chan<high_level_msg>\n };\n \n-#[doc = \"\n-Race-free helper to get access to a global task where a libuv\n-loop is running.\n-\n-# Return\n-\n-* A `high_level_loop` that encapsulates communication with the global loop.\n+#[doc=\"\n+Represents the range of interactions with a `high_level_loop`\n \"]\n-fn get_global_loop() -> high_level_loop unsafe {\n-    let global_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n-    log(debug, #fmt(\"ENTERING get_global_loop() loop chan: %?\",\n-       global_loop_chan_ptr));\n-    log(debug, #fmt(\"ENTERING get_global_loop() loop chan: %?\",\n-       global_loop_chan_ptr));\n-    log(debug,#fmt(\"value of loop ptr: %?\", *global_loop_chan_ptr));\n-\n-    let builder_fn = {||\n-        let builder = task::builder();\n-        let opts = {\n-            supervise: false,\n-            notify_chan: none,\n-            sched:\n-                some({mode: task::manual_threads(1u),\n-                      native_stack_size: none })\n-        };\n-        task::set_opts(builder, opts);\n-        builder\n-    };\n-    unsafe {\n-        log(debug, \"before priv::chan_from_global_ptr\");\n-        let chan = priv::chan_from_global_ptr::<high_level_msg>(\n-            global_loop_chan_ptr,\n-            builder_fn) {|port|\n-\n-            // the actual body of our global loop lives here\n-            log(debug, \"initialized global port task!\");\n-            log(debug, \"GLOBAL!!!! initialized global port task!\");\n-            outer_global_loop_body(port);\n-        };\n-        log(debug, \"after priv::chan_from_global_ptr\");\n-        let handle = get_global_async_handle_native_representation()\n-            as **ll::uv_async_t;\n-        ret { async_handle: handle, op_chan: chan };\n-    }\n+enum high_level_msg {\n+    interaction (fn~(*libc::c_void)),\n+    auto_ref_handle (*libc::c_void),\n+    auto_unref_handle (*libc::c_void, *u8),\n+    tear_down\n }\n \n #[doc = \"\n-Takes a vanilla libuv `uv_loop_t*` ptr, performs some setup and then calls\n-`uv_run()`. Users will be able to access this loop via a provided\n-`async_handle` and `msg_ptr_po`. On top of libuv's internal handle refcount,\n-the high_level_loop manages its own lifetime with a similar refcount scheme.\n-\n-This call blocks for the lifetime of the libuv loop.\n+Given a vanilla `uv_loop_t*`\n \n # Arguments\n \n * loop_ptr - a pointer to a currently unused libuv loop. Its `data` field\n will be overwritten before the loop begins\n-* async_handle - a pointer to a _fresh_ `ll::uv_async_t` record that _has\n-not_ been initialized via `uv_async_init`, `ll::uv::async_init`, etc. It\n must be a pointer to a clean rust `uv_async_t` record\n-* before_run - a unique closure that is invoked just before the call to\n-`uv_run`\n+* msg_po - an active port that receives `high_level_msg`s\n+* before_run - a unique closure that is invoked after `uv_async_init` is\n+called on the `async_handle` passed into this callback, just before `uv_run`\n+is called on the provided `loop_ptr`\n * before_msg_drain - a unique closure that is invoked every time the loop is\n-awoken, but before the port pointed to in the `msg_po` argument is drained.\n+awoken, but before the port pointed to in the `msg_po` argument is drained\n+* before_tear_down - called just before the loop invokes `uv_close()` on the\n+provided `async_handle`. `uv_run` should return shortly after\n \"]\n unsafe fn run_high_level_loop(loop_ptr: *libc::c_void,\n                               msg_po: comm::port<high_level_msg>,\n-                              before_run: fn~(*global_loop_data),\n-                              before_msg_drain: fn~() -> bool,\n-                              before_tear_down: fn~(*global_loop_data)) {\n+                              before_run: fn~(*ll::uv_async_t),\n+                              before_msg_drain: fn~(*ll::uv_async_t) -> bool,\n+                              before_tear_down: fn~(*ll::uv_async_t)) {\n     // set up the special async handle we'll use to allow multi-task\n     // communication with this loop\n     let async = ll::async_t();\n@@ -116,20 +67,20 @@ unsafe fn run_high_level_loop(loop_ptr: *libc::c_void,\n     ll::async_init(loop_ptr, async_handle, high_level_wake_up_cb);\n \n     // initialize our loop data and store it in the loop\n-    let data: global_loop_data = {\n+    let data: global_loop_data = default_gl_data({\n         async_handle: async_handle,\n         mut active: true,\n         before_msg_drain: before_msg_drain,\n-        before_tear_down: gdc_callback(before_tear_down),\n+        before_tear_down: before_tear_down,\n         msg_po_ptr: ptr::addr_of(msg_po),\n         mut refd_handles: [mut],\n         mut unrefd_handles: [mut]\n-    };\n+    });\n     let data_ptr = ptr::addr_of(data);\n     ll::set_data_for_uv_handle(async_handle, data_ptr);\n \n     // call before_run\n-    before_run(data_ptr);\n+    before_run(async_handle);\n \n     log(debug, \"about to run high level loop\");\n     // enter the loop... this blocks until the loop is done..\n@@ -138,17 +89,18 @@ unsafe fn run_high_level_loop(loop_ptr: *libc::c_void,\n }\n \n #[doc = \"\n-Pass in a callback to be processed on the running libuv loop's thread\n+Provide a callback to be processed by `a_loop`\n+\n+The primary way to do operations again a running `high_level_loop` that\n+doesn't involve creating a uv handle via `safe_handle`\n \n # Arguments\n \n-* a_loop - a high_level_loop record that represents a channel of\n-communication with an active libuv loop running on a thread\n-somwhere in the current process\n+* a_loop - a `high_level_loop` that you want to do operations against\n * cb - a function callback to be processed on the running loop's\n thread. The only parameter is an opaque pointer to the running\n-uv_loop_t. You can use this pointer to initiate or continue any\n-operations against the loop\n+uv_loop_t. In the context of this callback, it is safe to use this pointer\n+to do various uv_* API calls. _DO NOT_ send this pointer out via ports/chans\n \"]\n unsafe fn interact(a_loop: high_level_loop,\n                       -cb: fn~(*libc::c_void)) {\n@@ -159,25 +111,50 @@ iface uv_handle_manager<T> {\n     fn init() -> T;\n }\n \n-resource uv_safe_handle<T>(handle_val: uv_handle_manager<T>) {\n+type safe_handle_fields<T> = {\n+    hl_loop: high_level_loop,\n+    handle: T,\n+    close_cb: *u8\n+};\n+\n+/*fn safe_handle<T>(a_loop: high_level_loop,\n+                  handle_val: T,\n+                  handle_init_cb: fn~(*libc::c_void, *T),\n+                  close_cb: *u8) {\n+\n+resource safe_handle_container<T>(handle_fields: safe_handle_fields<T>) {\n }\n+}*/\n+\n \n #[doc=\"\n+Needs to be encapsulated within `safe_handle`\n \"]\n fn ref_handle<T>(hl_loop: high_level_loop, handle: *T) unsafe {\n     send_high_level_msg(hl_loop, auto_ref_handle(handle as *libc::c_void));\n }\n #[doc=\"\n+Needs to be encapsulated within `safe_handle`\n \"]\n fn unref_handle<T>(hl_loop: high_level_loop, handle: *T,\n                    user_close_cb: *u8) unsafe {\n     send_high_level_msg(hl_loop, auto_unref_handle(handle as *libc::c_void,\n                                                    user_close_cb));\n }\n \n-/////////////////////\n // INTERNAL API\n-/////////////////////\n+\n+// data that lives for the lifetime of the high-evel oo\n+enum global_loop_data {\n+    default_gl_data({\n+        async_handle: *ll::uv_async_t,\n+        mut active: bool,\n+        before_msg_drain: fn~(*ll::uv_async_t) -> bool,\n+        before_tear_down: fn~(*ll::uv_async_t),\n+        msg_po_ptr: *comm::port<high_level_msg>,\n+        mut refd_handles: [mut *libc::c_void],\n+        mut unrefd_handles: [mut *libc::c_void]})\n+}\n \n unsafe fn send_high_level_msg(hl_loop: high_level_loop,\n                               -msg: high_level_msg) unsafe {\n@@ -201,11 +178,11 @@ unsafe fn send_high_level_msg(hl_loop: high_level_loop,\n // simply check if the loop is active and, if so, invoke the\n // user-supplied on_wake callback that is stored in the loop's\n // data member\n-crust fn high_level_wake_up_cb(async_handle: *libc::c_void,\n+crust fn high_level_wake_up_cb(async_handle: *ll::uv_async_t,\n                                status: int) unsafe {\n     // nothing here, yet.\n-    log(debug, #fmt(\"high_level_wake_up_cb crust.. handle: %?\",\n-                     async_handle));\n+    log(debug, #fmt(\"high_level_wake_up_cb crust.. handle: %? status: %?\",\n+                     async_handle, status));\n     let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n     let data = ll::get_data_for_uv_handle(async_handle) as *global_loop_data;\n     // we check to see if the loop is \"active\" (the loop is set to\n@@ -217,7 +194,7 @@ crust fn high_level_wake_up_cb(async_handle: *libc::c_void,\n     // in the loops msg_po)\n     if (*data).active {\n         log(debug, \"before on_wake\");\n-        let mut do_msg_drain = (*data).before_msg_drain();\n+        let mut do_msg_drain = (*data).before_msg_drain(async_handle);\n         let mut continue = true;\n         if do_msg_drain {\n             let msg_po = *((*data).msg_po_ptr);\n@@ -266,12 +243,8 @@ crust fn tear_down_close_cb(handle: *ll::uv_async_t) unsafe {\n fn high_level_tear_down(data: *global_loop_data) unsafe {\n     log(debug, \"high_level_tear_down() called, close async_handle\");\n     // call user-suppled before_tear_down cb\n-    alt (*data).before_tear_down {\n-      gdc_callback(cb) {\n-        cb(data);\n-      }\n-    }\n     let async_handle = (*data).async_handle;\n+    (*data).before_tear_down(async_handle);\n     ll::close(async_handle as *libc::c_void, tear_down_close_cb);\n }\n \n@@ -329,187 +302,3 @@ unsafe fn high_level_unref(data: *global_loop_data, handle: *libc::c_void,\n     }\n \n }\n-\n-enum high_level_msg {\n-    interaction (fn~(*libc::c_void)),\n-    auto_ref_handle (*libc::c_void),\n-    auto_unref_handle (*libc::c_void, *u8),\n-    tear_down\n-}\n-\n-unsafe fn get_global_async_handle_native_representation()\n-    -> *libc::uintptr_t {\n-    ret rustrt::rust_uv_get_kernel_global_async_handle();\n-}\n-\n-unsafe fn get_global_async_handle() -> *ll::uv_async_t {\n-    ret (*get_global_async_handle_native_representation()) as *ll::uv_async_t;\n-}\n-\n-unsafe fn set_global_async_handle(old: *ll::uv_async_t,\n-                           new_ptr: *ll::uv_async_t) {\n-    rustrt::rust_compare_and_swap_ptr(\n-        get_global_async_handle_native_representation(),\n-        old as libc::uintptr_t,\n-        new_ptr as libc::uintptr_t);\n-}\n-\n-enum global_data_callback {\n-    gdc_callback(fn~(*global_loop_data))\n-}\n-\n-type global_loop_data = {\n-    async_handle: *ll::uv_async_t,\n-    mut active: bool,\n-    before_msg_drain: fn~() -> bool,\n-    before_tear_down: global_data_callback,\n-    msg_po_ptr: *comm::port<high_level_msg>,\n-    mut refd_handles: [mut *libc::c_void],\n-    mut unrefd_handles: [mut *libc::c_void]\n-};\n-\n-unsafe fn outer_global_loop_body(msg_po: comm::port<high_level_msg>) {\n-    // we're going to use a single libuv-generated loop ptr\n-    // for the duration of the process\n-    let loop_ptr = ll::loop_new();\n-\n-    // data structure for loop goes here..\n-\n-    // immediately weaken the task this is running in.\n-    priv::weaken_task() {|weak_exit_po|\n-        // when we first enter this loop, we're going\n-        // to wait on stand-by to receive a request to\n-        // fire-up the libuv loop\n-        let mut continue = true;\n-        while continue {\n-            log(debug, \"in outer_loop...\");\n-            continue = either::either(\n-                {|left_val|\n-                    // bail out..\n-                    // if we catch this msg at this point,\n-                    // we should just be able to exit because\n-                    // the loop isn't active\n-                    log(debug, \"got msg on weak_exit_po in outer loop\");\n-                    false\n-                }, {|right_val|\n-                    log(debug, \"about to enter inner loop\");\n-                    inner_global_loop_body(weak_exit_po, msg_po, loop_ptr,\n-                                          copy(right_val))\n-                }, comm::select2(weak_exit_po, msg_po));\n-            log(debug,#fmt(\"GLOBAL LOOP EXITED, WAITING TO RESTART? %?\",\n-                       continue));\n-        }\n-    };\n-\n-    ll::loop_delete(loop_ptr);\n-}\n-\n-unsafe fn inner_global_loop_body(weak_exit_po_in: comm::port<()>,\n-                          msg_po_in: comm::port<high_level_msg>,\n-                          loop_ptr: *libc::c_void,\n-                          -first_interaction: high_level_msg) -> bool {\n-    // resend the msg\n-    comm::send(comm::chan(msg_po_in), first_interaction);\n-\n-    // black magic\n-    let weak_exit_po_ptr = ptr::addr_of(weak_exit_po_in);\n-    run_high_level_loop(\n-        loop_ptr,\n-        msg_po_in,\n-        // before_run\n-        {|data|\n-            // set the handle as the global\n-            set_global_async_handle(0u as *ll::uv_async_t,\n-                                    (*data).async_handle);\n-            // when this is ran, our async_handle is set up, so let's\n-            // do an async_send with it\n-            ll::async_send((*data).async_handle);\n-        },\n-        // before_msg_drain\n-        {||\n-            log(debug,\"entering before_msg_drain for the global loop\");\n-            let weak_exit_po = *weak_exit_po_ptr;\n-            if(comm::peek(weak_exit_po)) {\n-                // if this is true, immediately bail and return false, causing\n-                // the libuv loop to start tearing down\n-                log(debug,\"got weak_exit meg inside libuv loop\");\n-                comm::recv(weak_exit_po);\n-                false\n-            }\n-            // if no weak_exit_po msg is received, then we'll let the\n-            // loop continue\n-            else {\n-                true\n-            }\n-        },\n-        // before_tear_down\n-        {|data|\n-            set_global_async_handle((*data).async_handle,\n-                                    0 as *ll::uv_async_t);\n-        });\n-    // supposed to return a bool to indicate to the enclosing loop whether\n-    // it should continue or not..\n-    ret true;\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    crust fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) unsafe {\n-        log(debug, \"user close cb for timer_ptr\");\n-        let exit_ch_ptr = ll::get_data_for_uv_handle(\n-            timer_ptr as *libc::c_void) as *comm::chan<bool>;\n-        let exit_ch = *exit_ch_ptr;\n-        comm::send(exit_ch, true);\n-    }\n-    crust fn simple_timer_cb(timer_ptr: *ll::uv_timer_t,\n-                             status: libc::c_int) unsafe {\n-        log(debug, \"in simple timer cb\");\n-        ll::timer_stop(timer_ptr);\n-        let hl_loop = get_global_loop();\n-        interact(hl_loop) {|loop_ptr|\n-            log(debug, \"closing timer\");\n-            //ll::close(timer_ptr as *libc::c_void, simple_timer_close_cb);\n-            unref_handle(hl_loop, timer_ptr, simple_timer_close_cb);\n-            log(debug, \"about to deref exit_ch_ptr\");\n-            log(debug, \"after msg sent on deref'd exit_ch\");\n-        };\n-        log(debug, \"exiting simple timer cb\");\n-    }\n-\n-    fn impl_uv_hl_simple_timer(hl_loop: high_level_loop) unsafe {\n-        let exit_po = comm::port::<bool>();\n-        let exit_ch = comm::chan(exit_po);\n-        let exit_ch_ptr = ptr::addr_of(exit_ch);\n-        let timer_handle = ll::timer_t();\n-        let timer_ptr = ptr::addr_of(timer_handle);\n-        interact(hl_loop) {|loop_ptr|\n-            log(debug, \"user code inside interact loop!!!\");\n-            let init_status = ll::timer_init(loop_ptr, timer_ptr);\n-            if(init_status == 0i32) {\n-                ref_handle(hl_loop, timer_ptr);\n-                ll::set_data_for_uv_handle(\n-                    timer_ptr as *libc::c_void,\n-                    exit_ch_ptr as *libc::c_void);\n-                let start_status = ll::timer_start(timer_ptr, simple_timer_cb,\n-                                                   1u, 0u);\n-                if(start_status == 0i32) {\n-                }\n-                else {\n-                    fail \"failure on ll::timer_start()\";\n-                }\n-            }\n-            else {\n-                fail \"failure on ll::timer_init()\";\n-            }\n-        };\n-        comm::recv(exit_po);\n-        log(debug, \"test_uv_hl_simple_timer: msg recv on exit_po, done..\");\n-    }\n-    #[test]\n-    #[ignore(cfg(target_os = \"freebsd\"))]\n-    fn test_uv_hl_high_level_global_timer() unsafe {\n-        let hl_loop = get_global_loop();\n-        impl_uv_hl_simple_timer(hl_loop);\n-        impl_uv_hl_simple_timer(hl_loop);\n-    }\n-}\n\\ No newline at end of file"}]}