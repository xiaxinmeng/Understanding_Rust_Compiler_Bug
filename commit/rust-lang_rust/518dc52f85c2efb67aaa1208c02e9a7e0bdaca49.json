{"sha": "518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxOGRjNTJmODVjMmVmYjY3YWFhMTIwOGMwMmU5YTdlMGJkYWNhNDk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-19T22:16:48Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-20T18:04:00Z"}, "message": "Reformat\n\nThis changes the indexing syntax from .() to [], the vector syntax from ~[] to\n[] and the extension syntax from #fmt() to #fmt[]", "tree": {"sha": "9af4f631455ff5ba42b233819fe4bb9f3b9ac194", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9af4f631455ff5ba42b233819fe4bb9f3b9ac194"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "html_url": "https://github.com/rust-lang/rust/commit/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4aa165553bfb2a74e2e54f08fd9507e23bc24708", "url": "https://api.github.com/repos/rust-lang/rust/commits/4aa165553bfb2a74e2e54f08fd9507e23bc24708", "html_url": "https://github.com/rust-lang/rust/commit/4aa165553bfb2a74e2e54f08fd9507e23bc24708"}], "stats": {"total": 14175, "additions": 6788, "deletions": 7387}, "files": [{"sha": "d8fd682387b403397511c001c7aafebca497d7ac", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -137,10 +137,9 @@ mod write {\n                                                                    False);\n \n             if threshold != 0u {\n-                llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(MPMB,\n-                                                                   threshold);\n+                llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(\n+                    MPMB, threshold);\n             }\n-\n             llvm::LLVMPassManagerBuilderPopulateModulePassManager(MPMB,\n                                                                   pm.llpm);\n \n@@ -293,21 +292,21 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n        provided_metas {\n         let name: option::t<str> = none;\n         let vers: option::t<str> = none;\n-        let cmh_items: [@ast::meta_item] = ~[];\n+        let cmh_items: [@ast::meta_item] = [];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess, linkage_metas);\n         for meta: @ast::meta_item in linkage_metas {\n             if attr::get_meta_item_name(meta) == \"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { name = some(v); }\n-                  none. { cmh_items += ~[meta]; }\n+                  none. { cmh_items += [meta]; }\n                 }\n-            } else if (attr::get_meta_item_name(meta) == \"vers\") {\n+            } else if attr::get_meta_item_name(meta) == \"vers\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { vers = some(v); }\n-                  none. { cmh_items += ~[meta]; }\n+                  none. { cmh_items += [meta]; }\n                 }\n-            } else { cmh_items += ~[meta]; }\n+            } else { cmh_items += [meta]; }\n         }\n         ret {name: name, vers: vers, cmh_items: cmh_items};\n     }\n@@ -316,7 +315,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n     fn crate_meta_extras_hash(sha: sha1, _crate: &ast::crate,\n                               metas: &provided_metas) -> str {\n         fn len_and_str(s: &str) -> str {\n-            ret #fmt(\"%u_%s\", str::byte_len(s), s);\n+            ret #fmt[\"%u_%s\", str::byte_len(s), s];\n         }\n \n         fn len_and_str_lit(l: &ast::lit) -> str {\n@@ -345,8 +344,8 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n \n     fn warn_missing(sess: &session::session, name: str, default: str) {\n         if !sess.get_opts().library { ret; }\n-        sess.warn(#fmt(\"missing crate link meta '%s', using '%s' as default\",\n-                       name, default));\n+        sess.warn(#fmt[\"missing crate link meta '%s', using '%s' as default\",\n+                       name, default]);\n     }\n \n     fn crate_meta_name(sess: &session::session, _crate: &ast::crate,\n@@ -356,8 +355,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n               none. {\n                 let name =\n                     {\n-                        let os =\n-                            str::split(fs::basename(output), '.' as u8);\n+                        let os = str::split(fs::basename(output), '.' as u8);\n                         assert (vec::len(os) >= 2u);\n                         vec::pop(os);\n                         str::connect(os, \".\")\n@@ -429,7 +427,7 @@ fn mangle(ss: &[str]) -> str {\n \n     let n = \"_ZN\"; // Begin name-sequence.\n \n-    for s: str in ss { n += #fmt(\"%u%s\", str::byte_len(s), s); }\n+    for s: str in ss { n += #fmt[\"%u%s\", str::byte_len(s), s]; }\n     n += \"E\"; // End name-sequence.\n \n     ret n;\n@@ -438,7 +436,7 @@ fn mangle(ss: &[str]) -> str {\n fn exported_name(path: &[str], hash: &str, _vers: &str) -> str {\n     // FIXME: versioning isn't working yet\n \n-    ret mangle(path + ~[hash]); //  + \"@\" + vers;\n+    ret mangle(path + [hash]); //  + \"@\" + vers;\n \n }\n \n@@ -451,12 +449,12 @@ fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: &ty::t, name: &str)\n    -> str {\n     let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n-    ret mangle(~[name, s, hash]);\n+    ret mangle([name, s, hash]);\n }\n \n fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &[str],\n                                         flav: &str) -> str {\n-    ret mangle(path + ~[ccx.names.next(flav)]);\n+    ret mangle(path + [ccx.names.next(flav)]);\n }\n \n fn mangle_internal_name_by_path(_ccx: &@crate_ctxt, path: &[str]) -> str {"}, {"sha": "eb1741767adfbee0edfc8928875dd5c5a39e4b30", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -51,72 +51,68 @@ type upcalls =\n \n fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n                    taskptr_type: TypeRef, llmod: ModuleRef) -> @upcalls {\n-    fn decl(llmod: ModuleRef, name: str, tys: [TypeRef],\n-          rv: TypeRef) -> ValueRef {\n-        let arg_tys: [TypeRef] = ~[];\n-        for t: TypeRef in tys { arg_tys += ~[t]; }\n+    fn decl(llmod: ModuleRef, name: str, tys: [TypeRef], rv: TypeRef) ->\n+       ValueRef {\n+        let arg_tys: [TypeRef] = [];\n+        for t: TypeRef in tys { arg_tys += [t]; }\n         let fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n-    fn decl_with_taskptr(taskptr_type: TypeRef,\n-                         llmod: ModuleRef, name: str, tys: [TypeRef],\n-                         rv: TypeRef) -> ValueRef {\n-        ret decl(llmod, name, ~[taskptr_type] + tys, rv);\n+    fn decl_with_taskptr(taskptr_type: TypeRef, llmod: ModuleRef, name: str,\n+                         tys: [TypeRef], rv: TypeRef) -> ValueRef {\n+        ret decl(llmod, name, [taskptr_type] + tys, rv);\n     }\n     let dv = bind decl_with_taskptr(taskptr_type, llmod, _, _, T_void());\n     let d = bind decl_with_taskptr(taskptr_type, llmod, _, _, _);\n     let dr = bind decl(llmod, _, _, _);\n \n-    let empty_vec: [TypeRef] = ~[];\n-    ret @{grow_task: dv(\"grow_task\", ~[T_size_t()]),\n+    let empty_vec: [TypeRef] = [];\n+    ret @{grow_task: dv(\"grow_task\", [T_size_t()]),\n           _yield: dv(\"yield\", empty_vec),\n-          sleep: dv(\"sleep\", ~[T_size_t()]),\n-          _fail: dv(\"fail\", ~[T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n-          kill: dv(\"kill\", ~[taskptr_type]),\n+          sleep: dv(\"sleep\", [T_size_t()]),\n+          _fail: dv(\"fail\", [T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n+          kill: dv(\"kill\", [taskptr_type]),\n           exit: dv(\"exit\", empty_vec),\n           malloc:\n-              d(\"malloc\", ~[T_size_t(), T_ptr(tydesc_type)], T_ptr(T_i8())),\n-          free: dv(\"free\", ~[T_ptr(T_i8()), T_int()]),\n+              d(\"malloc\", [T_size_t(), T_ptr(tydesc_type)], T_ptr(T_i8())),\n+          free: dv(\"free\", [T_ptr(T_i8()), T_int()]),\n           shared_malloc:\n-              d(\"shared_malloc\", ~[T_size_t(), T_ptr(tydesc_type)],\n+              d(\"shared_malloc\", [T_size_t(), T_ptr(tydesc_type)],\n                 T_ptr(T_i8())),\n-          shared_free: dv(\"shared_free\", ~[T_ptr(T_i8())]),\n-          mark: d(\"mark\", ~[T_ptr(T_i8())], T_int()),\n-          new_str: d(\"new_str\", ~[T_ptr(T_i8()), T_size_t()], T_ptr(T_str())),\n+          shared_free: dv(\"shared_free\", [T_ptr(T_i8())]),\n+          mark: d(\"mark\", [T_ptr(T_i8())], T_int()),\n+          new_str: d(\"new_str\", [T_ptr(T_i8()), T_size_t()], T_ptr(T_str())),\n           evec_append:\n               d(\"evec_append\",\n-                ~[T_ptr(tydesc_type), T_ptr(tydesc_type),\n-                  T_ptr(T_opaque_vec_ptr()), T_opaque_vec_ptr(), T_bool()],\n+                [T_ptr(tydesc_type), T_ptr(tydesc_type),\n+                 T_ptr(T_opaque_vec_ptr()), T_opaque_vec_ptr(), T_bool()],\n                 T_void()),\n           get_type_desc:\n               d(\"get_type_desc\",\n-                ~[T_ptr(T_nil()), T_size_t(), T_size_t(), T_size_t(),\n-                  T_ptr(T_ptr(tydesc_type))], T_ptr(tydesc_type)),\n+                [T_ptr(T_nil()), T_size_t(), T_size_t(), T_size_t(),\n+                 T_ptr(T_ptr(tydesc_type))], T_ptr(tydesc_type)),\n           ivec_resize:\n-              d(\"ivec_resize\", ~[T_ptr(T_opaque_ivec()), T_int()], T_void()),\n+              d(\"ivec_resize\", [T_ptr(T_opaque_ivec()), T_int()], T_void()),\n           ivec_spill:\n-              d(\"ivec_spill\", ~[T_ptr(T_opaque_ivec()), T_int()], T_void()),\n+              d(\"ivec_spill\", [T_ptr(T_opaque_ivec()), T_int()], T_void()),\n           ivec_resize_shared:\n-              d(\"ivec_resize_shared\", ~[T_ptr(T_opaque_ivec()), T_int()],\n+              d(\"ivec_resize_shared\", [T_ptr(T_opaque_ivec()), T_int()],\n                 T_void()),\n           ivec_spill_shared:\n-              d(\"ivec_spill_shared\", ~[T_ptr(T_opaque_ivec()), T_int()],\n+              d(\"ivec_spill_shared\", [T_ptr(T_opaque_ivec()), T_int()],\n                 T_void()),\n           cmp_type:\n-              dr(\"cmp_type\", ~[T_ptr(T_i1()), taskptr_type,\n-                 T_ptr(tydesc_type), T_ptr(T_ptr(tydesc_type)),\n-                 T_ptr(T_i8()), T_ptr(T_i8()), T_i8()],\n-                 T_void()),\n+              dr(\"cmp_type\",\n+                 [T_ptr(T_i1()), taskptr_type, T_ptr(tydesc_type),\n+                  T_ptr(T_ptr(tydesc_type)), T_ptr(T_i8()), T_ptr(T_i8()),\n+                  T_i8()], T_void()),\n           log_type:\n-              dr(\"log_type\", ~[taskptr_type, T_ptr(tydesc_type),\n-                 T_ptr(T_i8()), T_i32()],\n+              dr(\"log_type\",\n+                 [taskptr_type, T_ptr(tydesc_type), T_ptr(T_i8()), T_i32()],\n                  T_void()),\n-          dynastack_mark:\n-              d(\"dynastack_mark\", ~[], T_ptr(T_i8())),\n-          dynastack_alloc:\n-              d(\"dynastack_alloc\", ~[T_size_t()], T_ptr(T_i8())),\n-          dynastack_free:\n-              d(\"dynastack_free\", ~[T_ptr(T_i8())], T_void())};\n+          dynastack_mark: d(\"dynastack_mark\", [], T_ptr(T_i8())),\n+          dynastack_alloc: d(\"dynastack_alloc\", [T_size_t()], T_ptr(T_i8())),\n+          dynastack_free: d(\"dynastack_free\", [T_ptr(T_i8())], T_void())};\n }\n //\n // Local Variables:"}, {"sha": "a75a46e64c7f113e961777eb0f05b4e9f3be28d5", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 94, "deletions": 98, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -53,11 +53,11 @@ fn default_configuration(sess: session::session, argv0: str, input: str) ->\n \n     let mk = attr::mk_name_value_item_str;\n \n-    ret ~[ // Target bindings.\n-          mk(\"target_os\", std::os::target_os()), mk(\"target_arch\", \"x86\"),\n-          mk(\"target_libc\", libc),\n-          // Build bindings.\n-          mk(\"build_compiler\", argv0), mk(\"build_input\", input)];\n+    ret [ // Target bindings.\n+         mk(\"target_os\", std::os::target_os()), mk(\"target_arch\", \"x86\"),\n+         mk(\"target_libc\", libc),\n+         // Build bindings.\n+         mk(\"build_compiler\", argv0), mk(\"build_input\", input)];\n }\n \n fn build_configuration(sess: session::session, argv0: str, input: str) ->\n@@ -71,8 +71,8 @@ fn build_configuration(sess: session::session, argv0: str, input: str) ->\n         {\n             if sess.get_opts().test && !attr::contains_name(user_cfg, \"test\")\n                {\n-                ~[attr::mk_word_item(\"test\")]\n-            } else { ~[] }\n+                [attr::mk_word_item(\"test\")]\n+            } else { [] }\n         };\n     ret user_cfg + gen_cfg + default_cfg;\n }\n@@ -81,8 +81,8 @@ fn build_configuration(sess: session::session, argv0: str, input: str) ->\n fn parse_cfgspecs(cfgspecs: &[str]) -> ast::crate_cfg {\n     // FIXME: It would be nice to use the parser to parse all varieties of\n     // meta_item here. At the moment we just support the meta_word variant.\n-    let words = ~[];\n-    for s: str in cfgspecs { words += ~[attr::mk_word_item(s)]; }\n+    let words = [];\n+    for s: str in cfgspecs { words += [attr::mk_word_item(s)]; }\n     ret words;\n }\n \n@@ -92,31 +92,29 @@ fn parse_input(sess: session::session, cfg: &ast::crate_cfg, input: str) ->\n    @ast::crate {\n     if !input_is_stdin(input) {\n         parser::parse_crate_from_file(input, cfg, sess.get_parse_sess())\n-    } else {\n-        parse_input_src(sess, cfg, input).crate\n-    }\n+    } else { parse_input_src(sess, cfg, input).crate }\n }\n \n-fn parse_input_src(sess: session::session, cfg: &ast::crate_cfg,\n-                   infile: str) -> {crate: @ast::crate, src: str} {\n-    let srcbytes = if infile != \"-\" {\n-        io::file_reader(infile)\n-    } else {\n-        io::stdin()\n-    }.read_whole_stream();\n+fn parse_input_src(sess: session::session, cfg: &ast::crate_cfg, infile: str)\n+   -> {crate: @ast::crate, src: str} {\n+    let srcbytes =\n+        if infile != \"-\" {\n+            io::file_reader(infile)\n+        } else { io::stdin() }.read_whole_stream();\n     let src = str::unsafe_from_bytes(srcbytes);\n-    let crate = parser::parse_crate_from_source_str(infile, src, cfg,\n-                                                    sess.get_parse_sess());\n+    let crate =\n+        parser::parse_crate_from_source_str(infile, src, cfg,\n+                                            sess.get_parse_sess());\n     ret {crate: crate, src: src};\n }\n \n-fn time<T>(do_it: bool, what: str, thunk: fn() -> T ) -> T {\n+fn time<T>(do_it: bool, what: str, thunk: fn() -> T) -> T {\n     if !do_it { ret thunk(); }\n     let start = std::time::precise_time_s();\n     let rv = thunk();\n     let end = std::time::precise_time_s();\n-    log_err #fmt(\"time: %s took %s s\", what,\n-                 common::float_to_str(end - start, 3u));\n+    log_err #fmt[\"time: %s took %s s\", what,\n+                 common::float_to_str(end - start, 3u)];\n     ret rv;\n }\n \n@@ -143,33 +141,33 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n              bind middle::ast_map::map_crate(*crate));\n     time(time_passes, \"external crate/lib resolution\",\n          bind creader::read_crates(sess, *crate));\n-    let {def_map, ext_map} =\n+    let {def_map: def_map, ext_map: ext_map} =\n         time(time_passes, \"resolution\",\n              bind resolve::resolve_crate(sess, ast_map, crate));\n     let freevars =\n         time(time_passes, \"freevar finding\",\n              bind freevars::annotate_freevars(sess, def_map, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, ast_map, freevars);\n     time::<()>(time_passes, \"typechecking\",\n-             bind typeck::check_crate(ty_cx, crate));\n+               bind typeck::check_crate(ty_cx, crate));\n     time::<()>(time_passes, \"alt checking\",\n-             bind middle::check_alt::check_crate(ty_cx, crate));\n+               bind middle::check_alt::check_crate(ty_cx, crate));\n     if sess.get_opts().run_typestate {\n         time(time_passes, \"typestate checking\",\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n     time(time_passes, \"alias checking\",\n          bind middle::alias::check_crate(ty_cx, crate));\n     time::<()>(time_passes, \"kind checking\",\n-             bind kind::check_crate(ty_cx, crate));\n+               bind kind::check_crate(ty_cx, crate));\n     if sess.get_opts().no_trans { ret; }\n     let llmod =\n         time::<llvm::llvm::ModuleRef>(time_passes, \"translation\",\n-                                    bind trans::trans_crate(sess, crate,\n-                                                            ty_cx, output,\n-                                                            ast_map));\n+                                      bind trans::trans_crate(sess, crate,\n+                                                              ty_cx, output,\n+                                                              ast_map));\n     time::<()>(time_passes, \"LLVM passes\",\n-             bind link::write::run_passes(sess, llmod, output));\n+               bind link::write::run_passes(sess, llmod, output));\n }\n \n fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n@@ -222,7 +220,8 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n     alt ppm {\n       ppm_typed. {\n         let amap = middle::ast_map::map_crate(*crate);\n-        let {def_map, ext_map} = resolve::resolve_crate(sess, amap, crate);\n+        let {def_map: def_map, ext_map: ext_map} =\n+            resolve::resolve_crate(sess, amap, crate);\n         let freevars = freevars::annotate_freevars(sess, def_map, crate);\n         let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, amap, freevars);\n         typeck::check_crate(ty_cx, crate);\n@@ -239,14 +238,14 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n \n fn version(argv0: str) {\n     let vers = \"unknown version\";\n-    let env_vers = #env(\"CFG_VERSION\");\n+    let env_vers = #env[\"CFG_VERSION\"];\n     if str::byte_len(env_vers) != 0u { vers = env_vers; }\n-    io::stdout().write_str(#fmt(\"%s %s\\n\", argv0, vers));\n+    io::stdout().write_str(#fmt[\"%s %s\\n\", argv0, vers]);\n }\n \n fn usage(argv0: str) {\n-    io::stdout().write_str(#fmt(\"usage: %s [options] <input>\\n\", argv0) +\n-                                   \"\n+    io::stdout().write_str(#fmt[\"usage: %s [options] <input>\\n\", argv0] +\n+                               \"\n options:\n \n     -h --help          display this message\n@@ -287,9 +286,9 @@ fn get_os(triple: str) -> session::os {\n     ret if str::find(triple, \"win32\") >= 0 ||\n                str::find(triple, \"mingw32\") >= 0 {\n             session::os_win32\n-        } else if (str::find(triple, \"darwin\") >= 0) {\n+        } else if str::find(triple, \"darwin\") >= 0 {\n             session::os_macos\n-        } else if (str::find(triple, \"linux\") >= 0) {\n+        } else if str::find(triple, \"linux\") >= 0 {\n             session::os_linux\n         } else { log_err \"Unknown operating system!\"; fail };\n }\n@@ -300,10 +299,10 @@ fn get_arch(triple: str) -> session::arch {\n                str::find(triple, \"i686\") >= 0 ||\n                str::find(triple, \"i786\") >= 0 {\n             session::arch_x86\n-        } else if (str::find(triple, \"x86_64\") >= 0) {\n+        } else if str::find(triple, \"x86_64\") >= 0 {\n             session::arch_x64\n-        } else if (str::find(triple, \"arm\") >= 0 ||\n-                       str::find(triple, \"xscale\") >= 0) {\n+        } else if str::find(triple, \"arm\") >= 0 ||\n+                      str::find(triple, \"xscale\") >= 0 {\n             session::arch_arm\n         } else { log_err \"Unknown architecture! \" + triple; fail };\n }\n@@ -331,21 +330,21 @@ fn build_session_options(binary: str, match: getopts::match, binary_dir: str)\n     let library = opt_present(match, \"lib\");\n     let static = opt_present(match, \"static\");\n \n-    let library_search_paths = ~[binary_dir + \"/lib\"];\n+    let library_search_paths = [binary_dir + \"/lib\"];\n     let lsp_vec = getopts::opt_strs(match, \"L\");\n-    for lsp: str in lsp_vec { library_search_paths += ~[lsp]; }\n+    for lsp: str in lsp_vec { library_search_paths += [lsp]; }\n \n     let parse_only = opt_present(match, \"parse-only\");\n     let no_trans = opt_present(match, \"no-trans\");\n \n     let output_type =\n         if parse_only || no_trans {\n             link::output_type_none\n-        } else if (opt_present(match, \"S\")) {\n+        } else if opt_present(match, \"S\") {\n             link::output_type_assembly\n-        } else if (opt_present(match, \"c\")) {\n+        } else if opt_present(match, \"c\") {\n             link::output_type_object\n-        } else if (opt_present(match, \"emit-llvm\")) {\n+        } else if opt_present(match, \"emit-llvm\") {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n     let verify = !opt_present(match, \"noverify\");\n@@ -363,7 +362,7 @@ fn build_session_options(binary: str, match: getopts::match, binary_dir: str)\n                 fail;\n             }\n             2u\n-        } else if (opt_present(match, \"OptLevel\")) {\n+        } else if opt_present(match, \"OptLevel\") {\n             alt getopts::opt_str(match, \"OptLevel\") {\n               \"0\" { 0u }\n               \"1\" { 1u }\n@@ -417,24 +416,23 @@ fn build_session(sopts: @session::options) -> session::session {\n fn parse_pretty(sess: session::session, name: &str) -> pp_mode {\n     if str::eq(name, \"normal\") {\n         ret ppm_normal;\n-    } else if (str::eq(name, \"typed\")) {\n+    } else if str::eq(name, \"typed\") {\n         ret ppm_typed;\n-    } else if (str::eq(name, \"identified\")) { ret ppm_identified; }\n+    } else if str::eq(name, \"identified\") { ret ppm_identified; }\n     sess.fatal(\"argument to `pretty` or `expand` must be one of `normal`, \" +\n                    \"`typed`, or `identified`\");\n }\n \n fn opts() -> [getopts::opt] {\n-    ret ~[optflag(\"h\"), optflag(\"help\"), optflag(\"v\"), optflag(\"version\"),\n-          optflag(\"glue\"), optflag(\"emit-llvm\"), optflagopt(\"pretty\"),\n-          optflagopt(\"expand\"), optflag(\"ls\"), optflag(\"parse-only\"),\n-          optflag(\"no-trans\"),\n-          optflag(\"O\"), optopt(\"OptLevel\"), optmulti(\"L\"), optflag(\"S\"),\n-          optflag(\"c\"), optopt(\"o\"), optflag(\"g\"), optflag(\"save-temps\"),\n-          optopt(\"sysroot\"), optflag(\"stats\"), optflag(\"time-passes\"),\n-          optflag(\"time-llvm-passes\"), optflag(\"no-typestate\"),\n-          optflag(\"noverify\"), optmulti(\"cfg\"), optflag(\"test\"),\n-          optflag(\"lib\"), optflag(\"static\"), optflag(\"gc\")];\n+    ret [optflag(\"h\"), optflag(\"help\"), optflag(\"v\"), optflag(\"version\"),\n+         optflag(\"glue\"), optflag(\"emit-llvm\"), optflagopt(\"pretty\"),\n+         optflagopt(\"expand\"), optflag(\"ls\"), optflag(\"parse-only\"),\n+         optflag(\"no-trans\"), optflag(\"O\"), optopt(\"OptLevel\"), optmulti(\"L\"),\n+         optflag(\"S\"), optflag(\"c\"), optopt(\"o\"), optflag(\"g\"),\n+         optflag(\"save-temps\"), optopt(\"sysroot\"), optflag(\"stats\"),\n+         optflag(\"time-passes\"), optflag(\"time-llvm-passes\"),\n+         optflag(\"no-typestate\"), optflag(\"noverify\"), optmulti(\"cfg\"),\n+         optflag(\"test\"), optflag(\"lib\"), optflag(\"static\"), optflag(\"gc\")];\n }\n \n fn main(args: [str]) {\n@@ -444,7 +442,7 @@ fn main(args: [str]) {\n         alt getopts::getopts(args, opts()) {\n           getopts::success(m) { m }\n           getopts::failure(f) {\n-            log_err #fmt(\"error: %s\", getopts::fail_str(f));\n+            log_err #fmt[\"error: %s\", getopts::fail_str(f)];\n             fail\n           }\n         };\n@@ -471,10 +469,10 @@ fn main(args: [str]) {\n     }\n     if n_inputs == 0u {\n         sess.fatal(\"No input filename given.\");\n-    } else if (n_inputs > 1u) {\n+    } else if n_inputs > 1u {\n         sess.fatal(\"Multiple input filenames provided.\");\n     }\n-    let ifile = match.free.(0);\n+    let ifile = match.free[0];\n     let saved_out_filename: str = \"\";\n     let cfg = build_configuration(sess, binary, ifile);\n     let expand =\n@@ -502,10 +500,7 @@ fn main(args: [str]) {\n       none::<pp_mode>. {/* continue */ }\n     }\n     let ls = opt_present(match, \"ls\");\n-    if ls {\n-        metadata::creader::list_file_metadata(ifile, io::stdout());\n-        ret;\n-    }\n+    if ls { metadata::creader::list_file_metadata(ifile, io::stdout()); ret; }\n \n     let stop_after_codegen =\n         sopts.output_type != link::output_type_exe ||\n@@ -516,29 +511,31 @@ fn main(args: [str]) {\n         // \"-\" as input file will cause the parser to read from stdin so we\n         // have to make up a name\n         // We want to toss everything after the final '.'\n-        let parts = if !input_is_stdin(ifile) {\n-            str::split(ifile, '.' as u8)\n-        } else {\n-            ~[\"default\", \"rs\"]\n-        };\n+        let parts =\n+            if !input_is_stdin(ifile) {\n+                str::split(ifile, '.' as u8)\n+            } else { [\"default\", \"rs\"] };\n         vec::pop(parts);\n         saved_out_filename = str::connect(parts, \".\");\n-        let suffix = alt sopts.output_type {\n-          link::output_type_none. { \"none\" }\n-          link::output_type_bitcode. { \"bc\" }\n-          link::output_type_assembly. { \"s\" }\n-          // Object and exe output both use the '.o' extension here\n-          link::output_type_object. | link::output_type_exe. { \"o\" }\n-        };\n+        let suffix =\n+            alt sopts.output_type {\n+              link::output_type_none. { \"none\" }\n+              link::output_type_bitcode. { \"bc\" }\n+              link::output_type_assembly. { \"s\" }\n+\n+              // Object and exe output both use the '.o' extension here\n+              link::output_type_object. | link::output_type_exe. {\n+                \"o\"\n+              }\n+            };\n         let ofile = saved_out_filename + \".\" + suffix;\n         compile_input(sess, cfg, ifile, ofile);\n       }\n       some(ofile) {\n         // FIXME: what about windows? This will create a foo.exe.o.\n         saved_out_filename = ofile;\n-        let temp_filename = if !stop_after_codegen {\n-            ofile + \".o\"\n-        } else { ofile };\n+        let temp_filename =\n+            if !stop_after_codegen { ofile + \".o\" } else { ofile };\n         compile_input(sess, cfg, ifile, temp_filename);\n       }\n     }\n@@ -556,8 +553,8 @@ fn main(args: [str]) {\n     // The invocations of gcc share some flags across platforms\n \n     let gcc_args =\n-        ~[stage, \"-Lrt\", \"-lrustrt\", glu, \"-m32\", \"-o\", saved_out_filename,\n-          saved_out_filename + \".o\"];\n+        [stage, \"-Lrt\", \"-lrustrt\", glu, \"-m32\", \"-o\", saved_out_filename,\n+         saved_out_filename + \".o\"];\n     let lib_cmd;\n \n     let os = sess.get_targ_cfg().os;\n@@ -591,46 +588,45 @@ fn main(args: [str]) {\n     let cstore = sess.get_cstore();\n     for cratepath: str in cstore::get_used_crate_files(cstore) {\n         if str::ends_with(cratepath, \".rlib\") {\n-            gcc_args += ~[cratepath];\n+            gcc_args += [cratepath];\n             cont;\n         }\n         let dir = fs::dirname(cratepath);\n-        if dir != \"\" { gcc_args += ~[\"-L\" + dir]; }\n+        if dir != \"\" { gcc_args += [\"-L\" + dir]; }\n         let libarg = unlib(sess.get_targ_cfg(), fs::basename(cratepath));\n-        gcc_args += ~[\"-l\" + libarg];\n+        gcc_args += [\"-l\" + libarg];\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for arg: str in ula { gcc_args += ~[arg]; }\n+    for arg: str in ula { gcc_args += [arg]; }\n \n     let used_libs = cstore::get_used_libraries(cstore);\n-    for l: str in used_libs { gcc_args += ~[\"-l\" + l]; }\n+    for l: str in used_libs { gcc_args += [\"-l\" + l]; }\n \n     if sopts.library {\n-        gcc_args += ~[lib_cmd];\n+        gcc_args += [lib_cmd];\n     } else {\n         // FIXME: why do we hardcode -lm?\n-        gcc_args += ~[\"-lm\", main];\n+        gcc_args += [\"-lm\", main];\n     }\n     // We run 'gcc' here\n \n     let err_code = run::run_program(prog, gcc_args);\n     if 0 != err_code {\n-        sess.err(#fmt(\"linking with gcc failed with code %d\", err_code));\n-        sess.note(#fmt(\"gcc arguments: %s\",\n-                       str::connect(gcc_args, \" \")));\n+        sess.err(#fmt[\"linking with gcc failed with code %d\", err_code]);\n+        sess.note(#fmt[\"gcc arguments: %s\", str::connect(gcc_args, \" \")]);\n         sess.abort_if_errors();\n     }\n     // Clean up on Darwin\n \n     if sess.get_targ_cfg().os == session::os_macos {\n-        run::run_program(\"dsymutil\", ~[saved_out_filename]);\n+        run::run_program(\"dsymutil\", [saved_out_filename]);\n     }\n \n \n     // Remove the temporary object file if we aren't saving temps\n     if !sopts.save_temps {\n-        run::run_program(\"rm\", ~[saved_out_filename + \".o\"]);\n+        run::run_program(\"rm\", [saved_out_filename + \".o\"]);\n     }\n }\n \n@@ -641,7 +637,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let match =\n-            alt getopts::getopts(~[\"--test\"], opts()) {\n+            alt getopts::getopts([\"--test\"], opts()) {\n               getopts::success(m) { m }\n             };\n         let sessopts = build_session_options(\"whatever\", match, \"whatever\");\n@@ -655,7 +651,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let match =\n-            alt getopts::getopts(~[\"--test\", \"--cfg=test\"], opts()) {\n+            alt getopts::getopts([\"--test\", \"--cfg=test\"], opts()) {\n               getopts::success(m) { m }\n             };\n         let sessopts = build_session_options(\"whatever\", match, \"whatever\");"}, {"sha": "5a2b26739aae45aad96fb2b168214bfc29f55f11", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -43,8 +43,7 @@ type options =\n      test: bool,\n      parse_only: bool,\n      no_trans: bool,\n-     do_gc: bool\n-     };\n+     do_gc: bool};\n \n type crate_metadata = {name: str, data: [u8]};\n \n@@ -90,10 +89,10 @@ obj session(targ_cfg: @config,\n     }\n     fn note(msg: str) { codemap::emit_note(none, msg, parse_sess.cm); }\n     fn span_bug(sp: span, msg: str) -> ! {\n-        self.span_fatal(sp, #fmt(\"internal compiler error %s\", msg));\n+        self.span_fatal(sp, #fmt[\"internal compiler error %s\", msg]);\n     }\n     fn bug(msg: str) -> ! {\n-        self.fatal(#fmt(\"internal compiler error %s\", msg));\n+        self.fatal(#fmt[\"internal compiler error %s\", msg]);\n     }\n     fn span_unimpl(sp: span, msg: str) -> ! {\n         self.span_bug(sp, \"unimplemented \" + msg);"}, {"sha": "0f3eb354d9e6d21a06d8900939bcfe6339317fbf", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -30,7 +30,7 @@ export mk_attr;\n // From a list of crate attributes get only the meta_items that impact crate\n // linkage\n fn find_linkage_metas(attrs: &[ast::attribute]) -> [@ast::meta_item] {\n-    let metas: [@ast::meta_item] = ~[];\n+    let metas: [@ast::meta_item] = [];\n     for attr: ast::attribute in find_attrs_by_name(attrs, \"link\") {\n         alt attr.node.value.node {\n           ast::meta_list(_, items) { metas += items; }\n@@ -95,8 +95,8 @@ fn attr_meta(attr: &ast::attribute) -> @ast::meta_item { @attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n fn attr_metas(attrs: &[ast::attribute]) -> [@ast::meta_item] {\n-    let mitems = ~[];\n-    for a: ast::attribute in attrs { mitems += ~[attr_meta(a)]; }\n+    let mitems = [];\n+    for a: ast::attribute in attrs { mitems += [attr_meta(a)]; }\n     ret mitems;\n }\n \n@@ -122,11 +122,11 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n }\n \n fn contains(haystack: &[@ast::meta_item], needle: @ast::meta_item) -> bool {\n-    log #fmt(\"looking for %s\",\n-             syntax::print::pprust::meta_item_to_str(*needle));\n+    log #fmt[\"looking for %s\",\n+             syntax::print::pprust::meta_item_to_str(*needle)];\n     for item: @ast::meta_item in haystack {\n-        log #fmt(\"looking in %s\",\n-                 syntax::print::pprust::meta_item_to_str(*item));\n+        log #fmt[\"looking in %s\",\n+                 syntax::print::pprust::meta_item_to_str(*item)];\n         if eq(item, needle) { log \"found it!\"; ret true; }\n     }\n     log \"found it not :(\";\n@@ -152,13 +152,13 @@ fn sort_meta_items(items: &[@ast::meta_item]) -> [@ast::meta_item] {\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let v: [mutable @ast::meta_item] = ~[mutable];\n-    for mi: @ast::meta_item in items { v += ~[mutable mi]; }\n+    let v: [mutable @ast::meta_item] = [mutable];\n+    for mi: @ast::meta_item in items { v += [mutable mi]; }\n \n     std::sort::quick_sort(lteq, v);\n \n-    let v2: [@ast::meta_item] = ~[];\n-    for mi: @ast::meta_item in v { v2 += ~[mi]; }\n+    let v2: [@ast::meta_item] = [];\n+    for mi: @ast::meta_item in v { v2 += [mi]; }\n     ret v2;\n }\n \n@@ -176,14 +176,13 @@ fn remove_meta_items_by_name(items: &[@ast::meta_item], name: str) ->\n     ret vec::filter_map(filter, items);\n }\n \n-fn require_unique_names(sess: &session::session,\n-                        metas: &[@ast::meta_item]) {\n+fn require_unique_names(sess: &session::session, metas: &[@ast::meta_item]) {\n     let map = map::mk_hashmap::<str, ()>(str::hash, str::eq);\n     for meta: @ast::meta_item in metas {\n         let name = get_meta_item_name(meta);\n         if map.contains_key(name) {\n             sess.span_fatal(meta.span,\n-                            #fmt(\"duplicate meta item `%s`\", name));\n+                            #fmt[\"duplicate meta item `%s`\", name]);\n         }\n         map.insert(name, ());\n     }"}, {"sha": "4aa1c07be57c8dd286652beedcad9e7a420c8a8f", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -115,7 +115,7 @@ fn in_cfg(cfg: &ast::crate_cfg, attrs: &[ast::attribute]) -> bool {\n                 }\n             }\n             let cfg_metas = attr::attr_metas(item_cfg_attrs);\n-            vec::foldl(extract_metas, ~[], cfg_metas)\n+            vec::foldl(extract_metas, [], cfg_metas)\n         };\n \n     for cfg_mi: @ast::meta_item in item_cfg_metas {"}, {"sha": "93ddaa5455900e1a45f54fb7fc2bb783abec96a1", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 42, "deletions": 49, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -9,7 +9,7 @@ import front::attr;\n \n export modify_for_testing;\n \n-type node_id_gen = @fn() -> ast::node_id ;\n+type node_id_gen = @fn() -> ast::node_id;\n \n type test = {path: [ast::ident], ignore: bool};\n \n@@ -36,8 +36,8 @@ fn modify_for_testing(crate: @ast::crate) -> @ast::crate {\n \n     let cx: test_ctxt =\n         @{next_node_id: next_node_id_fn,\n-          mutable path: ~[],\n-          mutable testfns: ~[]};\n+          mutable path: [],\n+          mutable testfns: []};\n \n     let precursor =\n         {fold_crate: bind fold_crate(cx, _, _),\n@@ -51,8 +51,8 @@ fn modify_for_testing(crate: @ast::crate) -> @ast::crate {\n     ret res;\n }\n \n-fn fold_mod(_cx: &test_ctxt, m: &ast::_mod, fld: fold::ast_fold)\n-    -> ast::_mod {\n+fn fold_mod(_cx: &test_ctxt, m: &ast::_mod, fld: fold::ast_fold) ->\n+   ast::_mod {\n \n     // Remove any defined main function from the AST so it doesn't clash with\n     // the one we're going to add.  FIXME: This is sloppy. Instead we should\n@@ -87,14 +87,14 @@ fn fold_crate(cx: &test_ctxt, c: &ast::crate_, fld: fold::ast_fold) ->\n fn fold_item(cx: &test_ctxt, i: &@ast::item, fld: fold::ast_fold) ->\n    @ast::item {\n \n-    cx.path += ~[i.ident];\n-    log #fmt(\"current path: %s\", ast::path_name_i(cx.path));\n+    cx.path += [i.ident];\n+    log #fmt[\"current path: %s\", ast::path_name_i(cx.path)];\n \n     if is_test_fn(i) {\n         log \"this is a test function\";\n         let test = {path: cx.path, ignore: is_ignored(i)};\n-        cx.testfns += ~[test];\n-        log #fmt(\"have %u test functions\", vec::len(cx.testfns));\n+        cx.testfns += [test];\n+        log #fmt[\"have %u test functions\", vec::len(cx.testfns)];\n     }\n \n     let res = fold::noop_fold_item(i, fld);\n@@ -127,7 +127,7 @@ fn is_ignored(i: &@ast::item) -> bool {\n \n fn add_test_module(cx: &test_ctxt, m: &ast::_mod) -> ast::_mod {\n     let testmod = mk_test_module(cx);\n-    ret {items: m.items + ~[testmod] with m};\n+    ret {items: m.items + [testmod] with m};\n }\n \n /*\n@@ -154,16 +154,16 @@ fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n     // The synthesized main function which will call the console test runner\n     // with our list of tests\n     let mainfn = mk_main(cx);\n-    let testmod: ast::_mod = {view_items: ~[], items: ~[mainfn, testsfn]};\n+    let testmod: ast::_mod = {view_items: [], items: [mainfn, testsfn]};\n     let item_ = ast::item_mod(testmod);\n     let item: ast::item =\n         {ident: \"__test\",\n-         attrs: ~[],\n+         attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n          span: ast::dummy_sp()};\n \n-    log #fmt(\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item));\n+    log #fmt[\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item)];\n \n     ret @item;\n }\n@@ -176,27 +176,27 @@ fn mk_tests(cx: &test_ctxt) -> @ast::item {\n     let ret_ty = mk_test_desc_vec_ty(cx);\n \n     let decl: ast::fn_decl =\n-        {inputs: ~[],\n+        {inputs: [],\n          output: ret_ty,\n          purity: ast::impure_fn,\n          il: ast::il_normal,\n          cf: ast::return,\n-         constraints: ~[]};\n+         constraints: []};\n     let proto = ast::proto_fn;\n \n     // The vector of test_descs for this crate\n     let test_descs = mk_test_desc_vec(cx);\n \n     let body_: ast::blk_ =\n-        {stmts: ~[], expr: option::some(test_descs), id: cx.next_node_id()};\n+        {stmts: [], expr: option::some(test_descs), id: cx.next_node_id()};\n     let body = nospan(body_);\n \n     let fn_ = {decl: decl, proto: proto, body: body};\n \n-    let item_ = ast::item_fn(fn_, ~[]);\n+    let item_ = ast::item_fn(fn_, []);\n     let item: ast::item =\n         {ident: \"tests\",\n-         attrs: ~[],\n+         attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n          span: ast::dummy_sp()};\n@@ -205,19 +205,19 @@ fn mk_tests(cx: &test_ctxt) -> @ast::item {\n \n fn empty_fn_ty() -> ast::ty {\n     let proto = ast::proto_fn;\n-    let input_ty = ~[];\n+    let input_ty = [];\n     let ret_ty = @nospan(ast::ty_nil);\n     let cf = ast::return;\n-    let constrs = ~[];\n+    let constrs = [];\n     ret nospan(ast::ty_fn(proto, input_ty, ret_ty, cf, constrs));\n }\n \n // The ast::ty of [std::test::test_desc]\n fn mk_test_desc_vec_ty(cx: &test_ctxt) -> @ast::ty {\n     let test_desc_ty_path: ast::path =\n         nospan({global: false,\n-                idents: ~[\"std\", \"test\", \"test_desc\"],\n-                types: ~[]});\n+                idents: [\"std\", \"test\", \"test_desc\"],\n+                types: []});\n \n     let test_desc_ty: ast::ty =\n         nospan(ast::ty_path(test_desc_ty_path, cx.next_node_id()));\n@@ -228,11 +228,11 @@ fn mk_test_desc_vec_ty(cx: &test_ctxt) -> @ast::ty {\n }\n \n fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n-    log #fmt(\"building test vector from %u tests\", vec::len(cx.testfns));\n-    let descs = ~[];\n+    log #fmt[\"building test vector from %u tests\", vec::len(cx.testfns)];\n+    let descs = [];\n     for test: test in cx.testfns {\n         let test_ = test; // Satisfy alias analysis\n-        descs += ~[mk_test_desc_rec(cx, test_)];\n+        descs += [mk_test_desc_rec(cx, test_)];\n     }\n \n     ret @{id: cx.next_node_id(),\n@@ -243,7 +243,7 @@ fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     let path = test.path;\n \n-    log #fmt(\"encoding %s\", ast::path_name_i(path));\n+    log #fmt[\"encoding %s\", ast::path_name_i(path)];\n \n     let name_lit: ast::lit =\n         nospan(ast::lit_str(ast::path_name_i(path), ast::sk_rc));\n@@ -255,8 +255,7 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     let name_field: ast::field =\n         nospan({mut: ast::imm, ident: \"name\", expr: @name_expr});\n \n-    let fn_path: ast::path =\n-        nospan({global: false, idents: path, types: ~[]});\n+    let fn_path: ast::path = nospan({global: false, idents: path, types: []});\n \n     let fn_expr: ast::expr =\n         {id: cx.next_node_id(),\n@@ -277,7 +276,7 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n         nospan({mut: ast::imm, ident: \"ignore\", expr: @ignore_expr});\n \n     let desc_rec_: ast::expr_ =\n-        ast::expr_rec(~[name_field, fn_field, ignore_field], option::none);\n+        ast::expr_rec([name_field, fn_field, ignore_field], option::none);\n     let desc_rec: ast::expr =\n         {id: cx.next_node_id(), node: desc_rec_, span: ast::dummy_sp()};\n     ret @desc_rec;\n@@ -294,28 +293,28 @@ fn mk_main(cx: &test_ctxt) -> @ast::item {\n     let ret_ty = nospan(ast::ty_nil);\n \n     let decl: ast::fn_decl =\n-        {inputs: ~[args_arg],\n+        {inputs: [args_arg],\n          output: @ret_ty,\n          purity: ast::impure_fn,\n          il: ast::il_normal,\n          cf: ast::return,\n-         constraints: ~[]};\n+         constraints: []};\n     let proto = ast::proto_fn;\n \n     let test_main_call_expr = mk_test_main_call(cx);\n \n     let body_: ast::blk_ =\n-        {stmts: ~[],\n+        {stmts: [],\n          expr: option::some(test_main_call_expr),\n          id: cx.next_node_id()};\n     let body = {node: body_, span: ast::dummy_sp()};\n \n     let fn_ = {decl: decl, proto: proto, body: body};\n \n-    let item_ = ast::item_fn(fn_, ~[]);\n+    let item_ = ast::item_fn(fn_, []);\n     let item: ast::item =\n         {ident: \"main\",\n-         attrs: ~[],\n+         attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n          span: ast::dummy_sp()};\n@@ -326,38 +325,32 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n \n     // Get the args passed to main so we can pass the to test_main\n     let args_path: ast::path =\n-        nospan({global: false, idents: ~[\"args\"], types: ~[]});\n+        nospan({global: false, idents: [\"args\"], types: []});\n \n     let args_path_expr_: ast::expr_ = ast::expr_path(args_path);\n \n     let args_path_expr: ast::expr =\n-        {id: cx.next_node_id(),\n-         node: args_path_expr_,\n-         span: ast::dummy_sp()};\n+        {id: cx.next_node_id(), node: args_path_expr_, span: ast::dummy_sp()};\n \n     // Call __test::test to generate the vector of test_descs\n     let test_path: ast::path =\n-        nospan({global: false, idents: ~[\"tests\"], types: ~[]});\n+        nospan({global: false, idents: [\"tests\"], types: []});\n \n     let test_path_expr_: ast::expr_ = ast::expr_path(test_path);\n \n     let test_path_expr: ast::expr =\n-        {id: cx.next_node_id(),\n-         node: test_path_expr_,\n-         span: ast::dummy_sp()};\n+        {id: cx.next_node_id(), node: test_path_expr_, span: ast::dummy_sp()};\n \n-    let test_call_expr_: ast::expr_ = ast::expr_call(@test_path_expr, ~[]);\n+    let test_call_expr_: ast::expr_ = ast::expr_call(@test_path_expr, []);\n \n     let test_call_expr: ast::expr =\n-        {id: cx.next_node_id(),\n-         node: test_call_expr_,\n-         span: ast::dummy_sp()};\n+        {id: cx.next_node_id(), node: test_call_expr_, span: ast::dummy_sp()};\n \n     // Call std::test::test_main\n     let test_main_path: ast::path =\n         nospan({global: false,\n-                idents: ~[\"std\", \"test\", \"test_main\"],\n-                types: ~[]});\n+                idents: [\"std\", \"test\", \"test_main\"],\n+                types: []});\n \n     let test_main_path_expr_: ast::expr_ = ast::expr_path(test_main_path);\n \n@@ -368,7 +361,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n \n     let test_main_call_expr_: ast::expr_ =\n         ast::expr_call(@test_main_path_expr,\n-                       ~[@args_path_expr, @test_call_expr]);\n+                       [@args_path_expr, @test_call_expr]);\n \n     let test_main_call_expr: ast::expr =\n         {id: cx.next_node_id(),"}, {"sha": "5a4dcdc5e0d013a1229499b6dd642874e4f0a338", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -81,20 +81,20 @@ const LLVMOptimizeForSizeAttribute: uint = 8192u;\n const LLVMStackProtectAttribute: uint = 16384u;\n const LLVMStackProtectReqAttribute: uint = 32768u;\n const LLVMAlignmentAttribute: uint = 2031616u;\n- // 31 << 16\n+// 31 << 16\n const LLVMNoCaptureAttribute: uint = 2097152u;\n const LLVMNoRedZoneAttribute: uint = 4194304u;\n const LLVMNoImplicitFloatAttribute: uint = 8388608u;\n const LLVMNakedAttribute: uint = 16777216u;\n const LLVMInlineHintAttribute: uint = 33554432u;\n const LLVMStackAttribute: uint = 469762048u;\n- // 7 << 26\n+// 7 << 26\n const LLVMUWTableAttribute: uint = 1073741824u;\n- // 1 << 30\n+// 1 << 30\n \n \n- // Consts for the LLVM IntPredicate type, pre-cast to uint.\n- // FIXME: as above.\n+// Consts for the LLVM IntPredicate type, pre-cast to uint.\n+// FIXME: as above.\n \n \n const LLVMIntEQ: uint = 32u;\n@@ -276,9 +276,9 @@ native \"cdecl\" mod llvm = \"rustllvm\" {\n \n     /* Operations on constants of any type */\n     fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n-     /* all zeroes */\n+    /* all zeroes */\n     fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n-     /* only for int/vector */\n+    /* only for int/vector */\n     fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n     fn LLVMIsConstant(Val: ValueRef) -> Bool;\n     fn LLVMIsNull(Val: ValueRef) -> Bool;\n@@ -809,19 +809,19 @@ native \"cdecl\" mod llvm = \"rustllvm\" {\n                                                    Value: Bool);\n     fn LLVMPassManagerBuilderSetDisableUnrollLoops(PMB: PassManagerBuilderRef,\n                                                    Value: Bool);\n-    fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(PMB:\n-                                                        PassManagerBuilderRef,\n-                                                        Value: Bool);\n-    fn LLVMPassManagerBuilderUseInlinerWithThreshold(PMB:\n-                                                     PassManagerBuilderRef,\n-                                                     threshold: uint);\n-    fn LLVMPassManagerBuilderPopulateModulePassManager(PMB:\n-                                                       PassManagerBuilderRef,\n-                                                       PM: PassManagerRef);\n-\n-    fn LLVMPassManagerBuilderPopulateFunctionPassManager(PMB:\n-                                                        PassManagerBuilderRef,\n-                                                         PM: PassManagerRef);\n+    fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n+        PMB: PassManagerBuilderRef,\n+        threshold: uint);\n+    fn LLVMPassManagerBuilderPopulateModulePassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef);\n+\n+    fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef);\n \n     /** Destroys a memory buffer. */\n     fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n@@ -905,68 +905,68 @@ native \"cdecl\" mod llvm = \"rustllvm\" {\n  * it's attached to.\n  */\n \n-resource BuilderRef_res(B: BuilderRef) {\n-    llvm::LLVMDisposeBuilder(B);\n-}\n+resource BuilderRef_res(B: BuilderRef) { llvm::LLVMDisposeBuilder(B); }\n+\n+obj builder(B: BuilderRef,\n+            terminated: @mutable bool,\n \n-obj builder(B: BuilderRef, terminated: @mutable bool,\n             // Stored twice so that we don't have to constantly deref\n             res: @BuilderRef_res) {\n     /* Terminators */\n     fn RetVoid() -> ValueRef {\n-        assert (!*terminated);\n+        assert (!*terminated);;\n         *terminated = true;\n         ret llvm::LLVMBuildRetVoid(B);\n     }\n \n     fn Ret(V: ValueRef) -> ValueRef {\n-        assert (!*terminated);\n+        assert (!*terminated);;\n         *terminated = true;\n         ret llvm::LLVMBuildRet(B, V);\n     }\n \n     fn AggregateRet(RetVals: &[ValueRef]) -> ValueRef {\n-        assert (!*terminated);\n+        assert (!*terminated);;\n         *terminated = true;\n         ret llvm::LLVMBuildAggregateRet(B, vec::to_ptr(RetVals),\n                                         vec::len(RetVals));\n     }\n \n     fn Br(Dest: BasicBlockRef) -> ValueRef {\n-        assert (!*terminated);\n+        assert (!*terminated);;\n         *terminated = true;\n         ret llvm::LLVMBuildBr(B, Dest);\n     }\n \n     fn CondBr(If: ValueRef, Then: BasicBlockRef, Else: BasicBlockRef) ->\n        ValueRef {\n-        assert (!*terminated);\n+        assert (!*terminated);;\n         *terminated = true;\n         ret llvm::LLVMBuildCondBr(B, If, Then, Else);\n     }\n \n     fn Switch(V: ValueRef, Else: BasicBlockRef, NumCases: uint) -> ValueRef {\n-        assert (!*terminated);\n+        assert (!*terminated);;\n         *terminated = true;\n         ret llvm::LLVMBuildSwitch(B, V, Else, NumCases);\n     }\n \n     fn IndirectBr(Addr: ValueRef, NumDests: uint) -> ValueRef {\n-        assert (!*terminated);\n+        assert (!*terminated);;\n         *terminated = true;\n         ret llvm::LLVMBuildIndirectBr(B, Addr, NumDests);\n     }\n \n     fn Invoke(Fn: ValueRef, Args: &[ValueRef], Then: BasicBlockRef,\n               Catch: BasicBlockRef) -> ValueRef {\n-        assert (!*terminated);\n+        assert (!*terminated);;\n         *terminated = true;\n         ret llvm::LLVMBuildInvoke(B, Fn, vec::to_ptr(Args), vec::len(Args),\n                                   Then, Catch, str::buf(\"\"));\n     }\n \n     fn Unreachable() -> ValueRef {\n-        assert (!*terminated);\n+        assert (!*terminated);;\n         *terminated = true;\n         ret llvm::LLVMBuildUnreachable(B);\n     }\n@@ -1402,14 +1402,12 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n         let T: ValueRef =\n             llvm::LLVMGetNamedFunction(M, str::buf(\"llvm.trap\"));\n         assert (T as int != 0);\n-        let Args: [ValueRef] = ~[];\n+        let Args: [ValueRef] = [];\n         ret llvm::LLVMBuildCall(B, T, vec::to_ptr(Args), vec::len(Args),\n                                 str::buf(\"\"));\n     }\n \n-    fn is_terminated() -> bool {\n-        ret *terminated;\n-    }\n+    fn is_terminated() -> bool { ret *terminated; }\n }\n \n fn new_builder(llbb: BasicBlockRef) -> builder {\n@@ -1454,15 +1452,15 @@ fn mk_type_names() -> type_names {\n }\n \n fn type_to_str(names: type_names, ty: TypeRef) -> str {\n-    ret type_to_str_inner(names, ~[], ty);\n+    ret type_to_str_inner(names, [], ty);\n }\n \n fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n    str {\n \n     if names.type_has_name(ty) { ret names.get_name(ty); }\n \n-    let outer = outer0 + ~[ty];\n+    let outer = outer0 + [ty];\n \n     let kind: int = llvm::LLVMGetTypeKind(ty);\n \n@@ -1480,6 +1478,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n     alt kind {\n \n \n+\n       // FIXME: more enum-as-int constants determined from Core::h;\n       // horrible, horrible. Complete as needed.\n \n@@ -1494,11 +1493,13 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n       6 { ret \"Label\"; }\n \n \n+\n       7 {\n         ret \"i\" + std::int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n       }\n \n \n+\n       8 {\n         let s = \"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n@@ -1512,6 +1513,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n       }\n \n \n+\n       9 {\n         let s: str = \"{\";\n         let n_elts: uint = llvm::LLVMCountStructElementTypes(ty);\n@@ -1523,12 +1525,14 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n       }\n \n \n+\n       10 {\n         let el_ty = llvm::LLVMGetElementType(ty);\n         ret \"[\" + type_to_str_inner(names, outer, el_ty) + \"]\";\n       }\n \n \n+\n       11 {\n         let i: uint = 0u;\n         for tout: TypeRef in outer0 {\n@@ -1543,12 +1547,13 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n       }\n \n \n+\n       12 {\n         ret \"Opaque\";\n       }\n       13 { ret \"Vector\"; }\n       14 { ret \"Metadata\"; }\n-      _ { log_err #fmt(\"unknown TypeKind %d\", kind as int); fail; }\n+      _ { log_err #fmt[\"unknown TypeKind %d\", kind as int]; fail; }\n     }\n }\n "}, {"sha": "fd233ad4443261629b79bf101c5497c0cfd09448", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -67,7 +67,7 @@ fn visit_item(e: env, i: &@ast::item) {\n         }\n         let cstore = e.sess.get_cstore();\n         if !cstore::add_used_library(cstore, m.native_name) { ret; }\n-        for a: ast::attribute  in\n+        for a: ast::attribute in\n             attr::find_attrs_by_name(i.attrs, \"link_args\") {\n             alt attr::get_meta_item_value_str(attr::attr_meta(a)) {\n               some(linkarg) { cstore::add_used_link_args(cstore, linkarg); }\n@@ -93,12 +93,12 @@ fn metadata_matches(crate_data: &@[u8], metas: &[@ast::meta_item]) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n \n-    log #fmt(\"matching %u metadata requirements against %u items\",\n-             vec::len(metas), vec::len(linkage_metas));\n+    log #fmt[\"matching %u metadata requirements against %u items\",\n+             vec::len(metas), vec::len(linkage_metas)];\n \n     for needed: @ast::meta_item in metas {\n         if !attr::contains(linkage_metas, needed) {\n-            log #fmt(\"missing %s\", pprust::meta_item_to_str(*needed));\n+            log #fmt[\"missing %s\", pprust::meta_item_to_str(*needed)];\n             ret false;\n         }\n     }\n@@ -116,26 +116,26 @@ fn default_native_lib_naming(sess: session::session, static: bool) ->\n }\n \n fn find_library_crate(sess: &session::session, ident: &ast::ident,\n-                      metas: &[@ast::meta_item],\n-                      library_search_paths: &[str]) ->\n-   option::t<{ident: str, data: @[u8]}> {\n+                      metas: &[@ast::meta_item], library_search_paths: &[str])\n+   -> option::t<{ident: str, data: @[u8]}> {\n \n     attr::require_unique_names(sess, metas);\n \n     // FIXME: Probably want a warning here since the user\n     // is using the wrong type of meta item\n-    let crate_name = {\n-        let name_items = attr::find_meta_items_by_name(metas, \"name\");\n-        alt vec::last(name_items) {\n-          some(i) {\n-            alt attr::get_meta_item_value_str(i) {\n-              some(n) { n }\n-              _ { ident }\n+    let crate_name =\n+        {\n+            let name_items = attr::find_meta_items_by_name(metas, \"name\");\n+            alt vec::last(name_items) {\n+              some(i) {\n+                alt attr::get_meta_item_value_str(i) {\n+                  some(n) { n }\n+                  _ { ident }\n+                }\n+              }\n+              none. { ident }\n             }\n-          }\n-          none. { ident }\n-        }\n-    };\n+        };\n \n     let nn = default_native_lib_naming(sess, sess.get_opts().static);\n     let x =\n@@ -157,23 +157,23 @@ fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: str,\n     // manually filtering fs::list_dir here.\n \n     for library_search_path: str in library_search_paths {\n-        log #fmt(\"searching %s\", library_search_path);\n+        log #fmt[\"searching %s\", library_search_path];\n         for path: str in fs::list_dir(library_search_path) {\n-            log #fmt(\"searching %s\", path);\n+            log #fmt[\"searching %s\", path];\n             let f: str = fs::basename(path);\n             if !(str::starts_with(f, prefix) && str::ends_with(f, nn.suffix))\n                {\n-                log #fmt(\"skipping %s, doesn't look like %s*%s\", path, prefix,\n-                         nn.suffix);\n+                log #fmt[\"skipping %s, doesn't look like %s*%s\", path, prefix,\n+                         nn.suffix];\n                 cont;\n             }\n             alt get_metadata_section(path) {\n               option::some(cvec) {\n                 if !metadata_matches(cvec, metas) {\n-                    log #fmt(\"skipping %s, metadata doesn't match\", path);\n+                    log #fmt[\"skipping %s, metadata doesn't match\", path];\n                     cont;\n                 }\n-                log #fmt(\"found %s with matching metadata\", path);\n+                log #fmt[\"found %s with matching metadata\", path];\n                 ret some({ident: path, data: cvec});\n               }\n               _ { }\n@@ -204,15 +204,14 @@ fn get_metadata_section(filename: str) -> option::t<@[u8]> {\n }\n \n fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n-                      metas: &[@ast::meta_item],\n-                      library_search_paths: &[str]) ->\n-   {ident: str, data: @[u8]} {\n+                      metas: &[@ast::meta_item], library_search_paths: &[str])\n+   -> {ident: str, data: @[u8]} {\n \n \n     alt find_library_crate(sess, ident, metas, library_search_paths) {\n       some(t) { ret t; }\n       none. {\n-        sess.span_fatal(span, #fmt(\"can't find crate for '%s'\", ident));\n+        sess.span_fatal(span, #fmt[\"can't find crate for '%s'\", ident]);\n       }\n     }\n }\n@@ -253,7 +252,7 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n     for dep: decoder::crate_dep in decoder::get_crate_deps(cdata) {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.ident;\n-        log #fmt(\"resolving dep %s\", cname);\n+        log #fmt[\"resolving dep %s\", cname];\n         if e.crate_cache.contains_key(cname) {\n             log \"already have it\";\n             // We've already seen this crate\n@@ -264,7 +263,7 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n             // This is a new one so we've got to load it\n             // FIXME: Need better error reporting than just a bogus span\n             let fake_span = ast::dummy_sp();\n-            let local_cnum = resolve_crate(e, cname, ~[], fake_span);\n+            let local_cnum = resolve_crate(e, cname, [], fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n         }\n     }"}, {"sha": "ed737e046ec567aec443e714e3fb2abef6af0635", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -56,9 +56,9 @@ fn mk_cstore() -> cstore {\n     let crate_map = map::new_int_hash::<ast::crate_num>();\n     ret private(@{metas: meta_cache,\n                   use_crate_map: crate_map,\n-                  mutable used_crate_files: ~[],\n-                  mutable used_libraries: ~[],\n-                  mutable used_link_args: ~[]});\n+                  mutable used_crate_files: [],\n+                  mutable used_libraries: [],\n+                  mutable used_link_args: []});\n }\n \n fn get_crate_data(cstore: &cstore, cnum: ast::crate_num) -> crate_metadata {\n@@ -76,15 +76,15 @@ fn have_crate_data(cstore: &cstore, cnum: ast::crate_num) -> bool {\n \n iter iter_crate_data(cstore: &cstore) ->\n      @{key: ast::crate_num, val: crate_metadata} {\n-    for each kv: @{key: ast::crate_num, val: crate_metadata}  in\n+    for each kv: @{key: ast::crate_num, val: crate_metadata} in\n              p(cstore).metas.items() {\n         put kv;\n     }\n }\n \n fn add_used_crate_file(cstore: &cstore, lib: &str) {\n     if !vec::member(lib, p(cstore).used_crate_files) {\n-        p(cstore).used_crate_files += ~[lib];\n+        p(cstore).used_crate_files += [lib];\n     }\n }\n \n@@ -97,7 +97,7 @@ fn add_used_library(cstore: &cstore, lib: &str) -> bool {\n \n     if vec::member(lib, p(cstore).used_libraries) { ret false; }\n \n-    p(cstore).used_libraries += ~[lib];\n+    p(cstore).used_libraries += [lib];\n     ret true;\n }\n "}, {"sha": "972334ddfc7aba40fe386faefdbdc2814aa3e250", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -33,9 +33,9 @@ export external_resolver;\n // def_id for an item defined in another crate, somebody needs to figure out\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n-type external_resolver = fn(&ast::def_id) -> ast::def_id ;\n+type external_resolver = fn(&ast::def_id) -> ast::def_id;\n \n-fn lookup_hash(d: &ebml::doc, eq_fn: fn(&[u8]) -> bool , hash: uint) ->\n+fn lookup_hash(d: &ebml::doc, eq_fn: fn(&[u8]) -> bool, hash: uint) ->\n    [ebml::doc] {\n     let index = ebml::get_doc(d, tag_index);\n     let table = ebml::get_doc(index, tag_index_table);\n@@ -44,27 +44,26 @@ fn lookup_hash(d: &ebml::doc, eq_fn: fn(&[u8]) -> bool , hash: uint) ->\n     let bucket = ebml::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n \n-    let result: [ebml::doc] = ~[];\n+    let result: [ebml::doc] = [];\n     let belt = tag_index_buckets_bucket_elt;\n     for each elt: ebml::doc in ebml::tagged_docs(bucket, belt) {\n         let pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n         if eq_fn(vec::slice::<u8>(*elt.data, elt.start + 4u, elt.end)) {\n-            result += ~[ebml::doc_at(d.data, pos)];\n+            result += [ebml::doc_at(d.data, pos)];\n         }\n     }\n     ret result;\n }\n \n-fn maybe_find_item(item_id: int, items: &ebml::doc) ->\n-   option::t<ebml::doc> {\n+fn maybe_find_item(item_id: int, items: &ebml::doc) -> option::t<ebml::doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         ret ebml::be_uint_from_bytes(@bytes, 0u, 4u) as int == item_id;\n     }\n     let eqer = bind eq_item(_, item_id);\n     let found = lookup_hash(items, eqer, hash_node_id(item_id));\n     if vec::len(found) == 0u {\n         ret option::none::<ebml::doc>;\n-    } else { ret option::some::<ebml::doc>(found.(0)); }\n+    } else { ret option::some::<ebml::doc>(found[0]); }\n }\n \n fn find_item(item_id: int, items: &ebml::doc) -> ebml::doc {\n@@ -115,19 +114,20 @@ fn item_type(item: &ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n }\n \n fn item_ty_param_kinds(item: &ebml::doc) -> [ast::kind] {\n-    let ks: [ast::kind] = ~[];\n+    let ks: [ast::kind] = [];\n     let tp = tag_items_data_item_ty_param_kinds;\n     for each p: ebml::doc in ebml::tagged_docs(item, tp) {\n-        let dat : [u8] = ebml::doc_data(p);\n+        let dat: [u8] = ebml::doc_data(p);\n         let vi = ebml::vint_at(dat, 0u);\n         let i = 0u;\n         while i < vi.val {\n-            let k = alt dat.(vi.next + i) as char {\n-              'u' { ast::kind_unique }\n-              's' { ast::kind_shared }\n-              'p' { ast::kind_pinned }\n-            };\n-            ks += ~[k];\n+            let k =\n+                alt dat[vi.next + i] as char {\n+                  'u' { ast::kind_unique }\n+                  's' { ast::kind_shared }\n+                  'p' { ast::kind_pinned }\n+                };\n+            ks += [k];\n             i += 1u;\n         }\n     }\n@@ -136,11 +136,11 @@ fn item_ty_param_kinds(item: &ebml::doc) -> [ast::kind] {\n \n fn tag_variant_ids(item: &ebml::doc, this_cnum: ast::crate_num) ->\n    [ast::def_id] {\n-    let ids: [ast::def_id] = ~[];\n+    let ids: [ast::def_id] = [];\n     let v = tag_items_data_item_variant;\n     for each p: ebml::doc in ebml::tagged_docs(item, v) {\n         let ext = parse_def_id(ebml::doc_data(p));\n-        ids += ~[{crate: this_cnum, node: ext.node}];\n+        ids += [{crate: this_cnum, node: ext.node}];\n     }\n     ret ids;\n }\n@@ -155,10 +155,10 @@ fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n     let md = ebml::new_doc(data);\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n-    let result: [ast::def_id] = ~[];\n+    let result: [ast::def_id] = [];\n     for doc: ebml::doc in lookup_hash(paths, eqer, hash_path(s)) {\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n-        result += ~[parse_def_id(ebml::doc_data(did_doc))];\n+        result += [parse_def_id(ebml::doc_data(did_doc))];\n     }\n     ret result;\n }\n@@ -203,12 +203,12 @@ fn get_type(data: @[u8], def: ast::def_id, tcx: &ty::ctxt,\n     let node_id = def.node;\n     let item = lookup_item(node_id, data);\n     let t = item_type(item, this_cnum, tcx, extres);\n-    let tp_kinds : [ast::kind];\n+    let tp_kinds: [ast::kind];\n     let fam_ch = item_family(item);\n     let has_ty_params = family_has_type_params(fam_ch);\n     if has_ty_params {\n         tp_kinds = item_ty_param_kinds(item);\n-    } else { tp_kinds = ~[]; }\n+    } else { tp_kinds = []; }\n     ret {kinds: tp_kinds, ty: t};\n }\n \n@@ -231,22 +231,22 @@ fn get_tag_variants(_data: &@[u8], def: ast::def_id, tcx: &ty::ctxt,\n         cstore::get_crate_data(tcx.sess.get_cstore(), external_crate_id).data;\n     let items = ebml::get_doc(ebml::new_doc(data), tag_items);\n     let item = find_item(def.node, items);\n-    let infos: [ty::variant_info] = ~[];\n+    let infos: [ty::variant_info] = [];\n     let variant_ids = tag_variant_ids(item, external_crate_id);\n     for did: ast::def_id in variant_ids {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type(item, external_crate_id, tcx, extres);\n-        let arg_tys: [ty::t] = ~[];\n+        let arg_tys: [ty::t] = [];\n         alt ty::struct(tcx, ctor_ty) {\n           ty::ty_fn(_, args, _, _, _) {\n-            for a: ty::arg in args { arg_tys += ~[a.ty]; }\n+            for a: ty::arg in args { arg_tys += [a.ty]; }\n           }\n           _ {\n             // Nullary tag variant.\n \n           }\n         }\n-        infos += ~[{args: arg_tys, ctor_ty: ctor_ty, id: did}];\n+        infos += [{args: arg_tys, ctor_ty: ctor_ty, id: did}];\n     }\n     ret infos;\n }\n@@ -295,47 +295,47 @@ fn item_family_to_str(fam: u8) -> str {\n }\n \n fn get_meta_items(md: &ebml::doc) -> [@ast::meta_item] {\n-    let items: [@ast::meta_item] = ~[];\n-    for each meta_item_doc: ebml::doc  in\n+    let items: [@ast::meta_item] = [];\n+    for each meta_item_doc: ebml::doc in\n              ebml::tagged_docs(md, tag_meta_item_word) {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n-        items += ~[attr::mk_word_item(n)];\n+        items += [attr::mk_word_item(n)];\n     }\n-    for each meta_item_doc: ebml::doc  in\n+    for each meta_item_doc: ebml::doc in\n              ebml::tagged_docs(md, tag_meta_item_name_value) {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n         let v = str::unsafe_from_bytes(ebml::doc_data(vd));\n         // FIXME (#611): Should be able to decode meta_name_value variants,\n         // but currently they can't be encoded\n-        items += ~[attr::mk_name_value_item_str(n, v)];\n+        items += [attr::mk_name_value_item_str(n, v)];\n     }\n-    for each meta_item_doc: ebml::doc  in\n+    for each meta_item_doc: ebml::doc in\n              ebml::tagged_docs(md, tag_meta_item_list) {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n-        items += ~[attr::mk_list_item(n, subitems)];\n+        items += [attr::mk_list_item(n, subitems)];\n     }\n     ret items;\n }\n \n fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n-    let attrs: [ast::attribute] = ~[];\n+    let attrs: [ast::attribute] = [];\n     alt ebml::maybe_get_doc(md, tag_attributes) {\n       option::some(attrs_d) {\n-        for each attr_doc: ebml::doc  in\n+        for each attr_doc: ebml::doc in\n                  ebml::tagged_docs(attrs_d, tag_attribute) {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n             assert (vec::len(meta_items) == 1u);\n-            let meta_item = meta_items.(0);\n+            let meta_item = meta_items[0];\n             attrs +=\n-                ~[{node: {style: ast::attr_outer, value: *meta_item},\n-                   span: ast::dummy_sp()}];\n+                [{node: {style: ast::attr_outer, value: *meta_item},\n+                  span: ast::dummy_sp()}];\n         }\n       }\n       option::none. { }\n@@ -345,15 +345,15 @@ fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n \n fn list_meta_items(meta_items: &ebml::doc, out: io::writer) {\n     for mi: @ast::meta_item in get_meta_items(meta_items) {\n-        out.write_str(#fmt(\"%s\\n\", pprust::meta_item_to_str(*mi)));\n+        out.write_str(#fmt[\"%s\\n\", pprust::meta_item_to_str(*mi)]);\n     }\n }\n \n fn list_crate_attributes(md: &ebml::doc, out: io::writer) {\n     out.write_str(\"=Crate Attributes=\\n\");\n \n     for attr: ast::attribute in get_attributes(md) {\n-        out.write_str(#fmt(\"%s\\n\", pprust::attribute_to_str(attr)));\n+        out.write_str(#fmt[\"%s\\n\", pprust::attribute_to_str(attr)]);\n     }\n \n     out.write_str(\"\\n\\n\");\n@@ -366,14 +366,13 @@ fn get_crate_attributes(data: @[u8]) -> [ast::attribute] {\n type crate_dep = {cnum: ast::crate_num, ident: str};\n \n fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n-    let deps: [crate_dep] = ~[];\n+    let deps: [crate_dep] = [];\n     let cratedoc = ebml::new_doc(data);\n     let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n     let crate_num = 1;\n-    for each depdoc: ebml::doc  in\n-             ebml::tagged_docs(depsdoc, tag_crate_dep) {\n+    for each depdoc: ebml::doc in ebml::tagged_docs(depsdoc, tag_crate_dep) {\n         let depname = str::unsafe_from_bytes(ebml::doc_data(depdoc));\n-        deps += ~[{cnum: crate_num, ident: depname}];\n+        deps += [{cnum: crate_num, ident: depname}];\n         crate_num += 1;\n     }\n     ret deps;\n@@ -383,7 +382,7 @@ fn list_crate_deps(data: @[u8], out: io::writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n     for dep: crate_dep in get_crate_deps(data) {\n-        out.write_str(#fmt(\"%d %s\\n\", dep.cnum, dep.ident));\n+        out.write_str(#fmt[\"%d %s\\n\", dep.cnum, dep.ident]);\n     }\n \n     out.write_str(\"\\n\");\n@@ -395,16 +394,16 @@ fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n     let items = ebml::get_doc(md, tag_items);\n     let index = ebml::get_doc(paths, tag_index);\n     let bs = ebml::get_doc(index, tag_index_buckets);\n-    for each bucket: ebml::doc  in\n+    for each bucket: ebml::doc in\n              ebml::tagged_docs(bs, tag_index_buckets_bucket) {\n         let et = tag_index_buckets_bucket_elt;\n         for each elt: ebml::doc in ebml::tagged_docs(bucket, et) {\n             let data = read_path(elt);\n             let def = ebml::doc_at(bytes, data.pos);\n             let did_doc = ebml::get_doc(def, tag_def_id);\n             let did = parse_def_id(ebml::doc_data(did_doc));\n-            out.write_str(#fmt(\"%s (%s)\\n\", data.path,\n-                               describe_def(items, did)));\n+            out.write_str(#fmt[\"%s (%s)\\n\", data.path,\n+                               describe_def(items, did)]);\n         }\n     }\n     out.write_str(\"\\n\");"}, {"sha": "babfc2ce77cd2fb819e304ebe32823d42877e9f1", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -51,14 +51,13 @@ fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n \n fn add_to_index(ebml_w: &ebml::writer, path: &[str],\n                 index: &mutable [entry<str>], name: &str) {\n-    let full_path = path + ~[name];\n+    let full_path = path + [name];\n     index +=\n-        ~[{val: str::connect(full_path, \"::\"),\n-           pos: ebml_w.writer.tell()}];\n+        [{val: str::connect(full_path, \"::\"), pos: ebml_w.writer.tell()}];\n }\n \n-fn encode_native_module_item_paths(ebml_w: &ebml::writer,\n-                                   nmod: &native_mod, path: &[str],\n+fn encode_native_module_item_paths(ebml_w: &ebml::writer, nmod: &native_mod,\n+                                   path: &[str],\n                                    index: &mutable [entry<str>]) {\n     for nitem: @native_item in nmod.items {\n         add_to_index(ebml_w, path, index, nitem.ident);\n@@ -93,15 +92,15 @@ fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n             ebml::start_tag(ebml_w, tag_paths_data_mod);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            encode_module_item_paths(ebml_w, _mod, path + ~[it.ident], index);\n+            encode_module_item_paths(ebml_w, _mod, path + [it.ident], index);\n             ebml::end_tag(ebml_w);\n           }\n           item_native_mod(nmod) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_mod);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            encode_native_module_item_paths(ebml_w, nmod, path + ~[it.ident],\n+            encode_native_module_item_paths(ebml_w, nmod, path + [it.ident],\n                                             index);\n             ebml::end_tag(ebml_w);\n           }\n@@ -148,10 +147,9 @@ fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n     }\n }\n \n-fn encode_item_paths(ebml_w: &ebml::writer, crate: &@crate) ->\n-   [entry<str>] {\n-    let index: [entry<str>] = ~[];\n-    let path: [str] = ~[];\n+fn encode_item_paths(ebml_w: &ebml::writer, crate: &@crate) -> [entry<str>] {\n+    let index: [entry<str>] = [];\n+    let path: [str] = [];\n     ebml::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n     ebml::end_tag(ebml_w);\n@@ -162,28 +160,29 @@ fn encode_item_paths(ebml_w: &ebml::writer, crate: &@crate) ->\n // Item info table encoding\n fn encode_family(ebml_w: &ebml::writer, c: u8) {\n     ebml::start_tag(ebml_w, tag_items_data_item_family);\n-    ebml_w.writer.write(~[c]);\n+    ebml_w.writer.write([c]);\n     ebml::end_tag(ebml_w);\n }\n \n fn encode_inlineness(ebml_w: &ebml::writer, c: u8) {\n     ebml::start_tag(ebml_w, tag_items_data_item_inlineness);\n-    ebml_w.writer.write(~[c]);\n+    ebml_w.writer.write([c]);\n     ebml::end_tag(ebml_w);\n }\n \n-fn def_to_str(did: &def_id) -> str { ret #fmt(\"%d:%d\", did.crate, did.node); }\n+fn def_to_str(did: &def_id) -> str { ret #fmt[\"%d:%d\", did.crate, did.node]; }\n \n fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {\n     ebml::start_tag(ebml_w, tag_items_data_item_ty_param_kinds);\n     ebml::write_vint(ebml_w.writer, vec::len::<ty_param>(tps));\n     for tp: ty_param in tps {\n-        let c = alt tp.kind {\n-          kind_unique. { 'u' }\n-          kind_shared. { 's' }\n-          kind_pinned. { 'p' }\n-        };\n-        ebml_w.writer.write(~[c as u8]);\n+        let c =\n+            alt tp.kind {\n+              kind_unique. { 'u' }\n+              kind_shared. { 's' }\n+              kind_pinned. { 'p' }\n+            };\n+        ebml_w.writer.write([c as u8]);\n     }\n     ebml::end_tag(ebml_w);\n }\n@@ -229,7 +228,7 @@ fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n                            index: &mutable [entry<int>],\n                            ty_params: &[ty_param]) {\n     for variant: variant in variants {\n-        index += ~[{val: variant.node.id, pos: ebml_w.writer.tell()}];\n+        index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_family(ebml_w, 'v' as u8);\n@@ -245,8 +244,8 @@ fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n     }\n }\n \n-fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebml::writer,\n-                        item: @item, index: &mutable [entry<int>]) {\n+fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebml::writer, item: @item,\n+                        index: &mutable [entry<int>]) {\n     alt item.node {\n       item_const(_, _) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n@@ -260,8 +259,10 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebml::writer,\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w,\n-                    alt fd.decl.purity { pure_fn. { 'p' } impure_fn. { 'f' } }\n-                        as u8);\n+                      alt fd.decl.purity {\n+                        pure_fn. { 'p' }\n+                        impure_fn. { 'f' }\n+                      } as u8);\n         encode_inlineness(ebml_w,\n                           alt fd.decl.il {\n                             il_normal. { 'n' }\n@@ -315,7 +316,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebml::writer,\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n \n-        index += ~[{val: ctor_id, pos: ebml_w.writer.tell()}];\n+        index += [{val: ctor_id, pos: ebml_w.writer.tell()}];\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'f' as u8);\n@@ -334,7 +335,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebml::writer,\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n         ebml::end_tag(ebml_w);\n \n-        index += ~[{val: ctor_id, pos: ebml_w.writer.tell()}];\n+        index += [{val: ctor_id, pos: ebml_w.writer.tell()}];\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'f' as u8);\n@@ -369,17 +370,17 @@ fn encode_info_for_native_item(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n \n fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebml::writer) ->\n    [entry<int>] {\n-    let index: [entry<int>] = ~[];\n+    let index: [entry<int>] = [];\n     ebml::start_tag(ebml_w, tag_items_data);\n-    for each kvp: @{key: node_id, val: middle::ast_map::ast_node}  in\n+    for each kvp: @{key: node_id, val: middle::ast_map::ast_node} in\n              ecx.ccx.ast_map.items() {\n         alt kvp.val {\n           middle::ast_map::node_item(i) {\n-            index += ~[{val: kvp.key, pos: ebml_w.writer.tell()}];\n+            index += [{val: kvp.key, pos: ebml_w.writer.tell()}];\n             encode_info_for_item(ecx, ebml_w, i, index);\n           }\n           middle::ast_map::node_native_item(i) {\n-            index += ~[{val: kvp.key, pos: ebml_w.writer.tell()}];\n+            index += [{val: kvp.key, pos: ebml_w.writer.tell()}];\n             encode_info_for_native_item(ecx, ebml_w, i);\n           }\n           _ { }\n@@ -392,30 +393,30 @@ fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebml::writer) ->\n \n // Path and definition ID indexing\n \n-fn create_index<T>(index: &[entry<T>], hash_fn: fn(&T) -> uint ) ->\n+fn create_index<T>(index: &[entry<T>], hash_fn: fn(&T) -> uint) ->\n    [@[entry<T>]] {\n-    let buckets: [@mutable [entry<T>]] = ~[];\n-    for each i: uint in uint::range(0u, 256u) { buckets += ~[@mutable ~[]]; }\n+    let buckets: [@mutable [entry<T>]] = [];\n+    for each i: uint in uint::range(0u, 256u) { buckets += [@mutable []]; }\n     for elt: entry<T> in index {\n         let h = hash_fn(elt.val);\n-        *buckets.(h % 256u) += ~[elt];\n+        *buckets[h % 256u] += [elt];\n     }\n \n-    let buckets_frozen = ~[];\n+    let buckets_frozen = [];\n     for bucket: @mutable [entry<T>] in buckets {\n-        buckets_frozen += ~[@*bucket];\n+        buckets_frozen += [@*bucket];\n     }\n     ret buckets_frozen;\n }\n \n fn encode_index<T>(ebml_w: &ebml::writer, buckets: &[@[entry<T>]],\n-                   write_fn: fn(&io::writer, &T) ) {\n+                   write_fn: fn(&io::writer, &T)) {\n     let writer = io::new_writer_(ebml_w.writer);\n     ebml::start_tag(ebml_w, tag_index);\n-    let bucket_locs: [uint] = ~[];\n+    let bucket_locs: [uint] = [];\n     ebml::start_tag(ebml_w, tag_index_buckets);\n     for bucket: @[entry<T>] in buckets {\n-        bucket_locs += ~[ebml_w.writer.tell()];\n+        bucket_locs += [ebml_w.writer.tell()];\n         ebml::start_tag(ebml_w, tag_index_buckets_bucket);\n         for elt: entry<T> in *bucket {\n             ebml::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n@@ -508,30 +509,30 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n                 attr::remove_meta_items_by_name(tmp, \"vers\")\n             };\n \n-        let meta_items = ~[name_item, vers_item] + other_items;\n+        let meta_items = [name_item, vers_item] + other_items;\n         let link_item = attr::mk_list_item(\"link\", meta_items);\n \n         ret attr::mk_attr(link_item);\n     }\n \n-    let attrs: [attribute] = ~[];\n+    let attrs: [attribute] = [];\n     let found_link_attr = false;\n     for attr: attribute in crate.node.attrs {\n         attrs +=\n             if attr::get_attr_name(attr) != \"link\" {\n-                ~[attr]\n+                [attr]\n             } else {\n                 alt attr.node.value.node {\n                   meta_list(n, l) {\n                     found_link_attr = true;\n-                    ~[synthesize_link_attr(ecx, l)]\n+                    [synthesize_link_attr(ecx, l)]\n                   }\n-                  _ { ~[attr] }\n+                  _ { [attr] }\n                 }\n             }\n     }\n \n-    if !found_link_attr { attrs += ~[synthesize_link_attr(ecx, ~[])]; }\n+    if !found_link_attr { attrs += [synthesize_link_attr(ecx, [])]; }\n \n     ret attrs;\n }\n@@ -543,9 +544,9 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n         type numname = {crate: crate_num, ident: str};\n \n         // Pull the cnums and names out of cstore\n-        let pairs: [mutable numname] = ~[mutable];\n+        let pairs: [mutable numname] = [mutable];\n         for each hashkv: hashkv in cstore::iter_crate_data(cstore) {\n-            pairs += ~[mutable {crate: hashkv.key, ident: hashkv.val.name}];\n+            pairs += [mutable {crate: hashkv.key, ident: hashkv.val.name}];\n         }\n \n         // Sort by cnum\n@@ -612,7 +613,7 @@ fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n \n-    buf_w.write(~[0u8, 0u8, 0u8, 0u8]);\n+    buf_w.write([0u8, 0u8, 0u8, 0u8]);\n     ret string_w.get_str();\n }\n "}, {"sha": "31034b7a6aed31e76e044487df4b224a025cc22a", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -19,17 +19,17 @@ export parse_ty_data;\n // data buffer. Whatever format you choose should not contain pipe characters.\n \n // Callback to translate defs to strs or back:\n-type str_def = fn(str) -> ast::def_id ;\n+type str_def = fn(str) -> ast::def_id;\n \n type pstate =\n     {data: @[u8], crate: int, mutable pos: uint, len: uint, tcx: ty::ctxt};\n \n tag ty_or_bang { a_ty(ty::t); a_bang; }\n \n-fn peek(st: @pstate) -> u8 { ret st.data.(st.pos); }\n+fn peek(st: @pstate) -> u8 { ret st.data[st.pos]; }\n \n fn next(st: @pstate) -> u8 {\n-    let ch = st.data.(st.pos);\n+    let ch = st.data[st.pos];\n     st.pos = st.pos + 1u;\n     ret ch;\n }\n@@ -39,7 +39,7 @@ fn parse_ident(st: @pstate, sd: str_def, last: char) -> ast::ident {\n     ret parse_ident_(st, sd, bind is_last(last, _));\n }\n \n-fn parse_ident_(st: @pstate, _sd: str_def, is_last: fn(char) -> bool ) ->\n+fn parse_ident_(st: @pstate, _sd: str_def, is_last: fn(char) -> bool) ->\n    ast::ident {\n     let rslt = \"\";\n     while !is_last(peek(st) as char) {\n@@ -65,14 +65,14 @@ fn parse_ty_or_bang(st: @pstate, sd: str_def) -> ty_or_bang {\n }\n \n fn parse_constrs(st: @pstate, sd: str_def) -> [@ty::constr] {\n-    let rslt: [@ty::constr] = ~[];\n+    let rslt: [@ty::constr] = [];\n     alt peek(st) as char {\n       ':' {\n         do  {\n             next(st);\n             let one: @ty::constr =\n                 parse_constr::<uint>(st, sd, parse_constr_arg);\n-            rslt += ~[one];\n+            rslt += [one];\n         } while peek(st) as char == ';'\n       }\n       _ { }\n@@ -82,14 +82,14 @@ fn parse_constrs(st: @pstate, sd: str_def) -> [@ty::constr] {\n \n // FIXME less copy-and-paste\n fn parse_ty_constrs(st: @pstate, sd: str_def) -> [@ty::type_constr] {\n-    let rslt: [@ty::type_constr] = ~[];\n+    let rslt: [@ty::type_constr] = [];\n     alt peek(st) as char {\n       ':' {\n         do  {\n             next(st);\n             let one: @ty::type_constr =\n                 parse_constr::<path>(st, sd, parse_ty_constr_arg);\n-            rslt += ~[one];\n+            rslt += [one];\n         } while peek(st) as char == ';'\n       }\n       _ { }\n@@ -98,24 +98,24 @@ fn parse_ty_constrs(st: @pstate, sd: str_def) -> [@ty::type_constr] {\n }\n \n fn parse_path(st: @pstate, sd: str_def) -> ast::path {\n-    let idents: [ast::ident] = ~[];\n+    let idents: [ast::ident] = [];\n     fn is_last(c: char) -> bool { ret c == '(' || c == ':'; }\n-    idents += ~[parse_ident_(st, sd, is_last)];\n+    idents += [parse_ident_(st, sd, is_last)];\n     while true {\n         alt peek(st) as char {\n           ':' { next(st); next(st); }\n           c {\n             if c == '(' {\n                 ret respan(ast::dummy_sp(),\n-                           {global: false, idents: idents, types: ~[]});\n-            } else { idents += ~[parse_ident_(st, sd, is_last)]; }\n+                           {global: false, idents: idents, types: []});\n+            } else { idents += [parse_ident_(st, sd, is_last)]; }\n           }\n         }\n     }\n     fail \"parse_path: ill-formed path\";\n }\n \n-type arg_parser<T> = fn(@pstate, str_def) -> ast::constr_arg_general_<T> ;\n+type arg_parser<T> = fn(@pstate, str_def) -> ast::constr_arg_general_<T>;\n \n fn parse_constr_arg(st: @pstate, _sd: str_def) -> ast::fn_constr_arg {\n     alt peek(st) as char {\n@@ -153,7 +153,7 @@ fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n fn parse_constr<@T>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n    @ty::constr_general<T> {\n     let sp = ast::dummy_sp(); // FIXME: use a real span\n-    let args: [@sp_constr_arg<T>] = ~[];\n+    let args: [@sp_constr_arg<T>] = [];\n     let pth: path = parse_path(st, sd);\n     let ignore: char = next(st) as char;\n     assert (ignore as char == '(');\n@@ -162,7 +162,7 @@ fn parse_constr<@T>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n     do  {\n         an_arg = pser(st, sd);\n         // FIXME use a real span\n-        args += ~[@respan(sp, an_arg)];\n+        args += [@respan(sp, an_arg)];\n         ignore = next(st) as char;\n     } while ignore == ';'\n     assert (ignore == ')');\n@@ -197,21 +197,23 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       't' {\n         assert (next(st) as char == '[');\n         let def = parse_def(st, sd);\n-        let params: [ty::t] = ~[];\n-        while peek(st) as char != ']' { params += ~[parse_ty(st, sd)]; }\n+        let params: [ty::t] = [];\n+        while peek(st) as char != ']' { params += [parse_ty(st, sd)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_tag(st.tcx, def, params);\n       }\n       'p' {\n-        let k = alt next(st) as char {\n-          'u' { kind_unique }\n-          's' { kind_shared }\n-          'p' { kind_pinned }\n-          c {\n-            log_err \"unexpected char in encoded type param: \";\n-            log_err c; fail\n-          }\n-        };\n+        let k =\n+            alt next(st) as char {\n+              'u' { kind_unique }\n+              's' { kind_shared }\n+              'p' { kind_pinned }\n+              c {\n+                log_err \"unexpected char in encoded type param: \";\n+                log_err c;\n+                fail\n+              }\n+            };\n         ret ty::mk_param(st.tcx, parse_int(st) as uint, k);\n       }\n       '@' { ret ty::mk_box(st.tcx, parse_mt(st, sd)); }\n@@ -220,22 +222,22 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       'I' { ret ty::mk_vec(st.tcx, parse_mt(st, sd)); }\n       'R' {\n         assert (next(st) as char == '[');\n-        let fields: [ty::field] = ~[];\n+        let fields: [ty::field] = [];\n         while peek(st) as char != ']' {\n             let name = \"\";\n             while peek(st) as char != '=' {\n                 name += str::unsafe_from_byte(next(st));\n             }\n             st.pos = st.pos + 1u;\n-            fields += ~[{ident: name, mt: parse_mt(st, sd)}];\n+            fields += [{ident: name, mt: parse_mt(st, sd)}];\n         }\n         st.pos = st.pos + 1u;\n         ret ty::mk_rec(st.tcx, fields);\n       }\n       'T' {\n         assert (next(st) as char == '[');\n-        let params = ~[];\n-        while peek(st) as char != ']' { params += ~[parse_ty(st, sd)]; }\n+        let params = [];\n+        while peek(st) as char != ']' { params += [parse_ty(st, sd)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_tup(st.tcx, params);\n       }\n@@ -268,7 +270,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       }\n       'O' {\n         assert (next(st) as char == '[');\n-        let methods: [ty::method] = ~[];\n+        let methods: [ty::method] = [];\n         while peek(st) as char != ']' {\n             let proto;\n             alt next(st) as char {\n@@ -281,12 +283,12 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n             }\n             let func = parse_ty_fn(st, sd);\n             methods +=\n-                ~[{proto: proto,\n-                   ident: name,\n-                   inputs: func.args,\n-                   output: func.ty,\n-                   cf: func.cf,\n-                   constrs: func.cs}];\n+                [{proto: proto,\n+                  ident: name,\n+                  inputs: func.args,\n+                  output: func.ty,\n+                  cf: func.cf,\n+                  constrs: func.cs}];\n         }\n         st.pos += 1u;\n         ret ty::mk_obj(st.tcx, methods);\n@@ -295,8 +297,8 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         assert (next(st) as char == '[');\n         let def = parse_def(st, sd);\n         let inner = parse_ty(st, sd);\n-        let params: [ty::t] = ~[];\n-        while peek(st) as char != ']' { params += ~[parse_ty(st, sd)]; }\n+        let params: [ty::t] = [];\n+        while peek(st) as char != ']' { params += [parse_ty(st, sd)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_res(st.tcx, def, inner, params);\n       }\n@@ -375,7 +377,7 @@ fn parse_hex(st: @pstate) -> uint {\n fn parse_ty_fn(st: @pstate, sd: str_def) ->\n    {args: [ty::arg], ty: ty::t, cf: ast::controlflow, cs: [@ty::constr]} {\n     assert (next(st) as char == '[');\n-    let inputs: [ty::arg] = ~[];\n+    let inputs: [ty::arg] = [];\n     while peek(st) as char != ']' {\n         let mode = ty::mo_val;\n         if peek(st) as char == '&' {\n@@ -389,7 +391,7 @@ fn parse_ty_fn(st: @pstate, sd: str_def) ->\n             mode = ty::mo_move;\n             st.pos += 1u;\n         }\n-        inputs += ~[{mode: mode, ty: parse_ty(st, sd)}];\n+        inputs += [{mode: mode, ty: parse_ty(st, sd)}];\n     }\n     st.pos += 1u; // eat the ']'\n     let cs = parse_constrs(st, sd);\n@@ -406,18 +408,18 @@ fn parse_ty_fn(st: @pstate, sd: str_def) ->\n fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let colon_idx = 0u;\n     let len = vec::len::<u8>(buf);\n-    while colon_idx < len && buf.(colon_idx) != ':' as u8 { colon_idx += 1u; }\n+    while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n         log_err \"didn't find ':' when parsing def id\";\n         fail;\n     }\n     let crate_part = vec::slice::<u8>(buf, 0u, colon_idx);\n     let def_part = vec::slice::<u8>(buf, colon_idx + 1u, len);\n \n-    let crate_part_vec = ~[];\n-    let def_part_vec = ~[];\n-    for b: u8 in crate_part { crate_part_vec += ~[b]; }\n-    for b: u8 in def_part { def_part_vec += ~[b]; }\n+    let crate_part_vec = [];\n+    let def_part_vec = [];\n+    for b: u8 in crate_part { crate_part_vec += [b]; }\n+    for b: u8 in def_part { def_part_vec += [b]; }\n \n     let crate_num = uint::parse_buf(crate_part_vec, 10u) as int;\n     let def_num = uint::parse_buf(def_part_vec, 10u) as int;"}, {"sha": "5568804c0563d762213fbb0e4c351e3c075b8c07", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -17,9 +17,10 @@ export ac_no_abbrevs;\n export ac_use_abbrevs;\n export enc_ty;\n \n-type ctxt =  // Def -> str Callback:\n+type ctxt =\n+     // Def -> str Callback:\n      // The type context.\n-    {ds: fn(&def_id) -> str , tcx: ty::ctxt, abbrevs: abbrev_ctxt};\n+     {ds: fn(&def_id) -> str, tcx: ty::ctxt, abbrevs: abbrev_ctxt};\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n@@ -151,7 +152,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n           native_abi_llvm. { w.write_char('l'); }\n           native_abi_x86stdcall. { w.write_char('s'); }\n         }\n-        enc_ty_fn(w, cx, args, out, return, ~[]);\n+        enc_ty_fn(w, cx, args, out, return, []);\n       }\n       ty::ty_obj(methods) {\n         w.write_str(\"O[\");\n@@ -176,7 +177,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n       }\n-      ty::ty_param(id,k) {\n+      ty::ty_param(id, k) {\n         alt k {\n           kind_unique. { w.write_str(\"pu\"); }\n           kind_shared. { w.write_str(\"ps\"); }\n@@ -210,9 +211,7 @@ fn enc_ty_fn(w: &io::writer, cx: &@ctxt, args: &[ty::arg], out: &ty::t,\n             w.write_char('&');\n             if mut { w.write_char('m'); }\n           }\n-          ty::mo_move. {\n-            w.write_char('-');\n-          }\n+          ty::mo_move. { w.write_char('-'); }\n           ty::mo_val. { }\n         }\n         enc_ty(w, cx, arg.ty);"}, {"sha": "738489bb400624e1104ecda7ddd79ffa8b36c8cb", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 137, "deletions": 124, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -42,12 +42,13 @@ fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n     // Stores information about object fields and function\n     // arguments that's otherwise not easily available.\n     let cx = @{tcx: tcx, local_map: std::map::new_int_hash()};\n-    let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n-              visit_item: bind visit_item(cx, _, _, _),\n-              visit_expr: bind visit_expr(cx, _, _, _),\n-              visit_decl: bind visit_decl(cx, _, _, _)\n-              with *visit::default_visitor::<scope>()};\n-    visit::visit_crate(*crate, @~[], visit::mk_vt(v));\n+    let v =\n+        @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n+          visit_item: bind visit_item(cx, _, _, _),\n+          visit_expr: bind visit_expr(cx, _, _, _),\n+          visit_decl: bind visit_decl(cx, _, _, _)\n+             with *visit::default_visitor::<scope>()};\n+    visit::visit_crate(*crate, @[], visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n }\n \n@@ -57,27 +58,36 @@ fn visit_fn(cx: &@ctx, f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n     for arg_: ast::arg in f.decl.inputs {\n         cx.local_map.insert(arg_.id, arg(arg_.mode));\n     }\n-    let scope = alt (f.proto) {\n-      // Blocks need to obey any restrictions from the enclosing scope.\n-      ast::proto_block. { sc }\n-      // Closures need to prohibit writing to any of the upvars.\n-      // This doesn't seem like a particularly clean way to do this.\n-      ast::proto_closure. {\n-        let dnums = ~[];\n-        for each nid in freevars::get_freevar_defs(cx.tcx, id).keys() {\n-            dnums += ~[nid];\n-        }\n-        @~[@{root_vars: ~[],\n-             // I'm not sure if there is anything sensical to put here\n-             block_defnum: 0,\n-             bindings: dnums,\n-             tys: ~[],\n-             depends_on: ~[],\n-             mutable ok: valid}]\n-      }\n-      // Non capturing functions start out fresh.\n-      _ { @~[] }\n-    };\n+    let scope =\n+        alt f.proto {\n+\n+          // Blocks need to obey any restrictions from the enclosing scope.\n+          ast::proto_block. {\n+            sc\n+          }\n+\n+          // Closures need to prohibit writing to any of the upvars.\n+          // This doesn't seem like a particularly clean way to do this.\n+          ast::proto_closure. {\n+            let dnums = [];\n+            for each nid in freevars::get_freevar_defs(cx.tcx, id).keys() {\n+                dnums += [nid];\n+            };\n+            @[\n+              // I'm not sure if there is anything sensical to put here\n+              @{root_vars: [],\n+                block_defnum: 0,\n+                bindings: dnums,\n+                tys: [],\n+                depends_on: [],\n+                mutable ok: valid}]\n+          }\n+\n+          // Non capturing functions start out fresh.\n+          _ {\n+            @[]\n+          }\n+        };\n \n     v.visit_block(f.body, scope, v);\n }\n@@ -168,51 +178,54 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n    {root_vars: [node_id], unsafe_ts: [ty::t]} {\n     let fty = ty::expr_ty(cx.tcx, f);\n     let arg_ts = fty_args(cx, fty);\n-    let roots: [node_id] = ~[];\n-    let mut_roots: [{arg: uint, node: node_id}] = ~[];\n-    let unsafe_ts: [ty::t] = ~[];\n-    let unsafe_t_offsets: [uint] = ~[];\n+    let roots: [node_id] = [];\n+    let mut_roots: [{arg: uint, node: node_id}] = [];\n+    let unsafe_ts: [ty::t] = [];\n+    let unsafe_t_offsets: [uint] = [];\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n         if arg_t.mode != ty::mo_val {\n-            let arg = args.(i);\n+            let arg = args[i];\n             let root = expr_root(cx, arg, false);\n             if arg_t.mode == ty::mo_alias(true) {\n                 alt path_def(cx, arg) {\n                   some(def) {\n                     let dnum = ast::def_id_of_def(def).node;\n                     if def_is_local(def, true) {\n                         if is_immutable_alias(cx, sc, dnum) {\n-                            cx.tcx.sess.span_err\n-                                (arg.span, \"passing an immutable alias \\\n-                                            by mutable alias\");\n+                            cx.tcx.sess.span_err(\n+                                arg.span,\n+                                \"passing an immutable alias \\\n+                                 by mutable alias\");\n                         } else if is_immutable_objfield(cx, dnum) {\n-                            cx.tcx.sess.span_err\n-                                (arg.span, \"passing an immutable object \\\n-                                            field by mutable alias\");\n+                            cx.tcx.sess.span_err(\n+                                arg.span,\n+                                \"passing an immutable object \\\n+                                 field by mutable alias\");\n                         }\n                     } else {\n-                        cx.tcx.sess.span_err\n-                            (arg.span,\n-                             \"passing a static item by mutable alias\");\n+                        cx.tcx.sess.span_err(\n+                            arg.span,\n+                            \"passing a static item by mutable alias\");\n                     }\n-                    mut_roots += ~[{arg: i, node: dnum}];\n+                    mut_roots += [{arg: i, node: dnum}];\n                   }\n                   _ {\n                     if !mut_field(root.ds) {\n-                        let m = \"passing a temporary value or \\\n+                        let m =\n+                            \"passing a temporary value or \\\n                                  immutable field by mutable alias\";\n                         cx.tcx.sess.span_err(arg.span, m);\n                     }\n                   }\n                 }\n             }\n             alt path_def_id(cx, root.ex) {\n-              some(did) { roots += ~[did.node]; }\n+              some(did) { roots += [did.node]; }\n               _ { }\n             }\n             alt inner_mut(root.ds) {\n-              some(t) { unsafe_ts += ~[t]; unsafe_t_offsets += ~[i]; }\n+              some(t) { unsafe_ts += [t]; unsafe_t_offsets += [i]; }\n               _ { }\n             }\n         }\n@@ -223,27 +236,27 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n           ast::expr_path(_) {\n             if def_is_local(cx.tcx.def_map.get(f.id), true) {\n                 cx.tcx.sess.span_err(f.span,\n-                                     #fmt(\"function may alias with \\\n+                                     #fmt[\"function may alias with \\\n                          argument %u, which is not immutably rooted\",\n-                                          unsafe_t_offsets.(0)));\n+                                          unsafe_t_offsets[0]]);\n             }\n           }\n           _ { }\n         }\n     }\n     let j = 0u;\n     for unsafe: ty::t in unsafe_ts {\n-        let offset = unsafe_t_offsets.(j);\n+        let offset = unsafe_t_offsets[j];\n         j += 1u;\n         let i = 0u;\n         for arg_t: ty::arg in arg_ts {\n             let mut_alias = arg_t.mode == ty::mo_alias(true);\n             if i != offset &&\n                    ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias) {\n-                cx.tcx.sess.span_err(args.(i).span,\n-                                     #fmt(\"argument %u may alias with \\\n+                cx.tcx.sess.span_err(args[i].span,\n+                                     #fmt[\"argument %u may alias with \\\n                      argument %u, which is not immutably rooted\",\n-                                          i, offset));\n+                                          i, offset]);\n             }\n             i += 1u;\n         }\n@@ -265,7 +278,7 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n \n \n         if mut_alias_to_root {\n-            cx.tcx.sess.span_err(args.(root.arg).span,\n+            cx.tcx.sess.span_err(args[root.arg].span,\n                                  \"passing a mutable alias to a \\\n                  variable that roots another alias\");\n         }\n@@ -281,14 +294,14 @@ fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n         if arg_t.mode != ty::mo_val {\n             let mut_a = arg_t.mode == ty::mo_alias(true);\n             let ok = true;\n-            alt args.(i).node {\n+            alt args[i].node {\n               ast::expr_path(_) {\n-                let def = cx.tcx.def_map.get(args.(i).id);\n+                let def = cx.tcx.def_map.get(args[i].id);\n                 let dnum = ast::def_id_of_def(def).node;\n                 alt cx.local_map.find(dnum) {\n                   some(arg(ast::alias(mut))) {\n                     if mut_a && !mut {\n-                        cx.tcx.sess.span_err(args.(i).span,\n+                        cx.tcx.sess.span_err(args[i].span,\n                                              \"passing an immutable \\\n                                      alias by mutable alias\");\n                     }\n@@ -299,7 +312,7 @@ fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n               _ { ok = false; }\n             }\n             if !ok {\n-                cx.tcx.sess.span_err(args.(i).span,\n+                cx.tcx.sess.span_err(args[i].span,\n                                      \"can not pass a local value by \\\n                                      alias to a tail call\");\n             }\n@@ -313,26 +326,28 @@ fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n     visit::visit_expr(input, sc, v);\n     let root = expr_root(cx, input, true);\n     let roots =\n-        alt path_def_id(cx, root.ex) { some(did) { ~[did.node] } _ { ~[] } };\n+        alt path_def_id(cx, root.ex) { some(did) { [did.node] } _ { [] } };\n     let forbidden_tp: [ty::t] =\n-        alt inner_mut(root.ds) { some(t) { ~[t] } _ { ~[] } };\n+        alt inner_mut(root.ds) { some(t) { [t] } _ { [] } };\n     for a: ast::arm in arms {\n         let dnums = arm_defnums(a);\n         let new_sc = sc;\n         if vec::len(dnums) > 0u {\n-            new_sc = @(*sc + ~[@{root_vars: roots,\n-                                 block_defnum: dnums.(vec::len(dnums) - 1u),\n-                                 bindings: dnums,\n-                                 tys: forbidden_tp,\n-                                 depends_on: deps(sc, roots),\n-                                 mutable ok: valid}]);\n+            new_sc =\n+                @(*sc +\n+                      [@{root_vars: roots,\n+                         block_defnum: dnums[vec::len(dnums) - 1u],\n+                         bindings: dnums,\n+                         tys: forbidden_tp,\n+                         depends_on: deps(sc, roots),\n+                         mutable ok: valid}]);\n         }\n         visit::visit_arm(a, new_sc, v);\n     }\n }\n \n fn arm_defnums(arm: &ast::arm) -> [node_id] {\n-    ret ast::pat_binding_ids(arm.pats.(0));\n+    ret ast::pat_binding_ids(arm.pats[0]);\n }\n \n fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n@@ -342,13 +357,14 @@ fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n       ast::expr_call(f, args) {\n         let data = check_call(cx, f, args, sc);\n         let bindings = ast::pat_binding_ids(local.node.pat);\n-        let new_sc = @{root_vars: data.root_vars,\n-                       block_defnum: bindings.(vec::len(bindings) - 1u),\n-                       bindings: bindings,\n-                       tys: data.unsafe_ts,\n-                       depends_on: deps(sc, data.root_vars),\n-                       mutable ok: valid};\n-        visit::visit_block(blk, @(*sc + ~[new_sc]), v);\n+        let new_sc =\n+            @{root_vars: data.root_vars,\n+              block_defnum: bindings[vec::len(bindings) - 1u],\n+              bindings: bindings,\n+              tys: data.unsafe_ts,\n+              depends_on: deps(sc, data.root_vars),\n+              mutable ok: valid};\n+        visit::visit_block(blk, @(*sc + [new_sc]), v);\n       }\n     }\n }\n@@ -358,15 +374,13 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n     visit::visit_expr(seq, sc, v);\n     let root = expr_root(cx, seq, false);\n     let root_def =\n-        alt path_def_id(cx, root.ex) { some(did) { ~[did.node] } _ { ~[] } };\n-    let unsafe = alt inner_mut(root.ds) { some(t) { ~[t] } _ { ~[] } };\n+        alt path_def_id(cx, root.ex) { some(did) { [did.node] } _ { [] } };\n+    let unsafe = alt inner_mut(root.ds) { some(t) { [t] } _ { [] } };\n \n     // If this is a mutable vector, don't allow it to be touched.\n     let seq_t = ty::expr_ty(cx.tcx, seq);\n     alt ty::struct(cx.tcx, seq_t) {\n-      ty::ty_vec(mt) {\n-        if mt.mut != ast::imm { unsafe = ~[seq_t]; }\n-      }\n+      ty::ty_vec(mt) { if mt.mut != ast::imm { unsafe = [seq_t]; } }\n       ty::ty_str. | ty::ty_istr. {/* no-op */ }\n       _ {\n         cx.tcx.sess.span_unimpl(seq.span,\n@@ -375,13 +389,14 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n       }\n     }\n     let bindings = ast::pat_binding_ids(local.node.pat);\n-    let new_sc = @{root_vars: root_def,\n-                   block_defnum: bindings.(vec::len(bindings) - 1u),\n-                   bindings: bindings,\n-                   tys: unsafe,\n-                   depends_on: deps(sc, root_def),\n-                   mutable ok: valid};\n-    visit::visit_block(blk, @(*sc + ~[new_sc]), v);\n+    let new_sc =\n+        @{root_vars: root_def,\n+          block_defnum: bindings[vec::len(bindings) - 1u],\n+          bindings: bindings,\n+          tys: unsafe,\n+          depends_on: deps(sc, root_def),\n+          mutable ok: valid};\n+    visit::visit_block(blk, @(*sc + [new_sc]), v);\n }\n \n fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n@@ -391,6 +406,7 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n     let my_defnum = ast::def_id_of_def(def).node;\n     let var_t = ty::expr_ty(cx.tcx, ex);\n     for r: restrict in *sc {\n+\n         // excludes variables introduced since the alias was made\n         // FIXME This does not work anymore, now that we have macros.\n         if my_defnum < r.block_defnum {\n@@ -399,7 +415,7 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n                     r.ok = val_taken(ex.span, p);\n                 }\n             }\n-        } else if (vec::member(my_defnum, r.bindings)) {\n+        } else if vec::member(my_defnum, r.bindings) {\n             test_scope(cx, sc, r, p);\n         }\n     }\n@@ -411,7 +427,7 @@ fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n         let dnum = ast::def_id_of_def(cx.tcx.def_map.get(dest.id)).node;\n         if is_immutable_alias(*cx, sc, dnum) {\n             cx.tcx.sess.span_err(dest.span, \"assigning to immutable alias\");\n-        } else if (is_immutable_objfield(*cx, dnum)) {\n+        } else if is_immutable_objfield(*cx, dnum) {\n             cx.tcx.sess.span_err(dest.span,\n                                  \"assigning to immutable obj field\");\n         }\n@@ -425,9 +441,9 @@ fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n         let root = expr_root(*cx, dest, false);\n         if vec::len(*root.ds) == 0u {\n             cx.tcx.sess.span_err(dest.span, \"assignment to non-lvalue\");\n-        } else if (!root.ds.(0).mut) {\n+        } else if !root.ds[0].mut {\n             let name =\n-                alt root.ds.(0).kind {\n+                alt root.ds[0].kind {\n                   unbox. { \"box\" }\n                   field. { \"field\" }\n                   index. { \"vec content\" }\n@@ -475,9 +491,7 @@ fn is_immutable_alias(cx: &ctx, sc: &scope, dnum: node_id) -> bool {\n       some(arg(ast::alias(false))) { ret true; }\n       _ { }\n     }\n-    for r: restrict in *sc {\n-        if vec::member(dnum, r.bindings) { ret true; }\n-    }\n+    for r: restrict in *sc { if vec::member(dnum, r.bindings) { ret true; } }\n     ret false;\n }\n \n@@ -489,17 +503,18 @@ fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n     let prob = r.ok;\n     for dep: uint in r.depends_on {\n         if prob != valid { break; }\n-        prob = sc.(dep).ok;\n+        prob = sc[dep].ok;\n     }\n     if prob != valid {\n-        let msg = alt prob {\n-          overwritten(sp, wpt) {\n-            {span: sp, msg: \"overwriting \" + ast::path_name(wpt)}\n-          }\n-          val_taken(sp, vpt) {\n-            {span: sp, msg: \"taking the value of \" + ast::path_name(vpt)}\n-          }\n-        };\n+        let msg =\n+            alt prob {\n+              overwritten(sp, wpt) {\n+                {span: sp, msg: \"overwriting \" + ast::path_name(wpt)}\n+              }\n+              val_taken(sp, vpt) {\n+                {span: sp, msg: \"taking the value of \" + ast::path_name(vpt)}\n+              }\n+            };\n         cx.tcx.sess.span_err(msg.span,\n                              msg.msg + \" will invalidate alias \" +\n                                  ast::path_name(p) + \", which is still used\");\n@@ -508,10 +523,10 @@ fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n \n fn deps(sc: &scope, roots: &[node_id]) -> [uint] {\n     let i = 0u;\n-    let result = ~[];\n+    let result = [];\n     for r: restrict in *sc {\n         for dn: node_id in roots {\n-            if vec::member(dn, r.bindings) { result += ~[i]; }\n+            if vec::member(dn, r.bindings) { result += [i]; }\n         }\n         i += 1u;\n     }\n@@ -530,37 +545,37 @@ type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n    {ex: @ast::expr, ds: @[deref]} {\n     fn maybe_auto_unbox(cx: &ctx, t: ty::t) -> {t: ty::t, ds: [deref]} {\n-        let ds = ~[];\n+        let ds = [];\n         while true {\n             alt ty::struct(cx.tcx, t) {\n               ty::ty_box(mt) {\n-                ds += ~[@{mut: mt.mut != ast::imm, kind: unbox, outer_t: t}];\n+                ds += [@{mut: mt.mut != ast::imm, kind: unbox, outer_t: t}];\n                 t = mt.ty;\n               }\n               ty::ty_uniq(mt) {\n-                ds += ~[@{mut: false, kind: unbox, outer_t: t}];\n+                ds += [@{mut: false, kind: unbox, outer_t: t}];\n               }\n               ty::ty_res(_, inner, tps) {\n-                ds += ~[@{mut: false, kind: unbox, outer_t: t}];\n+                ds += [@{mut: false, kind: unbox, outer_t: t}];\n                 t = ty::substitute_type_params(cx.tcx, tps, inner);\n               }\n               ty::ty_tag(did, tps) {\n                 let variants = ty::tag_variants(cx.tcx, did);\n                 if vec::len(variants) != 1u ||\n-                       vec::len(variants.(0).args) != 1u {\n+                       vec::len(variants[0].args) != 1u {\n                     break;\n                 }\n-                ds += ~[@{mut: false, kind: unbox, outer_t: t}];\n+                ds += [@{mut: false, kind: unbox, outer_t: t}];\n                 t =\n                     ty::substitute_type_params(cx.tcx, tps,\n-                                               variants.(0).args.(0));\n+                                               variants[0].args[0]);\n               }\n               _ { break; }\n             }\n         }\n         ret {t: t, ds: ds};\n     }\n-    let ds: [deref] = ~[];\n+    let ds: [deref] = [];\n     while true {\n         alt { ex.node } {\n           ast::expr_field(base, ident) {\n@@ -577,7 +592,7 @@ fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n               }\n               ty::ty_obj(_) { }\n             }\n-            ds += ~[@{mut: mut, kind: field, outer_t: auto_unbox.t}];\n+            ds += [@{mut: mut, kind: field, outer_t: auto_unbox.t}];\n             ds += auto_unbox.ds;\n             ex = base;\n           }\n@@ -586,9 +601,9 @@ fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n             alt ty::struct(cx.tcx, auto_unbox.t) {\n               ty::ty_vec(mt) {\n                 ds +=\n-                    ~[@{mut: mt.mut != ast::imm,\n-                        kind: index,\n-                        outer_t: auto_unbox.t}];\n+                    [@{mut: mt.mut != ast::imm,\n+                       kind: index,\n+                       outer_t: auto_unbox.t}];\n               }\n             }\n             ds += auto_unbox.ds;\n@@ -605,7 +620,7 @@ fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n                   ty::ty_tag(_, _) { }\n                   ty::ty_ptr(mt) { mut = mt.mut != ast::imm; }\n                 }\n-                ds += ~[@{mut: mut, kind: unbox, outer_t: base_t}];\n+                ds += [@{mut: mut, kind: unbox, outer_t: base_t}];\n                 ex = base;\n             } else { break; }\n           }\n@@ -631,9 +646,9 @@ fn inner_mut(ds: &@[deref]) -> option::t<ty::t> {\n \n fn path_def(cx: &ctx, ex: &@ast::expr) -> option::t<ast::def> {\n     ret alt ex.node {\n-      ast::expr_path(_) { some(cx.tcx.def_map.get(ex.id)) }\n-      _ { none }\n-    }\n+          ast::expr_path(_) { some(cx.tcx.def_map.get(ex.id)) }\n+          _ { none }\n+        }\n }\n \n fn path_def_id(cx: &ctx, ex: &@ast::expr) -> option::t<ast::def_id> {\n@@ -673,25 +688,23 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n             ret false;\n           }\n           ty::ty_tup(ts) {\n-            for t in ts {\n-                if helper(tcx, needle, t, mut) {\n-                    ret true;\n-                }\n-            }\n+            for t in ts { if helper(tcx, needle, t, mut) { ret true; } }\n             ret false;\n           }\n \n+\n           // These may contain anything.\n           ty::ty_fn(_, _, _, _, _) {\n             ret true;\n           }\n           ty::ty_obj(_) { ret true; }\n \n+\n           // A type param may include everything, but can only be\n           // treated as opaque downstream, and is thus safe unless we\n           // saw mutable fields, in which case the whole thing can be\n           // overwritten.\n-          ty::ty_param(_,_) {\n+          ty::ty_param(_, _) {\n             ret mut;\n           }\n           _ { ret false; }"}, {"sha": "afba7e20cedac7b292890cbf7c3667217a5771f0", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -60,14 +60,14 @@ fn new_smallintmap_int_adapter<@V>() -> std::map::hashmap<int, V> {\n // interface.\n // FIXME: hashmap and smallintmap should support the same interface.\n fn new_smallintmap_adapter<@K,\n-                           @V>(key_idx: fn(&K) -> uint ,\n-                               idx_key: fn(&uint) -> K ) ->\n+                           @V>(key_idx: fn(&K) -> uint,\n+                               idx_key: fn(&uint) -> K) ->\n    std::map::hashmap<K, V> {\n \n     obj adapter<@K,\n                 @V>(map: smallintmap::smallintmap<V>,\n-                    key_idx: fn(&K) -> uint ,\n-                    idx_key: fn(&uint) -> K ) {\n+                    key_idx: fn(&K) -> uint,\n+                    idx_key: fn(&uint) -> K) {\n \n         fn size() -> uint { fail }\n \n@@ -128,45 +128,44 @@ mod test {\n     #[test]\n     fn test_node_span_item() {\n         let expected: codemap::span = mk_sp(20u, 30u);\n-        let node = node_item(@{ident: \"test\",\n-                               attrs: ~[],\n-                               id: 0,\n-                               node: item_mod({view_items: ~[],\n-                                               items: ~[]}),\n-                               span: expected});\n-        assert node_span(node) == expected;\n+        let node =\n+            node_item(@{ident: \"test\",\n+                        attrs: [],\n+                        id: 0,\n+                        node: item_mod({view_items: [], items: []}),\n+                        span: expected});\n+        assert (node_span(node) == expected);\n     }\n \n     #[test]\n     fn test_node_span_obj_ctor() {\n         let expected: codemap::span = mk_sp(20u, 30u);\n-        let node = node_obj_ctor(@{ident: \"test\",\n-                                   attrs: ~[],\n-                                   id: 0,\n-                                   node: item_mod({view_items: ~[],\n-                                                   items: ~[]}),\n-                                   span: expected});\n-        assert node_span(node) == expected;\n+        let node =\n+            node_obj_ctor(@{ident: \"test\",\n+                            attrs: [],\n+                            id: 0,\n+                            node: item_mod({view_items: [], items: []}),\n+                            span: expected});\n+        assert (node_span(node) == expected);\n     }\n \n     #[test]\n     fn test_node_span_native_item() {\n         let expected: codemap::span = mk_sp(20u, 30u);\n-        let node = node_native_item(@{ident: \"test\",\n-                                      attrs: ~[],\n-                                      node: native_item_ty,\n-                                      id: 0,\n-                                      span: expected});\n-        assert node_span(node) == expected;\n+        let node =\n+            node_native_item(@{ident: \"test\",\n+                               attrs: [],\n+                               node: native_item_ty,\n+                               id: 0,\n+                               span: expected});\n+        assert (node_span(node) == expected);\n     }\n \n     #[test]\n     fn test_node_span_expr() {\n         let expected: codemap::span = mk_sp(20u, 30u);\n-        let node = node_expr(@{id: 0,\n-                               node: expr_break,\n-                               span: expected});\n-        assert node_span(node) == expected;\n+        let node = node_expr(@{id: 0, node: expr_break, span: expected});\n+        assert (node_span(node) == expected);\n     }\n }\n "}, {"sha": "7c2f76c0590b6eaf50a3baf676aabd25ecb42cc2", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -5,7 +5,7 @@ fn check_crate(tcx: &ty::ctxt, crate: &@crate) {\n     let v =\n         @{visit_expr: bind check_expr(tcx, _, _, _),\n           visit_local: bind check_local(tcx, _, _, _)\n-          with *visit::default_visitor::<()>()};\n+             with *visit::default_visitor::<()>()};\n     visit::visit_crate(*crate, (), visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n }\n@@ -22,7 +22,7 @@ fn check_arms(tcx: &ty::ctxt, arms: &[arm]) {\n             let reachable = true;\n             let j = 0;\n             while j < i {\n-                for prev_pat: @pat in arms.(j).pats {\n+                for prev_pat: @pat in arms[j].pats {\n                     if pattern_supersedes(tcx, prev_pat, arm_pat) {\n                         reachable = false;\n                     }\n@@ -38,11 +38,10 @@ fn check_arms(tcx: &ty::ctxt, arms: &[arm]) {\n }\n \n fn pattern_supersedes(tcx: &ty::ctxt, a: &@pat, b: &@pat) -> bool {\n-    fn patterns_supersede(tcx: &ty::ctxt, as: &[@pat], bs: &[@pat]) ->\n-       bool {\n+    fn patterns_supersede(tcx: &ty::ctxt, as: &[@pat], bs: &[@pat]) -> bool {\n         let i = 0;\n         for a: @pat in as {\n-            if !pattern_supersedes(tcx, a, bs.(i)) { ret false; }\n+            if !pattern_supersedes(tcx, a, bs[i]) { ret false; }\n             i += 1;\n         }\n         ret true;\n@@ -119,19 +118,13 @@ fn is_refutable(tcx: &ty::ctxt, pat: &@pat) -> bool {\n         ret false;\n       }\n       pat_tup(elts) {\n-        for elt in elts {\n-            if is_refutable(tcx, elt) { ret true; }\n-        }\n+        for elt in elts { if is_refutable(tcx, elt) { ret true; } }\n         ret false;\n       }\n       pat_tag(_, args) {\n         let vdef = variant_def_ids(tcx.def_map.get(pat.id));\n-        if std::vec::len(ty::tag_variants(tcx, vdef.tg)) != 1u {\n-            ret true;\n-        }\n-        for p: @pat in args {\n-            if is_refutable(tcx, p) { ret true; }\n-        }\n+        if std::vec::len(ty::tag_variants(tcx, vdef.tg)) != 1u { ret true; }\n+        for p: @pat in args { if is_refutable(tcx, p) { ret true; } }\n         ret false;\n       }\n     }"}, {"sha": "8bef22f8ad8c99524cb3cb49c8a6e98e640464bd", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 66, "deletions": 61, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -38,59 +38,62 @@ type freevar_map = hashmap<ast::node_id, freevar_info>;\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n-                    walker: &fn(&visit::vt<()>) ,\n+                    walker: &fn(&visit::vt<()>),\n                     initial_decls: [ast::node_id]) -> freevar_info {\n     let decls = new_int_hash();\n     for decl: ast::node_id in initial_decls { set_add(decls, decl); }\n-    let refs = @mutable ~[];\n+    let refs = @mutable [];\n \n-    let walk_fn = lambda(f: &ast::_fn, _tps: &[ast::ty_param], _sp: &span,\n-                         _i: &ast::fn_ident, _nid: ast::node_id) {\n-        for a: ast::arg in f.decl.inputs { set_add(decls, a.id); }\n-    };\n-    let walk_expr = lambda(expr: &@ast::expr) {\n-        alt expr.node {\n-          ast::expr_path(path) {\n-            if !def_map.contains_key(expr.id) {\n-                sess.span_fatal(expr.span,\n-                                \"internal error in collect_freevars\");\n+    let walk_fn =\n+        lambda (f: &ast::_fn, _tps: &[ast::ty_param], _sp: &span,\n+                _i: &ast::fn_ident, _nid: ast::node_id) {\n+            for a: ast::arg in f.decl.inputs { set_add(decls, a.id); }\n+        };\n+    let walk_expr =\n+        lambda (expr: &@ast::expr) {\n+            alt expr.node {\n+              ast::expr_path(path) {\n+                if !def_map.contains_key(expr.id) {\n+                    sess.span_fatal(expr.span,\n+                                    \"internal error in collect_freevars\");\n+                }\n+                alt def_map.get(expr.id) {\n+                  ast::def_arg(did) { *refs += [expr.id]; }\n+                  ast::def_local(did) { *refs += [expr.id]; }\n+                  ast::def_binding(did) { *refs += [expr.id]; }\n+                  _ {/* no-op */ }\n+                }\n+              }\n+              _ { }\n             }\n-            alt def_map.get(expr.id) {\n-              ast::def_arg(did) { *refs += ~[expr.id]; }\n-              ast::def_local(did) { *refs += ~[expr.id]; }\n-              ast::def_binding(did) { *refs += ~[expr.id]; }\n-              _ {/* no-op */ }\n+        };\n+    let walk_local =\n+        lambda (local: &@ast::local) {\n+            for each b: @ast::pat in ast::pat_bindings(local.node.pat) {\n+                set_add(decls, b.id);\n             }\n-          }\n-          _ { }\n-        }\n-    };\n-    let walk_local = lambda(local: &@ast::local) {\n-        for each b: @ast::pat in ast::pat_bindings(local.node.pat) {\n-            set_add(decls, b.id);\n-        }\n-    };\n-    let walk_pat = lambda(p: &@ast::pat) {\n-        alt p.node { ast::pat_bind(_) { set_add(decls, p.id); } _ { } }\n-    };\n-\n-    walker(visit::mk_simple_visitor\n-           (@{visit_local: walk_local,\n-              visit_pat: walk_pat,\n-              visit_expr: walk_expr,\n-              visit_fn: walk_fn\n-              with *visit::default_simple_visitor()}));\n+        };\n+    let walk_pat =\n+        lambda (p: &@ast::pat) {\n+            alt p.node { ast::pat_bind(_) { set_add(decls, p.id); } _ { } }\n+        };\n \n+    walker(visit::mk_simple_visitor(@{visit_local: walk_local,\n+                                      visit_pat: walk_pat,\n+                                      visit_expr: walk_expr,\n+                                      visit_fn: walk_fn\n+                                         with\n+                                         *visit::default_simple_visitor()}));\n     // Calculate (refs - decls). This is the set of captured upvars.\n     // We build a vec of the node ids of the uses and a set of the\n     // node ids of the definitions.\n-    let canonical_refs = ~[];\n+    let canonical_refs = [];\n     let defs = new_int_hash();\n     for ref_id_: ast::node_id in *refs {\n         let ref_id = ref_id_;\n         let def_id = ast::def_id_of_def(def_map.get(ref_id)).node;\n         if !decls.contains_key(def_id) && !defs.contains_key(def_id) {\n-            canonical_refs += ~[ref_id];\n+            canonical_refs += [ref_id];\n             set_add(defs, def_id);\n         }\n     }\n@@ -106,32 +109,34 @@ fn annotate_freevars(sess: &session::session, def_map: &resolve::def_map,\n                      crate: &@ast::crate) -> freevar_map {\n     let freevars = new_int_hash();\n \n-    let walk_fn = lambda(f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n-                         i: &ast::fn_ident, nid: ast::node_id) {\n-        let start_walk = lambda(v: &visit::vt<()>) {\n-            v.visit_fn(f, tps, sp, i, nid, (), v);\n+    let walk_fn =\n+        lambda (f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n+                i: &ast::fn_ident, nid: ast::node_id) {\n+            let start_walk =\n+                lambda (v: &visit::vt<()>) {\n+                    v.visit_fn(f, tps, sp, i, nid, (), v);\n+                };\n+            let vars = collect_freevars(def_map, sess, start_walk, []);\n+            freevars.insert(nid, vars);\n+        };\n+    let walk_expr =\n+        lambda (expr: &@ast::expr) {\n+            alt expr.node {\n+              ast::expr_for_each(local, _, body) {\n+                let start_walk =\n+                    lambda (v: &visit::vt<()>) {\n+                        v.visit_block(body, (), v);\n+                    };\n+                let bound = ast::pat_binding_ids(local.node.pat);\n+                let vars = collect_freevars(def_map, sess, start_walk, bound);\n+                freevars.insert(body.node.id, vars);\n+              }\n+              _ { }\n+            }\n         };\n-        let vars = collect_freevars(def_map, sess, start_walk, ~[]);\n-        freevars.insert(nid, vars);\n-    };\n-    let walk_expr = lambda(expr: &@ast::expr) {\n-        alt expr.node {\n-          ast::expr_for_each(local, _, body) {\n-            let start_walk = lambda(v: &visit::vt<()>) {\n-                v.visit_block(body, (), v);\n-            };\n-            let bound = ast::pat_binding_ids(local.node.pat);\n-            let vars =\n-                collect_freevars(def_map, sess, start_walk, bound);\n-            freevars.insert(body.node.id, vars);\n-          }\n-          _ { }\n-        }\n-    };\n \n     let visitor =\n-        visit::mk_simple_visitor(@{visit_fn: walk_fn,\n-                                   visit_expr: walk_expr\n+        visit::mk_simple_visitor(@{visit_fn: walk_fn, visit_expr: walk_expr\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visitor);\n "}, {"sha": "103ce9eb47dd348c75ada0b5e0260dce3cfb17e8", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 84, "deletions": 82, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -16,15 +16,13 @@ import std::vec;\n \n import lll = lib::llvm::llvm;\n \n-type ctxt = @{ mutable next_tydesc_num: uint };\n+type ctxt = @{mutable next_tydesc_num: uint};\n \n-fn mk_ctxt() -> ctxt {\n-    ret @{ mutable next_tydesc_num: 0u };\n-}\n+fn mk_ctxt() -> ctxt { ret @{mutable next_tydesc_num: 0u}; }\n \n fn add_global(ccx: &@crate_ctxt, llval: ValueRef, name: str) -> ValueRef {\n-    let llglobal = lll::LLVMAddGlobal(ccx.llmod, val_ty(llval),\n-                                      str::buf(name));\n+    let llglobal =\n+        lll::LLVMAddGlobal(ccx.llmod, val_ty(llval), str::buf(name));\n     lll::LLVMSetInitializer(llglobal, llval);\n     lll::LLVMSetGlobalConstant(llglobal, True);\n     ret llglobal;\n@@ -33,7 +31,7 @@ fn add_global(ccx: &@crate_ctxt, llval: ValueRef, name: str) -> ValueRef {\n fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     let bcx = cx;\n     if !type_is_gc_relevant(bcx_tcx(cx), ty) ||\n-            ty::type_has_dynamic_size(bcx_tcx(cx), ty) {\n+           ty::type_has_dynamic_size(bcx_tcx(cx), ty) {\n         ret bcx;\n     }\n \n@@ -52,94 +50,98 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     let llvalptr = bcx.build.PointerCast(llval, T_ptr(T_ptr(T_i8())));\n \n     alt td_r.kind {\n-        tk_derived. {\n-            // It's a derived type descriptor. First, spill it.\n-            let lltydescptr = trans::alloca(bcx, val_ty(lltydesc));\n-            bcx.build.Store(lltydesc, lltydescptr);\n-\n-            let number = gc_cx.next_tydesc_num;\n-            gc_cx.next_tydesc_num += 1u;\n-\n-            let lldestindex = add_global(bcx_ccx(bcx),\n-                                         C_struct(~[C_int(0),\n-                                                    C_uint(number)]),\n-                                         \"rust_gc_tydesc_dest_index\");\n-            let llsrcindex = add_global(bcx_ccx(bcx),\n-                                        C_struct(~[C_int(1), C_uint(number)]),\n-                                        \"rust_gc_tydesc_src_index\");\n-\n-            lldestindex = lll::LLVMConstPointerCast(lldestindex,\n-                                                    T_ptr(T_i8()));\n-            llsrcindex = lll::LLVMConstPointerCast(llsrcindex,\n-                                                   T_ptr(T_i8()));\n-\n-            lltydescptr = bcx.build.PointerCast(lltydescptr,\n-                                                T_ptr(T_ptr(T_i8())));\n-\n-            bcx.build.Call(gcroot, ~[ lltydescptr, lldestindex ]);\n-            bcx.build.Call(gcroot, ~[ llvalptr, llsrcindex ]);\n-        }\n-        tk_param. {\n-            bcx_tcx(cx).sess.bug(\"we should never be trying to root values \" +\n-                \"of a type parameter\");\n-        }\n-        tk_static. {\n-            // Static type descriptor.\n-\n-            let llstaticgcmeta = add_global(bcx_ccx(bcx),\n-                                            C_struct(~[C_int(2), lltydesc]),\n-                                            \"rust_gc_tydesc_static_gc_meta\");\n-            let llstaticgcmetaptr = lll::LLVMConstPointerCast(llstaticgcmeta,\n-                                                              T_ptr(T_i8()));\n-\n-            bcx.build.Call(gcroot, ~[ llvalptr, llstaticgcmetaptr ]);\n-        }\n+      tk_derived. {\n+        // It's a derived type descriptor. First, spill it.\n+        let lltydescptr = trans::alloca(bcx, val_ty(lltydesc));\n+        bcx.build.Store(lltydesc, lltydescptr);\n+\n+        let number = gc_cx.next_tydesc_num;\n+        gc_cx.next_tydesc_num += 1u;\n+\n+        let lldestindex =\n+            add_global(bcx_ccx(bcx), C_struct([C_int(0), C_uint(number)]),\n+                       \"rust_gc_tydesc_dest_index\");\n+        let llsrcindex =\n+            add_global(bcx_ccx(bcx), C_struct([C_int(1), C_uint(number)]),\n+                       \"rust_gc_tydesc_src_index\");\n+\n+        lldestindex = lll::LLVMConstPointerCast(lldestindex, T_ptr(T_i8()));\n+        llsrcindex = lll::LLVMConstPointerCast(llsrcindex, T_ptr(T_i8()));\n+\n+        lltydescptr =\n+            bcx.build.PointerCast(lltydescptr, T_ptr(T_ptr(T_i8())));\n+\n+        bcx.build.Call(gcroot, [lltydescptr, lldestindex]);\n+        bcx.build.Call(gcroot, [llvalptr, llsrcindex]);\n+      }\n+      tk_param. {\n+        bcx_tcx(cx).sess.bug(\"we should never be trying to root values \" +\n+                                 \"of a type parameter\");\n+      }\n+      tk_static. {\n+        // Static type descriptor.\n+\n+        let llstaticgcmeta =\n+            add_global(bcx_ccx(bcx), C_struct([C_int(2), lltydesc]),\n+                       \"rust_gc_tydesc_static_gc_meta\");\n+        let llstaticgcmetaptr =\n+            lll::LLVMConstPointerCast(llstaticgcmeta, T_ptr(T_i8()));\n+\n+        bcx.build.Call(gcroot, [llvalptr, llstaticgcmetaptr]);\n+      }\n     }\n \n     ret bcx;\n }\n \n fn type_is_gc_relevant(cx: &ty::ctxt, ty: &ty::t) -> bool {\n     alt ty::struct(cx, ty) {\n-        ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int. |\n-        ty::ty_float. | ty::ty_uint. | ty::ty_machine(_) | ty::ty_char. |\n-        ty::ty_istr. | ty::ty_type. | ty::ty_native(_) | ty::ty_ptr(_) |\n-        ty::ty_type. | ty::ty_native(_) {\n-            ret false;\n-        }\n-\n-        ty::ty_rec(fields) {\n-            for f in fields {\n-                if type_is_gc_relevant(cx, f.mt.ty) { ret true; }\n-            }\n-            ret false;\n-        }\n-        ty::ty_tup(elts) {\n-            for elt in elts {\n-                if type_is_gc_relevant(cx, elt) { ret true; }\n+      ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int. | ty::ty_float. |\n+      ty::ty_uint. | ty::ty_machine(_) | ty::ty_char. | ty::ty_istr. |\n+      ty::ty_type. | ty::ty_native(_) | ty::ty_ptr(_) | ty::ty_type. |\n+      ty::ty_native(_) {\n+        ret false;\n+      }\n+\n+\n+      ty::ty_rec(fields) {\n+        for f in fields { if type_is_gc_relevant(cx, f.mt.ty) { ret true; } }\n+        ret false;\n+      }\n+      ty::ty_tup(elts) {\n+        for elt in elts { if type_is_gc_relevant(cx, elt) { ret true; } }\n+        ret false;\n+      }\n+\n+\n+      ty::ty_tag(did, tps) {\n+        let variants = ty::tag_variants(cx, did);\n+        for variant in variants {\n+            for aty in variant.args {\n+                let arg_ty = ty::substitute_type_params(cx, tps, aty);\n+                if type_is_gc_relevant(cx, arg_ty) { ret true; }\n             }\n-            ret false;\n         }\n+        ret false;\n+      }\n+\n+\n+      ty::ty_vec(tm) {\n+        ret type_is_gc_relevant(cx, tm.ty);\n+      }\n+      ty::ty_constr(sub, _) { ret type_is_gc_relevant(cx, sub); }\n \n-        ty::ty_tag(did, tps) {\n-            let variants = ty::tag_variants(cx, did);\n-            for variant in variants {\n-                for aty in variant.args {\n-                    let arg_ty = ty::substitute_type_params(cx, tps, aty);\n-                    if type_is_gc_relevant(cx, arg_ty) { ret true; }\n-                }\n-            }\n-            ret false;\n-        }\n \n-        ty::ty_vec(tm) { ret type_is_gc_relevant(cx, tm.ty); }\n-        ty::ty_constr(sub, _) { ret type_is_gc_relevant(cx, sub); }\n+      ty::ty_str. | ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_fn(_, _, _, _, _)\n+      | ty::ty_native_fn(_, _, _) | ty::ty_obj(_) | ty::ty_param(_, _) |\n+      ty::ty_res(_, _, _) {\n+        ret true;\n+      }\n \n-        ty::ty_str. | ty::ty_box(_) | ty::ty_uniq(_) |\n-        ty::ty_fn(_,_,_,_,_) | ty::ty_native_fn(_,_,_) | ty::ty_obj(_) |\n-        ty::ty_param(_,_) | ty::ty_res(_,_,_) { ret true; }\n \n-        ty::ty_var(_) { fail \"ty_var in type_is_gc_relevant\"; }\n+      ty::ty_var(_) {\n+        fail \"ty_var in type_is_gc_relevant\";\n+      }\n     }\n }\n "}, {"sha": "f5e833a86d2f9341c340478cb2d1befb28598375", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -101,35 +101,30 @@ fn kind_to_str(k: kind) -> str {\n     }\n }\n \n-fn type_and_kind(tcx: &ty::ctxt, e: &@ast::expr)\n-    -> {ty: ty::t, kind: ast::kind} {\n+fn type_and_kind(tcx: &ty::ctxt, e: &@ast::expr) ->\n+   {ty: ty::t, kind: ast::kind} {\n     let t = ty::expr_ty(tcx, e);\n     let k = ty::type_kind(tcx, t);\n     {ty: t, kind: k}\n }\n \n-fn need_expr_kind(tcx: &ty::ctxt, e: &@ast::expr,\n-                  k_need: ast::kind, descr: &str) {\n+fn need_expr_kind(tcx: &ty::ctxt, e: &@ast::expr, k_need: ast::kind,\n+                  descr: &str) {\n     let tk = type_and_kind(tcx, e);\n-    log #fmt(\"for %s: want %s type, got %s type %s\",\n-             descr,\n-             kind_to_str(k_need),\n-             kind_to_str(tk.kind),\n-             util::ppaux::ty_to_str(tcx, tk.ty));\n+    log #fmt[\"for %s: want %s type, got %s type %s\", descr,\n+             kind_to_str(k_need), kind_to_str(tk.kind),\n+             util::ppaux::ty_to_str(tcx, tk.ty)];\n \n-    if ! kind_lteq(k_need, tk.kind) {\n+    if !kind_lteq(k_need, tk.kind) {\n         let s =\n-            #fmt(\"mismatched kinds for %s: needed %s type, got %s type %s\",\n-                 descr,\n-                 kind_to_str(k_need),\n-                 kind_to_str(tk.kind),\n-                 util::ppaux::ty_to_str(tcx, tk.ty));\n+            #fmt[\"mismatched kinds for %s: needed %s type, got %s type %s\",\n+                 descr, kind_to_str(k_need), kind_to_str(tk.kind),\n+                 util::ppaux::ty_to_str(tcx, tk.ty)];\n         tcx.sess.span_err(e.span, s);\n     }\n }\n \n-fn need_shared_lhs_rhs(tcx: &ty::ctxt,\n-                       a: &@ast::expr, b: &@ast::expr,\n+fn need_shared_lhs_rhs(tcx: &ty::ctxt, a: &@ast::expr, b: &@ast::expr,\n                        op: &str) {\n     need_expr_kind(tcx, a, ast::kind_shared, op + \" lhs\");\n     need_expr_kind(tcx, b, ast::kind_shared, op + \" rhs\");\n@@ -142,24 +137,24 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n       ast::expr_swap(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<->\"); }\n       ast::expr_call(callee, _) {\n         let tpt = ty::expr_ty_params_and_ty(tcx, callee);\n+\n         // If we have typarams, we're calling an item; we need to check\n         // that all the types we're supplying as typarams conform to the\n         // typaram kind constraints on that item.\n         if vec::len(tpt.params) != 0u {\n             let callee_def = ast::def_id_of_def(tcx.def_map.get(callee.id));\n             let item_tk = ty::lookup_item_type(tcx, callee_def);\n             let i = 0;\n-            assert vec::len(item_tk.kinds) == vec::len(tpt.params);\n+            assert (vec::len(item_tk.kinds) == vec::len(tpt.params));\n             for k_need: ast::kind in item_tk.kinds {\n-                let t = tpt.params.(i);\n+                let t = tpt.params[i];\n                 let k = ty::type_kind(tcx, t);\n-                if ! kind_lteq(k_need, k) {\n-                    let s = #fmt(\"mismatched kinds for typaram %d: \\\n+                if !kind_lteq(k_need, k) {\n+                    let s =\n+                        #fmt[\"mismatched kinds for typaram %d: \\\n                                   needed %s type, got %s type %s\",\n-                                 i,\n-                                 kind_to_str(k_need),\n-                                 kind_to_str(k),\n-                                 util::ppaux::ty_to_str(tcx, t));\n+                             i, kind_to_str(k_need), kind_to_str(k),\n+                             util::ppaux::ty_to_str(tcx, t)];\n                     tcx.sess.span_err(e.span, s);\n                 }\n                 i += 1;\n@@ -171,9 +166,9 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n }\n \n fn check_crate(tcx: &ty::ctxt, crate: &@ast::crate) {\n-    let visit = visit::mk_simple_visitor\n-        (@{visit_expr: bind check_expr(tcx, _)\n-           with *visit::default_simple_visitor()});\n+    let visit =\n+        visit::mk_simple_visitor(@{visit_expr: bind check_expr(tcx, _)\n+                                      with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visit);\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "0785be758230d414a483d69a0f98a2734ccee466", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 88, "deletions": 96, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -65,9 +65,11 @@ tag import_state {\n     todo(ast::node_id, ast::ident, [ast::ident], codemap::span, scopes);\n     resolving(span);\n     resolved(option::t<def>,\n-              /* value */\n+\n+             /* value */\n              option::t<def>,\n-              /* type */\n+\n+             /* type */\n              option::t<def>); /* module */\n }\n \n@@ -135,7 +137,7 @@ tag dir { inside; outside; }\n tag namespace { ns_value; ns_type; ns_module; }\n \n fn resolve_crate(sess: session, amap: &ast_map::map, crate: @ast::crate) ->\n-    {def_map: def_map, ext_map: ext_map} {\n+   {def_map: def_map, ext_map: ext_map} {\n     let e =\n         @{cstore: sess.get_cstore(),\n           def_map: new_int_hash::<def>(),\n@@ -144,7 +146,7 @@ fn resolve_crate(sess: session, amap: &ast_map::map, crate: @ast::crate) ->\n           mod_map: new_int_hash::<@indexed_mod>(),\n           ext_map: new_def_hash::<[ident]>(),\n           ext_cache: new_ext_hash(),\n-          mutable reported: ~[],\n+          mutable reported: [],\n           sess: sess};\n     map_crate(e, crate);\n     resolve_imports(*e);\n@@ -169,7 +171,7 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n     e.mod_map.insert(-1,\n                      @{m: some(c.node.module),\n                        index: index_mod(c.node.module),\n-                       mutable glob_imports: ~[],\n+                       mutable glob_imports: [],\n                        glob_imported_names: new_str_hash::<import_state>()});\n     fn index_vi(e: @env, i: &@ast::view_item, sc: &scopes, _v: &vt<scopes>) {\n         alt i.node {\n@@ -180,8 +182,8 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n             for ident in idents {\n                 e.imports.insert(ident.node.id,\n                                  todo(ident.node.id, ident.node.name,\n-                                        mod_path + ~[ident.node.name],\n-                                        ident.span, sc));\n+                                      mod_path + [ident.node.name],\n+                                      ident.span, sc));\n             }\n           }\n           _ { }\n@@ -195,15 +197,15 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n             e.mod_map.insert(i.id,\n                              @{m: some(md),\n                                index: index_mod(md),\n-                               mutable glob_imports: ~[],\n+                               mutable glob_imports: [],\n                                glob_imported_names: s});\n           }\n           ast::item_native_mod(nmd) {\n             let s = new_str_hash::<import_state>();\n             e.mod_map.insert(i.id,\n                              @{m: none::<ast::_mod>,\n                                index: index_nmod(nmd),\n-                               mutable glob_imports: ~[],\n+                               mutable glob_imports: [],\n                                glob_imported_names: s});\n           }\n           _ { }\n@@ -237,12 +239,13 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n         }\n         alt vi.node {\n \n+\n           //if it really is a glob import, that is\n           ast::view_item_import_glob(path, _) {\n             let imp = follow_import(*e, sc, path, vi.span);\n             if option::is_some(imp) {\n                 find_mod(e, sc).glob_imports +=\n-                    ~[{def: option::get(imp), item: vi}];\n+                    [{def: option::get(imp), item: vi}];\n             }\n           }\n           _ { }\n@@ -255,8 +258,7 @@ fn resolve_imports(e: &env) {\n              {\n         alt it.val {\n           todo(node_id, name, path, span, scopes) {\n-            resolve_import(e, local_def(node_id),\n-                           name, path, span, scopes);\n+            resolve_import(e, local_def(node_id), name, path, span, scopes);\n           }\n           resolved(_, _, _) { }\n         }\n@@ -318,8 +320,8 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n                 e.def_map.insert(pat.id, option::get(fnd));\n               }\n               _ {\n-                e.sess.span_err\n-                    (p.span, \"not a tag variant: \" + ast::path_name(p));\n+                e.sess.span_err(p.span,\n+                                \"not a tag variant: \" + ast::path_name(p));\n               }\n             }\n           }\n@@ -349,7 +351,7 @@ fn visit_fn_with_scope(e: &@env, f: &ast::_fn, tp: &[ast::ty_param],\n     // is this a main fn declaration?\n     alt name {\n       some(nm) {\n-        if is_main_name(~[nm]) && !e.sess.get_opts().library {\n+        if is_main_name([nm]) && !e.sess.get_opts().library {\n             // This is a main function -- set it in the session\n             // as the main ID\n             e.sess.set_main_id(id);\n@@ -361,9 +363,7 @@ fn visit_fn_with_scope(e: &@env, f: &ast::_fn, tp: &[ast::ty_param],\n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n \n-    for c: @ast::constr in f.decl.constraints {\n-        resolve_constr(e, c, sc, v);\n-    }\n+    for c: @ast::constr in f.decl.constraints { resolve_constr(e, c, sc, v); }\n     visit::visit_fn(f, tp, sp, name, id,\n                     cons(scope_fn(f.decl, f.proto, tp), @sc), v);\n }\n@@ -372,24 +372,22 @@ fn visit_block_with_scope(b: &ast::blk, sc: &scopes, v: &vt<scopes>) {\n     let pos = @mutable 0u, loc = @mutable 0u;\n     let block_sc = cons(scope_block(b, pos, loc), @sc);\n     for stmt in b.node.stmts {\n-        v.visit_stmt(stmt, block_sc, v);\n-        *pos += 1u;\n+        v.visit_stmt(stmt, block_sc, v);;\n+        *pos += 1u;;\n         *loc = 0u;\n     }\n     visit::visit_expr_opt(b.node.expr, block_sc, v);\n }\n \n fn visit_decl_with_scope(d: &@decl, sc: &scopes, v: &vt<scopes>) {\n-    let loc_pos = alt list::car(sc) {\n-      scope_block(_, _, pos) { pos }\n-      _ { @mutable 0u }\n-    };\n+    let loc_pos =\n+        alt list::car(sc) {\n+          scope_block(_, _, pos) { pos }\n+          _ { @mutable 0u }\n+        };\n     alt d.node {\n       decl_local(locs) {\n-        for loc in locs {\n-            v.visit_local(loc, sc, v);\n-            *loc_pos += 1u;\n-        }\n+        for loc in locs { v.visit_local(loc, sc, v);; *loc_pos += 1u; }\n       }\n       decl_item(it) { v.visit_item(it, sc, v); }\n     }\n@@ -408,7 +406,7 @@ fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt<scopes>) {\n         v.visit_block(blk, new_sc, v);\n       }\n       ast::expr_fn(f) {\n-        visit::visit_expr(x, cons(scope_fn(f.decl, f.proto, ~[]), @sc), v);\n+        visit::visit_expr(x, cons(scope_fn(f.decl, f.proto, []), @sc), v);\n       }\n       _ { visit::visit_expr(x, sc, v); }\n     }\n@@ -417,12 +415,12 @@ fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt<scopes>) {\n fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n    option::t<def> {\n     let path_len = vec::len(path);\n-    let dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n+    let dcur = lookup_in_scope_strict(e, sc, sp, path[0], ns_module);\n     let i = 1u;\n     while true && option::is_some(dcur) {\n         if i == path_len { break; }\n         dcur =\n-            lookup_in_mod_strict(e, sc, option::get(dcur), sp, path.(i),\n+            lookup_in_mod_strict(e, sc, option::get(dcur), sp, path[i],\n                                  ns_module, outside);\n         i += 1u;\n     }\n@@ -461,23 +459,22 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n                   ids: &[ast::ident], sp: &codemap::span, sc_in: &scopes) {\n     e.imports.insert(defid.node, resolving(sp));\n     let n_idents = vec::len(ids);\n-    let end_id = ids.(n_idents - 1u);\n+    let end_id = ids[n_idents - 1u];\n     // Ignore the current scope if this import would shadow itself.\n     let sc =\n-        if str::eq(name, ids.(0)) { std::list::cdr(sc_in) } else { sc_in };\n+        if str::eq(name, ids[0]) { std::list::cdr(sc_in) } else { sc_in };\n     if n_idents == 1u {\n         register(e, defid, sp, end_id, sc_in,\n                  lookup_in_scope(e, sc, sp, end_id, ns_value),\n                  lookup_in_scope(e, sc, sp, end_id, ns_type),\n                  lookup_in_scope(e, sc, sp, end_id, ns_module));\n         remove_if_unresolved(e.imports, defid.node);\n-    } else {\n-        let  // FIXME (issue #521)\n-            dcur =\n-            alt lookup_in_scope(e, sc, sp, ids.(0), ns_module) {\n+    } else { // FIXME (issue #521)\n+        let dcur =\n+            alt lookup_in_scope(e, sc, sp, ids[0], ns_module) {\n               some(dcur) { dcur }\n               none. {\n-                unresolved_err(e, sc, sp, ids.(0), ns_name(ns_module));\n+                unresolved_err(e, sc, sp, ids[0], ns_name(ns_module));\n                 remove_if_unresolved(e.imports, defid.node);\n                 ret ()\n               }\n@@ -488,20 +485,18 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n                 register(e, defid, sp, end_id, sc_in,\n                          lookup_in_mod(e, dcur, sp, end_id, ns_value,\n                                        outside),\n-                         lookup_in_mod(e, dcur, sp, end_id, ns_type,\n-                                       outside),\n+                         lookup_in_mod(e, dcur, sp, end_id, ns_type, outside),\n                          lookup_in_mod(e, dcur, sp, end_id, ns_module,\n                                        outside));\n                 remove_if_unresolved(e.imports, defid.node);\n                 break;\n             } else {\n                 dcur =\n-                    alt lookup_in_mod(e, dcur, sp, ids.(i), ns_module,\n-                                      outside) {\n+                    alt lookup_in_mod(e, dcur, sp, ids[i], ns_module, outside)\n+                        {\n                       some(dcur) { dcur }\n                       none. {\n-                        unresolved_err(e, sc, sp, ids.(i),\n-                                       ns_name(ns_module));\n+                        unresolved_err(e, sc, sp, ids[i], ns_name(ns_module));\n                         remove_if_unresolved(e.imports, defid.node);\n                         ret () // FIXME (issue #521)\n                       }\n@@ -563,7 +558,7 @@ fn unresolved_err(e: &env, sc: &scopes, sp: &span, name: &ident, kind: &str) {\n     for rs: {ident: str, sc: scope} in e.reported {\n         if str::eq(rs.ident, name) && err_scope == rs.sc { ret; }\n     }\n-    e.reported += ~[{ident: name, sc: err_scope}];\n+    e.reported += [{ident: name, sc: err_scope}];\n     e.sess.span_err(sp, mk_unresolved_msg(name, kind));\n }\n \n@@ -572,7 +567,7 @@ fn unresolved_fatal(e: &env, sp: &span, id: &ident, kind: &str) -> ! {\n }\n \n fn mk_unresolved_msg(id: &ident, kind: &str) -> str {\n-    ret #fmt(\"unresolved %s: %s\", kind, id);\n+    ret #fmt[\"unresolved %s: %s\", kind, id];\n }\n \n // Lookup helpers\n@@ -587,13 +582,13 @@ fn lookup_path_strict(e: &env, sc: &scopes, sp: &span, pth: &ast::path_,\n     } else { first_scope = sc; }\n \n     let dcur =\n-        lookup_in_scope_strict(e, first_scope, sp, pth.idents.(0), headns);\n+        lookup_in_scope_strict(e, first_scope, sp, pth.idents[0], headns);\n \n     let i = 1u;\n     while i < n_idents && option::is_some(dcur) {\n         let curns = if n_idents == i + 1u { ns } else { ns_module };\n         dcur =\n-            lookup_in_mod_strict(e, sc, option::get(dcur), sp, pth.idents.(i),\n+            lookup_in_mod_strict(e, sc, option::get(dcur), sp, pth.idents[i],\n                                  curns, outside);\n         i += 1u;\n     }\n@@ -630,7 +625,7 @@ fn def_is_obj_field(d: &def) -> bool {\n }\n \n fn def_is_ty_arg(d: &def) -> bool {\n-    ret alt d { ast::def_ty_arg(_,_) { true } _ { false } };\n+    ret alt d { ast::def_ty_arg(_, _) { true } _ { false } };\n }\n \n fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n@@ -675,7 +670,7 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n             if ns == ns_value {\n                 alt lookup_in_pat(name, local.node.pat) {\n                   some(did) { ret some(ast::def_local(did)); }\n-                  _ {}\n+                  _ { }\n                 }\n             }\n           }\n@@ -685,7 +680,7 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n           scope_arm(a) {\n             if ns == ns_value {\n                 ret option::map(ast::def_binding,\n-                                lookup_in_pat(name, a.pats.(0)));\n+                                lookup_in_pat(name, a.pats[0]));\n             }\n           }\n         }\n@@ -736,7 +731,7 @@ fn lookup_in_ty_params(name: &ident, ty_params: &[ast::ty_param]) ->\n    option::t<def> {\n     let i = 0u;\n     for tp: ast::ty_param in ty_params {\n-        if str::eq(tp.ident, name) { ret some(ast::def_ty_arg(i,tp.kind)); }\n+        if str::eq(tp.ident, name) { ret some(ast::def_ty_arg(i, tp.kind)); }\n         i += 1u;\n     }\n     ret none::<def>;\n@@ -746,9 +741,7 @@ fn lookup_in_pat(name: &ident, pat: &@ast::pat) -> option::t<def_id> {\n     let found = none;\n     for each bound in ast::pat_bindings(pat) {\n         let p_name = alt bound.node { ast::pat_bind(n) { n } };\n-        if str::eq(p_name, name) {\n-            found = some(local_def(bound.id));\n-        }\n+        if str::eq(p_name, name) { found = some(local_def(bound.id)); }\n     }\n     ret found;\n }\n@@ -791,7 +784,7 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n     let i = vec::len(b.stmts);\n     while i > 0u {\n         i -= 1u;\n-        let st = b.stmts.(i);\n+        let st = b.stmts[i];\n         alt st.node {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n@@ -800,11 +793,11 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n                     let j = vec::len(locs);\n                     while j > 0u {\n                         j -= 1u;\n-                        let loc = locs.(j);\n+                        let loc = locs[j];\n                         if ns == ns_value && (i < pos || j < loc_pos) {\n                             alt lookup_in_pat(name, loc.node.pat) {\n                               some(did) { ret some(ast::def_local(did)); }\n-                              _ {}\n+                              _ { }\n                             }\n                         }\n                     }\n@@ -817,7 +810,7 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n                         if str::eq(it.ident, name) {\n                             ret some(ast::def_ty(local_def(it.id)));\n                         }\n-                    } else if (ns == ns_value) {\n+                    } else if ns == ns_value {\n                         for v: ast::variant in variants {\n                             if str::eq(v.node.name, name) {\n                                 let i = v.node.id;\n@@ -904,7 +897,7 @@ fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n \n         let cached = e.ext_cache.find({did: defid, ident: name, ns: ns});\n         if !is_none(cached) { ret cached; }\n-        let path = ~[name];\n+        let path = [name];\n         if defid.node != -1 { path = e.ext_map.get(defid) + path; }\n         let fnd = lookup_external(e, defid.crate, path, ns);\n         if !is_none(fnd) {\n@@ -923,8 +916,7 @@ fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n     }\n }\n \n-fn found_view_item(e: &env, vi: @ast::view_item) ->\n-   option::t<def> {\n+fn found_view_item(e: &env, vi: @ast::view_item) -> option::t<def> {\n     alt vi.node {\n       ast::view_item_use(_, _, id) {\n         let cnum = cstore::get_use_stmt_cnum(e.cstore, id);\n@@ -936,8 +928,7 @@ fn found_view_item(e: &env, vi: @ast::view_item) ->\n fn lookup_import(e: &env, defid: def_id, ns: namespace) -> option::t<def> {\n     alt e.imports.get(defid.node) {\n       todo(node_id, name, path, span, scopes) {\n-        resolve_import(e, local_def(node_id),\n-                       name, path, span, scopes);\n+        resolve_import(e, local_def(node_id), name, path, span, scopes);\n         ret lookup_import(e, defid, ns);\n       }\n       resolving(sp) { e.sess.span_err(sp, \"cyclic import\"); ret none; }\n@@ -998,15 +989,15 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n \n         let matches =\n             vec::filter_map(bind lookup_in_mod_(e, _, sp, id, ns, dr),\n-                             { info.glob_imports });\n+                            { info.glob_imports });\n         if vec::len(matches) == 0u {\n             ret none;\n-        } else if (vec::len(matches) == 1u) {\n-            ret some(matches.(0).def);\n+        } else if vec::len(matches) == 1u {\n+            ret some(matches[0].def);\n         } else {\n             for match: glob_imp_def in matches {\n                 let sp = match.item.span;\n-                e.sess.span_note(sp, #fmt(\"'%s' is imported here\", id));\n+                e.sess.span_note(sp, #fmt[\"'%s' is imported here\", id]);\n             }\n             e.sess.span_fatal(sp,\n                               \"'\" + id + \"' is glob-imported from\" +\n@@ -1051,7 +1042,7 @@ fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n         alt item.node {\n           ast::item_tag(variants, _) {\n             if ns == ns_value {\n-                let vid = variants.(variant_idx).node.id;\n+                let vid = variants[variant_idx].node.id;\n                 ret some(ast::def_variant(local_def(item.id),\n                                           local_def(vid)));\n             } else { ret none::<def>; }\n@@ -1090,22 +1081,24 @@ fn index_mod(md: &ast::_mod) -> mod_index {\n     let index = new_str_hash::<list<mod_index_entry>>();\n     for it: @ast::view_item in md.view_items {\n         alt it.node {\n-          ast::view_item_use(ident, _, _)\n-          {\n+          ast::view_item_use(ident, _, _) {\n             add_to_index(index, ident, mie_view_item(it));\n           }\n \n+\n           ast::view_item_import(ident, _, id) {\n             add_to_index(index, ident, mie_import_ident(id, it.span));\n           }\n \n+\n           ast::view_item_import_from(_, idents, _) {\n             for ident in idents {\n                 add_to_index(index, ident.node.name,\n                              mie_import_ident(ident.node.id, ident.span));\n             }\n           }\n \n+\n           //globbed imports have to be resolved lazily.\n           ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) {\n           }\n@@ -1191,20 +1184,19 @@ fn lookup_external(e: &env, cnum: int, ids: &[ident], ns: namespace) ->\n fn check_for_collisions(e: &@env, c: &ast::crate) {\n     // Module indices make checking those relatively simple -- just check each\n     // name for multiple entities in the same namespace.\n-    for each m: @{key: ast::node_id, val: @indexed_mod}\n-        in e.mod_map.items() {\n-        for each name: @{key: ident, val: list<mod_index_entry>}\n-            in m.val.index.items() {\n+    for each m: @{key: ast::node_id, val: @indexed_mod} in e.mod_map.items() {\n+        for each name: @{key: ident, val: list<mod_index_entry>} in\n+                 m.val.index.items() {\n             check_mod_name(*e, name.key, name.val);\n         }\n     }\n     // Other scopes have to be checked the hard way.\n-    let v = @{visit_item: bind check_item(e, _, _, _),\n-              visit_block: bind check_block(e, _, _, _),\n-              visit_arm: bind check_arm(e, _, _, _),\n-              visit_expr: bind check_expr(e, _, _, _),\n-              visit_ty: bind check_ty(e, _, _, _)\n-              with *visit::default_visitor()};\n+    let v =\n+        @{visit_item: bind check_item(e, _, _, _),\n+          visit_block: bind check_block(e, _, _, _),\n+          visit_arm: bind check_arm(e, _, _, _),\n+          visit_expr: bind check_expr(e, _, _, _),\n+          visit_ty: bind check_ty(e, _, _, _) with *visit::default_visitor()};\n     visit::visit_crate(c, (), visit::mk_vt(v));\n }\n \n@@ -1252,29 +1244,29 @@ fn mie_span(mie: &mod_index_entry) -> span {\n \n fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt<()>) {\n     fn typaram_names(tps: &[ast::ty_param]) -> [ident] {\n-        let x: [ast::ident] = ~[];\n-        for tp: ast::ty_param in tps { x += ~[tp.ident] }\n+        let x: [ast::ident] = [];\n+        for tp: ast::ty_param in tps { x += [tp.ident] }\n         ret x;\n     }\n     visit::visit_item(i, x, v);\n     alt i.node {\n       ast::item_fn(f, ty_params) {\n         check_fn(*e, i.span, f);\n-        ensure_unique(*e, i.span, typaram_names(ty_params),\n-                      ident_id, \"type parameter\");\n+        ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n+                      \"type parameter\");\n       }\n       ast::item_obj(ob, ty_params, _) {\n         fn field_name(field: &ast::obj_field) -> ident { ret field.ident; }\n         ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n         for m: @ast::method in ob.methods {\n             check_fn(*e, m.span, m.node.meth);\n         }\n-        ensure_unique(*e, i.span, typaram_names(ty_params),\n-                      ident_id, \"type parameter\");\n+        ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n+                      \"type parameter\");\n       }\n       ast::item_tag(_, ty_params) {\n-        ensure_unique(*e, i.span, typaram_names(ty_params),\n-                      ident_id, \"type parameter\");\n+        ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n+                      \"type parameter\");\n       }\n       _ { }\n     }\n@@ -1290,25 +1282,25 @@ fn check_pat(ch: checker, p: &@ast::pat) {\n fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt<()>) {\n     visit::visit_arm(a, x, v);\n     let ch0 = checker(*e, \"binding\");\n-    check_pat(ch0, a.pats.(0));\n+    check_pat(ch0, a.pats[0]);\n     let seen0 = ch0.seen;\n     let i = vec::len(a.pats);\n     while i > 1u {\n         i -= 1u;\n         let ch = checker(*e, \"binding\");\n-        check_pat(ch, a.pats.(i));\n+        check_pat(ch, a.pats[i]);\n \n         // Ensure the bindings introduced in this pattern are the same as in\n         // the first pattern.\n         if vec::len(ch.seen) != vec::len(seen0) {\n-            e.sess.span_err(a.pats.(i).span,\n+            e.sess.span_err(a.pats[i].span,\n                             \"inconsistent number of bindings\");\n         } else {\n             for name: ident in ch.seen {\n                 if is_none(vec::find(bind str::eq(name, _), seen0)) {\n                     // Fight the alias checker\n                     let name_ = name;\n-                    e.sess.span_err(a.pats.(i).span,\n+                    e.sess.span_err(a.pats[i].span,\n                                     \"binding \" + name_ +\n                                         \" does not occur in first pattern\");\n                 }\n@@ -1395,7 +1387,7 @@ fn check_ty(e: &@env, ty: &@ast::ty, x: &(), v: &vt<()>) {\n type checker = @{mutable seen: [ident], kind: str, sess: session};\n \n fn checker(e: &env, kind: str) -> checker {\n-    let seen: [ident] = ~[];\n+    let seen: [ident] = [];\n     ret @{mutable seen: seen, kind: kind, sess: e.sess};\n }\n \n@@ -1408,12 +1400,12 @@ fn check_name(ch: &checker, sp: &span, name: &ident) {\n }\n fn add_name(ch: &checker, sp: &span, name: &ident) {\n     check_name(ch, sp, name);\n-    ch.seen += ~[name];\n+    ch.seen += [name];\n }\n \n fn ident_id(i: &ident) -> ident { ret i; }\n \n-fn ensure_unique<T>(e: &env, sp: &span, elts: &[T], id: fn(&T) -> ident ,\n+fn ensure_unique<T>(e: &env, sp: &span, elts: &[T], id: fn(&T) -> ident,\n                     kind: &str) {\n     let ch = checker(e, kind);\n     for elt: T in elts { add_name(ch, sp, id(elt)); }"}, {"sha": "a3d0dbe0b6eb1efffcf940d78a1f9562c7491df0", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 206, "deletions": 193, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -34,61 +34,65 @@ import std::str;\n \n import ty_ctxt = middle::ty::ctxt;\n \n-type res_info = { did: ast::def_id, t: ty::t };\n-\n-type ctxt = {\n-    mutable next_tag_id: u16,\n-    pad: u16,\n-    tag_id_to_index: hashmap<ast::def_id,u16>,\n-    mutable tag_order: [ast::def_id],\n-    resources: interner::interner<res_info>,\n-    llshapetablesty: TypeRef,\n-    llshapetables: ValueRef\n-};\n-\n-const shape_u8 : u8 = 0u8;\n-const shape_u16 : u8 = 1u8;\n-const shape_u32 : u8 = 2u8;\n-const shape_u64 : u8 = 3u8;\n-const shape_i8 : u8 = 4u8;\n-const shape_i16 : u8 = 5u8;\n-const shape_i32 : u8 = 6u8;\n-const shape_i64 : u8 = 7u8;\n-const shape_f32 : u8 = 8u8;\n-const shape_f64 : u8 = 9u8;\n-const shape_evec : u8 = 10u8;\n-const shape_ivec : u8 = 11u8;\n-const shape_tag : u8 = 12u8;\n-const shape_box : u8 = 13u8;\n-const shape_struct : u8 = 17u8;\n-const shape_fn : u8 = 18u8;\n-const shape_obj : u8 = 19u8;\n-const shape_res : u8 = 20u8;\n-const shape_var : u8 = 21u8;\n-const shape_uniq : u8 = 22u8;\n+type res_info = {did: ast::def_id, t: ty::t};\n+\n+type ctxt =\n+    {mutable next_tag_id: u16,\n+     pad: u16,\n+     tag_id_to_index: hashmap<ast::def_id, u16>,\n+     mutable tag_order: [ast::def_id],\n+     resources: interner::interner<res_info>,\n+     llshapetablesty: TypeRef,\n+     llshapetables: ValueRef};\n+\n+const shape_u8: u8 = 0u8;\n+const shape_u16: u8 = 1u8;\n+const shape_u32: u8 = 2u8;\n+const shape_u64: u8 = 3u8;\n+const shape_i8: u8 = 4u8;\n+const shape_i16: u8 = 5u8;\n+const shape_i32: u8 = 6u8;\n+const shape_i64: u8 = 7u8;\n+const shape_f32: u8 = 8u8;\n+const shape_f64: u8 = 9u8;\n+const shape_evec: u8 = 10u8;\n+const shape_ivec: u8 = 11u8;\n+const shape_tag: u8 = 12u8;\n+const shape_box: u8 = 13u8;\n+const shape_struct: u8 = 17u8;\n+const shape_fn: u8 = 18u8;\n+const shape_obj: u8 = 19u8;\n+const shape_res: u8 = 20u8;\n+const shape_var: u8 = 21u8;\n+const shape_uniq: u8 = 22u8;\n \n // FIXME: This is a bad API in trans_common.\n-fn C_u8(n : u8) -> ValueRef { ret trans_common::C_u8(n as uint); }\n+fn C_u8(n: u8) -> ValueRef { ret trans_common::C_u8(n as uint); }\n \n-fn hash_res_info(ri : &res_info) -> uint {\n+fn hash_res_info(ri: &res_info) -> uint {\n     let h = 5381u;\n-    h *= 33u; h += (ri.did.crate as uint);\n-    h *= 33u; h += (ri.did.node as uint);\n-    h *= 33u; h += (ri.t as uint);\n+    h *= 33u;\n+    h += ri.did.crate as uint;\n+    h *= 33u;\n+    h += ri.did.node as uint;\n+    h *= 33u;\n+    h += ri.t as uint;\n     ret h;\n }\n \n-fn eq_res_info(a : &res_info, b : &res_info) -> bool {\n+fn eq_res_info(a: &res_info, b: &res_info) -> bool {\n     ret a.did.crate == b.did.crate && a.did.node == b.did.node && a.t == b.t;\n }\n \n-fn mk_global(ccx : &@crate_ctxt, name : &str, llval : ValueRef) -> ValueRef {\n-    let llglobal = lib::llvm::llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval),\n-                                                   str::buf(name));\n+fn mk_global(ccx: &@crate_ctxt, name: &str, llval: ValueRef) -> ValueRef {\n+    let llglobal =\n+        lib::llvm::llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval),\n+                                       str::buf(name));\n     lib::llvm::llvm::LLVMSetInitializer(llglobal, llval);\n     lib::llvm::llvm::LLVMSetGlobalConstant(llglobal, True);\n-    lib::llvm::llvm::LLVMSetLinkage(llglobal, lib::llvm::LLVMInternalLinkage\n-                                    as lib::llvm::llvm::Linkage);\n+    lib::llvm::llvm::LLVMSetLinkage(llglobal,\n+                                    lib::llvm::LLVMInternalLinkage as\n+                                        lib::llvm::llvm::Linkage);\n     ret llglobal;\n }\n \n@@ -99,18 +103,18 @@ fn mk_global(ccx : &@crate_ctxt, name : &str, llval : ValueRef) -> ValueRef {\n //\n // TODO: Use this in dynamic_size_of() as well.\n \n-fn largest_variants(ccx : &@crate_ctxt, tag_id : &ast::def_id) -> [uint] {\n+fn largest_variants(ccx: &@crate_ctxt, tag_id: &ast::def_id) -> [uint] {\n     // Compute the minimum and maximum size and alignment for each variant.\n     //\n     // TODO: We could do better here; e.g. we know that any variant that\n     // contains (T,T) must be as least as large as any variant that contains\n     // just T.\n-    let ranges = ~[];\n+    let ranges = [];\n     let variants = ty::tag_variants(ccx.tcx, tag_id);\n-    for variant : ty::variant_info in variants {\n+    for variant: ty::variant_info in variants {\n         let bounded = true;\n-        let { a: min_size, b: min_align } = { a: 0u, b: 0u };\n-        for elem_t : ty::t in variant.args {\n+        let {a: min_size, b: min_align} = {a: 0u, b: 0u};\n+        for elem_t: ty::t in variant.args {\n             if ty::type_contains_params(ccx.tcx, elem_t) {\n                 // TODO: We could do better here; this causes us to\n                 // conservatively assume that (int, T) has minimum size 0,\n@@ -123,34 +127,34 @@ fn largest_variants(ccx : &@crate_ctxt, tag_id : &ast::def_id) -> [uint] {\n             }\n         }\n \n-        ranges += ~[{ size:  { min: min_size,  bounded: bounded },\n-                      align: { min: min_align, bounded: bounded } }];\n+        ranges +=\n+            [{size: {min: min_size, bounded: bounded},\n+              align: {min: min_align, bounded: bounded}}];\n     }\n \n     // Initialize the candidate set to contain all variants.\n-    let candidates = ~[mutable];\n-    for variant in variants { candidates += ~[mutable true]; }\n+    let candidates = [mutable];\n+    for variant in variants { candidates += [mutable true]; }\n \n     // Do a pairwise comparison among all variants still in the candidate set.\n     // Throw out any variant that we know has size and alignment at least as\n     // small as some other variant.\n     let i = 0u;\n     while i < vec::len(ranges) - 1u {\n-        if candidates.(i) {\n+        if candidates[i] {\n             let j = i + 1u;\n-            while (j < vec::len(ranges)) {\n-                if candidates.(j) {\n-                    if ranges.(i).size.bounded && ranges.(i).align.bounded &&\n-                            ranges.(j).size.bounded &&\n-                            ranges.(j).align.bounded {\n-                        if ranges.(i).size >= ranges.(j).size &&\n-                                ranges.(i).align >= ranges.(j).align {\n+            while j < vec::len(ranges) {\n+                if candidates[j] {\n+                    if ranges[i].size.bounded && ranges[i].align.bounded &&\n+                           ranges[j].size.bounded && ranges[j].align.bounded {\n+                        if ranges[i].size >= ranges[j].size &&\n+                               ranges[i].align >= ranges[j].align {\n                             // Throw out j.\n-                            candidates.(j) = false;\n-                        } else if ranges.(j).size >= ranges.(i).size &&\n-                                ranges.(j).align >= ranges.(j).align {\n+                            candidates[j] = false;\n+                        } else if ranges[j].size >= ranges[i].size &&\n+                                      ranges[j].align >= ranges[j].align {\n                             // Throw out i.\n-                            candidates.(i) = false;\n+                            candidates[i] = false;\n                         }\n                     }\n                 }\n@@ -161,10 +165,10 @@ fn largest_variants(ccx : &@crate_ctxt, tag_id : &ast::def_id) -> [uint] {\n     }\n \n     // Return the resulting set.\n-    let result = ~[];\n+    let result = [];\n     i = 0u;\n     while i < vec::len(candidates) {\n-        if candidates.(i) { result += ~[i]; }\n+        if candidates[i] { result += [i]; }\n         i += 1u;\n     }\n     ret result;\n@@ -175,23 +179,24 @@ fn largest_variants(ccx : &@crate_ctxt, tag_id : &ast::def_id) -> [uint] {\n //\n // TODO: Migrate trans over to use this.\n \n-fn round_up(size : u16, align : u8) -> u16 {\n-    assert align >= 1u8;\n+fn round_up(size: u16, align: u8) -> u16 {\n+    assert (align >= 1u8);\n     let alignment = align as u16;\n-    ret ((size-1u16) + alignment) & !(alignment-1u16);\n+    ret size - 1u16 + alignment & !(alignment - 1u16);\n }\n \n-type size_align = { size: u16, align: u8 };\n+type size_align = {size: u16, align: u8};\n \n-fn compute_static_tag_size(ccx : &@crate_ctxt, largest_variants : &[uint],\n-                           did : &ast::def_id) -> size_align {\n-    let max_size = 0u16; let max_align = 1u8;\n+fn compute_static_tag_size(ccx: &@crate_ctxt, largest_variants: &[uint],\n+                           did: &ast::def_id) -> size_align {\n+    let max_size = 0u16;\n+    let max_align = 1u8;\n     let variants = ty::tag_variants(ccx.tcx, did);\n-    for vid : uint in largest_variants {\n+    for vid: uint in largest_variants {\n         // We increment a \"virtual data pointer\" to compute the size.\n-        let lltys = ~[];\n-        for typ : ty::t in variants.(vid).args {\n-            lltys += ~[trans::type_of(ccx, dummy_sp(), typ)];\n+        let lltys = [];\n+        for typ: ty::t in variants[vid].args {\n+            lltys += [trans::type_of(ccx, dummy_sp(), typ)];\n         }\n \n         let llty = trans_common::T_struct(lltys);\n@@ -205,24 +210,17 @@ fn compute_static_tag_size(ccx : &@crate_ctxt, largest_variants : &[uint],\n     // Add space for the tag if applicable.\n     // FIXME (issue #792): This is wrong. If the tag starts with an 8 byte\n     // aligned quantity, we don't align it.\n-    if vec::len(variants) > 1u {\n-        max_size += 4u16;\n-        max_align = 4u8;\n-    }\n+    if vec::len(variants) > 1u { max_size += 4u16; max_align = 4u8; }\n \n-    ret { size: max_size, align: max_align };\n+    ret {size: max_size, align: max_align};\n }\n \n-tag tag_kind {\n-    tk_unit;\n-    tk_enum;\n-    tk_complex;\n-}\n+tag tag_kind { tk_unit; tk_enum; tk_complex; }\n \n-fn tag_kind(ccx : &@crate_ctxt, did : &ast::def_id) -> tag_kind {\n+fn tag_kind(ccx: &@crate_ctxt, did: &ast::def_id) -> tag_kind {\n     let variants = ty::tag_variants(ccx.tcx, did);\n     if vec::len(variants) == 0u { ret tk_complex; }\n-    for v : ty::variant_info in variants {\n+    for v: ty::variant_info in variants {\n         if vec::len(v.args) > 0u { ret tk_complex; }\n     }\n     if vec::len(variants) == 1u { ret tk_unit; }\n@@ -231,100 +229,109 @@ fn tag_kind(ccx : &@crate_ctxt, did : &ast::def_id) -> tag_kind {\n \n \n // Returns the code corresponding to the pointer size on this architecture.\n-fn s_int(_tcx : &ty_ctxt) -> u8 {\n-    ret shape_i32;      // TODO: x86-64\n+fn s_int(_tcx: &ty_ctxt) -> u8 {\n+    ret shape_i32; // TODO: x86-64\n }\n \n-fn s_uint(_tcx : &ty_ctxt) -> u8 {\n-    ret shape_u32;      // TODO: x86-64\n+fn s_uint(_tcx: &ty_ctxt) -> u8 {\n+    ret shape_u32; // TODO: x86-64\n }\n \n-fn s_float(_tcx : &ty_ctxt) -> u8 {\n-    ret shape_f64;      // TODO: x86-64\n+fn s_float(_tcx: &ty_ctxt) -> u8 {\n+    ret shape_f64; // TODO: x86-64\n }\n \n-fn mk_ctxt(llmod : ModuleRef) -> ctxt {\n+fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n     let llshapetablesty = trans_common::T_named_struct(\"shapes\");\n     let llshapetables =\n         lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty,\n                                        str::buf(\"shapes\"));\n \n-    ret {\n-        mutable next_tag_id: 0u16,\n-        pad: 0u16,\n-        tag_id_to_index: common::new_def_hash(),\n-        mutable tag_order: ~[],\n-        resources: interner::mk(hash_res_info, eq_res_info),\n-        llshapetablesty: llshapetablesty,\n-        llshapetables: llshapetables\n-    };\n+    ret {mutable next_tag_id: 0u16,\n+         pad: 0u16,\n+         tag_id_to_index: common::new_def_hash(),\n+         mutable tag_order: [],\n+         resources: interner::mk(hash_res_info, eq_res_info),\n+         llshapetablesty: llshapetablesty,\n+         llshapetables: llshapetables};\n }\n \n-fn add_bool(dest : &mutable [u8], val : bool) {\n-    dest += ~[if val { 1u8 } else { 0u8 }];\n+fn add_bool(dest: &mutable [u8], val: bool) {\n+    dest += [if val { 1u8 } else { 0u8 }];\n }\n \n-fn add_u16(dest : &mutable [u8], val : u16) {\n-    dest += ~[(val & 0xffu16) as u8, (val >> 8u16) as u8];\n+fn add_u16(dest: &mutable [u8], val: u16) {\n+    dest += [val & 0xffu16 as u8, val >> 8u16 as u8];\n }\n \n-fn add_substr(dest : &mutable [u8], src : &[u8]) {\n+fn add_substr(dest: &mutable [u8], src: &[u8]) {\n     add_u16(dest, vec::len(src) as u16);\n     dest += src;\n }\n \n-fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> [u8] {\n-    let s = ~[];\n+fn shape_of(ccx: &@crate_ctxt, t: ty::t) -> [u8] {\n+    let s = [];\n \n     alt ty::struct(ccx.tcx, t) {\n       ty::ty_nil. | ty::ty_bool. | ty::ty_machine(ast::ty_u8.) | ty::ty_bot. {\n-        s += ~[shape_u8];\n+        s += [shape_u8];\n+      }\n+\n+\n+      ty::ty_int. {\n+        s += [s_int(ccx.tcx)];\n       }\n+      ty::ty_float. { s += [s_float(ccx.tcx)]; }\n \n-      ty::ty_int. { s += ~[s_int(ccx.tcx)]; }\n-      ty::ty_float. { s += ~[s_float(ccx.tcx)]; }\n \n       ty::ty_uint. | ty::ty_ptr(_) | ty::ty_type. | ty::ty_native(_) {\n-        s += ~[s_uint(ccx.tcx)];\n+        s += [s_uint(ccx.tcx)];\n       }\n \n-      ty::ty_machine(ast::ty_i8.) { s += ~[shape_i8]; }\n-      ty::ty_machine(ast::ty_u16.) { s += ~[shape_u16]; }\n-      ty::ty_machine(ast::ty_i16.) { s += ~[shape_i16]; }\n-      ty::ty_machine(ast::ty_u32.) | ty::ty_char. { s += ~[shape_u32]; }\n-      ty::ty_machine(ast::ty_i32.) { s += ~[shape_i32]; }\n-      ty::ty_machine(ast::ty_u64.) { s += ~[shape_u64]; }\n-      ty::ty_machine(ast::ty_i64.) { s += ~[shape_i64]; }\n \n-      ty::ty_str. { s += ~[shape_evec, 1u8, 1u8, 0u8, shape_u8]; }\n-      ty::ty_istr. { s += ~[shape_ivec, 1u8, 1u8, 0u8, shape_u8]; }\n+      ty::ty_machine(ast::ty_i8.) {\n+        s += [shape_i8];\n+      }\n+      ty::ty_machine(ast::ty_u16.) { s += [shape_u16]; }\n+      ty::ty_machine(ast::ty_i16.) { s += [shape_i16]; }\n+      ty::ty_machine(ast::ty_u32.) | ty::ty_char. { s += [shape_u32]; }\n+      ty::ty_machine(ast::ty_i32.) { s += [shape_i32]; }\n+      ty::ty_machine(ast::ty_u64.) { s += [shape_u64]; }\n+      ty::ty_machine(ast::ty_i64.) { s += [shape_i64]; }\n+\n+\n+      ty::ty_str. {\n+        s += [shape_evec, 1u8, 1u8, 0u8, shape_u8];\n+      }\n+      ty::ty_istr. { s += [shape_ivec, 1u8, 1u8, 0u8, shape_u8]; }\n+\n \n       ty::ty_tag(did, tps) {\n         alt tag_kind(ccx, did) {\n           tk_unit. {\n             // FIXME: For now we do this.\n-            s += ~[shape_u32];\n+            s += [shape_u32];\n           }\n-          tk_enum. { s += ~[shape_u32]; }\n+          tk_enum. { s += [shape_u32]; }\n           tk_complex. {\n-            s += ~[shape_tag];\n+            s += [shape_tag];\n \n-            let sub = ~[];\n+            let sub = [];\n \n             let id;\n             alt ccx.shape_cx.tag_id_to_index.find(did) {\n               none. {\n                 id = ccx.shape_cx.next_tag_id;\n                 ccx.shape_cx.tag_id_to_index.insert(did, id);\n-                ccx.shape_cx.tag_order += ~[did];\n+                ccx.shape_cx.tag_order += [did];\n                 ccx.shape_cx.next_tag_id += 1u16;\n               }\n               some(existing_id) { id = existing_id; }\n             }\n             add_u16(sub, id as u16);\n \n             add_u16(sub, vec::len(tps) as u16);\n-            for tp : ty::t in tps {\n+            for tp: ty::t in tps {\n                 let subshape = shape_of(ccx, tp);\n                 add_u16(sub, vec::len(subshape) as u16);\n                 sub += subshape;\n@@ -335,91 +342,97 @@ fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> [u8] {\n         }\n       }\n \n+\n       ty::ty_box(mt) {\n-        s += ~[shape_box];\n+        s += [shape_box];\n         add_substr(s, shape_of(ccx, mt.ty));\n       }\n       ty::ty_uniq(subt) {\n-        s += ~[shape_uniq];\n+        s += [shape_uniq];\n         add_substr(s, shape_of(ccx, subt));\n       }\n       ty::ty_vec(mt) {\n-        s += ~[shape_ivec];\n+        s += [shape_ivec];\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n         add_size_hint(ccx, s, mt.ty);\n         add_substr(s, shape_of(ccx, mt.ty));\n       }\n       ty::ty_rec(fields) {\n-        s += ~[shape_struct];\n-        let sub = ~[];\n-        for f : field in fields { sub += shape_of(ccx, f.mt.ty); }\n+        s += [shape_struct];\n+        let sub = [];\n+        for f: field in fields { sub += shape_of(ccx, f.mt.ty); }\n         add_substr(s, sub);\n       }\n       ty::ty_tup(elts) {\n-        s += ~[shape_struct];\n-        let sub = ~[];\n+        s += [shape_struct];\n+        let sub = [];\n         for elt in elts { sub += shape_of(ccx, elt); }\n         add_substr(s, sub);\n       }\n \n-      ty::ty_fn(_,_,_,_,_) { s += ~[shape_fn]; }\n-      ty::ty_native_fn(_,_,_) { s += ~[shape_u32]; }\n-      ty::ty_obj(_) { s += ~[shape_obj]; }\n+\n+      ty::ty_fn(_, _, _, _, _) {\n+        s += [shape_fn];\n+      }\n+      ty::ty_native_fn(_, _, _) { s += [shape_u32]; }\n+      ty::ty_obj(_) { s += [shape_obj]; }\n+\n \n       ty::ty_res(did, raw_subt, tps) {\n         let subt = ty::substitute_type_params(ccx.tcx, tps, raw_subt);\n-        let ri = { did: did, t: subt };\n+        let ri = {did: did, t: subt};\n         let id = interner::intern(ccx.shape_cx.resources, ri);\n \n-        s += ~[shape_res];\n+        s += [shape_res];\n         add_u16(s, id as u16);\n         add_u16(s, vec::len(tps) as u16);\n \n-        let sub = ~[];\n-        for tp : ty::t in tps { add_substr(s, sub); }\n+        let sub = [];\n+        for tp: ty::t in tps { add_substr(s, sub); }\n         add_substr(s, sub);\n \n         add_substr(s, shape_of(ccx, subt));\n \n       }\n \n-      ty::ty_var(n) { fail \"shape_of ty_var\"; }\n-      ty::ty_param(n,_) { s += ~[shape_var, n as u8]; }\n+\n+      ty::ty_var(n) {\n+        fail \"shape_of ty_var\";\n+      }\n+      ty::ty_param(n, _) { s += [shape_var, n as u8]; }\n     }\n \n     ret s;\n }\n \n-fn add_size_hint(ccx : &@crate_ctxt, s : &mutable [u8], typ : ty::t) {\n-    if (ty::type_has_dynamic_size(ccx.tcx, typ)) {\n-        s += ~[ 0u8, 0u8, 0u8 ];\n-        ret;\n-    }\n+fn add_size_hint(ccx: &@crate_ctxt, s: &mutable [u8], typ: ty::t) {\n+    if ty::type_has_dynamic_size(ccx.tcx, typ) { s += [0u8, 0u8, 0u8]; ret; }\n \n     let llty = trans::type_of(ccx, dummy_sp(), typ);\n     add_u16(s, trans::llsize_of_real(ccx, llty) as u16);\n-    s += ~[ trans::llalign_of_real(ccx, llty) as u8 ];\n+    s += [trans::llalign_of_real(ccx, llty) as u8];\n }\n \n // FIXME: We might discover other variants as we traverse these. Handle this.\n-fn shape_of_variant(ccx : &@crate_ctxt, v : &ty::variant_info) -> [u8] {\n-    let s = ~[];\n-    for t : ty::t in v.args { s += shape_of(ccx, t); }\n+fn shape_of_variant(ccx: &@crate_ctxt, v: &ty::variant_info) -> [u8] {\n+    let s = [];\n+    for t: ty::t in v.args { s += shape_of(ccx, t); }\n     ret s;\n }\n \n-fn gen_tag_shapes(ccx : &@crate_ctxt) -> ValueRef {\n+fn gen_tag_shapes(ccx: &@crate_ctxt) -> ValueRef {\n     // Loop over all the tag variants and write their shapes into a data\n     // buffer. As we do this, it's possible for us to discover new tags, so we\n     // must do this first.\n     let i = 0u;\n-    let data = ~[]; let offsets = ~[];\n-    while (i < vec::len(ccx.shape_cx.tag_order)) {\n-        let did = ccx.shape_cx.tag_order.(i);\n+    let data = [];\n+    let offsets = [];\n+    while i < vec::len(ccx.shape_cx.tag_order) {\n+        let did = ccx.shape_cx.tag_order[i];\n         let variants = ty::tag_variants(ccx.tcx, did);\n \n-        for v : ty::variant_info in variants {\n-            offsets += ~[vec::len(data) as u16];\n+        for v: ty::variant_info in variants {\n+            offsets += [vec::len(data) as u16];\n \n             let variant_shape = shape_of_variant(ccx, v);\n             add_substr(data, variant_shape);\n@@ -432,13 +445,14 @@ fn gen_tag_shapes(ccx : &@crate_ctxt) -> ValueRef {\n     // info records for each tag) and the info space (which contains offsets\n     // to each variant shape). As we do so, build up the header.\n \n-    let header = ~[]; let info = ~[];\n+    let header = [];\n+    let info = [];\n     let header_sz = 2u16 * ccx.shape_cx.next_tag_id;\n     let data_sz = vec::len(data) as u16;\n \n     let info_sz = 0u16;\n-    for did_ : ast::def_id in ccx.shape_cx.tag_order {\n-        let did = did_;    // Satisfy alias checker.\n+    for did_: ast::def_id in ccx.shape_cx.tag_order {\n+        let did = did_; // Satisfy alias checker.\n         let variants = ty::tag_variants(ccx.tcx, did);\n         add_u16(header, header_sz + info_sz);\n         info_sz += 2u16 * ((vec::len(variants) as u16) + 2u16) + 3u16;\n@@ -448,25 +462,25 @@ fn gen_tag_shapes(ccx : &@crate_ctxt) -> ValueRef {\n     // variant. Also construct the largest-variant table for each tag, which\n     // contains the variants that the size-of operation needs to look at.\n \n-    let lv_table = ~[];\n+    let lv_table = [];\n     i = 0u;\n-    for did_ : ast::def_id in ccx.shape_cx.tag_order {\n-        let did = did_;    // Satisfy alias checker.\n+    for did_: ast::def_id in ccx.shape_cx.tag_order {\n+        let did = did_; // Satisfy alias checker.\n         let variants = ty::tag_variants(ccx.tcx, did);\n         add_u16(info, vec::len(variants) as u16);\n \n         // Construct the largest-variants table.\n-        add_u16(info, header_sz + info_sz + data_sz +\n-                (vec::len(lv_table) as u16));\n+        add_u16(info,\n+                header_sz + info_sz + data_sz + (vec::len(lv_table) as u16));\n \n         let lv = largest_variants(ccx, did);\n         add_u16(lv_table, vec::len(lv) as u16);\n-        for v : uint in lv { add_u16(lv_table, v as u16); }\n+        for v: uint in lv { add_u16(lv_table, v as u16); }\n \n         // Determine whether the tag has dynamic size.\n         let dynamic = false;\n-        for variant : ty::variant_info in variants {\n-            for typ : ty::t in variant.args {\n+        for variant: ty::variant_info in variants {\n+            for typ: ty::t in variant.args {\n                 if ty::type_has_dynamic_size(ccx.tcx, typ) { dynamic = true; }\n             }\n         }\n@@ -475,24 +489,22 @@ fn gen_tag_shapes(ccx : &@crate_ctxt) -> ValueRef {\n         // Otherwise, write a placeholder.\n         let size_align;\n         if dynamic {\n-            size_align = { size: 0u16, align: 0u8 };\n-        } else {\n-            size_align = compute_static_tag_size(ccx, lv, did);\n-        }\n+            size_align = {size: 0u16, align: 0u8};\n+        } else { size_align = compute_static_tag_size(ccx, lv, did); }\n         add_u16(info, size_align.size);\n-        info += ~[size_align.align];\n+        info += [size_align.align];\n \n         // Now write in the offset of each variant.\n-        for v : ty::variant_info in variants {\n-            add_u16(info, header_sz + info_sz + offsets.(i));\n+        for v: ty::variant_info in variants {\n+            add_u16(info, header_sz + info_sz + offsets[i]);\n             i += 1u;\n         }\n     }\n \n     assert (i == vec::len(offsets));\n-    assert (header_sz == (vec::len(header) as u16));\n-    assert (info_sz == (vec::len(info) as u16));\n-    assert (data_sz == (vec::len(data) as u16));\n+    assert (header_sz == vec::len(header) as u16);\n+    assert (info_sz == vec::len(info) as u16);\n+    assert (data_sz == vec::len(data) as u16);\n \n     header += info;\n     header += data;\n@@ -501,32 +513,33 @@ fn gen_tag_shapes(ccx : &@crate_ctxt) -> ValueRef {\n     ret mk_global(ccx, \"tag_shapes\", C_bytes(header));\n }\n \n-fn gen_resource_shapes(ccx : &@crate_ctxt) -> ValueRef {\n-    let dtors = ~[];\n+fn gen_resource_shapes(ccx: &@crate_ctxt) -> ValueRef {\n+    let dtors = [];\n     let i = 0u;\n     let len = interner::len(ccx.shape_cx.resources);\n     while i < len {\n         let ri = interner::get(ccx.shape_cx.resources, i);\n-        dtors += ~[trans_common::get_res_dtor(ccx, dummy_sp(), ri.did, ri.t)];\n+        dtors += [trans_common::get_res_dtor(ccx, dummy_sp(), ri.did, ri.t)];\n         i += 1u;\n     }\n \n     ret mk_global(ccx, \"resource_shapes\", C_struct(dtors));\n }\n \n-fn gen_shape_tables(ccx : &@crate_ctxt) {\n+fn gen_shape_tables(ccx: &@crate_ctxt) {\n     let lltagstable = gen_tag_shapes(ccx);\n     let llresourcestable = gen_resource_shapes(ccx);\n     trans_common::set_struct_body(ccx.shape_cx.llshapetablesty,\n-                                  ~[val_ty(lltagstable),\n-                                    val_ty(llresourcestable)]);\n+                                  [val_ty(lltagstable),\n+                                   val_ty(llresourcestable)]);\n \n-    let lltables = C_named_struct(ccx.shape_cx.llshapetablesty,\n-                                  ~[lltagstable, llresourcestable]);\n+    let lltables =\n+        C_named_struct(ccx.shape_cx.llshapetablesty,\n+                       [lltagstable, llresourcestable]);\n     lib::llvm::llvm::LLVMSetInitializer(ccx.shape_cx.llshapetables, lltables);\n     lib::llvm::llvm::LLVMSetGlobalConstant(ccx.shape_cx.llshapetables, True);\n     lib::llvm::llvm::LLVMSetLinkage(ccx.shape_cx.llshapetables,\n                                     lib::llvm::LLVMInternalLinkage as\n-                                    lib::llvm::llvm::Linkage);\n+                                        lib::llvm::llvm::Linkage);\n }\n "}, {"sha": "4c51c34d26aa46c138f376cc731e8426090eabb0", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 814, "deletions": 867, "changes": 1681, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "b1c9486212070dfd4e232ad1317c180c449ba935", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 94, "deletions": 96, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -72,24 +72,24 @@ fn matches_always(p: &@ast::pat) -> bool {\n \n fn bind_for_pat(p: &@ast::pat, br: &match_branch, val: ValueRef) {\n     alt p.node {\n-      ast::pat_bind(name) { br.bound += ~[{ident: name, val: val}]; }\n+      ast::pat_bind(name) { br.bound += [{ident: name, val: val}]; }\n       _ { }\n     }\n }\n \n-type enter_pat = fn(&@ast::pat) -> option::t<[@ast::pat]> ;\n+type enter_pat = fn(&@ast::pat) -> option::t<[@ast::pat]>;\n \n fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n-    let result = ~[];\n+    let result = [];\n     for br: match_branch in m {\n-        alt e(br.pats.(col)) {\n+        alt e(br.pats[col]) {\n           some(sub) {\n             let pats =\n                 vec::slice(br.pats, 0u, col) + sub +\n                     vec::slice(br.pats, col + 1u, vec::len(br.pats));\n             let new_br = @{pats: pats with *br};\n-            result += ~[new_br];\n-            bind_for_pat(br.pats.(col), new_br, val);\n+            result += [new_br];\n+            bind_for_pat(br.pats[col], new_br, val);\n           }\n           none. { }\n         }\n@@ -99,7 +99,7 @@ fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n \n fn enter_default(m: &match, col: uint, val: ValueRef) -> match {\n     fn e(p: &@ast::pat) -> option::t<[@ast::pat]> {\n-        ret if matches_always(p) { some(~[]) } else { none };\n+        ret if matches_always(p) { some([]) } else { none };\n     }\n     ret enter_match(m, col, val, e);\n }\n@@ -116,7 +116,7 @@ fn enter_opt(ccx: &@crate_ctxt, m: &match, opt: &opt, col: uint,\n                 } else { none };\n           }\n           ast::pat_lit(l) {\n-            ret if opt_eq(lit(l), opt) { some(~[]) } else { none };\n+            ret if opt_eq(lit(l), opt) { some([]) } else { none };\n           }\n           _ { ret some(vec::init_elt(dummy, size)); }\n         }\n@@ -131,13 +131,13 @@ fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n        option::t<[@ast::pat]> {\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n-            let pats = ~[];\n+            let pats = [];\n             for fname: ast::ident in fields {\n                 let pat = dummy;\n                 for fpat: ast::field_pat in fpats {\n                     if str::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n                 }\n-                pats += ~[pat];\n+                pats += [pat];\n             }\n             ret some(pats);\n           }\n@@ -149,8 +149,8 @@ fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n \n fn enter_tup(m: &match, col: uint, val: ValueRef, n_elts: uint) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(dummy: &@ast::pat, n_elts: uint, p: &@ast::pat)\n-        -> option::t<[@ast::pat]> {\n+    fn e(dummy: &@ast::pat, n_elts: uint, p: &@ast::pat) ->\n+       option::t<[@ast::pat]> {\n         alt p.node {\n           ast::pat_tup(elts) { ret some(elts); }\n           _ { ret some(vec::init_elt(dummy, n_elts)); }\n@@ -163,8 +163,8 @@ fn enter_box(m: &match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(dummy: &@ast::pat, p: &@ast::pat) -> option::t<[@ast::pat]> {\n         alt p.node {\n-          ast::pat_box(sub) { ret some(~[sub]); }\n-          _ { ret some(~[dummy]); }\n+          ast::pat_box(sub) { ret some([sub]); }\n+          _ { ret some([dummy]); }\n         }\n     }\n     ret enter_match(m, col, val, bind e(dummy, _));\n@@ -173,15 +173,15 @@ fn enter_box(m: &match, col: uint, val: ValueRef) -> match {\n fn get_options(ccx: &@crate_ctxt, m: &match, col: uint) -> [opt] {\n     fn add_to_set(set: &mutable [opt], val: &opt) {\n         for l: opt in set { if opt_eq(l, val) { ret; } }\n-        set += ~[val];\n+        set += [val];\n     }\n \n-    let found = ~[];\n+    let found = [];\n     for br: match_branch in m {\n-        alt br.pats.(col).node {\n+        alt br.pats[col].node {\n           ast::pat_lit(l) { add_to_set(found, lit(l)); }\n           ast::pat_tag(_, _) {\n-            add_to_set(found, variant_opt(ccx, br.pats.(col).id));\n+            add_to_set(found, variant_opt(ccx, br.pats[col].id));\n           }\n           _ { }\n         }\n@@ -190,41 +190,41 @@ fn get_options(ccx: &@crate_ctxt, m: &match, col: uint) -> [opt] {\n }\n \n fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n-                        vdefs: &{tg: def_id, var: def_id}, val: ValueRef)\n-    -> {vals: [ValueRef], bcx: @block_ctxt} {\n+                        vdefs: &{tg: def_id, var: def_id}, val: ValueRef) ->\n+   {vals: [ValueRef], bcx: @block_ctxt} {\n     let ccx = bcx.fcx.lcx.ccx;\n     let ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n     let blobptr = val;\n     let variants = ty::tag_variants(ccx.tcx, vdefs.tg);\n-    let args = ~[];\n+    let args = [];\n     let size =\n         vec::len(ty::tag_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n     if size > 0u && vec::len(variants) != 1u {\n         let tagptr =\n             bcx.build.PointerCast(val,\n                                   trans_common::T_opaque_tag_ptr(ccx.tn));\n-        blobptr = bcx.build.GEP(tagptr, ~[C_int(0), C_int(1)]);\n+        blobptr = bcx.build.GEP(tagptr, [C_int(0), C_int(1)]);\n     }\n     let i = 0u;\n     while i < size {\n         let r =\n             trans::GEP_tag(bcx, blobptr, vdefs.tg, vdefs.var, ty_param_substs,\n                            i as int);\n         bcx = r.bcx;\n-        args += ~[r.val];\n+        args += [r.val];\n         i += 1u;\n     }\n     ret {vals: args, bcx: bcx};\n }\n \n fn collect_record_fields(m: &match, col: uint) -> [ast::ident] {\n-    let fields = ~[];\n+    let fields = [];\n     for br: match_branch in m {\n-        alt br.pats.(col).node {\n+        alt br.pats[col].node {\n           ast::pat_rec(fs, _) {\n             for f: ast::field_pat in fs {\n                 if !vec::any(bind str::eq(f.ident, _), fields) {\n-                    fields += ~[f.ident];\n+                    fields += [f.ident];\n                 }\n             }\n           }\n@@ -236,14 +236,14 @@ fn collect_record_fields(m: &match, col: uint) -> [ast::ident] {\n \n fn any_box_pat(m: &match, col: uint) -> bool {\n     for br: match_branch in m {\n-        alt br.pats.(col).node { ast::pat_box(_) { ret true; } _ { } }\n+        alt br.pats[col].node { ast::pat_box(_) { ret true; } _ { } }\n     }\n     ret false;\n }\n \n fn any_tup_pat(m: &match, col: uint) -> bool {\n     for br: match_branch in m {\n-        alt br.pats.(col).node { ast::pat_tup(_) { ret true; } _ { } }\n+        alt br.pats[col].node { ast::pat_tup(_) { ret true; } _ { } }\n     }\n     ret false;\n }\n@@ -252,13 +252,13 @@ type exit_node = {bound: bind_map, from: BasicBlockRef, to: BasicBlockRef};\n type mk_fail = fn() -> BasicBlockRef;\n \n fn pick_col(m: &match) -> uint {\n-    let scores = vec::init_elt_mut(0u, vec::len(m.(0).pats));\n+    let scores = vec::init_elt_mut(0u, vec::len(m[0].pats));\n     for br: match_branch in m {\n         let i = 0u;\n         for p: @ast::pat in br.pats {\n             alt p.node {\n-              ast::pat_lit(_) | ast::pat_tag(_, _) { scores.(i) += 1u; }\n-              _ {}\n+              ast::pat_lit(_) | ast::pat_tag(_, _) { scores[i] += 1u; }\n+              _ { }\n             }\n             i += 1u;\n         }\n@@ -272,10 +272,7 @@ fn pick_col(m: &match) -> uint {\n         if score == 0u { ret i; }\n         // If no irrefutable ones are found, we pick the one with the biggest\n         // branching factor.\n-        if score > max_score {\n-            max_score = score;\n-            best_col = i;\n-        }\n+        if score > max_score { max_score = score; best_col = i; }\n         i += 1u;\n     }\n     ret best_col;\n@@ -284,22 +281,24 @@ fn pick_col(m: &match) -> uint {\n fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n                     f: &mk_fail, exits: &mutable [exit_node]) {\n     if vec::len(m) == 0u { bcx.build.Br(f()); ret; }\n-    if vec::len(m.(0).pats) == 0u {\n-        exits += ~[{bound: m.(0).bound, from: bcx.llbb, to: m.(0).body}];\n-        bcx.build.Br(m.(0).body);\n+    if vec::len(m[0].pats) == 0u {\n+        exits += [{bound: m[0].bound, from: bcx.llbb, to: m[0].body}];\n+        bcx.build.Br(m[0].body);\n         ret;\n     }\n \n     let col = pick_col(m);\n-    let val = vals.(col);\n-    let vals_left = vec::slice(vals, 0u, col) +\n-        vec::slice(vals, col + 1u, vec::len(vals));\n+    let val = vals[col];\n+    let vals_left =\n+        vec::slice(vals, 0u, col) +\n+            vec::slice(vals, col + 1u, vec::len(vals));\n     let ccx = bcx.fcx.lcx.ccx;\n     let pat_id = 0;\n     for br: match_branch in m {\n+\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n-        if pat_id == 0 { pat_id = br.pats.(col).id; }\n+        if pat_id == 0 { pat_id = br.pats[col].id; }\n     }\n \n     let rec_fields = collect_record_fields(m, col);\n@@ -308,12 +307,12 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         let rec_ty = ty::node_id_to_monotype(ccx.tcx, pat_id);\n         let fields =\n             alt ty::struct(ccx.tcx, rec_ty) { ty::ty_rec(fields) { fields } };\n-        let rec_vals = ~[];\n+        let rec_vals = [];\n         for field_name: ast::ident in rec_fields {\n             let ix: uint =\n                 ty::field_idx(ccx.sess, dummy_sp(), field_name, fields);\n-            let r = trans::GEP_tup_like(bcx, rec_ty, val, ~[0, ix as int]);\n-            rec_vals += ~[r.val];\n+            let r = trans::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n+            rec_vals += [r.val];\n             bcx = r.bcx;\n         }\n         compile_submatch(bcx, enter_rec(m, col, rec_fields, val),\n@@ -323,13 +322,14 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n \n     if any_tup_pat(m, col) {\n         let tup_ty = ty::node_id_to_monotype(ccx.tcx, pat_id);\n-        let n_tup_elts = alt ty::struct(ccx.tcx, tup_ty) {\n-          ty::ty_tup(elts) { vec::len(elts) }\n-        };\n-        let tup_vals = ~[], i = 0u;\n+        let n_tup_elts =\n+            alt ty::struct(ccx.tcx, tup_ty) {\n+              ty::ty_tup(elts) { vec::len(elts) }\n+            };\n+        let tup_vals = [], i = 0u;\n         while i < n_tup_elts {\n-            let r = trans::GEP_tup_like(bcx, tup_ty, val, ~[0, i as int]);\n-            tup_vals += ~[r.val];\n+            let r = trans::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n+            tup_vals += [r.val];\n             bcx = r.bcx;\n             i += 1u;\n         }\n@@ -343,9 +343,9 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         let box = bcx.build.Load(val);\n         let unboxed =\n             bcx.build.InBoundsGEP(box,\n-                                  ~[C_int(0),\n-                                    C_int(back::abi::box_rc_field_body)]);\n-        compile_submatch(bcx, enter_box(m, col, val), ~[unboxed] + vals_left,\n+                                  [C_int(0),\n+                                   C_int(back::abi::box_rc_field_body)]);\n+        compile_submatch(bcx, enter_box(m, col, val), [unboxed] + vals_left,\n                          f, exits);\n         ret;\n     }\n@@ -356,14 +356,16 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n     let kind = no_branch;\n     let test_val = val;\n     if vec::len(opts) > 0u {\n-        alt opts.(0) {\n+        alt opts[0] {\n           var(_, vdef) {\n             if vec::len(ty::tag_variants(ccx.tcx, vdef.tg)) == 1u {\n                 kind = single;\n             } else {\n-                let tagptr = bcx.build.PointerCast\n-                    (val, trans_common::T_opaque_tag_ptr(ccx.tn));\n-                let discrimptr = bcx.build.GEP(tagptr, ~[C_int(0), C_int(0)]);\n+                let tagptr =\n+                    bcx.build.PointerCast(\n+                        val,\n+                        trans_common::T_opaque_tag_ptr(ccx.tn));\n+                let discrimptr = bcx.build.GEP(tagptr, [C_int(0), C_int(0)]);\n                 test_val = bcx.build.Load(discrimptr);\n                 kind = switch;\n             }\n@@ -398,15 +400,15 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             let r = trans_opt(bcx, opt);\n             bcx = r.bcx;\n             let t = ty::node_id_to_type(ccx.tcx, pat_id);\n-            let eq = trans::trans_compare(bcx, ast::eq, test_val, t,\n-                                          r.val, t);\n+            let eq =\n+                trans::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n             bcx = new_sub_block_ctxt(bcx, \"next\");\n             eq.bcx.build.CondBr(eq.val, opt_cx.llbb, bcx.llbb);\n           }\n           _ { }\n         }\n         let size = 0u;\n-        let unpacked = ~[];\n+        let unpacked = [];\n         alt opt {\n           var(_, vdef) {\n             let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n@@ -441,18 +443,18 @@ fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n     let our_block = bcx.llbb as uint;\n     let success = true;\n     for each item: @{key: ast::ident, val: ast::node_id} in ids.items() {\n-        let llbbs = ~[];\n-        let vals = ~[];\n+        let llbbs = [];\n+        let vals = [];\n         for ex: exit_node in map {\n             if ex.to as uint == our_block {\n                 alt assoc(item.key, ex.bound) {\n-                  some(val) { llbbs += ~[ex.from]; vals += ~[val]; }\n+                  some(val) { llbbs += [ex.from]; vals += [val]; }\n                   none. { }\n                 }\n             }\n         }\n         if vec::len(vals) > 0u {\n-            let phi = bcx.build.Phi(val_ty(vals.(0)), vals, llbbs);\n+            let phi = bcx.build.Phi(val_ty(vals[0]), vals, llbbs);\n             bcx.fcx.lllocals.insert(item.val, phi);\n         } else { success = false; }\n     }\n@@ -461,25 +463,23 @@ fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n \n fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n              output: &trans::out_method) -> result {\n-    let bodies = ~[];\n-    let match: match = ~[];\n+    let bodies = [];\n+    let match: match = [];\n     let er = trans::trans_expr(cx, expr);\n-    if (ty::type_is_bot(bcx_tcx(cx), ty::expr_ty(bcx_tcx(cx), expr))) {\n+    if ty::type_is_bot(bcx_tcx(cx), ty::expr_ty(bcx_tcx(cx), expr)) {\n+\n         // No need to generate code for alt,\n         // since the disc diverges.\n-        if (!cx.build.is_terminated()) {\n+        if !cx.build.is_terminated() {\n             ret rslt(cx, cx.build.Unreachable());\n-        }\n-        else {\n-            ret er;\n-        }\n+        } else { ret er; }\n     }\n \n     for a: ast::arm in arms {\n         let body = new_scope_block_ctxt(cx, \"case_body\");\n-        bodies += ~[body];\n+        bodies += [body];\n         for p: @ast::pat in a.pats {\n-            match += ~[@{pats: ~[p], body: body.llbb, mutable bound: ~[]}];\n+            match += [@{pats: [p], body: body.llbb, mutable bound: []}];\n         }\n     }\n \n@@ -489,26 +489,26 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n                done: @mutable option::t<BasicBlockRef>) -> BasicBlockRef {\n         alt *done { some(bb) { ret bb; } _ { } }\n         let fail_cx = new_sub_block_ctxt(cx, \"case_fallthrough\");\n-        trans::trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");\n+        trans::trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");;\n         *done = some(fail_cx.llbb);\n         ret fail_cx.llbb;\n     }\n \n-    let exit_map = ~[];\n+    let exit_map = [];\n     let t = trans::node_id_type(cx.fcx.lcx.ccx, expr.id);\n     let v = trans::spill_if_immediate(er.bcx, er.val, t);\n-    compile_submatch(er.bcx, match, ~[v],\n-                     bind mk_fail(cx, expr.span, fail_cx), exit_map);\n+    compile_submatch(er.bcx, match, [v], bind mk_fail(cx, expr.span, fail_cx),\n+                     exit_map);\n \n     let i = 0u;\n-    let arm_results = ~[];\n+    let arm_results = [];\n     for a: ast::arm in arms {\n-        let body_cx = bodies.(i);\n-        if make_phi_bindings(body_cx, exit_map, ast::pat_id_map(a.pats.(0))) {\n+        let body_cx = bodies[i];\n+        if make_phi_bindings(body_cx, exit_map, ast::pat_id_map(a.pats[0])) {\n             let block_res = trans::trans_block(body_cx, a.body, output);\n-            arm_results += ~[block_res];\n+            arm_results += [block_res];\n         } else { // Unreachable\n-            arm_results += ~[rslt(body_cx, C_nil())];\n+            arm_results += [rslt(body_cx, C_nil())];\n         }\n         i += 1u;\n     }\n@@ -518,8 +518,7 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n // Not alt-related, but similar to the pattern-munging code above\n fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n                         table: hashmap<ast::node_id, ValueRef>,\n-                        make_copy: bool)\n-    -> @block_ctxt {\n+                        make_copy: bool) -> @block_ctxt {\n     let ccx = bcx.fcx.lcx.ccx;\n     alt pat.node {\n       ast::pat_bind(_) {\n@@ -532,18 +531,15 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n             bcx = trans::copy_ty(bcx, loaded, ty).bcx;\n             table.insert(pat.id, alloc);\n             trans_common::add_clean(bcx, alloc, ty);\n-        } else {\n-            table.insert(pat.id, val);\n-        }\n+        } else { table.insert(pat.id, val); }\n       }\n       ast::pat_tag(_, sub) {\n         if vec::len(sub) == 0u { ret bcx; }\n         let vdefs = ast::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);\n         let i = 0;\n         for argval: ValueRef in args.vals {\n-            bcx = bind_irrefutable_pat(bcx, sub.(i), argval, table,\n-                                       make_copy);\n+            bcx = bind_irrefutable_pat(bcx, sub[i], argval, table, make_copy);\n             i += 1;\n         }\n       }\n@@ -554,26 +550,28 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n         for f: ast::field_pat in fields {\n             let ix: uint =\n                 ty::field_idx(ccx.sess, pat.span, f.ident, rec_fields);\n-            let r = trans::GEP_tup_like(bcx, rec_ty, val, ~[0, ix as int]);\n+            let r = trans::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n             bcx = bind_irrefutable_pat(r.bcx, f.pat, r.val, table, make_copy);\n         }\n       }\n       ast::pat_tup(elems) {\n         let tup_ty = ty::node_id_to_monotype(ccx.tcx, pat.id);\n         let i = 0u;\n         for elem in elems {\n-            let r = trans::GEP_tup_like(bcx, tup_ty, val, ~[0, i as int]);\n+            let r = trans::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n             bcx = bind_irrefutable_pat(r.bcx, elem, r.val, table, make_copy);\n             i += 1u;\n         }\n       }\n       ast::pat_box(inner) {\n         let box = bcx.build.Load(val);\n-        let unboxed = bcx.build.InBoundsGEP\n-            (box, ~[C_int(0), C_int(back::abi::box_rc_field_body)]);\n+        let unboxed =\n+            bcx.build.InBoundsGEP(box,\n+                                  [C_int(0),\n+                                   C_int(back::abi::box_rc_field_body)]);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, table, true);\n       }\n-      ast::pat_wild. | ast::pat_lit(_) {}\n+      ast::pat_wild. | ast::pat_lit(_) { }\n     }\n     ret bcx;\n }"}, {"sha": "e53f4a47b272d66697a4f0adeac91b1da692fd5d", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 161, "deletions": 163, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -71,9 +71,9 @@ type derived_tydesc_info = {lltydesc: ValueRef, escapes: bool};\n type glue_fns = {no_op_type_glue: ValueRef};\n \n tag tydesc_kind {\n-    tk_static;      // Static (monomorphic) type descriptor.\n-    tk_param;       // Type parameter.\n-    tk_derived;     // Derived from a typaram or another derived tydesc.\n+    tk_static; // Static (monomorphic) type descriptor.\n+    tk_param; // Type parameter.\n+    tk_derived; // Derived from a typaram or another derived tydesc.\n }\n \n type tydesc_info =\n@@ -111,46 +111,44 @@ type stats =\n      fn_times: @mutable [{ident: str, time: int}]};\n \n // Crate context.  Every crate we compile has one of these.\n-type crate_ctxt = {\n-    sess: session::session,\n-    llmod: ModuleRef,\n-    td: target_data,\n-    tn: type_names,\n-    externs: hashmap<str, ValueRef>,\n-    intrinsics: hashmap<str, ValueRef>,\n-\n+type crate_ctxt =\n     // A mapping from the def_id of each item in this crate to the address\n     // of the first instruction of the item's definition in the executable\n     // we're generating.\n-    item_ids: hashmap<ast::node_id, ValueRef>,\n-    ast_map: ast_map::map,\n-    item_symbols: hashmap<ast::node_id, str>,\n-    mutable main_fn: option::t<ValueRef>,\n-    link_meta: link::link_meta,\n     // TODO: hashmap<tup(tag_id,subtys), @tag_info>\n-    tag_sizes: hashmap<ty::t, uint>,\n-    discrims: hashmap<ast::node_id, ValueRef>,\n-    discrim_symbols: hashmap<ast::node_id, str>,\n-    fn_pairs: hashmap<ast::node_id, ValueRef>,\n-    consts: hashmap<ast::node_id, ValueRef>,\n-    obj_methods: hashmap<ast::node_id, ()>,\n-    tydescs: hashmap<ty::t, @tydesc_info>,\n-    module_data: hashmap<str, ValueRef>,\n-    lltypes: hashmap<ty::t, TypeRef>,\n-    glues: @glue_fns,\n-    names: namegen,\n-    sha: std::sha1::sha1,\n-    type_sha1s: hashmap<ty::t, str>,\n-    type_short_names: hashmap<ty::t, str>,\n-    tcx: ty::ctxt,\n-    stats: stats,\n-    upcalls: @upcall::upcalls,\n-    rust_object_type: TypeRef,\n-    tydesc_type: TypeRef,\n-    task_type: TypeRef,\n-    shape_cx: shape::ctxt,\n-    gc_cx: gc::ctxt\n-};\n+    {sess: session::session,\n+     llmod: ModuleRef,\n+     td: target_data,\n+     tn: type_names,\n+     externs: hashmap<str, ValueRef>,\n+     intrinsics: hashmap<str, ValueRef>,\n+     item_ids: hashmap<ast::node_id, ValueRef>,\n+     ast_map: ast_map::map,\n+     item_symbols: hashmap<ast::node_id, str>,\n+     mutable main_fn: option::t<ValueRef>,\n+     link_meta: link::link_meta,\n+     tag_sizes: hashmap<ty::t, uint>,\n+     discrims: hashmap<ast::node_id, ValueRef>,\n+     discrim_symbols: hashmap<ast::node_id, str>,\n+     fn_pairs: hashmap<ast::node_id, ValueRef>,\n+     consts: hashmap<ast::node_id, ValueRef>,\n+     obj_methods: hashmap<ast::node_id, ()>,\n+     tydescs: hashmap<ty::t, @tydesc_info>,\n+     module_data: hashmap<str, ValueRef>,\n+     lltypes: hashmap<ty::t, TypeRef>,\n+     glues: @glue_fns,\n+     names: namegen,\n+     sha: std::sha1::sha1,\n+     type_sha1s: hashmap<ty::t, str>,\n+     type_short_names: hashmap<ty::t, str>,\n+     tcx: ty::ctxt,\n+     stats: stats,\n+     upcalls: @upcall::upcalls,\n+     rust_object_type: TypeRef,\n+     tydesc_type: TypeRef,\n+     task_type: TypeRef,\n+     shape_cx: shape::ctxt,\n+     gc_cx: gc::ctxt};\n \n type local_ctxt =\n     {path: [str],\n@@ -164,12 +162,11 @@ type val_self_pair = {v: ValueRef, t: ty::t};\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n-type fn_ctxt = {\n+type fn_ctxt =\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n     // instructions for this function that will go in the .text\n     // section of the executable we're generating.\n-    llfn: ValueRef,\n \n     // The three implicit arguments that arrive in the function we're\n     // creating.  For instance, foo(int, int) is really foo(ret*,\n@@ -179,37 +176,30 @@ type fn_ctxt = {\n     // convenience.\n \n     // Points to the current task.\n-    lltaskptr: ValueRef,\n \n     // Points to the current environment (bindings of variables to\n     // values), if this is a regular function; points to the current\n     // object, if this is a method.\n-    llenv: ValueRef,\n \n     // Points to where the return value of this function should end\n     // up.\n-    llretptr: ValueRef,\n \n     // The next three elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n     // the function, due to LLVM's quirks.\n \n     // A block for all the function's static allocas, so that LLVM\n     // will coalesce them into a single alloca call.\n-    mutable llstaticallocas: BasicBlockRef,\n \n     // A block containing code that copies incoming arguments to space\n     // already allocated by code in one of the llallocas blocks.\n     // (LLVM requires that arguments be copied to local allocas before\n     // allowing most any operation to be performed on them.)\n-    mutable llcopyargs: BasicBlockRef,\n \n     // The first block containing derived tydescs received from the\n     // runtime.  See description of derived_tydescs, below.\n-    mutable llderivedtydescs_first: BasicBlockRef,\n \n     // The last block of the llderivedtydescs group.\n-    mutable llderivedtydescs: BasicBlockRef,\n \n     // A block for all of the dynamically sized allocas.  This must be\n     // after llderivedtydescs, because these sometimes depend on\n@@ -219,52 +209,41 @@ type fn_ctxt = {\n     // for incoming function arguments?  Or is it merely the block\n     // containing code that copies incoming args to space already\n     // alloca'd by code in llallocas?\n-    mutable lldynamicallocas: BasicBlockRef,\n \n-    mutable llreturn: BasicBlockRef,\n \n     // The token used to clear the dynamic allocas at the end of this frame.\n-    mutable llobstacktoken: option::t<ValueRef>,\n \n     // The 'self' object currently in use in this function, if there\n     // is one.\n-    mutable llself: option::t<val_self_pair>,\n \n     // If this function is actually a iter, a block containing the\n     // code called whenever the iter calls 'put'.\n-    mutable lliterbody: option::t<ValueRef>,\n \n     // If this function is actually a iter, the type of the function\n     // that that we call when we call 'put'. Having to track this is\n     // pretty irritating. We have to do it because we need the type if\n     // we are going to put the iterbody into a closure (if it appears\n     // in a for-each inside of an iter).\n-    mutable iterbodyty: option::t<ty::t>,\n \n     // The next four items: hash tables mapping from AST def_ids to\n     // LLVM-stuff-in-the-frame.\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: hashmap<ast::node_id, ValueRef>,\n \n     // Maps fields in objects to pointers into the interior of\n     // llself's body.\n-    llobjfields: hashmap<ast::node_id, ValueRef>,\n \n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: hashmap<ast::node_id, ValueRef>,\n \n     // The same as above, but for variables accessed via the frame\n     // pointer we pass into an iter, for access to the static\n     // environment of the iter-calling frame.\n-    llupvars: hashmap<ast::node_id, ValueRef>,\n \n     // For convenience, a vector of the incoming tydescs for each of\n     // this functions type parameters, fetched via llvm::LLVMGetParam.\n     // For example, for a function foo::<A, B, C>(), lltydescs contains\n     // the ValueRefs for the tydescs for A, B, and C.\n-    mutable lltydescs: [ValueRef],\n \n     // Derived tydescs are tydescs created at runtime, for types that\n     // involve type parameters inside type constructors.  For example,\n@@ -275,31 +254,48 @@ type fn_ctxt = {\n     // when information about both \"[T]\" and \"T\" are available.  When\n     // such a tydesc is created, we cache it in the derived_tydescs\n     // table for the next time that such a tydesc is needed.\n-    derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n \n     // The node_id of the function, or -1 if it doesn't correspond to\n     // a user-defined function.\n-    id: ast::node_id,\n \n     // The source span where this function comes from, for error\n     // reporting.\n-    sp: span,\n \n     // This function's enclosing local context.\n-    lcx: @local_ctxt\n-};\n+    {llfn: ValueRef,\n+     lltaskptr: ValueRef,\n+     llenv: ValueRef,\n+     llretptr: ValueRef,\n+     mutable llstaticallocas: BasicBlockRef,\n+     mutable llcopyargs: BasicBlockRef,\n+     mutable llderivedtydescs_first: BasicBlockRef,\n+     mutable llderivedtydescs: BasicBlockRef,\n+     mutable lldynamicallocas: BasicBlockRef,\n+     mutable llreturn: BasicBlockRef,\n+     mutable llobstacktoken: option::t<ValueRef>,\n+     mutable llself: option::t<val_self_pair>,\n+     mutable lliterbody: option::t<ValueRef>,\n+     mutable iterbodyty: option::t<ty::t>,\n+     llargs: hashmap<ast::node_id, ValueRef>,\n+     llobjfields: hashmap<ast::node_id, ValueRef>,\n+     lllocals: hashmap<ast::node_id, ValueRef>,\n+     llupvars: hashmap<ast::node_id, ValueRef>,\n+     mutable lltydescs: [ValueRef],\n+     derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n+     id: ast::node_id,\n+     sp: span,\n+     lcx: @local_ctxt};\n \n tag cleanup {\n-    clean(fn(&@block_ctxt) -> result );\n-    clean_temp(ValueRef, fn(&@block_ctxt) -> result );\n+    clean(fn(&@block_ctxt) -> result);\n+    clean_temp(ValueRef, fn(&@block_ctxt) -> result);\n }\n \n fn add_clean(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n-    find_scope_cx(cx).cleanups += ~[clean(bind drop_slot(_, val, ty))];\n+    find_scope_cx(cx).cleanups += [clean(bind drop_slot(_, val, ty))];\n }\n fn add_clean_temp(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n-    find_scope_cx(cx).cleanups +=\n-        ~[clean_temp(val, bind drop_ty(_, val, ty))];\n+    find_scope_cx(cx).cleanups += [clean_temp(val, bind drop_ty(_, val, ty))];\n }\n \n // Note that this only works for temporaries. We should, at some point, move\n@@ -326,22 +322,23 @@ fn revoke_clean(cx: &@block_ctxt, val: ValueRef) {\n     sc_cx.cleanups =\n         std::vec::slice(sc_cx.cleanups, 0u, found as uint) +\n             std::vec::slice(sc_cx.cleanups, (found as uint) + 1u,\n-                             std::vec::len(sc_cx.cleanups));\n+                            std::vec::len(sc_cx.cleanups));\n }\n \n-fn get_res_dtor(ccx : &@crate_ctxt, sp : &span, did : &ast::def_id,\n-                inner_t : ty::t) -> ValueRef {\n+fn get_res_dtor(ccx: &@crate_ctxt, sp: &span, did: &ast::def_id,\n+                inner_t: ty::t) -> ValueRef {\n     if did.crate == ast::local_crate {\n         alt ccx.fn_pairs.find(did.node) {\n-            some(x) { ret x; }\n-            _ { ccx.tcx.sess.bug(\"get_res_dtor: can't find resource dtor!\"); }\n+          some(x) { ret x; }\n+          _ { ccx.tcx.sess.bug(\"get_res_dtor: can't find resource dtor!\"); }\n         }\n     }\n \n     let params = csearch::get_type_param_count(ccx.sess.get_cstore(), did);\n-    let f_t = trans::type_of_fn(ccx, sp, ast::proto_fn,\n-                                ~[{ mode: ty::mo_alias(false), ty: inner_t }],\n-                                ty::mk_nil(ccx.tcx), params);\n+    let f_t =\n+        trans::type_of_fn(ccx, sp, ast::proto_fn,\n+                          [{mode: ty::mo_alias(false), ty: inner_t}],\n+                          ty::mk_nil(ccx.tcx), params);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n                                 csearch::get_symbol(ccx.sess.get_cstore(),\n                                                     did),\n@@ -378,36 +375,35 @@ tag block_kind {\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-type block_ctxt = {\n+type block_ctxt =\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n     // instructions into that block by way of this block context.\n-    llbb: BasicBlockRef,\n \n     // The llvm::builder object serving as an interface to LLVM's\n     // LLVMBuild* functions.\n-    build: builder,\n \n     // The block pointing to this one in the function's digraph.\n-    parent: block_parent,\n \n     // The 'kind' of basic block this is.\n-    kind: block_kind,\n \n     // A list of functions that run at the end of translating this\n     // block, cleaning up any variables that were introduced in the\n     // block and need to go out of scope at the end of it.\n-    mutable cleanups: [cleanup],\n \n     // The source span where this block comes from, for error\n     // reporting.\n-    sp: span,\n \n     // The function context for the function to which this block is\n     // attached.\n-    fcx: @fn_ctxt\n-};\n+    {llbb: BasicBlockRef,\n+     build: builder,\n+     parent: block_parent,\n+     kind: block_kind,\n+     mutable cleanups: [cleanup],\n+     sp: span,\n+     fcx: @fn_ctxt};\n \n // FIXME: we should be able to use option::t<@block_parent> here but\n // the infinite-tag check in rustboot gets upset.\n@@ -417,7 +413,7 @@ type result = {bcx: @block_ctxt, val: ValueRef};\n type result_t = {bcx: @block_ctxt, val: ValueRef, ty: ty::t};\n \n fn extend_path(cx: @local_ctxt, name: &str) -> @local_ctxt {\n-    ret @{path: cx.path + ~[name] with *cx};\n+    ret @{path: cx.path + [name] with *cx};\n }\n \n fn rslt(bcx: @block_ctxt, val: ValueRef) -> result {\n@@ -438,7 +434,7 @@ fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n     assert (n < elt_count);\n     let elt_tys = std::vec::init_elt(T_nil(), elt_count);\n     llvm::LLVMGetStructElementTypes(llstructty, std::vec::to_ptr(elt_tys));\n-    ret llvm::LLVMGetElementType(elt_tys.(n));\n+    ret llvm::LLVMGetElementType(elt_tys[n]);\n }\n \n fn find_scope_cx(cx: &@block_ctxt) -> @block_ctxt {\n@@ -459,8 +455,8 @@ fn bcx_tcx(bcx: &@block_ctxt) -> ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n fn bcx_ccx(bcx: &@block_ctxt) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n fn bcx_lcx(bcx: &@block_ctxt) -> @local_ctxt { ret bcx.fcx.lcx; }\n fn bcx_fcx(bcx: &@block_ctxt) -> @fn_ctxt { ret bcx.fcx; }\n-fn fcx_ccx(fcx: &@fn_ctxt)    -> @crate_ctxt { ret fcx.lcx.ccx; }\n-fn fcx_tcx(fcx: &@fn_ctxt)    -> ty::ctxt { ret fcx.lcx.ccx.tcx; }\n+fn fcx_ccx(fcx: &@fn_ctxt) -> @crate_ctxt { ret fcx.lcx.ccx; }\n+fn fcx_tcx(fcx: &@fn_ctxt) -> ty::ctxt { ret fcx.lcx.ccx.tcx; }\n fn lcx_ccx(lcx: &@local_ctxt) -> @crate_ctxt { ret lcx.ccx; }\n fn ccx_tcx(ccx: &@crate_ctxt) -> ty::ctxt { ret ccx.tcx; }\n \n@@ -527,7 +523,7 @@ fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n }\n \n fn T_fn_pair(cx: &crate_ctxt, tfn: TypeRef) -> TypeRef {\n-    ret T_struct(~[T_ptr(tfn), T_opaque_closure_ptr(cx)]);\n+    ret T_struct([T_ptr(tfn), T_opaque_closure_ptr(cx)]);\n }\n \n fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n@@ -547,7 +543,7 @@ fn set_struct_body(t: TypeRef, elts: &[TypeRef]) {\n                             False);\n }\n \n-fn T_empty_struct() -> TypeRef { ret T_struct(~[]); }\n+fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n \n // NB: This will return something different every time it's called. If\n // you need a generic object type that matches the type of your\n@@ -556,25 +552,27 @@ fn T_empty_struct() -> TypeRef { ret T_struct(~[]); }\n fn T_rust_object() -> TypeRef {\n     let t = T_named_struct(\"rust_object\");\n     let e = T_ptr(T_empty_struct());\n-    set_struct_body(t, ~[e, e]);\n+    set_struct_body(t, [e, e]);\n     ret t;\n }\n \n fn T_task() -> TypeRef {\n     let t = T_named_struct(\"task\");\n \n-    let  // Refcount\n-         // Delegate pointer\n-         // Stack segment pointer\n-         // Runtime SP\n-         // Rust SP\n-         // GC chain\n-\n-         // Domain pointer\n-         // Crate cache pointer\n-         elems =\n-        ~[T_int(), T_int(), T_int(), T_int(), T_int(), T_int(), T_int(),\n-          T_int()];\n+     // Refcount\n+     // Delegate pointer\n+     // Stack segment pointer\n+     // Runtime SP\n+     // Rust SP\n+     // GC chain\n+\n+\n+     // Domain pointer\n+     // Crate cache pointer\n+\n+    let elems =\n+        [T_int(), T_int(), T_int(), T_int(), T_int(), T_int(), T_int(),\n+         T_int()];\n     set_struct_body(t, elems);\n     ret t;\n }\n@@ -586,7 +584,7 @@ fn T_tydesc_field(cx: &crate_ctxt, field: int) -> TypeRef {\n         std::vec::init_elt::<TypeRef>(T_nil(), abi::n_tydesc_fields as uint);\n     llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n                                     std::vec::to_ptr::<TypeRef>(tydesc_elts));\n-    let t = llvm::LLVMGetElementType(tydesc_elts.(field));\n+    let t = llvm::LLVMGetElementType(tydesc_elts[field]);\n     ret t;\n }\n \n@@ -611,30 +609,30 @@ fn T_tydesc(taskptr_type: TypeRef) -> TypeRef {\n     let tydescpp = T_ptr(T_ptr(tydesc));\n     let pvoid = T_ptr(T_i8());\n     let glue_fn_ty =\n-        T_ptr(T_fn(~[T_ptr(T_nil()), taskptr_type, T_ptr(T_nil()), tydescpp,\n-                     pvoid], T_void()));\n+        T_ptr(T_fn([T_ptr(T_nil()), taskptr_type, T_ptr(T_nil()), tydescpp,\n+                    pvoid], T_void()));\n     let cmp_glue_fn_ty =\n-        T_ptr(T_fn(~[T_ptr(T_i1()), taskptr_type, T_ptr(tydesc), tydescpp,\n-                     pvoid, pvoid, T_i8()], T_void()));\n+        T_ptr(T_fn([T_ptr(T_i1()), taskptr_type, T_ptr(tydesc), tydescpp,\n+                    pvoid, pvoid, T_i8()], T_void()));\n \n     let elems =\n-        ~[tydescpp, T_int(), T_int(), glue_fn_ty, glue_fn_ty, glue_fn_ty,\n-          glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty, cmp_glue_fn_ty,\n-          T_ptr(T_i8()), T_ptr(T_i8()), T_int()];\n+        [tydescpp, T_int(), T_int(), glue_fn_ty, glue_fn_ty, glue_fn_ty,\n+         glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty, cmp_glue_fn_ty,\n+         T_ptr(T_i8()), T_ptr(T_i8()), T_int()];\n     set_struct_body(tydesc, elems);\n     ret tydesc;\n }\n \n fn T_array(t: TypeRef, n: uint) -> TypeRef { ret llvm::LLVMArrayType(t, n); }\n \n fn T_evec(t: TypeRef) -> TypeRef {\n-    ret T_struct(~[T_int(), // Refcount\n-                   T_int(), // Alloc\n-                   T_int(), // Fill\n+    ret T_struct([T_int(), // Refcount\n+                  T_int(), // Alloc\n+                  T_int(), // Fill\n \n-                   T_int(), // Pad\n-                            // Body elements\n-                             T_array(t, 0u)]);\n+                  T_int(), // Pad\n+                           // Body elements\n+                            T_array(t, 0u)]);\n }\n \n fn T_opaque_vec_ptr() -> TypeRef { ret T_ptr(T_evec(T_int())); }\n@@ -644,61 +642,61 @@ fn T_opaque_vec_ptr() -> TypeRef { ret T_ptr(T_evec(T_int())); }\n //\n // TODO: Support user-defined vector sizes.\n fn T_ivec(t: TypeRef) -> TypeRef {\n-    ret T_struct(~[T_int(), // Length (\"fill\"; if zero, heapified)\n-                   T_int(), // Alloc\n-                   T_array(t, abi::ivec_default_length)]); // Body elements\n+    ret T_struct([T_int(), // Length (\"fill\"; if zero, heapified)\n+                  T_int(), // Alloc\n+                  T_array(t, abi::ivec_default_length)]); // Body elements\n \n }\n \n \n // Note that the size of this one is in bytes.\n fn T_opaque_ivec() -> TypeRef {\n-    ret T_struct(~[T_int(), // Length (\"fill\"; if zero, heapified)\n-                   T_int(), // Alloc\n-                   T_array(T_i8(), 0u)]); // Body elements\n+    ret T_struct([T_int(), // Length (\"fill\"; if zero, heapified)\n+                  T_int(), // Alloc\n+                  T_array(T_i8(), 0u)]); // Body elements\n \n }\n \n fn T_ivec_heap_part(t: TypeRef) -> TypeRef {\n-    ret T_struct(~[T_int(), // Real length\n-                   T_array(t, 0u)]); // Body elements\n+    ret T_struct([T_int(), // Real length\n+                  T_array(t, 0u)]); // Body elements\n \n }\n \n \n // Interior vector on the heap, also known as the \"stub\". Cast to this when\n // the allocated length (second element of T_ivec above) is zero.\n fn T_ivec_heap(t: TypeRef) -> TypeRef {\n-    ret T_struct(~[T_int(), // Length (zero)\n-                   T_int(), // Alloc\n-                   T_ptr(T_ivec_heap_part(t))]); // Pointer\n+    ret T_struct([T_int(), // Length (zero)\n+                  T_int(), // Alloc\n+                  T_ptr(T_ivec_heap_part(t))]); // Pointer\n \n }\n \n fn T_opaque_ivec_heap_part() -> TypeRef {\n-    ret T_struct(~[T_int(), // Real length\n-                   T_array(T_i8(), 0u)]); // Body elements\n+    ret T_struct([T_int(), // Real length\n+                  T_array(T_i8(), 0u)]); // Body elements\n \n }\n \n fn T_opaque_ivec_heap() -> TypeRef {\n-    ret T_struct(~[T_int(), // Length (zero)\n-                   T_int(), // Alloc\n-                   T_ptr(T_opaque_ivec_heap_part())]); // Pointer\n+    ret T_struct([T_int(), // Length (zero)\n+                  T_int(), // Alloc\n+                  T_ptr(T_opaque_ivec_heap_part())]); // Pointer\n \n }\n \n fn T_str() -> TypeRef { ret T_evec(T_i8()); }\n \n-fn T_box(t: TypeRef) -> TypeRef { ret T_struct(~[T_int(), t]); }\n+fn T_box(t: TypeRef) -> TypeRef { ret T_struct([T_int(), t]); }\n \n fn T_port(_t: TypeRef) -> TypeRef {\n-    ret T_struct(~[T_int()]); // Refcount\n+    ret T_struct([T_int()]); // Refcount\n \n }\n \n fn T_chan(_t: TypeRef) -> TypeRef {\n-    ret T_struct(~[T_int()]); // Refcount\n+    ret T_struct([T_int()]); // Refcount\n \n }\n \n@@ -716,14 +714,13 @@ fn T_typaram(tn: &type_names) -> TypeRef {\n \n fn T_typaram_ptr(tn: &type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n \n-fn T_closure_ptr(cx: &crate_ctxt, llbindings_ty: TypeRef,\n-                 n_ty_params: uint) -> TypeRef {\n+fn T_closure_ptr(cx: &crate_ctxt, llbindings_ty: TypeRef, n_ty_params: uint)\n+   -> TypeRef {\n     // NB: keep this in sync with code in trans_bind; we're making\n     // an LLVM typeref structure that has the same \"shape\" as the ty::t\n     // it constructs.\n-    ret T_ptr(T_box(T_struct(~[T_ptr(cx.tydesc_type),\n-                               llbindings_ty,\n-                               T_captured_tydescs(cx, n_ty_params)])));\n+    ret T_ptr(T_box(T_struct([T_ptr(cx.tydesc_type), llbindings_ty,\n+                              T_captured_tydescs(cx, n_ty_params)])));\n }\n \n fn T_opaque_closure_ptr(cx: &crate_ctxt) -> TypeRef {\n@@ -737,15 +734,15 @@ fn T_opaque_closure_ptr(cx: &crate_ctxt) -> TypeRef {\n fn T_tag(tn: &type_names, size: uint) -> TypeRef {\n     let s = \"tag_\" + uint::to_str(size, 10u);\n     if tn.name_has_type(s) { ret tn.get_type(s); }\n-    let t = T_struct(~[T_int(), T_array(T_i8(), size)]);\n+    let t = T_struct([T_int(), T_array(T_i8(), size)]);\n     tn.associate(s, t);\n     ret t;\n }\n \n fn T_opaque_tag(tn: &type_names) -> TypeRef {\n     let s = \"opaque_tag\";\n     if tn.name_has_type(s) { ret tn.get_type(s); }\n-    let t = T_struct(~[T_int(), T_i8()]);\n+    let t = T_struct([T_int(), T_i8()]);\n     tn.associate(s, t);\n     ret t;\n }\n@@ -763,8 +760,8 @@ fn T_obj_ptr(cx: &crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n     // type. The dynamically-sized fields follow the captured tydescs.\n \n     fn T_obj(cx: &crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n-        ret T_struct(~[T_ptr(cx.tydesc_type),\n-                       T_captured_tydescs(cx, n_captured_tydescs)]);\n+        ret T_struct([T_ptr(cx.tydesc_type),\n+                      T_captured_tydescs(cx, n_captured_tydescs)]);\n     }\n     ret T_ptr(T_box(T_obj(cx, n_captured_tydescs)));\n }\n@@ -832,14 +829,15 @@ fn C_cstr(cx: &@crate_ctxt, s: &str) -> ValueRef {\n \n // A rust boxed-and-length-annotated string.\n fn C_str(cx: &@crate_ctxt, s: &str) -> ValueRef {\n-    let len = str::byte_len(s);\n-    let  // 'alloc'\n-         // 'fill'\n-         // 'pad'\n-        box =\n-        C_struct(~[C_int(abi::const_refcount as int), C_int(len + 1u as int),\n-                   C_int(len + 1u as int), C_int(0),\n-                   llvm::LLVMConstString(str::buf(s), len, False)]);\n+    let len =\n+        str::byte_len(s); // 'alloc'\n+                          // 'fill'\n+                          // 'pad'\n+\n+    let box =\n+        C_struct([C_int(abi::const_refcount as int), C_int(len + 1u as int),\n+                  C_int(len + 1u as int), C_int(0),\n+                  llvm::LLVMConstString(str::buf(s), len, False)]);\n     let g =\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(box),\n                             str::buf(cx.names.next(\"str\")));\n@@ -856,8 +854,8 @@ fn C_postr(s: &str) -> ValueRef {\n \n fn C_zero_byte_arr(size: uint) -> ValueRef {\n     let i = 0u;\n-    let elts: [ValueRef] = ~[];\n-    while i < size { elts += ~[C_u8(0u)]; i += 1u; }\n+    let elts: [ValueRef] = [];\n+    while i < size { elts += [C_u8(0u)]; i += 1u; }\n     ret llvm::LLVMConstArray(T_i8(), std::vec::to_ptr(elts),\n                              std::vec::len(elts));\n }\n@@ -873,19 +871,19 @@ fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n }\n \n fn C_array(ty: TypeRef, elts: &[ValueRef]) -> ValueRef {\n-    ret llvm::LLVMConstArray(ty, std::vec::to_ptr(elts),\n-                             std::vec::len(elts));\n+    ret llvm::LLVMConstArray(ty, std::vec::to_ptr(elts), std::vec::len(elts));\n }\n \n-fn C_bytes(bytes : &[u8]) -> ValueRef {\n+fn C_bytes(bytes: &[u8]) -> ValueRef {\n     ret llvm::LLVMConstString(unsafe::reinterpret_cast(vec::to_ptr(bytes)),\n                               vec::len(bytes), False);\n }\n \n-fn C_shape(ccx : &@crate_ctxt, bytes : &[u8]) -> ValueRef {\n+fn C_shape(ccx: &@crate_ctxt, bytes: &[u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n-    let llglobal = llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape),\n-                                       str::buf(ccx.names.next(\"shape\")));\n+    let llglobal =\n+        llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape),\n+                            str::buf(ccx.names.next(\"shape\")));\n     llvm::LLVMSetInitializer(llglobal, llshape);\n     llvm::LLVMSetGlobalConstant(llglobal, True);\n     llvm::LLVMSetLinkage(llglobal,"}, {"sha": "627dedf90a19a6b49fd271960aac1cc796bdf590", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 127, "deletions": 151, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -43,10 +43,10 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n \n     // The fields of our object will become the arguments to the function\n     // we're creating.\n-    let fn_args: [ast::arg] = ~[];\n+    let fn_args: [ast::arg] = [];\n     for f: ast::obj_field in ob.fields {\n         fn_args +=\n-            ~[{mode: ast::alias(false), ty: f.ty, ident: f.ident, id: f.id}];\n+            [{mode: ast::alias(false), ty: f.ty, ident: f.ident, id: f.id}];\n     }\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n \n@@ -77,15 +77,14 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n     // of 'pair'.\n     let pair_vtbl =\n-        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n-    let pair_box =\n-        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_box)]);\n+        bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    let pair_box = bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_box)]);\n \n     // Make a vtable for this object: a static array of pointers to functions.\n     // It will be located in the read-only memory of the executable we're\n     // creating and will contain ValueRefs for all of this object's methods.\n     // create_vtbl returns a pointer to the vtable, which we store.\n-    let vtbl = create_vtbl(cx, sp, self_ty, ob, ty_params, none, ~[]);\n+    let vtbl = create_vtbl(cx, sp, self_ty, ob, ty_params, none, []);\n     vtbl = bcx.build.PointerCast(vtbl, T_ptr(T_empty_struct()));\n \n     bcx.build.Store(vtbl, pair_vtbl);\n@@ -103,18 +102,18 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         // Store null into pair, if no args or typarams.\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n-        let obj_fields: [ty::t] = ~[];\n-        for a: ty::arg in arg_tys { obj_fields += ~[a.ty]; }\n+        let obj_fields: [ty::t] = [];\n+        for a: ty::arg in arg_tys { obj_fields += [a.ty]; }\n \n-        let tps: [ty::t] = ~[];\n+        let tps: [ty::t] = [];\n         let tydesc_ty = ty::mk_type(ccx.tcx);\n-        for tp: ast::ty_param in ty_params { tps += ~[tydesc_ty]; }\n+        for tp: ast::ty_param in ty_params { tps += [tydesc_ty]; }\n \n         // Synthesize an object body type and hand it off to\n         // trans_malloc_boxed, which allocates a box, including space for a\n         // refcount.\n-        let body_ty: ty::t = create_object_body_type(ccx.tcx, obj_fields, tps,\n-                                                     none);\n+        let body_ty: ty::t =\n+            create_object_body_type(ccx.tcx, obj_fields, tps, none);\n         let box = trans_malloc_boxed(bcx, body_ty);\n         bcx = box.bcx;\n         let body = box.body;\n@@ -129,8 +128,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         // later.\n \n         let body_tydesc =\n-            GEP_tup_like(bcx, body_ty, body,\n-                         ~[0, abi::obj_body_elt_tydesc]);\n+            GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_tydesc]);\n         bcx = body_tydesc.bcx;\n         let ti = none::<@tydesc_info>;\n         let body_td = get_tydesc(bcx, body_ty, true, ti).result;\n@@ -148,37 +146,35 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n \n         // Copy typarams into captured typarams.\n         let body_typarams =\n-            GEP_tup_like(bcx, body_ty, body,\n-                         ~[0, abi::obj_body_elt_typarams]);\n+            GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_typarams]);\n         bcx = body_typarams.bcx;\n         // TODO: can we just get typarams_ty out of body_ty instead?\n         let typarams_ty: ty::t = ty::mk_tup(ccx.tcx, tps);\n         let i: int = 0;\n         for tp: ast::ty_param in ty_params {\n-            let typaram = bcx.fcx.lltydescs.(i);\n+            let typaram = bcx.fcx.lltydescs[i];\n             let capture =\n-                GEP_tup_like(bcx, typarams_ty, body_typarams.val, ~[0, i]);\n+                GEP_tup_like(bcx, typarams_ty, body_typarams.val, [0, i]);\n             bcx = capture.bcx;\n             bcx = copy_val(bcx, INIT, capture.val, typaram, tydesc_ty).bcx;\n             i += 1;\n         }\n \n         // Copy args into body fields.\n         let body_fields =\n-            GEP_tup_like(bcx, body_ty, body,\n-                         ~[0, abi::obj_body_elt_fields]);\n+            GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_fields]);\n         bcx = body_fields.bcx;\n         i = 0;\n         for f: ast::obj_field in ob.fields {\n             alt bcx.fcx.llargs.find(f.id) {\n               some(arg1) {\n-                let arg = load_if_immediate(bcx, arg1, arg_tys.(i).ty);\n+                let arg = load_if_immediate(bcx, arg1, arg_tys[i].ty);\n                 // TODO: can we just get fields_ty out of body_ty instead?\n                 let fields_ty: ty::t = ty::mk_tup(ccx.tcx, obj_fields);\n                 let field =\n-                    GEP_tup_like(bcx, fields_ty, body_fields.val, ~[0, i]);\n+                    GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n                 bcx = field.bcx;\n-                bcx = copy_val(bcx, INIT, field.val, arg, arg_tys.(i).ty).bcx;\n+                bcx = copy_val(bcx, INIT, field.val, arg, arg_tys[i].ty).bcx;\n                 i += 1;\n               }\n               none. {\n@@ -210,16 +206,16 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n \n     // Fields.  FIXME (part of issue #538): Where do we fill in the field\n     // *values* from the outer object?\n-    let additional_fields: [ast::anon_obj_field] = ~[];\n-    let additional_field_vals: [result] = ~[];\n-    let additional_field_tys: [ty::t] = ~[];\n+    let additional_fields: [ast::anon_obj_field] = [];\n+    let additional_field_vals: [result] = [];\n+    let additional_field_tys: [ty::t] = [];\n     alt anon_obj.fields {\n       none. { }\n       some(fields) {\n         additional_fields = fields;\n         for f: ast::anon_obj_field in fields {\n-            additional_field_tys += ~[node_id_type(ccx, f.id)];\n-            additional_field_vals += ~[trans_expr(bcx, f.expr)];\n+            additional_field_tys += [node_id_type(ccx, f.id)];\n+            additional_field_vals += [trans_expr(bcx, f.expr)];\n         }\n       }\n     }\n@@ -236,7 +232,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     let wrapper_obj: ast::_obj =\n         {fields:\n              std::vec::map(ast::obj_field_from_anon_obj_field,\n-                            additional_fields),\n+                           additional_fields),\n          methods: anon_obj.methods};\n \n     let inner_obj_ty: ty::t;\n@@ -251,7 +247,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         // just pass the outer object to create_vtbl().  Our vtable won't need\n         // to have any forwarding slots.\n         vtbl =\n-            create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, ~[], none,\n+            create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, [], none,\n                         additional_field_tys);\n       }\n       some(e) {\n@@ -269,7 +265,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         // forwarding slot.  And, of course, we need to create a normal vtable\n         // entry for every method being added.\n         vtbl =\n-            create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, ~[],\n+            create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, [],\n                         some(inner_obj_ty), additional_field_tys);\n       }\n     }\n@@ -283,9 +279,8 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n \n     // Grab onto the first and second elements of the pair.\n     let pair_vtbl =\n-        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n-    let pair_box =\n-        bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_box)]);\n+        bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    let pair_box = bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_box)]);\n \n     vtbl = bcx.build.PointerCast(vtbl, T_ptr(T_empty_struct()));\n     bcx.build.Store(vtbl, pair_vtbl);\n@@ -307,9 +302,9 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         // Synthesize a type for the object body and hand it off to\n         // trans_malloc_boxed, which allocates a box, including space for a\n         // refcount.\n-        let body_ty: ty::t = create_object_body_type(ccx.tcx,\n-                                                     additional_field_tys,\n-                                                     ~[], some(inner_obj_ty));\n+        let body_ty: ty::t =\n+            create_object_body_type(ccx.tcx, additional_field_tys, [],\n+                                    some(inner_obj_ty));\n         let box = trans_malloc_boxed(bcx, body_ty);\n         bcx = box.bcx;\n         let body = box.body;\n@@ -323,8 +318,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         // the types of the object's fields, so that the fields can be freed\n         // later.\n         let body_tydesc =\n-            GEP_tup_like(bcx, body_ty, body,\n-                         ~[0, abi::obj_body_elt_tydesc]);\n+            GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_tydesc]);\n         bcx = body_tydesc.bcx;\n         let ti = none::<@tydesc_info>;\n         let body_td = get_tydesc(bcx, body_ty, true, ti).result;\n@@ -338,23 +332,20 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         // function in its closure: the fields were passed to the object\n         // constructor and are now available to the object's methods.\n         let body_fields =\n-            GEP_tup_like(bcx, body_ty, body,\n-                         ~[0, abi::obj_body_elt_fields]);\n+            GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_fields]);\n         bcx = body_fields.bcx;\n         let i: int = 0;\n         for f: ast::anon_obj_field in additional_fields {\n             // FIXME (part of issue #538): make this work eventually, when we\n             // have additional field exprs in the AST.\n-            load_if_immediate(bcx, additional_field_vals.(i).val,\n-                              additional_field_tys.(i));\n-            let fields_ty: ty::t = ty::mk_tup(ccx.tcx,\n-                                                  additional_field_tys);\n-            let field =\n-                GEP_tup_like(bcx, fields_ty, body_fields.val, ~[0, i]);\n+            load_if_immediate(bcx, additional_field_vals[i].val,\n+                              additional_field_tys[i]);\n+            let fields_ty: ty::t = ty::mk_tup(ccx.tcx, additional_field_tys);\n+            let field = GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n             bcx = field.bcx;\n             bcx =\n-                copy_val(bcx, INIT, field.val, additional_field_vals.(i).val,\n-                         additional_field_tys.(i)).bcx;\n+                copy_val(bcx, INIT, field.val, additional_field_vals[i].val,\n+                         additional_field_tys[i]).bcx;\n             i += 1;\n         }\n \n@@ -370,7 +361,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n \n             let body_inner_obj =\n                 GEP_tup_like(bcx, body_ty, body,\n-                             ~[0, abi::obj_body_elt_inner_obj]);\n+                             [0, abi::obj_body_elt_inner_obj]);\n             bcx = body_inner_obj.bcx;\n             bcx =\n                 copy_val(bcx, INIT, body_inner_obj.val, inner_obj_val.val,\n@@ -390,6 +381,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n // Used only inside create_vtbl and create_backwarding_vtbl to distinguish\n // different kinds of slots we'll have to create.\n tag vtbl_mthd {\n+\n     // Normal methods are complete AST nodes, but for forwarding methods, the\n     // only information we'll have about them is their type.\n     normal_mthd(@ast::method);\n@@ -421,9 +413,8 @@ fn vtbl_mthd_lteq(a: &vtbl_mthd, b: &vtbl_mthd) -> bool {\n \n // filtering_fn: Used by create_vtbl to filter a list of methods to remove the\n // ones that we don't need forwarding slots for.\n-fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd,\n-                addtl_meths: [@ast::method]) ->\n-    option::t<vtbl_mthd> {\n+fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd, addtl_meths: [@ast::method])\n+   -> option::t<vtbl_mthd> {\n \n     // Since m is a fwding_mthd, and we're checking to see if it's in\n     // addtl_meths (which only contains normal_mthds), we can't just check if\n@@ -448,10 +439,10 @@ fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd,\n // object, and return a pointer to it.\n fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n                ob: &ast::_obj, ty_params: &[ast::ty_param],\n-               inner_obj_ty: option::t<ty::t>,\n-               additional_field_tys: &[ty::t]) -> ValueRef {\n+               inner_obj_ty: option::t<ty::t>, additional_field_tys: &[ty::t])\n+   -> ValueRef {\n \n-    let llmethods: [ValueRef] = ~[];\n+    let llmethods: [ValueRef] = [];\n \n     alt inner_obj_ty {\n       none. {\n@@ -460,12 +451,12 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n \n         // Sort and process all the methods.\n         let meths =\n-            std::sort::merge_sort::<@ast::method>\n-            (bind ast_mthd_lteq(_, _), ob.methods);\n+            std::sort::merge_sort::<@ast::method>(bind ast_mthd_lteq(_, _),\n+                                                  ob.methods);\n \n         for m: @ast::method in meths {\n-            llmethods += ~[process_normal_mthd(cx, m, outer_obj_ty,\n-                                               ty_params)];\n+            llmethods +=\n+                [process_normal_mthd(cx, m, outer_obj_ty, ty_params)];\n         }\n       }\n       some(inner_obj_ty) {\n@@ -478,13 +469,13 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n         // we take the set difference of { methods on the original object }\n         // and { methods being added, whether entirely new or overriding }.\n \n-        let meths: [vtbl_mthd] = ~[];\n+        let meths: [vtbl_mthd] = [];\n \n         // Gather up methods on the inner object.\n         alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n           ty::ty_obj(inner_obj_methods) {\n             for m: ty::method in inner_obj_methods {\n-                meths += ~[fwding_mthd(@m)];\n+                meths += [fwding_mthd(@m)];\n             }\n           }\n           _ {\n@@ -500,12 +491,12 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n \n         // And now add the additional ones, both overriding ones and entirely\n         // new ones.  These will just be normal methods.\n-        for m: @ast::method in ob.methods { meths += ~[normal_mthd(m)]; }\n+        for m: @ast::method in ob.methods { meths += [normal_mthd(m)]; }\n \n         // Sort all the methods and process them.\n         meths =\n-            std::sort::merge_sort::<vtbl_mthd>\n-            (bind vtbl_mthd_lteq(_, _), meths);\n+            std::sort::merge_sort::<vtbl_mthd>(bind vtbl_mthd_lteq(_, _),\n+                                               meths);\n \n         // To create forwarding methods, we'll need a \"backwarding\" vtbl.  See\n         // create_backwarding_vtbl and process_bkwding_method for details.\n@@ -516,13 +507,13 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n             alt m {\n               normal_mthd(nm) {\n                 llmethods +=\n-                    ~[process_normal_mthd(cx, nm, outer_obj_ty, ty_params)];\n+                    [process_normal_mthd(cx, nm, outer_obj_ty, ty_params)];\n               }\n               fwding_mthd(fm) {\n                 llmethods +=\n-                    ~[process_fwding_mthd(cx, sp, fm, ty_params, inner_obj_ty,\n-                                          backwarding_vtbl,\n-                                          additional_field_tys)];\n+                    [process_fwding_mthd(cx, sp, fm, ty_params, inner_obj_ty,\n+                                         backwarding_vtbl,\n+                                         additional_field_tys)];\n               }\n             }\n         }\n@@ -542,40 +533,36 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n     // object, and it needs to forward them to the corresponding slots on the\n     // outer object.  All we know about either one are their types.\n \n-    let llmethods: [ValueRef] = ~[];\n-    let meths: [ty::method]= ~[];\n+    let llmethods: [ValueRef] = [];\n+    let meths: [ty::method] = [];\n \n     // Gather up methods on the inner object.\n     alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n-        ty::ty_obj(inner_obj_methods) {\n-            for m: ty::method in inner_obj_methods {\n-                meths += ~[m];\n-            }\n-        }\n-        _ {\n-            // Shouldn't happen.\n-            cx.ccx.sess.bug(\"create_backwarding_vtbl(): trying to extend a \\\n+      ty::ty_obj(inner_obj_methods) {\n+        for m: ty::method in inner_obj_methods { meths += [m]; }\n+      }\n+      _ {\n+        // Shouldn't happen.\n+        cx.ccx.sess.bug(\"create_backwarding_vtbl(): trying to extend a \\\n                             non-object\");\n-        }\n+      }\n     }\n \n     // Methods should have already been sorted, so no need to do so again.\n     for m: ty::method in meths {\n         // We pass outer_obj_ty to process_fwding_mthd() because it's the one\n         // being forwarded to.\n-        llmethods += ~[process_bkwding_mthd(\n-            cx, sp, @m, ~[], outer_obj_ty, ~[])];\n+        llmethods += [process_bkwding_mthd(cx, sp, @m, [], outer_obj_ty, [])];\n     }\n-\n     ret finish_vtbl(cx, llmethods, \"backwarding_vtbl\");\n }\n \n // finish_vtbl: Given a vector of vtable entries, create the table in\n // read-only memory and return a pointer to it.\n-fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: str)\n-    -> ValueRef {\n+fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: str) ->\n+   ValueRef {\n     let vtbl = C_struct(llmethods);\n-    let vtbl_name = mangle_internal_name_by_path(cx.ccx, cx.path + ~[name]);\n+    let vtbl_name = mangle_internal_name_by_path(cx.ccx, cx.path + [name]);\n     let gvar =\n         llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), str::buf(vtbl_name));\n     llvm::LLVMSetInitializer(gvar, vtbl);\n@@ -600,17 +587,17 @@ fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: str)\n // the corresponding method on inner does, calls that method on outer, and\n // returns the value returned from that call.\n fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n-                       ty_params: &[ast::ty_param], outer_obj_ty: ty::t,\n-                       _additional_field_tys: &[ty::t]) -> ValueRef {\n+                        ty_params: &[ast::ty_param], outer_obj_ty: ty::t,\n+                        _additional_field_tys: &[ty::t]) -> ValueRef {\n \n     // Create a local context that's aware of the name of the method we're\n     // creating.\n-    let mcx: @local_ctxt = @{path: cx.path + ~[\"method\", m.ident] with *cx};\n+    let mcx: @local_ctxt = @{path: cx.path + [\"method\", m.ident] with *cx};\n \n     // Make up a name for the backwarding function.\n     let fn_name: str = \"backwarding_fn\";\n-    let s: str = mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path,\n-                                                      fn_name);\n+    let s: str =\n+        mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path, fn_name);\n \n     // Get the backwarding function's type and declare it.\n     let llbackwarding_fn_ty: TypeRef =\n@@ -630,19 +617,17 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // self-stack to get to the one we really want.\n \n     // Cast to self-stack's type.\n-    let llenv = bcx.build.PointerCast(\n-        fcx.llenv,\n-        T_ptr(T_struct(~[cx.ccx.rust_object_type,\n-                         T_ptr(cx.ccx.rust_object_type)])));\n-\n-    let llself_obj_ptr = bcx.build.GEP(llenv,\n-                                       ~[C_int(0),\n-                                         C_int(1)]);\n+    let llenv =\n+        bcx.build.PointerCast(\n+            fcx.llenv,\n+            T_ptr(T_struct([cx.ccx.rust_object_type,\n+                            T_ptr(cx.ccx.rust_object_type)])));\n+    let llself_obj_ptr = bcx.build.GEP(llenv, [C_int(0), C_int(1)]);\n     llself_obj_ptr = bcx.build.Load(llself_obj_ptr);\n \n     // Cast it back to pointer-to-object-type, so LLVM won't complain.\n-    llself_obj_ptr = bcx.build.PointerCast(llself_obj_ptr,\n-                                           T_ptr(cx.ccx.rust_object_type));\n+    llself_obj_ptr =\n+        bcx.build.PointerCast(llself_obj_ptr, T_ptr(cx.ccx.rust_object_type));\n \n     // The 'llretptr' that will arrive in the backwarding function we're\n     // creating also needs to be the correct type.  Cast it to the method's\n@@ -670,13 +655,12 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n \n     let llouter_obj_vtbl =\n-        bcx.build.GEP(llself_obj_ptr,\n-                      ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n+        bcx.build.GEP(llself_obj_ptr, [C_int(0), C_int(abi::obj_field_vtbl)]);\n     llouter_obj_vtbl = bcx.build.Load(llouter_obj_vtbl);\n     llouter_obj_vtbl = bcx.build.PointerCast(llouter_obj_vtbl, vtbl_type);\n \n     let llouter_mthd =\n-        bcx.build.GEP(llouter_obj_vtbl, ~[C_int(0), C_int(ix as int)]);\n+        bcx.build.GEP(llouter_obj_vtbl, [C_int(0), C_int(ix as int)]);\n \n     // Set up the outer method to be called.\n     let outer_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n@@ -692,7 +676,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Set up the three implicit arguments to the outer method we'll need to\n     // call.\n     let self_arg = llself_obj_ptr;\n-    let llouter_mthd_args: [ValueRef] = ~[llretptr, fcx.lltaskptr, self_arg];\n+    let llouter_mthd_args: [ValueRef] = [llretptr, fcx.lltaskptr, self_arg];\n \n     // Copy the explicit arguments that are being passed into the forwarding\n     // function (they're in fcx.llargs) to llouter_mthd_args.\n@@ -703,7 +687,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         if arg.mode == ty::mo_val {\n             passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n         }\n-        llouter_mthd_args += ~[passed_arg];\n+        llouter_mthd_args += [passed_arg];\n         a += 1u;\n     }\n \n@@ -737,12 +721,12 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Create a local context that's aware of the name of the method we're\n     // creating.\n-    let mcx: @local_ctxt = @{path: cx.path + ~[\"method\", m.ident] with *cx};\n+    let mcx: @local_ctxt = @{path: cx.path + [\"method\", m.ident] with *cx};\n \n     // Make up a name for the forwarding function.\n     let fn_name: str = \"forwarding_fn\";\n-    let s: str = mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path,\n-                                                      fn_name);\n+    let s: str =\n+        mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path, fn_name);\n \n     // Get the forwarding function's type and declare it.\n     let llforwarding_fn_ty: TypeRef =\n@@ -776,7 +760,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // First, grab the box out of the self_obj.  It contains a refcount and a\n     // body.\n     let llself_obj_box =\n-        bcx.build.GEP(llself_obj_ptr, ~[C_int(0), C_int(abi::obj_field_box)]);\n+        bcx.build.GEP(llself_obj_ptr, [C_int(0), C_int(abi::obj_field_box)]);\n     llself_obj_box = bcx.build.Load(llself_obj_box);\n \n     let ccx = bcx_ccx(bcx);\n@@ -786,13 +770,13 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Now, reach into the box and grab the body.\n     let llself_obj_body =\n         bcx.build.GEP(llself_obj_box,\n-                      ~[C_int(0), C_int(abi::box_rc_field_body)]);\n+                      [C_int(0), C_int(abi::box_rc_field_body)]);\n \n     // Now, we need to figure out exactly what type the body is supposed to be\n     // cast to.\n-    let body_ty: ty::t = create_object_body_type(cx.ccx.tcx,\n-                                                 additional_field_tys, ~[],\n-                                                 some(inner_obj_ty));\n+    let body_ty: ty::t =\n+        create_object_body_type(cx.ccx.tcx, additional_field_tys, [],\n+                                some(inner_obj_ty));\n     // And cast to that type.\n     llself_obj_body =\n         bcx.build.PointerCast(llself_obj_body,\n@@ -801,7 +785,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Now, reach into the body and grab the inner_obj.\n     let llinner_obj =\n         GEP_tup_like(bcx, body_ty, llself_obj_body,\n-                     ~[0, abi::obj_body_elt_inner_obj]);\n+                     [0, abi::obj_body_elt_inner_obj]);\n     bcx = llinner_obj.bcx;\n \n     // And, now, somewhere in inner_obj is a vtable with an entry for the\n@@ -810,12 +794,11 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // call it.\n     let llinner_obj_vtbl =\n         bcx.build.GEP(llinner_obj.val,\n-                      ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n+                      [C_int(0), C_int(abi::obj_field_vtbl)]);\n     llinner_obj_vtbl = bcx.build.Load(llinner_obj_vtbl);\n \n     let llinner_obj_body =\n-        bcx.build.GEP(llinner_obj.val,\n-                      ~[C_int(0), C_int(abi::obj_field_box)]);\n+        bcx.build.GEP(llinner_obj.val, [C_int(0), C_int(abi::obj_field_box)]);\n     llinner_obj_body = bcx.build.Load(llinner_obj_body);\n \n     // Get the index of the method we want.\n@@ -836,7 +819,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     llinner_obj_vtbl = bcx.build.PointerCast(llinner_obj_vtbl, vtbl_type);\n \n     let llorig_mthd =\n-        bcx.build.GEP(llinner_obj_vtbl, ~[C_int(0), C_int(ix as int)]);\n+        bcx.build.GEP(llinner_obj_vtbl, [C_int(0), C_int(ix as int)]);\n \n     // Set up the original method to be called.\n     let orig_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n@@ -850,21 +833,21 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     llorig_mthd = bcx.build.Load(llorig_mthd);\n \n     // Set up the self-stack.\n-    let self_stack = alloca(bcx, T_struct(~[cx.ccx.rust_object_type,\n-                                            T_ptr(cx.ccx.rust_object_type)]));\n-    self_stack = populate_self_stack(bcx,\n-                                     self_stack,\n-                                     llself_obj_ptr,\n-                                     backwarding_vtbl,\n-                                     llinner_obj_body);\n+    let self_stack =\n+        alloca(bcx,\n+               T_struct([cx.ccx.rust_object_type,\n+                         T_ptr(cx.ccx.rust_object_type)]));\n+    self_stack =\n+        populate_self_stack(bcx, self_stack, llself_obj_ptr, backwarding_vtbl,\n+                            llinner_obj_body);\n \n     // Cast self_stack back to pointer-to-object-type to make LLVM happy.\n-    self_stack = bcx.build.PointerCast(self_stack,\n-                                       T_ptr(cx.ccx.rust_object_type));\n+    self_stack =\n+        bcx.build.PointerCast(self_stack, T_ptr(cx.ccx.rust_object_type));\n \n     // Set up the three implicit arguments to the original method we'll need\n     // to call.\n-    let llorig_mthd_args: [ValueRef] = ~[llretptr, fcx.lltaskptr, self_stack];\n+    let llorig_mthd_args: [ValueRef] = [llretptr, fcx.lltaskptr, self_stack];\n \n     // Copy the explicit arguments that are being passed into the forwarding\n     // function (they're in fcx.llargs) to llorig_mthd_args.\n@@ -875,7 +858,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         if arg.mode == ty::mo_val {\n             passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n         }\n-        llorig_mthd_args += ~[passed_arg];\n+        llorig_mthd_args += [passed_arg];\n         a += 1u;\n     }\n \n@@ -901,12 +884,14 @@ fn create_object_body_type(tcx: &ty::ctxt, fields_ty: &[ty::t],\n     let body_ty: ty::t;\n     alt maybe_inner_obj_ty {\n       some(inner_obj_ty) {\n-        body_ty = ty::mk_tup(tcx, ~[tydesc_ty, typarams_ty_tup,\n-                                    fields_ty_tup, inner_obj_ty]);\n+        body_ty =\n+            ty::mk_tup(tcx,\n+                       [tydesc_ty, typarams_ty_tup, fields_ty_tup,\n+                        inner_obj_ty]);\n       }\n       none {\n-        body_ty = ty::mk_tup(tcx, ~[tydesc_ty, typarams_ty_tup,\n-                                    fields_ty_tup]);\n+        body_ty =\n+            ty::mk_tup(tcx, [tydesc_ty, typarams_ty_tup, fields_ty_tup]);\n       }\n     }\n \n@@ -927,7 +912,7 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n       }\n     }\n     let mcx: @local_ctxt =\n-        @{path: cx.path + ~[\"method\", m.node.ident] with *cx};\n+        @{path: cx.path + [\"method\", m.node.ident] with *cx};\n     let s: str = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n     let llfn: ValueRef = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n \n@@ -949,32 +934,23 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n // via the llenv argument, and we want the forwarding function to call a\n // method on a \"self\" that's inner-obj-shaped, but we also want to hold onto\n // the outer obj for potential use later by backwarding functions.\n-fn populate_self_stack(bcx: @block_ctxt,\n-                       self_stack: ValueRef, outer_obj: ValueRef,\n-                       backwarding_vtbl: ValueRef, inner_obj_body: ValueRef)\n-    -> ValueRef {\n+fn populate_self_stack(bcx: @block_ctxt, self_stack: ValueRef,\n+                       outer_obj: ValueRef, backwarding_vtbl: ValueRef,\n+                       inner_obj_body: ValueRef) -> ValueRef {\n \n     // Drop the outer obj into the second slot.\n-    let self_pair_ptr = bcx.build.GEP(self_stack,\n-                            ~[C_int(0),\n-                              C_int(1)]);\n+    let self_pair_ptr = bcx.build.GEP(self_stack, [C_int(0), C_int(1)]);\n     bcx.build.Store(outer_obj, self_pair_ptr);\n \n     // Drop in the backwarding vtbl.\n-    let wrapper_pair = bcx.build.GEP(self_stack,\n-                                     ~[C_int(0),\n-                                       C_int(0)]);\n-    let wrapper_vtbl_ptr = bcx.build.GEP(wrapper_pair,\n-                                         ~[C_int(0),\n-                                           C_int(0)]);\n+    let wrapper_pair = bcx.build.GEP(self_stack, [C_int(0), C_int(0)]);\n+    let wrapper_vtbl_ptr = bcx.build.GEP(wrapper_pair, [C_int(0), C_int(0)]);\n     let backwarding_vtbl_cast =\n         bcx.build.PointerCast(backwarding_vtbl, T_ptr(T_empty_struct()));\n     bcx.build.Store(backwarding_vtbl_cast, wrapper_vtbl_ptr);\n \n     // Drop in the inner obj body.\n-    let wrapper_body_ptr = bcx.build.GEP(wrapper_pair,\n-                                         ~[C_int(0),\n-                                           C_int(1)]);\n+    let wrapper_body_ptr = bcx.build.GEP(wrapper_pair, [C_int(0), C_int(1)]);\n     bcx.build.Store(inner_obj_body, wrapper_body_ptr);\n \n     ret self_stack;"}, {"sha": "6aa35018f2ffd9aa741670b99790422f83f44320", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -23,21 +23,21 @@ import aux::crate_ctxt;\n import aux::add_node;\n import middle::tstate::ann::empty_ann;\n \n-fn collect_ids_expr(e: &@expr, rs: @mutable [node_id]) { *rs += ~[e.id]; }\n+fn collect_ids_expr(e: &@expr, rs: @mutable [node_id]) { *rs += [e.id]; }\n \n-fn collect_ids_block(b: &blk, rs: @mutable [node_id]) { *rs += ~[b.node.id]; }\n+fn collect_ids_block(b: &blk, rs: @mutable [node_id]) { *rs += [b.node.id]; }\n \n fn collect_ids_stmt(s: &@stmt, rs: @mutable [node_id]) {\n     alt s.node {\n       stmt_decl(_, id) {\n         log \"node_id \" + int::str(id);\n-        log_stmt(*s);\n-        *rs += ~[id];\n+        log_stmt(*s);;\n+        *rs += [id];\n       }\n       stmt_expr(_, id) {\n         log \"node_id \" + int::str(id);\n-        log_stmt(*s);\n-        *rs += ~[id];\n+        log_stmt(*s);;\n+        *rs += [id];\n       }\n       _ { }\n     }\n@@ -67,7 +67,7 @@ fn init_vecs(ccx: &crate_ctxt, node_ids: &[node_id], len: uint) {\n \n fn visit_fn(ccx: &crate_ctxt, num_constraints: uint, f: &_fn,\n             tps: &[ty_param], sp: &span, i: &fn_ident, id: node_id) {\n-    let node_ids: @mutable [node_id] = @mutable ~[];\n+    let node_ids: @mutable [node_id] = @mutable [];\n     node_ids_in_fn(f, tps, sp, i, id, node_ids);\n     let node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);"}, {"sha": "8f9a56b5e2090f6929115c8d9a4a5393a19aecdf", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 94, "deletions": 103, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -122,7 +122,7 @@ fn tos(v: &[uint]) -> str {\n     for i: uint in v {\n         if i == 0u {\n             rslt += \"0\";\n-        } else if (i == 1u) { rslt += \"1\"; } else { rslt += \"?\"; }\n+        } else if i == 1u { rslt += \"1\"; } else { rslt += \"?\"; }\n     }\n     ret rslt;\n }\n@@ -239,55 +239,56 @@ type norm_constraint = {bit_num: uint, c: sp_constr};\n type constr_map = @std::map::hashmap<def_id, constraint>;\n \n /* Contains stuff that has to be computed up front */\n+/* For easy access, the fn_info stores two special constraints for each\n+function.  i_return holds if all control paths in this function terminate\n+in either a return expression, or an appropriate tail expression.\n+i_diverge holds if all control paths in this function terminate in a fail\n+or diverging call.\n+\n+It might be tempting to use a single constraint C for both properties,\n+where C represents i_return and !C represents i_diverge. This is\n+inadvisable, because then the sense of the bit depends on context. If we're\n+inside a ! function, that reverses the sense of the bit: C would be\n+i_diverge and !C would be i_return.  That's awkward, because we have to\n+pass extra context around to functions that shouldn't care.\n+\n+Okay, suppose C represents i_return and !C represents i_diverge, regardless\n+of context. Consider this code:\n+\n+if (foo) { ret; } else { fail; }\n+\n+C is true in the consequent and false in the alternative. What's T `join`\n+F, then?  ? doesn't work, because this code should definitely-return if the\n+context is a returning function (and be definitely-rejected if the context\n+is a ! function).  F doesn't work, because then the code gets incorrectly\n+rejected if the context is a returning function. T would work, but it\n+doesn't make sense for T `join` F to be T (consider init constraints, for\n+example).;\n+\n+So we need context. And so it seems clearer to just have separate\n+constraints.\n+*/\n type fn_info =\n     {constrs: constr_map,\n      num_constraints: uint,\n      cf: controlflow,\n-/* For easy access, the fn_info stores two special constraints for each\n-   function.  i_return holds if all control paths in this function terminate\n-   in either a return expression, or an appropriate tail expression.\n-   i_diverge holds if all control paths in this function terminate in a fail\n-   or diverging call.\n-\n-   It might be tempting to use a single constraint C for both properties,\n-   where C represents i_return and !C represents i_diverge. This is\n-   inadvisable, because then the sense of the bit depends on context. If we're\n-   inside a ! function, that reverses the sense of the bit: C would be\n-   i_diverge and !C would be i_return.  That's awkward, because we have to\n-   pass extra context around to functions that shouldn't care.\n-\n-   Okay, suppose C represents i_return and !C represents i_diverge, regardless\n-   of context. Consider this code:\n-\n-     if (foo) { ret; } else { fail; }\n-\n-   C is true in the consequent and false in the alternative. What's T `join`\n-   F, then?  ? doesn't work, because this code should definitely-return if the\n-   context is a returning function (and be definitely-rejected if the context\n-   is a ! function).  F doesn't work, because then the code gets incorrectly\n-   rejected if the context is a returning function. T would work, but it\n-   doesn't make sense for T `join` F to be T (consider init constraints, for\n-   example).;\n-\n-   So we need context. And so it seems clearer to just have separate\n-   constraints.\n-*/\n      i_return: tsconstr,\n      i_diverge: tsconstr,\n-    /* list, accumulated during pre/postcondition\n+     /* list, accumulated during pre/postcondition\n      computation, of all local variables that may be\n      used */\n-// Doesn't seem to work without the @ -- bug\n+     // Doesn't seem to work without the @ -- bug\n      used_vars: @mutable [node_id]};\n \n fn tsconstr_to_def_id(t: &tsconstr) -> def_id {\n     alt t { ninit(id, _) { local_def(id) } npred(_, id, _) { id } }\n }\n \n fn tsconstr_to_node_id(t: &tsconstr) -> node_id {\n-    alt t { ninit(id, _) { id }\n-            npred(_, id, _) {\n-              fail \"tsconstr_to_node_id called on pred constraint\" } }\n+    alt t {\n+      ninit(id, _) { id }\n+      npred(_, id, _) { fail \"tsconstr_to_node_id called on pred constraint\" }\n+    }\n }\n \n /* mapping from node ID to typestate annotation */\n@@ -298,10 +299,7 @@ type node_ann_table = @mutable [mutable ts_ann];\n type fn_info_map = @std::map::hashmap<node_id, fn_info>;\n \n type fn_ctxt =\n-    {enclosing: fn_info,\n-     id: node_id,\n-     name: ident,\n-     ccx: crate_ctxt};\n+    {enclosing: fn_info, id: node_id, name: ident, ccx: crate_ctxt};\n \n type crate_ctxt = {tcx: ty::ctxt, node_anns: node_ann_table, fm: fn_info_map};\n \n@@ -315,12 +313,12 @@ fn add_node(ccx: &crate_ctxt, i: node_id, a: &ts_ann) {\n     if sz <= i as uint {\n         vec::grow_mut(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n     }\n-    ccx.node_anns.(i) = a;\n+    ccx.node_anns[i] = a;\n }\n \n fn get_ts_ann(ccx: &crate_ctxt, i: node_id) -> option::t<ts_ann> {\n     if i as uint < vec::len(*ccx.node_anns) {\n-        ret some::<ts_ann>(ccx.node_anns.(i));\n+        ret some::<ts_ann>(ccx.node_anns[i]);\n     } else { ret none::<ts_ann>; }\n }\n \n@@ -507,7 +505,7 @@ fn pure_exp(ccx: &crate_ctxt, id: node_id, p: &prestate) -> bool {\n fn num_constraints(m: fn_info) -> uint { ret m.num_constraints; }\n \n fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n-    let na: [mutable ts_ann] = ~[mutable];\n+    let na: [mutable ts_ann] = [mutable];\n     ret {tcx: cx, node_anns: @mutable na, fm: @new_int_hash::<fn_info>()};\n }\n \n@@ -524,7 +522,7 @@ fn controlflow_expr(ccx: &crate_ctxt, e: @expr) -> controlflow {\n fn constraints_expr(cx: &ty::ctxt, e: @expr) -> [@ty::constr] {\n     alt ty::struct(cx, ty::node_id_to_type(cx, e.id)) {\n       ty::ty_fn(_, _, _, _, cs) { ret cs; }\n-      _ { ret ~[]; }\n+      _ { ret []; }\n     }\n }\n \n@@ -557,14 +555,14 @@ fn node_id_to_def_upvar(cx: &fn_ctxt, id: node_id) -> option::t<def> {\n fn norm_a_constraint(id: def_id, c: &constraint) -> [norm_constraint] {\n     alt c {\n       cinit(n, sp, i) {\n-        ret ~[{bit_num: n, c: respan(sp, ninit(id.node, i))}];\n+        ret [{bit_num: n, c: respan(sp, ninit(id.node, i))}];\n       }\n       cpred(p, descs) {\n-        let rslt: [norm_constraint] = ~[];\n+        let rslt: [norm_constraint] = [];\n         for pd: pred_args in *descs {\n             rslt +=\n-                ~[{bit_num: pd.node.bit_num,\n-                   c: respan(pd.span, npred(p, id, pd.node.args))}];\n+                [{bit_num: pd.node.bit_num,\n+                  c: respan(pd.span, npred(p, id, pd.node.args))}];\n         }\n         ret rslt;\n       }\n@@ -575,8 +573,8 @@ fn norm_a_constraint(id: def_id, c: &constraint) -> [norm_constraint] {\n // Tried to write this as an iterator, but I got a\n // non-exhaustive match in trans.\n fn constraints(fcx: &fn_ctxt) -> [norm_constraint] {\n-    let rslt: [norm_constraint] = ~[];\n-    for each p: @{key: def_id, val: constraint}  in\n+    let rslt: [norm_constraint] = [];\n+    for each p: @{key: def_id, val: constraint} in\n              fcx.enclosing.constrs.items() {\n         rslt += norm_a_constraint(p.key, p.val);\n     }\n@@ -614,12 +612,12 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: &@expr) -> @constr_arg_use {\n         alt tcx.def_map.find(e.id) {\n           some(def_local(l_id)) {\n             ret @respan(p.span,\n-                        carg_ident({ident: p.node.idents.(0),\n+                        carg_ident({ident: p.node.idents[0],\n                                     node: l_id.node}));\n           }\n           some(def_arg(a_id)) {\n             ret @respan(p.span,\n-                        carg_ident({ident: p.node.idents.(0),\n+                        carg_ident({ident: p.node.idents[0],\n                                     node: a_id.node}));\n           }\n           _ {\n@@ -638,17 +636,17 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: &@expr) -> @constr_arg_use {\n     }\n }\n \n-fn exprs_to_constr_args(tcx: ty::ctxt, args: &[@expr]) ->\n-   [@constr_arg_use] {\n+fn exprs_to_constr_args(tcx: ty::ctxt, args: &[@expr]) -> [@constr_arg_use] {\n     let f = bind expr_to_constr_arg(tcx, _);\n-    let rslt: [@constr_arg_use] = ~[];\n-    for e: @expr in args { rslt += ~[f(e)]; }\n+    let rslt: [@constr_arg_use] = [];\n+    for e: @expr in args { rslt += [f(e)]; }\n     rslt\n }\n \n fn expr_to_constr(tcx: ty::ctxt, e: &@expr) -> sp_constr {\n     alt e.node {\n \n+\n       // FIXME change the first pattern to expr_path to test a\n       // typechecker bug\n       expr_call(operator, args) {\n@@ -681,9 +679,9 @@ fn pred_args_to_str(p: &pred_args) -> str {\n \n fn substitute_constr_args(cx: &ty::ctxt, actuals: &[@expr], c: &@ty::constr)\n    -> tsconstr {\n-    let rslt: [@constr_arg_use] = ~[];\n+    let rslt: [@constr_arg_use] = [];\n     for a: @constr_arg in c.node.args {\n-        rslt += ~[substitute_arg(cx, actuals, a)];\n+        rslt += [substitute_arg(cx, actuals, a)];\n     }\n     ret npred(c.node.path, c.node.id, rslt);\n }\n@@ -694,7 +692,7 @@ fn substitute_arg(cx: &ty::ctxt, actuals: &[@expr], a: @constr_arg) ->\n     alt a.node {\n       carg_ident(i) {\n         if i < num_actuals {\n-            ret expr_to_constr_arg(cx, actuals.(i));\n+            ret expr_to_constr_arg(cx, actuals[i]);\n         } else {\n             cx.sess.span_fatal(a.span, \"Constraint argument out of bounds\");\n         }\n@@ -704,11 +702,11 @@ fn substitute_arg(cx: &ty::ctxt, actuals: &[@expr], a: @constr_arg) ->\n     }\n }\n \n-fn pred_args_matches(pattern: &[constr_arg_general_<inst>],\n-                     desc: &pred_args) -> bool {\n+fn pred_args_matches(pattern: &[constr_arg_general_<inst>], desc: &pred_args)\n+   -> bool {\n     let i = 0u;\n     for c: @constr_arg_use in desc.node.args {\n-        let n = pattern.(i);\n+        let n = pattern[i];\n         alt c.node {\n           carg_ident(p) {\n             alt n {\n@@ -729,8 +727,8 @@ fn pred_args_matches(pattern: &[constr_arg_general_<inst>],\n     ret true;\n }\n \n-fn find_instance_(pattern: &[constr_arg_general_<inst>],\n-                  descs: &[pred_args]) -> option::t<uint> {\n+fn find_instance_(pattern: &[constr_arg_general_<inst>], descs: &[pred_args])\n+   -> option::t<uint> {\n     for d: pred_args in descs {\n         if pred_args_matches(pattern, d) { ret some(d.node.bit_num); }\n     }\n@@ -743,7 +741,7 @@ type subst = [{from: inst, to: inst}];\n fn find_instances(_fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n    [{from: uint, to: uint}] {\n \n-    let rslt = ~[];\n+    let rslt = [];\n     if vec::len(subst) == 0u { ret rslt; }\n \n     alt c {\n@@ -754,7 +752,7 @@ fn find_instances(_fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n                 let old_bit_num = d.node.bit_num;\n                 let new = replace(subst, d);\n                 alt find_instance_(new, *descs) {\n-                  some(d1) { rslt += ~[{from: old_bit_num, to: d1}]; }\n+                  some(d1) { rslt += [{from: old_bit_num, to: d1}]; }\n                   _ { }\n                 }\n             }\n@@ -791,18 +789,18 @@ fn insts_to_str(stuff: &[constr_arg_general_<inst>]) -> str {\n }\n \n fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n-    let rslt: [constr_arg_general_<inst>] = ~[];\n+    let rslt: [constr_arg_general_<inst>] = [];\n     for c: @constr_arg_use in d.node.args {\n         alt c.node {\n           carg_ident(p) {\n             alt find_in_subst(p.node, subst) {\n-              some(new) { rslt += ~[carg_ident(new)]; }\n-              _ { rslt += ~[c.node]; }\n+              some(new) { rslt += [carg_ident(new)]; }\n+              _ { rslt += [c.node]; }\n             }\n           }\n           _ {\n             //  log_err \"##\";\n-            rslt += ~[c.node];\n+            rslt += [c.node];\n           }\n         }\n     }\n@@ -893,15 +891,15 @@ fn copy_in_poststate_two(fcx: &fn_ctxt, src_post: &poststate,\n                          ty: oper_type) {\n     let subst;\n     alt ty {\n-      oper_swap. { subst = ~[{from: dest, to: src}, {from: src, to: dest}]; }\n+      oper_swap. { subst = [{from: dest, to: src}, {from: src, to: dest}]; }\n       oper_assign_op. {\n         ret; // Don't do any propagation\n       }\n-      _ { subst = ~[{from: src, to: dest}]; }\n+      _ { subst = [{from: src, to: dest}]; }\n     }\n \n \n-    for each p: @{key: def_id, val: constraint}  in\n+    for each p: @{key: def_id, val: constraint} in\n              fcx.enclosing.constrs.items() {\n         // replace any occurrences of the src def_id with the\n         // dest def_id\n@@ -1000,19 +998,19 @@ fn constraint_mentions(_fcx: &fn_ctxt, c: &norm_constraint, v: node_id) ->\n    bool {\n     ret alt c.c.node {\n           ninit(id, _) { v == id }\n-          npred(_, _, args) { args_mention(args, any_eq, ~[v]) }\n+          npred(_, _, args) { args_mention(args, any_eq, [v]) }\n         };\n }\n \n fn non_init_constraint_mentions(_fcx: &fn_ctxt, c: &norm_constraint,\n                                 v: &node_id) -> bool {\n     ret alt c.c.node {\n           ninit(_, _) { false }\n-          npred(_, _, args) { args_mention(args, any_eq, ~[v]) }\n+          npred(_, _, args) { args_mention(args, any_eq, [v]) }\n         };\n }\n \n-fn args_mention<T>(args: &[@constr_arg_use], q: fn(&[T], node_id) -> bool ,\n+fn args_mention<T>(args: &[@constr_arg_use], q: fn(&[T], node_id) -> bool,\n                    s: &[T]) -> bool {\n     /*\n       FIXME\n@@ -1038,7 +1036,7 @@ fn args_mention<T>(args: &[@constr_arg_use], q: fn(&[T], node_id) -> bool ,\n     ret false;\n }\n \n-fn use_var(fcx: &fn_ctxt, v: &node_id) { *fcx.enclosing.used_vars += ~[v]; }\n+fn use_var(fcx: &fn_ctxt, v: &node_id) { *fcx.enclosing.used_vars += [v]; }\n \n // FIXME: This should be a function in std::vec::.\n fn vec_contains(v: &@mutable [node_id], i: &node_id) -> bool {\n@@ -1057,9 +1055,9 @@ fn do_nothing<T>(_f: &_fn, _tp: &[ty_param], _sp: &span, _i: &fn_ident,\n \n \n fn args_to_constr_args(sp: &span, args: &[arg]) -> [@constr_arg_use] {\n-    let actuals: [@constr_arg_use] = ~[];\n+    let actuals: [@constr_arg_use] = [];\n     for a: arg in args {\n-        actuals += ~[@respan(sp, carg_ident({ident: a.ident, node: a.id}))];\n+        actuals += [@respan(sp, carg_ident({ident: a.ident, node: a.id}))];\n     }\n     ret actuals;\n }\n@@ -1079,56 +1077,49 @@ fn ast_constr_to_sp_constr(tcx: &ty::ctxt, args: &[arg], c: &@constr) ->\n \n type binding = {lhs: [inst], rhs: option::t<initializer>};\n \n-fn local_to_bindings(loc : &@local) -> binding {\n-    let lhs = ~[];\n+fn local_to_bindings(loc: &@local) -> binding {\n+    let lhs = [];\n     for each p: @pat in pat_bindings(loc.node.pat) {\n         let ident = alt p.node { pat_bind(name) { name } };\n-        lhs += ~[{ident: ident, node: p.id}];\n+        lhs += [{ident: ident, node: p.id}];\n     }\n-    {lhs: lhs,\n-     rhs: loc.node.init}\n+    {lhs: lhs, rhs: loc.node.init}\n }\n \n-fn locals_to_bindings(locals : &[@local]) -> [binding] {\n+fn locals_to_bindings(locals: &[@local]) -> [binding] {\n     vec::map(local_to_bindings, locals)\n }\n \n fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> [ty::mode] {\n-    let ty = ty::type_autoderef(fcx.ccx.tcx,\n-                                ty::node_id_to_type(fcx.ccx.tcx, callee));\n+    let ty =\n+        ty::type_autoderef(fcx.ccx.tcx,\n+                           ty::node_id_to_type(fcx.ccx.tcx, callee));\n     alt ty::struct(fcx.ccx.tcx, ty) {\n-      ty::ty_fn(_, args, _, _, _)\n-      | ty::ty_native_fn(_, args, _) {\n-        let modes = ~[];\n-        for arg: ty::arg in args {\n-            modes += ~[arg.mode];\n-        }\n+      ty::ty_fn(_, args, _, _, _) | ty::ty_native_fn(_, args, _) {\n+        let modes = [];\n+        for arg: ty::arg in args { modes += [arg.mode]; }\n         ret modes;\n       }\n       _ {\n         // Shouldn't happen; callee should be ty_fn.\n-        fcx.ccx.tcx.sess.bug(\"non-fn callee type in callee_modes: \"\n-                             + util::ppaux::ty_to_str(fcx.ccx.tcx, ty));\n+        fcx.ccx.tcx.sess.bug(\"non-fn callee type in callee_modes: \" +\n+                                 util::ppaux::ty_to_str(fcx.ccx.tcx, ty));\n       }\n-   }\n+    }\n }\n \n fn callee_arg_init_ops(fcx: &fn_ctxt, callee: node_id) -> [init_op] {\n     fn mode_to_op(m: &ty::mode) -> init_op {\n-        alt m {\n-          ty::mo_move. { init_move }\n-          _ { init_assign }\n-        }\n+        alt m { ty::mo_move. { init_move } _ { init_assign } }\n     }\n     vec::map(mode_to_op, callee_modes(fcx, callee))\n }\n \n-fn anon_bindings(ops: &[init_op], es : &[@expr]) -> [binding] {\n-    let bindings: [binding] = ~[];\n+fn anon_bindings(ops: &[init_op], es: &[@expr]) -> [binding] {\n+    let bindings: [binding] = [];\n     let i = 0;\n     for op: init_op in ops {\n-        bindings += ~[{lhs: ~[],\n-                       rhs: some({op:op, expr: es.(i)})}];\n+        bindings += [{lhs: [], rhs: some({op: op, expr: es[i]})}];\n         i += 1;\n     }\n     ret bindings;"}, {"sha": "8c37df3cec49b800e8aa09ea0ab4e0922fc92a1c", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -79,7 +79,7 @@ fn seq_tritv(p: &postcond, q: &postcond) {\n fn seq_postconds(fcx: &fn_ctxt, ps: &[postcond]) -> postcond {\n     let sz = vec::len(ps);\n     if sz >= 1u {\n-        let prev = tritv_clone(ps.(0));\n+        let prev = tritv_clone(ps[0]);\n         for p: postcond in vec::slice(ps, 1u, sz) { seq_tritv(prev, p); }\n         ret prev;\n     } else { ret ann::empty_poststate(num_constraints(fcx.enclosing)); }\n@@ -97,7 +97,7 @@ fn seq_preconds(fcx: &fn_ctxt, pps: &[pre_and_post]) -> precond {\n                        first: &pre_and_post) -> precond {\n         let sz: uint = vec::len(pps);\n         if sz >= 1u {\n-            let second = pps.(0);\n+            let second = pps[0];\n             assert (pps_len(second) == num_constraints(fcx.enclosing));\n             let second_pre = clone(second.precondition);\n             difference(second_pre, first.postcondition);\n@@ -113,7 +113,7 @@ fn seq_preconds(fcx: &fn_ctxt, pps: &[pre_and_post]) -> precond {\n \n \n     if sz >= 1u {\n-        let first = pps.(0);\n+        let first = pps[0];\n         assert (pps_len(first) == num_vars);\n         ret seq_preconds_go(fcx, vec::slice(pps, 1u, sz), first);\n     } else { ret true_precond(num_vars); }\n@@ -150,24 +150,24 @@ fn relax_precond_stmt(s: &@stmt, cx: &relax_ctxt,\n     visit::visit_stmt(s, cx, vt);\n }\n \n-type relax_ctxt = {fcx:fn_ctxt, i:node_id};\n+type relax_ctxt = {fcx: fn_ctxt, i: node_id};\n \n fn relax_precond_block_inner(b: &blk, cx: &relax_ctxt,\n                              vt: &visit::vt<relax_ctxt>) {\n     relax_precond(cx.i as uint, block_precond(cx.fcx.ccx, b));\n     visit::visit_block(b, cx, vt);\n }\n \n-fn relax_precond_block(fcx: &fn_ctxt, i: node_id, b:&blk) {\n+fn relax_precond_block(fcx: &fn_ctxt, i: node_id, b: &blk) {\n     let cx = {fcx: fcx, i: i};\n     let visitor = visit::default_visitor::<relax_ctxt>();\n     visitor =\n         @{visit_block: relax_precond_block_inner,\n           visit_expr: relax_precond_expr,\n           visit_stmt: relax_precond_stmt,\n-          visit_item: (fn (_i: &@item, _cx: &relax_ctxt,\n-                           _vt: &visit::vt<relax_ctxt>) {})\n-          with *visitor};\n+          visit_item:\n+              fn (_i: &@item, _cx: &relax_ctxt, _vt: &visit::vt<relax_ctxt>) {\n+              } with *visitor};\n     let v1 = visit::mk_vt(visitor);\n     v1.visit_block(b, cx, v1);\n }\n@@ -217,7 +217,7 @@ fn clear_in_poststate_expr(fcx: &fn_ctxt, e: &@expr, t: &poststate) {\n     }\n }\n \n-fn kill_poststate_(fcx : &fn_ctxt, c : &tsconstr, post : &poststate) -> bool {\n+fn kill_poststate_(fcx: &fn_ctxt, c: &tsconstr, post: &poststate) -> bool {\n     log \"kill_poststate_\";\n     ret clear_in_poststate_(bit_num(fcx, c), post);\n }\n@@ -241,8 +241,8 @@ fn clear_in_prestate_ident(fcx: &fn_ctxt, id: &node_id, ident: &ident,\n     ret kill_prestate(fcx, parent, ninit(id, ident));\n }\n \n-fn clear_in_poststate_ident_(fcx : &fn_ctxt, id : &node_id, ident : &ident,\n-                             post : &poststate) -> bool {\n+fn clear_in_poststate_ident_(fcx: &fn_ctxt, id: &node_id, ident: &ident,\n+                             post: &poststate) -> bool {\n     ret kill_poststate_(fcx, ninit(id, ident), post);\n }\n "}, {"sha": "ca28e06c9f813579d13f373c09b2d4de137512cc", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -52,8 +52,8 @@ fn check_unused_vars(fcx: &fn_ctxt) {\n     for c: norm_constraint in constraints(fcx) {\n         alt c.c.node {\n           ninit(id, v) {\n-            if !vec_contains(fcx.enclosing.used_vars, id) &&\n-               v.(0) != ('_' as u8) {\n+            if !vec_contains(fcx.enclosing.used_vars, id) && v[0] != '_' as u8\n+               {\n                 fcx.ccx.tcx.sess.span_warn(c.c.span, \"unused variable \" + v);\n             }\n           }\n@@ -143,17 +143,18 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n     /* Check that the return value is initialized */\n     let post = aux::block_poststate(fcx.ccx, f.body);\n     if f.proto == ast::proto_fn &&\n-        !promises(fcx, post, fcx.enclosing.i_return) &&\n-        !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n-        f.decl.cf == return {\n+           !promises(fcx, post, fcx.enclosing.i_return) &&\n+           !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n+           f.decl.cf == return {\n         fcx.ccx.tcx.sess.span_err(f.body.span,\n-                                   \"In function \" + fcx.name +\n-                                       \", not all control paths \\\n+                                  \"In function \" + fcx.name +\n+                                      \", not all control paths \\\n                                         return a value\");\n         fcx.ccx.tcx.sess.span_fatal(f.decl.output.span,\n                                     \"see declared return type of '\" +\n                                         ty_to_str(f.decl.output) + \"'\");\n-    } else if (f.decl.cf == noreturn) {\n+    } else if f.decl.cf == noreturn {\n+\n         // check that this really always fails\n         // Note that it's ok for i_diverge and i_return to both be true.\n         // In fact, i_diverge implies i_return. (But not vice versa!)"}, {"sha": "277704998ce32412adb99470967c98254bf4a2b6", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -16,16 +16,17 @@ type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n fn collect_local(loc: &@local, cx: &ctxt, v: &visit::vt<ctxt>) {\n     for each p: @pat in pat_bindings(loc.node.pat) {\n         let ident = alt p.node { pat_bind(id) { id } };\n-        log \"collect_local: pushing \" + ident;\n-        *cx.cs += ~[respan(loc.span, ninit(p.id, ident))];\n+        log \"collect_local: pushing \" + ident;;\n+        *cx.cs += [respan(loc.span, ninit(p.id, ident))];\n     }\n     visit::visit_local(loc, cx, v);\n }\n \n fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt<ctxt>) {\n     alt e.node {\n-      expr_check(_, ch) { *cx.cs += ~[expr_to_constr(cx.tcx, ch)]; }\n-      expr_if_check(ex, _, _) { *cx.cs += ~[expr_to_constr(cx.tcx, ex)]; }\n+      expr_check(_, ch) { *cx.cs += [expr_to_constr(cx.tcx, ch)]; }\n+      expr_if_check(ex, _, _) { *cx.cs += [expr_to_constr(cx.tcx, ex)]; }\n+\n \n       // If it's a call, generate appropriate instances of the\n       // call's constraints.\n@@ -34,7 +35,7 @@ fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt<ctxt>) {\n             let ct: sp_constr =\n                 respan(c.span,\n                        aux::substitute_constr_args(cx.tcx, operands, c));\n-            *cx.cs += ~[ct];\n+            *cx.cs += [ct];\n         }\n       }\n       _ { }\n@@ -45,7 +46,7 @@ fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt<ctxt>) {\n \n fn find_locals(tcx: &ty::ctxt, f: &_fn, tps: &[ty_param], sp: &span,\n                i: &fn_ident, id: node_id) -> ctxt {\n-    let cx: ctxt = {cs: @mutable ~[], tcx: tcx};\n+    let cx: ctxt = {cs: @mutable [], tcx: tcx};\n     let visitor = visit::default_visitor::<ctxt>();\n \n     visitor =\n@@ -70,13 +71,13 @@ fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n                                  \" as a variable and a pred\");\n               }\n               cpred(_, pds) {\n-                *pds += ~[respan(c.span, {args: args, bit_num: next})];\n+                *pds += [respan(c.span, {args: args, bit_num: next})];\n               }\n             }\n           }\n           none. {\n             let rslt: @mutable [pred_args] =\n-                @mutable ~[respan(c.span, {args: args, bit_num: next})];\n+                @mutable [respan(c.span, {args: args, bit_num: next})];\n             tbl.insert(d_id, cpred(p, rslt));\n           }\n         }\n@@ -111,32 +112,33 @@ fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n \n     /* Need to add constraints for args too, b/c they\n     can be deinitialized */\n-    for a:arg in f.decl.inputs {\n-        next = add_constraint(cx.tcx, respan(f_sp,\n-                                             ninit(a.id, a.ident)),\n-                              next, res_map);\n+    for a: arg in f.decl.inputs {\n+        next =\n+            add_constraint(cx.tcx, respan(f_sp, ninit(a.id, a.ident)), next,\n+                           res_map);\n     }\n \n     /* add the special i_diverge and i_return constraints\n     (see the type definition for auxiliary::fn_info for an explanation) */\n \n     // use the name of the function for the \"return\" constraint\n-    next = add_constraint(cx.tcx, respan(f_sp, ninit(id, name)), next,\n-                          res_map);\n+    next =\n+        add_constraint(cx.tcx, respan(f_sp, ninit(id, name)), next, res_map);\n     // and the name of the function, with a '!' appended to it, for the\n     // \"diverges\" constraint\n     let diverges_id = ccx.tcx.sess.next_node_id();\n     let diverges_name = name + \"!\";\n     add_constraint(cx.tcx, respan(f_sp, ninit(diverges_id, diverges_name)),\n                    next, res_map);\n \n-    let v: @mutable [node_id] = @mutable ~[];\n+    let v: @mutable [node_id] = @mutable [];\n     let rslt =\n         {constrs: res_map,\n-         num_constraints:\n+\n          // add 2 to account for the i_return and i_diverge constraints\n-             vec::len(*cx.cs) + vec::len(f.decl.constraints)\n-                 + vec::len(f.decl.inputs) + 2u,\n+         num_constraints:\n+             vec::len(*cx.cs) + vec::len(f.decl.constraints) +\n+                 vec::len(f.decl.inputs) + 2u,\n          cf: f.decl.cf,\n          i_return: ninit(id, name),\n          i_diverge: ninit(diverges_id, diverges_name),"}, {"sha": "0d04d5656e780e158f1d1d0601c80e8fe1177f01", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 70, "deletions": 74, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -59,13 +59,14 @@ fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n     alt i.node {\n       item_const(_, e) {\n         // make a fake fcx\n-        let v: @mutable [node_id] = @mutable ~[];\n+        let v: @mutable [node_id] = @mutable [];\n         let fake_fcx =\n-            {enclosing:\n+            {\n+             // just bogus\n+             enclosing:\n                  {constrs: @new_def_hash::<constraint>(),\n                   num_constraints: 0u,\n                   cf: return,\n-                  // just bogus\n                   i_return: ninit(0, \"\"),\n                   i_diverge: ninit(0, \"\"),\n                   used_vars: v},\n@@ -104,7 +105,7 @@ fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n fn find_pre_post_exprs(fcx: &fn_ctxt, args: &[@expr], id: node_id) {\n     if vec::len::<@expr>(args) > 0u {\n         log \"find_pre_post_exprs: oper =\";\n-        log_expr(*args.(0));\n+        log_expr(*args[0]);\n     }\n     fn do_one(fcx: fn_ctxt, e: &@expr) { find_pre_post_expr(fcx, e); }\n     for e: @expr in args { do_one(fcx, e); }\n@@ -132,8 +133,7 @@ fn find_pre_post_loop(fcx: &fn_ctxt, l: &@local, index: &@expr, body: &blk,\n     }\n \n     let loop_precond =\n-        seq_preconds(fcx,\n-                     ~[expr_pp(fcx.ccx, index), block_pp(fcx.ccx, body)]);\n+        seq_preconds(fcx, [expr_pp(fcx.ccx, index), block_pp(fcx.ccx, body)]);\n     let loop_postcond =\n         intersect_states(expr_postcond(fcx.ccx, index),\n                          block_postcond(fcx.ccx, body));\n@@ -159,8 +159,8 @@ fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n \n         let precond_res =\n             seq_preconds(fcx,\n-                         ~[expr_pp(fcx.ccx, antec),\n-                           block_pp(fcx.ccx, conseq)]);\n+                         [expr_pp(fcx.ccx, antec),\n+                          block_pp(fcx.ccx, conseq)]);\n         set_pre_and_post(fcx.ccx, id, precond_res,\n                          expr_poststate(fcx.ccx, antec));\n       }\n@@ -173,12 +173,11 @@ fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n         find_pre_post_expr(fcx, altern);\n         let precond_false_case =\n             seq_preconds(fcx,\n-                         ~[expr_pp(fcx.ccx, antec),\n-                           expr_pp(fcx.ccx, altern)]);\n+                         [expr_pp(fcx.ccx, antec), expr_pp(fcx.ccx, altern)]);\n         let postcond_false_case =\n             seq_postconds(fcx,\n-                          ~[expr_postcond(fcx.ccx, antec),\n-                            expr_postcond(fcx.ccx, altern)]);\n+                          [expr_postcond(fcx.ccx, antec),\n+                           expr_postcond(fcx.ccx, altern)]);\n \n         /* Be sure to set the bit for the check condition here,\n          so that it's *not* set in the alternative. */\n@@ -191,15 +190,15 @@ fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n         }\n         let precond_true_case =\n             seq_preconds(fcx,\n-                         ~[expr_pp(fcx.ccx, antec),\n-                           block_pp(fcx.ccx, conseq)]);\n+                         [expr_pp(fcx.ccx, antec),\n+                          block_pp(fcx.ccx, conseq)]);\n         let postcond_true_case =\n             seq_postconds(fcx,\n-                          ~[expr_postcond(fcx.ccx, antec),\n-                            block_postcond(fcx.ccx, conseq)]);\n+                          [expr_postcond(fcx.ccx, antec),\n+                           block_postcond(fcx.ccx, conseq)]);\n \n         let precond_res =\n-            seq_postconds(fcx, ~[precond_true_case, precond_false_case]);\n+            seq_postconds(fcx, [precond_true_case, precond_false_case]);\n         let postcond_res =\n             intersect_states(postcond_true_case, postcond_false_case);\n         set_pre_and_post(fcx.ccx, id, precond_res, postcond_res);\n@@ -220,10 +219,10 @@ fn gen_if_local(fcx: &fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n             gen(fcx, larger_id,\n                 ninit(d_id.node, path_to_ident(fcx.ccx.tcx, pth)));\n           }\n-          _ { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n+          _ { find_pre_post_exprs(fcx, [lhs, rhs], larger_id); }\n         }\n       }\n-      _ { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n+      _ { find_pre_post_exprs(fcx, [lhs, rhs], larger_id); }\n     }\n }\n \n@@ -303,13 +302,12 @@ fn handle_var(fcx: &fn_ctxt, rslt: &pre_and_post, id: node_id, name: ident) {\n     }\n }\n \n-fn forget_args_moved_in(fcx: &fn_ctxt, parent: &@expr,\n-                        modes: &[ty::mode],\n+fn forget_args_moved_in(fcx: &fn_ctxt, parent: &@expr, modes: &[ty::mode],\n                         operands: &[@expr]) {\n     let i = 0u;\n     for mode: ty::mode in modes {\n         if mode == ty::mo_move {\n-            forget_in_postcond(fcx, parent.id, operands.(i).id);\n+            forget_in_postcond(fcx, parent.id, operands[i].id);\n         }\n         i += 1u;\n     }\n@@ -324,8 +322,10 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n \n     alt e.node {\n       expr_call(operator, operands) {\n-        let /* copy */args = operands;\n-        args += ~[operator];\n+        /* copy */\n+\n+        let args = operands;\n+        args += [operator];\n \n         find_pre_post_exprs(fcx, args, e.id);\n         /* see if the call has any constraints on its type */\n@@ -377,12 +377,10 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       }\n       expr_rec(fields, maybe_base) {\n         let es = field_exprs(fields);\n-        alt maybe_base { none. {/* no-op */ } some(b) { es += ~[b]; } }\n+        alt maybe_base { none. {/* no-op */ } some(b) { es += [b]; } }\n         find_pre_post_exprs(fcx, es, e.id);\n       }\n-      expr_tup(elts) {\n-        find_pre_post_exprs(fcx, elts, e.id);\n-      }\n+      expr_tup(elts) { find_pre_post_exprs(fcx, elts, e.id); }\n       expr_copy(a) {\n         find_pre_post_expr(fcx, a);\n         copy_pre_post(fcx.ccx, e.id, a);\n@@ -394,7 +392,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         /* Different from expr_assign in that the lhs *must*\n            already be initialized */\n \n-        find_pre_post_exprs(fcx, ~[lhs, rhs], e.id);\n+        find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n         forget_in_postcond_still_init(fcx, e.id, lhs.id);\n       }\n       expr_lit(_) { clear_pp(expr_pp(fcx.ccx, e)); }\n@@ -426,12 +424,11 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n             find_pre_post_expr(fcx, l);\n             find_pre_post_expr(fcx, r);\n             let overall_pre =\n-                seq_preconds(fcx,\n-                             ~[expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]);\n+                seq_preconds(fcx, [expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]);\n             set_precondition(node_id_to_ts_ann(fcx.ccx, e.id), overall_pre);\n             set_postcondition(node_id_to_ts_ann(fcx.ccx, e.id),\n                               expr_postcond(fcx.ccx, l));\n-        } else { find_pre_post_exprs(fcx, ~[l, r], e.id); }\n+        } else { find_pre_post_exprs(fcx, [l, r], e.id); }\n       }\n       expr_unary(_, operand) {\n         find_pre_post_expr(fcx, operand);\n@@ -446,8 +443,8 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         find_pre_post_block(fcx, body);\n         set_pre_and_post(fcx.ccx, e.id,\n                          seq_preconds(fcx,\n-                                      ~[expr_pp(fcx.ccx, test),\n-                                        block_pp(fcx.ccx, body)]),\n+                                      [expr_pp(fcx.ccx, test),\n+                                       block_pp(fcx.ccx, body)]),\n                          intersect_states(expr_postcond(fcx.ccx, test),\n                                           block_postcond(fcx.ccx, body)));\n       }\n@@ -456,8 +453,8 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         find_pre_post_expr(fcx, test);\n         let loop_postcond =\n             seq_postconds(fcx,\n-                          ~[block_postcond(fcx.ccx, body),\n-                            expr_postcond(fcx.ccx, test)]);\n+                          [block_postcond(fcx.ccx, body),\n+                           expr_postcond(fcx.ccx, test)]);\n         /* conservative approximation: if the body\n            could break or cont, the test may never be executed */\n \n@@ -466,8 +463,8 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         }\n         set_pre_and_post(fcx.ccx, e.id,\n                          seq_preconds(fcx,\n-                                      ~[block_pp(fcx.ccx, body),\n-                                        expr_pp(fcx.ccx, test)]),\n+                                      [block_pp(fcx.ccx, body),\n+                                       expr_pp(fcx.ccx, test)]),\n                          loop_postcond);\n       }\n       expr_for(d, index, body) {\n@@ -476,18 +473,18 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       expr_for_each(d, index, body) {\n         find_pre_post_loop(fcx, d, index, body, e.id);\n       }\n-      expr_index(val, sub) { find_pre_post_exprs(fcx, ~[val, sub], e.id); }\n+      expr_index(val, sub) { find_pre_post_exprs(fcx, [val, sub], e.id); }\n       expr_alt(ex, alts) {\n         find_pre_post_expr(fcx, ex);\n         fn do_an_alt(fcx: &fn_ctxt, an_alt: &arm) -> pre_and_post {\n             find_pre_post_block(fcx, an_alt.body);\n             ret block_pp(fcx.ccx, an_alt.body);\n         }\n-        let alt_pps = ~[];\n-        for a: arm in alts { alt_pps += ~[do_an_alt(fcx, a)]; }\n+        let alt_pps = [];\n+        for a: arm in alts { alt_pps += [do_an_alt(fcx, a)]; }\n         fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, pp: &pre_and_post,\n                       next: &pre_and_post) -> pre_and_post {\n-            union(pp.precondition, seq_preconds(fcx, ~[antec, next]));\n+            union(pp.precondition, seq_preconds(fcx, [antec, next]));\n             intersect(pp.postcondition, next.postcondition);\n             ret pp;\n         }\n@@ -536,22 +533,20 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       }\n \n \n+\n       expr_bind(operator, maybe_args) {\n-        let args = ~[];\n+        let args = [];\n         let cmodes = callee_modes(fcx, operator.id);\n-        let modes = ~[];\n+        let modes = [];\n         let i = 0;\n         for expr_opt: option::t<@expr> in maybe_args {\n             alt expr_opt {\n               none. {/* no-op */ }\n-              some(expr) {\n-                modes += ~[cmodes.(i)];\n-                args += ~[expr];\n-              }\n+              some(expr) { modes += [cmodes[i]]; args += [expr]; }\n             }\n             i += 1;\n         }\n-        args += ~[operator]; /* ??? order of eval? */\n+        args += [operator]; /* ??? order of eval? */\n         forget_args_moved_in(fcx, e, modes, args);\n         find_pre_post_exprs(fcx, args, e.id);\n       }\n@@ -567,7 +562,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n           none. { clear_pp(expr_pp(fcx.ccx, e)); }\n         }\n       }\n-      expr_uniq(sub) { find_pre_post_exprs(fcx, ~[sub], e.id); }\n+      expr_uniq(sub) { find_pre_post_exprs(fcx, [sub], e.id); }\n     }\n }\n \n@@ -603,23 +598,25 @@ fn find_pre_post_stmt(fcx: &fn_ctxt, s: &stmt) {\n                         /* FIXME: This won't be necessary when typestate\n                         works well enough for pat_bindings to return a\n                         refinement-typed thing. */\n-                        let ident = alt pat.node {\n-                          pat_bind(n) { n }\n-                          _ {\n-                            fcx.ccx.tcx.sess.span_bug(pat.span,\n-                                                      \"Impossible LHS\");\n-                          }\n-                        };\n+                        let ident =\n+                            alt pat.node {\n+                              pat_bind(n) { n }\n+                              _ {\n+                                fcx.ccx.tcx.sess.span_bug(pat.span,\n+                                                          \"Impossible LHS\");\n+                              }\n+                            };\n                         alt p {\n                           some(p) {\n                             copy_in_postcond(fcx, id,\n                                              {ident: ident, node: pat.id},\n                                              {ident:\n-                                              path_to_ident(fcx.ccx.tcx, p),\n+                                                  path_to_ident(fcx.ccx.tcx,\n+                                                                p),\n                                               node: an_init.expr.id},\n                                              op_to_oper_ty(an_init.op));\n                           }\n-                          none. {}\n+                          none. { }\n                         }\n                         gen(fcx, id, ninit(pat.id, ident));\n                     }\n@@ -645,10 +642,9 @@ fn find_pre_post_stmt(fcx: &fn_ctxt, s: &stmt) {\n                             fcx.ccx.tcx.sess.span_bug(pat.span,\n                                                       \"Impossible LHS\");\n                           }\n-                        };\n+                        }\n                     }\n-                    copy_pre_post_(fcx.ccx, id,\n-                                   prev_pp.precondition,\n+                    copy_pre_post_(fcx.ccx, id, prev_pp.precondition,\n                                    prev_pp.postcondition);\n                   }\n                   none. {\n@@ -694,33 +690,33 @@ fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n     let nv = num_constraints(fcx.enclosing);\n     fn do_one_(fcx: fn_ctxt, s: &@stmt) {\n         find_pre_post_stmt(fcx, *s);\n-/*\n-        log_err \"pre_post for stmt:\";\n-        log_stmt_err(*s);\n-        log_err \"is:\";\n-        log_pp_err(stmt_pp(fcx.ccx, *s));\n-*/\n+        /*\n+                log_err \"pre_post for stmt:\";\n+                log_stmt_err(*s);\n+                log_err \"is:\";\n+                log_pp_err(stmt_pp(fcx.ccx, *s));\n+        */\n     }\n     for s: @stmt in b.node.stmts { do_one_(fcx, s); }\n     fn do_inner_(fcx: fn_ctxt, e: &@expr) { find_pre_post_expr(fcx, e); }\n     let do_inner = bind do_inner_(fcx, _);\n     option::map::<@expr, ()>(do_inner, b.node.expr);\n \n-    let pps: [pre_and_post] = ~[];\n-    for s: @stmt in b.node.stmts { pps += ~[stmt_pp(fcx.ccx, *s)]; }\n+    let pps: [pre_and_post] = [];\n+    for s: @stmt in b.node.stmts { pps += [stmt_pp(fcx.ccx, *s)]; }\n     alt b.node.expr {\n       none. {/* no-op */ }\n-      some(e) { pps += ~[expr_pp(fcx.ccx, e)]; }\n+      some(e) { pps += [expr_pp(fcx.ccx, e)]; }\n     }\n \n     let block_precond = seq_preconds(fcx, pps);\n \n-    let postconds = ~[];\n-    for pp: pre_and_post in pps { postconds += ~[get_post(pp)]; }\n+    let postconds = [];\n+    for pp: pre_and_post in pps { postconds += [get_post(pp)]; }\n \n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n-    postconds += ~[block_precond];\n+    postconds += [block_precond];\n \n     let block_postcond = empty_poststate(nv);\n     /* conservative approximation */"}, {"sha": "3d8d8767ceb0c5b723d2abd08122bd70289faaf6", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 89, "deletions": 98, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -30,9 +30,9 @@ import util::common::log_stmt_err;\n import util::common::log_expr_err;\n \n fn handle_move_or_copy(fcx: &fn_ctxt, post: &poststate, rhs_path: &path,\n-      rhs_id: &node_id, instlhs: &inst, init_op: &init_op) {\n+                       rhs_id: &node_id, instlhs: &inst, init_op: &init_op) {\n     let rhs_d = local_node_id_to_def_id(fcx, rhs_id);\n-    alt (rhs_d) {\n+    alt rhs_d {\n       some(rhsid) {\n         // RHS is a local var\n         let instrhs =\n@@ -46,19 +46,19 @@ fn handle_move_or_copy(fcx: &fn_ctxt, post: &poststate, rhs_path: &path,\n     }\n }\n \n-fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &[binding])\n-    -> {changed: bool, post: poststate} {\n+fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &[binding]) ->\n+   {changed: bool, post: poststate} {\n     let changed = false;\n     let post = tritv_clone(pres);\n-    for b:binding in bindings {\n-        alt (b.rhs) {\n+    for b: binding in bindings {\n+        alt b.rhs {\n           some(an_init) {\n             // an expression, with or without a destination\n-            changed |= find_pre_post_state_expr(fcx, post, an_init.expr)\n-                || changed;\n+            changed |=\n+                find_pre_post_state_expr(fcx, post, an_init.expr) || changed;\n             post = tritv_clone(expr_poststate(fcx.ccx, an_init.expr));\n             for i: inst in b.lhs {\n-                alt (an_init.expr.node) {\n+                alt an_init.expr.node {\n                   expr_path(p) {\n                     handle_move_or_copy(fcx, post, p, an_init.expr.id, i,\n                                         an_init.op);\n@@ -67,6 +67,7 @@ fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &[binding])\n                 }\n                 set_in_poststate_ident(fcx, i.node, i.ident, post);\n             }\n+\n             // Forget the RHS if we just moved it.\n             if an_init.op == init_move {\n                 forget_in_poststate(fcx, post, an_init.expr.id);\n@@ -168,18 +169,17 @@ fn find_pre_post_state_call(fcx: &fn_ctxt, pres: &prestate, a: &@expr,\n     // FIXME: This could be a typestate constraint\n     if vec::len(bs) != vec::len(ops) {\n         fcx.ccx.tcx.sess.span_bug(a.span,\n-                                  #fmt(\"mismatched arg lengths: \\\n+                                  #fmt[\"mismatched arg lengths: \\\n                                         %u exprs vs. %u ops\",\n-                                       vec::len(bs), vec::len(ops)));\n+                                       vec::len(bs), vec::len(ops)]);\n     }\n-    ret find_pre_post_state_exprs(fcx, expr_poststate(fcx.ccx, a), id,\n-                                  ops, bs, cf)\n-            || changed;\n+    ret find_pre_post_state_exprs(fcx, expr_poststate(fcx.ccx, a), id, ops,\n+                                  bs, cf) || changed;\n }\n \n fn find_pre_post_state_exprs(fcx: &fn_ctxt, pres: &prestate, id: node_id,\n-                             ops: &[init_op], es: &[@expr],\n-                             cf: controlflow) -> bool {\n+                             ops: &[init_op], es: &[@expr], cf: controlflow)\n+   -> bool {\n     let rs = seq_states(fcx, pres, anon_bindings(ops, es));\n     let changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n     /* if this is a failing call, it sets everything as initialized */\n@@ -315,8 +315,8 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n       expr_vec(elts, _) {\n         ret find_pre_post_state_exprs(fcx, pres, e.id,\n                                       vec::init_elt(init_assign,\n-                                                     vec::len(elts)),\n-                                      elts, return);\n+                                                    vec::len(elts)), elts,\n+                                      return);\n       }\n       expr_call(operator, operands) {\n         ret find_pre_post_state_call(fcx, pres, operator, e.id,\n@@ -325,17 +325,14 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n                                      controlflow_expr(fcx.ccx, operator));\n       }\n       expr_bind(operator, maybe_args) {\n-        let args = ~[];\n+        let args = [];\n         let callee_ops = callee_arg_init_ops(fcx, operator.id);\n-        let ops = ~[];\n+        let ops = [];\n         let i = 0;\n         for a_opt: option::t<@expr> in maybe_args {\n             alt a_opt {\n               none. {/* no-op */ }\n-              some(a) {\n-                ops += ~[callee_ops.(i)];\n-                args += ~[a];\n-              }\n+              some(a) { ops += [callee_ops[i]]; args += [a]; }\n             }\n             i += 1;\n         }\n@@ -366,9 +363,8 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n         let changed =\n             find_pre_post_state_exprs(fcx, pres, e.id,\n                                       vec::init_elt(init_assign,\n-                                                     vec::len(fields)),\n-                                      field_exprs(fields),\n-                                      return);\n+                                                    vec::len(fields)),\n+                                      field_exprs(fields), return);\n         alt maybe_base {\n           none. {/* do nothing */ }\n           some(base) {\n@@ -383,12 +379,10 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n       expr_tup(elts) {\n         ret find_pre_post_state_exprs(fcx, pres, e.id,\n                                       vec::init_elt(init_assign,\n-                                                     vec::len(elts)),\n-                                      elts, return);\n-      }\n-      expr_copy(a) {\n-        ret find_pre_post_state_sub(fcx, pres, a, e.id, none);\n+                                                    vec::len(elts)), elts,\n+                                      return);\n       }\n+      expr_copy(a) { ret find_pre_post_state_sub(fcx, pres, a, e.id, none); }\n       expr_move(lhs, rhs) {\n         ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id, oper_move);\n       }\n@@ -405,14 +399,14 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n         /* normally, everything is true if execution continues after\n            a ret expression (since execution never continues locally\n            after a ret expression */\n-// FIXME should factor this out\n+        // FIXME should factor this out\n         let post = false_postcond(num_constrs);\n         // except for the \"diverges\" bit...\n         kill_poststate_(fcx, fcx.enclosing.i_diverge, post);\n \n         set_poststate_ann(fcx.ccx, e.id, post);\n \n-       alt maybe_ret_val {\n+        alt maybe_ret_val {\n           none. {/* do nothing */ }\n           some(ret_val) {\n             changed |= find_pre_post_state_expr(fcx, pres, ret_val);\n@@ -565,14 +559,12 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n         woo! */\n         let post = false_postcond(num_constrs);\n         alt fcx.enclosing.cf {\n-          noreturn. {\n-            kill_poststate_(fcx, ninit(fcx.id, fcx.name), post);\n-          }\n-          _ {}\n+          noreturn. { kill_poststate_(fcx, ninit(fcx.id, fcx.name), post); }\n+          _ { }\n         }\n         ret set_prestate_ann(fcx.ccx, e.id, pres) |\n-            set_poststate_ann(fcx.ccx, e.id, post)\n-                | alt maybe_fail_val {\n+                set_poststate_ann(fcx.ccx, e.id, post) |\n+                alt maybe_fail_val {\n                   none. { false }\n                   some(fail_val) {\n                     find_pre_post_state_expr(fcx, pres, fail_val)\n@@ -603,74 +595,73 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n     }\n }\n \n-fn find_pre_post_state_stmt(fcx: &fn_ctxt, pres: &prestate, s: @stmt)\n-    -> bool {\n+fn find_pre_post_state_stmt(fcx: &fn_ctxt, pres: &prestate, s: @stmt) ->\n+   bool {\n     let stmt_ann = stmt_to_ann(fcx.ccx, *s);\n \n-/*\n-    log_err (\"[\" + fcx.name + \"]\");\n-    log_err \"*At beginning: stmt = \";\n-    log_stmt_err(*s);\n-    log_err \"*prestate = \";\n-    log_tritv_err(fcx, stmt_ann.states.prestate);\n-    log_err \"*poststate =\";\n-    log_tritv_err(fcx, stmt_ann.states.poststate);\n-    log_err \"pres = \";\n-    log_tritv_err(fcx, pres);\n-*/\n-\n-    alt (s.node) {\n+    /*\n+        log_err (\"[\" + fcx.name + \"]\");\n+        log_err \"*At beginning: stmt = \";\n+        log_stmt_err(*s);\n+        log_err \"*prestate = \";\n+        log_tritv_err(fcx, stmt_ann.states.prestate);\n+        log_err \"*poststate =\";\n+        log_tritv_err(fcx, stmt_ann.states.poststate);\n+        log_err \"pres = \";\n+        log_tritv_err(fcx, pres);\n+    */\n+\n+    alt s.node {\n       stmt_decl(adecl, id) {\n-        alt (adecl.node) {\n+        alt adecl.node {\n           decl_local(alocals) {\n             set_prestate(stmt_ann, pres);\n-            let c_and_p = seq_states(fcx, pres,\n-                                     locals_to_bindings(alocals));\n+            let c_and_p = seq_states(fcx, pres, locals_to_bindings(alocals));\n             /* important to do this in one step to ensure\n             termination (don't want to set changed to true\n             for intermediate changes) */\n \n-            let changed = (set_poststate(stmt_ann, c_and_p.post)\n-                           | c_and_p.changed);\n+            let changed =\n+                set_poststate(stmt_ann, c_and_p.post) | c_and_p.changed;\n \n-/*\n-                log_err \"Summary: stmt = \";\n-                log_stmt_err(*s);\n-                log_err \"prestate = \";\n-                log_tritv_err(fcx, stmt_ann.states.prestate);\n-                log_err \"poststate =\";\n-                log_tritv_err(fcx, stmt_ann.states.poststate);\n-                log_err \"changed =\";\n-                log_err changed;\n-*/\n+            /*\n+                            log_err \"Summary: stmt = \";\n+                            log_stmt_err(*s);\n+                            log_err \"prestate = \";\n+                            log_tritv_err(fcx, stmt_ann.states.prestate);\n+                            log_err \"poststate =\";\n+                            log_tritv_err(fcx, stmt_ann.states.poststate);\n+                            log_err \"changed =\";\n+                            log_err changed;\n+            */\n \n             ret changed;\n           }\n           decl_item(an_item) {\n-            ret set_prestate(stmt_ann, pres) |\n-                set_poststate(stmt_ann, pres);\n+            ret set_prestate(stmt_ann, pres) | set_poststate(stmt_ann, pres);\n             /* the outer visitor will recurse into the item */\n           }\n         }\n       }\n       stmt_expr(ex, _) {\n-        let changed = find_pre_post_state_expr(fcx, pres, ex) |\n+        let changed =\n+            find_pre_post_state_expr(fcx, pres, ex) |\n                 set_prestate(stmt_ann, expr_prestate(fcx.ccx, ex)) |\n                 set_poststate(stmt_ann, expr_poststate(fcx.ccx, ex));\n \n-/*\n-       log_err \"Finally:\";\n-          log_stmt_err(*s);\n-          log_err(\"prestate = \");\n-          //              log_err(bitv::to_str(stmt_ann.states.prestate));\n-          log_tritv_err(fcx, stmt_ann.states.prestate);\n-          log_err(\"poststate =\");\n-          //   log_err(bitv::to_str(stmt_ann.states.poststate));\n-          log_tritv_err(fcx, stmt_ann.states.poststate);\n-          log_err(\"changed =\");\n-*/\n+        /*\n+        log_err \"Finally:\";\n+        log_stmt_err(*s);\n+        log_err(\"prestate = \");\n+        log_err(bitv::to_str(stmt_ann.states.prestate));\n+        log_tritv_err(fcx, stmt_ann.states.prestate);\n+        log_err(\"poststate =\");\n+        log_err(bitv::to_str(stmt_ann.states.poststate));\n+        log_tritv_err(fcx, stmt_ann.states.poststate);\n+        log_err(\"changed =\");\n+        */\n \n-          ret changed;\n+        ret changed;\n       }\n       _ { ret false; }\n     }\n@@ -706,18 +697,18 @@ fn find_pre_post_state_block(fcx: &fn_ctxt, pres0: &prestate, b: &blk) ->\n     set_poststate_ann(fcx.ccx, b.node.id, post);\n \n \n-/*\n-    log_err \"For block:\";\n-    log_block_err(b);\n-    log_err \"poststate = \";\n-    log_states_err(block_states(fcx.ccx, b));\n-    log_err \"pres0:\";\n-    log_tritv_err(fcx, pres0);\n-    log_err \"post:\";\n-    log_tritv_err(fcx, post);\n-    log_err \"changed = \";\n-    log_err changed;\n-*/\n+    /*\n+        log_err \"For block:\";\n+        log_block_err(b);\n+        log_err \"poststate = \";\n+        log_states_err(block_states(fcx.ccx, b));\n+        log_err \"pres0:\";\n+        log_tritv_err(fcx, pres0);\n+        log_err \"post:\";\n+        log_tritv_err(fcx, post);\n+        log_err \"changed = \";\n+        log_err changed;\n+    */\n \n     ret changed;\n }\n@@ -731,7 +722,7 @@ fn find_pre_post_state_fn(fcx: &fn_ctxt, f: &_fn) -> bool {\n \n     // Arguments start out initialized\n     let block_pre = block_prestate(fcx.ccx, f.body);\n-    for a:arg in f.decl.inputs {\n+    for a: arg in f.decl.inputs {\n         set_in_prestate_constr(fcx, ninit(a.id, a.ident), block_pre);\n     }\n "}, {"sha": "77e3575c175bfe8e3944bbec6664d6d0e3f40503", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -54,17 +54,19 @@ fn trit_minus(a: trit, b: trit) -> trit {\n         alt b {\n           ttrue. { dont_care }\n           tfalse. { ttrue }\n-           /* internally contradictory, but\n-              I guess it'll get flagged? */\n-           dont_care. {\n+\n+          /* internally contradictory, but\n+             I guess it'll get flagged? */\n+          dont_care. {\n             ttrue\n           }\n         }\n       }\n       tfalse. {\n         alt b {\n           ttrue. { tfalse }\n-           /* see above comment */\n+\n+          /* see above comment */\n           _ {\n             tfalse\n           }\n@@ -80,7 +82,8 @@ fn trit_or(a: trit, b: trit) -> trit {\n       tfalse. {\n         alt b {\n           ttrue. { dont_care }\n-           /* FIXME: ?????? */\n+\n+          /* FIXME: ?????? */\n           _ {\n             tfalse\n           }\n@@ -97,15 +100,18 @@ fn trit_or(a: trit, b: trit) -> trit {\n fn trit_and(a: trit, b: trit) -> trit {\n     alt a {\n       dont_care. { b }\n-       // also seems wrong for case b = ttrue\n+\n+      // also seems wrong for case b = ttrue\n       ttrue. {\n         alt b {\n           dont_care. { ttrue }\n-           // ??? Seems wrong\n+\n+          // ??? Seems wrong\n           ttrue. {\n             ttrue\n           }\n \n+\n           // false wins, since if something is uninit\n           // on one path, we care\n           // (Rationale: it's always safe to assume that\n@@ -117,6 +123,7 @@ fn trit_and(a: trit, b: trit) -> trit {\n         }\n       }\n \n+\n       // Rationale: if it's uninit on one path,\n       // we can consider it as uninit on all paths\n       tfalse. {\n@@ -180,7 +187,7 @@ fn tritv_get(v: &t, i: uint) -> trit {\n     let b1 = bitv::get(v.uncertain, i);\n     let b2 = bitv::get(v.val, i);\n     assert (!(b1 && b2));\n-    if b1 { dont_care } else if (b2) { ttrue } else { tfalse }\n+    if b1 { dont_care } else if b2 { ttrue } else { tfalse }\n }\n \n fn tritv_set(i: uint, v: &t, t: trit) -> bool {\n@@ -241,14 +248,14 @@ fn tritv_doesntcare(v: &t) -> bool {\n \n fn to_vec(v: &t) -> [uint] {\n     let i: uint = 0u;\n-    let rslt: [uint] = ~[];\n+    let rslt: [uint] = [];\n     while i < v.nbits {\n         rslt +=\n-            ~[alt tritv_get(v, i) {\n-                dont_care. { 2u }\n-                ttrue. { 1u }\n-                tfalse. { 0u }\n-              }];\n+            [alt tritv_get(v, i) {\n+               dont_care. { 2u }\n+               ttrue. { 1u }\n+               tfalse. { 0u }\n+             }];\n         i += 1u;\n     }\n     ret rslt;"}, {"sha": "c2594c98f2daa7f053bfb37151f1cd71feec688f", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 252, "deletions": 261, "changes": 513, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -207,13 +207,12 @@ type mt = {ty: t, mut: ast::mutability};\n type creader_cache = hashmap<{cnum: int, pos: uint, len: uint}, ty::t>;\n \n type ctxt =\n-\n     //        constr_table fn_constrs,\n+    // We need the ext_map just for printing the types of tags defined in\n+    // other crates. Once we get cnames back it should go.\n     @{ts: @type_store,\n       sess: session::session,\n       def_map: resolve::def_map,\n-      // We need the ext_map just for printing the types of tags defined in\n-      // other crates. Once we get cnames back it should go.\n       ext_map: resolve::ext_map,\n       node_types: node_type_table,\n       items: ast_map::map,\n@@ -460,7 +459,7 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<str>) -> @raw_t {\n       ty_istr. {/* no-op */ }\n       ty_type. {/* no-op */ }\n       ty_native(_) {/* no-op */ }\n-      ty_param(_,_) { has_params = true; }\n+      ty_param(_, _) { has_params = true; }\n       ty_var(_) { has_vars = true; }\n       ty_tag(_, tys) {\n         for tt: t in tys { derive_flags_t(cx, has_params, has_vars, tt); }\n@@ -475,9 +474,7 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<str>) -> @raw_t {\n         }\n       }\n       ty_tup(ts) {\n-        for tt in ts {\n-            derive_flags_t(cx, has_params, has_vars, tt);\n-        }\n+        for tt in ts { derive_flags_t(cx, has_params, has_vars, tt); }\n       }\n       ty_fn(_, args, tt, _, _) {\n         derive_flags_sig(cx, has_params, has_vars, args, tt);\n@@ -604,9 +601,8 @@ fn mk_type(_cx: &ctxt) -> t { ret idx_type; }\n fn mk_native(cx: &ctxt, did: &def_id) -> t { ret gen_ty(cx, ty_native(did)); }\n \n fn mk_iter_body_fn(cx: &ctxt, output: &t) -> t {\n-    ret mk_fn(cx, ast::proto_block,\n-              ~[{mode: ty::mo_alias(false), ty: output}],\n-              ty::mk_nil(cx), ast::return, ~[]);\n+    ret mk_fn(cx, ast::proto_block, [{mode: ty::mo_alias(false), ty: output}],\n+              ty::mk_nil(cx), ast::return, []);\n }\n \n // Returns the one-level-deep type structure of the given type.\n@@ -622,7 +618,7 @@ fn cname(cx: &ctxt, typ: &t) -> option::t<str> {\n \n \n // Type folds\n-type ty_walk = fn(t) ;\n+type ty_walk = fn(t);\n \n fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n     alt struct(cx, ty) {\n@@ -647,9 +643,7 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n       ty_rec(fields) {\n         for fl: field in fields { walk_ty(cx, walker, fl.mt.ty); }\n       }\n-      ty_tup(ts) {\n-        for tt in ts { walk_ty(cx, walker, tt); }\n-      }\n+      ty_tup(ts) { for tt in ts { walk_ty(cx, walker, tt); } }\n       ty_fn(proto, args, ret_ty, _, _) {\n         for a: arg in args { walk_ty(cx, walker, a.ty); }\n         walk_ty(cx, walker, ret_ty);\n@@ -668,20 +662,18 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n         walk_ty(cx, walker, sub);\n         for tp: t in tps { walk_ty(cx, walker, tp); }\n       }\n-      ty_constr(sub, _) {\n-        walk_ty(cx, walker, sub);\n-      }\n+      ty_constr(sub, _) { walk_ty(cx, walker, sub); }\n       ty_var(_) {/* no-op */ }\n-      ty_param(_,_) {/* no-op */ }\n+      ty_param(_, _) {/* no-op */ }\n       ty_uniq(sub) { walk_ty(cx, walker, sub); }\n     }\n     walker(ty);\n }\n \n tag fold_mode {\n-    fm_var(fn(int) -> t );\n-    fm_param(fn(uint,ast::kind) -> t );\n-    fm_general(fn(t) -> t );\n+    fm_var(fn(int) -> t);\n+    fm_param(fn(uint, ast::kind) -> t);\n+    fm_general(fn(t) -> t);\n }\n \n fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n@@ -717,77 +709,75 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n         ty = mk_vec(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n       ty_tag(tid, subtys) {\n-        let new_subtys: [t] = ~[];\n-        for subty: t in subtys { new_subtys += ~[fold_ty(cx, fld, subty)]; }\n+        let new_subtys: [t] = [];\n+        for subty: t in subtys { new_subtys += [fold_ty(cx, fld, subty)]; }\n         ty = copy_cname(cx, mk_tag(cx, tid, new_subtys), ty);\n       }\n       ty_rec(fields) {\n-        let new_fields: [field] = ~[];\n+        let new_fields: [field] = [];\n         for fl: field in fields {\n             let new_ty = fold_ty(cx, fld, fl.mt.ty);\n             let new_mt = {ty: new_ty, mut: fl.mt.mut};\n-            new_fields += ~[{ident: fl.ident, mt: new_mt}];\n+            new_fields += [{ident: fl.ident, mt: new_mt}];\n         }\n         ty = copy_cname(cx, mk_rec(cx, new_fields), ty);\n       }\n       ty_tup(ts) {\n-        let new_ts = ~[];\n-        for tt in ts {\n-            new_ts += ~[fold_ty(cx, fld, tt)];\n-        }\n+        let new_ts = [];\n+        for tt in ts { new_ts += [fold_ty(cx, fld, tt)]; }\n         ty = copy_cname(cx, mk_tup(cx, new_ts), ty);\n       }\n       ty_fn(proto, args, ret_ty, cf, constrs) {\n-        let new_args: [arg] = ~[];\n+        let new_args: [arg] = [];\n         for a: arg in args {\n             let new_ty = fold_ty(cx, fld, a.ty);\n-            new_args += ~[{mode: a.mode, ty: new_ty}];\n+            new_args += [{mode: a.mode, ty: new_ty}];\n         }\n         ty =\n             copy_cname(cx,\n                        mk_fn(cx, proto, new_args, fold_ty(cx, fld, ret_ty),\n                              cf, constrs), ty);\n       }\n       ty_native_fn(abi, args, ret_ty) {\n-        let new_args: [arg] = ~[];\n+        let new_args: [arg] = [];\n         for a: arg in args {\n             let new_ty = fold_ty(cx, fld, a.ty);\n-            new_args += ~[{mode: a.mode, ty: new_ty}];\n+            new_args += [{mode: a.mode, ty: new_ty}];\n         }\n         ty =\n             copy_cname(cx,\n                        mk_native_fn(cx, abi, new_args,\n                                     fold_ty(cx, fld, ret_ty)), ty);\n       }\n       ty_obj(methods) {\n-        let new_methods: [method] = ~[];\n+        let new_methods: [method] = [];\n         for m: method in methods {\n-            let new_args: [arg] = ~[];\n+            let new_args: [arg] = [];\n             for a: arg in m.inputs {\n-                new_args += ~[{mode: a.mode, ty: fold_ty(cx, fld, a.ty)}];\n+                new_args += [{mode: a.mode, ty: fold_ty(cx, fld, a.ty)}];\n             }\n             new_methods +=\n-                ~[{proto: m.proto,\n-                   ident: m.ident,\n-                   inputs: new_args,\n-                   output: fold_ty(cx, fld, m.output),\n-                   cf: m.cf,\n-                   constrs: m.constrs}];\n+                [{proto: m.proto,\n+                  ident: m.ident,\n+                  inputs: new_args,\n+                  output: fold_ty(cx, fld, m.output),\n+                  cf: m.cf,\n+                  constrs: m.constrs}];\n         }\n         ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n       }\n       ty_res(did, subty, tps) {\n-        let new_tps = ~[];\n-        for tp: t in tps { new_tps += ~[fold_ty(cx, fld, tp)]; }\n+        let new_tps = [];\n+        for tp: t in tps { new_tps += [fold_ty(cx, fld, tp)]; }\n         ty =\n             copy_cname(cx, mk_res(cx, did, fold_ty(cx, fld, subty), new_tps),\n                        ty);\n       }\n       ty_var(id) {\n         alt fld { fm_var(folder) { ty = folder(id); } _ {/* no-op */ } }\n       }\n-      ty_param(id,k) {\n-        alt fld { fm_param(folder) { ty = folder(id,k); } _ {/* no-op */ } }\n+      ty_param(id, k) {\n+        alt fld { fm_param(folder) { ty = folder(id, k); } _ {/* no-op */ } }\n       }\n     }\n \n@@ -867,7 +857,10 @@ fn type_is_str(cx: &ctxt, ty: &t) -> bool {\n fn sequence_is_interior(cx: &ctxt, ty: &t) -> bool {\n     alt struct(cx, ty) {\n \n-      ty::ty_str. { ret false; }\n+\n+      ty::ty_str. {\n+        ret false;\n+      }\n       ty::ty_vec(_) { ret true; }\n       ty::ty_istr. { ret true; }\n       _ { cx.sess.bug(\"sequence_is_interior called on non-sequence type\"); }\n@@ -895,8 +888,8 @@ fn type_is_tup_like(cx: &ctxt, ty: &t) -> bool {\n \n fn get_element_type(cx: &ctxt, ty: &t, i: uint) -> t {\n     alt struct(cx, ty) {\n-      ty_rec(flds) { ret flds.(i).mt.ty; }\n-      ty_tup(ts) { ret ts.(i); }\n+      ty_rec(flds) { ret flds[i].mt.ty; }\n+      ty_tup(ts) { ret ts[i]; }\n       _ {\n         cx.sess.bug(\"get_element_type called on type \" + ty_to_str(cx, ty) +\n                         \" - expected a \\\n@@ -948,6 +941,7 @@ fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n     let result = false;\n     alt struct(cx, ty) {\n \n+\n       // scalar types\n       ty_nil. {\n         /* no-op */\n@@ -964,27 +958,19 @@ fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n       ty_native(_) {/* no-op */ }\n       ty_rec(flds) {\n         for f: field in flds {\n-            if type_has_pointers(cx, f.mt.ty) {\n-                result = true;\n-                break;\n-            }\n+            if type_has_pointers(cx, f.mt.ty) { result = true; break; }\n         }\n       }\n       ty_tup(elts) {\n-        for m in elts {\n-            if type_has_pointers(cx, m) { result = true; }\n-        }\n+        for m in elts { if type_has_pointers(cx, m) { result = true; } }\n       }\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n         for variant: variant_info in variants {\n             for aty: t in variant.args {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = substitute_type_params(cx, tps, aty);\n-                if type_has_pointers(cx, arg_ty) {\n-                    result = true;\n-                    break;\n-                }\n+                if type_has_pointers(cx, arg_ty) { result = true; break; }\n             }\n             if result { break; }\n         }\n@@ -1002,9 +988,9 @@ fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n \n fn type_needs_drop(cx: &ctxt, ty: &t) -> bool {\n     ret alt struct(cx, ty) {\n-      ty_res(_, _, _) { true }\n-      _ { type_has_pointers(cx, ty) }\n-    };\n+          ty_res(_, _, _) { true }\n+          _ { type_has_pointers(cx, ty) }\n+        };\n }\n \n fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n@@ -1020,42 +1006,52 @@ fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n \n     alt struct(cx, ty) {\n \n+\n       // Scalar types are unique-kind, no substructure.\n-      ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_uint. | ty_float.\n-      | ty_machine(_) | ty_char. | ty_native(_) {\n+      ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_uint. | ty_float. |\n+      ty_machine(_) | ty_char. | ty_native(_) {\n         // no-op\n       }\n \n+\n       // A handful of other built-in are unique too.\n       ty_type. | ty_istr. | ty_native_fn(_, _, _) {\n         // no-op\n       }\n \n+\n       // Those things with refcounts-to-interior are just shared.\n       ty_str. {\n         result = kind_shared;\n       }\n \n+\n       // FIXME: obj is broken for now, since we aren't asserting\n       // anything about its fields.\n-      ty_obj(_) { result = kind_shared; }\n+      ty_obj(_) {\n+        result = kind_shared;\n+      }\n+\n \n       // FIXME: the environment capture mode is not fully encoded\n       // here yet, leading to weirdness around closure.\n       ty_fn(proto, _, _, _, _) {\n-        result = alt proto {\n-          ast::proto_block. { ast::kind_pinned }\n-          ast::proto_closure. { ast::kind_shared }\n-          _ { ast::kind_unique }\n-        }\n+        result =\n+            alt proto {\n+              ast::proto_block. { ast::kind_pinned }\n+              ast::proto_closure. { ast::kind_shared }\n+              _ { ast::kind_unique }\n+            }\n       }\n \n+\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n       ty_box(mt) {\n         result = ast::kind_shared;\n       }\n \n+\n       // Pointers and unique boxes / vecs raise pinned to shared,\n       // otherwise pass through their pointee kind.\n       ty_ptr(tm) | ty_vec(tm) {\n@@ -1064,13 +1060,15 @@ fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n         result = kind::lower_kind(result, k);\n       }\n \n+\n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n         for f: field in flds {\n             result = kind::lower_kind(result, type_kind(cx, f.mt.ty));\n             if result == ast::kind_pinned { break; }\n         }\n       }\n+\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n         for ty: t in tys {\n@@ -1079,6 +1077,7 @@ fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n         }\n       }\n \n+\n       // Tags lower to the lowest of their variants.\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1093,27 +1092,34 @@ fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n         }\n       }\n \n+\n       // Resources are always pinned.\n       ty_res(did, inner, tps) {\n         result = ast::kind_pinned;\n       }\n \n-      ty_var(_) { fail; }\n \n-      ty_param(_,k) {\n+      ty_var(_) {\n+        fail;\n+      }\n+\n+\n+      ty_param(_, k) {\n         result = kind::lower_kind(result, k);\n       }\n \n+\n       ty_constr(t, _) {\n         result = type_kind(cx, t);\n       }\n \n-        _ {\n-            cx.sess.bug(\"missed case: \" + ty_to_str(cx, ty));\n-        }\n \n+      _ {\n+        cx.sess.bug(\"missed case: \" + ty_to_str(cx, ty));\n+      }\n     }\n \n+\n     cx.kind_cache.insert(ty, result);\n     ret result;\n }\n@@ -1140,7 +1146,7 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n       ty_tag(_, subtys) {\n         let i = 0u;\n         while i < vec::len::<t>(subtys) {\n-            if type_has_dynamic_size(cx, subtys.(i)) { ret true; }\n+            if type_has_dynamic_size(cx, subtys[i]) { ret true; }\n             i += 1u;\n         }\n         ret false;\n@@ -1151,15 +1157,13 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n       ty_rec(fields) {\n         let i = 0u;\n         while i < vec::len::<field>(fields) {\n-            if type_has_dynamic_size(cx, fields.(i).mt.ty) { ret true; }\n+            if type_has_dynamic_size(cx, fields[i].mt.ty) { ret true; }\n             i += 1u;\n         }\n         ret false;\n       }\n       ty_tup(ts) {\n-        for tt in ts {\n-            if type_has_dynamic_size(cx, tt) { ret true; }\n-        }\n+        for tt in ts { if type_has_dynamic_size(cx, tt) { ret true; } }\n         ret false;\n       }\n       ty_fn(_, _, _, _, _) { ret false; }\n@@ -1170,7 +1174,7 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n         ret type_has_dynamic_size(cx, sub);\n       }\n       ty_var(_) { fail \"ty_var in type_has_dynamic_size()\"; }\n-      ty_param(_,_) { ret true; }\n+      ty_param(_, _) { ret true; }\n       ty_type. { ret false; }\n       ty_native(_) { ret false; }\n       ty_uniq(_) { ret false; }\n@@ -1242,6 +1246,7 @@ fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n       ty_istr. { result = true; }\n \n \n+\n       // scalar types\n       ty_nil. {\n         result = false;\n@@ -1257,6 +1262,7 @@ fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n       ty_native(_) { result = false; }\n \n \n+\n       // boxed types\n       ty_str. {\n         result = false;\n@@ -1267,6 +1273,7 @@ fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n       ty_obj(_) { result = false; }\n \n \n+\n       // structural types\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1284,94 +1291,93 @@ fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n         }\n       }\n       ty_tup(elts) {\n-        for m in elts {\n-            if type_owns_heap_mem(cx, m) { result = true; }\n-        }\n+        for m in elts { if type_owns_heap_mem(cx, m) { result = true; } }\n       }\n       ty_res(_, inner, tps) {\n         result =\n             type_owns_heap_mem(cx, substitute_type_params(cx, tps, inner));\n       }\n \n+\n       ty_ptr(_) {\n         result = false;\n       }\n       ty_var(_) { fail \"ty_var in type_owns_heap_mem\"; }\n-      ty_param(_,_) { result = false; }\n+      ty_param(_, _) { result = false; }\n     }\n \n     cx.owns_heap_mem_cache.insert(ty, result);\n     ret result;\n }\n \n // Whether a type is Plain Old Data (i.e. can be safely memmoved).\n-fn type_is_pod(cx : &ctxt, ty : &t) -> bool {\n+fn type_is_pod(cx: &ctxt, ty: &t) -> bool {\n     let result = true;\n     alt struct(cx, ty) {\n-        // Scalar types\n-        ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_float. | ty_uint. |\n-        ty_machine(_) | ty_char. | ty_type. | ty_native(_) | ty_ptr(_) {\n-            result = true;\n-        }\n \n-        // Boxed types\n-        ty_str. | ty_istr. | ty_box(_) | ty_vec(_) |\n-        ty_fn(_,_,_,_,_) | ty_native_fn(_,_,_) | ty_obj(_) { result = false; }\n+      // Scalar types\n+      ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_float. | ty_uint. |\n+      ty_machine(_) | ty_char. | ty_type. | ty_native(_) | ty_ptr(_) {\n+        result = true;\n+      }\n \n-        // Structural types\n-        ty_tag(did, tps) {\n-            let variants = tag_variants(cx, did);\n-            for variant : variant_info in variants {\n-                let tup_ty = mk_tup(cx, variant.args);\n \n-                // Perform any type parameter substitutions.\n-                tup_ty = substitute_type_params(cx, tps, tup_ty);\n-                if !type_is_pod(cx, tup_ty) { result = false; }\n-            }\n-        }\n-        ty_rec(flds) {\n-            for f : field in flds {\n-                if !type_is_pod(cx, f.mt.ty) { result = false; }\n-            }\n-        }\n-        ty_tup(elts) {\n-            for elt in elts {\n-                if !type_is_pod(cx, elt) { result = false; }\n-            }\n+      // Boxed types\n+      ty_str. | ty_istr. | ty_box(_) | ty_vec(_) | ty_fn(_, _, _, _, _) |\n+      ty_native_fn(_, _, _) | ty_obj(_) {\n+        result = false;\n+      }\n+\n+\n+      // Structural types\n+      ty_tag(did, tps) {\n+        let variants = tag_variants(cx, did);\n+        for variant: variant_info in variants {\n+            let tup_ty = mk_tup(cx, variant.args);\n+\n+            // Perform any type parameter substitutions.\n+            tup_ty = substitute_type_params(cx, tps, tup_ty);\n+            if !type_is_pod(cx, tup_ty) { result = false; }\n         }\n-        ty_res(_, inner, tps) {\n-            result = type_is_pod(cx,\n-                substitute_type_params(cx, tps, inner));\n+      }\n+      ty_rec(flds) {\n+        for f: field in flds {\n+            if !type_is_pod(cx, f.mt.ty) { result = false; }\n         }\n-        ty_constr(subt, _) { result = type_is_pod(cx, subt); }\n+      }\n+      ty_tup(elts) {\n+        for elt in elts { if !type_is_pod(cx, elt) { result = false; } }\n+      }\n+      ty_res(_, inner, tps) {\n+        result = type_is_pod(cx, substitute_type_params(cx, tps, inner));\n+      }\n+      ty_constr(subt, _) { result = type_is_pod(cx, subt); }\n+\n \n-        ty_var(_) { fail \"ty_var in type_is_pod\"; }\n-        ty_param(_,_) { result = false; }\n+      ty_var(_) {\n+        fail \"ty_var in type_is_pod\";\n+      }\n+      ty_param(_, _) { result = false; }\n     }\n \n     ret result;\n }\n \n fn type_param(cx: &ctxt, ty: &t) -> option::t<uint> {\n     alt struct(cx, ty) {\n-      ty_param(id,_) { ret some(id); }\n+      ty_param(id, _) { ret some(id); }\n       _ {/* fall through */ }\n     }\n     ret none;\n }\n \n // Returns a vec of all the type variables\n // occurring in t. It may contain duplicates.\n-fn vars_in_type(cx:&ctxt, ty: &t) -> [int] {\n-    fn collect_var(cx:&ctxt, vars: &@mutable [int], ty: t) {\n-        alt struct(cx, ty) {\n-          ty_var(v) {\n-            *vars += ~[v];\n-          }\n-          _ {}\n-        }\n+fn vars_in_type(cx: &ctxt, ty: &t) -> [int] {\n+    fn collect_var(cx: &ctxt, vars: &@mutable [int], ty: t) {\n+        alt struct(cx, ty) { ty_var(v) { *vars += [v]; } _ { } }\n     }\n-    let rslt: @mutable [int] = @mutable (~[]);\n+    let rslt: @mutable [int] = @mutable [];\n     walk_ty(cx, bind collect_var(cx, rslt, _), ty);\n     // Works because of a \"convenient\" bug that lets us\n     // return a mutable vec as if it's immutable\n@@ -1388,11 +1394,10 @@ fn type_autoderef(cx: &ctxt, t: &ty::t) -> ty::t {\n           }\n           ty::ty_tag(did, tps) {\n             let variants = tag_variants(cx, did);\n-            if vec::len(variants) != 1u || vec::len(variants.(0).args) != 1u\n-               {\n+            if vec::len(variants) != 1u || vec::len(variants[0].args) != 1u {\n                 break;\n             }\n-            t1 = substitute_type_params(cx, tps, variants.(0).args.(0));\n+            t1 = substitute_type_params(cx, tps, variants[0].args[0]);\n           }\n           _ { break; }\n         }\n@@ -1490,6 +1495,7 @@ fn hash_type_structure(st: &sty) -> uint {\n         ret h;\n       }\n \n+\n       // ???\n       ty_fn(_, args, rty, _, _) {\n         ret hash_fn(27u, args, rty);\n@@ -1501,7 +1507,7 @@ fn hash_type_structure(st: &sty) -> uint {\n         ret h;\n       }\n       ty_var(v) { ret hash_uint(30u, v as uint); }\n-      ty_param(pid,_) { ret hash_uint(31u, pid); }\n+      ty_param(pid, _) { ret hash_uint(31u, pid); }\n       ty_type. { ret 32u; }\n       ty_native(did) { ret hash_def(33u, did); }\n       ty_bot. { ret 34u; }\n@@ -1516,11 +1522,7 @@ fn hash_type_structure(st: &sty) -> uint {\n         for c: @type_constr in cs { h += h << 5u + hash_type_constr(h, c); }\n         ret h;\n       }\n-      ty_uniq(t) {\n-        let h = 37u;\n-        h += h << 5u + hash_ty(t);\n-        ret h;\n-      }\n+      ty_uniq(t) { let h = 37u; h += h << 5u + hash_ty(t); ret h; }\n     }\n }\n \n@@ -1542,7 +1544,7 @@ fn hash_ty(typ: &t) -> uint { ret typ; }\n // users should use `eq_ty()` instead.\n fn eq_int(x: &uint, y: &uint) -> bool { ret x == y; }\n \n-fn arg_eq<T>(eq: &fn(&T, &T) -> bool , a: @sp_constr_arg<T>,\n+fn arg_eq<T>(eq: &fn(&T, &T) -> bool, a: @sp_constr_arg<T>,\n              b: @sp_constr_arg<T>) -> bool {\n     alt a.node {\n       ast::carg_base. {\n@@ -1557,11 +1559,11 @@ fn arg_eq<T>(eq: &fn(&T, &T) -> bool , a: @sp_constr_arg<T>,\n     }\n }\n \n-fn args_eq<T>(eq: fn(&T, &T) -> bool , a: &[@sp_constr_arg<T>],\n+fn args_eq<T>(eq: fn(&T, &T) -> bool, a: &[@sp_constr_arg<T>],\n               b: &[@sp_constr_arg<T>]) -> bool {\n     let i: uint = 0u;\n     for arg: @sp_constr_arg<T> in a {\n-        if !arg_eq(eq, arg, b.(i)) { ret false; }\n+        if !arg_eq(eq, arg, b[i]) { ret false; }\n         i += 1u;\n     }\n     ret true;\n@@ -1576,7 +1578,7 @@ fn constr_eq(c: &@constr, d: &@constr) -> bool {\n fn constrs_eq(cs: &[@constr], ds: &[@constr]) -> bool {\n     if vec::len(cs) != vec::len(ds) { ret false; }\n     let i = 0u;\n-    for c: @constr in cs { if !constr_eq(c, ds.(i)) { ret false; } i += 1u; }\n+    for c: @constr in cs { if !constr_eq(c, ds[i]) { ret false; } i += 1u; }\n     ret true;\n }\n \n@@ -1630,7 +1632,7 @@ fn node_id_to_type(cx: &ctxt, id: &ast::node_id) -> t {\n \n fn node_id_to_type_params(cx: &ctxt, id: &ast::node_id) -> [t] {\n     alt node_id_to_ty_param_substs_opt_and_ty(cx, id).substs {\n-      none. { ret ~[]; }\n+      none. { ret []; }\n       some(tps) { ret tps; }\n     }\n }\n@@ -1663,17 +1665,17 @@ fn node_id_to_monotype(cx: &ctxt, id: ast::node_id) -> t {\n fn count_ty_params(cx: &ctxt, ty: t) -> uint {\n     fn counter(cx: &ctxt, param_indices: @mutable [uint], ty: t) {\n         alt struct(cx, ty) {\n-          ty_param(param_idx,_) {\n+          ty_param(param_idx, _) {\n             let seen = false;\n             for other_param_idx: uint in *param_indices {\n                 if param_idx == other_param_idx { seen = true; }\n             }\n-            if !seen { *param_indices += ~[param_idx]; }\n+            if !seen { *param_indices += [param_idx]; }\n           }\n           _ {/* fall through */ }\n         }\n     }\n-    let param_indices: @mutable [uint] = @mutable ~[];\n+    let param_indices: @mutable [uint] = @mutable [];\n     let f = bind counter(cx, param_indices, _);\n     walk_ty(cx, f, ty);\n     ret vec::len::<uint>(*param_indices);\n@@ -1810,31 +1812,32 @@ fn is_lval(expr: &@ast::expr) -> bool {\n     }\n }\n \n-fn occurs_check_fails(tcx: &ctxt, sp: &option::t<span>, vid: int, rt: &t)\n-    -> bool {\n-    if (!type_contains_vars(tcx, rt)) {\n+fn occurs_check_fails(tcx: &ctxt, sp: &option::t<span>, vid: int, rt: &t) ->\n+   bool {\n+    if !type_contains_vars(tcx, rt) {\n         // Fast path\n         ret false;\n     }\n+\n     // Occurs check!\n     if vec::member(vid, vars_in_type(tcx, rt)) {\n         alt sp {\n-          some (s) {\n+          some(s) {\n             // Maybe this should be span_err -- however, there's an\n             // assertion later on that the type doesn't contain\n             // variables, so in this case we have to be sure to die.\n-            tcx.sess.span_fatal(s,\n-                                \"Type inference failed because I \\\n-               could not find a type\\n that's both of the form \" +\n-               ty_to_str(tcx, ty::mk_var(tcx, (vid)))\n-              + \" and of the form \" + ty_to_str(tcx, rt)\n-              + \". Such a type would have to be infinitely \\\n-               large.\");\n+            tcx.sess.span_fatal(\n+                s,\n+                \"Type inference failed because I \\\n+                 could not find a type\\n that's both of the form \"\n+                + ty_to_str(tcx, ty::mk_var(tcx, vid)) +\n+                \" and of the form \" + ty_to_str(tcx, rt) +\n+                \". Such a type would have to be infinitely \\\n+                 large.\");\n           }\n           _ { ret true; }\n         }\n-    }\n-    else { ret false; }\n+    } else { ret false; }\n }\n \n // Type unification via Robinson's algorithm (Robinson 1965). Implemented as\n@@ -1893,10 +1896,7 @@ mod unify {\n         alt smallintmap::find(cx.vb.types, root_a) {\n           none. {\n             alt smallintmap::find(cx.vb.types, root_b) {\n-              none. {\n-                ufind::union(cx.vb.sets, set_a, set_b);\n-                ret unres_ok;\n-              }\n+              none. { ufind::union(cx.vb.sets, set_a, set_b); ret unres_ok; }\n               some(t_b) { replace_type(cx, t_b); ret unres_ok; }\n             }\n           }\n@@ -1958,7 +1958,7 @@ mod unify {\n         let i = 0u;\n         let rslt;\n         for c: @type_constr in expected {\n-            rslt = unify_constr(base_t, c, actual.(i));\n+            rslt = unify_constr(base_t, c, actual[i]);\n             alt rslt { ures_ok(_) { } ures_err(_) { ret rslt; } }\n             i += 1u;\n         }\n@@ -1975,7 +1975,7 @@ mod unify {\n         let i = 0u;\n         let actual;\n         for a: @ty_constr_arg in expected.node.args {\n-            actual = actual_constr.node.args.(i);\n+            actual = actual_constr.node.args[i];\n             alt a.node {\n               carg_base. {\n                 alt actual.node { carg_base. { } _ { ret err_res; } }\n@@ -2021,22 +2021,22 @@ mod unify {\n         }\n         // TODO: as above, we should have an iter2 iterator.\n \n-        let result_ins: [arg] = ~[];\n+        let result_ins: [arg] = [];\n         let i = 0u;\n         while i < expected_len {\n-            let expected_input = expected_inputs.(i);\n-            let actual_input = actual_inputs.(i);\n+            let expected_input = expected_inputs[i];\n+            let actual_input = actual_inputs[i];\n             // Unify the result modes.\n \n             let result_mode;\n             if expected_input.mode != actual_input.mode {\n-                ret fn_common_res_err\n-                    (ures_err(terr_mode_mismatch(expected_input.mode,\n-                                                 actual_input.mode)));\n+                ret fn_common_res_err(\n+                    ures_err(terr_mode_mismatch(expected_input.mode,\n+                                                actual_input.mode)));\n             } else { result_mode = expected_input.mode; }\n             let result = unify_step(cx, expected_input.ty, actual_input.ty);\n             alt result {\n-              ures_ok(rty) { result_ins += ~[{mode: result_mode, ty: rty}]; }\n+              ures_ok(rty) { result_ins += [{mode: result_mode, ty: rty}]; }\n               _ { ret fn_common_res_err(result); }\n             }\n             i += 1u;\n@@ -2053,12 +2053,13 @@ mod unify {\n                 expected: &t, actual: &t, expected_inputs: &[arg],\n                 expected_output: &t, actual_inputs: &[arg], actual_output: &t,\n                 expected_cf: &controlflow, actual_cf: &controlflow,\n-                _expected_constrs: &[@constr], actual_constrs: &[@constr])\n-       -> result {\n+                _expected_constrs: &[@constr], actual_constrs: &[@constr]) ->\n+       result {\n         if e_proto != a_proto { ret ures_err(terr_mismatch); }\n         alt expected_cf {\n           ast::return. { }\n-           // ok\n+\n+          // ok\n           ast::noreturn. {\n             alt actual_cf {\n               ast::noreturn. {\n@@ -2109,14 +2110,14 @@ mod unify {\n     fn unify_obj(cx: &@ctxt, expected: &t, actual: &t,\n                  expected_meths: &[method], actual_meths: &[method]) ->\n        result {\n-        let result_meths: [method] = ~[];\n+        let result_meths: [method] = [];\n         let i: uint = 0u;\n         let expected_len: uint = vec::len::<method>(expected_meths);\n         let actual_len: uint = vec::len::<method>(actual_meths);\n         if expected_len != actual_len { ret ures_err(terr_meth_count); }\n         while i < expected_len {\n-            let e_meth = expected_meths.(i);\n-            let a_meth = actual_meths.(i);\n+            let e_meth = expected_meths[i];\n+            let a_meth = actual_meths[i];\n             if !str::eq(e_meth.ident, a_meth.ident) {\n                 ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident));\n             }\n@@ -2130,8 +2131,8 @@ mod unify {\n                 alt struct(cx.tcx, tfn) {\n                   ty_fn(proto, ins, out, cf, constrs) {\n                     result_meths +=\n-                        ~[{inputs: ins, output: out, cf: cf, constrs: constrs\n-                              with e_meth}];\n+                        [{inputs: ins, output: out, cf: cf, constrs: constrs\n+                             with e_meth}];\n                   }\n                 }\n               }\n@@ -2148,9 +2149,7 @@ mod unify {\n        fixup_result {\n         alt struct(tcx, typ) {\n           ty_var(vid) {\n-            if vid as uint >= ufind::set_count(vb.sets) {\n-                ret fix_err(vid);\n-            }\n+            if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n             let root_id = ufind::find(vb.sets, vid as uint);\n             alt smallintmap::find::<t>(vb.types, root_id) {\n               none. { ret fix_err(vid); }\n@@ -2172,6 +2171,7 @@ mod unify {\n \n         alt struct(cx.tcx, actual) {\n \n+\n           // If the RHS is a variable type, then just do the\n           // appropriate binding.\n           ty::ty_var(actual_id) {\n@@ -2219,6 +2219,7 @@ mod unify {\n         alt struct(cx.tcx, expected) {\n           ty::ty_nil. { ret struct_cmp(cx, expected, actual); }\n \n+\n           // _|_ unifies with anything\n           ty::ty_bot. {\n             ret ures_ok(actual);\n@@ -2242,7 +2243,7 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_param(_,_) { ret struct_cmp(cx, expected, actual); }\n+          ty::ty_param(_, _) { ret struct_cmp(cx, expected, actual); }\n           ty::ty_tag(expected_id, expected_tps) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_tag(actual_id, actual_tps) {\n@@ -2251,15 +2252,15 @@ mod unify {\n                     ret ures_err(terr_mismatch);\n                 }\n                 // TODO: factor this cruft out\n-                let result_tps: [t] = ~[];\n+                let result_tps: [t] = [];\n                 let i = 0u;\n                 let expected_len = vec::len::<t>(expected_tps);\n                 while i < expected_len {\n-                    let expected_tp = expected_tps.(i);\n-                    let actual_tp = actual_tps.(i);\n+                    let expected_tp = expected_tps[i];\n+                    let actual_tp = actual_tps[i];\n                     let result = unify_step(cx, expected_tp, actual_tp);\n                     alt result {\n-                      ures_ok(rty) { result_tps += ~[rty]; }\n+                      ures_ok(rty) { result_tps += [rty]; }\n                       _ { ret result; }\n                     }\n                     i += 1u;\n@@ -2354,11 +2355,11 @@ mod unify {\n                 alt result {\n                   ures_ok(res_inner) {\n                     let i = 0u;\n-                    let res_tps = ~[];\n+                    let res_tps = [];\n                     for ex_tp: t in ex_tps {\n-                        let result = unify_step(cx, ex_tp, act_tps.(i));\n+                        let result = unify_step(cx, ex_tp, act_tps[i]);\n                         alt result {\n-                          ures_ok(rty) { res_tps += ~[rty]; }\n+                          ures_ok(rty) { res_tps += [rty]; }\n                           _ { ret result; }\n                         }\n                         i += 1u;\n@@ -2383,11 +2384,11 @@ mod unify {\n                 // TODO: implement an iterator that can iterate over\n                 // two arrays simultaneously.\n \n-                let result_fields: [field] = ~[];\n+                let result_fields: [field] = [];\n                 let i = 0u;\n                 while i < expected_len {\n-                    let expected_field = expected_fields.(i);\n-                    let actual_field = actual_fields.(i);\n+                    let expected_field = expected_fields[i];\n+                    let actual_field = actual_fields[i];\n                     let mut;\n                     alt unify_mut(expected_field.mt.mut, actual_field.mt.mut)\n                         {\n@@ -2406,7 +2407,7 @@ mod unify {\n                     alt result {\n                       ures_ok(rty) {\n                         let mt = {ty: rty, mut: mut};\n-                        result_fields += ~[{mt: mt with expected_field}];\n+                        result_fields += [{mt: mt with expected_field}];\n                       }\n                       _ { ret result; }\n                     }\n@@ -2422,24 +2423,21 @@ mod unify {\n               ty::ty_tup(actual_elems) {\n                 let expected_len = vec::len(expected_elems);\n                 let actual_len = vec::len(actual_elems);\n-                if (expected_len != actual_len) {\n+                if expected_len != actual_len {\n                     let err = terr_tuple_size(expected_len, actual_len);\n                     ret ures_err(err);\n                 }\n                 // TODO: implement an iterator that can iterate over\n                 // two arrays simultaneously.\n \n-                let result_elems = ~[];\n+                let result_elems = [];\n                 let i = 0u;\n                 while i < expected_len {\n-                    let expected_elem = expected_elems.(i);\n-                    let actual_elem = actual_elems.(i);\n-                    let result = unify_step(cx, expected_elem,\n-                                            actual_elem);\n+                    let expected_elem = expected_elems[i];\n+                    let actual_elem = actual_elems[i];\n+                    let result = unify_step(cx, expected_elem, actual_elem);\n                     alt result {\n-                      ures_ok(rty) {\n-                        result_elems += ~[rty];\n-                      }\n+                      ures_ok(rty) { result_elems += [rty]; }\n                       _ { ret result; }\n                     }\n                     i += 1u;\n@@ -2519,17 +2517,15 @@ mod unify {\n             let sets = \"\";\n             let j = 0u;\n             while j < vec::len::<option::t<uint>>(vb.sets.nodes) {\n-                if ufind::find(vb.sets, j) == i {\n-                    sets += #fmt(\" %u\", j);\n-                }\n+                if ufind::find(vb.sets, j) == i { sets += #fmt[\" %u\", j]; }\n                 j += 1u;\n             }\n             let typespec;\n             alt smallintmap::find::<t>(vb.types, i) {\n               none. { typespec = \"\"; }\n               some(typ) { typespec = \" =\" + ty_to_str(tcx, typ); }\n             }\n-            log_err #fmt(\"set %u:%s%s\", i, typespec, sets);\n+            log_err #fmt[\"set %u:%s%s\", i, typespec, sets];\n             i += 1u;\n         }\n     }\n@@ -2538,8 +2534,8 @@ mod unify {\n     //    Takes an optional span - complain about occurs check violations\n     //    iff the span is present (so that if we already know we're going\n     //    to error anyway, we don't complain)\n-    fn fixup_vars(tcx: ty_ctxt, sp: &option::t<span>,\n-                  vb: @var_bindings, typ: t) -> fixup_result {\n+    fn fixup_vars(tcx: ty_ctxt, sp: &option::t<span>, vb: @var_bindings,\n+                  typ: t) -> fixup_result {\n         fn subst_vars(tcx: ty_ctxt, sp: &option::t<span>, vb: @var_bindings,\n                       unresolved: @mutable option::t<int>, vid: int) -> t {\n             // Should really return a fixup_result instead of a t, but fold_ty\n@@ -2553,11 +2549,13 @@ mod unify {\n               none. { *unresolved = some(vid); ret ty::mk_var(tcx, vid); }\n               some(rt) {\n                 if occurs_check_fails(tcx, sp, vid, rt) {\n-      // Return the type unchanged, so we can error out downstream\n+                    // Return the type unchanged, so we can error out\n+                    // downstream\n                     ret rt;\n                 }\n                 ret fold_ty(tcx,\n-                  fm_var(bind subst_vars(tcx, sp, vb, unresolved, _)), rt);\n+                            fm_var(bind subst_vars(tcx, sp, vb, unresolved,\n+                                                   _)), rt);\n               }\n             }\n         }\n@@ -2572,8 +2570,7 @@ mod unify {\n         }\n     }\n     fn resolve_type_var(tcx: &ty_ctxt, sp: &option::t<span>,\n-                        vb: &@var_bindings, vid: int) ->\n-       fixup_result {\n+                        vb: &@var_bindings, vid: int) -> fixup_result {\n         if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n         let root_id = ufind::find(vb.sets, vid as uint);\n         alt smallintmap::find::<t>(vb.types, root_id) {\n@@ -2594,8 +2591,8 @@ fn type_err_to_str(err: &ty::type_err) -> str {\n       terr_vec_mutability. { ret \"vectors differ in mutability\"; }\n       terr_tuple_size(e_sz, a_sz) {\n         ret \"expected a tuple with \" + uint::to_str(e_sz, 10u) +\n-            \" elements but found one with \" + uint::to_str(a_sz, 10u)\n-            + \" elements\";\n+                \" elements but found one with \" + uint::to_str(a_sz, 10u) +\n+                \" elements\";\n       }\n       terr_record_size(e_sz, a_sz) {\n         ret \"expected a record with \" + uint::to_str(e_sz, 10u) +\n@@ -2634,25 +2631,23 @@ fn type_err_to_str(err: &ty::type_err) -> str {\n \n // Converts type parameters in a type to type variables and returns the\n // resulting type along with a list of type variable IDs.\n-fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int ,\n-                       typ: t, ty_param_count: uint) -> {ids: [int], ty: t} {\n-    let param_var_ids: @mutable [int] = @mutable ~[];\n+fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int, typ: t,\n+                       ty_param_count: uint) -> {ids: [int], ty: t} {\n+    let param_var_ids: @mutable [int] = @mutable [];\n     let i = 0u;\n-    while i < ty_param_count { *param_var_ids += ~[next_ty_var()]; i += 1u; }\n+    while i < ty_param_count { *param_var_ids += [next_ty_var()]; i += 1u; }\n     fn binder(sp: span, cx: ctxt, param_var_ids: @mutable [int],\n-              _next_ty_var: fn() -> int , index: uint, _kind: ast::kind)\n-        -> t {\n+              _next_ty_var: fn() -> int, index: uint, _kind: ast::kind) -> t {\n         if index < vec::len(*param_var_ids) {\n-            ret mk_var(cx, param_var_ids.(index));\n+            ret mk_var(cx, param_var_ids[index]);\n         } else {\n             cx.sess.span_fatal(sp, \"Unbound type parameter in callee's type\");\n         }\n     }\n     let new_typ =\n         fold_ty(cx,\n-                fm_param(bind binder(sp, cx, param_var_ids, next_ty_var,\n-                                     _, _)),\n-                typ);\n+                fm_param(bind binder(sp, cx, param_var_ids, next_ty_var, _,\n+                                     _)), typ);\n     ret {ids: *param_var_ids, ty: new_typ};\n }\n \n@@ -2661,10 +2656,10 @@ fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int ,\n // substitions.\n fn substitute_type_params(cx: &ctxt, substs: &[ty::t], typ: t) -> t {\n     if !type_contains_params(cx, typ) { ret typ; }\n-    fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint,\n-                   _kind: ast::kind) -> t {\n+    fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint, _kind: ast::kind)\n+       -> t {\n         // FIXME: bounds check can fail\n-        ret substs.(idx);\n+        ret substs[idx];\n     }\n     ret fold_ty(cx, fm_param(bind substituter(cx, @substs, _, _)), typ);\n }\n@@ -2679,7 +2674,7 @@ fn def_has_ty_params(def: &ast::def) -> bool {\n       ast::def_local(_) { ret false; }\n       ast::def_variant(_, _) { ret true; }\n       ast::def_ty(_) { ret false; }\n-      ast::def_ty_arg(_,_) { ret false; }\n+      ast::def_ty_arg(_, _) { ret false; }\n       ast::def_binding(_) { ret false; }\n       ast::def_use(_) { ret false; }\n       ast::def_native_ty(_) { ret false; }\n@@ -2702,20 +2697,20 @@ fn tag_variants(cx: &ctxt, id: &ast::def_id) -> [variant_info] {\n       ast_map::node_item(item) {\n         alt item.node {\n           ast::item_tag(variants, _) {\n-            let result: [variant_info] = ~[];\n+            let result: [variant_info] = [];\n             for variant: ast::variant in variants {\n                 let ctor_ty = node_id_to_monotype(cx, variant.node.id);\n-                let arg_tys: [t] = ~[];\n+                let arg_tys: [t] = [];\n                 if std::vec::len(variant.node.args) > 0u {\n                     for a: arg in ty_fn_args(cx, ctor_ty) {\n-                        arg_tys += ~[a.ty];\n+                        arg_tys += [a.ty];\n                     }\n                 }\n                 let did = variant.node.id;\n                 result +=\n-                    ~[{args: arg_tys,\n-                       ctor_ty: ctor_ty,\n-                       id: ast::local_def(did)}];\n+                    [{args: arg_tys,\n+                      ctor_ty: ctor_ty,\n+                      id: ast::local_def(did)}];\n             }\n             ret result;\n           }\n@@ -2731,7 +2726,7 @@ fn tag_variant_with_id(cx: &ctxt, tag_id: &ast::def_id,\n     let variants = tag_variants(cx, tag_id);\n     let i = 0u;\n     while i < vec::len::<variant_info>(variants) {\n-        let variant = variants.(i);\n+        let variant = variants[i];\n         if def_eq(variant.id, variant_id) { ret variant; }\n         i += 1u;\n     }\n@@ -2841,7 +2836,7 @@ fn is_binopable(cx: &ctxt, ty: t, op: ast::binop) -> bool {\n           ty_rec(_) { tycat_struct }\n           ty_tup(_) { tycat_struct }\n           ty_tag(_, _) { tycat_struct }\n-          ty_bot.    { tycat_bot }\n+          ty_bot. { tycat_bot }\n           _ { tycat_other }\n         }\n     }\n@@ -2852,24 +2847,20 @@ fn is_binopable(cx: &ctxt, ty: t, op: ast::binop) -> bool {\n     /*.          add,     shift,   bit\n       .             sub,     rel,     logic\n       .                mult,    eq,         */\n-    let  /*other*/\n-         /*bool*/\n-         /*int*/\n-         /*float*/\n-         /*str*/\n-         /*vec*/\n-         /*bot*/\n-        tbl =\n-        ~[~[f, f, f, f, t, t, f, f],\n-          ~[f, f, f, f, t, t, t, t],\n-          ~[t, t, t, t, t, t, t, f],\n-          ~[t, t, t, f, t, t, f, f],\n-          ~[t, f, f, f, t, t, f, f],\n-          ~[t, f, f, f, t, t, f, f],\n-          ~[f, f, f, f, t, t, f, f],\n-          ~[t, t, t, t, t, t, t, t]]; /*struct*/\n-\n-    ret tbl.(tycat(cx, ty)).(opcat(op));\n+     /*other*/\n+     /*bool*/\n+     /*int*/\n+     /*float*/\n+     /*str*/\n+     /*vec*/\n+     /*bot*/\n+    let tbl =\n+        [[f, f, f, f, t, t, f, f], [f, f, f, f, t, t, t, t],\n+         [t, t, t, t, t, t, t, f], [t, t, t, f, t, t, f, f],\n+         [t, f, f, f, t, t, f, f], [t, f, f, f, t, t, f, f],\n+         [f, f, f, f, t, t, f, f], [t, t, t, t, t, t, t, t]]; /*struct*/\n+\n+    ret tbl[tycat(cx, ty)][opcat(op)];\n }\n \n fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: &@ast::constr_general<T>) ->\n@@ -2880,10 +2871,10 @@ fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: &@ast::constr_general<T>) ->\n                     {path: c.node.path, args: c.node.args, id: pred_id});\n       }\n       _ {\n-        tcx.sess.span_fatal\n-            (c.span, \"Predicate \" + path_to_str(c.node.path) +\n-             \" is unbound or bound to a non-function or an \\\n-              impure function\");\n+        tcx.sess.span_fatal(c.span,\n+                            \"Predicate \" + path_to_str(c.node.path) +\n+                            \" is unbound or bound to a non-function or an \\\n+                             impure function\");\n       }\n     }\n }"}, {"sha": "9e9d068224996e9465e4c7e675e3f2f325bfaef2", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 423, "deletions": 406, "changes": 829, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -53,8 +53,10 @@ type ty_table = hashmap<ast::def_id, ty::t>;\n \n // Used for typechecking the methods of an object.\n tag obj_info {\n+\n     // Regular objects have a node_id at compile time.\n     regular_obj([ast::obj_field], ast::node_id);\n+\n     // Anonymous objects only have a type at compile time.  It's optional\n     // because not all anonymous objects have a inner_obj to attach to.\n     anon_obj([ast::obj_field], option::t<ty::sty>);\n@@ -78,14 +80,14 @@ type fn_ctxt =\n \n \n // Used for ast_ty_to_ty() below.\n-type ty_getter = fn(&ast::def_id) -> ty::ty_param_kinds_and_ty ;\n+type ty_getter = fn(&ast::def_id) -> ty::ty_param_kinds_and_ty;\n \n fn lookup_local(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> int {\n     alt fcx.locals.find(id) {\n       some(x) { x }\n       _ {\n-        fcx.ccx.tcx.sess.span_fatal\n-            (sp, \"internal error looking up a local var\")\n+        fcx.ccx.tcx.sess.span_fatal(sp,\n+                                    \"internal error looking up a local var\")\n       }\n     }\n }\n@@ -94,23 +96,23 @@ fn lookup_def(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> ast::def {\n     alt fcx.ccx.tcx.def_map.find(id) {\n       some(x) { x }\n       _ {\n-        fcx.ccx.tcx.sess.span_fatal\n-            (sp, \"internal error looking up a definition\")\n+        fcx.ccx.tcx.sess.span_fatal(sp,\n+                                    \"internal error looking up a definition\")\n       }\n     }\n }\n \n fn ident_for_local(loc: &@ast::local) -> ast::ident {\n     ret alt loc.node.pat.node {\n-      ast::pat_bind(name) { name }\n-      _ { \"local\" } // FIXME DESTR\n-    };\n+          ast::pat_bind(name) { name }\n+          _ { \"local\" }\n+        }; // FIXME DESTR\n }\n \n // Returns the type parameter count and the type for the given definition.\n fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n    -> ty_param_kinds_and_ty {\n-    let no_kinds: [ast::kind] = ~[];\n+    let no_kinds: [ast::kind] = [];\n     alt defn {\n       ast::def_arg(id) {\n \n@@ -168,22 +170,25 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n     if ty_substs_len > 0u {\n         let param_var_len = vec::len(ty_param_vars);\n         if param_var_len == 0u {\n-            fcx.ccx.tcx.sess.span_fatal\n-                (sp, \"this item does not take type parameters\");\n-        } else if (ty_substs_len > param_var_len) {\n-            fcx.ccx.tcx.sess.span_fatal\n-                (sp, \"too many type parameter provided for this item\");\n-        } else if (ty_substs_len < param_var_len) {\n-            fcx.ccx.tcx.sess.span_fatal\n-                (sp, \"not enough type parameters provided for this item\");\n-        }\n-        let ty_substs: [ty::t] = ~[];\n+            fcx.ccx.tcx.sess.span_fatal(\n+                sp,\n+                \"this item does not take type parameters\");\n+        } else if ty_substs_len > param_var_len {\n+            fcx.ccx.tcx.sess.span_fatal(\n+                sp,\n+                \"too many type parameter provided for this item\");\n+        } else if ty_substs_len < param_var_len {\n+            fcx.ccx.tcx.sess.span_fatal(\n+                sp,\n+                \"not enough type parameters provided for this item\");\n+        }\n+        let ty_substs: [ty::t] = [];\n         let i = 0u;\n         while i < ty_substs_len {\n-            let ty_var = ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i));\n-            let ty_subst = ast_ty_to_ty_crate(fcx.ccx, pth.node.types.(i));\n+            let ty_var = ty::mk_var(fcx.ccx.tcx, ty_param_vars[i]);\n+            let ty_subst = ast_ty_to_ty_crate(fcx.ccx, pth.node.types[i]);\n             let res_ty = demand::simple(fcx, pth.span, ty_var, ty_subst);\n-            ty_substs += ~[res_ty];\n+            ty_substs += [res_ty];\n             i += 1u;\n         }\n         ty_substs_opt = some::<[ty::t]>(ty_substs);\n@@ -194,10 +199,10 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n         }\n     } else {\n         // We will acquire the type parameters through unification.\n-        let ty_substs: [ty::t] = ~[];\n+        let ty_substs: [ty::t] = [];\n         let i = 0u;\n         while i < ty_param_count {\n-            ty_substs += ~[ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i))];\n+            ty_substs += [ty::mk_var(fcx.ccx.tcx, ty_param_vars[i])];\n             i += 1u;\n         }\n         ty_substs_opt = some::<[ty::t]>(ty_substs);\n@@ -215,13 +220,13 @@ fn ast_mode_to_mode(mode: ast::mode) -> ty::mode {\n \n \n // Type tests\n-fn structurally_resolved_type(fcx: &@fn_ctxt, sp: &span, tp: ty::t) ->\n-   ty::t {\n+fn structurally_resolved_type(fcx: &@fn_ctxt, sp: &span, tp: ty::t) -> ty::t {\n     alt ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, tp) {\n       fix_ok(typ_s) { ret typ_s; }\n       fix_err(_) {\n-        fcx.ccx.tcx.sess.span_fatal\n-            (sp, \"the type of this value must be known in this context\");\n+        fcx.ccx.tcx.sess.span_fatal(\n+            sp,\n+            \"the type of this value must be known in this context\");\n       }\n     }\n }\n@@ -293,12 +298,11 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         // The typedef is type-parametric. Do the type substitution.\n         //\n \n-        let param_bindings: [ty::t] = ~[];\n+        let param_bindings: [ty::t] = [];\n         for ast_ty: @ast::ty in args {\n-            param_bindings += ~[ast_ty_to_ty(tcx, getter, ast_ty)];\n+            param_bindings += [ast_ty_to_ty(tcx, getter, ast_ty)];\n         }\n-        if vec::len(param_bindings) !=\n-            vec::len(ty_param_kinds_and_ty.kinds) {\n+        if vec::len(param_bindings) != vec::len(ty_param_kinds_and_ty.kinds) {\n             tcx.sess.span_fatal(sp,\n                                 \"Wrong number of type arguments for a \\\n                                  polymorphic type\");\n@@ -335,23 +339,23 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         typ = ty::mk_tup(tcx, flds);\n       }\n       ast::ty_rec(fields) {\n-        let flds: [field] = ~[];\n+        let flds: [field] = [];\n         for f: ast::ty_field in fields {\n             let tm = ast_mt_to_mt(tcx, getter, f.node.mt);\n-            flds += ~[{ident: f.node.ident, mt: tm}];\n+            flds += [{ident: f.node.ident, mt: tm}];\n         }\n         typ = ty::mk_rec(tcx, flds);\n       }\n       ast::ty_fn(proto, inputs, output, cf, constrs) {\n-        let i = ~[];\n+        let i = [];\n         for ta: ast::ty_arg in inputs {\n-            i += ~[ast_arg_to_arg(tcx, getter, ta)];\n+            i += [ast_arg_to_arg(tcx, getter, ta)];\n         }\n         let out_ty = ast_ty_to_ty(tcx, getter, output);\n \n-        let out_constrs = ~[];\n+        let out_constrs = [];\n         for constr: @ast::constr in constrs {\n-            out_constrs += ~[ty::ast_constr_to_constr(tcx, constr)];\n+            out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n         }\n         typ = ty::mk_fn(tcx, proto, i, out_ty, cf, out_constrs);\n       }\n@@ -361,7 +365,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n             typ = instantiate(tcx, ast_ty.span, getter, id, path.node.types);\n           }\n           some(ast::def_native_ty(id)) { typ = getter(id).ty; }\n-          some(ast::def_ty_arg(id,k)) { typ = ty::mk_param(tcx, id, k); }\n+          some(ast::def_ty_arg(id, k)) { typ = ty::mk_param(tcx, id, k); }\n           some(_) {\n             tcx.sess.span_fatal(ast_ty.span,\n                                 \"found type name used as a variable\");\n@@ -373,17 +377,17 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         cname = some(path_to_str(path));\n       }\n       ast::ty_obj(meths) {\n-        let tmeths: [ty::method] = ~[];\n+        let tmeths: [ty::method] = [];\n         for m: ast::ty_method in meths {\n-            let ins = ~[];\n+            let ins = [];\n             for ta: ast::ty_arg in m.node.inputs {\n-                ins += ~[ast_arg_to_arg(tcx, getter, ta)];\n+                ins += [ast_arg_to_arg(tcx, getter, ta)];\n             }\n             let out = ast_ty_to_ty(tcx, getter, m.node.output);\n \n-            let out_constrs = ~[];\n+            let out_constrs = [];\n             for constr: @ast::constr in m.node.constrs {\n-                out_constrs += ~[ty::ast_constr_to_constr(tcx, constr)];\n+                out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n             }\n             let new_m: ty::method =\n                 {proto: m.node.proto,\n@@ -392,20 +396,19 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n                  output: out,\n                  cf: m.node.cf,\n                  constrs: out_constrs};\n-            tmeths += ~[new_m];\n+            tmeths += [new_m];\n         }\n         typ = ty::mk_obj(tcx, ty::sort_methods(tmeths));\n       }\n       ast::ty_constr(t, cs) {\n-        let out_cs = ~[];\n+        let out_cs = [];\n         for constr: @ast::ty_constr in cs {\n-            out_cs += ~[ty::ast_constr_to_constr(tcx, constr)];\n+            out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n         }\n         typ = ty::mk_constr(tcx, ast_ty_to_ty(tcx, getter, t), out_cs);\n       }\n       ast::ty_infer. {\n-        tcx.sess.span_bug(ast_ty.span,\n-                          \"found ty_infer in unexpected place\");\n+        tcx.sess.span_bug(ast_ty.span, \"found ty_infer in unexpected place\");\n       }\n     }\n     alt cname {\n@@ -429,8 +432,8 @@ fn ast_ty_to_ty_crate(ccx: @crate_ctxt, ast_ty: &@ast::ty) -> ty::t {\n }\n \n // A wrapper around ast_ty_to_ty_crate that handles ty_infer.\n-fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, ast_ty: &@ast::ty)\n-    -> option::t<ty::t> {\n+fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, ast_ty: &@ast::ty) ->\n+   option::t<ty::t> {\n     alt ast_ty.node {\n       ast::ty_infer. { none }\n       _ { some(ast_ty_to_ty_crate(ccx, ast_ty)) }\n@@ -467,7 +470,7 @@ mod write {\n                 tpot: &ty_param_substs_opt_and_ty) {\n         inner(fcx.ccx.tcx.node_types, node_id, tpot);\n         if ty::type_contains_vars(fcx.ccx.tcx, tpot.ty) {\n-            fcx.fixups += ~[node_id];\n+            fcx.fixups += [node_id];\n         }\n     }\n \n@@ -521,35 +524,33 @@ mod collect {\n     type ctxt = {tcx: ty::ctxt};\n \n     fn mk_ty_params(cx: &@ctxt, atps: &[ast::ty_param]) -> [ty::t] {\n-        let tps = ~[];\n+        let tps = [];\n         let i = 0u;\n         for atp: ast::ty_param in atps {\n-            tps += ~[ty::mk_param(cx.tcx, i, atp.kind)];\n+            tps += [ty::mk_param(cx.tcx, i, atp.kind)];\n             i += 1u;\n         }\n         ret tps;\n     }\n \n     fn ty_param_kinds(tps: &[ast::ty_param]) -> [ast::kind] {\n-        let k: [ast::kind] = ~[];\n-        for p: ast::ty_param in tps {\n-            k += ~[p.kind]\n-        }\n+        let k: [ast::kind] = [];\n+        for p: ast::ty_param in tps { k += [p.kind] }\n         ret k;\n     }\n \n-    fn ty_of_fn_decl(cx: &@ctxt, convert: &fn(&@ast::ty) -> ty::t ,\n-                     ty_of_arg: &fn(&ast::arg) -> arg , decl: &ast::fn_decl,\n+    fn ty_of_fn_decl(cx: &@ctxt, convert: &fn(&@ast::ty) -> ty::t,\n+                     ty_of_arg: &fn(&ast::arg) -> arg, decl: &ast::fn_decl,\n                      proto: ast::proto, ty_params: &[ast::ty_param],\n                      def_id: &option::t<ast::def_id>) ->\n        ty::ty_param_kinds_and_ty {\n-        let input_tys = ~[];\n-        for a: ast::arg in decl.inputs { input_tys += ~[ty_of_arg(a)]; }\n+        let input_tys = [];\n+        for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(a)]; }\n         let output_ty = convert(decl.output);\n \n-        let out_constrs = ~[];\n+        let out_constrs = [];\n         for constr: @ast::constr in decl.constraints {\n-            out_constrs += ~[ty::ast_constr_to_constr(cx.tcx, constr)];\n+            out_constrs += [ty::ast_constr_to_constr(cx.tcx, constr)];\n         }\n         let t_fn =\n             ty::mk_fn(cx.tcx, proto_to_ty_proto(proto), input_tys, output_ty,\n@@ -558,13 +559,13 @@ mod collect {\n         alt def_id { some(did) { cx.tcx.tcache.insert(did, tpt); } _ { } }\n         ret tpt;\n     }\n-    fn ty_of_native_fn_decl(cx: &@ctxt, convert: &fn(&@ast::ty) -> ty::t ,\n-                            ty_of_arg: &fn(&ast::arg) -> arg ,\n+    fn ty_of_native_fn_decl(cx: &@ctxt, convert: &fn(&@ast::ty) -> ty::t,\n+                            ty_of_arg: &fn(&ast::arg) -> arg,\n                             decl: &ast::fn_decl, abi: ast::native_abi,\n                             ty_params: &[ast::ty_param], def_id: &ast::def_id)\n        -> ty::ty_param_kinds_and_ty {\n-        let input_tys = ~[];\n-        for a: ast::arg in decl.inputs { input_tys += ~[ty_of_arg(a)]; }\n+        let input_tys = [];\n+        for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(a)]; }\n         let output_ty = convert(decl.output);\n \n         let t_fn = ty::mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n@@ -608,16 +609,16 @@ mod collect {\n         let get = bind getter(cx, _);\n         let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n \n-        let inputs = ~[];\n+        let inputs = [];\n         for a: ast::arg in m.node.meth.decl.inputs {\n-            inputs += ~[ty_of_arg(cx, a)];\n+            inputs += [ty_of_arg(cx, a)];\n         }\n \n         let output = convert(m.node.meth.decl.output);\n \n-        let out_constrs = ~[];\n+        let out_constrs = [];\n         for constr: @ast::constr in m.node.meth.decl.constraints {\n-            out_constrs += ~[ty::ast_constr_to_constr(cx.tcx, constr)];\n+            out_constrs += [ty::ast_constr_to_constr(cx.tcx, constr)];\n         }\n         ret {proto: proto_to_ty_proto(m.node.meth.proto),\n              ident: m.node.ident,\n@@ -638,24 +639,24 @@ mod collect {\n        ty::ty_param_kinds_and_ty {\n         let t_obj = ty_of_obj(cx, id, ob, ty_params);\n \n-        let t_inputs: [arg] = ~[];\n+        let t_inputs: [arg] = [];\n         for f: ast::obj_field in ob.fields {\n             let g = bind getter(cx, _);\n             let t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n-            t_inputs += ~[{mode: ty::mo_alias(false), ty: t_field}];\n+            t_inputs += [{mode: ty::mo_alias(false), ty: t_field}];\n         }\n \n         let t_fn =\n             ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj.ty, ast::return,\n-                      ~[]);\n+                      []);\n         let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n         cx.tcx.tcache.insert(local_def(ctor_id), tpt);\n         ret tpt;\n     }\n     fn ty_of_item(cx: &@ctxt, it: &@ast::item) -> ty::ty_param_kinds_and_ty {\n         let get = bind getter(cx, _);\n         let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n-        let no_kinds: [ast::kind] = ~[];\n+        let no_kinds: [ast::kind] = [];\n         alt it.node {\n           ast::item_const(t, _) {\n             let typ = convert(t);\n@@ -687,7 +688,7 @@ mod collect {\n             ret tpt;\n           }\n           ast::item_res(f, _, tps, _) {\n-            let t_arg = ty_of_arg(cx, f.decl.inputs.(0));\n+            let t_arg = ty_of_arg(cx, f.decl.inputs[0]);\n             let t_res =\n                 {kinds: ty_param_kinds(tps),\n                  ty:\n@@ -710,7 +711,7 @@ mod collect {\n     }\n     fn ty_of_native_item(cx: &@ctxt, it: &@ast::native_item,\n                          abi: ast::native_abi) -> ty::ty_param_kinds_and_ty {\n-        let no_kinds: [ast::kind] = ~[];\n+        let no_kinds: [ast::kind] = [];\n         alt it.node {\n           ast::native_item_fn(_, fn_decl, params) {\n             let get = bind getter(cx, _);\n@@ -749,26 +750,26 @@ mod collect {\n                 // should be called to resolve named types.\n \n                 let f = bind getter(cx, _);\n-                let args: [arg] = ~[];\n+                let args: [arg] = [];\n                 for va: ast::variant_arg in variant.node.args {\n                     let arg_ty = ast_ty_to_ty(cx.tcx, f, va.ty);\n-                    args += ~[{mode: ty::mo_alias(false), ty: arg_ty}];\n+                    args += [{mode: ty::mo_alias(false), ty: arg_ty}];\n                 }\n                 let tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n                 // FIXME: this will be different for constrained types\n                 result_ty =\n                     ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t, ast::return,\n-                              ~[]);\n+                              []);\n             }\n             let tpt = {kinds: ty_param_kinds(ty_params), ty: result_ty};\n             cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n         }\n     }\n     fn get_obj_method_types(cx: &@ctxt, object: &ast::_obj) -> [ty::method] {\n-        let meths = ~[];\n+        let meths = [];\n         for m: @ast::method in object.methods {\n-            meths += ~[ty_of_method(cx, m)];\n+            meths += [ty_of_method(cx, m)];\n         }\n         ret meths;\n     }\n@@ -793,8 +794,8 @@ mod collect {\n             // we write into the table for this item.\n             ty_of_item(cx, it);\n \n-            let tpt = ty_of_obj_ctor(cx, it.ident, object,\n-                                     ctor_id, ty_params);\n+            let tpt =\n+                ty_of_obj_ctor(cx, it.ident, object, ctor_id, ty_params);\n             write::ty_only(cx.tcx, ctor_id, tpt.ty);\n             // Write the methods into the type table.\n             //\n@@ -804,9 +805,9 @@ mod collect {\n             let method_types = get_obj_method_types(cx, object);\n             let i = 0u;\n             while i < vec::len::<@ast::method>(object.methods) {\n-                write::ty_only(cx.tcx, object.methods.(i).node.id,\n+                write::ty_only(cx.tcx, object.methods[i].node.id,\n                                ty::method_ty_to_fn_ty(cx.tcx,\n-                                                      method_types.(i)));\n+                                                      method_types[i]));\n                 i += 1u;\n             }\n             // Write in the types of the object fields.\n@@ -816,22 +817,22 @@ mod collect {\n             let args = ty::ty_fn_args(cx.tcx, tpt.ty);\n             i = 0u;\n             while i < vec::len::<ty::arg>(args) {\n-                let fld = object.fields.(i);\n-                write::ty_only(cx.tcx, fld.id, args.(i).ty);\n+                let fld = object.fields[i];\n+                write::ty_only(cx.tcx, fld.id, args[i].ty);\n                 i += 1u;\n             }\n           }\n           ast::item_res(f, dtor_id, tps, ctor_id) {\n-            let t_arg = ty_of_arg(cx, f.decl.inputs.(0));\n+            let t_arg = ty_of_arg(cx, f.decl.inputs[0]);\n             let t_res =\n                 ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n                            mk_ty_params(cx, tps));\n             let t_ctor =\n-                ty::mk_fn(cx.tcx, ast::proto_fn, ~[t_arg], t_res, ast::return,\n-                          ~[]);\n+                ty::mk_fn(cx.tcx, ast::proto_fn, [t_arg], t_res, ast::return,\n+                          []);\n             let t_dtor =\n-                ty::mk_fn(cx.tcx, ast::proto_fn, ~[t_arg], ty::mk_nil(cx.tcx),\n-                          ast::return, ~[]);\n+                ty::mk_fn(cx.tcx, ast::proto_fn, [t_arg], ty::mk_nil(cx.tcx),\n+                          ast::return, []);\n             write::ty_only(cx.tcx, it.id, t_res);\n             write::ty_only(cx.tcx, ctor_id, t_ctor);\n             cx.tcx.tcache.insert(local_def(ctor_id),\n@@ -869,10 +870,12 @@ mod collect {\n         // contained within the native module.\n         let abi = @mutable none::<ast::native_abi>;\n         let cx = @{tcx: tcx};\n-        let visit = visit::mk_simple_visitor\n-            (@{visit_item: bind convert(cx, abi, _),\n-               visit_native_item: bind convert_native(cx, abi, _)\n-               with *visit::default_simple_visitor()});\n+        let visit =\n+            visit::mk_simple_visitor(@{visit_item: bind convert(cx, abi, _),\n+                                       visit_native_item:\n+                                       bind convert_native(cx, abi, _)\n+                                           with\n+                                           *visit::default_simple_visitor()});\n         visit::visit_crate(*crate, (), visit);\n     }\n }\n@@ -901,7 +904,7 @@ fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: &ty::t) -> ty::t {\n                     break;\n                 }\n               }\n-              _ {}\n+              _ { }\n             }\n             t1 = inner.ty;\n           }\n@@ -910,13 +913,12 @@ fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: &ty::t) -> ty::t {\n           }\n           ty::ty_tag(did, tps) {\n             let variants = ty::tag_variants(fcx.ccx.tcx, did);\n-            if vec::len(variants) != 1u || vec::len(variants.(0).args) != 1u\n-               {\n+            if vec::len(variants) != 1u || vec::len(variants[0].args) != 1u {\n                 ret t1;\n             }\n             t1 =\n                 ty::substitute_type_params(fcx.ccx.tcx, tps,\n-                                           variants.(0).args.(0));\n+                                           variants[0].args[0]);\n           }\n           _ { ret t1; }\n         }\n@@ -926,6 +928,7 @@ fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: &ty::t) -> ty::t {\n \n fn do_fn_block_coerce(fcx: &@fn_ctxt, sp: &span, actual: &ty::t,\n                       expected: &ty::t) -> ty::t {\n+\n     // fns can be silently coerced to blocks when being used as\n     // function call or bind arguments, but not the reverse.\n     // If our actual type is a fn and our expected type is a block,\n@@ -962,16 +965,16 @@ type ty_param_substs_and_ty = {substs: [ty::t], ty: ty::t};\n mod demand {\n     fn simple(fcx: &@fn_ctxt, sp: &span, expected: &ty::t, actual: &ty::t) ->\n        ty::t {\n-        full(fcx, sp, expected, actual, ~[], false).ty\n+        full(fcx, sp, expected, actual, [], false).ty\n     }\n-    fn block_coerce(fcx: &@fn_ctxt, sp: &span,\n-                    expected: &ty::t, actual: &ty::t) -> ty::t {\n-        full(fcx, sp, expected, actual, ~[], true).ty\n+    fn block_coerce(fcx: &@fn_ctxt, sp: &span, expected: &ty::t,\n+                    actual: &ty::t) -> ty::t {\n+        full(fcx, sp, expected, actual, [], true).ty\n     }\n \n     fn with_substs(fcx: &@fn_ctxt, sp: &span, expected: &ty::t,\n                    actual: &ty::t, ty_param_substs_0: &[ty::t]) ->\n-        ty_param_substs_and_ty {\n+       ty_param_substs_and_ty {\n         full(fcx, sp, expected, actual, ty_param_substs_0, false)\n     }\n \n@@ -984,33 +987,31 @@ mod demand {\n             actual = do_fn_block_coerce(fcx, sp, actual, expected);\n         }\n \n-        let ty_param_substs: [mutable ty::t] = ~[mutable];\n-        let ty_param_subst_var_ids: [int] = ~[];\n+        let ty_param_substs: [mutable ty::t] = [mutable];\n+        let ty_param_subst_var_ids: [int] = [];\n         for ty_param_subst: ty::t in ty_param_substs_0 {\n             // Generate a type variable and unify it with the type parameter\n             // substitution. We will then pull out these type variables.\n             let t_0 = next_ty_var(fcx);\n-            ty_param_substs += ~[mutable t_0];\n-            ty_param_subst_var_ids += ~[ty::ty_var_id(fcx.ccx.tcx, t_0)];\n+            ty_param_substs += [mutable t_0];\n+            ty_param_subst_var_ids += [ty::ty_var_id(fcx.ccx.tcx, t_0)];\n             simple(fcx, sp, ty_param_subst, t_0);\n         }\n \n         fn mk_result(fcx: &@fn_ctxt, result_ty: &ty::t,\n                      ty_param_subst_var_ids: &[int]) ->\n            ty_param_substs_and_ty {\n-            let result_ty_param_substs: [ty::t] = ~[];\n+            let result_ty_param_substs: [ty::t] = [];\n             for var_id: int in ty_param_subst_var_ids {\n                 let tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n-                result_ty_param_substs += ~[tp_subst];\n+                result_ty_param_substs += [tp_subst];\n             }\n             ret {substs: result_ty_param_substs, ty: result_ty};\n         }\n \n \n         alt unify::unify(fcx, expected, actual) {\n-          ures_ok(t) {\n-            ret mk_result(fcx, t, ty_param_subst_var_ids);\n-          }\n+          ures_ok(t) { ret mk_result(fcx, t, ty_param_subst_var_ids); }\n           ures_err(err) {\n             let e_err = resolve_type_vars_if_possible(fcx, expected);\n             let a_err = resolve_type_vars_if_possible(fcx, actual);\n@@ -1039,7 +1040,7 @@ fn are_compatible(fcx: &@fn_ctxt, expected: &ty::t, actual: &ty::t) -> bool {\n // Returns the types of the arguments to a tag variant.\n fn variant_arg_types(ccx: &@crate_ctxt, _sp: &span, vid: &ast::def_id,\n                      tag_ty_params: &[ty::t]) -> [ty::t] {\n-    let result: [ty::t] = ~[];\n+    let result: [ty::t] = [];\n     let tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt ty::struct(ccx.tcx, tpt.ty) {\n       ty::ty_fn(_, ins, _, _, _) {\n@@ -1049,7 +1050,7 @@ fn variant_arg_types(ccx: &@crate_ctxt, _sp: &span, vid: &ast::def_id,\n         for arg: ty::arg in ins {\n             let arg_ty =\n                 ty::substitute_type_params(ccx.tcx, tag_ty_params, arg.ty);\n-            result += ~[arg_ty];\n+            result += [arg_ty];\n         }\n       }\n       _ {\n@@ -1077,8 +1078,8 @@ mod writeback {\n     fn resolve_type_vars_in_type(fcx: &@fn_ctxt, sp: &span, typ: ty::t) ->\n        option::t<ty::t> {\n         if !ty::type_contains_vars(fcx.ccx.tcx, typ) { ret some(typ); }\n-        alt ty::unify::fixup_vars(fcx.ccx.tcx, some(sp),\n-                                  fcx.var_bindings, typ) {\n+        alt ty::unify::fixup_vars(fcx.ccx.tcx, some(sp), fcx.var_bindings,\n+                                  typ) {\n           fix_ok(new_type) { ret some(new_type); }\n           fix_err(vid) {\n             fcx.ccx.tcx.sess.span_err(sp,\n@@ -1101,10 +1102,10 @@ mod writeback {\n         alt tpot.substs {\n           none::<[ty::t]>. { new_substs_opt = none::<[ty::t]>; }\n           some::<[ty::t]>(substs) {\n-            let new_substs: [ty::t] = ~[];\n+            let new_substs: [ty::t] = [];\n             for subst: ty::t in substs {\n                 alt resolve_type_vars_in_type(fcx, sp, subst) {\n-                  some(t) { new_substs += ~[t]; }\n+                  some(t) { new_substs += [t]; }\n                   none. { wbcx.success = false; ret; }\n                 }\n             }\n@@ -1163,28 +1164,28 @@ mod writeback {\n \n     fn resolve_type_vars_in_expr(fcx: &@fn_ctxt, e: &@ast::expr) -> bool {\n         let wbcx = {fcx: fcx, mutable success: true};\n-        let visit = visit::mk_vt\n-            (@{visit_item: visit_item,\n-               visit_stmt: visit_stmt,\n-               visit_expr: visit_expr,\n-               visit_block: visit_block,\n-               visit_pat: visit_pat,\n-               visit_local: visit_local\n-               with *visit::default_visitor()});\n+        let visit =\n+            visit::mk_vt(@{visit_item: visit_item,\n+                           visit_stmt: visit_stmt,\n+                           visit_expr: visit_expr,\n+                           visit_block: visit_block,\n+                           visit_pat: visit_pat,\n+                           visit_local: visit_local\n+                              with *visit::default_visitor()});\n         visit::visit_expr(e, wbcx, visit);\n         ret wbcx.success;\n     }\n \n     fn resolve_type_vars_in_block(fcx: &@fn_ctxt, blk: &ast::blk) -> bool {\n         let wbcx = {fcx: fcx, mutable success: true};\n-        let visit = visit::mk_vt\n-            (@{visit_item: visit_item,\n-               visit_stmt: visit_stmt,\n-               visit_expr: visit_expr,\n-               visit_block: visit_block,\n-               visit_pat: visit_pat,\n-               visit_local: visit_local\n-               with *visit::default_visitor()});\n+        let visit =\n+            visit::mk_vt(@{visit_item: visit_item,\n+                           visit_stmt: visit_stmt,\n+                           visit_expr: visit_expr,\n+                           visit_block: visit_block,\n+                           visit_pat: visit_pat,\n+                           visit_local: visit_local\n+                              with *visit::default_visitor()});\n         visit::visit_block(blk, wbcx, visit);\n         ret wbcx.success;\n     }\n@@ -1202,42 +1203,40 @@ type gather_result =\n // Used only as a helper for check_fn.\n fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n                  old_fcx: &option::t<@fn_ctxt>) -> gather_result {\n-    let {vb, locals, local_names, nvi} = alt old_fcx {\n-      none. {\n-        { vb: ty::unify::mk_var_bindings(),\n-          locals: new_int_hash::<int>(),\n-          local_names: new_int_hash::<ast::ident>(),\n-          nvi: @mutable 0 }\n-      }\n-      some(fcx) {\n-        { vb: fcx.var_bindings,\n-          locals: fcx.locals,\n-          local_names: fcx.local_names,\n-          nvi: fcx.next_var_id }\n-      }\n-    };\n+    let {vb: vb, locals: locals, local_names: local_names, nvi: nvi} =\n+        alt old_fcx {\n+          none. {\n+            {vb: ty::unify::mk_var_bindings(),\n+             locals: new_int_hash::<int>(),\n+             local_names: new_int_hash::<ast::ident>(),\n+             nvi: @mutable 0}\n+          }\n+          some(fcx) {\n+            {vb: fcx.var_bindings,\n+             locals: fcx.locals,\n+             local_names: fcx.local_names,\n+             nvi: fcx.next_var_id}\n+          }\n+        };\n     let tcx = ccx.tcx;\n \n-    let next_var_id = lambda() -> int {\n-        let rv = *nvi;\n-        *nvi += 1;\n-        ret rv;\n-    };\n-    let assign = lambda(nid: ast::node_id, ident: &ast::ident,\n-                        ty_opt: option::t<ty::t>) {\n-        let var_id = next_var_id();\n-        locals.insert(nid, var_id);\n-        local_names.insert(nid, ident);\n-        alt ty_opt {\n-          none. {/* nothing to do */ }\n-          some(typ) {\n-            ty::unify::unify(ty::mk_var(tcx, var_id), typ, vb, tcx);\n-          }\n-        }\n-    };\n+    let next_var_id = lambda () -> int { let rv = *nvi; *nvi += 1; ret rv; };\n+    let assign =\n+        lambda (nid: ast::node_id, ident: &ast::ident,\n+                ty_opt: option::t<ty::t>) {\n+            let var_id = next_var_id();\n+            locals.insert(nid, var_id);\n+            local_names.insert(nid, ident);\n+            alt ty_opt {\n+              none. {/* nothing to do */ }\n+              some(typ) {\n+                ty::unify::unify(ty::mk_var(tcx, var_id), typ, vb, tcx);\n+              }\n+            }\n+        };\n \n     // Add object fields, if any.\n-    let obj_fields = ~[];\n+    let obj_fields = [];\n     alt get_obj_info(ccx) {\n       some(oinfo) {\n         alt oinfo {\n@@ -1256,32 +1255,33 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n     let i = 0u;\n     for arg: ty::arg in args {\n-        assign(f.decl.inputs.(i).id, f.decl.inputs.(i).ident, some(arg.ty));\n+        assign(f.decl.inputs[i].id, f.decl.inputs[i].ident, some(arg.ty));\n         i += 1u;\n     }\n \n     // Add explicitly-declared locals.\n-    let visit_local = lambda(local: &@ast::local, e: &(), v: &visit::vt<()>) {\n-        let local_ty = ast_ty_to_ty_crate_infer(ccx, local.node.ty);\n-        assign(local.node.id, ident_for_local(local), local_ty);\n-        visit::visit_local(local, e, v);\n-    };\n+    let visit_local =\n+        lambda (local: &@ast::local, e: &(), v: &visit::vt<()>) {\n+            let local_ty = ast_ty_to_ty_crate_infer(ccx, local.node.ty);\n+            assign(local.node.id, ident_for_local(local), local_ty);\n+            visit::visit_local(local, e, v);\n+        };\n \n     // Add pattern bindings.\n-    let visit_pat = lambda(p: &@ast::pat, e: &(), v: &visit::vt<()>) {\n-        alt p.node {\n-          ast::pat_bind(ident) {\n-            assign(p.id, ident, none);\n-          }\n-          _ {/* no-op */ }\n-        }\n-        visit::visit_pat(p, e, v);\n-    };\n+    let visit_pat =\n+        lambda (p: &@ast::pat, e: &(), v: &visit::vt<()>) {\n+            alt p.node {\n+              ast::pat_bind(ident) { assign(p.id, ident, none); }\n+              _ {/* no-op */ }\n+            }\n+            visit::visit_pat(p, e, v);\n+        };\n \n     // Don't descend into fns and items\n     fn visit_fn<E>(_f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n                    _i: &ast::fn_ident, _id: ast::node_id, _e: &E,\n-                   _v: &visit::vt<E>) { }\n+                   _v: &visit::vt<E>) {\n+    }\n     fn visit_item<E>(_i: &@ast::item, _e: &E, _v: &visit::vt<E>) { }\n \n     let visit =\n@@ -1371,41 +1371,43 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n                     // TODO (issue #448): Wrap a #fmt string over multiple\n                     // lines...\n                     let s =\n-                        #fmt(\"this pattern has %u field%s, but the \\\n+                        #fmt[\"this pattern has %u field%s, but the \\\n                                        corresponding variant has %u field%s\",\n                              subpats_len,\n                              if subpats_len == 1u { \"\" } else { \"s\" },\n-                             arg_len, if arg_len == 1u { \"\" } else { \"s\" });\n+                             arg_len, if arg_len == 1u { \"\" } else { \"s\" }];\n                     fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n                 }\n \n                 // TODO: vec::iter2\n \n                 let i = 0u;\n                 for subpat: @ast::pat in subpats {\n-                    check_pat(fcx, map, subpat, arg_types.(i));\n+                    check_pat(fcx, map, subpat, arg_types[i]);\n                     i += 1u;\n                 }\n-            } else if (subpats_len > 0u) {\n+            } else if subpats_len > 0u {\n                 // TODO: note definition of tag variant\n-                fcx.ccx.tcx.sess.span_fatal\n-                    (pat.span, #fmt(\"this pattern has %u field%s, \\\n-                                     but the corresponding \\\n-                                     variant has no fields\",\n-                                    subpats_len,\n-                                    if subpats_len == 1u { \"\" }\n-                                    else { \"s\" }));\n+                fcx.ccx.tcx.sess.span_fatal(\n+                    pat.span,\n+                    #fmt[\"this pattern has %u field%s, \\\n+                          but the corresponding \\\n+                          variant has no fields\",\n+                         subpats_len,\n+                         if subpats_len == 1u {\n+                             \"\"\n+                         } else { \"s\" }]);\n             }\n             write::ty_fixup(fcx, pat.id, path_tpot);\n           }\n           _ {\n             // FIXME: Switch expected and actual in this message? I\n             // can never tell.\n             fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                        #fmt(\"mismatched types: \\\n+                                        #fmt[\"mismatched types: \\\n                                                   expected %s, found tag\",\n                                              ty_to_str(fcx.ccx.tcx,\n-                                                       expected)));\n+                                                       expected)]);\n           }\n         }\n         write::ty_fixup(fcx, pat.id, path_tpot);\n@@ -1416,19 +1418,21 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n           ty::ty_rec(fields) { ex_fields = fields; }\n           _ {\n             fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                        #fmt(\"mismatched types: expected %s, \\\n+                                        #fmt[\"mismatched types: expected %s, \\\n                                          found record\",\n                                              ty_to_str(fcx.ccx.tcx,\n-                                                       expected)));\n+                                                       expected)]);\n           }\n         }\n         let f_count = vec::len(fields);\n         let ex_f_count = vec::len(ex_fields);\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n-            fcx.ccx.tcx.sess.span_fatal\n-                (pat.span, #fmt(\"mismatched types: expected a record \\\n-                                 with %u fields, found one with %u \\\n-                                 fields\", ex_f_count, f_count));\n+            fcx.ccx.tcx.sess.span_fatal(\n+                pat.span,\n+                #fmt[\"mismatched types: expected a record \\\n+                      with %u fields, found one with %u \\\n+                      fields\",\n+                     ex_f_count, f_count]);\n         }\n         fn matches(name: &str, f: &ty::field) -> bool {\n             ret str::eq(name, f.ident);\n@@ -1438,9 +1442,9 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n               some(field) { check_pat(fcx, map, f.pat, field.mt.ty); }\n               none. {\n                 fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                            #fmt(\"mismatched types: did not \\\n+                                            #fmt[\"mismatched types: did not \\\n                                              expect a record with a field %s\",\n-                                                 f.ident));\n+                                                 f.ident]);\n               }\n             }\n         }\n@@ -1452,23 +1456,23 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n           ty::ty_tup(elts) { ex_elts = elts; }\n           _ {\n             fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                        #fmt(\"mismatched types: expected %s, \\\n-                                         found tuple\", ty_to_str(fcx.ccx.tcx,\n-                                                                 expected)));\n+                                        #fmt[\"mismatched types: expected %s, \\\n+                                         found tuple\",\n+                                             ty_to_str(fcx.ccx.tcx,\n+                                                       expected)]);\n           }\n         }\n         let e_count = vec::len(elts);\n         if e_count != vec::len(ex_elts) {\n-            fcx.ccx.tcx.sess.span_fatal\n-                (pat.span, #fmt(\"mismatched types: expected a tuple \\\n-                                 with %u fields, found one with %u \\\n-                                 fields\", vec::len(ex_elts), e_count));\n+            fcx.ccx.tcx.sess.span_fatal(\n+                pat.span,\n+                #fmt[\"mismatched types: expected a tuple \\\n+                      with %u fields, found one with %u \\\n+                      fields\",\n+                     vec::len(ex_elts), e_count]);\n         }\n         let i = 0u;\n-        for elt in elts {\n-            check_pat(fcx, map, elt, ex_elts.(i));\n-            i += 1u;\n-        }\n+        for elt in elts { check_pat(fcx, map, elt, ex_elts[i]); i += 1u; }\n         write::ty_only_fixup(fcx, pat.id, expected);\n       }\n       ast::pat_box(inner) {\n@@ -1506,31 +1510,31 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: &ast::purity,\n         alt ccx.tcx.def_map.find(callee.id) {\n           some(ast::def_fn(_, ast::pure_fn.)) { ret; }\n           _ {\n-            ccx.tcx.sess.span_fatal\n-                (sp, \"Pure function calls function not known to be pure\");\n+            ccx.tcx.sess.span_fatal(\n+                sp,\n+                \"Pure function calls function not known to be pure\");\n           }\n         }\n       }\n     }\n }\n \n-type unifier = fn(fcx: &@fn_ctxt, sp: &span,\n-                  expected: &ty::t, actual: &ty::t) -> ty::t;\n+type unifier = fn(&@fn_ctxt, &span, &ty::t, &ty::t) -> ty::t;\n \n fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n-    fn dummy_unify(_fcx: &@fn_ctxt, _sp: &span,\n-                   _expected: &ty::t, actual: &ty::t) -> ty::t {\n+    fn dummy_unify(_fcx: &@fn_ctxt, _sp: &span, _expected: &ty::t,\n+                   actual: &ty::t) -> ty::t {\n         actual\n     }\n     ret check_expr_with_unifier(fcx, expr, dummy_unify, 0u);\n }\n-fn check_expr_with(fcx: &@fn_ctxt, expr: &@ast::expr, expected: &ty::t)\n-    -> bool {\n+fn check_expr_with(fcx: &@fn_ctxt, expr: &@ast::expr, expected: &ty::t) ->\n+   bool {\n     ret check_expr_with_unifier(fcx, expr, demand::simple, expected);\n }\n \n-fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n-                           unify: &unifier, expected: &ty::t) -> bool {\n+fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n+                           expected: &ty::t) -> bool {\n     //log_err \"typechecking expr \" + syntax::print::pprust::expr_to_str(expr);\n \n     // A generic function to factor out common logic from call and bind\n@@ -1558,48 +1562,54 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n           ty::ty_fn(ast::proto_iter., _, _, _, _) {\n             if call_kind != kind_for_each {\n                 fcx.ccx.tcx.sess.span_err(\n-                    sp, \"calling iter outside of for each loop\");\n+                    sp,\n+                    \"calling iter outside of for each loop\");\n             }\n           }\n           _ {\n-              if call_kind == kind_for_each {\n+            if call_kind == kind_for_each {\n                 fcx.ccx.tcx.sess.span_err(\n-                    sp, \"calling non-iter as sequence of for each loop\");\n+                    sp,\n+                    \"calling non-iter as sequence of for each loop\");\n             }\n           }\n         }\n \n         // Grab the argument types\n-        let arg_tys = alt sty {\n-          ty::ty_fn(_, arg_tys, _, _, _) |\n-          ty::ty_native_fn(_, arg_tys, _) { arg_tys }\n-          _ {\n-            fcx.ccx.tcx.sess.span_fatal(f.span,\n-                                        \"mismatched types: \\\n+        let arg_tys =\n+            alt sty {\n+              ty::ty_fn(_, arg_tys, _, _, _) | ty::ty_native_fn(_, arg_tys, _)\n+              {\n+                arg_tys\n+              }\n+              _ {\n+                fcx.ccx.tcx.sess.span_fatal(f.span,\n+                                            \"mismatched types: \\\n                                            expected function or native \\\n                                            function but found \"\n-                                            + ty_to_str(fcx.ccx.tcx, fty))\n-          }\n-        };\n+                                                + ty_to_str(fcx.ccx.tcx, fty))\n+              }\n+            };\n \n         // Check that the correct number of arguments were supplied.\n         let expected_arg_count = vec::len(arg_tys);\n         let supplied_arg_count = vec::len(args);\n         if expected_arg_count != supplied_arg_count {\n-            fcx.ccx.tcx.sess.span_err(\n-                sp,\n-                #fmt(\"this function takes %u \\\n+            fcx.ccx.tcx.sess.span_err(sp,\n+                                      #fmt[\"this function takes %u \\\n                       parameter%s but %u parameter%s supplied\",\n-                     expected_arg_count,\n-                     if expected_arg_count == 1u { \"\" } else { \"s\" },\n-                     supplied_arg_count,\n-                     if supplied_arg_count == 1u\n-                     { \" was\" } else { \"s were\" }));\n+                                           expected_arg_count,\n+                                           if expected_arg_count == 1u {\n+                                               \"\"\n+                                           } else { \"s\" }, supplied_arg_count,\n+                                           if supplied_arg_count == 1u {\n+                                               \" was\"\n+                                           } else { \"s were\" }]);\n             // HACK: extend the arguments list with dummy arguments to\n             // check against\n             let dummy = {mode: ty::mo_val, ty: ty::mk_nil(fcx.ccx.tcx)};\n             while vec::len(arg_tys) < supplied_arg_count {\n-                arg_tys += ~[dummy];\n+                arg_tys += [dummy];\n             }\n         }\n \n@@ -1609,26 +1619,31 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         // functions. This is so that we have more information about the types\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n-        let check_args = lambda(check_blocks: bool) -> bool {\n-            let i = 0u;\n-            let bot = false;\n-            for a_opt: option::t<@ast::expr> in args {\n-                alt a_opt {\n-                  some(a) {\n-                    let is_block =\n-                        alt a.node { ast::expr_fn(_) { true } _ { false } };\n-                    if is_block == check_blocks {\n-                        bot |= check_expr_with_unifier(fcx, a,\n-                                                       demand::block_coerce,\n-                                                       arg_tys.(i).ty);\n+        let check_args =\n+            lambda (check_blocks: bool) -> bool {\n+                let i = 0u;\n+                let bot = false;\n+                for a_opt: option::t<@ast::expr> in args {\n+                    alt a_opt {\n+                      some(a) {\n+                        let is_block =\n+                            alt a.node {\n+                              ast::expr_fn(_) { true }\n+                              _ { false }\n+                            };\n+                        if is_block == check_blocks {\n+                            bot |=\n+                                check_expr_with_unifier(fcx, a,\n+                                                        demand::block_coerce,\n+                                                        arg_tys[i].ty);\n+                        }\n+                      }\n+                      none. { }\n                     }\n-                  }\n-                  none. {}\n+                    i += 1u;\n                 }\n-                i += 1u;\n-            }\n-            ret bot;\n-        };\n+                ret bot;\n+            };\n         bot |= check_args(false);\n         bot |= check_args(true);\n \n@@ -1647,9 +1662,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n     // A generic function for checking call expressions\n     fn check_call(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n                   args: &[@ast::expr], call_kind: call_kind) -> bool {\n-        let args_opt_0: [option::t<@ast::expr>] = ~[];\n+        let args_opt_0: [option::t<@ast::expr>] = [];\n         for arg: @ast::expr in args {\n-            args_opt_0 += ~[some::<@ast::expr>(arg)];\n+            args_opt_0 += [some::<@ast::expr>(arg)];\n         }\n \n         // Call the generic checker.\n@@ -1687,8 +1702,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                              element_ty: ty::t, body: &ast::blk,\n                              node_id: ast::node_id) -> bool {\n         let locid = lookup_local(fcx, local.span, local.node.id);\n-        element_ty = demand::simple(fcx, local.span, element_ty,\n-                                    ty::mk_var(fcx.ccx.tcx, locid));\n+        element_ty =\n+            demand::simple(fcx, local.span, element_ty,\n+                           ty::mk_var(fcx.ccx.tcx, locid));\n         let bot = check_decl_local(fcx, local);\n         check_block(fcx, body);\n         // Unify type of decl with element type of the seq\n@@ -1812,50 +1828,50 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         bot = check_expr(fcx, oper);\n         let oper_t = expr_ty(tcx, oper);\n         alt unop {\n-          ast::box(mut) {\n-            oper_t = ty::mk_box(tcx, {ty: oper_t, mut: mut});\n-          }\n+          ast::box(mut) { oper_t = ty::mk_box(tcx, {ty: oper_t, mut: mut}); }\n           ast::deref. {\n             alt structure_of(fcx, expr.span, oper_t) {\n               ty::ty_box(inner) { oper_t = inner.ty; }\n               ty::ty_res(_, inner, _) { oper_t = inner; }\n               ty::ty_tag(id, tps) {\n                 let variants = ty::tag_variants(tcx, id);\n                 if vec::len(variants) != 1u ||\n-                       vec::len(variants.(0).args) != 1u {\n-                    tcx.sess.span_fatal\n-                        (expr.span, \"can only dereference tags \" +\n-                         \"with a single variant which has a \"\n-                         + \"single argument\");\n+                       vec::len(variants[0].args) != 1u {\n+                    tcx.sess.span_fatal(\n+                        expr.span,\n+                        \"can only dereference tags \" +\n+                        \"with a single variant which has a \"\n+                        + \"single argument\");\n                 }\n                 oper_t =\n-                    ty::substitute_type_params(tcx, tps,\n-                                               variants.(0).args.(0));\n+                    ty::substitute_type_params(tcx, tps, variants[0].args[0]);\n               }\n               ty::ty_ptr(inner) { oper_t = inner.ty; }\n               _ {\n                 tcx.sess.span_fatal(expr.span,\n                                     \"dereferencing non-\" +\n-                                    \"dereferenceable type: \" +\n-                                    ty_to_str(tcx, oper_t));\n+                                        \"dereferenceable type: \" +\n+                                        ty_to_str(tcx, oper_t));\n               }\n             }\n           }\n           ast::not. {\n             if !type_is_integral(fcx, oper.span, oper_t) &&\n                    structure_of(fcx, oper.span, oper_t) != ty::ty_bool {\n                 tcx.sess.span_err(expr.span,\n-                                  #fmt(\"mismatched types: expected bool \\\n+                                  #fmt[\"mismatched types: expected bool \\\n                                         or integer but found %s\",\n-                                       ty_to_str(tcx, oper_t)));\n+                                       ty_to_str(tcx, oper_t)]);\n             }\n           }\n           ast::neg. {\n             oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n             if !(ty::type_is_integral(tcx, oper_t) ||\n-                 ty::type_is_fp(tcx, oper_t)) {\n-                tcx.sess.span_err(expr.span, \"applying unary minus to \\\n-                   non-numeric type \" + ty_to_str(tcx, oper_t));\n+                     ty::type_is_fp(tcx, oper_t)) {\n+                tcx.sess.span_err(expr.span,\n+                                  \"applying unary minus to \\\n+                   non-numeric type \"\n+                                      + ty_to_str(tcx, oper_t));\n             }\n           }\n         }\n@@ -1883,9 +1899,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         bot = true;\n         alt expr_opt {\n           none. {/* do nothing */ }\n-          some(e) {\n-            check_expr_with(fcx, e, ty::mk_str(tcx));\n-          }\n+          some(e) { check_expr_with(fcx, e, ty::mk_str(tcx)); }\n         }\n         write::bot_ty(tcx, id);\n       }\n@@ -1901,15 +1915,13 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                                   \"ret; in function returning non-nil\");\n             }\n           }\n-          some(e) {\n-            check_expr_with(fcx, e, fcx.ret_ty);\n-          }\n+          some(e) { check_expr_with(fcx, e, fcx.ret_ty); }\n         }\n         write::bot_ty(tcx, id);\n       }\n       ast::expr_put(expr_opt) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n-        if (fcx.proto != ast::proto_iter) {\n+        if fcx.proto != ast::proto_iter {\n             tcx.sess.span_err(expr.span, \"put in non-iterator\");\n         }\n         alt expr_opt {\n@@ -1920,9 +1932,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                                   \"put; in iterator yielding non-nil\");\n             }\n           }\n-          some(e) {\n-            bot = check_expr_with(fcx, e, fcx.ret_ty);\n-          }\n+          some(e) { bot = check_expr_with(fcx, e, fcx.ret_ty); }\n         }\n         write::nil_ty(tcx, id);\n       }\n@@ -1942,8 +1952,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         write::nil_ty(tcx, id);\n       }\n       ast::expr_if_check(cond, thn, elsopt) {\n-        bot = check_pred_expr(fcx, cond) |\n-              check_then_else(fcx, thn, elsopt, id, expr.span);\n+        bot =\n+            check_pred_expr(fcx, cond) |\n+                check_then_else(fcx, thn, elsopt, id, expr.span);\n       }\n       ast::expr_ternary(_, _, _) {\n         bot = check_expr(fcx, ast::ternary_to_if(expr));\n@@ -1954,8 +1965,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n       }\n       ast::expr_copy(a) {\n         bot = check_expr_with_unifier(fcx, a, unify, expected);\n-        let tpot = ty::node_id_to_ty_param_substs_opt_and_ty(fcx.ccx.tcx,\n-                                                             a.id);\n+        let tpot =\n+            ty::node_id_to_ty_param_substs_opt_and_ty(fcx.ccx.tcx, a.id);\n         write::ty_fixup(fcx, id, tpot);\n \n       }\n@@ -1974,12 +1985,12 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n       ast::expr_assign_op(op, lhs, rhs) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n-        check_binop_type_compat(fcx, expr.span, expr_ty(tcx, lhs),\n-                                op);\n+        check_binop_type_compat(fcx, expr.span, expr_ty(tcx, lhs), op);\n       }\n       ast::expr_if(cond, thn, elsopt) {\n-        bot = check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n-              check_then_else(fcx, thn, elsopt, id, expr.span);\n+        bot =\n+            check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n+                check_then_else(fcx, thn, elsopt, id, expr.span);\n       }\n       ast::expr_for(decl, seq, body) {\n         bot = check_expr(fcx, seq);\n@@ -1990,24 +2001,27 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n           ty::ty_vec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n           ty::ty_istr. { elt_ty = ty::mk_mach(tcx, ast::ty_u8); }\n           _ {\n-            tcx.sess.span_fatal\n-                (expr.span, \"mismatched types: expected vector or string but \"\n-                 + \"found \" + ty_to_str(tcx, ety));\n+            tcx.sess.span_fatal(\n+                expr.span,\n+                \"mismatched types: expected vector or string but \"\n+                + \"found \" + ty_to_str(tcx, ety));\n           }\n         }\n         bot |= check_for_or_for_each(fcx, decl, elt_ty, body, id);\n       }\n       ast::expr_for_each(decl, seq, body) {\n-        alt (seq.node) {\n+        alt seq.node {\n           ast::expr_call(f, args) {\n-            bot = check_call_full(fcx, seq.span, f, args,\n-                                  kind_for_each, seq.id);\n+            bot =\n+                check_call_full(fcx, seq.span, f, args, kind_for_each,\n+                                seq.id);\n+          }\n+          _ {\n+            tcx.sess.span_fatal(expr.span,\n+                                \"sequence in for each loop not a call\");\n           }\n-          _ { tcx.sess.span_fatal(\n-              expr.span, \"sequence in for each loop not a call\"); }\n         }\n-        bot |= check_for_or_for_each(fcx, decl, expr_ty(tcx, seq),\n-                                     body, id);\n+        bot |= check_for_or_for_each(fcx, decl, expr_ty(tcx, seq), body, id);\n       }\n       ast::expr_while(cond, body) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx));\n@@ -2025,7 +2039,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         // bindings.\n         let pattern_ty = ty::expr_ty(tcx, expr);\n         for arm: ast::arm in arms {\n-            let id_map = ast::pat_id_map(arm.pats.(0));\n+            let id_map = ast::pat_id_map(arm.pats[0]);\n             for p: @ast::pat in arm.pats {\n                 check_pat(fcx, id_map, p, pattern_ty);\n             }\n@@ -2045,14 +2059,15 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n       ast::expr_fn(f) {\n         let cx = @{tcx: tcx};\n         let convert = bind ast_ty_to_ty_crate_tyvar(fcx, _);\n-        let ty_of_arg = lambda(a: &ast::arg) -> ty::arg {\n-            let ty_mode = ast_mode_to_mode(a.mode);\n-            let tt = ast_ty_to_ty_crate_tyvar(fcx, a.ty);\n-            ret {mode: ty_mode, ty: tt};\n-        };\n+        let ty_of_arg =\n+            lambda (a: &ast::arg) -> ty::arg {\n+                let ty_mode = ast_mode_to_mode(a.mode);\n+                let tt = ast_ty_to_ty_crate_tyvar(fcx, a.ty);\n+                ret {mode: ty_mode, ty: tt};\n+            };\n         let fty =\n             collect::ty_of_fn_decl(cx, convert, ty_of_arg, f.decl, f.proto,\n-                                   ~[], none).ty;\n+                                   [], none).ty;\n         write::ty_only_fixup(fcx, id, fty);\n \n         // Unify the type of the function with the expected type before we\n@@ -2065,10 +2080,11 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n       }\n       ast::expr_block(b) {\n         bot = check_block(fcx, b);\n-        let typ = alt b.node.expr {\n-          some(expr) { expr_ty(tcx, expr) }\n-          none. { ty::mk_nil(tcx) }\n-        };\n+        let typ =\n+            alt b.node.expr {\n+              some(expr) { expr_ty(tcx, expr) }\n+              none. { ty::mk_nil(tcx) }\n+            };\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_bind(f, args) {\n@@ -2077,7 +2093,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n \n         // Pull the argument and return types out.\n         let proto_1;\n-        let arg_tys_1: [ty::arg] = ~[];\n+        let arg_tys_1: [ty::arg] = [];\n         let rt_1;\n         let fty = expr_ty(tcx, f);\n         let t_1;\n@@ -2093,17 +2109,15 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             // to the resulting function type.\n             let i = 0u;\n             while i < vec::len::<option::t<@ast::expr>>(args) {\n-                alt args.(i) {\n+                alt args[i] {\n                   some(_) {/* no-op */ }\n-                  none. { arg_tys_1 += ~[arg_tys.(i)]; }\n+                  none. { arg_tys_1 += [arg_tys[i]]; }\n                 }\n                 i += 1u;\n             }\n             t_1 = ty::mk_fn(tcx, proto_1, arg_tys_1, rt_1, cf, constrs);\n           }\n-          _ {\n-            fail \"LHS of bind expr didn't have a function type?!\";\n-          }\n+          _ { fail \"LHS of bind expr didn't have a function type?!\"; }\n         }\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n@@ -2120,6 +2134,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             alt oinfo {\n               regular_obj(_, obj_id) {\n                 let did = local_def(obj_id);\n+\n                 // Try looking up the current object in the type\n                 // cache.\n                 alt tcx.tcache.find(did) {\n@@ -2131,7 +2146,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                   }\n                   none. {\n                     tcx.sess.bug(\"didn't find \" + int::str(did.node) +\n-                                 \" in type cache\");\n+                                     \" in type cache\");\n                   }\n                 }\n               }\n@@ -2172,42 +2187,40 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                  type_is_scalar(fcx, expr.span, t_1)) {\n             tcx.sess.span_err(expr.span,\n                               \"non-scalar cast: \" +\n-                              ty_to_str(tcx, expr_ty(tcx, e))\n-                              + \" as \" + ty_to_str(tcx, t_1));\n+                                  ty_to_str(tcx, expr_ty(tcx, e)) + \" as \" +\n+                                  ty_to_str(tcx, t_1));\n         }\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n       ast::expr_vec(args, mut) {\n         let t: ty::t = next_ty_var(fcx);\n-        for e: @ast::expr in args {\n-            bot |= check_expr_with(fcx, e, t);\n-        }\n+        for e: @ast::expr in args { bot |= check_expr_with(fcx, e, t); }\n         let typ = ty::mk_vec(tcx, {ty: t, mut: mut});\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_tup(elts) {\n-        let elt_ts = ~[];\n+        let elt_ts = [];\n         vec::reserve(elt_ts, vec::len(elts));\n         for e in elts {\n             check_expr(fcx, e);\n             let ety = expr_ty(fcx.ccx.tcx, e);\n-            elt_ts += ~[ety];\n+            elt_ts += [ety];\n         }\n         let typ = ty::mk_tup(fcx.ccx.tcx, elt_ts);\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_rec(fields, base) {\n         alt base { none. {/* no-op */ } some(b_0) { check_expr(fcx, b_0); } }\n-        let fields_t: [spanned<field>] = ~[];\n+        let fields_t: [spanned<field>] = [];\n         for f: ast::field in fields {\n             bot |= check_expr(fcx, f.node.expr);\n             let expr_t = expr_ty(tcx, f.node.expr);\n             let expr_mt = {ty: expr_t, mut: f.node.mut};\n             // for the most precise error message,\n             // should be f.node.expr.span, not f.span\n             fields_t +=\n-                ~[respan(f.node.expr.span,\n-                         {ident: f.node.ident, mt: expr_mt})];\n+                [respan(f.node.expr.span,\n+                        {ident: f.node.ident, mt: expr_mt})];\n         }\n         alt base {\n           none. {\n@@ -2218,7 +2231,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n           some(bexpr) {\n             bot |= check_expr(fcx, bexpr);\n             let bexpr_t = expr_ty(tcx, bexpr);\n-            let base_fields: [field] = ~[];\n+            let base_fields: [field] = [];\n             alt structure_of(fcx, expr.span, bexpr_t) {\n               ty::ty_rec(flds) { base_fields = flds; }\n               _ {\n@@ -2237,8 +2250,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                 }\n                 if !found {\n                     tcx.sess.span_fatal(f.span,\n-                                        \"unknown field in record update: \"\n-                                        + f.node.ident);\n+                                        \"unknown field in record update: \" +\n+                                            f.node.ident);\n                 }\n             }\n           }\n@@ -2250,30 +2263,29 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         base_t = do_autoderef(fcx, expr.span, base_t);\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_rec(fields) {\n-            let ix: uint =\n-                ty::field_idx(tcx.sess, expr.span, field, fields);\n+            let ix: uint = ty::field_idx(tcx.sess, expr.span, field, fields);\n             if ix >= vec::len::<ty::field>(fields) {\n                 tcx.sess.span_fatal(expr.span, \"bad index on record\");\n             }\n-            write::ty_only_fixup(fcx, id, fields.(ix).mt.ty);\n+            write::ty_only_fixup(fcx, id, fields[ix].mt.ty);\n           }\n           ty::ty_obj(methods) {\n             let ix: uint =\n                 ty::method_idx(tcx.sess, expr.span, field, methods);\n             if ix >= vec::len::<ty::method>(methods) {\n                 tcx.sess.span_fatal(expr.span, \"bad index on obj\");\n             }\n-            let meth = methods.(ix);\n+            let meth = methods[ix];\n             let t =\n-                ty::mk_fn(tcx, meth.proto, meth.inputs, meth.output,\n-                          meth.cf, meth.constrs);\n+                ty::mk_fn(tcx, meth.proto, meth.inputs, meth.output, meth.cf,\n+                          meth.constrs);\n             write::ty_only_fixup(fcx, id, t);\n           }\n           _ {\n             let t_err = resolve_type_vars_if_possible(fcx, base_t);\n             let msg =\n-                #fmt(\"attempted field access on type %s\",\n-                     ty_to_str(tcx, t_err));\n+                #fmt[\"attempted field access on type %s\",\n+                     ty_to_str(tcx, t_err)];\n             tcx.sess.span_fatal(expr.span, msg);\n           }\n         }\n@@ -2288,7 +2300,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             tcx.sess.span_err(idx.span,\n                               \"mismatched types: expected \\\n                                integer but found \"\n-                              + ty_to_str(tcx, idx_t));\n+                                  + ty_to_str(tcx, idx_t));\n         }\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_vec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n@@ -2303,12 +2315,12 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n           _ {\n             tcx.sess.span_fatal(expr.span,\n                                 \"vector-indexing bad type: \" +\n-                                ty_to_str(tcx, base_t));\n+                                    ty_to_str(tcx, base_t));\n           }\n         }\n       }\n       ast::expr_anon_obj(ao) {\n-        let fields: [ast::anon_obj_field] = ~[];\n+        let fields: [ast::anon_obj_field] = [];\n         alt ao.fields { none. { } some(v) { fields = v; } }\n \n         // FIXME: These next three functions are largely ripped off from\n@@ -2321,16 +2333,16 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         fn ty_of_method(ccx: @crate_ctxt, m: &@ast::method) -> ty::method {\n             let convert = bind ast_ty_to_ty_crate(ccx, _);\n \n-            let inputs = ~[];\n+            let inputs = [];\n             for aa: ast::arg in m.node.meth.decl.inputs {\n-                inputs += ~[ty_of_arg(ccx, aa)];\n+                inputs += [ty_of_arg(ccx, aa)];\n             }\n \n             let output = convert(m.node.meth.decl.output);\n \n-            let out_constrs = ~[];\n+            let out_constrs = [];\n             for constr: @ast::constr in m.node.meth.decl.constraints {\n-                out_constrs += ~[ty::ast_constr_to_constr(ccx.tcx, constr)];\n+                out_constrs += [ty::ast_constr_to_constr(ccx.tcx, constr)];\n             }\n \n             ret {proto: m.node.meth.proto,\n@@ -2341,18 +2353,18 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                  constrs: out_constrs};\n         }\n \n-        let method_types: [ty::method] = ~[];\n+        let method_types: [ty::method] = [];\n         {\n             // Outer methods.\n             for m: @ast::method in ao.methods {\n-                method_types += ~[ty_of_method(fcx.ccx, m)];\n+                method_types += [ty_of_method(fcx.ccx, m)];\n             }\n \n             // Inner methods.\n \n             // Typecheck 'inner_obj'.  If it exists, it had better have object\n             // type.\n-            let inner_obj_methods: [ty::method] = ~[];\n+            let inner_obj_methods: [ty::method] = [];\n             let inner_obj_ty: ty::t = ty::mk_nil(tcx);\n             let inner_obj_sty: option::t<ty::sty> = none;\n             alt ao.inner_obj {\n@@ -2371,9 +2383,11 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                       ty::ty_obj(ms) { inner_obj_methods = ms; }\n                       _ {\n                         // The user is trying to extend a non-object.\n-                        tcx.sess.span_fatal\n-                            (e.span, syntax::print::pprust::expr_to_str(e) +\n-                             \" does not have object type\");\n+                        tcx.sess.span_fatal(\n+                            e.span,\n+                            syntax::print::pprust::expr_to_str(e)\n+                            +\n+                            \" does not have object type\");\n                       }\n                     }\n                   }\n@@ -2382,16 +2396,15 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             }\n \n             fcx.ccx.obj_infos +=\n-                ~[anon_obj(vec::map(ast::obj_field_from_anon_obj_field,\n-                                     fields), inner_obj_sty)];\n+                [anon_obj(vec::map(ast::obj_field_from_anon_obj_field,\n+                                   fields), inner_obj_sty)];\n \n             // Whenever an outer method overrides an inner, we need to remove\n             // that inner from the type.  Filter inner_obj_methods to remove\n             // any methods that share a name with an outer method.\n-            fn filtering_fn(ccx: @crate_ctxt,\n-                            m: &ty::method,\n+            fn filtering_fn(ccx: @crate_ctxt, m: &ty::method,\n                             outer_obj_methods: [@ast::method]) ->\n-                option::t<ty::method> {\n+               option::t<ty::method> {\n \n                 for om: @ast::method in outer_obj_methods {\n                     if str::eq(om.node.ident, m.ident) {\n@@ -2401,8 +2414,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                         if new_type != m {\n                             ccx.tcx.sess.span_fatal(\n                                 om.span,\n-                                \"Attempted to override method \" +\n-                                m.ident + \" with one of a different type\");\n+                                \"Attempted to override method \"\n+                                + m.ident +\n+                                \" with one of a different type\");\n                         }\n                         ret none;\n                     }\n@@ -2426,9 +2440,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         // collect::convert for regular objects.)\n         let i = 0u;\n         while i < vec::len::<@ast::method>(ao.methods) {\n-            write::ty_only(tcx, ao.methods.(i).node.id,\n-                           ty::method_ty_to_fn_ty(tcx,\n-                                                  method_types.(i)));\n+            write::ty_only(tcx, ao.methods[i].node.id,\n+                           ty::method_ty_to_fn_ty(tcx, method_types[i]));\n             i += 1u;\n         }\n \n@@ -2447,9 +2460,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n       }\n       _ { tcx.sess.unimpl(\"expr type in typeck::check_expr\"); }\n     }\n-    if bot {\n-        write::ty_only_fixup(fcx, expr.id, ty::mk_bot(tcx));\n-    }\n+    if bot { write::ty_only_fixup(fcx, expr.id, ty::mk_bot(tcx)); }\n \n     unify(fcx, expr.span, expected, expr_ty(tcx, expr));\n     ret bot;\n@@ -2481,7 +2492,7 @@ fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) -> bool {\n     alt fcx.locals.find(local.node.id) {\n       none. {\n         fcx.ccx.tcx.sess.bug(\"check_decl_local: local id not found \" +\n-                             ident_for_local(local));\n+                                 ident_for_local(local));\n       }\n       some(i) {\n         let t = ty::mk_var(fcx.ccx.tcx, i);\n@@ -2523,11 +2534,13 @@ fn check_block(fcx: &@fn_ctxt, blk: &ast::blk) -> bool {\n     let warned = false;\n     for s: @ast::stmt in blk.node.stmts {\n         if bot && !warned &&\n-           alt s.node {\n-            ast::stmt_decl(@{node: ast::decl_local(_), _}, _) |\n-            ast::stmt_expr(_, _) { true }\n-            _ { false }\n-           } {\n+               alt s.node {\n+                 ast::stmt_decl(@{node: ast::decl_local(_), _}, _) |\n+                 ast::stmt_expr(_, _) {\n+                   true\n+                 }\n+                 _ { false }\n+               } {\n             fcx.ccx.tcx.sess.span_warn(s.span, \"unreachable statement\");\n             warned = true;\n         }\n@@ -2555,7 +2568,7 @@ fn check_const(ccx: &@crate_ctxt, _sp: &span, e: &@ast::expr,\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n     let rty = node_id_to_type(ccx.tcx, id);\n-    let fixups: [ast::node_id] = ~[];\n+    let fixups: [ast::node_id] = [];\n     let fcx: @fn_ctxt =\n         @{ret_ty: rty,\n           purity: ast::pure_fn,\n@@ -2574,7 +2587,7 @@ fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     let decl = f.decl;\n     let body = f.body;\n     let gather_result = gather_locals(ccx, f, id, old_fcx);\n-    let fixups: [ast::node_id] = ~[];\n+    let fixups: [ast::node_id] = [];\n     let fcx: @fn_ctxt =\n         @{ret_ty: ty::ty_fn_ret(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)),\n           purity: decl.purity,\n@@ -2588,6 +2601,7 @@ fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     check_block(fcx, body);\n     alt decl.purity {\n       ast::pure_fn. {\n+\n         // This just checks that the declared type is bool, and trusts\n         // that that's the actual return type.\n         if !ty::type_is_bool(ccx.tcx, fcx.ret_ty) {\n@@ -2598,16 +2612,17 @@ fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n       _ { }\n     }\n \n-// For non-iterator fns, we unify the tail expr's type with the\n-// function result type, if there is a tail expr.\n-// We don't do this check for an iterator, as the tail expr doesn't\n-// have to have the result type of the iterator.\n+    // For non-iterator fns, we unify the tail expr's type with the\n+    // function result type, if there is a tail expr.\n+    // We don't do this check for an iterator, as the tail expr doesn't\n+    // have to have the result type of the iterator.\n     if option::is_some(body.node.expr) && f.proto != ast::proto_iter {\n         let tail_expr = option::get(body.node.expr);\n         // The use of resolve_type_vars_if_possible makes me very\n         // afraid :-(\n-        let tail_expr_ty = resolve_type_vars_if_possible(\n-          fcx, expr_ty(ccx.tcx, tail_expr));\n+        let tail_expr_ty =\n+            resolve_type_vars_if_possible(fcx, expr_ty(ccx.tcx, tail_expr));\n+\n         // Hacky compromise: use eq and not are_compatible\n         // This allows things like while loops and ifs with no\n         // else to appear in tail position without a trailing\n@@ -2623,7 +2638,7 @@ fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     // force any remaining type vars to be resolved.\n     // If we have an enclosing function scope, our type variables will be\n     // resolved when the enclosing scope finishes up.\n-    if (option::is_none(old_fcx)) {\n+    if option::is_none(old_fcx) {\n         writeback::resolve_type_vars_in_block(fcx, body);\n     }\n }\n@@ -2639,7 +2654,7 @@ fn check_item(ccx: @crate_ctxt, it: &@ast::item) {\n       ast::item_res(f, dtor_id, _, _) { check_fn(ccx, f, dtor_id, none); }\n       ast::item_obj(ob, _, _) {\n         // We're entering an object, so gather up the info we need.\n-        ccx.obj_infos += ~[regular_obj(ob.fields, it.id)];\n+        ccx.obj_infos += [regular_obj(ob.fields, it.id)];\n \n         // Typecheck the methods.\n         for method: @ast::method in ob.methods { check_method(ccx, method); }\n@@ -2672,17 +2687,19 @@ fn check_main_fn_ty(tcx: &ty::ctxt, main_id: &ast::node_id) {\n         ok &= ty::type_is_nil(tcx, rs);\n         let num_args = vec::len(args);\n         ok &=\n-            num_args == 0u || num_args == 1u && arg_is_argv_ty(tcx, args.(0));\n+            num_args == 0u || num_args == 1u && arg_is_argv_ty(tcx, args[0]);\n         if !ok {\n             let span = ast_map::node_span(tcx.items.get(main_id));\n-            tcx.sess.span_err(span, \"wrong type in main function: found \" +\n-                              ty_to_str(tcx, main_t));\n+            tcx.sess.span_err(span,\n+                              \"wrong type in main function: found \" +\n+                                  ty_to_str(tcx, main_t));\n         }\n       }\n       _ {\n         let span = ast_map::node_span(tcx.items.get(main_id));\n-        tcx.sess.span_bug(span, \"main has a non-function type: found\" +\n-                          ty_to_str(tcx, main_t));\n+        tcx.sess.span_bug(span,\n+                          \"main has a non-function type: found\" +\n+                              ty_to_str(tcx, main_t));\n       }\n     }\n }\n@@ -2699,12 +2716,12 @@ fn check_for_main_fn(tcx: &ty::ctxt, crate: &@ast::crate) {\n fn check_crate(tcx: &ty::ctxt, crate: &@ast::crate) {\n     collect::collect_item_types(tcx, crate);\n \n-    let obj_infos: [obj_info] = ~[];\n+    let obj_infos: [obj_info] = [];\n \n     let ccx = @{mutable obj_infos: obj_infos, tcx: tcx};\n-    let visit = visit::mk_simple_visitor\n-        (@{visit_item: bind check_item(ccx, _)\n-           with *visit::default_simple_visitor()});\n+    let visit =\n+        visit::mk_simple_visitor(@{visit_item: bind check_item(ccx, _)\n+                                      with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visit);\n     check_for_main_fn(tcx, crate);\n     tcx.sess.abort_if_errors();"}, {"sha": "80d327b119b5e9afd849d33807a298238c1e07c2", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -49,13 +49,15 @@ tag def {\n     def_arg(def_id);\n     def_local(def_id);\n     def_variant(def_id, /* tag */def_id);\n+\n     /* variant */\n     def_ty(def_id);\n     def_ty_arg(uint, kind);\n     def_binding(def_id);\n     def_use(def_id);\n     def_native_ty(def_id);\n     def_native_fn(def_id);\n+\n     /* A \"fake\" def for upvars. This never appears in the def_map, but\n      * freevars::def_lookup will return it for a def that is an upvar.\n      * It contains the actual def. */\n@@ -77,7 +79,7 @@ fn def_id_of_def(d: def) -> def_id {\n       def_local(id) { ret id; }\n       def_variant(_, id) { ret id; }\n       def_ty(id) { ret id; }\n-      def_ty_arg(_,_) { fail; }\n+      def_ty_arg(_, _) { fail; }\n       def_binding(id) { ret id; }\n       def_use(id) { ret id; }\n       def_native_ty(id) { ret id; }\n@@ -100,10 +102,7 @@ type crate_ =\n \n tag crate_directive_ {\n     cdir_src_mod(ident, option::t<filename>, [attribute]);\n-    cdir_dir_mod(ident,\n-                 option::t<filename>,\n-                 [@crate_directive],\n-                 [attribute]);\n+    cdir_dir_mod(ident, option::t<filename>, [@crate_directive], [attribute]);\n     cdir_view_item(@view_item);\n     cdir_syntax(path);\n     cdir_auth(path, _auth);\n@@ -155,30 +154,22 @@ iter pat_bindings(pat: &@pat) -> @pat {\n     alt pat.node {\n       pat_bind(_) { put pat; }\n       pat_tag(_, sub) {\n-        for p in sub {\n-            for each b in pat_bindings(p) { put b; }\n-        }\n+        for p in sub { for each b in pat_bindings(p) { put b; } }\n       }\n       pat_rec(fields, _) {\n-        for f in fields {\n-            for each b in pat_bindings(f.pat) { put b; }\n-        }\n+        for f in fields { for each b in pat_bindings(f.pat) { put b; } }\n       }\n       pat_tup(elts) {\n-        for elt in elts {\n-            for each b in pat_bindings(elt) { put b; }\n-        }\n-      }\n-      pat_box(sub) {\n-        for each b in pat_bindings(sub) { put b; }\n+        for elt in elts { for each b in pat_bindings(elt) { put b; } }\n       }\n-      pat_wild. | pat_lit(_) {}\n+      pat_box(sub) { for each b in pat_bindings(sub) { put b; } }\n+      pat_wild. | pat_lit(_) { }\n     }\n }\n \n fn pat_binding_ids(pat: &@pat) -> [node_id] {\n-    let found = ~[];\n-    for each b in pat_bindings(pat) { found += ~[b.id]; }\n+    let found = [];\n+    for each b in pat_bindings(pat) { found += [b.id]; }\n     ret found;\n }\n \n@@ -258,6 +249,7 @@ type stmt = spanned<stmt_>;\n tag stmt_ {\n     stmt_decl(@decl, node_id);\n     stmt_expr(@expr, node_id);\n+\n     // These only exist in crate-level blocks.\n     stmt_crate_directive(@crate_directive);\n }\n@@ -266,10 +258,8 @@ tag init_op { init_assign; init_move; }\n \n type initializer = {op: init_op, expr: @expr};\n \n-type local_ = {ty: @ty,\n-               pat: @pat, // FIXME: should really be a refinement on pat\n-               init: option::t<initializer>,\n-               id: node_id};\n+type local_ =  // FIXME: should really be a refinement on pat\n+    {ty: @ty, pat: @pat, init: option::t<initializer>, id: node_id};\n \n type local = spanned<local_>;\n \n@@ -312,6 +302,7 @@ tag expr_ {\n     expr_alt(@expr, [arm]);\n     expr_fn(_fn);\n     expr_block(blk);\n+\n     /*\n      * FIXME: many of these @exprs should be constrained with\n      * is_lval once we have constrained types working.\n@@ -331,10 +322,13 @@ tag expr_ {\n     expr_put(option::t<@expr>);\n     expr_be(@expr);\n     expr_log(int, @expr);\n+\n     /* just an assert, no significance to typestate */\n     expr_assert(@expr);\n+\n     /* preds that typestate is aware of */\n     expr_check(check_mode, @expr);\n+\n     /* FIXME Would be nice if expr_check desugared\n        to expr_if_check. */\n     expr_if_check(@expr, blk, option::t<@expr>);\n@@ -428,10 +422,11 @@ tag ty_ {\n     ty_bot; /* return type of ! functions and type of\n              ret/fail/break/cont. there is no syntax\n              for this type. */\n+\n      /* bot represents the value of functions that don't return a value\n         locally to their context. in contrast, things like log that do\n         return, but don't return a meaningful value, have result type nil. */\n-    ty_bool;\n+     ty_bool;\n     ty_int;\n     ty_uint;\n     ty_float;\n@@ -453,6 +448,7 @@ tag ty_ {\n     ty_type;\n     ty_constr(@ty, [@ty_constr]);\n     ty_mac(mac);\n+\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n     // nested in one.\n@@ -514,6 +510,7 @@ tag purity {\n tag controlflow {\n     noreturn; // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n+\n     return; // everything else\n }\n \n@@ -531,9 +528,9 @@ type _obj = {fields: [obj_field], methods: [@method]};\n \n type anon_obj =\n     // New fields and methods, if they exist.\n+    // inner_obj: the original object being extended, if it exists.\n     {fields: option::t<[anon_obj_field]>,\n      methods: [@method],\n-     // inner_obj: the original object being extended, if it exists.\n      inner_obj: option::t<@expr>};\n \n type _mod = {view_items: [@view_item], items: [@item]};\n@@ -601,10 +598,14 @@ tag item_ {\n     item_ty(@ty, [ty_param]);\n     item_tag([variant], [ty_param]);\n     item_obj(_obj, [ty_param], /* constructor id */node_id);\n-    item_res(_fn, /* dtor */\n-             node_id, /* dtor id */\n+    item_res(_fn,\n+              /* dtor */\n+             node_id,\n+              /* dtor id */\n              [ty_param],\n-             node_id /* ctor id */);\n+\n+             /* ctor id */\n+             node_id);\n }\n \n type native_item =\n@@ -637,11 +638,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     for vi: @ast::view_item in m.view_items {\n         alt vi.node {\n           ast::view_item_export(ids, _) {\n-            for id in ids {\n-                if str::eq(i, id) {\n-                    ret true;\n-                }\n-            }\n+            for id in ids { if str::eq(i, id) { ret true; } }\n             count += 1u;\n           }\n           _ {/* fall through */ }\n@@ -670,7 +667,7 @@ fn eq_ty(a: &@ty, b: &@ty) -> bool { ret std::box::ptr_eq(a, b); }\n fn hash_ty(t: &@ty) -> uint { ret t.span.lo << 16u + t.span.hi; }\n \n fn block_from_expr(e: @expr) -> blk {\n-    let blk_ = {stmts: ~[], expr: option::some::<@expr>(e), id: e.id};\n+    let blk_ = {stmts: [], expr: option::some::<@expr>(e), id: e.id};\n     ret {node: blk_, span: e.span};\n }\n "}, {"sha": "a52a58e629e0e70f3506b4b1d758ad9e5ee156dc", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -23,36 +23,36 @@ type codemap = @{mutable files: [filemap]};\n \n type loc = {filename: filename, line: uint, col: uint};\n \n-fn new_codemap() -> codemap { ret @{mutable files: ~[]}; }\n+fn new_codemap() -> codemap { ret @{mutable files: []}; }\n \n fn new_filemap(filename: filename, start_pos_ch: uint, start_pos_byte: uint)\n    -> filemap {\n     ret @{name: filename,\n           start_pos: {ch: start_pos_ch, byte: start_pos_byte},\n-          mutable lines: ~[{ch: start_pos_ch, byte: start_pos_byte}]};\n+          mutable lines: [{ch: start_pos_ch, byte: start_pos_byte}]};\n }\n \n fn next_line(file: filemap, chpos: uint, byte_pos: uint) {\n-    file.lines += ~[{ch: chpos, byte: byte_pos}];\n+    file.lines += [{ch: chpos, byte: byte_pos}];\n }\n \n-type lookup_fn = fn(file_pos) -> uint ;\n+type lookup_fn = fn(file_pos) -> uint;\n \n fn lookup_pos(map: codemap, pos: uint, lookup: lookup_fn) -> loc {\n     let a = 0u;\n     let b = vec::len(map.files);\n     while b - a > 1u {\n         let m = (a + b) / 2u;\n-        if lookup(map.files.(m).start_pos) > pos { b = m; } else { a = m; }\n+        if lookup(map.files[m].start_pos) > pos { b = m; } else { a = m; }\n     }\n-    let f = map.files.(a);\n+    let f = map.files[a];\n     a = 0u;\n     b = vec::len(f.lines);\n     while b - a > 1u {\n         let m = (a + b) / 2u;\n-        if lookup(f.lines.(m)) > pos { b = m; } else { a = m; }\n+        if lookup(f.lines[m]) > pos { b = m; } else { a = m; }\n     }\n-    ret {filename: f.name, line: a + 1u, col: pos - lookup(f.lines.(a))};\n+    ret {filename: f.name, line: a + 1u, col: pos - lookup(f.lines[a])};\n }\n \n fn lookup_char_pos(map: codemap, pos: uint) -> loc {\n@@ -65,7 +65,8 @@ fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n     ret lookup_pos(map, pos, lookup);\n }\n \n-tag opt_span { //hack (as opposed to option::t), to make `span` compile\n+tag opt_span {\n+     //hack (as opposed to option::t), to make `span` compile\n     os_none;\n     os_some(@span);\n }\n@@ -75,13 +76,14 @@ fn span_to_str(sp: &span, cm: &codemap) -> str {\n     let cur = sp;\n     let res = \"\";\n     let prev_file = none;\n-    while(true) {\n+    while true {\n         let lo = lookup_char_pos(cm, cur.lo);\n         let hi = lookup_char_pos(cm, cur.hi);\n-        res += #fmt(\"%s:%u:%u:%u:%u\",\n-                    if some(lo.filename) == prev_file { \"-\" }\n-                    else                              { lo.filename },\n-                    lo.line, lo.col, hi.line, hi.col);\n+        res +=\n+            #fmt[\"%s:%u:%u:%u:%u\",\n+                 if some(lo.filename) == prev_file {\n+                     \"-\"\n+                 } else { lo.filename }, lo.line, lo.col, hi.line, hi.col];\n         alt cur.expanded_from {\n           os_none. { break; }\n           os_some(new_sp) {\n@@ -110,11 +112,9 @@ fn emit_diagnostic(sp: &option::t<span>, msg: &str, kind: &str, color: u8,\n     if term::color_supported() {\n         term::fg(io::stdout().get_buf_writer(), color);\n     }\n-    io::stdout().write_str(#fmt(\"%s:\", kind));\n-    if term::color_supported() {\n-        term::reset(io::stdout().get_buf_writer());\n-    }\n-    io::stdout().write_str(#fmt(\" %s\\n\", msg));\n+    io::stdout().write_str(#fmt[\"%s:\", kind]);\n+    if term::color_supported() { term::reset(io::stdout().get_buf_writer()); }\n+    io::stdout().write_str(#fmt[\" %s\\n\", msg]);\n \n     maybe_highlight_lines(sp, cm, maybe_lines);\n }\n@@ -143,14 +143,14 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n         }\n         // Print the offending lines\n         for line: uint in display_lines {\n-            io::stdout().write_str(#fmt(\"%s:%u \", fm.name, line + 1u));\n+            io::stdout().write_str(#fmt[\"%s:%u \", fm.name, line + 1u]);\n             let s = get_line(fm, line as int, file);\n             if !str::ends_with(s, \"\\n\") { s += \"\\n\"; }\n             io::stdout().write_str(s);\n         }\n         if elided {\n-            let last_line = display_lines.(vec::len(display_lines) - 1u);\n-            let s = #fmt(\"%s:%u \", fm.name, last_line + 1u);\n+            let last_line = display_lines[vec::len(display_lines) - 1u];\n+            let s = #fmt[\"%s:%u \", fm.name, last_line + 1u];\n             let indent = str::char_len(s);\n             let out = \"\";\n             while indent > 0u { out += \" \"; indent -= 1u; }\n@@ -163,7 +163,7 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n         if vec::len(lines.lines) == 1u {\n             let lo = lookup_char_pos(cm, option::get(sp).lo);\n             let digits = 0u;\n-            let num = lines.lines.(0) / 10u;\n+            let num = lines.lines[0] / 10u;\n \n             // how many digits must be indent past?\n             while num > 0u { num /= 10u; digits += 1u; }\n@@ -202,18 +202,18 @@ type file_lines = {name: str, lines: [uint]};\n fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n-    let lines = ~[];\n+    let lines = [];\n     for each i: uint in uint::range(lo.line - 1u, hi.line as uint) {\n-        lines += ~[i];\n+        lines += [i];\n     }\n     ret @{name: lo.filename, lines: lines};\n }\n \n fn get_line(fm: filemap, line: int, file: &str) -> str {\n-    let begin: uint = fm.lines.(line).byte - fm.start_pos.byte;\n+    let begin: uint = fm.lines[line].byte - fm.start_pos.byte;\n     let end: uint;\n     if line as uint < vec::len(fm.lines) - 1u {\n-        end = fm.lines.(line + 1).byte - fm.start_pos.byte;\n+        end = fm.lines[line + 1].byte - fm.start_pos.byte;\n     } else {\n         // If we're not done parsing the file, we're at the limit of what's\n         // parsed. If we just slice the rest of the string, we'll print out\n@@ -232,7 +232,6 @@ fn get_filemap(cm: codemap, filename: str) -> filemap {\n     //      (or expected function, found _|_)\n     fail; // (\"asking for \" + filename + \" which we don't know about\");\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "6d1bd6626c2e2b0e38e9dc2ca48fe00928bea231", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -7,10 +7,10 @@ import std::map::new_str_hash;\n import codemap;\n \n type syntax_expander =\n-    fn(&ext_ctxt, span, @ast::expr, option::t<str>) -> @ast::expr ;\n+    fn(&ext_ctxt, span, @ast::expr, option::t<str>) -> @ast::expr;\n type macro_def = {ident: str, ext: syntax_extension};\n type macro_definer =\n-    fn(&ext_ctxt, span, @ast::expr, option::t<str>) -> macro_def ;\n+    fn(&ext_ctxt, span, @ast::expr, option::t<str>) -> macro_def;\n \n tag syntax_extension {\n     normal(syntax_expander);\n@@ -34,20 +34,22 @@ fn syntax_expander_table() -> hashmap<str, syntax_extension> {\n     ret syntax_expanders;\n }\n \n-obj ext_ctxt(sess: @session, crate_file_name_hack: str,\n+obj ext_ctxt(sess: @session,\n+             crate_file_name_hack: str,\n              mutable backtrace: codemap::opt_span) {\n     fn crate_file_name() -> str { ret crate_file_name_hack; }\n \n     fn session() -> @session { ret sess; }\n \n-    fn print_backtrace() {\n-    }\n+    fn print_backtrace() { }\n \n     fn backtrace() -> codemap::opt_span { ret backtrace; }\n \n     fn bt_push(sp: span) {\n-        backtrace = codemap::os_some(@{lo: sp.lo, hi: sp.hi,\n-                                       expanded_from: backtrace});\n+        backtrace =\n+            codemap::os_some(@{lo: sp.lo,\n+                               hi: sp.hi,\n+                               expanded_from: backtrace});\n     }\n     fn bt_pop() {\n         alt backtrace {\n@@ -67,21 +69,16 @@ obj ext_ctxt(sess: @session, crate_file_name_hack: str,\n         self.print_backtrace();\n         sess.span_err(sp, msg);\n     }\n-    fn span_unimpl(sp:span, msg: str) -> ! {\n+    fn span_unimpl(sp: span, msg: str) -> ! {\n         self.print_backtrace();\n         sess.span_unimpl(sp, msg);\n     }\n-    fn span_bug(sp:span, msg: str) -> ! {\n+    fn span_bug(sp: span, msg: str) -> ! {\n         self.print_backtrace();\n         sess.span_bug(sp, msg);\n     }\n-    fn bug(msg: str) -> ! {\n-        self.print_backtrace();\n-        sess.bug(msg);\n-    }\n-    fn next_id() -> ast::node_id {\n-        ret sess.next_node_id();\n-    }\n+    fn bug(msg: str) -> ! { self.print_backtrace(); sess.bug(msg); }\n+    fn next_id() -> ast::node_id { ret sess.next_node_id(); }\n \n }\n \n@@ -93,7 +90,7 @@ fn mk_ctxt(sess: &session) -> ext_ctxt {\n     // the extensions the file name of the crate being compiled so they can\n     // use it to guess whether paths should be prepended with \"std::\". This is\n     // super-ugly and needs a better solution.\n-    let crate_file_name_hack = sess.get_codemap().files.(0).name;\n+    let crate_file_name_hack = sess.get_codemap().files[0].name;\n \n     ret ext_ctxt(@sess, crate_file_name_hack, codemap::os_none);\n }\n@@ -115,7 +112,7 @@ fn expr_to_ident(cx: &ext_ctxt, expr: @ast::expr, error: str) -> ast::ident {\n       ast::expr_path(p) {\n         if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u {\n             cx.span_fatal(expr.span, error);\n-        } else { ret p.node.idents.(0); }\n+        } else { ret p.node.idents[0]; }\n       }\n       _ { cx.span_fatal(expr.span, error); }\n     }"}, {"sha": "466f55e60e630a1ce57889818a3cf003eb6edc46", "filename": "src/comp/syntax/ext/concat_idents.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -4,18 +4,21 @@ import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n                      _body: option::t<str>) -> @ast::expr {\n-    let args: [@ast::expr] = alt arg.node {\n-      ast::expr_vec(elts, _) { elts }\n-      _ { cx.span_fatal(sp, \"#concat_idents requires a vector argument .\") }\n-    };\n+    let args: [@ast::expr] =\n+        alt arg.node {\n+          ast::expr_vec(elts, _) { elts }\n+          _ {\n+            cx.span_fatal(sp, \"#concat_idents requires a vector argument .\")\n+          }\n+        };\n     let res: ast::ident = \"\";\n     for e: @ast::expr in args {\n         res += expr_to_ident(cx, e, \"expected an ident\");\n     }\n \n     ret @{id: cx.next_id(),\n-          node: ast::expr_path( {\n-              node: {global: false, idents: ~[res], types: ~[]},\n-              span: sp}),\n+          node:\n+              ast::expr_path({node: {global: false, idents: [res], types: []},\n+                              span: sp}),\n           span: sp};\n }"}, {"sha": "52a738ab97faa5df4d979461ab4a316e6dae7e3b", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -12,17 +12,20 @@ export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n                      _body: option::t<str>) -> @ast::expr {\n-    let args: [@ast::expr] = alt arg.node {\n-      ast::expr_vec(elts, _) { elts }\n-      _ { cx.span_fatal(sp, \"#env requires arguments of the form `[...]`.\") }\n-    };\n+    let args: [@ast::expr] =\n+        alt arg.node {\n+          ast::expr_vec(elts, _) { elts }\n+          _ {\n+            cx.span_fatal(sp, \"#env requires arguments of the form `[...]`.\")\n+          }\n+        };\n     if vec::len::<@ast::expr>(args) != 1u {\n         cx.span_fatal(sp, \"malformed #env call\");\n     }\n     // FIXME: if this was more thorough it would manufacture an\n     // option::t<str> rather than just an maybe-empty string.\n \n-    let var = expr_to_str(cx, args.(0), \"#env requires a string\");\n+    let var = expr_to_str(cx, args[0], \"#env requires a string\");\n     alt generic_os::getenv(var) {\n       option::none. { ret make_new_str(cx, sp, \"\"); }\n       option::some(s) { ret make_new_str(cx, sp, s); }"}, {"sha": "149216aa6cd7e467f62d7577e6774812e1ad661b", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -15,14 +15,14 @@ import syntax::ext::base::*;\n \n \n fn expand_expr(exts: &hashmap<str, syntax_extension>, cx: &ext_ctxt,\n-               e: &expr_, fld: ast_fold,\n-               orig: &fn(&expr_, ast_fold) -> expr_ ) -> expr_ {\n+               e: &expr_, fld: ast_fold, orig: &fn(&expr_, ast_fold) -> expr_)\n+   -> expr_ {\n     ret alt e {\n           expr_mac(mac) {\n             alt mac.node {\n               mac_invoc(pth, args, body) {\n                 assert (vec::len(pth.node.idents) > 0u);\n-                let extname = pth.node.idents.(0);\n+                let extname = pth.node.idents[0];\n                 alt exts.find(extname) {\n                   none. {\n                     cx.span_fatal(pth.span,\n@@ -41,7 +41,7 @@ fn expand_expr(exts: &hashmap<str, syntax_extension>, cx: &ext_ctxt,\n                   some(macro_defining(ext)) {\n                     let named_extension = ext(cx, pth.span, args, body);\n                     exts.insert(named_extension.ident, named_extension.ext);\n-                    ast::expr_rec(~[], none)\n+                    ast::expr_rec([], none)\n                   }\n                 }\n               }\n@@ -65,7 +65,6 @@ fn expand_crate(sess: &session::session, c: &@crate) -> @crate {\n     ret res;\n \n }\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "9b8a1b616847f87289136a7b40d20cc84287cbec", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -17,17 +17,20 @@ export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n                      _body: option::t<str>) -> @ast::expr {\n-    let args: [@ast::expr] = alt arg.node {\n-      ast::expr_vec(elts, _) { elts }\n-      _ { cx.span_fatal(sp, \"#fmt requires arguments of the form `[...]`.\") }\n-    };\n+    let args: [@ast::expr] =\n+        alt arg.node {\n+          ast::expr_vec(elts, _) { elts }\n+          _ {\n+            cx.span_fatal(sp, \"#fmt requires arguments of the form `[...]`.\")\n+          }\n+        };\n     if vec::len::<@ast::expr>(args) == 0u {\n         cx.span_fatal(sp, \"#fmt requires a format string\");\n     }\n     let fmt =\n-        expr_to_str(cx, args.(0),\n+        expr_to_str(cx, args[0],\n                     \"first argument to #fmt must be a \" + \"string literal.\");\n-    let fmtspan = args.(0).span;\n+    let fmtspan = args[0].span;\n     log \"Format string:\";\n     log fmt;\n     fn parse_fmt_err_(cx: &ext_ctxt, sp: span, msg: str) -> ! {\n@@ -66,7 +69,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     }\n     fn make_path_expr(cx: &ext_ctxt, sp: span, idents: &[ast::ident]) ->\n        @ast::expr {\n-        let path = {global: false, idents: idents, types: ~[]};\n+        let path = {global: false, idents: idents, types: []};\n         let sp_path = {node: path, span: sp};\n         let pathexpr = ast::expr_path(sp_path);\n         ret @{id: cx.next_id(), node: pathexpr, span: sp};\n@@ -85,13 +88,13 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     fn make_rec_expr(cx: &ext_ctxt, sp: span,\n                      fields: &[{ident: ast::ident, ex: @ast::expr}]) ->\n        @ast::expr {\n-        let astfields: [ast::field] = ~[];\n+        let astfields: [ast::field] = [];\n         for field: {ident: ast::ident, ex: @ast::expr} in fields {\n             let ident = field.ident;\n             let val = field.ex;\n             let astfield =\n                 {node: {mut: ast::imm, ident: ident, expr: val}, span: sp};\n-            astfields += ~[astfield];\n+            astfields += [astfield];\n         }\n         let recexpr = ast::expr_rec(astfields, option::none::<@ast::expr>);\n         ret @{id: cx.next_id(), node: recexpr, span: sp};\n@@ -101,8 +104,8 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             ret str::find(cx.crate_file_name(), \"std.rc\") >= 0;\n         }\n         if compiling_std(cx) {\n-            ret ~[\"extfmt\", \"rt\", ident];\n-        } else { ret ~[\"std\", \"extfmt\", \"rt\", ident]; }\n+            ret [\"extfmt\", \"rt\", ident];\n+        } else { ret [\"std\", \"extfmt\", \"rt\", ident]; }\n     }\n     fn make_rt_path_expr(cx: &ext_ctxt, sp: span, ident: str) -> @ast::expr {\n         let path = make_path_vec(cx, ident);\n@@ -112,9 +115,8 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     // which tells the RT::conv* functions how to perform the conversion\n \n     fn make_rt_conv_expr(cx: &ext_ctxt, sp: span, cnv: &conv) -> @ast::expr {\n-        fn make_flags(cx: &ext_ctxt, sp: span, flags: &[flag]) ->\n-           @ast::expr {\n-            let flagexprs: [@ast::expr] = ~[];\n+        fn make_flags(cx: &ext_ctxt, sp: span, flags: &[flag]) -> @ast::expr {\n+            let flagexprs: [@ast::expr] = [];\n             for f: flag in flags {\n                 let fstr;\n                 alt f {\n@@ -124,14 +126,14 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                   flag_sign_always. { fstr = \"flag_sign_always\"; }\n                   flag_alternate. { fstr = \"flag_alternate\"; }\n                 }\n-                flagexprs += ~[make_rt_path_expr(cx, sp, fstr)];\n+                flagexprs += [make_rt_path_expr(cx, sp, fstr)];\n             }\n             // FIXME: 0-length vectors can't have their type inferred\n             // through the rec that these flags are a member of, so\n             // this is a hack placeholder flag\n \n             if vec::len::<@ast::expr>(flagexprs) == 0u {\n-                flagexprs += ~[make_rt_path_expr(cx, sp, \"flag_none\")];\n+                flagexprs += [make_rt_path_expr(cx, sp, \"flag_none\")];\n             }\n             ret make_vec_expr(cx, sp, flagexprs);\n         }\n@@ -143,7 +145,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n               count_is(c) {\n                 let count_lit = make_new_int(cx, sp, c);\n                 let count_is_path = make_path_vec(cx, \"count_is\");\n-                let count_is_args = ~[count_lit];\n+                let count_is_args = [count_lit];\n                 ret make_call(cx, sp, count_is_path, count_is_args);\n               }\n               _ { cx.span_unimpl(sp, \"unimplemented #fmt conversion\"); }\n@@ -168,10 +170,10 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             ret make_rec_expr(cx, sp,\n-                              ~[{ident: \"flags\", ex: flags_expr},\n-                                {ident: \"width\", ex: width_expr},\n-                                {ident: \"precision\", ex: precision_expr},\n-                                {ident: \"ty\", ex: ty_expr}]);\n+                              [{ident: \"flags\", ex: flags_expr},\n+                               {ident: \"width\", ex: width_expr},\n+                               {ident: \"precision\", ex: precision_expr},\n+                               {ident: \"ty\", ex: ty_expr}]);\n         }\n         let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         let rt_conv_width = make_count(cx, sp, cnv.width);\n@@ -185,7 +187,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n         let fname = \"conv_\" + conv_type;\n         let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n-        let args = ~[cnv_expr, arg];\n+        let args = [cnv_expr, arg];\n         ret make_call(cx, arg.span, path, args);\n     }\n     fn make_new_conv(cx: &ext_ctxt, sp: span, cnv: conv, arg: @ast::expr) ->\n@@ -304,7 +306,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n           ty_octal. { log \"type: octal\"; }\n         }\n     }\n-    let fmt_sp = args.(0).span;\n+    let fmt_sp = args[0].span;\n     let n = 0u;\n     let tmp_expr = make_new_str(cx, sp, \"\");\n     let nargs = vec::len::<@ast::expr>(args);\n@@ -323,7 +325,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             }\n             log \"Building conversion:\";\n             log_conv(conv);\n-            let arg_expr = args.(n);\n+            let arg_expr = args[n];\n             let c_expr = make_new_conv(cx, fmt_sp, conv, arg_expr);\n             tmp_expr = make_add_expr(cx, fmt_sp, tmp_expr, c_expr);\n           }\n@@ -332,9 +334,10 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     let expected_nargs = n + 1u; // n conversions + the fmt string\n \n     if expected_nargs < nargs {\n-        cx.span_fatal\n-            (sp, #fmt(\"too many arguments to #fmt. found %u, expected %u\",\n-                      nargs, expected_nargs));\n+        cx.span_fatal(\n+            sp,\n+            #fmt[\"too many arguments to #fmt. found %u, expected %u\",\n+                 nargs, expected_nargs]);\n     }\n     ret tmp_expr;\n }"}, {"sha": "4eb381762fe9222b8d4f9b7fc5ea414a7798d811", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -5,16 +5,19 @@ import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n                      _body: option::t<str>) -> @ast::expr {\n-    let args: [@ast::expr] = alt arg.node {\n-      ast::expr_vec(elts, _) { elts }\n-      _ { cx.span_fatal(sp, \"#ident_to_str requires a vector argument .\") }\n-    };\n+    let args: [@ast::expr] =\n+        alt arg.node {\n+          ast::expr_vec(elts, _) { elts }\n+          _ {\n+            cx.span_fatal(sp, \"#ident_to_str requires a vector argument .\")\n+          }\n+        };\n     if vec::len::<@ast::expr>(args) != 1u {\n         cx.span_fatal(sp, \"malformed #ident_to_str call\");\n     }\n \n     ret make_new_lit(cx, sp,\n-                     ast::lit_str(expr_to_ident(cx, args.(0u),\n+                     ast::lit_str(expr_to_ident(cx, args[0u],\n                                                 \"expected an ident\"),\n                                   ast::sk_rc));\n "}, {"sha": "a03ff11a66d42d41371078d2029787e5efd856d5", "filename": "src/comp/syntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -9,5 +9,5 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n     std::io::stdout().write_line(print::pprust::expr_to_str(arg));\n \n     //trivial expression\n-    ret @{id: cx.next_id(), node: ast::expr_rec(~[], option::none), span: sp};\n+    ret @{id: cx.next_id(), node: ast::expr_rec([], option::none), span: sp};\n }"}, {"sha": "e5dd343203a39da9b269c4490f6ea5569d39446a", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 70, "deletions": 67, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -34,7 +34,7 @@ export add_new_extension;\n \n fn path_to_ident(pth: &path) -> option::t<ident> {\n     if vec::len(pth.node.idents) == 1u && vec::len(pth.node.types) == 0u {\n-        ret some(pth.node.idents.(0u));\n+        ret some(pth.node.idents[0u]);\n     }\n     ret none;\n }\n@@ -89,10 +89,10 @@ fn match_error(cx: &ext_ctxt, m: &matchable, expected: &str) -> ! {\n // we'll want to return something indicating amount of progress and location\n // of failure instead of `none`.\n type match_result = option::t<arb_depth<matchable>>;\n-type selector = fn(&matchable) -> match_result ;\n+type selector = fn(&matchable) -> match_result;\n \n-fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n-    -> {pre: [@expr], rep: option::t<@expr>, post: [@expr]} {\n+fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr]) ->\n+   {pre: [@expr], rep: option::t<@expr>, post: [@expr]} {\n     let idx: uint = 0u;\n     let res = none;\n     for elt: @expr in elts {\n@@ -103,10 +103,10 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n                 if res != none {\n                     cx.span_fatal(m.span, \"only one ellipsis allowed\");\n                 }\n-                res = some({pre: vec::slice(elts, 0u, idx - 1u),\n-                            rep: some(elts.(idx - 1u)),\n-                            post: vec::slice(elts, idx + 1u,\n-                                              vec::len(elts))});\n+                res =\n+                    some({pre: vec::slice(elts, 0u, idx - 1u),\n+                          rep: some(elts[idx - 1u]),\n+                          post: vec::slice(elts, idx + 1u, vec::len(elts))});\n               }\n               _ { }\n             }\n@@ -116,16 +116,16 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n         idx += 1u;\n     }\n     ret alt res {\n-      some(val) { val }\n-      none. { {pre: elts, rep: none, post: ~[]} }\n-    }\n+          some(val) { val }\n+          none. { {pre: elts, rep: none, post: []} }\n+        }\n }\n \n fn option_flatten_map<T, U>(f: &fn(&T) -> option::t<U>, v: &[T]) ->\n    option::t<[U]> {\n-    let res = ~[];\n+    let res = [];\n     for elem: T in v {\n-        alt f(elem) { none. { ret none; } some(fv) { res += ~[fv]; } }\n+        alt f(elem) { none. { ret none; } some(fv) { res += [fv]; } }\n     }\n     ret some(res);\n }\n@@ -168,7 +168,7 @@ fn acumm_bindings(_cx: &ext_ctxt, _b_dest: &bindings, _b_src: &bindings) { }\n fn pattern_to_selectors(cx: &ext_ctxt, e: @expr) -> binders {\n     let res: binders =\n         {real_binders: new_str_hash::<selector>(),\n-         mutable literal_ast_matchers: ~[]};\n+         mutable literal_ast_matchers: []};\n     //this oughta return binders instead, but macro args are a sequence of\n     //expressions, rather than a single expression\n     fn trivial_selector(m: &matchable) -> match_result { ret some(leaf(m)); }\n@@ -203,7 +203,7 @@ fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t<bindings> {\n /* use the bindings on the body to generate the expanded code */\n \n fn transcribe(cx: &ext_ctxt, b: &bindings, body: @expr) -> @expr {\n-    let idx_path: @mutable [uint] = @mutable ~[];\n+    let idx_path: @mutable [uint] = @mutable [];\n     fn new_id(_old: node_id, cx: &ext_ctxt) -> node_id { ret cx.next_id(); }\n     fn new_span(cx: &ext_ctxt, sp: &span) -> span {\n         /* this discards information in the case of macro-defining macros */\n@@ -236,7 +236,7 @@ fn follow(m: &arb_depth<matchable>, idx_path: @mutable [uint]) ->\n     for idx: uint in *idx_path {\n         alt res {\n           leaf(_) { ret res;/* end of the line */ }\n-          seq(new_ms, _) { res = new_ms.(idx); }\n+          seq(new_ms, _) { res = new_ms[idx]; }\n         }\n     }\n     ret res;\n@@ -282,13 +282,12 @@ iter free_vars(b: &bindings, e: @expr) -> ident {\n \n /* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n-                    recur: fn(&@expr) -> @expr , exprs: [@expr])\n-    -> [@expr] {\n+                    recur: fn(&@expr) -> @expr, exprs: [@expr]) -> [@expr] {\n     alt elts_to_ell(cx, exprs) {\n       {pre: pre, rep: repeat_me_maybe, post: post} {\n         let res = vec::map(recur, pre);\n         alt repeat_me_maybe {\n-          none. {}\n+          none. { }\n           some(repeat_me) {\n             let repeat: option::t<{rep_count: uint, name: ident}> = none;\n             /* we need to walk over all the free vars in lockstep, except for\n@@ -305,9 +304,10 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                       some({rep_count: old_len, name: old_name}) {\n                         let len = vec::len(*ms);\n                         if old_len != len {\n-                            let msg = #fmt(\"'%s' occurs %u times, but \", fv,\n-                                           len) + #fmt(\"'%s' occurs %u times\",\n-                                                       old_name, old_len);\n+                            let msg =\n+                                #fmt[\"'%s' occurs %u times, but \", fv, len] +\n+                                    #fmt[\"'%s' occurs %u times\", old_name,\n+                                         old_len];\n                             cx.span_fatal(repeat_me.span, msg);\n                         }\n                       }\n@@ -319,14 +319,14 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n               none. {\n                 cx.span_fatal(repeat_me.span,\n                               \"'...' surrounds an expression without any\" +\n-                              \" repeating syntax variables\");\n+                                  \" repeating syntax variables\");\n               }\n               some({rep_count: rc, _}) {\n                 /* Whew, we now know how how many times to repeat */\n                 let idx: uint = 0u;\n                 while idx < rc {\n-                    *idx_path += ~[idx];\n-                    res += ~[recur(repeat_me)]; // whew!\n+                    *idx_path += [idx];\n+                    res += [recur(repeat_me)]; // whew!\n                     vec::pop(*idx_path);\n                     idx += 1u;\n                 }\n@@ -357,9 +357,9 @@ fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                    p: &path_, _fld: ast_fold) -> path_ {\n     // Don't substitute into qualified names.\n     if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret p; }\n-    ret alt follow_for_trans(cx, b.find(p.idents.(0)), idx_path) {\n+    ret alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n           some(match_ident(id)) {\n-            {global: false, idents: ~[id.node], types: ~[]}\n+            {global: false, idents: [id.node], types: []}\n           }\n           some(match_path(a_pth)) { a_pth.node }\n           some(m) { match_error(cx, m, \"a path\") }\n@@ -370,21 +370,20 @@ fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n \n fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                    e: &ast::expr_, fld: ast_fold,\n-                   orig: fn(&ast::expr_, ast_fold) -> ast::expr_ ) ->\n+                   orig: fn(&ast::expr_, ast_fold) -> ast::expr_) ->\n    ast::expr_ {\n     ret alt e {\n           expr_path(p) {\n             // Don't substitute into qualified names.\n-            if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u\n-               {\n+            if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u {\n                 e\n             }\n-            alt follow_for_trans(cx, b.find(p.node.idents.(0)), idx_path) {\n+            alt follow_for_trans(cx, b.find(p.node.idents[0]), idx_path) {\n               some(match_ident(id)) {\n                 expr_path(respan(id.span,\n                                  {global: false,\n-                                  idents: ~[id.node],\n-                                  types: ~[]}))\n+                                  idents: [id.node],\n+                                  types: []}))\n               }\n               some(match_path(a_pth)) { expr_path(a_pth) }\n               some(match_expr(a_exp)) { a_exp.node }\n@@ -398,7 +397,7 @@ fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n \n fn transcribe_type(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                    t: &ast::ty_, fld: ast_fold,\n-                   orig: fn(&ast::ty_, ast_fold) -> ast::ty_ ) -> ast::ty_ {\n+                   orig: fn(&ast::ty_, ast_fold) -> ast::ty_) -> ast::ty_ {\n     ret alt t {\n           ast::ty_path(pth, _) {\n             alt path_to_ident(pth) {\n@@ -422,12 +421,13 @@ fn transcribe_type(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n \n fn transcribe_block(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                     blk: &blk_, fld: ast_fold,\n-                    orig: fn(&blk_, ast_fold) -> blk_ ) -> blk_ {\n+                    orig: fn(&blk_, ast_fold) -> blk_) -> blk_ {\n     ret alt block_to_ident(blk) {\n           some(id) {\n             alt follow_for_trans(cx, b.find(id), idx_path) {\n               some(match_block(new_blk)) { new_blk.node }\n \n+\n               // possibly allow promotion of ident/path/expr to blocks?\n               some(m) {\n                 match_error(cx, m, \"a block\")\n@@ -452,20 +452,20 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n           expr_vec(p_elts, _) {\n             alt elts_to_ell(cx, p_elts) {\n               {pre: pre, rep: some(repeat_me), post: post} {\n-                p_t_s_r_length(cx, vec::len(pre) + vec::len(post),\n-                               true, s, b);\n-                if(vec::len(pre) > 0u) {\n+                p_t_s_r_length(cx, vec::len(pre) + vec::len(post), true, s,\n+                               b);\n+                if vec::len(pre) > 0u {\n                     p_t_s_r_actual_vector(cx, pre, true, s, b);\n                 }\n                 p_t_s_r_ellipses(cx, repeat_me, vec::len(pre), s, b);\n \n-                if(vec::len(post) > 0u) {\n+                if vec::len(post) > 0u {\n                     cx.span_unimpl(e.span,\n                                    \"matching after `...` not yet supported\");\n                 }\n               }\n               {pre: pre, rep: none., post: post} {\n-                if post != ~[] {\n+                if post != [] {\n                     cx.bug(\"elts_to_ell provided an invalid result\");\n                 }\n                 p_t_s_r_length(cx, vec::len(pre), false, s, b);\n@@ -474,6 +474,7 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n             }\n           }\n \n+\n           /* TODO: handle embedded types and blocks, at least */\n           expr_mac(mac) {\n             p_t_s_r_mac(cx, mac, s, b);\n@@ -488,7 +489,7 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n                       _ { cx.bug(\"broken traversal in p_t_s_r\") }\n                     }\n             }\n-            b.literal_ast_matchers += ~[bind select(cx, _, e)];\n+            b.literal_ast_matchers += [bind select(cx, _, e)];\n           }\n         }\n       }\n@@ -545,7 +546,7 @@ fn block_to_ident(blk: &blk_) -> option::t<ident> {\n \n fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n     fn select_pt_1(cx: &ext_ctxt, m: &matchable,\n-                   fn_m: fn(&ast::mac) -> match_result ) -> match_result {\n+                   fn_m: fn(&ast::mac) -> match_result) -> match_result {\n         ret alt m {\n               match_expr(e) {\n                 alt e.node { expr_mac(mac) { fn_m(mac) } _ { none } }\n@@ -603,17 +604,18 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n                     s: &selector, b: &binders) {\n     fn select(cx: &ext_ctxt, repeat_me: @expr, offset: uint, m: &matchable) ->\n-        match_result {\n+       match_result {\n         ret alt m {\n               match_expr(e) {\n                 alt e.node {\n                   expr_vec(arg_elts, _) {\n-                    let elts = ~[];\n+                    let elts = [];\n                     let idx = offset;\n                     while idx < vec::len(arg_elts) {\n-                        elts += ~[leaf(match_expr(arg_elts.(idx)))];\n+                        elts += [leaf(match_expr(arg_elts[idx]))];\n                         idx += 1u;\n                     }\n+\n                     // using repeat_me.span is a little wacky, but the\n                     // error we want to report is one in the macro def\n                     some(seq(@elts, repeat_me.span))\n@@ -631,14 +633,14 @@ fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n \n fn p_t_s_r_length(cx: &ext_ctxt, len: uint, at_least: bool, s: selector,\n                   b: &binders) {\n-    fn len_select(_cx: &ext_ctxt, m: &matchable, at_least: bool, len: uint)\n-        -> match_result {\n+    fn len_select(_cx: &ext_ctxt, m: &matchable, at_least: bool, len: uint) ->\n+       match_result {\n         ret alt m {\n               match_expr(e) {\n                 alt e.node {\n                   expr_vec(arg_elts, _) {\n                     let actual_len = vec::len(arg_elts);\n-                    if (at_least && actual_len >= len) || actual_len == len {\n+                    if at_least && actual_len >= len || actual_len == len {\n                         some(leaf(match_exact))\n                     } else { none }\n                   }\n@@ -649,7 +651,7 @@ fn p_t_s_r_length(cx: &ext_ctxt, len: uint, at_least: bool, s: selector,\n             }\n     }\n     b.literal_ast_matchers +=\n-        ~[compose_sels(s, bind len_select(cx, _, at_least, len))];\n+        [compose_sels(s, bind len_select(cx, _, at_least, len))];\n }\n \n fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], _repeat_after: bool,\n@@ -661,31 +663,33 @@ fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], _repeat_after: bool,\n                   match_expr(e) {\n                     alt e.node {\n                       expr_vec(arg_elts, _) {\n-                        some(leaf(match_expr(arg_elts.(idx))))\n+                        some(leaf(match_expr(arg_elts[idx])))\n                       }\n                       _ { none }\n                     }\n                   }\n                   _ { cx.bug(\"broken traversal in p_t_s_r\") }\n                 }\n         }\n-        p_t_s_rec(cx, match_expr(elts.(idx)),\n+        p_t_s_rec(cx, match_expr(elts[idx]),\n                   compose_sels(s, bind select(cx, _, idx)), b);\n         idx += 1u;\n     }\n }\n \n fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n                      _body: option::t<str>) -> base::macro_def {\n-    let args: [@ast::expr] = alt arg.node {\n-      ast::expr_vec(elts, _) { elts }\n-      _ {\n-        cx.span_fatal(sp, \"#macro requires arguments of the form `[...]`.\")\n-      }\n-    };\n+    let args: [@ast::expr] =\n+        alt arg.node {\n+          ast::expr_vec(elts, _) { elts }\n+          _ {\n+            cx.span_fatal(sp,\n+                          \"#macro requires arguments of the form `[...]`.\")\n+          }\n+        };\n \n     let macro_name: option::t<str> = none;\n-    let clauses: [@clause] = ~[];\n+    let clauses: [@clause] = [];\n     for arg: @expr in args {\n         alt arg.node {\n           expr_vec(elts, mut) {\n@@ -696,7 +700,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n             }\n \n \n-            alt elts.(0u).node {\n+            alt elts[0u].node {\n               expr_mac(mac) {\n                 alt mac.node {\n                   mac_invoc(pth, invoc_arg, body) {\n@@ -706,8 +710,9 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n                           none. { macro_name = some(id); }\n                           some(other_id) {\n                             if id != other_id {\n-                                cx.span_fatal(pth.span, \"macro name must be \"\n-                                              + \"consistent\");\n+                                cx.span_fatal(pth.span,\n+                                              \"macro name must be \" +\n+                                                  \"consistent\");\n                             }\n                           }\n                         }\n@@ -718,15 +723,15 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n                       }\n                     }\n                     clauses +=\n-                        ~[@{params: pattern_to_selectors(cx, invoc_arg),\n-                            body: elts.(1u)}];\n+                        [@{params: pattern_to_selectors(cx, invoc_arg),\n+                           body: elts[1u]}];\n                     // FIXME: check duplicates (or just simplify\n                     // the macro arg situation)\n                   }\n                 }\n               }\n               _ {\n-                cx.span_fatal(elts.(0u).span,\n+                cx.span_fatal(elts[0u].span,\n                               \"extension clause must\" +\n                                   \" start with a macro invocation.\");\n               }\n@@ -756,9 +761,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n                          _body: option::t<str>, clauses: [@clause]) -> @expr {\n         for c: @clause in clauses {\n             alt use_selectors_to_bind(c.params, arg) {\n-              some(bindings) {\n-                ret transcribe(cx, bindings, c.body)\n-              }\n+              some(bindings) { ret transcribe(cx, bindings, c.body) }\n               none. { cont; }\n             }\n         }"}, {"sha": "b781a2481c2446257f9a7fe9f73b8a32c619c4bc", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 77, "deletions": 81, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -20,57 +20,57 @@ type ast_fold = @mutable a_f;\n \n type ast_fold_precursor =\n     //unlike the others, item_ is non-trivial\n-    {fold_crate: fn(&crate_, ast_fold) -> crate_ ,\n+    {fold_crate: fn(&crate_, ast_fold) -> crate_,\n      fold_crate_directive:\n-         fn(&crate_directive_, ast_fold) -> crate_directive_ ,\n-     fold_view_item: fn(&view_item_, ast_fold) -> view_item_ ,\n-     fold_native_item: fn(&@native_item, ast_fold) -> @native_item ,\n-     fold_item: fn(&@item, ast_fold) -> @item ,\n-     fold_item_underscore: fn(&item_, ast_fold) -> item_ ,\n-     fold_method: fn(&method_, ast_fold) -> method_ ,\n-     fold_block: fn(&blk_, ast_fold) -> blk_ ,\n-     fold_stmt: fn(&stmt_, ast_fold) -> stmt_ ,\n-     fold_arm: fn(&arm, ast_fold) -> arm ,\n-     fold_pat: fn(&pat_, ast_fold) -> pat_ ,\n-     fold_decl: fn(&decl_, ast_fold) -> decl_ ,\n-     fold_expr: fn(&expr_, ast_fold) -> expr_ ,\n-     fold_ty: fn(&ty_, ast_fold) -> ty_ ,\n-     fold_constr: fn(&ast::constr_, ast_fold) -> constr_ ,\n-     fold_fn: fn(&_fn, ast_fold) -> _fn ,\n-     fold_mod: fn(&_mod, ast_fold) -> _mod ,\n-     fold_native_mod: fn(&native_mod, ast_fold) -> native_mod ,\n-     fold_variant: fn(&variant_, ast_fold) -> variant_ ,\n-     fold_ident: fn(&ident, ast_fold) -> ident ,\n-     fold_path: fn(&path_, ast_fold) -> path_ ,\n-     fold_local: fn(&local_, ast_fold) -> local_ ,\n-     map_exprs: fn(fn(&@expr) -> @expr , [@expr]) -> [@expr],\n+         fn(&crate_directive_, ast_fold) -> crate_directive_,\n+     fold_view_item: fn(&view_item_, ast_fold) -> view_item_,\n+     fold_native_item: fn(&@native_item, ast_fold) -> @native_item,\n+     fold_item: fn(&@item, ast_fold) -> @item,\n+     fold_item_underscore: fn(&item_, ast_fold) -> item_,\n+     fold_method: fn(&method_, ast_fold) -> method_,\n+     fold_block: fn(&blk_, ast_fold) -> blk_,\n+     fold_stmt: fn(&stmt_, ast_fold) -> stmt_,\n+     fold_arm: fn(&arm, ast_fold) -> arm,\n+     fold_pat: fn(&pat_, ast_fold) -> pat_,\n+     fold_decl: fn(&decl_, ast_fold) -> decl_,\n+     fold_expr: fn(&expr_, ast_fold) -> expr_,\n+     fold_ty: fn(&ty_, ast_fold) -> ty_,\n+     fold_constr: fn(&ast::constr_, ast_fold) -> constr_,\n+     fold_fn: fn(&_fn, ast_fold) -> _fn,\n+     fold_mod: fn(&_mod, ast_fold) -> _mod,\n+     fold_native_mod: fn(&native_mod, ast_fold) -> native_mod,\n+     fold_variant: fn(&variant_, ast_fold) -> variant_,\n+     fold_ident: fn(&ident, ast_fold) -> ident,\n+     fold_path: fn(&path_, ast_fold) -> path_,\n+     fold_local: fn(&local_, ast_fold) -> local_,\n+     map_exprs: fn(fn(&@expr) -> @expr, [@expr]) -> [@expr],\n      new_id: fn(node_id) -> node_id,\n      new_span: fn(&span) -> span};\n \n type a_f =\n-    {fold_crate: fn(&crate) -> crate ,\n-     fold_crate_directive: fn(&@crate_directive) -> @crate_directive ,\n-     fold_view_item: fn(&@view_item) -> @view_item ,\n-     fold_native_item: fn(&@native_item) -> @native_item ,\n-     fold_item: fn(&@item) -> @item ,\n-     fold_item_underscore: fn(&item_) -> item_ ,\n-     fold_method: fn(&@method) -> @method ,\n-     fold_block: fn(&blk) -> blk ,\n-     fold_stmt: fn(&@stmt) -> @stmt ,\n-     fold_arm: fn(&arm) -> arm ,\n-     fold_pat: fn(&@pat) -> @pat ,\n-     fold_decl: fn(&@decl) -> @decl ,\n-     fold_expr: fn(&@expr) -> @expr ,\n-     fold_ty: fn(&@ty) -> @ty ,\n-     fold_constr: fn(&@constr) -> @constr ,\n-     fold_fn: fn(&_fn) -> _fn ,\n-     fold_mod: fn(&_mod) -> _mod ,\n-     fold_native_mod: fn(&native_mod) -> native_mod ,\n-     fold_variant: fn(&variant) -> variant ,\n-     fold_ident: fn(&ident) -> ident ,\n-     fold_path: fn(&path) -> path ,\n-     fold_local: fn(&@local) -> @local ,\n-     map_exprs: fn(fn(&@expr) -> @expr , [@expr]) -> [@expr],\n+    {fold_crate: fn(&crate) -> crate,\n+     fold_crate_directive: fn(&@crate_directive) -> @crate_directive,\n+     fold_view_item: fn(&@view_item) -> @view_item,\n+     fold_native_item: fn(&@native_item) -> @native_item,\n+     fold_item: fn(&@item) -> @item,\n+     fold_item_underscore: fn(&item_) -> item_,\n+     fold_method: fn(&@method) -> @method,\n+     fold_block: fn(&blk) -> blk,\n+     fold_stmt: fn(&@stmt) -> @stmt,\n+     fold_arm: fn(&arm) -> arm,\n+     fold_pat: fn(&@pat) -> @pat,\n+     fold_decl: fn(&@decl) -> @decl,\n+     fold_expr: fn(&@expr) -> @expr,\n+     fold_ty: fn(&@ty) -> @ty,\n+     fold_constr: fn(&@constr) -> @constr,\n+     fold_fn: fn(&_fn) -> _fn,\n+     fold_mod: fn(&_mod) -> _mod,\n+     fold_native_mod: fn(&native_mod) -> native_mod,\n+     fold_variant: fn(&variant) -> variant,\n+     fold_ident: fn(&ident) -> ident,\n+     fold_path: fn(&path) -> path,\n+     fold_local: fn(&@local) -> @local,\n+     map_exprs: fn(fn(&@expr) -> @expr, [@expr]) -> [@expr],\n      new_id: fn(node_id) -> node_id,\n      new_span: fn(&span) -> span};\n \n@@ -120,7 +120,7 @@ fn fold_meta_item_(mi: &@meta_item, fld: ast_fold) -> @meta_item {\n           span: mi.span};\n }\n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_(at: &attribute, fmi: fn(&@meta_item) -> @meta_item ) ->\n+fn fold_attribute_(at: &attribute, fmi: fn(&@meta_item) -> @meta_item) ->\n    attribute {\n     ret {node: {style: at.node.style, value: *fmi(@at.node.value)},\n          span: at.span};\n@@ -135,14 +135,14 @@ fn fold_arg_(a: &arg, fld: ast_fold) -> arg {\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: &mac, fld: ast_fold) -> mac {\n     ret {node:\n-         alt m.node {\n-           mac_invoc(pth, arg, body) {\n-             mac_invoc(fld.fold_path(pth), fld.fold_expr(arg), body)\n-           }\n-           mac_embed_type(ty) { mac_embed_type(fld.fold_ty(ty)) }\n-           mac_embed_block(blk) { mac_embed_block(fld.fold_block(blk)) }\n-           mac_ellipsis. { mac_ellipsis }\n-         },\n+             alt m.node {\n+               mac_invoc(pth, arg, body) {\n+                 mac_invoc(fld.fold_path(pth), fld.fold_expr(arg), body)\n+               }\n+               mac_embed_type(ty) { mac_embed_type(fld.fold_ty(ty)) }\n+               mac_embed_block(blk) { mac_embed_block(fld.fold_block(blk)) }\n+               mac_ellipsis. { mac_ellipsis }\n+             },\n          span: m.span};\n }\n \n@@ -200,7 +200,7 @@ fn noop_fold_native_item(ni: &@native_item, fld: ast_fold) -> @native_item {\n                                   cf: fdec.cf,\n                                   constraints:\n                                       vec::map(fld.fold_constr,\n-                                                fdec.constraints)}, typms)\n+                                               fdec.constraints)}, typms)\n                 }\n               },\n           id: ni.id,\n@@ -238,8 +238,8 @@ fn noop_fold_item_underscore(i: &item_, fld: ast_fold) -> item_ {\n           }\n           item_obj(o, typms, d) {\n             item_obj({fields: vec::map(fold_obj_field, o.fields),\n-                      methods: vec::map(fld.fold_method, o.methods)},\n-                     typms, d)\n+                      methods: vec::map(fld.fold_method, o.methods)}, typms,\n+                     d)\n           }\n           item_res(dtor, did, typms, cid) {\n             item_res(fld.fold_fn(dtor), did, typms, cid)\n@@ -269,8 +269,7 @@ fn noop_fold_stmt(s: &stmt_, fld: ast_fold) -> stmt_ {\n }\n \n fn noop_fold_arm(a: &arm, fld: ast_fold) -> arm {\n-    ret {pats: vec::map(fld.fold_pat, a.pats),\n-         body: fld.fold_block(a.body)};\n+    ret {pats: vec::map(fld.fold_pat, a.pats), body: fld.fold_block(a.body)};\n }\n \n fn noop_fold_pat(p: &pat_, fld: ast_fold) -> pat_ {\n@@ -282,15 +281,13 @@ fn noop_fold_pat(p: &pat_, fld: ast_fold) -> pat_ {\n             pat_tag(fld.fold_path(pth), vec::map(fld.fold_pat, pats))\n           }\n           pat_rec(fields, etc) {\n-            let fs = ~[];\n+            let fs = [];\n             for f: ast::field_pat in fields {\n-                fs += ~[{ident: f.ident, pat: fld.fold_pat(f.pat)}];\n+                fs += [{ident: f.ident, pat: fld.fold_pat(f.pat)}];\n             }\n             pat_rec(fs, etc)\n           }\n-          pat_tup(elts) {\n-            pat_tup(vec::map(fld.fold_pat, elts))\n-          }\n+          pat_tup(elts) { pat_tup(vec::map(fld.fold_pat, elts)) }\n           pat_box(inner) { pat_box(fld.fold_pat(inner)) }\n         };\n }\n@@ -346,9 +343,7 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n             expr_rec(vec::map(fold_field, fields),\n                      option::map(fld.fold_expr, maybe_expr))\n           }\n-          expr_tup(elts) {\n-            expr_tup(vec::map(fld.fold_expr, elts))\n-          }\n+          expr_tup(elts) { expr_tup(vec::map(fld.fold_expr, elts)) }\n           expr_call(f, args) {\n             expr_call(fld.fold_expr(f), fld.map_exprs(fld.fold_expr, args))\n           }\n@@ -393,9 +388,7 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n           expr_move(el, er) {\n             expr_move(fld.fold_expr(el), fld.fold_expr(er))\n           }\n-          expr_copy(e) {\n-            expr_copy(fld.fold_expr(e))\n-          }\n+          expr_copy(e) { expr_copy(fld.fold_expr(e)) }\n           expr_assign(el, er) {\n             expr_assign(fld.fold_expr(el), fld.fold_expr(er))\n           }\n@@ -487,19 +480,20 @@ fn noop_fold_path(p: &path_, fld: ast_fold) -> path_ {\n fn noop_fold_local(l: &local_, fld: ast_fold) -> local_ {\n     ret {ty: fld.fold_ty(l.ty),\n          pat: fld.fold_pat(l.pat),\n-         init: alt l.init {\n-           option::none::<initializer>. { l.init }\n-           option::some::<initializer>(init) {\n-             option::some::<initializer>({op: init.op,\n-                                        expr: fld.fold_expr(init.expr)})\n-           }\n-         },\n+         init:\n+             alt l.init {\n+               option::none::<initializer>. { l.init }\n+               option::some::<initializer>(init) {\n+                 option::some::<initializer>({op: init.op,\n+                                              expr: fld.fold_expr(init.expr)})\n+               }\n+             },\n          id: l.id};\n }\n \n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n-fn noop_map_exprs(f: fn(&@expr) -> @expr , es: [@expr]) -> [@expr] {\n+fn noop_map_exprs(f: fn(&@expr) -> @expr, es: [@expr]) -> [@expr] {\n     ret vec::map(f, es);\n }\n \n@@ -634,14 +628,16 @@ fn make_fold(afp: &ast_fold_precursor) -> ast_fold {\n     }\n     fn f_pat(afp: &ast_fold_precursor, f: ast_fold, x: &@pat) -> @pat {\n         ret @{id: afp.new_id(x.id),\n-              node: afp.fold_pat(x.node, f), span: afp.new_span(x.span)};\n+              node: afp.fold_pat(x.node, f),\n+              span: afp.new_span(x.span)};\n     }\n     fn f_decl(afp: &ast_fold_precursor, f: ast_fold, x: &@decl) -> @decl {\n         ret @{node: afp.fold_decl(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_expr(afp: &ast_fold_precursor, f: ast_fold, x: &@expr) -> @expr {\n         ret @{id: afp.new_id(x.id),\n-              node: afp.fold_expr(x.node, f), span: afp.new_span(x.span)};\n+              node: afp.fold_expr(x.node, f),\n+              span: afp.new_span(x.span)};\n     }\n     fn f_ty(afp: &ast_fold_precursor, f: ast_fold, x: &@ty) -> @ty {\n         ret @{node: afp.fold_ty(x.node, f), span: afp.new_span(x.span)};"}, {"sha": "af1ba91b37bd4d8ae9bb79456b06f32d77b98173", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -26,8 +26,7 @@ type ctx =\n       cfg: ast::crate_cfg};\n \n fn eval_crate_directives(cx: ctx, cdirs: &[@ast::crate_directive],\n-                         prefix: str,\n-                         view_items: &mutable [@ast::view_item],\n+                         prefix: str, view_items: &mutable [@ast::view_item],\n                          items: &mutable [@ast::item]) {\n     for sub_cdir: @ast::crate_directive in cdirs {\n         eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n@@ -36,8 +35,8 @@ fn eval_crate_directives(cx: ctx, cdirs: &[@ast::crate_directive],\n \n fn eval_crate_directives_to_mod(cx: ctx, cdirs: &[@ast::crate_directive],\n                                 prefix: str) -> ast::_mod {\n-    let view_items: [@ast::view_item] = ~[];\n-    let items: [@ast::item] = ~[];\n+    let view_items: [@ast::view_item] = [];\n+    let items: [@ast::item] = [];\n     eval_crate_directives(cx, cdirs, prefix, view_items, items);\n     ret {view_items: view_items, items: items};\n }\n@@ -53,7 +52,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n             if std::fs::path_is_absolute(file_path) {\n                 file_path\n             } else { prefix + std::fs::path_sep() + file_path };\n-        if cx.mode == mode_depend { cx.deps += ~[full_path]; ret; }\n+        if cx.mode == mode_depend { cx.deps += [full_path]; ret; }\n         let p0 =\n             new_parser_from_file(cx.sess, cx.cfg, full_path, cx.chpos,\n                                  cx.byte_pos, SOURCE_FILE);\n@@ -68,7 +67,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         // Thread defids, chpos and byte_pos through the parsers\n         cx.chpos = p0.get_chpos();\n         cx.byte_pos = p0.get_byte_pos();\n-        items += ~[i];\n+        items += [i];\n       }\n       ast::cdir_dir_mod(id, dir_opt, cdirs, attrs) {\n         let path = id;\n@@ -85,9 +84,9 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n               node: ast::item_mod(m0),\n               span: cdir.span};\n         cx.sess.next_id += 1;\n-        items += ~[i];\n+        items += [i];\n       }\n-      ast::cdir_view_item(vi) { view_items += ~[vi]; }\n+      ast::cdir_view_item(vi) { view_items += [vi]; }\n       ast::cdir_syntax(pth) { }\n       ast::cdir_auth(pth, eff) { }\n     }"}, {"sha": "6e4cc10abb7395d3a9d4c0949c0c73d2c6a63549", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 44, "deletions": 48, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -14,18 +14,18 @@ import codemap;\n \n type reader =\n     obj {\n-        fn is_eof() -> bool ;\n-        fn curr() -> char ;\n-        fn next() -> char ;\n-        fn init() ;\n-        fn bump() ;\n-        fn get_str_from(uint) -> str ;\n-        fn get_interner() -> @interner::interner<str> ;\n-        fn get_chpos() -> uint ;\n-        fn get_byte_pos() -> uint ;\n-        fn get_col() -> uint ;\n-        fn get_filemap() -> codemap::filemap ;\n-        fn err(str) ;\n+        fn is_eof() -> bool;\n+        fn curr() -> char;\n+        fn next() -> char;\n+        fn init();\n+        fn bump();\n+        fn get_str_from(uint) -> str;\n+        fn get_interner() -> @interner::interner<str>;\n+        fn get_chpos() -> uint;\n+        fn get_byte_pos() -> uint;\n+        fn get_col() -> uint;\n+        fn get_filemap() -> codemap::filemap;\n+        fn err(str);\n     };\n \n fn new_reader(cm: &codemap::codemap, src: str, filemap: codemap::filemap,\n@@ -81,7 +81,7 @@ fn new_reader(cm: &codemap::codemap, src: str, filemap: codemap::filemap,\n             codemap::emit_error(some(ast::mk_sp(chpos, chpos)), m, cm);\n         }\n     }\n-    let strs: [str] = ~[];\n+    let strs: [str] = [];\n     let rd =\n         reader(cm, src, str::byte_len(src), 0u, 0u, -1 as char,\n                filemap.start_pos.ch, strs, filemap, itr);\n@@ -166,22 +166,19 @@ fn consume_block_comment(rdr: &reader) {\n \n fn digits_to_string(s: str) -> int {\n     let accum_int: int = 0;\n-    for c: u8 in s {\n-        accum_int *= 10;\n-        accum_int += dec_digit_val(c as char);\n-    }\n+    for c: u8 in s { accum_int *= 10; accum_int += dec_digit_val(c as char); }\n     ret accum_int;\n }\n \n fn scan_exponent(rdr: &reader) -> option::t<str> {\n     let c = rdr.curr();\n     let rslt = \"\";\n     if c == 'e' || c == 'E' {\n-        rslt += str::unsafe_from_bytes(~[c as u8]);\n+        rslt += str::unsafe_from_bytes([c as u8]);\n         rdr.bump();\n         c = rdr.curr();\n         if c == '-' || c == '+' {\n-            rslt += str::unsafe_from_bytes(~[c as u8]);\n+            rslt += str::unsafe_from_bytes([c as u8]);\n             rdr.bump();\n         }\n         let exponent = scan_dec_digits(rdr);\n@@ -195,7 +192,7 @@ fn scan_dec_digits(rdr: &reader) -> str {\n     let c = rdr.curr();\n     let rslt: str = \"\";\n     while is_dec_digit(c) || c == '_' {\n-        if c != '_' { rslt += str::unsafe_from_bytes(~[c as u8]); }\n+        if c != '_' { rslt += str::unsafe_from_bytes([c as u8]); }\n         rdr.bump();\n         c = rdr.curr();\n     }\n@@ -216,7 +213,7 @@ fn scan_number(c: char, rdr: &reader) -> token::token {\n             rdr.bump();\n             c = rdr.curr();\n         }\n-    } else if (c == '0' && n == 'b') {\n+    } else if c == '0' && n == 'b' {\n         rdr.bump();\n         rdr.bump();\n         c = rdr.curr();\n@@ -290,7 +287,7 @@ fn scan_number(c: char, rdr: &reader) -> token::token {\n                 ret token::LIT_MACH_FLOAT(ast::ty_f32,\n                                           intern(*rdr.get_interner(),\n                                                  float_str));\n-            } else if (c == '6' && n == '4') {\n+            } else if c == '6' && n == '4' {\n                 rdr.bump();\n                 rdr.bump();\n                 ret token::LIT_MACH_FLOAT(ast::ty_f64,\n@@ -302,14 +299,14 @@ fn scan_number(c: char, rdr: &reader) -> token::token {\n             }\n         } else {\n             ret token::LIT_FLOAT(interner::intern::<str>(*rdr.get_interner(),\n-                                                       float_str));\n+                                                         float_str));\n         }\n     }\n     let maybe_exponent = scan_exponent(rdr);\n     alt maybe_exponent {\n       some(s) {\n         ret token::LIT_FLOAT(interner::intern::<str>(*rdr.get_interner(),\n-                                                   dec_str + s));\n+                                                     dec_str + s));\n       }\n       none. { ret token::LIT_INT(accum_int); }\n     }\n@@ -321,7 +318,7 @@ fn scan_numeric_escape(rdr: &reader, n_hex_digits: uint) -> char {\n         let n = rdr.curr();\n         rdr.bump();\n         if !is_hex_digit(n) {\n-            rdr.err(#fmt(\"illegal numeric character escape: %d\", n as int));\n+            rdr.err(#fmt[\"illegal numeric character escape: %d\", n as int]);\n             fail;\n         }\n         accum_int *= 16;\n@@ -351,7 +348,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n         if str::eq(accum_str, \"_\") { ret token::UNDERSCORE; }\n         let is_mod_name = c == ':' && rdr.next() == ':';\n         ret token::IDENT(interner::intern::<str>(*rdr.get_interner(),\n-                                               accum_str), is_mod_name);\n+                                                 accum_str), is_mod_name);\n     }\n     if is_dec_digit(c) { ret scan_number(c, rdr); }\n     fn binop(rdr: &reader, op: token::binop) -> token::token {\n@@ -363,6 +360,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n     }\n     alt c {\n \n+\n       // One-byte tokens.\n       '?' {\n         rdr.bump();\n@@ -401,6 +399,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n         } else { ret token::COLON; }\n       }\n \n+\n       // Multi-byte tokens.\n       '=' {\n         rdr.bump();\n@@ -461,7 +460,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n               'u' { c2 = scan_numeric_escape(rdr, 4u); }\n               'U' { c2 = scan_numeric_escape(rdr, 8u); }\n               c2 {\n-                rdr.err(#fmt(\"unknown character escape: %d\", c2 as int));\n+                rdr.err(#fmt[\"unknown character escape: %d\", c2 as int]);\n                 fail;\n               }\n             }\n@@ -500,7 +499,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n                     str::push_char(accum_str, scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 {\n-                    rdr.err(#fmt(\"unknown string escape: %d\", c2 as int));\n+                    rdr.err(#fmt[\"unknown string escape: %d\", c2 as int]);\n                     fail;\n                   }\n                 }\n@@ -510,7 +509,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n         }\n         rdr.bump();\n         ret token::LIT_STR(interner::intern::<str>(*rdr.get_interner(),\n-                                                 accum_str));\n+                                                   accum_str));\n       }\n       '-' {\n         if rdr.next() == '>' {\n@@ -537,7 +536,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n       '/' { ret binop(rdr, token::SLASH); }\n       '^' { ret binop(rdr, token::CARET); }\n       '%' { ret binop(rdr, token::PERCENT); }\n-      c { rdr.err(#fmt(\"unkown start of token: %d\", c as int)); fail; }\n+      c { rdr.err(#fmt[\"unkown start of token: %d\", c as int]); fail; }\n     }\n }\n \n@@ -562,7 +561,7 @@ fn read_to_eol(rdr: &reader) -> str {\n \n fn read_one_line_comment(rdr: &reader) -> str {\n     let val = read_to_eol(rdr);\n-    assert (val.(0) == '/' as u8 && val.(1) == '/' as u8);\n+    assert (val[0] == '/' as u8 && val[1] == '/' as u8);\n     ret val;\n }\n \n@@ -578,8 +577,8 @@ fn consume_non_eol_whitespace(rdr: &reader) {\n \n fn push_blank_line_comment(rdr: &reader, comments: &mutable [cmnt]) {\n     log \">>> blank-line comment\";\n-    let v: [str] = ~[];\n-    comments += ~[{style: blank_line, lines: v, pos: rdr.get_chpos()}];\n+    let v: [str] = [];\n+    comments += [{style: blank_line, lines: v, pos: rdr.get_chpos()}];\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: &reader,\n@@ -595,11 +594,11 @@ fn consume_whitespace_counting_blank_lines(rdr: &reader,\n fn read_line_comments(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     log \">>> line comments\";\n     let p = rdr.get_chpos();\n-    let lines: [str] = ~[];\n+    let lines: [str] = [];\n     while rdr.curr() == '/' && rdr.next() == '/' {\n         let line = read_one_line_comment(rdr);\n         log line;\n-        lines += ~[line];\n+        lines += [line];\n         consume_non_eol_whitespace(rdr);\n     }\n     log \"<<< line comments\";\n@@ -610,10 +609,7 @@ fn read_line_comments(rdr: &reader, code_to_the_left: bool) -> cmnt {\n \n fn all_whitespace(s: &str, begin: uint, end: uint) -> bool {\n     let i: uint = begin;\n-    while i != end {\n-        if !is_whitespace(s.(i) as char) { ret false; }\n-        i += 1u;\n-    }\n+    while i != end { if !is_whitespace(s[i] as char) { ret false; } i += 1u; }\n     ret true;\n }\n \n@@ -626,20 +622,20 @@ fn trim_whitespace_prefix_and_push_line(lines: &mutable [str], s: &str,\n         } else { s1 = \"\"; }\n     } else { s1 = s; }\n     log \"pushing line: \" + s1;\n-    lines += ~[s1];\n+    lines += [s1];\n }\n \n fn read_block_comment(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     log \">>> block comment\";\n     let p = rdr.get_chpos();\n-    let lines: [str] = ~[];\n+    let lines: [str] = [];\n     let col: uint = rdr.get_col();\n     rdr.bump();\n     rdr.bump();\n     let curr_line = \"/*\";\n     let level: int = 1;\n     while level > 0 {\n-        log #fmt(\"=== block comment level %d\", level);\n+        log #fmt[\"=== block comment level %d\", level];\n         if rdr.is_eof() { rdr.err(\"unterminated block comment\"); fail; }\n         if rdr.curr() == '\\n' {\n             trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n@@ -683,9 +679,9 @@ fn consume_comment(rdr: &reader, code_to_the_left: bool,\n                    comments: &mutable [cmnt]) {\n     log \">>> consume comment\";\n     if rdr.curr() == '/' && rdr.next() == '/' {\n-        comments += ~[read_line_comments(rdr, code_to_the_left)];\n-    } else if (rdr.curr() == '/' && rdr.next() == '*') {\n-        comments += ~[read_block_comment(rdr, code_to_the_left)];\n+        comments += [read_line_comments(rdr, code_to_the_left)];\n+    } else if rdr.curr() == '/' && rdr.next() == '*' {\n+        comments += [read_block_comment(rdr, code_to_the_left)];\n     } else { fail; }\n     log \"<<< consume comment\";\n }\n@@ -712,8 +708,8 @@ fn gather_comments_and_literals(cm: &codemap::codemap, path: str,\n     let src = str::unsafe_from_bytes(srdr.read_whole_stream());\n     let itr = @interner::mk::<str>(str::hash, str::eq);\n     let rdr = new_reader(cm, src, codemap::new_filemap(path, 0u, 0u), itr);\n-    let comments: [cmnt] = ~[];\n-    let literals: [lit] = ~[];\n+    let comments: [cmnt] = [];\n+    let literals: [lit] = [];\n     let first_read: bool = true;\n     while !rdr.is_eof() {\n         while true {\n@@ -731,7 +727,7 @@ fn gather_comments_and_literals(cm: &codemap::codemap, path: str,\n         }\n         let tok = next_token(rdr);\n         if is_lit(tok.tok) {\n-            literals += ~[{lit: rdr.get_str_from(tok.bpos), pos: tok.chpos}];\n+            literals += [{lit: rdr.get_str_from(tok.bpos), pos: tok.chpos}];\n         }\n         log \"tok: \" + token::to_str(rdr, tok.tok);\n         first_read = false;"}, {"sha": "8113f9fd94dc4217862b7a2e953ce7869522e9f8", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 298, "deletions": 320, "changes": 618, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -33,39 +33,38 @@ fn next_node_id(sess: &parse_sess) -> node_id {\n \n type parser =\n     obj {\n-        fn peek() -> token::token ;\n-        fn bump() ;\n-        fn swap(token::token, uint, uint) ;\n-        fn look_ahead(uint) -> token::token ;\n-        fn fatal(str) -> !  ;\n-        fn warn(str) ;\n-        fn restrict(restriction) ;\n-        fn get_restriction() -> restriction ;\n-        fn get_file_type() -> file_type ;\n-        fn get_cfg() -> ast::crate_cfg ;\n-        fn get_span() -> span ;\n-        fn get_lo_pos() -> uint ;\n-        fn get_hi_pos() -> uint ;\n-        fn get_last_lo_pos() -> uint ;\n-        fn get_last_hi_pos() -> uint ;\n-        fn get_prec_table() -> @[op_spec] ;\n-        fn get_str(token::str_num) -> str ;\n-        fn get_reader() -> lexer::reader ;\n-        fn get_filemap() -> codemap::filemap ;\n-        fn get_bad_expr_words() -> hashmap<str, ()> ;\n-        fn get_chpos() -> uint ;\n-        fn get_byte_pos() -> uint ;\n-        fn get_id() -> node_id ;\n-        fn get_sess() -> parse_sess ;\n+        fn peek() -> token::token;\n+        fn bump();\n+        fn swap(token::token, uint, uint);\n+        fn look_ahead(uint) -> token::token;\n+        fn fatal(str) -> ! ;\n+        fn warn(str);\n+        fn restrict(restriction);\n+        fn get_restriction() -> restriction;\n+        fn get_file_type() -> file_type;\n+        fn get_cfg() -> ast::crate_cfg;\n+        fn get_span() -> span;\n+        fn get_lo_pos() -> uint;\n+        fn get_hi_pos() -> uint;\n+        fn get_last_lo_pos() -> uint;\n+        fn get_last_hi_pos() -> uint;\n+        fn get_prec_table() -> @[op_spec];\n+        fn get_str(token::str_num) -> str;\n+        fn get_reader() -> lexer::reader;\n+        fn get_filemap() -> codemap::filemap;\n+        fn get_bad_expr_words() -> hashmap<str, ()>;\n+        fn get_chpos() -> uint;\n+        fn get_byte_pos() -> uint;\n+        fn get_id() -> node_id;\n+        fn get_sess() -> parse_sess;\n     };\n \n-fn new_parser_from_file(sess: parse_sess, cfg:\n-                        ast::crate_cfg, path: str,\n-                        chpos: uint, byte_pos: uint,\n-                        ftype: file_type) -> parser {\n+fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: str,\n+                        chpos: uint, byte_pos: uint, ftype: file_type) ->\n+   parser {\n     let src = io::read_whole_file_str(path);\n     let filemap = codemap::new_filemap(path, chpos, byte_pos);\n-    sess.cm.files += ~[filemap];\n+    sess.cm.files += [filemap];\n     let itr = @interner::mk(str::hash, str::eq);\n     let rdr = lexer::new_reader(sess.cm, src, filemap, itr);\n \n@@ -106,9 +105,9 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n             while vec::len(buffer) < distance {\n                 let next = lexer::next_token(rdr);\n                 let sp = ast::mk_sp(next.chpos, rdr.get_chpos());\n-                buffer = ~[{tok: next.tok, span: sp}] + buffer;\n+                buffer = [{tok: next.tok, span: sp}] + buffer;\n             }\n-            ret buffer.(distance - 1u).tok;\n+            ret buffer[distance - 1u].tok;\n         }\n         fn fatal(m: str) -> ! {\n             codemap::emit_error(some(self.get_span()), m, sess.cm);\n@@ -141,7 +140,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n \n     let tok0 = lexer::next_token(rdr);\n     let span0 = ast::mk_sp(tok0.chpos, rdr.get_chpos());\n-    ret stdio_parser(sess, cfg, ftype, tok0.tok, span0, span0, ~[],\n+    ret stdio_parser(sess, cfg, ftype, tok0.tok, span0, span0, [],\n                      UNRESTRICTED, rdr, prec_table(), bad_expr_word_table());\n }\n \n@@ -213,8 +212,7 @@ fn expect_gt(p: &parser) {\n     } else if p.peek() == token::BINOP(token::LSR) {\n         p.swap(token::GT, p.get_lo_pos() + 1u, p.get_hi_pos());\n     } else if p.peek() == token::BINOP(token::ASR) {\n-        p.swap(token::BINOP(token::LSR), p.get_lo_pos() + 1u,\n-               p.get_hi_pos());\n+        p.swap(token::BINOP(token::LSR), p.get_lo_pos() + 1u, p.get_hi_pos());\n     } else {\n         let s: str = \"expecting \";\n         s += token::to_str(p.get_reader(), token::GT);\n@@ -304,7 +302,7 @@ fn parse_ty_fn(proto: ast::proto, p: &parser) -> ast::ty_ {\n                   parse_fn_input_ty, p);\n     // FIXME: there's no syntax for this right now anyway\n     //  auto constrs = parse_constrs(~[], p);\n-    let constrs: [@ast::constr] = ~[];\n+    let constrs: [@ast::constr] = [];\n     let output: @ast::ty;\n     let cf = ast::return;\n     if p.peek() == token::RARROW {\n@@ -324,11 +322,11 @@ fn parse_ty_fn(proto: ast::proto, p: &parser) -> ast::ty_ {\n fn parse_proto(p: &parser) -> ast::proto {\n     if eat_word(p, \"iter\") {\n         ret ast::proto_iter;\n-    } else if (eat_word(p, \"fn\")) {\n+    } else if eat_word(p, \"fn\") {\n         ret ast::proto_fn;\n-    } else if (eat_word(p, \"block\")) {\n+    } else if eat_word(p, \"block\") {\n         ret ast::proto_block;\n-    } else if (eat_word(p, \"pred\")) {\n+    } else if eat_word(p, \"pred\") {\n         ret ast::proto_fn;\n     } else { unexpected(p, p.peek()); }\n }\n@@ -431,10 +429,10 @@ fn parse_constr_in_type(p: &parser) -> @ast::ty_constr {\n \n fn parse_constrs<T>(pser: fn(&parser) -> @ast::constr_general<T>, p: &parser)\n    -> [@ast::constr_general<T>] {\n-    let constrs: [@ast::constr_general<T>] = ~[];\n+    let constrs: [@ast::constr_general<T>] = [];\n     while true {\n         let constr = pser(p);\n-        constrs += ~[constr];\n+        constrs += [constr];\n         if p.peek() == token::COMMA { p.bump(); } else { break; }\n     }\n     constrs\n@@ -445,17 +443,15 @@ fn parse_type_constraints(p: &parser) -> [@ast::ty_constr] {\n }\n \n fn parse_ty_postfix(orig_t: ast::ty_, p: &parser, colons_before_params: bool)\n-        -> @ast::ty {\n+   -> @ast::ty {\n     let lo = p.get_lo_pos();\n \n     if colons_before_params && p.peek() == token::MOD_SEP {\n         p.bump();\n         expect(p, token::LT);\n     } else if !colons_before_params && p.peek() == token::LT {\n         p.bump();\n-    } else {\n-        ret @spanned(lo, p.get_lo_pos(), orig_t);\n-    }\n+    } else { ret @spanned(lo, p.get_lo_pos(), orig_t); }\n \n     // If we're here, we have explicit type parameter instantiation.\n     let seq = parse_seq_to_gt(some(token::COMMA), bind parse_ty(_, false), p);\n@@ -469,9 +465,7 @@ fn parse_ty_postfix(orig_t: ast::ty_, p: &parser, colons_before_params: bool)\n                                            idents: pth.node.idents,\n                                            types: seq}), ann));\n       }\n-      _ {\n-        p.fatal(\"type parameter instantiation only allowed for paths\");\n-      }\n+      _ { p.fatal(\"type parameter instantiation only allowed for paths\"); }\n     }\n }\n \n@@ -490,73 +484,71 @@ fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n \n     if eat_word(p, \"bool\") {\n         t = ast::ty_bool;\n-    } else if (eat_word(p, \"int\")) {\n+    } else if eat_word(p, \"int\") {\n         t = ast::ty_int;\n-    } else if (eat_word(p, \"uint\")) {\n+    } else if eat_word(p, \"uint\") {\n         t = ast::ty_uint;\n-    } else if (eat_word(p, \"float\")) {\n+    } else if eat_word(p, \"float\") {\n         t = ast::ty_float;\n-    } else if (eat_word(p, \"str\")) {\n+    } else if eat_word(p, \"str\") {\n         t = ast::ty_str;\n-    } else if (eat_word(p, \"istr\")) {\n+    } else if eat_word(p, \"istr\") {\n         t = ast::ty_istr;\n-    } else if (eat_word(p, \"char\")) {\n+    } else if eat_word(p, \"char\") {\n         t = ast::ty_char;\n-/*\n-    } else if (eat_word(p, \"task\")) {\n-        t = ast::ty_task;\n-*/\n-    } else if (eat_word(p, \"i8\")) {\n+        /*\n+            } else if (eat_word(p, \"task\")) {\n+                t = ast::ty_task;\n+        */\n+    } else if eat_word(p, \"i8\") {\n         t = ast::ty_machine(ast::ty_i8);\n-    } else if (eat_word(p, \"i16\")) {\n+    } else if eat_word(p, \"i16\") {\n         t = ast::ty_machine(ast::ty_i16);\n-    } else if (eat_word(p, \"i32\")) {\n+    } else if eat_word(p, \"i32\") {\n         t = ast::ty_machine(ast::ty_i32);\n-    } else if (eat_word(p, \"i64\")) {\n+    } else if eat_word(p, \"i64\") {\n         t = ast::ty_machine(ast::ty_i64);\n-    } else if (eat_word(p, \"u8\")) {\n+    } else if eat_word(p, \"u8\") {\n         t = ast::ty_machine(ast::ty_u8);\n-    } else if (eat_word(p, \"u16\")) {\n+    } else if eat_word(p, \"u16\") {\n         t = ast::ty_machine(ast::ty_u16);\n-    } else if (eat_word(p, \"u32\")) {\n+    } else if eat_word(p, \"u32\") {\n         t = ast::ty_machine(ast::ty_u32);\n-    } else if (eat_word(p, \"u64\")) {\n+    } else if eat_word(p, \"u64\") {\n         t = ast::ty_machine(ast::ty_u64);\n-    } else if (eat_word(p, \"f32\")) {\n+    } else if eat_word(p, \"f32\") {\n         t = ast::ty_machine(ast::ty_f32);\n-    } else if (eat_word(p, \"f64\")) {\n+    } else if eat_word(p, \"f64\") {\n         t = ast::ty_machine(ast::ty_f64);\n-    } else if (p.peek() == token::LPAREN) {\n+    } else if p.peek() == token::LPAREN {\n         p.bump();\n         if p.peek() == token::RPAREN {\n             hi = p.get_hi_pos();\n             p.bump();\n             t = ast::ty_nil;\n         } else {\n-            let ts = ~[parse_ty(p, false)];\n+            let ts = [parse_ty(p, false)];\n             while p.peek() == token::COMMA {\n                 p.bump();\n-                ts += ~[parse_ty(p, false)];\n+                ts += [parse_ty(p, false)];\n             }\n             if vec::len(ts) == 1u {\n-                t = ts.(0).node;\n-            } else {\n-                t = ast::ty_tup(ts);\n-            }\n+                t = ts[0].node;\n+            } else { t = ast::ty_tup(ts); }\n             hi = p.get_hi_pos();\n             expect(p, token::RPAREN);\n         }\n-    } else if (p.peek() == token::AT) {\n+    } else if p.peek() == token::AT {\n         p.bump();\n         let mt = parse_mt(p);\n         hi = mt.ty.span.hi;\n         t = ast::ty_box(mt);\n-    } else if (p.peek() == token::BINOP(token::STAR)) {\n+    } else if p.peek() == token::BINOP(token::STAR) {\n         p.bump();\n         let mt = parse_mt(p);\n         hi = mt.ty.span.hi;\n         t = ast::ty_ptr(mt);\n-    } else if (p.peek() == token::LBRACE) {\n+    } else if p.peek() == token::LBRACE {\n         let elems =\n             parse_seq(token::LBRACE, token::RBRACE, some(token::COMMA),\n                       parse_ty_field, p);\n@@ -568,28 +560,28 @@ fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n                 ast::ty_constr(@spanned(lo, hi, t),\n                                parse_type_constraints(p));\n         }\n-    } else if (p.peek() == token::LBRACKET) {\n+    } else if p.peek() == token::LBRACKET {\n         expect(p, token::LBRACKET);\n         t = ast::ty_vec(parse_mt(p));\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n-    } else if (eat_word(p, \"fn\")) {\n+    } else if eat_word(p, \"fn\") {\n         t = parse_ty_fn(ast::proto_fn, p);\n         alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n-    } else if (eat_word(p, \"block\")) {\n+    } else if eat_word(p, \"block\") {\n         t = parse_ty_fn(ast::proto_block, p);\n         alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n-    } else if (eat_word(p, \"iter\")) {\n+    } else if eat_word(p, \"iter\") {\n         t = parse_ty_fn(ast::proto_iter, p);\n         alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n-    } else if (eat_word(p, \"obj\")) {\n+    } else if eat_word(p, \"obj\") {\n         t = parse_ty_obj(p, hi);\n-    } else if (eat_word(p, \"mutable\")) {\n+    } else if eat_word(p, \"mutable\") {\n         p.warn(\"ignoring deprecated 'mutable' type constructor\");\n         let typ = parse_ty(p, false);\n         t = typ.node;\n         hi = typ.span.hi;\n-    } else if (p.peek() == token::MOD_SEP || is_ident(p.peek())) {\n+    } else if p.peek() == token::MOD_SEP || is_ident(p.peek()) {\n         let path = parse_path(p);\n         t = ast::ty_path(path, p.get_id());\n         hi = path.span.hi;\n@@ -602,9 +594,7 @@ fn parse_arg_mode(p: &parser) -> ast::mode {\n         ast::alias(eat_word(p, \"mutable\"))\n     } else if eat(p, token::BINOP(token::MINUS)) {\n         ast::move\n-    } else {\n-        ast::val\n-    }\n+    } else { ast::val }\n }\n \n fn parse_arg(p: &parser) -> ast::arg {\n@@ -625,15 +615,14 @@ fn parse_fn_block_arg(p: &parser) -> ast::arg {\n fn parse_seq_to_before_gt<T>(sep: option::t<token::token>,\n                              f: fn(&parser) -> T, p: &parser) -> [T] {\n     let first = true;\n-    let v = ~[];\n-    while p.peek() != token::GT &&\n-          p.peek() != token::BINOP(token::LSR) &&\n-          p.peek() != token::BINOP(token::ASR) {\n+    let v = [];\n+    while p.peek() != token::GT && p.peek() != token::BINOP(token::LSR) &&\n+              p.peek() != token::BINOP(token::ASR) {\n         alt sep {\n           some(t) { if first { first = false; } else { expect(p, t); } }\n           _ { }\n         }\n-        v += ~[f(p)];\n+        v += [f(p)];\n     }\n \n     ret v;\n@@ -658,30 +647,30 @@ fn parse_seq_lt_gt<T>(sep: option::t<token::token>, f: fn(&parser) -> T,\n }\n \n fn parse_seq_to_end<T>(ket: token::token, sep: option::t<token::token>,\n-                       f: fn(&parser) -> T , p: &parser) -> [T] {\n+                       f: fn(&parser) -> T, p: &parser) -> [T] {\n     let val = parse_seq_to_before_end(ket, sep, f, p);\n     p.bump();\n     ret val;\n }\n \n fn parse_seq_to_before_end<T>(ket: token::token, sep: option::t<token::token>,\n-                              f: fn(&parser) -> T , p: &parser) -> [T] {\n+                              f: fn(&parser) -> T, p: &parser) -> [T] {\n     let first: bool = true;\n-    let v: [T] = ~[];\n+    let v: [T] = [];\n     while p.peek() != ket {\n         alt sep {\n           some(t) { if first { first = false; } else { expect(p, t); } }\n           _ { }\n         }\n-        v += ~[f(p)];\n+        v += [f(p)];\n     }\n     ret v;\n }\n \n \n fn parse_seq<T>(bra: token::token, ket: token::token,\n-                sep: option::t<token::token>, f: fn(&parser) -> T ,\n-                p: &parser) -> spanned<[T]> {\n+                sep: option::t<token::token>, f: fn(&parser) -> T, p: &parser)\n+   -> spanned<[T]> {\n     let lo = p.get_lo_pos();\n     expect(p, bra);\n     let result = parse_seq_to_before_end::<T>(ket, sep, f, p);\n@@ -696,7 +685,7 @@ fn parse_lit(p: &parser) -> ast::lit {\n     let lit: ast::lit_ = ast::lit_nil;\n     if eat_word(p, \"true\") {\n         lit = ast::lit_bool(true);\n-    } else if (eat_word(p, \"false\")) {\n+    } else if eat_word(p, \"false\") {\n         lit = ast::lit_bool(false);\n     } else {\n         alt p.peek() {\n@@ -749,24 +738,22 @@ fn parse_path(p: &parser) -> ast::path {\n         p.bump();\n     } else { global = false; }\n \n-    let ids: [ast::ident] = ~[];\n+    let ids: [ast::ident] = [];\n     while true {\n         alt p.peek() {\n           token::IDENT(i, _) {\n             hi = p.get_hi_pos();\n-            ids += ~[p.get_str(i)];\n+            ids += [p.get_str(i)];\n             hi = p.get_hi_pos();\n             p.bump();\n             if p.peek() == token::MOD_SEP && p.look_ahead(1u) != token::LT {\n                 p.bump();\n-            } else {\n-                break;\n-            }\n+            } else { break; }\n           }\n           _ { break; }\n         }\n     }\n-    ret spanned(lo, hi, {global: global, idents: ids, types: ~[]});\n+    ret spanned(lo, hi, {global: global, idents: ids, types: []});\n }\n \n fn parse_path_and_ty_param_substs(p: &parser) -> ast::path {\n@@ -775,8 +762,8 @@ fn parse_path_and_ty_param_substs(p: &parser) -> ast::path {\n     if p.peek() == token::MOD_SEP {\n         p.bump();\n \n-        let seq = parse_seq_lt_gt(some(token::COMMA), bind parse_ty(_, false),\n-                                  p);\n+        let seq =\n+            parse_seq_lt_gt(some(token::COMMA), bind parse_ty(_, false), p);\n         let hi = seq.span.hi;\n         path =\n             spanned(lo, hi,\n@@ -827,28 +814,23 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n             let lit = @spanned(lo, hi, ast::lit_nil);\n             ret mk_expr(p, lo, hi, ast::expr_lit(lit));\n         }\n-        let es = ~[parse_expr(p)];\n-        while p.peek() == token::COMMA {\n-            p.bump();\n-            es += ~[parse_expr(p)];\n-        }\n+        let es = [parse_expr(p)];\n+        while p.peek() == token::COMMA { p.bump(); es += [parse_expr(p)]; }\n         hi = p.get_hi_pos();\n         expect(p, token::RPAREN);\n         if vec::len(es) == 1u {\n-            ret mk_expr(p, lo, hi, es.(0).node);\n-        } else {\n-            ret mk_expr(p, lo, hi, ast::expr_tup(es));\n-        }\n-    } else if (p.peek() == token::LBRACE) {\n+            ret mk_expr(p, lo, hi, es[0].node);\n+        } else { ret mk_expr(p, lo, hi, ast::expr_tup(es)); }\n+    } else if p.peek() == token::LBRACE {\n         p.bump();\n         if is_word(p, \"mutable\") ||\n                is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n-            let fields = ~[parse_field(p, token::COLON)];\n+            let fields = [parse_field(p, token::COLON)];\n             let base = none;\n             while p.peek() != token::RBRACE {\n                 if eat_word(p, \"with\") { base = some(parse_expr(p)); break; }\n                 expect(p, token::COMMA);\n-                fields += ~[parse_field(p, token::COLON)];\n+                fields += [parse_field(p, token::COLON)];\n             }\n             hi = p.get_hi_pos();\n             expect(p, token::RBRACE);\n@@ -859,48 +841,48 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n             let blk = parse_block_tail(p, lo);\n             ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n         }\n-    } else if (eat_word(p, \"if\")) {\n+    } else if eat_word(p, \"if\") {\n         ret parse_if_expr(p);\n-    } else if (eat_word(p, \"for\")) {\n+    } else if eat_word(p, \"for\") {\n         ret parse_for_expr(p);\n-    } else if (eat_word(p, \"while\")) {\n+    } else if eat_word(p, \"while\") {\n         ret parse_while_expr(p);\n-    } else if (eat_word(p, \"do\")) {\n+    } else if eat_word(p, \"do\") {\n         ret parse_do_while_expr(p);\n-    } else if (eat_word(p, \"alt\")) {\n+    } else if eat_word(p, \"alt\") {\n         ret parse_alt_expr(p);\n-/*\n-    } else if (eat_word(p, \"spawn\")) {\n-        ret parse_spawn_expr(p);\n-*/\n-    } else if (eat_word(p, \"fn\")) {\n+        /*\n+            } else if (eat_word(p, \"spawn\")) {\n+                ret parse_spawn_expr(p);\n+        */\n+    } else if eat_word(p, \"fn\") {\n         ret parse_fn_expr(p, ast::proto_fn);\n-    } else if (eat_word(p, \"block\")) {\n+    } else if eat_word(p, \"block\") {\n         ret parse_fn_expr(p, ast::proto_block);\n-    } else if (eat_word(p, \"lambda\")) {\n+    } else if eat_word(p, \"lambda\") {\n         ret parse_fn_expr(p, ast::proto_closure);\n-    } else if (p.peek() == token::LBRACKET) {\n+    } else if p.peek() == token::LBRACKET {\n         p.bump();\n         let mut = parse_mutability(p);\n         let es =\n             parse_seq_to_end(token::RBRACKET, some(token::COMMA), parse_expr,\n                              p);\n         ex = ast::expr_vec(es, mut);\n-    } else if (p.peek() == token::POUND_LT) {\n+    } else if p.peek() == token::POUND_LT {\n         p.bump();\n         let ty = parse_ty(p, false);\n         expect(p, token::GT);\n \n         /* hack: early return to take advantage of specialized function */\n         ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_embed_type(ty))\n-    } else if (p.peek() == token::POUND_LBRACE) {\n+    } else if p.peek() == token::POUND_LBRACE {\n         p.bump();\n         let blk = ast::mac_embed_block(parse_block_tail(p, lo));\n         ret mk_mac_expr(p, lo, p.get_hi_pos(), blk);\n-    } else if (p.peek() == token::ELLIPSIS) {\n+    } else if p.peek() == token::ELLIPSIS {\n         p.bump();\n         ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_ellipsis)\n-    } else if (p.peek() == token::TILDE) {\n+    } else if p.peek() == token::TILDE {\n         p.bump();\n         alt p.peek() {\n           token::LBRACKET. { // unique array (temporary)\n@@ -920,7 +902,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n           }\n           _ { ex = ast::expr_uniq(parse_expr(p)); }\n         }\n-    } else if (eat_word(p, \"obj\")) {\n+    } else if eat_word(p, \"obj\") {\n         // Anonymous object\n \n         // Only make people type () if they're actually adding new fields\n@@ -931,13 +913,13 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n                 some(parse_seq_to_end(token::RPAREN, some(token::COMMA),\n                                       parse_anon_obj_field, p));\n         }\n-        let meths: [@ast::method] = ~[];\n+        let meths: [@ast::method] = [];\n         let inner_obj: option::t<@ast::expr> = none;\n         expect(p, token::LBRACE);\n         while p.peek() != token::RBRACE {\n             if eat_word(p, \"with\") {\n                 inner_obj = some(parse_expr(p));\n-            } else { meths += ~[parse_method(p)]; }\n+            } else { meths += [parse_method(p)]; }\n         }\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACE);\n@@ -949,7 +931,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         // \"spanned\".\n         let ob = {fields: fields, methods: meths, inner_obj: inner_obj};\n         ex = ast::expr_anon_obj(ob);\n-    } else if (eat_word(p, \"bind\")) {\n+    } else if eat_word(p, \"bind\") {\n         let e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         fn parse_expr_opt(p: &parser) -> option::t<@ast::expr> {\n             alt p.peek() {\n@@ -962,57 +944,57 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n                       parse_expr_opt, p);\n         hi = es.span.hi;\n         ex = ast::expr_bind(e, es.node);\n-    } else if (p.peek() == token::POUND) {\n+    } else if p.peek() == token::POUND {\n         let ex_ext = parse_syntax_ext(p);\n         hi = ex_ext.span.hi;\n         ex = ex_ext.node;\n-    } else if (eat_word(p, \"fail\")) {\n+    } else if eat_word(p, \"fail\") {\n         if can_begin_expr(p.peek()) {\n             let e = parse_expr(p);\n             hi = e.span.hi;\n             ex = ast::expr_fail(some(e));\n         } else { ex = ast::expr_fail(none); }\n-    } else if (eat_word(p, \"log\")) {\n+    } else if eat_word(p, \"log\") {\n         let e = parse_expr(p);\n         ex = ast::expr_log(1, e);\n         hi = e.span.hi;\n-    } else if (eat_word(p, \"log_err\")) {\n+    } else if eat_word(p, \"log_err\") {\n         let e = parse_expr(p);\n         ex = ast::expr_log(0, e);\n         hi = e.span.hi;\n-    } else if (eat_word(p, \"assert\")) {\n+    } else if eat_word(p, \"assert\") {\n         let e = parse_expr(p);\n         ex = ast::expr_assert(e);\n         hi = e.span.hi;\n-    } else if (eat_word(p, \"check\")) {\n+    } else if eat_word(p, \"check\") {\n         /* Should be a predicate (pure boolean function) applied to\n            arguments that are all either slot variables or literals.\n            but the typechecker enforces that. */\n \n         let e = parse_expr(p);\n         hi = e.span.hi;\n         ex = ast::expr_check(ast::checked, e);\n-    } else if (eat_word(p, \"claim\")) {\n+    } else if eat_word(p, \"claim\") {\n         /* Same rules as check, except that if check-claims\n          is enabled (a command-line flag), then the parser turns\n         claims into check */\n \n         let e = parse_expr(p);\n         hi = e.span.hi;\n         ex = ast::expr_check(ast::unchecked, e);\n-    } else if (eat_word(p, \"ret\")) {\n+    } else if eat_word(p, \"ret\") {\n         if can_begin_expr(p.peek()) {\n             let e = parse_expr(p);\n             hi = e.span.hi;\n             ex = ast::expr_ret(some(e));\n         } else { ex = ast::expr_ret(none); }\n-    } else if (eat_word(p, \"break\")) {\n+    } else if eat_word(p, \"break\") {\n         ex = ast::expr_break;\n         hi = p.get_hi_pos();\n-    } else if (eat_word(p, \"cont\")) {\n+    } else if eat_word(p, \"cont\") {\n         ex = ast::expr_cont;\n         hi = p.get_hi_pos();\n-    } else if (eat_word(p, \"put\")) {\n+    } else if eat_word(p, \"put\") {\n         alt p.peek() {\n           token::SEMI. { ex = ast::expr_put(none); }\n           _ {\n@@ -1021,18 +1003,19 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n             ex = ast::expr_put(some(e));\n           }\n         }\n-    } else if (eat_word(p, \"be\")) {\n+    } else if eat_word(p, \"be\") {\n         let e = parse_expr(p);\n+\n         // FIXME: Is this the right place for this check?\n         if /*check*/ast::is_call_expr(e) {\n             hi = e.span.hi;\n             ex = ast::expr_be(e);\n         } else { p.fatal(\"Non-call expression in tail call\"); }\n-    } else if (eat_word(p, \"copy\")) {\n+    } else if eat_word(p, \"copy\") {\n         let e = parse_expr(p);\n         ex = ast::expr_copy(e);\n         hi = e.span.hi;\n-    } else if (eat_word(p, \"self\")) {\n+    } else if eat_word(p, \"self\") {\n         expect(p, token::DOT);\n         // The rest is a call expression.\n         let f: @ast::expr = parse_self_method(p);\n@@ -1041,9 +1024,9 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n                       parse_expr, p);\n         hi = es.span.hi;\n         ex = ast::expr_call(f, es.node);\n-    } else if (p.peek() == token::MOD_SEP ||\n-                   is_ident(p.peek()) && !is_word(p, \"true\") &&\n-                       !is_word(p, \"false\")) {\n+    } else if p.peek() == token::MOD_SEP ||\n+                  is_ident(p.peek()) && !is_word(p, \"true\") &&\n+                      !is_word(p, \"false\") {\n         check_bad_word(p);\n         let pth = parse_path_and_ty_param_substs(p);\n         hi = pth.span.hi;\n@@ -1068,16 +1051,16 @@ fn parse_syntax_ext_naked(p: &parser, lo: uint) -> @ast::expr {\n         p.fatal(\"expected a syntax expander name\");\n     }\n     //temporary for a backwards-compatible cycle:\n-    let es = if p.peek() == token::LPAREN {\n-        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                  parse_expr, p)\n-    } else {\n-        parse_seq(token::LBRACKET, token::RBRACKET, some(token::COMMA),\n-                  parse_expr, p)\n-    };\n+    let es =\n+        if p.peek() == token::LPAREN {\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                      parse_expr, p)\n+        } else {\n+            parse_seq(token::LBRACKET, token::RBRACKET, some(token::COMMA),\n+                      parse_expr, p)\n+        };\n     let hi = es.span.hi;\n-    let e = mk_expr(p, es.span.lo, hi,\n-                    ast::expr_vec(es.node, ast::imm));\n+    let e = mk_expr(p, es.span.lo, hi, ast::expr_vec(es.node, ast::imm));\n     ret mk_mac_expr(p, lo, hi, ast::mac_invoc(pth, e, none));\n }\n \n@@ -1204,26 +1187,26 @@ type op_spec = {tok: token::token, op: ast::binop, prec: int};\n \n // FIXME make this a const, don't store it in parser state\n fn prec_table() -> @[op_spec] {\n-    ret @~[{tok: token::BINOP(token::STAR), op: ast::mul, prec: 11},\n-           {tok: token::BINOP(token::SLASH), op: ast::div, prec: 11},\n-           {tok: token::BINOP(token::PERCENT), op: ast::rem, prec: 11},\n-           {tok: token::BINOP(token::PLUS), op: ast::add, prec: 10},\n-           {tok: token::BINOP(token::MINUS), op: ast::sub, prec: 10},\n-           {tok: token::BINOP(token::LSL), op: ast::lsl, prec: 9},\n-           {tok: token::BINOP(token::LSR), op: ast::lsr, prec: 9},\n-           {tok: token::BINOP(token::ASR), op: ast::asr, prec: 9},\n-           {tok: token::BINOP(token::AND), op: ast::bitand, prec: 8},\n-           {tok: token::BINOP(token::CARET), op: ast::bitxor, prec: 6},\n-           {tok: token::BINOP(token::OR), op: ast::bitor, prec: 6},\n-           // 'as' sits between here with 5\n-           {tok: token::LT, op: ast::lt, prec: 4},\n-           {tok: token::LE, op: ast::le, prec: 4},\n-           {tok: token::GE, op: ast::ge, prec: 4},\n-           {tok: token::GT, op: ast::gt, prec: 4},\n-           {tok: token::EQEQ, op: ast::eq, prec: 3},\n-           {tok: token::NE, op: ast::ne, prec: 3},\n-           {tok: token::ANDAND, op: ast::and, prec: 2},\n-           {tok: token::OROR, op: ast::or, prec: 1}];\n+    ret @[{tok: token::BINOP(token::STAR), op: ast::mul, prec: 11},\n+          {tok: token::BINOP(token::SLASH), op: ast::div, prec: 11},\n+          {tok: token::BINOP(token::PERCENT), op: ast::rem, prec: 11},\n+          {tok: token::BINOP(token::PLUS), op: ast::add, prec: 10},\n+          {tok: token::BINOP(token::MINUS), op: ast::sub, prec: 10},\n+          {tok: token::BINOP(token::LSL), op: ast::lsl, prec: 9},\n+          {tok: token::BINOP(token::LSR), op: ast::lsr, prec: 9},\n+          {tok: token::BINOP(token::ASR), op: ast::asr, prec: 9},\n+          {tok: token::BINOP(token::AND), op: ast::bitand, prec: 8},\n+          {tok: token::BINOP(token::CARET), op: ast::bitxor, prec: 6},\n+          {tok: token::BINOP(token::OR), op: ast::bitor, prec: 6},\n+          // 'as' sits between here with 5\n+          {tok: token::LT, op: ast::lt, prec: 4},\n+          {tok: token::LE, op: ast::le, prec: 4},\n+          {tok: token::GE, op: ast::ge, prec: 4},\n+          {tok: token::GT, op: ast::gt, prec: 4},\n+          {tok: token::EQEQ, op: ast::eq, prec: 3},\n+          {tok: token::NE, op: ast::ne, prec: 3},\n+          {tok: token::ANDAND, op: ast::and, prec: 2},\n+          {tok: token::OROR, op: ast::or, prec: 1}];\n }\n \n fn parse_binops(p: &parser) -> @ast::expr {\n@@ -1388,11 +1371,11 @@ fn parse_alt_expr(p: &parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let discriminant = parse_expr(p);\n     expect(p, token::LBRACE);\n-    let arms: [ast::arm] = ~[];\n+    let arms: [ast::arm] = [];\n     while p.peek() != token::RBRACE {\n         let pats = parse_pats(p);\n         let blk = parse_block(p);\n-        arms += ~[{pats: pats, body: blk}];\n+        arms += [{pats: pats, body: blk}];\n     }\n     let hi = p.get_hi_pos();\n     p.bump();\n@@ -1422,6 +1405,7 @@ fn parse_initializer(p: &parser) -> option::t<ast::initializer> {\n         ret some({op: ast::init_move, expr: parse_expr(p)});\n       }\n \n+\n       // Now that the the channel is the first argument to receive,\n       // combining it with an initializer doesn't really make sense.\n       // case (token::RECV) {\n@@ -1436,9 +1420,9 @@ fn parse_initializer(p: &parser) -> option::t<ast::initializer> {\n }\n \n fn parse_pats(p: &parser) -> [@ast::pat] {\n-    let pats = ~[];\n+    let pats = [];\n     while true {\n-        pats += ~[parse_pat(p)];\n+        pats += [parse_pat(p)];\n         if p.peek() == token::BINOP(token::OR) { p.bump(); } else { break; }\n     }\n     ret pats;\n@@ -1458,7 +1442,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n       }\n       token::LBRACE. {\n         p.bump();\n-        let fields = ~[];\n+        let fields = [];\n         let etc = false;\n         let first = true;\n         while p.peek() != token::RBRACE {\n@@ -1488,7 +1472,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n                       node: ast::pat_bind(fieldname),\n                       span: ast::mk_sp(lo, hi)};\n             }\n-            fields += ~[{ident: fieldname, pat: subpat}];\n+            fields += [{ident: fieldname, pat: subpat}];\n         }\n         hi = p.get_hi_pos();\n         p.bump();\n@@ -1499,13 +1483,13 @@ fn parse_pat(p: &parser) -> @ast::pat {\n         if p.peek() == token::RPAREN {\n             hi = p.get_hi_pos();\n             p.bump();\n-            pat = ast::pat_lit(@{node: ast::lit_nil,\n-                                 span: ast::mk_sp(lo,hi)});\n+            pat =\n+                ast::pat_lit(@{node: ast::lit_nil, span: ast::mk_sp(lo, hi)});\n         } else {\n-            let fields = ~[parse_pat(p)];\n+            let fields = [parse_pat(p)];\n             while p.peek() == token::COMMA {\n                 p.bump();\n-                fields += ~[parse_pat(p)];\n+                fields += [parse_pat(p)];\n             }\n             if vec::len(fields) == 1u { expect(p, token::COMMA); }\n             hi = p.get_hi_pos();\n@@ -1518,13 +1502,13 @@ fn parse_pat(p: &parser) -> @ast::pat {\n             let lit = parse_lit(p);\n             hi = lit.span.hi;\n             pat = ast::pat_lit(@lit);\n-        } else if (is_plain_ident(p) &&\n-                       alt p.look_ahead(1u) {\n-                         token::DOT. | token::LPAREN. | token::LBRACKET. {\n-                           false\n-                         }\n-                         _ { true }\n-                       }) {\n+        } else if is_plain_ident(p) &&\n+                      alt p.look_ahead(1u) {\n+                        token::DOT. | token::LPAREN. | token::LBRACKET. {\n+                          false\n+                        }\n+                        _ { true }\n+                      } {\n             hi = p.get_hi_pos();\n             pat = ast::pat_bind(parse_value_ident(p));\n         } else {\n@@ -1539,7 +1523,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n                 args = a.node;\n                 hi = a.span.hi;\n               }\n-              token::DOT. { args = ~[]; p.bump(); }\n+              token::DOT. { args = []; p.bump(); }\n               _ { expect(p, token::LPAREN); fail; }\n             }\n             pat = ast::pat_tag(tag_path, args);\n@@ -1556,18 +1540,15 @@ fn parse_local(p: &parser, allow_init: bool) -> @ast::local {\n     if eat(p, token::COLON) { ty = parse_ty(p, false); }\n     let init = if allow_init { parse_initializer(p) } else { none };\n     ret @spanned(lo, p.get_last_hi_pos(),\n-                 {ty: ty,\n-                  pat: pat,\n-                  init: init,\n-                  id: p.get_id()});\n+                 {ty: ty, pat: pat, init: init, id: p.get_id()});\n }\n \n fn parse_let(p: &parser) -> @ast::decl {\n     let lo = p.get_lo_pos();\n-    let locals = ~[parse_local(p, true)];\n+    let locals = [parse_local(p, true)];\n     while p.peek() == token::COMMA {\n         p.bump();\n-        locals += ~[parse_local(p, true)];\n+        locals += [parse_local(p, true)];\n     }\n     ret @spanned(lo, p.get_last_hi_pos(), ast::decl_local(locals));\n }\n@@ -1579,7 +1560,7 @@ fn parse_stmt(p: &parser) -> @ast::stmt {\n }\n \n fn parse_crate_stmt(p: &parser) -> @ast::stmt {\n-    let cdir = parse_crate_directive(p, ~[]);\n+    let cdir = parse_crate_directive(p, []);\n     ret @spanned(cdir.span.lo, cdir.span.hi,\n                  ast::stmt_crate_directive(@cdir));\n }\n@@ -1593,7 +1574,7 @@ fn parse_source_stmt(p: &parser) -> @ast::stmt {\n \n         let item_attrs;\n         alt parse_outer_attrs_or_ext(p) {\n-          none. { item_attrs = ~[]; }\n+          none. { item_attrs = []; }\n           some(left(attrs)) { item_attrs = attrs; }\n           some(right(ext)) {\n             ret @spanned(lo, ext.span.hi, ast::stmt_expr(ext, p.get_id()));\n@@ -1682,6 +1663,7 @@ fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n             }\n       }\n \n+\n       // We should not be calling this on a cdir.\n       ast::stmt_crate_directive(cdir) {\n         fail;\n@@ -1697,7 +1679,7 @@ fn parse_block(p: &parser) -> ast::blk {\n \n // some blocks start with \"#{\"...\n fn parse_block_tail(p: &parser, lo: uint) -> ast::blk {\n-    let stmts: [@ast::stmt] = ~[];\n+    let stmts: [@ast::stmt] = [];\n     let expr: option::t<@ast::expr> = none;\n     while p.peek() != token::RBRACE {\n         alt p.peek() {\n@@ -1709,21 +1691,21 @@ fn parse_block_tail(p: &parser, lo: uint) -> ast::blk {\n             alt stmt_to_expr(stmt) {\n               some(e) {\n                 alt p.peek() {\n-                  token::SEMI. { p.bump(); stmts += ~[stmt]; }\n+                  token::SEMI. { p.bump(); stmts += [stmt]; }\n                   token::RBRACE. { expr = some(e); }\n                   t {\n                     if stmt_ends_with_semi(*stmt) {\n                         p.fatal(\"expected ';' or '}' after \" +\n                                     \"expression but found \" +\n                                     token::to_str(p.get_reader(), t));\n                     }\n-                    stmts += ~[stmt];\n+                    stmts += [stmt];\n                   }\n                 }\n               }\n               none. {\n                 // Not an expression statement.\n-                stmts += ~[stmt];\n+                stmts += [stmt];\n \n \n                 if p.get_file_type() == SOURCE_FILE &&\n@@ -1742,16 +1724,17 @@ fn parse_block_tail(p: &parser, lo: uint) -> ast::blk {\n }\n \n fn parse_ty_param(p: &parser) -> ast::ty_param {\n-    let k = alt p.peek() {\n-      token::TILDE. { p.bump(); ast::kind_unique }\n-      token::AT. { p.bump(); ast::kind_shared }\n-      _ { ast::kind_pinned }\n-    };\n+    let k =\n+        alt p.peek() {\n+          token::TILDE. { p.bump(); ast::kind_unique }\n+          token::AT. { p.bump(); ast::kind_shared }\n+          _ { ast::kind_pinned }\n+        };\n     ret {ident: parse_ident(p), kind: k};\n }\n \n fn parse_ty_params(p: &parser) -> [ast::ty_param] {\n-    let ty_params: [ast::ty_param] = ~[];\n+    let ty_params: [ast::ty_param] = [];\n     if p.peek() == token::LT {\n         p.bump();\n         ty_params = parse_seq_to_gt(some(token::COMMA), parse_ty_param, p);\n@@ -1764,16 +1747,16 @@ fn parse_ty_params(p: &parser) -> [ast::ty_param] {\n     ret ty_params;\n }\n \n-fn parse_fn_decl(p: &parser, purity: ast::purity, il: ast::inlineness)\n-        -> ast::fn_decl {\n+fn parse_fn_decl(p: &parser, purity: ast::purity, il: ast::inlineness) ->\n+   ast::fn_decl {\n     let inputs: ast::spanned<[ast::arg]> =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), parse_arg,\n                   p);\n     let rslt: ty_or_bang;\n     // Use the args list to translate each bound variable\n     // mentioned in a constraint to an arg index.\n     // Seems weird to do this in the parser, but I'm not sure how else to.\n-    let constrs = ~[];\n+    let constrs = [];\n     if p.peek() == token::COLON {\n         p.bump();\n         constrs = parse_constrs(bind parse_ty_constr(inputs.node, _), p);\n@@ -1813,7 +1796,7 @@ fn parse_fn_block_decl(p: &parser) -> ast::fn_decl {\n          purity: ast::impure_fn,\n          il: ast::il_normal,\n          cf: ast::return,\n-         constraints: ~[]};\n+         constraints: []};\n }\n \n fn parse_fn(p: &parser, proto: ast::proto, purity: ast::purity,\n@@ -1839,8 +1822,8 @@ fn mk_item(p: &parser, lo: uint, hi: uint, ident: &ast::ident,\n }\n \n fn parse_item_fn_or_iter(p: &parser, purity: ast::purity, proto: ast::proto,\n-                         attrs: &[ast::attribute], il: ast::inlineness)\n-        -> @ast::item {\n+                         attrs: &[ast::attribute], il: ast::inlineness) ->\n+   @ast::item {\n     let lo = p.get_last_lo_pos();\n     let t = parse_fn_header(p);\n     let f = parse_fn(p, proto, purity, il);\n@@ -1875,28 +1858,24 @@ fn parse_method(p: &parser) -> @ast::method {\n     ret @spanned(lo, f.body.span.hi, meth);\n }\n \n-fn parse_item_obj(p: &parser, attrs: &[ast::attribute]) ->\n-   @ast::item {\n+fn parse_item_obj(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n     let ty_params = parse_ty_params(p);\n     let fields: ast::spanned<[ast::obj_field]> =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                   parse_obj_field, p);\n-    let meths: [@ast::method] = ~[];\n+    let meths: [@ast::method] = [];\n     expect(p, token::LBRACE);\n-    while p.peek() != token::RBRACE {\n-        meths += ~[parse_method(p)];\n-    }\n+    while p.peek() != token::RBRACE { meths += [parse_method(p)]; }\n     let hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n     let ob: ast::_obj = {fields: fields.node, methods: meths};\n     ret mk_item(p, lo, hi, ident, ast::item_obj(ob, ty_params, p.get_id()),\n                 attrs);\n }\n \n-fn parse_item_res(p: &parser, attrs: &[ast::attribute]) ->\n-   @ast::item {\n+fn parse_item_res(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n     let ty_params = parse_ty_params(p);\n@@ -1908,15 +1887,15 @@ fn parse_item_res(p: &parser, attrs: &[ast::attribute]) ->\n     let dtor = parse_block(p);\n     let decl =\n         {inputs:\n-             ~[{mode: ast::alias(false),\n-                ty: t,\n-                ident: arg_ident,\n-                id: p.get_id()}],\n+             [{mode: ast::alias(false),\n+               ty: t,\n+               ident: arg_ident,\n+               id: p.get_id()}],\n          output: @spanned(lo, lo, ast::ty_nil),\n          purity: ast::impure_fn,\n          il: ast::il_normal,\n          cf: ast::return,\n-         constraints: ~[]};\n+         constraints: []};\n     let f = {decl: decl, proto: ast::proto_fn, body: dtor};\n     ret mk_item(p, lo, dtor.span.hi, ident,\n                 ast::item_res(f, p.get_id(), ty_params, p.get_id()), attrs);\n@@ -1926,14 +1905,14 @@ fn parse_mod_items(p: &parser, term: token::token,\n                    first_item_attrs: &[ast::attribute]) -> ast::_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items =\n-        if vec::len(first_item_attrs) == 0u { parse_view(p) } else { ~[] };\n-    let items: [@ast::item] = ~[];\n+        if vec::len(first_item_attrs) == 0u { parse_view(p) } else { [] };\n+    let items: [@ast::item] = [];\n     let initial_attrs = first_item_attrs;\n     while p.peek() != term {\n         let attrs = initial_attrs + parse_outer_attributes(p);\n-        initial_attrs = ~[];\n+        initial_attrs = [];\n         alt parse_item(p, attrs) {\n-          some(i) { items += ~[i]; }\n+          some(i) { items += [i]; }\n           _ {\n             p.fatal(\"expected item but found \" +\n                         token::to_str(p.get_reader(), p.peek()));\n@@ -1999,25 +1978,25 @@ fn parse_native_item(p: &parser, attrs: &[ast::attribute]) ->\n    @ast::native_item {\n     if eat_word(p, \"type\") {\n         ret parse_item_native_type(p, attrs);\n-    } else if (eat_word(p, \"fn\")) {\n+    } else if eat_word(p, \"fn\") {\n         ret parse_item_native_fn(p, attrs);\n     } else { unexpected(p, p.peek()); }\n }\n \n fn parse_native_mod_items(p: &parser, native_name: &str, abi: ast::native_abi,\n-                          first_item_attrs: &[ast::attribute])\n-    -> ast::native_mod {\n+                          first_item_attrs: &[ast::attribute]) ->\n+   ast::native_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items =\n         if vec::len(first_item_attrs) == 0u {\n             parse_native_view(p)\n-        } else { ~[] };\n-    let items: [@ast::native_item] = ~[];\n+        } else { [] };\n+    let items: [@ast::native_item] = [];\n     let initial_attrs = first_item_attrs;\n     while p.peek() != token::RBRACE {\n         let attrs = initial_attrs + parse_outer_attributes(p);\n-        initial_attrs = ~[];\n-        items += ~[parse_native_item(p, attrs)];\n+        initial_attrs = [];\n+        items += [parse_native_item(p, attrs)];\n     }\n     ret {native_name: native_name,\n          abi: abi,\n@@ -2031,13 +2010,13 @@ fn parse_item_native_mod(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     if !is_word(p, \"mod\") {\n         let t = parse_str(p);\n         if str::eq(t, \"cdecl\") {\n-        } else if (str::eq(t, \"rust\")) {\n+        } else if str::eq(t, \"rust\") {\n             abi = ast::native_abi_rust;\n-        } else if (str::eq(t, \"llvm\")) {\n+        } else if str::eq(t, \"llvm\") {\n             abi = ast::native_abi_llvm;\n-        } else if (str::eq(t, \"rust-intrinsic\")) {\n+        } else if str::eq(t, \"rust-intrinsic\") {\n             abi = ast::native_abi_rust_intrinsic;\n-        } else if (str::eq(t, \"x86stdcall\")) {\n+        } else if str::eq(t, \"x86stdcall\") {\n             abi = ast::native_abi_x86stdcall;\n         } else { p.fatal(\"unsupported abi: \" + t); }\n     }\n@@ -2079,7 +2058,7 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let id = parse_ident(p);\n     let ty_params = parse_ty_params(p);\n-    let variants: [ast::variant] = ~[];\n+    let variants: [ast::variant] = [];\n     // Newtype syntax\n     if p.peek() == token::EQ {\n         if p.get_bad_expr_words().contains_key(id) {\n@@ -2091,10 +2070,10 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n         let variant =\n             spanned(ty.span.lo, ty.span.hi,\n                     {name: id,\n-                     args: ~[{ty: ty, id: p.get_id()}],\n+                     args: [{ty: ty, id: p.get_id()}],\n                      id: p.get_id()});\n         ret mk_item(p, lo, ty.span.hi, id,\n-                    ast::item_tag(~[variant], ty_params), attrs);\n+                    ast::item_tag([variant], ty_params), attrs);\n     }\n     expect(p, token::LBRACE);\n     while p.peek() != token::RBRACE {\n@@ -2104,15 +2083,15 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n             check_bad_word(p);\n             let vlo = p.get_lo_pos();\n             p.bump();\n-            let args: [ast::variant_arg] = ~[];\n+            let args: [ast::variant_arg] = [];\n             let vhi = p.get_hi_pos();\n             alt p.peek() {\n               token::LPAREN. {\n                 let arg_tys =\n                     parse_seq(token::LPAREN, token::RPAREN,\n                               some(token::COMMA), bind parse_ty(_, false), p);\n                 for ty: @ast::ty in arg_tys.node {\n-                    args += ~[{ty: ty, id: p.get_id()}];\n+                    args += [{ty: ty, id: p.get_id()}];\n                 }\n                 vhi = arg_tys.span.hi;\n               }\n@@ -2121,7 +2100,7 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n             expect(p, token::SEMI);\n             p.get_id();\n             let vr = {name: p.get_str(name), args: args, id: p.get_id()};\n-            variants += ~[spanned(vlo, vhi, vr)];\n+            variants += [spanned(vlo, vhi, vr)];\n           }\n           token::RBRACE. {/* empty */ }\n           _ {\n@@ -2144,33 +2123,33 @@ fn parse_auth(p: &parser) -> ast::_auth {\n fn parse_item(p: &parser, attrs: &[ast::attribute]) -> option::t<@ast::item> {\n     if eat_word(p, \"const\") {\n         ret some(parse_item_const(p, attrs));\n-    } else if (eat_word(p, \"inline\")) {\n+    } else if eat_word(p, \"inline\") {\n         expect_word(p, \"fn\");\n         ret some(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_fn,\n                                        attrs, ast::il_inline));\n-    } else if (is_word(p, \"fn\") && p.look_ahead(1u) != token::LPAREN) {\n+    } else if is_word(p, \"fn\") && p.look_ahead(1u) != token::LPAREN {\n         p.bump();\n         ret some(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_fn,\n                                        attrs, ast::il_normal));\n-    } else if (eat_word(p, \"pred\")) {\n-        ret some(parse_item_fn_or_iter(p, ast::pure_fn, ast::proto_fn,\n-                                       attrs, ast::il_normal));\n-    } else if (eat_word(p, \"iter\")) {\n+    } else if eat_word(p, \"pred\") {\n+        ret some(parse_item_fn_or_iter(p, ast::pure_fn, ast::proto_fn, attrs,\n+                                       ast::il_normal));\n+    } else if eat_word(p, \"iter\") {\n         ret some(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_iter,\n                                        attrs, ast::il_normal));\n-    } else if (eat_word(p, \"mod\")) {\n+    } else if eat_word(p, \"mod\") {\n         ret some(parse_item_mod(p, attrs));\n-    } else if (eat_word(p, \"native\")) {\n+    } else if eat_word(p, \"native\") {\n         ret some(parse_item_native_mod(p, attrs));\n     }\n     if eat_word(p, \"type\") {\n         ret some(parse_item_type(p, attrs));\n-    } else if (eat_word(p, \"tag\")) {\n+    } else if eat_word(p, \"tag\") {\n         ret some(parse_item_tag(p, attrs));\n-    } else if (is_word(p, \"obj\") && p.look_ahead(1u) != token::LPAREN) {\n+    } else if is_word(p, \"obj\") && p.look_ahead(1u) != token::LPAREN {\n         p.bump();\n         ret some(parse_item_obj(p, attrs));\n-    } else if (eat_word(p, \"resource\")) {\n+    } else if eat_word(p, \"resource\") {\n         ret some(parse_item_res(p, attrs));\n     } else { ret none; }\n }\n@@ -2185,18 +2164,18 @@ fn parse_outer_attrs_or_ext(p: &parser) -> attr_or_ext {\n         p.bump();\n         if p.peek() == token::LBRACKET {\n             let first_attr = parse_attribute_naked(p, ast::attr_outer, lo);\n-            ret some(left(~[first_attr] + parse_outer_attributes(p)));\n-        } else if (!(p.peek() == token::LT || p.peek() == token::LBRACKET)) {\n+            ret some(left([first_attr] + parse_outer_attributes(p)));\n+        } else if !(p.peek() == token::LT || p.peek() == token::LBRACKET) {\n             ret some(right(parse_syntax_ext_naked(p, lo)));\n         } else { ret none; }\n     } else { ret none; }\n }\n \n // Parse attributes that appear before an item\n fn parse_outer_attributes(p: &parser) -> [ast::attribute] {\n-    let attrs: [ast::attribute] = ~[];\n+    let attrs: [ast::attribute] = [];\n     while p.peek() == token::POUND {\n-        attrs += ~[parse_attribute(p, ast::attr_outer)];\n+        attrs += [parse_attribute(p, ast::attr_outer)];\n     }\n     ret attrs;\n }\n@@ -2224,19 +2203,19 @@ fn parse_attribute_naked(p: &parser, style: ast::attr_style, lo: uint) ->\n // until we see the semi).\n fn parse_inner_attrs_and_next(p: &parser) ->\n    {inner: [ast::attribute], next: [ast::attribute]} {\n-    let inner_attrs: [ast::attribute] = ~[];\n-    let next_outer_attrs: [ast::attribute] = ~[];\n+    let inner_attrs: [ast::attribute] = [];\n+    let next_outer_attrs: [ast::attribute] = [];\n     while p.peek() == token::POUND {\n         let attr = parse_attribute(p, ast::attr_inner);\n         if p.peek() == token::SEMI {\n             p.bump();\n-            inner_attrs += ~[attr];\n+            inner_attrs += [attr];\n         } else {\n             // It's not really an inner attribute\n             let outer_attr =\n                 spanned(attr.span.lo, attr.span.hi,\n                         {style: ast::attr_outer, value: attr.node.value});\n-            next_outer_attrs += ~[outer_attr];\n+            next_outer_attrs += [outer_attr];\n             break;\n         }\n     }\n@@ -2271,7 +2250,7 @@ fn parse_meta_seq(p: &parser) -> [@ast::meta_item] {\n }\n \n fn parse_optional_meta(p: &parser) -> [@ast::meta_item] {\n-    alt p.peek() { token::LPAREN. { ret parse_meta_seq(p); } _ { ret ~[]; } }\n+    alt p.peek() { token::LPAREN. { ret parse_meta_seq(p); } _ { ret []; } }\n }\n \n fn parse_use(p: &parser) -> ast::view_item_ {\n@@ -2283,16 +2262,14 @@ fn parse_use(p: &parser) -> ast::view_item_ {\n fn parse_rest_import_name(p: &parser, first: ast::ident,\n                           def_ident: option::t<ast::ident>) ->\n    ast::view_item_ {\n-    let identifiers: [ast::ident] = ~[first];\n+    let identifiers: [ast::ident] = [first];\n     let glob: bool = false;\n     let from_idents = option::none::<[ast::import_ident]>;\n     while true {\n         alt p.peek() {\n           token::SEMI. { break; }\n           token::MOD_SEP. {\n-            if glob {\n-                p.fatal(\"cannot path into a glob\");\n-            }\n+            if glob { p.fatal(\"cannot path into a glob\"); }\n             if option::is_some(from_idents) {\n                 p.fatal(\"cannot path into import list\");\n             }\n@@ -2301,41 +2278,41 @@ fn parse_rest_import_name(p: &parser, first: ast::ident,\n           _ { p.fatal(\"expecting '::' or ';'\"); }\n         }\n         alt p.peek() {\n-          token::IDENT(_, _) { identifiers += ~[parse_ident(p)]; }\n+          token::IDENT(_, _) { identifiers += [parse_ident(p)]; }\n+\n \n           //the lexer can't tell the different kinds of stars apart ) :\n           token::BINOP(token::STAR.) {\n             glob = true;\n             p.bump();\n           }\n \n+\n           token::LBRACE. {\n             fn parse_import_ident(p: &parser) -> ast::import_ident {\n                 let lo = p.get_lo_pos();\n                 let ident = parse_ident(p);\n                 let hi = p.get_hi_pos();\n-                ret spanned(lo, hi, {name: ident,\n-                                     id: p.get_id()});\n+                ret spanned(lo, hi, {name: ident, id: p.get_id()});\n             }\n-            let from_idents_ = parse_seq(token::LBRACE,\n-                                         token::RBRACE,\n-                                         some(token::COMMA),\n-                                         parse_import_ident,\n-                                         p).node;\n+            let from_idents_ =\n+                parse_seq(token::LBRACE, token::RBRACE, some(token::COMMA),\n+                          parse_import_ident, p).node;\n             if vec::is_empty(from_idents_) {\n                 p.fatal(\"at least one import is required\");\n             }\n             from_idents = some(from_idents_);\n           }\n \n-          _ { p.fatal(\"expecting an identifier, or '*'\"); }\n+\n+          _ {\n+            p.fatal(\"expecting an identifier, or '*'\");\n+          }\n         }\n     }\n     alt def_ident {\n       some(i) {\n-        if glob {\n-            p.fatal(\"globbed imports can't be renamed\");\n-        }\n+        if glob { p.fatal(\"globbed imports can't be renamed\"); }\n         if option::is_some(from_idents) {\n             p.fatal(\"can't rename import list\");\n         }\n@@ -2350,7 +2327,7 @@ fn parse_rest_import_name(p: &parser, first: ast::ident,\n                                            p.get_id());\n         } else {\n             let len = vec::len(identifiers);\n-            ret ast::view_item_import(identifiers.(len - 1u), identifiers,\n+            ret ast::view_item_import(identifiers[len - 1u], identifiers,\n                                       p.get_id());\n         }\n       }\n@@ -2385,8 +2362,9 @@ fn parse_import(p: &parser) -> ast::view_item_ {\n }\n \n fn parse_export(p: &parser) -> ast::view_item_ {\n-    let ids = parse_seq_to_before_end(\n-        token::SEMI, option::some(token::COMMA), parse_ident, p);\n+    let ids =\n+        parse_seq_to_before_end(token::SEMI, option::some(token::COMMA),\n+                                parse_ident, p);\n     ret ast::view_item_export(ids, p.get_id());\n }\n \n@@ -2395,9 +2373,9 @@ fn parse_view_item(p: &parser) -> @ast::view_item {\n     let the_item =\n         if eat_word(p, \"use\") {\n             parse_use(p)\n-        } else if (eat_word(p, \"import\")) {\n+        } else if eat_word(p, \"import\") {\n             parse_import(p)\n-        } else if (eat_word(p, \"export\")) { parse_export(p) } else { fail };\n+        } else if eat_word(p, \"export\") { parse_export(p) } else { fail };\n     let hi = p.get_lo_pos();\n     expect(p, token::SEMI);\n     ret @spanned(lo, hi, the_item);\n@@ -2415,14 +2393,14 @@ fn is_view_item(p: &parser) -> bool {\n }\n \n fn parse_view(p: &parser) -> [@ast::view_item] {\n-    let items: [@ast::view_item] = ~[];\n-    while is_view_item(p) { items += ~[parse_view_item(p)]; }\n+    let items: [@ast::view_item] = [];\n+    while is_view_item(p) { items += [parse_view_item(p)]; }\n     ret items;\n }\n \n fn parse_native_view(p: &parser) -> [@ast::view_item] {\n-    let items: [@ast::view_item] = ~[];\n-    while is_view_item(p) { items += ~[parse_view_item(p)]; }\n+    let items: [@ast::view_item] = [];\n+    while is_view_item(p) { items += [parse_view_item(p)]; }\n     ret items;\n }\n \n@@ -2436,22 +2414,21 @@ fn parse_crate_from_source_str(name: &str, source: &str, cfg: &ast::crate_cfg,\n                                sess: &parse_sess) -> @ast::crate {\n     let ftype = SOURCE_FILE;\n     let filemap = codemap::new_filemap(name, 0u, 0u);\n-    sess.cm.files += ~[filemap];\n+    sess.cm.files += [filemap];\n     let itr = @interner::mk(str::hash, str::eq);\n     let rdr = lexer::new_reader(sess.cm, source, filemap, itr);\n     let p = new_parser(sess, cfg, rdr, ftype);\n     ret parse_crate_mod(p, cfg);\n }\n \n // Parses a source module as a crate\n-fn parse_crate_mod(p: &parser, _cfg: &ast::crate_cfg) ->\n-   @ast::crate {\n+fn parse_crate_mod(p: &parser, _cfg: &ast::crate_cfg) -> @ast::crate {\n     let lo = p.get_lo_pos();\n     let crate_attrs = parse_inner_attrs_and_next(p);\n     let first_item_outer_attrs = crate_attrs.next;\n     let m = parse_mod_items(p, token::EOF, first_item_outer_attrs);\n     ret @spanned(lo, p.get_lo_pos(),\n-                 {directives: ~[],\n+                 {directives: [],\n                   module: m,\n                   attrs: crate_attrs.inner,\n                   config: p.get_cfg()});\n@@ -2488,13 +2465,15 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n             };\n         alt p.peek() {\n \n+\n           // mod x = \"foo.rs\";\n           token::SEMI. {\n             let hi = p.get_hi_pos();\n             p.bump();\n             ret spanned(lo, hi, ast::cdir_src_mod(id, file_opt, outer_attrs));\n           }\n \n+\n           // mod x = \"foo_dir\" { ...directives... }\n           token::LBRACE. {\n             p.bump();\n@@ -2510,14 +2489,14 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n           }\n           t { unexpected(p, t); }\n         }\n-    } else if (eat_word(p, \"auth\")) {\n+    } else if eat_word(p, \"auth\") {\n         let n = parse_path(p);\n         expect(p, token::EQ);\n         let a = parse_auth(p);\n         let hi = p.get_hi_pos();\n         expect(p, token::SEMI);\n         ret spanned(lo, hi, ast::cdir_auth(n, a));\n-    } else if (is_view_item(p)) {\n+    } else if is_view_item(p) {\n         let vi = parse_view_item(p);\n         ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n     } else { ret p.fatal(\"expected crate directive\"); }\n@@ -2534,10 +2513,10 @@ fn parse_crate_directives(p: &parser, term: token::token,\n         expect_word(p, \"mod\");\n     }\n \n-    let cdirs: [@ast::crate_directive] = ~[];\n+    let cdirs: [@ast::crate_directive] = [];\n     while p.peek() != term {\n         let cdir = @parse_crate_directive(p, first_outer_attr);\n-        cdirs += ~[cdir];\n+        cdirs += [cdir];\n     }\n     ret cdirs;\n }\n@@ -2551,7 +2530,7 @@ fn parse_crate_from_crate_file(input: &str, cfg: &ast::crate_cfg,\n     let crate_attrs = leading_attrs.inner;\n     let first_cdir_attr = leading_attrs.next;\n     let cdirs = parse_crate_directives(p, token::EOF, first_cdir_attr);\n-    let deps: [str] = ~[];\n+    let deps: [str] = [];\n     let cx =\n         @{p: p,\n           mode: eval::mode_parse,\n@@ -2570,15 +2549,14 @@ fn parse_crate_from_crate_file(input: &str, cfg: &ast::crate_cfg,\n                   config: p.get_cfg()});\n }\n \n-fn parse_crate_from_file(input: &str, cfg: &ast::crate_cfg,\n-                         sess: &parse_sess) -> @ast::crate {\n+fn parse_crate_from_file(input: &str, cfg: &ast::crate_cfg, sess: &parse_sess)\n+   -> @ast::crate {\n     if str::ends_with(input, \".rc\") {\n         parse_crate_from_crate_file(input, cfg, sess)\n     } else if str::ends_with(input, \".rs\") {\n         parse_crate_from_source_file(input, cfg, sess)\n     } else {\n-        codemap::emit_error(none,\n-                            \"unknown input file type: \" + input,\n+        codemap::emit_error(none, \"unknown input file type: \" + input,\n                             sess.cm);\n         fail\n     }"}, {"sha": "c974dc915c45a003aa7927b852fbf5fe3a67ad77", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -116,6 +116,7 @@ fn to_str(r: lexer::reader, t: token) -> str {\n       BINOP(op) { ret binop_to_str(op); }\n       BINOPEQ(op) { ret binop_to_str(op) + \"=\"; }\n \n+\n       /* Structural symbols */\n       AT. {\n         ret \"@\";\n@@ -140,6 +141,7 @@ fn to_str(r: lexer::reader, t: token) -> str {\n       POUND_LBRACE. { ret \"#{\"; }\n       POUND_LT. { ret \"#<\"; }\n \n+\n       /* Literals */\n       LIT_INT(i) {\n         ret int::to_str(i, 10u);\n@@ -165,6 +167,7 @@ fn to_str(r: lexer::reader, t: token) -> str {\n       }\n       LIT_BOOL(b) { if b { ret \"true\"; } else { ret \"false\"; } }\n \n+\n       /* Name components */\n       IDENT(s, _) {\n         ret interner::get::<str>(*r.get_interner(), s);"}, {"sha": "adeccd4150cbddcb5b0cbb334ae0f3be1105edf4", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 49, "deletions": 52, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -66,7 +66,7 @@ tag token { STRING(str, int); BREAK(break_t); BEGIN(begin_t); END; EOF; }\n \n fn tok_str(t: token) -> str {\n     alt t {\n-      STRING(s, len) { ret #fmt(\"STR(%s,%d)\", s, len); }\n+      STRING(s, len) { ret #fmt[\"STR(%s,%d)\", s, len]; }\n       BREAK(_) { ret \"BREAK\"; }\n       BEGIN(_) { ret \"BEGIN\"; }\n       END. { ret \"END\"; }\n@@ -84,7 +84,7 @@ fn buf_str(toks: &[mutable token], szs: &[mutable int], left: uint,\n     while i != right && L != 0u {\n         L -= 1u;\n         if i != left { s += \", \"; }\n-        s += #fmt(\"%d=%s\", szs.(i), tok_str(toks.(i)));\n+        s += #fmt[\"%d=%s\", szs[i], tok_str(toks[i])];\n         i += 1u;\n         i %= n;\n     }\n@@ -103,11 +103,11 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n     // fall behind.\n \n     let n: uint = 3u * linewidth;\n-    log #fmt(\"mk_printer %u\", linewidth);\n+    log #fmt[\"mk_printer %u\", linewidth];\n     let token: [mutable token] = vec::init_elt_mut(EOF, n);\n     let size: [mutable int] = vec::init_elt_mut(0, n);\n     let scan_stack: [mutable uint] = vec::init_elt_mut(0u, n);\n-    let print_stack: [print_stack_elt] = ~[];\n+    let print_stack: [print_stack_elt] = [];\n     ret printer(out, n, linewidth as int, // margin\n                 linewidth as int, // space\n                 0u, // left\n@@ -237,18 +237,18 @@ obj printer(out: io::writer,\n             // buffered indentation to avoid writing trailing whitespace\n             mutable pending_indentation: int) {\n \n-    fn last_token() -> token { ret token.(right); }\n+    fn last_token() -> token { ret token[right]; }\n \n     // be very careful with this!\n-    fn replace_last_token(t: token) { token.(right) = t; }\n+    fn replace_last_token(t: token) { token[right] = t; }\n \n     fn pretty_print(t: token) {\n-        log #fmt(\"pp [%u,%u]\", left, right);\n+        log #fmt[\"pp [%u,%u]\", left, right];\n         alt t {\n           EOF. {\n             if !scan_stack_empty {\n                 self.check_stack(0);\n-                self.advance_left(token.(left), size.(left));\n+                self.advance_left(token[left], size[left]);\n             }\n             self.indent(0);\n           }\n@@ -259,20 +259,20 @@ obj printer(out: io::writer,\n                 left = 0u;\n                 right = 0u;\n             } else { self.advance_right(); }\n-            log #fmt(\"pp BEGIN/buffer [%u,%u]\", left, right);\n-            token.(right) = t;\n-            size.(right) = -right_total;\n+            log #fmt[\"pp BEGIN/buffer [%u,%u]\", left, right];\n+            token[right] = t;\n+            size[right] = -right_total;\n             self.scan_push(right);\n           }\n           END. {\n             if scan_stack_empty {\n-                log #fmt(\"pp END/print [%u,%u]\", left, right);\n+                log #fmt[\"pp END/print [%u,%u]\", left, right];\n                 self.print(t, 0);\n             } else {\n-                log #fmt(\"pp END/buffer [%u,%u]\", left, right);\n+                log #fmt[\"pp END/buffer [%u,%u]\", left, right];\n                 self.advance_right();\n-                token.(right) = t;\n-                size.(right) = -1;\n+                token[right] = t;\n+                size[right] = -1;\n                 self.scan_push(right);\n             }\n           }\n@@ -283,66 +283,63 @@ obj printer(out: io::writer,\n                 left = 0u;\n                 right = 0u;\n             } else { self.advance_right(); }\n-            log #fmt(\"pp BREAK/buffer [%u,%u]\", left, right);\n+            log #fmt[\"pp BREAK/buffer [%u,%u]\", left, right];\n             self.check_stack(0);\n             self.scan_push(right);\n-            token.(right) = t;\n-            size.(right) = -right_total;\n+            token[right] = t;\n+            size[right] = -right_total;\n             right_total += b.blank_space;\n           }\n           STRING(s, len) {\n             if scan_stack_empty {\n-                log #fmt(\"pp STRING/print [%u,%u]\", left, right);\n+                log #fmt[\"pp STRING/print [%u,%u]\", left, right];\n                 self.print(t, len);\n             } else {\n-                log #fmt(\"pp STRING/buffer [%u,%u]\", left, right);\n+                log #fmt[\"pp STRING/buffer [%u,%u]\", left, right];\n                 self.advance_right();\n-                token.(right) = t;\n-                size.(right) = len;\n+                token[right] = t;\n+                size[right] = len;\n                 right_total += len;\n                 self.check_stream();\n             }\n           }\n         }\n     }\n     fn check_stream() {\n-        log #fmt(\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n-                 left, right, left_total, right_total);\n+        log #fmt[\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n+                 left, right, left_total, right_total];\n         if right_total - left_total > space {\n-            log #fmt(\"scan window is %d, longer than space on line (%d)\",\n-                     right_total - left_total, space);\n+            log #fmt[\"scan window is %d, longer than space on line (%d)\",\n+                     right_total - left_total, space];\n             if !scan_stack_empty {\n-                if left == scan_stack.(bottom) {\n-                    log #fmt(\"setting %u to infinity and popping\", left);\n-                    size.(self.scan_pop_bottom()) = size_infinity;\n+                if left == scan_stack[bottom] {\n+                    log #fmt[\"setting %u to infinity and popping\", left];\n+                    size[self.scan_pop_bottom()] = size_infinity;\n                 }\n             }\n-            self.advance_left(token.(left), size.(left));\n+            self.advance_left(token[left], size[left]);\n             if left != right { self.check_stream(); }\n         }\n     }\n     fn scan_push(x: uint) {\n-        log #fmt(\"scan_push %u\", x);\n+        log #fmt[\"scan_push %u\", x];\n         if scan_stack_empty {\n             scan_stack_empty = false;\n         } else { top += 1u; top %= buf_len; assert (top != bottom); }\n-        scan_stack.(top) = x;\n+        scan_stack[top] = x;\n     }\n     fn scan_pop() -> uint {\n         assert (!scan_stack_empty);\n-        let x = scan_stack.(top);\n+        let x = scan_stack[top];\n         if top == bottom {\n             scan_stack_empty = true;\n         } else { top += buf_len - 1u; top %= buf_len; }\n         ret x;\n     }\n-    fn scan_top() -> uint {\n-        assert (!scan_stack_empty);\n-        ret scan_stack.(top);\n-    }\n+    fn scan_top() -> uint { assert (!scan_stack_empty); ret scan_stack[top]; }\n     fn scan_pop_bottom() -> uint {\n         assert (!scan_stack_empty);\n-        let x = scan_stack.(bottom);\n+        let x = scan_stack[bottom];\n         if top == bottom {\n             scan_stack_empty = true;\n         } else { bottom += 1u; bottom %= buf_len; }\n@@ -354,7 +351,7 @@ obj printer(out: io::writer,\n         assert (right != left);\n     }\n     fn advance_left(x: token, L: int) {\n-        log #fmt(\"advnce_left [%u,%u], sizeof(%u)=%d\", left, right, left, L);\n+        log #fmt[\"advnce_left [%u,%u], sizeof(%u)=%d\", left, right, left, L];\n         if L >= 0 {\n             self.print(x, L);\n             alt x {\n@@ -365,47 +362,47 @@ obj printer(out: io::writer,\n             if left != right {\n                 left += 1u;\n                 left %= buf_len;\n-                self.advance_left(token.(left), size.(left));\n+                self.advance_left(token[left], size[left]);\n             }\n         }\n     }\n     fn check_stack(k: int) {\n         if !scan_stack_empty {\n             let x = self.scan_top();\n-            alt token.(x) {\n+            alt token[x] {\n               BEGIN(b) {\n                 if k > 0 {\n-                    size.(self.scan_pop()) = size.(x) + right_total;\n+                    size[self.scan_pop()] = size[x] + right_total;\n                     self.check_stack(k - 1);\n                 }\n               }\n               END. {\n                 // paper says + not =, but that makes no sense.\n \n-                size.(self.scan_pop()) = 1;\n+                size[self.scan_pop()] = 1;\n                 self.check_stack(k + 1);\n               }\n               _ {\n-                size.(self.scan_pop()) = size.(x) + right_total;\n+                size[self.scan_pop()] = size[x] + right_total;\n                 if k > 0 { self.check_stack(k); }\n               }\n             }\n         }\n     }\n     fn print_newline(amount: int) {\n-        log #fmt(\"NEWLINE %d\", amount);\n+        log #fmt[\"NEWLINE %d\", amount];\n         out.write_str(\"\\n\");\n         pending_indentation = 0;\n         self.indent(amount);\n     }\n     fn indent(amount: int) {\n-        log #fmt(\"INDENT %d\", amount);\n+        log #fmt[\"INDENT %d\", amount];\n         pending_indentation += amount;\n     }\n     fn top() -> print_stack_elt {\n         let n = vec::len(print_stack);\n         let top: print_stack_elt = {offset: 0, pbreak: broken(inconsistent)};\n-        if n != 0u { top = print_stack.(n - 1u); }\n+        if n != 0u { top = print_stack[n - 1u]; }\n         ret top;\n     }\n     fn write_str(s: str) {\n@@ -416,18 +413,18 @@ obj printer(out: io::writer,\n         out.write_str(s);\n     }\n     fn print(x: token, L: int) {\n-        log #fmt(\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n-                 space);\n+        log #fmt[\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n+                 space];\n         log buf_str(token, size, left, right, 6u);\n         alt x {\n           BEGIN(b) {\n             if L > space {\n                 let col = margin - space + b.offset;\n-                log #fmt(\"print BEGIN -> push broken block at col %d\", col);\n-                print_stack += ~[{offset: col, pbreak: broken(b.breaks)}];\n+                log #fmt[\"print BEGIN -> push broken block at col %d\", col];\n+                print_stack += [{offset: col, pbreak: broken(b.breaks)}];\n             } else {\n                 log \"print BEGIN -> push fitting block\";\n-                print_stack += ~[{offset: 0, pbreak: fits}];\n+                print_stack += [{offset: 0, pbreak: fits}];\n             }\n           }\n           END. {"}, {"sha": "c0e38a3b40e0ee72f9681472cff951caff29de52", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 133, "deletions": 167, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -32,7 +32,7 @@ tag ann_node {\n     node_expr(ps, @ast::expr);\n     node_pat(ps, @ast::pat);\n }\n-type pp_ann = {pre: fn(&ann_node) , post: fn(&ann_node) };\n+type pp_ann = {pre: fn(&ann_node), post: fn(&ann_node)};\n \n fn no_ann() -> pp_ann {\n     fn ignore(_node: &ann_node) { }\n@@ -49,12 +49,12 @@ type ps =\n       mutable boxes: [pp::breaks],\n       ann: pp_ann};\n \n-fn ibox(s: &ps, u: uint) { s.boxes += ~[pp::inconsistent]; pp::ibox(s.s, u); }\n+fn ibox(s: &ps, u: uint) { s.boxes += [pp::inconsistent]; pp::ibox(s.s, u); }\n \n fn end(s: &ps) { vec::pop(s.boxes); pp::end(s.s); }\n \n fn rust_printer(writer: io::writer) -> ps {\n-    let boxes: [pp::breaks] = ~[];\n+    let boxes: [pp::breaks] = [];\n     ret @{s: pp::mk_printer(writer, default_columns),\n           cm: none::<codemap>,\n           comments: none::<[lexer::cmnt]>,\n@@ -75,7 +75,7 @@ const default_columns: uint = 78u;\n // copy forward.\n fn print_crate(cm: &codemap, crate: @ast::crate, filename: str,\n                in: io::reader, out: io::writer, ann: &pp_ann) {\n-    let boxes: [pp::breaks] = ~[];\n+    let boxes: [pp::breaks] = [];\n     let r = lexer::gather_comments_and_literals(cm, filename, in);\n     let s =\n         @{s: pp::mk_printer(out, default_columns),\n@@ -135,12 +135,9 @@ fn attribute_to_str(attr: &ast::attribute) -> str {\n     be to_str(attr, print_attribute);\n }\n \n-fn cbox(s: &ps, u: uint) { s.boxes += ~[pp::consistent]; pp::cbox(s.s, u); }\n+fn cbox(s: &ps, u: uint) { s.boxes += [pp::consistent]; pp::cbox(s.s, u); }\n \n-fn box(s: &ps, u: uint, b: pp::breaks) {\n-    s.boxes += ~[b];\n-    pp::box(s.s, u, b);\n-}\n+fn box(s: &ps, u: uint, b: pp::breaks) { s.boxes += [b]; pp::box(s.s, u, b); }\n \n fn nbsp(s: &ps) { word(s.s, \" \"); }\n \n@@ -175,22 +172,16 @@ fn bclose_(s: &ps, span: codemap::span, indented: uint) {\n fn bclose(s: &ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n \n fn is_begin(s: &ps) -> bool {\n-    alt s.s.last_token() {\n-      pp::BEGIN(_) { true }\n-      _ { false }\n-    }\n+    alt s.s.last_token() { pp::BEGIN(_) { true } _ { false } }\n }\n \n fn is_end(s: &ps) -> bool {\n-    alt s.s.last_token() {\n-      pp::END. { true }\n-      _ { false }\n-    }\n+    alt s.s.last_token() { pp::END. { true } _ { false } }\n }\n \n fn is_bol(s: &ps) -> bool {\n     ret s.s.last_token() == pp::EOF ||\n-        s.s.last_token() == pp::hardbreak_tok();\n+            s.s.last_token() == pp::hardbreak_tok();\n }\n \n fn hardbreak_if_not_bol(s: &ps) { if !is_bol(s) { hardbreak(s.s); } }\n@@ -218,7 +209,7 @@ fn synth_comment(s: &ps, text: str) {\n     word(s.s, \"*/\");\n }\n \n-fn commasep<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ) {\n+fn commasep<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN)) {\n     box(s, 0u, b);\n     let first = true;\n     for elt: IN in elts {\n@@ -229,8 +220,8 @@ fn commasep<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ) {\n }\n \n \n-fn commasep_cmnt<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ,\n-                     get_span: fn(&IN) -> codemap::span ) {\n+fn commasep_cmnt<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN),\n+                     get_span: fn(&IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n     let i = 0u;\n@@ -241,7 +232,7 @@ fn commasep_cmnt<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ,\n         if i < len {\n             word(s.s, \",\");\n             maybe_print_trailing_comment(s, get_span(elt),\n-                                         some(get_span(elts.(i)).hi));\n+                                         some(get_span(elts[i]).hi));\n             space_if_not_bol(s);\n         }\n     }\n@@ -290,7 +281,7 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n         alt mt.mut {\n           ast::mut. { word_space(s, \"mutable\"); }\n           ast::maybe_mut. { word_space(s, \"mutable?\"); }\n-          ast::imm. {}\n+          ast::imm. { }\n         }\n         print_type(s, mt.ty);\n         word(s.s, \"]\");\n@@ -322,9 +313,9 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n         word(s.s, \"}\");\n       }\n       ast::ty_tup(elts) {\n-          popen(s);\n-          commasep(s, inconsistent, elts, print_type);\n-          pclose(s);\n+        popen(s);\n+        commasep(s, inconsistent, elts, print_type);\n+        pclose(s);\n       }\n       ast::ty_fn(proto, inputs, output, cf, constrs) {\n         print_ty_fn(s, proto, none::<str>, inputs, output, cf, constrs);\n@@ -371,6 +362,7 @@ fn print_native_item(s: &ps, item: &@ast::native_item) {\n       }\n \n \n+\n       ast::native_item_fn(lname, decl, typarams) {\n         print_fn(s, decl, ast::proto_fn, item.ident, typarams,\n                  decl.constraints);\n@@ -457,8 +449,8 @@ fn print_item(s: &ps, item: &@ast::item) {\n       ast::item_tag(variants, params) {\n         let newtype =\n             vec::len(variants) == 1u &&\n-                str::eq(item.ident, variants.(0).node.name) &&\n-                vec::len(variants.(0).node.args) == 1u;\n+                str::eq(item.ident, variants[0].node.name) &&\n+                vec::len(variants[0].node.args) == 1u;\n         if newtype {\n             ibox(s, indent_unit);\n             word_space(s, \"tag\");\n@@ -468,7 +460,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n         space(s.s);\n         if newtype {\n             word_space(s, \"=\");\n-            print_type(s, variants.(0).node.args.(0).ty);\n+            print_type(s, variants[0].node.args[0].ty);\n             word(s.s, \";\");\n             end(s);\n         } else {\n@@ -509,11 +501,11 @@ fn print_item(s: &ps, item: &@ast::item) {\n         space(s.s);\n         bopen(s);\n         for meth: @ast::method in _obj.methods {\n-            let typarams: [ast::ty_param] = ~[];\n+            let typarams: [ast::ty_param] = [];\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, meth.span.lo);\n             print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n-                     meth.node.ident, typarams, ~[]);\n+                     meth.node.ident, typarams, []);\n             word(s.s, \" \");\n             print_block(s, meth.node.meth.body);\n         }\n@@ -524,8 +516,8 @@ fn print_item(s: &ps, item: &@ast::item) {\n         word(s.s, item.ident);\n         print_type_params(s, tps);\n         popen(s);\n-        word_space(s, dt.decl.inputs.(0).ident + \":\");\n-        print_type(s, dt.decl.inputs.(0).ty);\n+        word_space(s, dt.decl.inputs[0].ident + \":\");\n+        print_type(s, dt.decl.inputs[0].ty);\n         pclose(s);\n         space(s.s);\n         print_block(s, dt.body);\n@@ -620,96 +612,86 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n     // extra semi to make sure the output retains the same meaning.\n     fn maybe_protect_block(s: &ps, last: &option::t<@ast::stmt>,\n                            next: &expr_or_stmt) {\n-        let last_expr_is_block = alt last {\n-          option::some(@{node: ast::stmt_expr(e, _), _}) {\n-            alt e.node {\n-              ast::expr_if(_ ,_ ,_)\n-              | ast::expr_alt(_, _)\n-              | ast::expr_block(_) { true }\n+        let last_expr_is_block =\n+            alt last {\n+              option::some(@{node: ast::stmt_expr(e, _), _}) {\n+                alt e.node {\n+                  ast::expr_if(_, _, _) | ast::expr_alt(_, _) |\n+                  ast::expr_block(_) {\n+                    true\n+                  }\n+                  _ { false }\n+                }\n+                true\n+              }\n               _ { false }\n-            }\n-            true\n-          }\n-          _ { false }\n-        };\n+            };\n \n         if !last_expr_is_block { ret; }\n \n-        let next_expr_is_ambig = alt next {\n-          expr_(e) { expr_is_ambig(e) }\n-          stmt_(@{node: ast::stmt_expr(e, _), _}) {\n-            expr_is_ambig(e)\n-          }\n-          _ { false }\n-        };\n+        let next_expr_is_ambig =\n+            alt next {\n+              expr_(e) { expr_is_ambig(e) }\n+              stmt_(@{node: ast::stmt_expr(e, _), _}) { expr_is_ambig(e) }\n+              _ { false }\n+            };\n \n-        if last_expr_is_block && next_expr_is_ambig {\n-            word(s.s, \";\");\n-        }\n+        if last_expr_is_block && next_expr_is_ambig { word(s.s, \";\"); }\n \n         fn expr_is_ambig(ex: @ast::expr) -> bool {\n-          // We're going to walk the expression to the 'left' looking for\n-          // various properties that might indicate ambiguity\n-\n-          type env = @mutable bool;\n-          let visitor = visit::mk_vt(@{\n-              visit_expr: visit_expr\n-                  with *visit::default_visitor()\n-          });\n-          let env = @mutable false;\n-          visit_expr(ex, env, visitor);\n-          ret *env;\n-\n-          fn visit_expr(ex: &@ast::expr, e: &env, v: &visit::vt<env>) {\n-              assert *e == false;\n-\n-              if expr_is_ambig(ex) {\n-                  *e = true;\n-                  ret;\n-              }\n-\n-              alt ex.node {\n-                ast::expr_assign(x, _) { v.visit_expr(x, e, v); }\n-                ast::expr_assign_op(_, x, _) { visit_expr(x, e, v); }\n-                ast::expr_move(x, _) { v.visit_expr(x, e, v); }\n-                ast::expr_field(x, _) { v.visit_expr(x, e, v); }\n-                ast::expr_index(x, _) { v.visit_expr(x, e, v); }\n-                ast::expr_binary(op, x, _) {\n-                  if need_parens(x, operator_prec(op)) {\n-                      *e = true;\n-                      ret;\n+            // We're going to walk the expression to the 'left' looking for\n+            // various properties that might indicate ambiguity\n+\n+            type env = @mutable bool;\n+            let visitor =\n+                visit::mk_vt(@{visit_expr: visit_expr\n+                                  with *visit::default_visitor()});\n+            let env = @mutable false;\n+            visit_expr(ex, env, visitor);\n+            ret *env;\n+\n+            fn visit_expr(ex: &@ast::expr, e: &env, v: &visit::vt<env>) {\n+                assert (*e == false);\n+\n+                if expr_is_ambig(ex) { *e = true; ret; }\n+\n+                alt ex.node {\n+                  ast::expr_assign(x, _) { v.visit_expr(x, e, v); }\n+                  ast::expr_assign_op(_, x, _) { visit_expr(x, e, v); }\n+                  ast::expr_move(x, _) { v.visit_expr(x, e, v); }\n+                  ast::expr_field(x, _) { v.visit_expr(x, e, v); }\n+                  ast::expr_index(x, _) { v.visit_expr(x, e, v); }\n+                  ast::expr_binary(op, x, _) {\n+                    if need_parens(x, operator_prec(op)) { *e = true; ret; }\n+                    v.visit_expr(x, e, v);\n                   }\n-                  v.visit_expr(x, e, v);\n-                }\n-                ast::expr_cast(x, _) {\n-                  if need_parens(x, parse::parser::as_prec) {\n-                      *e = true;\n-                      ret;\n+                  ast::expr_cast(x, _) {\n+                    if need_parens(x, parse::parser::as_prec) {\n+                        *e = true;\n+                        ret;\n+                    }\n                   }\n+                  ast::expr_ternary(x, _, _) { v.visit_expr(x, e, v); }\n+                  _ { }\n                 }\n-                ast::expr_ternary(x, _, _) { v.visit_expr(x, e, v); }\n-                _ { }\n-              }\n-          }\n+            }\n \n-          fn expr_is_ambig(ex: @ast::expr) -> bool {\n-              alt ex.node {\n-                ast::expr_unary(_, _) { true }\n-                ast::expr_tup(_) { true }\n-                _ { false }\n-              }\n-          }\n+            fn expr_is_ambig(ex: @ast::expr) -> bool {\n+                alt ex.node {\n+                  ast::expr_unary(_, _) { true }\n+                  ast::expr_tup(_) { true }\n+                  _ { false }\n+                }\n+            }\n         }\n     }\n }\n \n // ret and fail, without arguments cannot appear is the discriminant of if,\n // alt, do, & while unambiguously without being parenthesized\n fn print_maybe_parens_discrim(s: &ps, e: &@ast::expr) {\n-    let disambig = alt e.node {\n-      ast::expr_ret(option::none.) { true }\n-      _ { false }\n-    };\n+    let disambig =\n+        alt e.node { ast::expr_ret(option::none.) { true } _ { false } };\n     if disambig { popen(s) }\n     print_expr(s, e);\n     if disambig { pclose(s) }\n@@ -727,6 +709,7 @@ fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n           some(_else) {\n             alt _else.node {\n \n+\n               // \"another else-if\"\n               ast::expr_if(i, t, e) {\n                 cbox(s, indent_unit - 1u);\n@@ -738,6 +721,7 @@ fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n                 do_else(s, e);\n               }\n \n+\n               // \"final else\"\n               ast::expr_block(b) {\n                 cbox(s, indent_unit - 1u);\n@@ -758,10 +742,7 @@ fn print_mac(s: &ps, m: &ast::mac) {\n       ast::mac_invoc(path, arg, body) {\n         word(s.s, \"#\");\n         print_path(s, path, false);\n-        alt (arg.node) {\n-          ast::expr_vec(_,_) {}\n-          _ { word(s.s, \" \"); }\n-        }\n+        alt arg.node { ast::expr_vec(_, _) { } _ { word(s.s, \" \"); } }\n         print_expr(s, arg);\n         // FIXME: extension 'body'\n       }\n@@ -930,6 +911,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         bclose_(s, expr.span, alt_indent_unit);\n       }\n       ast::expr_fn(f) {\n+\n         // If the return type is the magic ty_infer, then we need to\n         // pretty print as a lambda-block\n         if f.decl.output.node == ast::ty_infer {\n@@ -939,11 +921,11 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n             ibox(s, 0u);\n             word(s.s, \"{\");\n             print_fn_block_args(s, f.decl);\n-            print_possibly_embedded_block(s, f.body,\n-                                          block_block_fn, indent_unit);\n+            print_possibly_embedded_block(s, f.body, block_block_fn,\n+                                          indent_unit);\n         } else {\n             head(s, proto_to_str(f.proto));\n-            print_fn_args_and_ret(s, f.decl, ~[]);\n+            print_fn_args_and_ret(s, f.decl, []);\n             space(s.s);\n             print_block(s, f.body);\n         }\n@@ -955,10 +937,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         ibox(s, 0u);\n         print_block(s, blk);\n       }\n-      ast::expr_copy(e) {\n-        word_space(s, \"copy\");\n-        print_expr(s, e);\n-      }\n+      ast::expr_copy(e) { word_space(s, \"copy\"); print_expr(s, e); }\n       ast::expr_move(lhs, rhs) {\n         print_expr(s, lhs);\n         space(s.s);\n@@ -1070,30 +1049,23 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n \n         // Methods\n         for meth: @ast::method in anon_obj.methods {\n-            let typarams: [ast::ty_param] = ~[];\n+            let typarams: [ast::ty_param] = [];\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, meth.span.lo);\n             print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n-                     meth.node.ident, typarams, ~[]);\n+                     meth.node.ident, typarams, []);\n             word(s.s, \" \");\n             print_block(s, meth.node.meth.body);\n         }\n \n         // With object\n         alt anon_obj.inner_obj {\n           none. { }\n-          some(e) {\n-            space(s.s);\n-            word_space(s, \"with\");\n-            print_expr(s, e);\n-          }\n+          some(e) { space(s.s); word_space(s, \"with\"); print_expr(s, e); }\n         }\n         bclose(s, expr.span);\n       }\n-      ast::expr_uniq(expr) {\n-        word(s.s, \"~\");\n-        print_expr(s, expr);\n-      }\n+      ast::expr_uniq(expr) { word(s.s, \"~\"); print_expr(s, expr); }\n     }\n     s.ann.post(ann_node);\n     end(s);\n@@ -1224,7 +1196,7 @@ fn print_fn(s: &ps, decl: ast::fn_decl, proto: ast::proto, name: str,\n }\n \n fn print_fn_args_and_ret(s: &ps, decl: &ast::fn_decl,\n-                        constrs: [@ast::constr]) {\n+                         constrs: [@ast::constr]) {\n     popen(s);\n     fn print_arg(s: &ps, x: &ast::arg) {\n         ibox(s, indent_unit);\n@@ -1270,7 +1242,7 @@ fn print_kind(s: &ps, kind: ast::kind) {\n     alt kind {\n       ast::kind_unique. { word(s.s, \"~\"); }\n       ast::kind_shared. { word(s.s, \"@\"); }\n-      _ { /* fallthrough */ }\n+      _ {/* fallthrough */ }\n     }\n }\n \n@@ -1320,7 +1292,7 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n       }\n       ast::view_item_import(id, ids, _) {\n         head(s, \"import\");\n-        if !str::eq(id, ids.(vec::len(ids) - 1u)) {\n+        if !str::eq(id, ids[vec::len(ids) - 1u]) {\n             word_space(s, id);\n             word_space(s, \"=\");\n         }\n@@ -1332,13 +1304,10 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n       }\n       ast::view_item_import_from(mod_path, idents, _) {\n         head(s, \"import\");\n-        for elt: str in mod_path {\n-            word(s.s, elt);\n-            word(s.s, \"::\");\n-        }\n+        for elt: str in mod_path { word(s.s, elt); word(s.s, \"::\"); }\n         word(s.s, \"{\");\n         commasep(s, inconsistent, idents,\n-                 fn(s: &ps, w: &ast::import_ident) {\n+                 fn (s: &ps, w: &ast::import_ident) {\n                      word(s.s, w.node.name)\n                  });\n         word(s.s, \"}\");\n@@ -1354,8 +1323,7 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n       }\n       ast::view_item_export(ids, _) {\n         head(s, \"export\");\n-        commasep(s, inconsistent, ids,\n-                 fn(s: &ps, w: &str) { word(s.s, w) });\n+        commasep(s, inconsistent, ids, fn (s: &ps, w: &str) { word(s.s, w) });\n       }\n     }\n     word(s.s, \";\");\n@@ -1377,16 +1345,15 @@ fn operator_prec(op: ast::binop) -> int {\n \n fn need_parens(expr: &@ast::expr, outer_prec: int) -> bool {\n     alt expr.node {\n-      ast::expr_binary(op, _, _) {\n-        operator_prec(op) < outer_prec\n-      }\n+      ast::expr_binary(op, _, _) { operator_prec(op) < outer_prec }\n       ast::expr_cast(_, _) { parse::parser::as_prec < outer_prec }\n-      ast::expr_ternary(_, _, _) {\n-        parse::parser::ternary_prec < outer_prec\n-      }\n+      ast::expr_ternary(_, _, _) { parse::parser::ternary_prec < outer_prec }\n+\n \n       // This may be too conservative in some cases\n-      ast::expr_assign(_, _) { true }\n+      ast::expr_assign(_, _) {\n+        true\n+      }\n       ast::expr_move(_, _) { true }\n       ast::expr_swap(_, _) { true }\n       ast::expr_assign_op(_, _, _) { true }\n@@ -1485,7 +1452,7 @@ fn print_remaining_comments(s: &ps) {\n fn in_cbox(s: &ps) -> bool {\n     let len = vec::len(s.boxes);\n     if len == 0u { ret false; }\n-    ret s.boxes.(len - 1u) == pp::consistent;\n+    ret s.boxes[len - 1u] == pp::consistent;\n }\n \n fn print_literal(s: &ps, lit: &@ast::lit) {\n@@ -1502,8 +1469,9 @@ fn print_literal(s: &ps, lit: &@ast::lit) {\n         print_string(s, st);\n       }\n       ast::lit_char(ch) {\n-        word(s.s, \"'\" + escape_str(\n-            str::unsafe_from_bytes(~[ch as u8]), '\\'') + \"'\");\n+        word(s.s,\n+             \"'\" + escape_str(str::unsafe_from_bytes([ch as u8]), '\\'') +\n+                 \"'\");\n       }\n       ast::lit_int(val) { word(s.s, int::str(val)); }\n       ast::lit_uint(val) { word(s.s, uint::str(val) + \"u\"); }\n@@ -1530,7 +1498,7 @@ fn next_lit(s: &ps) -> option::t<lexer::lit> {\n     alt s.literals {\n       some(lits) {\n         if s.cur_lit < vec::len(lits) {\n-            ret some(lits.(s.cur_lit));\n+            ret some(lits[s.cur_lit]);\n         } else { ret none::<lexer::lit>; }\n       }\n       _ { ret none::<lexer::lit>; }\n@@ -1556,7 +1524,7 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n       lexer::mixed. {\n         assert (vec::len(cmnt.lines) == 1u);\n         zerobreak(s.s);\n-        word(s.s, cmnt.lines.(0));\n+        word(s.s, cmnt.lines[0]);\n         zerobreak(s.s);\n       }\n       lexer::isolated. {\n@@ -1571,7 +1539,7 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n       lexer::trailing. {\n         word(s.s, \" \");\n         if vec::len(cmnt.lines) == 1u {\n-            word(s.s, cmnt.lines.(0));\n+            word(s.s, cmnt.lines[0]);\n             hardbreak(s.s);\n         } else {\n             ibox(s, 0u);\n@@ -1584,10 +1552,11 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n       }\n       lexer::blank_line. {\n         // We need to do at least one, possibly two hardbreaks.\n-        let is_semi = alt s.s.last_token() {\n-          pp::STRING(s, _) { s == \";\" }\n-          _ { false }\n-        };\n+        let is_semi =\n+            alt s.s.last_token() {\n+              pp::STRING(s, _) { s == \";\" }\n+              _ { false }\n+            };\n         if is_semi || is_begin(s) || is_end(s) { hardbreak(s.s) }\n         hardbreak(s.s);\n       }\n@@ -1605,7 +1574,7 @@ fn escape_str(st: str, to_escape: char) -> str {\n     let len = str::byte_len(st);\n     let i = 0u;\n     while i < len {\n-        alt st.(i) as char {\n+        alt st[i] as char {\n           '\\n' { out += \"\\\\n\"; }\n           '\\t' { out += \"\\\\t\"; }\n           '\\r' { out += \"\\\\r\"; }\n@@ -1622,7 +1591,7 @@ fn escape_str(st: str, to_escape: char) -> str {\n     ret out;\n }\n \n-fn to_str<T>(t: &T, f: fn(&ps, &T) ) -> str {\n+fn to_str<T>(t: &T, f: fn(&ps, &T)) -> str {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     f(s, t);\n@@ -1634,7 +1603,7 @@ fn next_comment(s: &ps) -> option::t<lexer::cmnt> {\n     alt s.comments {\n       some(cmnts) {\n         if s.cur_cmnt < vec::len(cmnts) {\n-            ret some(cmnts.(s.cur_cmnt));\n+            ret some(cmnts[s.cur_cmnt]);\n         } else { ret none::<lexer::cmnt>; }\n       }\n       _ { ret none::<lexer::cmnt>; }\n@@ -1643,8 +1612,8 @@ fn next_comment(s: &ps) -> option::t<lexer::cmnt> {\n \n // Removing the aliases from the type of f in the next two functions\n // triggers memory corruption, but I haven't isolated the bug yet. FIXME\n-fn constr_args_to_str<T>(f: &fn(&T) -> str ,\n-                         args: &[@ast::sp_constr_arg<T>]) -> str {\n+fn constr_args_to_str<T>(f: &fn(&T) -> str, args: &[@ast::sp_constr_arg<T>])\n+   -> str {\n     let comma = false;\n     let s = \"(\";\n     for a: @ast::sp_constr_arg<T> in args {\n@@ -1655,8 +1624,8 @@ fn constr_args_to_str<T>(f: &fn(&T) -> str ,\n     ret s;\n }\n \n-fn constr_arg_to_str<T>(f: &fn(&T) -> str, c: &ast::constr_arg_general_<T>)\n-   -> str {\n+fn constr_arg_to_str<T>(f: &fn(&T) -> str, c: &ast::constr_arg_general_<T>) ->\n+   str {\n     alt c {\n       ast::carg_base. { ret \"*\"; }\n       ast::carg_ident(i) { ret f(i); }\n@@ -1686,7 +1655,7 @@ fn ast_ty_fn_constrs_str(constrs: &[@ast::constr]) -> str {\n }\n \n fn fn_arg_idx_to_str(decl: &ast::fn_decl, idx: &uint) -> str {\n-    decl.inputs.(idx).ident\n+    decl.inputs[idx].ident\n }\n \n fn ast_fn_constr_to_str(decl: &ast::fn_decl, c: &@ast::constr) -> str {\n@@ -1696,8 +1665,7 @@ fn ast_fn_constr_to_str(decl: &ast::fn_decl, c: &@ast::constr) -> str {\n }\n \n // FIXME: fix repeated code\n-fn ast_fn_constrs_str(decl: &ast::fn_decl,\n-                      constrs: &[@ast::constr]) -> str {\n+fn ast_fn_constrs_str(decl: &ast::fn_decl, constrs: &[@ast::constr]) -> str {\n     let s = \"\";\n     let colon = true;\n     for c: @ast::constr in constrs {\n@@ -1717,9 +1685,7 @@ fn proto_to_str(p: &ast::proto) -> str {\n }\n \n fn ty_constr_to_str(c: &@ast::ty_constr) -> str {\n-    fn ty_constr_path_to_str(p: &ast::path) -> str {\n-        \"*.\" + path_to_str(p)\n-    }\n+    fn ty_constr_path_to_str(p: &ast::path) -> str { \"*.\" + path_to_str(p) }\n \n     ret path_to_str(c.node.path) +\n             constr_args_to_str::<ast::path>(ty_constr_path_to_str,"}, {"sha": "31656886a453197d29a5cd132f1b268cce0d8bc0", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -18,7 +18,7 @@ type interner<T> =\n \n fn mk<@T>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n     let m = map::mk_hashmap::<T, uint>(hasher, eqer);\n-    ret {map: m, mutable vect: ~[], hasher: hasher, eqer: eqer};\n+    ret {map: m, mutable vect: [], hasher: hasher, eqer: eqer};\n }\n \n fn intern<@T>(itr: &interner<T>, val: &T) -> uint {\n@@ -27,13 +27,13 @@ fn intern<@T>(itr: &interner<T>, val: &T) -> uint {\n       none. {\n         let new_idx = vec::len::<T>(itr.vect);\n         itr.map.insert(val, new_idx);\n-        itr.vect += ~[val];\n+        itr.vect += [val];\n         ret new_idx;\n       }\n     }\n }\n \n-fn get<T>(itr: &interner<T>, idx: uint) -> T { ret itr.vect.(idx); }\n+fn get<T>(itr: &interner<T>, idx: uint) -> T { ret itr.vect[idx]; }\n \n-fn len<T>(itr : &interner<T>) -> uint { ret vec::len(itr.vect); }\n+fn len<T>(itr: &interner<T>) -> uint { ret vec::len(itr.vect); }\n "}, {"sha": "350dfc3dd445920dc9dfd930dad519fa9115a5ca", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 37, "deletions": 44, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -32,8 +32,7 @@ type visitor<E> =\n       visit_expr: fn(&@expr, &E, &vt<E>),\n       visit_ty: fn(&@ty, &E, &vt<E>),\n       visit_constr: fn(&path, &span, node_id, &E, &vt<E>),\n-      visit_fn:\n-          fn(&_fn, &[ty_param], &span, &fn_ident, node_id, &E, &vt<E>) };\n+      visit_fn: fn(&_fn, &[ty_param], &span, &fn_ident, node_id, &E, &vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n     ret @{visit_mod: bind visit_mod::<E>(_, _, _, _),\n@@ -104,8 +103,8 @@ fn visit_item<E>(i: &@item, e: &E, v: &vt<E>) {\n       item_obj(ob, _, _) {\n         for f: obj_field in ob.fields { v.visit_ty(f.ty, e, v); }\n         for m: @method in ob.methods {\n-            v.visit_fn(m.node.meth, ~[], m.span, some(m.node.ident),\n-                       m.node.id, e, v);\n+            v.visit_fn(m.node.meth, [], m.span, some(m.node.ident), m.node.id,\n+                       e, v);\n         }\n       }\n     }\n@@ -132,9 +131,7 @@ fn visit_ty<E>(t: &@ty, e: &E, v: &vt<E>) {\n       ty_rec(flds) {\n         for f: ty_field in flds { v.visit_ty(f.node.mt.ty, e, v); }\n       }\n-      ty_tup(ts) {\n-        for tt in ts { v.visit_ty(tt, e, v); }\n-      }\n+      ty_tup(ts) { for tt in ts { v.visit_ty(tt, e, v); } }\n       ty_fn(_, args, out, _, constrs) {\n         for a: ty_arg in args { v.visit_ty(a.node.ty, e, v); }\n         for c: @constr in constrs {\n@@ -174,9 +171,7 @@ fn visit_pat<E>(p: &@pat, e: &E, v: &vt<E>) {\n       pat_rec(fields, _) {\n         for f: field_pat in fields { v.visit_pat(f.pat, e, v); }\n       }\n-      pat_tup(elts) {\n-        for elt in elts { v.visit_pat(elt, e, v); }\n-      }\n+      pat_tup(elts) { for elt in elts { v.visit_pat(elt, e, v); } }\n       pat_box(inner) { v.visit_pat(inner, e, v); }\n       _ { }\n     }\n@@ -249,9 +244,7 @@ fn visit_expr<E>(ex: &@expr, e: &E, v: &vt<E>) {\n         for f: field in flds { v.visit_expr(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);\n       }\n-      expr_tup(elts) {\n-        for el in elts { v.visit_expr(el, e, v); }\n-      }\n+      expr_tup(elts) { for el in elts { v.visit_expr(el, e, v); } }\n       expr_call(callee, args) {\n         v.visit_expr(callee, e, v);\n         visit_exprs(args, e, v);\n@@ -291,7 +284,7 @@ fn visit_expr<E>(ex: &@expr, e: &E, v: &vt<E>) {\n         v.visit_expr(x, e, v);\n         for a: arm in arms { v.visit_arm(a, e, v); }\n       }\n-      expr_fn(f) { v.visit_fn(f, ~[], ex.span, none, ex.id, e, v); }\n+      expr_fn(f) { v.visit_fn(f, [], ex.span, none, ex.id, e, v); }\n       expr_block(b) { v.visit_block(b, e, v); }\n       expr_assign(a, b) { v.visit_expr(b, e, v); v.visit_expr(a, e, v); }\n       expr_copy(a) { v.visit_expr(a, e, v); }\n@@ -328,8 +321,8 @@ fn visit_expr<E>(ex: &@expr, e: &E, v: &vt<E>) {\n           some(ex) { v.visit_expr(ex, e, v); }\n         }\n         for m: @method in anon_obj.methods {\n-            v.visit_fn(m.node.meth, ~[], m.span, some(m.node.ident),\n-                       m.node.id, e, v);\n+            v.visit_fn(m.node.meth, [], m.span, some(m.node.ident), m.node.id,\n+                       e, v);\n         }\n       }\n       expr_mac(mac) { visit_mac(mac, e, v); }\n@@ -348,20 +341,20 @@ fn visit_arm<E>(a: &arm, e: &E, v: &vt<E>) {\n type simple_visitor =\n     // takes the components so that one function can be\n     // generic over constr and ty_constr\n-    @{visit_mod: fn(&_mod, &span) ,\n-      visit_view_item: fn(&@view_item) ,\n-      visit_native_item: fn(&@native_item) ,\n-      visit_item: fn(&@item) ,\n-      visit_local: fn(&@local) ,\n-      visit_block: fn(&ast::blk) ,\n-      visit_stmt: fn(&@stmt) ,\n-      visit_arm: fn(&arm) ,\n-      visit_pat: fn(&@pat) ,\n-      visit_decl: fn(&@decl) ,\n-      visit_expr: fn(&@expr) ,\n-      visit_ty: fn(&@ty) ,\n-      visit_constr: fn(&path, &span, node_id) ,\n-      visit_fn: fn(&_fn, &[ty_param], &span, &fn_ident, node_id) };\n+    @{visit_mod: fn(&_mod, &span),\n+      visit_view_item: fn(&@view_item),\n+      visit_native_item: fn(&@native_item),\n+      visit_item: fn(&@item),\n+      visit_local: fn(&@local),\n+      visit_block: fn(&ast::blk),\n+      visit_stmt: fn(&@stmt),\n+      visit_arm: fn(&arm),\n+      visit_pat: fn(&@pat),\n+      visit_decl: fn(&@decl),\n+      visit_expr: fn(&@expr),\n+      visit_ty: fn(&@ty),\n+      visit_constr: fn(&path, &span, node_id),\n+      visit_fn: fn(&_fn, &[ty_param], &span, &fn_ident, node_id)};\n \n fn default_simple_visitor() -> simple_visitor {\n     ret @{visit_mod: fn (_m: &_mod, _sp: &span) { },\n@@ -384,61 +377,61 @@ fn default_simple_visitor() -> simple_visitor {\n }\n \n fn mk_simple_visitor(v: &simple_visitor) -> vt<()> {\n-    fn v_mod(f: fn(&_mod, &span) , m: &_mod, sp: &span, e: &(), v: &vt<()>) {\n+    fn v_mod(f: fn(&_mod, &span), m: &_mod, sp: &span, e: &(), v: &vt<()>) {\n         f(m, sp);\n         visit_mod(m, sp, e, v);\n     }\n-    fn v_view_item(f: fn(&@view_item) , vi: &@view_item, e: &(), v: &vt<()>) {\n+    fn v_view_item(f: fn(&@view_item), vi: &@view_item, e: &(), v: &vt<()>) {\n         f(vi);\n         visit_view_item(vi, e, v);\n     }\n-    fn v_native_item(f: fn(&@native_item) , ni: &@native_item, e: &(),\n+    fn v_native_item(f: fn(&@native_item), ni: &@native_item, e: &(),\n                      v: &vt<()>) {\n         f(ni);\n         visit_native_item(ni, e, v);\n     }\n-    fn v_item(f: fn(&@item) , i: &@item, e: &(), v: &vt<()>) {\n+    fn v_item(f: fn(&@item), i: &@item, e: &(), v: &vt<()>) {\n         f(i);\n         visit_item(i, e, v);\n     }\n-    fn v_local(f: fn(&@local) , l: &@local, e: &(), v: &vt<()>) {\n+    fn v_local(f: fn(&@local), l: &@local, e: &(), v: &vt<()>) {\n         f(l);\n         visit_local(l, e, v);\n     }\n-    fn v_block(f: fn(&ast::blk) , bl: &ast::blk, e: &(), v: &vt<()>) {\n+    fn v_block(f: fn(&ast::blk), bl: &ast::blk, e: &(), v: &vt<()>) {\n         f(bl);\n         visit_block(bl, e, v);\n     }\n-    fn v_stmt(f: fn(&@stmt) , st: &@stmt, e: &(), v: &vt<()>) {\n+    fn v_stmt(f: fn(&@stmt), st: &@stmt, e: &(), v: &vt<()>) {\n         f(st);\n         visit_stmt(st, e, v);\n     }\n-    fn v_arm(f: fn(&arm) , a: &arm, e: &(), v: &vt<()>) {\n+    fn v_arm(f: fn(&arm), a: &arm, e: &(), v: &vt<()>) {\n         f(a);\n         visit_arm(a, e, v);\n     }\n-    fn v_pat(f: fn(&@pat) , p: &@pat, e: &(), v: &vt<()>) {\n+    fn v_pat(f: fn(&@pat), p: &@pat, e: &(), v: &vt<()>) {\n         f(p);\n         visit_pat(p, e, v);\n     }\n-    fn v_decl(f: fn(&@decl) , d: &@decl, e: &(), v: &vt<()>) {\n+    fn v_decl(f: fn(&@decl), d: &@decl, e: &(), v: &vt<()>) {\n         f(d);\n         visit_decl(d, e, v);\n     }\n-    fn v_expr(f: fn(&@expr) , ex: &@expr, e: &(), v: &vt<()>) {\n+    fn v_expr(f: fn(&@expr), ex: &@expr, e: &(), v: &vt<()>) {\n         f(ex);\n         visit_expr(ex, e, v);\n     }\n-    fn v_ty(f: fn(&@ty) , ty: &@ty, e: &(), v: &vt<()>) {\n+    fn v_ty(f: fn(&@ty), ty: &@ty, e: &(), v: &vt<()>) {\n         f(ty);\n         visit_ty(ty, e, v);\n     }\n-    fn v_constr(f: fn(&path, &span, node_id) , pt: &path, sp: &span,\n+    fn v_constr(f: fn(&path, &span, node_id), pt: &path, sp: &span,\n                 id: node_id, e: &(), v: &vt<()>) {\n         f(pt, sp, id);\n         visit_constr(pt, sp, id, e, v);\n     }\n-    fn v_fn(f: fn(&_fn, &[ty_param], &span, &fn_ident, node_id) , ff: &_fn,\n+    fn v_fn(f: fn(&_fn, &[ty_param], &span, &fn_ident, node_id), ff: &_fn,\n             tps: &[ty_param], sp: &span, ident: &fn_ident, id: node_id,\n             e: &(), v: &vt<()>) {\n         f(ff, tps, sp, ident, id);"}, {"sha": "ddd12d772293c926d33c46bc0b74ee11cc4806a9", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -50,8 +50,8 @@ fn new_def_hash<@V>() -> std::map::hashmap<ast::def_id, V> {\n fn field_expr(f: &ast::field) -> @ast::expr { ret f.node.expr; }\n \n fn field_exprs(fields: &[ast::field]) -> [@ast::expr] {\n-    let es = ~[];\n-    for f: ast::field in fields { es += ~[f.node.expr]; }\n+    let es = [];\n+    for f: ast::field in fields { es += [f.node.expr]; }\n     ret es;\n }\n \n@@ -160,8 +160,7 @@ fn is_main_name(path: &[str]) -> bool {\n // FIXME mode this to std::float when editing the stdlib no longer\n // requires a snapshot\n fn float_to_str(num: float, digits: uint) -> str {\n-    let accum = if num < 0.0 { num = -num; \"-\" }\n-                else { \"\" };\n+    let accum = if num < 0.0 { num = -num; \"-\" } else { \"\" };\n     let trunc = num as uint;\n     let frac = num - (trunc as float);\n     accum += uint::str(trunc);"}, {"sha": "5a71005acc2d3495a8d287bf9e65e9cbf2cd0e60", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 55, "deletions": 56, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -38,7 +38,7 @@ fn fn_ident_to_string(id: ast::node_id, i: &ast::fn_ident) -> str {\n }\n \n fn get_id_ident(cx: &ctxt, id: ast::def_id) -> str {\n-    if (id.crate != ast::local_crate) {\n+    if id.crate != ast::local_crate {\n         str::connect(cx.ext_map.get(id), \"::\")\n     } else {\n         alt cx.items.find(id.node) {\n@@ -60,8 +60,8 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n         let s = proto_to_str(proto);\n         alt ident { some(i) { s += \" \"; s += i; } _ { } }\n         s += \"(\";\n-        let strs = ~[];\n-        for a: arg in inputs { strs += ~[fn_input_to_str(cx, a)]; }\n+        let strs = [];\n+        for a: arg in inputs { strs += [fn_input_to_str(cx, a)]; }\n         s += str::connect(strs, \", \");\n         s += \")\";\n         if struct(cx, output) != ty_nil {\n@@ -91,60 +91,59 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n     }\n     alt cname(cx, typ) { some(cs) { ret cs; } _ { } }\n     ret alt struct(cx, typ) {\n-      ty_native(_) { \"native\" }\n-      ty_nil. { \"()\" }\n-      ty_bot. { \"_|_\" }\n-      ty_bool. { \"bool\" }\n-      ty_int. { \"int\" }\n-      ty_float. { \"float\" }\n-      ty_uint. { \"uint\" }\n-      ty_machine(tm) { ty_mach_to_str(tm) }\n-      ty_char. { \"char\" }\n-      ty_str. { \"str\" }\n-      ty_istr. { \"istr\" }\n-      ty_box(tm) { \"@\" + mt_to_str(cx, tm) }\n-      ty_uniq(t) { \"~\" + ty_to_str(cx, t) }\n-      ty_vec(tm) { \"[\" + mt_to_str(cx, tm) + \"]\" }\n-      ty_type. { \"type\" }\n-      ty_rec(elems) {\n-        let strs: [str] = ~[];\n-        for fld: field in elems { strs += ~[field_to_str(cx, fld)]; }\n-        \"{\" + str::connect(strs, \",\") + \"}\"\n-      }\n-      ty_tup(elems) {\n-        let strs = ~[];\n-        for elem in elems { strs += ~[ty_to_str(cx, elem)]; }\n-        \"(\" + str::connect(strs, \",\") + \")\"\n-      }\n-      ty_tag(id, tps) {\n-        let s = get_id_ident(cx, id);\n-        if vec::len::<t>(tps) > 0u {\n-            let strs: [str] = ~[];\n-            for typ: t in tps { strs += ~[ty_to_str(cx, typ)]; }\n-            s += \"[\" + str::connect(strs, \",\") + \"]\";\n+          ty_native(_) { \"native\" }\n+          ty_nil. { \"()\" }\n+          ty_bot. { \"_|_\" }\n+          ty_bool. { \"bool\" }\n+          ty_int. { \"int\" }\n+          ty_float. { \"float\" }\n+          ty_uint. { \"uint\" }\n+          ty_machine(tm) { ty_mach_to_str(tm) }\n+          ty_char. { \"char\" }\n+          ty_str. { \"str\" }\n+          ty_istr. { \"istr\" }\n+          ty_box(tm) { \"@\" + mt_to_str(cx, tm) }\n+          ty_uniq(t) { \"~\" + ty_to_str(cx, t) }\n+          ty_vec(tm) { \"[\" + mt_to_str(cx, tm) + \"]\" }\n+          ty_type. { \"type\" }\n+          ty_rec(elems) {\n+            let strs: [str] = [];\n+            for fld: field in elems { strs += [field_to_str(cx, fld)]; }\n+            \"{\" + str::connect(strs, \",\") + \"}\"\n+          }\n+          ty_tup(elems) {\n+            let strs = [];\n+            for elem in elems { strs += [ty_to_str(cx, elem)]; }\n+            \"(\" + str::connect(strs, \",\") + \")\"\n+          }\n+          ty_tag(id, tps) {\n+            let s = get_id_ident(cx, id);\n+            if vec::len::<t>(tps) > 0u {\n+                let strs: [str] = [];\n+                for typ: t in tps { strs += [ty_to_str(cx, typ)]; }\n+                s += \"[\" + str::connect(strs, \",\") + \"]\";\n+            }\n+            s\n+          }\n+          ty_fn(proto, inputs, output, cf, constrs) {\n+            fn_to_str(cx, proto, none, inputs, output, cf, constrs)\n+          }\n+          ty_native_fn(_, inputs, output) {\n+            fn_to_str(cx, ast::proto_fn, none, inputs, output, ast::return,\n+                      [])\n+          }\n+          ty_obj(meths) {\n+            let strs = [];\n+            for m: method in meths { strs += [method_to_str(cx, m)]; }\n+            \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\"\n+          }\n+          ty_res(id, _, _) { get_id_ident(cx, id) }\n+          ty_var(v) { \"<T\" + int::str(v) + \">\" }\n+          ty_param(id, _) {\n+            \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])\n+          }\n+          _ { ty_to_short_str(cx, typ) }\n         }\n-        s\n-      }\n-      ty_fn(proto, inputs, output, cf, constrs) {\n-        fn_to_str(cx, proto, none, inputs, output, cf, constrs)\n-      }\n-      ty_native_fn(_, inputs, output) {\n-        fn_to_str(cx, ast::proto_fn, none, inputs, output, ast::return, ~[])\n-      }\n-      ty_obj(meths) {\n-        let strs = ~[];\n-        for m: method in meths { strs += ~[method_to_str(cx, m)]; }\n-        \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\"\n-      }\n-      ty_res(id, _, _) {\n-        get_id_ident(cx, id)\n-      }\n-      ty_var(v) { \"<T\" + int::str(v) + \">\" }\n-      ty_param(id,_) {\n-        \"'\" + str::unsafe_from_bytes(~[('a' as u8) + (id as u8)])\n-      }\n-      _ { ty_to_short_str(cx, typ) }\n-    }\n }\n \n fn ty_to_short_str(cx: &ctxt, typ: t) -> str {"}, {"sha": "de8696baf3f69cf133186495869f461f5ff01334", "filename": "src/fuzzer/ast_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,13 +1,13 @@\n use std;\n import std::vec;\n \n-fn vec_equal<T>(v: &[T], u: &[T], element_equality_test: fn(&T, &T) -> bool )\n+fn vec_equal<T>(v: &[T], u: &[T], element_equality_test: fn(&T, &T) -> bool)\n    -> bool {\n     let Lv = vec::len(v);\n     if Lv != vec::len(u) { ret false; }\n     let i = 0u;\n     while i < Lv {\n-        if !element_equality_test(v.(i), u.(i)) { ret false; }\n+        if !element_equality_test(v[i], u[i]) { ret false; }\n         i += 1u;\n     }\n     ret true;\n@@ -18,10 +18,10 @@ fn builtin_equal<T>(a: &T, b: &T) -> bool { ret a == b; }\n fn main() {\n     assert (builtin_equal(5, 5));\n     assert (!builtin_equal(5, 4));\n-    assert (!vec_equal(~[5, 5], ~[5], builtin_equal));\n-    assert (!vec_equal(~[5, 5], ~[5, 4], builtin_equal));\n-    assert (!vec_equal(~[5, 5], ~[4, 5], builtin_equal));\n-    assert (vec_equal(~[5, 5], ~[5, 5], builtin_equal));\n+    assert (!vec_equal([5, 5], [5], builtin_equal));\n+    assert (!vec_equal([5, 5], [5, 4], builtin_equal));\n+    assert (!vec_equal([5, 5], [4, 5], builtin_equal));\n+    assert (vec_equal([5, 5], [5, 5], builtin_equal));\n \n     log_err \"Pass\";\n }"}, {"sha": "d9c3f979e398ba636ae82ff04a73588118ef9f1a", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 103, "deletions": 82, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -21,11 +21,9 @@ import rustc::syntax::parse::parser;\n import rustc::syntax::print::pprust;\n \n fn write_file(filename: &str, content: &str) {\n-    io::file_writer(filename,\n-                        ~[io::create,\n-                          io::truncate]).write_str(content);\n+    io::file_writer(filename, [io::create, io::truncate]).write_str(content);\n     // Work around https://github.com/graydon/rust/issues/726\n-    std::run::run_program(\"chmod\", ~[\"644\", filename]);\n+    std::run::run_program(\"chmod\", [\"644\", filename]);\n }\n \n fn file_contains(filename: &str, needle: &str) -> bool {\n@@ -41,16 +39,16 @@ fn find_rust_files(files: &mutable [str], path: str) {\n     if str::ends_with(path, \".rs\") {\n         if file_contains(path, \"xfail-stage1\") {\n             //log_err \"Skipping \" + path + \" because it is marked as xfail-stage1\";\n-        } else { files += ~[path]; }\n-    } else if (fs::file_is_dir(path) && str::find(path, \"compile-fail\") == -1)\n-     {\n+        } else { files += [path]; }\n+    } else if fs::file_is_dir(path) && str::find(path, \"compile-fail\") == -1 {\n         for p in fs::list_dir(path) { find_rust_files(files, p); }\n     }\n }\n \n fn safe_to_steal(e: ast::expr_) -> bool {\n     alt e {\n \n+\n       // pretty-printer precedence issues -- https://github.com/graydon/rust/issues/670\n       ast::expr_unary(_, _) {\n         false\n@@ -73,31 +71,41 @@ fn safe_to_steal(e: ast::expr_) -> bool {\n       ast::expr_binary(_, _, _) { false }\n       ast::expr_assign(_, _) { false }\n       ast::expr_assign_op(_, _, _) { false }\n-      ast::expr_fail(option::none.) { false /* https://github.com/graydon/rust/issues/764 */ }\n+      ast::expr_fail(option::none.) {\n+        false\n+        /* https://github.com/graydon/rust/issues/764 */\n+\n+      }\n       ast::expr_ret(option::none.) { false }\n       ast::expr_put(option::none.) { false }\n \n-      ast::expr_ret(_) { false /* lots of code generation issues, such as https://github.com/graydon/rust/issues/770 */ }\n+\n+      ast::expr_ret(_) {\n+        false\n+        /* lots of code generation issues, such as https://github.com/graydon/rust/issues/770 */\n+\n+      }\n       ast::expr_fail(_) { false }\n \n+\n       _ {\n         true\n       }\n     }\n }\n \n fn steal_exprs(crate: &ast::crate) -> [ast::expr] {\n-    let exprs: @mutable [ast::expr] = @mutable ~[];\n+    let exprs: @mutable [ast::expr] = @mutable [];\n     // \"Stash\" is not type-parameterized because of the need for safe_to_steal\n     fn stash_expr(es: @mutable [ast::expr], e: &@ast::expr) {\n         if safe_to_steal(e.node) {\n-            *es += ~[*e];\n+            *es += [*e];\n         } else {/* now my indices are wrong :( */ }\n     }\n-    let v = visit::mk_simple_visitor\n-        (@{visit_expr: bind stash_expr(exprs, _)\n-           with *visit::default_simple_visitor()});\n-    visit::visit_crate(crate, (), v);\n+    let v =\n+        visit::mk_simple_visitor(@{visit_expr: bind stash_expr(exprs, _)\n+                                      with *visit::default_simple_visitor()});\n+    visit::visit_crate(crate, (), v);;\n     *exprs\n }\n \n@@ -128,6 +136,7 @@ fn replace_expr_in_crate(crate: &ast::crate, i: uint, newexpr: ast::expr_) ->\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n     fold::dummy_out(af); // work around a leak (https://github.com/graydon/rust/issues/651)\n+    ;\n     *crate2\n }\n \n@@ -138,26 +147,28 @@ iter under(n: uint) -> uint {\n \n fn devnull() -> io::writer { std::io::string_writer().get_writer() }\n \n-fn as_str(f: fn(io::writer) ) -> str {\n+fn as_str(f: fn(io::writer)) -> str {\n     let w = std::io::string_writer();\n     f(w.get_writer());\n     ret w.get_str();\n }\n \n-fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap, filename: &str) {\n+fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n+                         filename: &str) {\n     let exprs = steal_exprs(crate);\n     let exprsL = vec::len(exprs);\n-    if (exprsL < 100u) {\n+    if exprsL < 100u {\n         for each i: uint in under(uint::min(exprsL, 20u)) {\n-            log_err \"Replacing... \" + pprust::expr_to_str(@exprs.(i));\n+            log_err \"Replacing... \" + pprust::expr_to_str(@exprs[i]);\n             for each j: uint in under(uint::min(exprsL, 5u)) {\n-                log_err \"With... \" + pprust::expr_to_str(@exprs.(j));\n-                let crate2 = @replace_expr_in_crate(crate, i, exprs.(j).node);\n+                log_err \"With... \" + pprust::expr_to_str(@exprs[j]);\n+                let crate2 = @replace_expr_in_crate(crate, i, exprs[j].node);\n                 // It would be best to test the *crate* for stability, but testing the\n                 // string for stability is easier and ok for now.\n-                let str3 = as_str(bind pprust::print_crate(codemap, crate2, filename,\n-                                  io::string_reader(\"\"), _,\n-                                  pprust::no_ann()));\n+                let str3 =\n+                    as_str(bind pprust::print_crate(codemap, crate2, filename,\n+                                                    io::string_reader(\"\"), _,\n+                                                    pprust::no_ann()));\n                 // 1u would be sane here, but the pretty-printer currently has lots of whitespace and paren issues,\n                 // and https://github.com/graydon/rust/issues/766 is hilarious.\n                 check_roundtrip_convergence(str3, 7u);\n@@ -174,37 +185,52 @@ fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap, filenam\n fn check_whole_compiler(code: &str) {\n     let filename = \"test.rs\";\n     write_file(filename, code);\n-    let p = std::run::program_output(\"/Users/jruderman/code/rust/build/stage1/rustc\", ~[\"-c\", filename]);\n+    let p =\n+        std::run::program_output(\"/Users/jruderman/code/rust/build/stage1/rustc\",\n+                                 [\"-c\", filename]);\n+\n     //log_err #fmt(\"Status: %d\", p.status);\n     //log_err \"Output: \" + p.out;\n     if p.err != \"\" {\n         if contains(p.err, \"argument of incompatible type\") {\n             log_err \"https://github.com/graydon/rust/issues/769\";\n-        } else if contains(p.err, \"Cannot create binary operator with two operands of differing type\") {\n+        } else if contains(p.err,\n+                           \"Cannot create binary operator with two operands of differing type\")\n+         {\n             log_err \"https://github.com/graydon/rust/issues/770\";\n         } else if contains(p.err, \"May only branch on boolean predicates!\") {\n             log_err \"https://github.com/graydon/rust/issues/770 or https://github.com/graydon/rust/issues/776\";\n-        } else if contains(p.err, \"Invalid constantexpr cast!\") && contains(code, \"!\") {\n+        } else if contains(p.err, \"Invalid constantexpr cast!\") &&\n+                      contains(code, \"!\") {\n             log_err \"https://github.com/graydon/rust/issues/777\";\n-        } else if contains(p.err, \"Both operands to ICmp instruction are not of the same type!\") && contains(code, \"!\") {\n+        } else if contains(p.err,\n+                           \"Both operands to ICmp instruction are not of the same type!\")\n+                      && contains(code, \"!\") {\n             log_err \"https://github.com/graydon/rust/issues/777 #issuecomment-1678487\";\n-        } else if contains(p.err, \"Ptr must be a pointer to Val type!\") && contains(code, \"!\") {\n+        } else if contains(p.err, \"Ptr must be a pointer to Val type!\") &&\n+                      contains(code, \"!\") {\n             log_err \"https://github.com/graydon/rust/issues/779\";\n-        } else if contains(p.err, \"Calling a function with bad signature!\") && (contains(code, \"iter\") || contains(code, \"range\")) {\n+        } else if contains(p.err, \"Calling a function with bad signature!\") &&\n+                      (contains(code, \"iter\") || contains(code, \"range\")) {\n             log_err \"https://github.com/graydon/rust/issues/771 - calling an iter fails\";\n-        } else if contains(p.err, \"Calling a function with a bad signature!\") && contains(code, \"empty\") {\n+        } else if contains(p.err, \"Calling a function with a bad signature!\")\n+                      && contains(code, \"empty\") {\n             log_err \"https://github.com/graydon/rust/issues/775 - possibly a modification of run-pass/import-glob-crate.rs\";\n-        } else if contains(p.err, \"Invalid type for pointer element!\") && contains(code, \"put\") {\n+        } else if contains(p.err, \"Invalid type for pointer element!\") &&\n+                      contains(code, \"put\") {\n             log_err \"https://github.com/graydon/rust/issues/773 - put put ()\";\n-        } else if contains(p.err, \"pointer being freed was not allocated\") && contains(p.out, \"Out of stack space, sorry\") {\n+        } else if contains(p.err, \"pointer being freed was not allocated\") &&\n+                      contains(p.out, \"Out of stack space, sorry\") {\n             log_err \"https://github.com/graydon/rust/issues/768 + https://github.com/graydon/rust/issues/778\"\n         } else {\n             log_err \"Stderr: \" + p.err;\n             fail \"Unfamiliar error message\";\n         }\n-    } else if contains(p.out, \"non-exhaustive match failure\") && contains(p.out, \"alias.rs\") {\n+    } else if contains(p.out, \"non-exhaustive match failure\") &&\n+                  contains(p.out, \"alias.rs\") {\n         log_err \"https://github.com/graydon/rust/issues/772\";\n-    } else if contains(p.out, \"non-exhaustive match failure\") && contains(p.out, \"trans.rs\") && contains(code, \"put\") {\n+    } else if contains(p.out, \"non-exhaustive match failure\") &&\n+                  contains(p.out, \"trans.rs\") && contains(code, \"put\") {\n         log_err \"https://github.com/graydon/rust/issues/774\";\n     } else if contains(p.out, \"Out of stack space, sorry\") {\n         log_err \"Possibly a variant of https://github.com/graydon/rust/issues/768\";\n@@ -214,74 +240,64 @@ fn check_whole_compiler(code: &str) {\n         }\n     } else if p.status == 11 {\n         log_err \"What is this I don't even\";\n-    } else if p.status != 0 {\n-        fail \"Unfamiliar status code\";\n-    }\n+    } else if p.status != 0 { fail \"Unfamiliar status code\"; }\n }\n \n fn parse_and_print(code: &str) -> str {\n     let filename = \"tmp.rs\";\n     let sess = @{cm: codemap::new_codemap(), mutable next_id: 0};\n     //write_file(filename, code);\n-    let crate =\n-        parser::parse_crate_from_source_str(filename, code, ~[], sess);\n+    let crate = parser::parse_crate_from_source_str(filename, code, [], sess);\n     ret as_str(bind pprust::print_crate(sess.cm, crate, filename,\n                                         io::string_reader(code), _,\n                                         pprust::no_ann()));\n }\n \n fn content_is_dangerous_to_modify(code: &str) -> bool {\n-    let dangerous_patterns = [\n-         \"obj\", // not safe to steal; https://github.com/graydon/rust/issues/761\n+    let dangerous_patterns =\n+        [\"obj\", // not safe to steal; https://github.com/graydon/rust/issues/761\n          \"#macro\", // not safe to steal things inside of it, because they have a special syntax\n          \"#\", // strange representation of the arguments to #fmt, for example\n          \" be \", // don't want to replace its child with a non-call: \"Non-call expression in tail call\"\n-         \"@\" // hangs when compiling: https://github.com/graydon/rust/issues/768\n-    ];\n+         \"@\"]; // hangs when compiling: https://github.com/graydon/rust/issues/768\n \n     for p: str in dangerous_patterns { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n-fn content_is_confusing(code: &str) -> bool {\n-    let  // https://github.com/graydon/rust/issues/671\n-         // https://github.com/graydon/rust/issues/669\n-         // https://github.com/graydon/rust/issues/669\n-         // https://github.com/graydon/rust/issues/669\n-         // crazy rules enforced by parser rather than typechecker?\n-         // more precedence issues\n-         // more precedence issues?\n-        confusing_patterns =\n+fn content_is_confusing(code: &str) ->\n+   bool { // https://github.com/graydon/rust/issues/671\n+          // https://github.com/graydon/rust/issues/669\n+          // https://github.com/graydon/rust/issues/669\n+          // https://github.com/graydon/rust/issues/669\n+          // crazy rules enforced by parser rather than typechecker?\n+          // more precedence issues\n+          // more precedence issues?\n+\n+    let confusing_patterns =\n         [\"#macro\", \"][]\", \"][mutable]\", \"][mutable ]\", \"self\", \"spawn\",\n-         \"bind\",\n-         \"\\n\\n\\n\\n\\n\", // https://github.com/graydon/rust/issues/759\n+         \"bind\", \"\\n\\n\\n\\n\\n\", // https://github.com/graydon/rust/issues/759\n          \" : \", // https://github.com/graydon/rust/issues/760\n-         \"if ret\",\n-         \"alt ret\",\n-         \"if fail\",\n-         \"alt fail\"\n-         ];\n+         \"if ret\", \"alt ret\", \"if fail\", \"alt fail\"];\n \n     for p: str in confusing_patterns { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n fn file_is_confusing(filename: &str) -> bool {\n-    let\n \n-         // https://github.com/graydon/rust/issues/674\n+    // https://github.com/graydon/rust/issues/674\n \n-         // something to do with () as a lone pattern\n+    // something to do with () as a lone pattern\n \n-         // an issue where -2147483648 gains an\n-         // extra negative sign each time through,\n-         // which i can't reproduce using \"rustc\n-         // --pretty normal\"???\n-         confusing_files =\n+    // an issue where -2147483648 gains an\n+    // extra negative sign each time through,\n+    // which i can't reproduce using \"rustc\n+    // --pretty normal\"???\n+    let confusing_files =\n         [\"block-expr-precedence.rs\", \"nil-pattern.rs\",\n          \"syntax-extension-fmt.rs\",\n-         \"newtype.rs\" // modifying it hits something like https://github.com/graydon/rust/issues/670\n-         ];\n+         \"newtype.rs\"]; // modifying it hits something like https://github.com/graydon/rust/issues/670\n \n     for f in confusing_files { if contains(filename, f) { ret true; } }\n \n@@ -303,23 +319,25 @@ fn check_roundtrip_convergence(code: &str, maxIters: uint) {\n     }\n \n     if old == new {\n-        log_err #fmt(\"Converged after %u iterations\", i);\n+        log_err #fmt[\"Converged after %u iterations\", i];\n     } else {\n-        log_err #fmt(\"Did not converge after %u iterations!\", i);\n+        log_err #fmt[\"Did not converge after %u iterations!\", i];\n         write_file(\"round-trip-a.rs\", old);\n         write_file(\"round-trip-b.rs\", new);\n-        std::run::run_program(\"diff\", ~[\"-w\", \"-u\", \"round-trip-a.rs\", \"round-trip-b.rs\"]);\n+        std::run::run_program(\"diff\",\n+                              [\"-w\", \"-u\", \"round-trip-a.rs\",\n+                               \"round-trip-b.rs\"]);\n         fail \"Mismatch\";\n     }\n }\n \n fn check_convergence(files: &[str]) {\n-    log_err #fmt(\"pp convergence tests: %u files\", vec::len(files));\n+    log_err #fmt[\"pp convergence tests: %u files\", vec::len(files)];\n     for file in files {\n         if !file_is_confusing(file) {\n             let s = io::read_whole_file_str(file);\n             if !content_is_confusing(s) {\n-                log_err #fmt(\"pp converge: %s\", file);\n+                log_err #fmt[\"pp converge: %s\", file];\n                 // Change from 7u to 2u when https://github.com/graydon/rust/issues/759 is fixed\n                 check_roundtrip_convergence(s, 7u);\n             }\n@@ -331,25 +349,28 @@ fn check_variants(files: &[str]) {\n     for file in files {\n         if !file_is_confusing(file) {\n             let s = io::read_whole_file_str(file);\n-            if content_is_dangerous_to_modify(s) || content_is_confusing(s) { cont; }\n+            if content_is_dangerous_to_modify(s) || content_is_confusing(s) {\n+                cont;\n+            }\n             log_err \"check_variants: \" + file;\n             let sess = @{cm: codemap::new_codemap(), mutable next_id: 0};\n-            let crate = parser::parse_crate_from_source_str(file, s, ~[], sess);\n+            let crate =\n+                parser::parse_crate_from_source_str(file, s, [], sess);\n             log_err as_str(bind pprust::print_crate(sess.cm, crate, file,\n-                                        io::string_reader(s), _,\n-                                        pprust::no_ann()));\n+                                                    io::string_reader(s), _,\n+                                                    pprust::no_ann()));\n             check_variants_of_ast(*crate, sess.cm, file);\n         }\n     }\n }\n \n fn main(args: [str]) {\n     if vec::len(args) != 2u {\n-        log_err #fmt(\"usage: %s <testdir>\", args.(0));\n+        log_err #fmt[\"usage: %s <testdir>\", args[0]];\n         ret;\n     }\n-    let files = ~[];\n-    let root = args.(1);\n+    let files = [];\n+    let root = args[1];\n \n     find_rust_files(files, root);\n     check_convergence(files);"}, {"sha": "3dd24875c52c41f0bdb6273976d0c09f72cc4466", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -32,19 +32,19 @@ fn vec_omit<T>(v: &[T], i: uint) -> [T] {\n     slice(v, 0u, i) + slice(v, i + 1u, len(v))\n }\n fn vec_dup<T>(v: &[T], i: uint) -> [T] {\n-    slice(v, 0u, i) + ~[v.(i)] + slice(v, i, len(v))\n+    slice(v, 0u, i) + [v[i]] + slice(v, i, len(v))\n }\n fn vec_swadj<T>(v: &[T], i: uint) -> [T] {\n-    slice(v, 0u, i) + ~[v.(i + 1u), v.(i)] + slice(v, i + 2u, len(v))\n+    slice(v, 0u, i) + [v[i + 1u], v[i]] + slice(v, i + 2u, len(v))\n }\n fn vec_prefix<T>(v: &[T], i: uint) -> [T] { slice(v, 0u, i) }\n fn vec_suffix<T>(v: &[T], i: uint) -> [T] { slice(v, i, len(v)) }\n \n fn vec_poke<T>(v: &[T], i: uint, x: &T) -> [T] {\n-    slice(v, 0u, i) + ~[x] + slice(v, i + 1u, len(v))\n+    slice(v, 0u, i) + [x] + slice(v, i + 1u, len(v))\n }\n fn vec_insert<T>(v: &[T], i: uint, x: &T) -> [T] {\n-    slice(v, 0u, i) + ~[x] + slice(v, i, len(v))\n+    slice(v, 0u, i) + [x] + slice(v, i, len(v))\n }\n \n // Iterates over 0...length, skipping the specified number on each side.\n@@ -55,28 +55,28 @@ iter ix(skip_low: uint, skip_high: uint, length: uint) -> uint {\n \n // Returns a bunch of modified versions of v, some of which introduce new elements (borrowed from xs).\n fn vec_edits<T>(v: &[T], xs: &[T]) -> [[T]] {\n-    let edits: [[T]] = ~[];\n+    let edits: [[T]] = [];\n     let Lv: uint = len(v);\n \n     if Lv != 1u {\n         edits +=\n-            ~[~[]]; // When Lv == 1u, this is redundant with omit\n-                    //if (Lv >= 3u) { edits += ~[vec_reverse(v)]; }\n+            [[]]; // When Lv == 1u, this is redundant with omit\n+                  //if (Lv >= 3u) { edits += ~[vec_reverse(v)]; }\n \n-    }\n \n-    for each i: uint in ix(0u, 1u, Lv) { edits += ~[vec_omit(v, i)]; }\n-    for each i: uint in ix(0u, 1u, Lv) { edits += ~[vec_dup(v, i)]; }\n-    for each i: uint in ix(0u, 2u, Lv) { edits += ~[vec_swadj(v, i)]; }\n-    for each i: uint in ix(1u, 2u, Lv) { edits += ~[vec_prefix(v, i)]; }\n-    for each i: uint in ix(2u, 1u, Lv) { edits += ~[vec_suffix(v, i)]; }\n+    }\n+    for each i: uint in ix(0u, 1u, Lv) { edits += [vec_omit(v, i)]; }\n+    for each i: uint in ix(0u, 1u, Lv) { edits += [vec_dup(v, i)]; }\n+    for each i: uint in ix(0u, 2u, Lv) { edits += [vec_swadj(v, i)]; }\n+    for each i: uint in ix(1u, 2u, Lv) { edits += [vec_prefix(v, i)]; }\n+    for each i: uint in ix(2u, 1u, Lv) { edits += [vec_suffix(v, i)]; }\n \n     for each j: uint in ix(0u, 1u, len(xs)) {\n         for each i: uint in ix(0u, 1u, Lv) {\n-            edits += ~[vec_poke(v, i, xs.(j))];\n+            edits += [vec_poke(v, i, xs[j])];\n         }\n         for each i: uint in ix(0u, 0u, Lv) {\n-            edits += ~[vec_insert(v, i, xs.(j))];\n+            edits += [vec_insert(v, i, xs[j])];\n         }\n     }\n \n@@ -89,7 +89,7 @@ fn vec_to_str(v: &[int]) -> str {\n     let i = 0u;\n     let s = \"[\";\n     while i < len(v) {\n-        s += int::str(v.(i));\n+        s += int::str(v[i]);\n         if i + 1u < len(v) { s += \", \" }\n         i += 1u;\n     }\n@@ -99,16 +99,16 @@ fn vec_to_str(v: &[int]) -> str {\n fn show_edits(a: &[int], xs: &[int]) {\n     log_err \"=== Edits of \" + vec_to_str(a) + \" ===\";\n     let b = vec_edits(a, xs);\n-    for each i: uint in ix(0u, 1u, len(b)) { log_err vec_to_str(b.(i)); }\n+    for each i: uint in ix(0u, 1u, len(b)) { log_err vec_to_str(b[i]); }\n }\n \n fn demo_edits() {\n-    let xs = ~[7, 8];\n-    show_edits(~[], xs);\n-    show_edits(~[1], xs);\n-    show_edits(~[1, 2], xs);\n-    show_edits(~[1, 2, 3], xs);\n-    show_edits(~[1, 2, 3, 4], xs);\n+    let xs = [7, 8];\n+    show_edits([], xs);\n+    show_edits([1], xs);\n+    show_edits([1, 2], xs);\n+    show_edits([1, 2, 3], xs);\n+    show_edits([1, 2, 3, 4], xs);\n }\n \n fn main() { demo_edits(); }"}, {"sha": "c2e9c13dc89bc1585c187952a7db67a7c55a83d9", "filename": "src/lib/aio.rs", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -28,26 +28,17 @@ native \"rust\" mod rustrt {\n // currently in the sendable kind, so we'll unsafely cast between ints.\n type server = rustrt::server;\n type client = rustrt::socket;\n-tag pending_connection {\n-    remote(net::ip_addr,int);\n-    incoming(server);\n-}\n+tag pending_connection { remote(net::ip_addr, int); incoming(server); }\n \n-tag socket_event {\n-    connected(client);\n-    closed;\n-    received([u8]);\n-}\n+tag socket_event { connected(client); closed; received([u8]); }\n \n-tag server_event {\n-    pending(_chan<_chan<socket_event>>);\n-}\n+tag server_event { pending(_chan<_chan<socket_event>>); }\n \n tag request {\n     quit;\n-    connect(pending_connection,_chan<socket_event>);\n-    serve(net::ip_addr,int,_chan<server_event>,_chan<server>);\n-    write(client,[u8],_chan<bool>);\n+    connect(pending_connection, _chan<socket_event>);\n+    serve(net::ip_addr, int, _chan<server_event>, _chan<server>);\n+    write(client, [u8], _chan<bool>);\n     close_server(server, _chan<bool>);\n     close_client(client);\n }\n@@ -74,12 +65,12 @@ fn new_client(client: client, evt: _chan<socket_event>) {\n \n     send(evt, connected(client));\n \n-    while (true) {\n+    while true {\n         log \"waiting for bytes\";\n         let data: [u8] = reader.recv();\n         log \"got some bytes\";\n         log vec::len::<u8>(data);\n-        if (vec::len::<u8>(data) == 0u) {\n+        if vec::len::<u8>(data) == 0u {\n             log \"got empty buffer, bailing\";\n             break;\n         }\n@@ -104,19 +95,17 @@ fn accept_task(client: client, events: _chan<server_event>) {\n fn server_task(ip: net::ip_addr, portnum: int, events: _chan<server_event>,\n                server: _chan<server>) {\n     let accepter: _port<client> = mk_port();\n-    send(server, rustrt::aio_serve(ip_to_sbuf(ip), portnum,\n-                                   accepter.mk_chan()));\n+    send(server,\n+         rustrt::aio_serve(ip_to_sbuf(ip), portnum, accepter.mk_chan()));\n \n     let client: client;\n-    while (true) {\n+    while true {\n         log \"preparing to accept a client\";\n         client = accepter.recv();\n-        if (rustrt::aio_is_null_client(client)) {\n-          log \"client was actually null, returning\";\n-          ret;\n-        } else {\n-          task::_spawn(bind accept_task(client, events));\n-        }\n+        if rustrt::aio_is_null_client(client) {\n+            log \"client was actually null, returning\";\n+            ret;\n+        } else { task::_spawn(bind accept_task(client, events)); }\n     }\n }\n \n@@ -128,7 +117,7 @@ fn request_task(c: _chan<ctx>) {\n     log \"uv run task spawned\";\n     // Spin for requests\n     let req: request;\n-    while (true) {\n+    while true {\n         req = p.recv();\n         alt req {\n           quit. {\n@@ -137,20 +126,19 @@ fn request_task(c: _chan<ctx>) {\n             rustrt::aio_stop();\n             ret;\n           }\n-          connect(remote(ip,portnum),client) {\n+          connect(remote(ip, portnum), client) {\n             task::_spawn(bind connect_task(ip, portnum, client));\n           }\n-          serve(ip,portnum,events,server) {\n+          serve(ip, portnum, events, server) {\n             task::_spawn(bind server_task(ip, portnum, events, server));\n           }\n-          write(socket,v,status) {\n-            rustrt::aio_writedata(socket,\n-                                  vec::to_ptr::<u8>(v), vec::len::<u8>(v),\n-                                  status);\n+          write(socket, v, status) {\n+            rustrt::aio_writedata(socket, vec::to_ptr::<u8>(v),\n+                                  vec::len::<u8>(v), status);\n           }\n-          close_server(server,status) {\n+          close_server(server, status) {\n             log \"closing server\";\n-            rustrt::aio_close_server(server,status);\n+            rustrt::aio_close_server(server, status);\n           }\n           close_client(client) {\n             log \"closing client\";"}, {"sha": "019aa32f36a996cf928b0fd3da9eb3a22b84526e", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -35,16 +35,16 @@ fn create(nbits: uint, init: bool) -> t {\n     ret @{storage: storage, nbits: nbits};\n }\n \n-fn process(op: &block(uint, uint) -> uint , v0: &t, v1: &t) -> bool {\n+fn process(op: &block(uint, uint) -> uint, v0: &t, v1: &t) -> bool {\n     let len = vec::len(v1.storage);\n     assert (vec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n     let changed = false;\n     for each i: uint in uint::range(0u, len) {\n-        let w0 = v0.storage.(i);\n-        let w1 = v1.storage.(i);\n+        let w0 = v0.storage[i];\n+        let w1 = v1.storage[i];\n         let w = op(w0, w1);\n-        if w0 != w { changed = true; v0.storage.(i) = w; }\n+        if w0 != w { changed = true; v0.storage[i] = w; }\n     }\n     ret changed;\n }\n@@ -70,7 +70,7 @@ fn assign(v0: &t, v1: t) -> bool {\n fn clone(v: t) -> t {\n     let storage = vec::init_elt_mut::<uint>(0u, v.nbits / uint_bits() + 1u);\n     let len = vec::len(v.storage);\n-    for each i: uint in uint::range(0u, len) { storage.(i) = v.storage.(i); }\n+    for each i: uint in uint::range(0u, len) { storage[i] = v.storage[i]; }\n     ret @{storage: storage, nbits: v.nbits};\n }\n \n@@ -79,7 +79,7 @@ fn get(v: &t, i: uint) -> bool {\n     let bits = uint_bits();\n     let w = i / bits;\n     let b = i % bits;\n-    let x = 1u & v.storage.(w) >> b;\n+    let x = 1u & v.storage[w] >> b;\n     ret x == 1u;\n }\n \n@@ -90,15 +90,15 @@ fn equal(v0: &t, v1: &t) -> bool {\n     let len = vec::len(v1.storage);\n     let i = 0u;\n     while i < len {\n-        if v0.storage.(i) != v1.storage.(i) { ret false; }\n+        if v0.storage[i] != v1.storage[i] { ret false; }\n         i = i + 1u;\n     }\n     ret true;\n }\n \n fn clear(v: &t) {\n     for each i: uint in uint::range(0u, vec::len(v.storage)) {\n-        v.storage.(i) = 0u;\n+        v.storage[i] = 0u;\n     }\n }\n \n@@ -108,7 +108,7 @@ fn set_all(v: &t) {\n \n fn invert(v: &t) {\n     for each i: uint in uint::range(0u, vec::len(v.storage)) {\n-        v.storage.(i) = !v.storage.(i);\n+        v.storage[i] = !v.storage[i];\n     }\n }\n \n@@ -127,8 +127,7 @@ fn set(v: &t, i: uint, x: bool) {\n     let w = i / bits;\n     let b = i % bits;\n     let flag = 1u << b;\n-    v.storage.(w) =\n-        if x { v.storage.(w) | flag } else { v.storage.(w) & !flag };\n+    v.storage[w] = if x { v.storage[w] | flag } else { v.storage[w] & !flag };\n }\n \n \n@@ -154,9 +153,7 @@ fn to_vec(v: &t) -> [uint] {\n \n fn to_str(v: &t) -> str {\n     let rs = \"\";\n-    for i: uint in to_vec(v) {\n-        if i == 1u { rs += \"1\"; } else { rs += \"0\"; }\n-    }\n+    for i: uint in to_vec(v) { if i == 1u { rs += \"1\"; } else { rs += \"0\"; } }\n     ret rs;\n }\n \n@@ -166,7 +163,7 @@ fn eq_vec(v0: &t, v1: &[uint]) -> bool {\n     let i = 0u;\n     while i < len {\n         let w0 = get(v0, i);\n-        let w1 = v1.(i);\n+        let w1 = v1[i];\n         if !w0 && w1 != 0u || w0 && w1 == 0u { ret false; }\n         i = i + 1u;\n     }"}, {"sha": "634c9b9647cf4456e171358eb76ac26707961dd5", "filename": "src/lib/char.rs", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fchar.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -26,31 +26,55 @@ pred is_whitespace(c: char) -> bool {\n     const ch_next_line: char = '\\u0085';\n     const ch_no_break_space: char = '\\u00a0';\n \n-    if c == ch_space { true }\n-    else if c == ch_ogham_space_mark { true }\n-    else if c == ch_mongolian_vowel_sep { true }\n-    else if c == ch_en_quad { true }\n-    else if c == ch_em_quad { true }\n-    else if c == ch_en_space { true }\n-    else if c == ch_em_space { true }\n-    else if c == ch_three_per_em_space { true }\n-    else if c == ch_four_per_em_space { true }\n-    else if c == ch_six_per_em_space { true }\n-    else if c == ch_figure_space { true }\n-    else if c == ch_punctuation_space { true }\n-    else if c == ch_thin_space { true }\n-    else if c == ch_hair_space { true }\n-    else if c == ch_narrow_no_break_space { true }\n-    else if c == ch_medium_mathematical_space { true }\n-    else if c == ch_ideographic_space { true }\n-    else if c == ch_line_tabulation { true }\n-    else if c == ch_paragraph_separator { true }\n-    else if c == ch_character_tabulation { true }\n-    else if c == ch_line_feed { true }\n-    else if c == ch_line_tabulation { true }\n-    else if c == ch_form_feed { true }\n-    else if c == ch_carriage_return { true }\n-    else if c == ch_next_line { true }\n-    else if c == ch_no_break_space { true }\n-    else { false }\n-}\n\\ No newline at end of file\n+    if c == ch_space {\n+        true\n+    } else if c == ch_ogham_space_mark {\n+        true\n+    } else if c == ch_mongolian_vowel_sep {\n+        true\n+    } else if c == ch_en_quad {\n+        true\n+    } else if c == ch_em_quad {\n+        true\n+    } else if c == ch_en_space {\n+        true\n+    } else if c == ch_em_space {\n+        true\n+    } else if c == ch_three_per_em_space {\n+        true\n+    } else if c == ch_four_per_em_space {\n+        true\n+    } else if c == ch_six_per_em_space {\n+        true\n+    } else if c == ch_figure_space {\n+        true\n+    } else if c == ch_punctuation_space {\n+        true\n+    } else if c == ch_thin_space {\n+        true\n+    } else if c == ch_hair_space {\n+        true\n+    } else if c == ch_narrow_no_break_space {\n+        true\n+    } else if c == ch_medium_mathematical_space {\n+        true\n+    } else if c == ch_ideographic_space {\n+        true\n+    } else if c == ch_line_tabulation {\n+        true\n+    } else if c == ch_paragraph_separator {\n+        true\n+    } else if c == ch_character_tabulation {\n+        true\n+    } else if c == ch_line_feed {\n+        true\n+    } else if c == ch_line_tabulation {\n+        true\n+    } else if c == ch_form_feed {\n+        true\n+    } else if c == ch_carriage_return {\n+        true\n+    } else if c == ch_next_line {\n+        true\n+    } else if c == ch_no_break_space { true } else { false }\n+}"}, {"sha": "ebe9c75bc398c385088c232b7c2e51d54d1234b4", "filename": "src/lib/comm.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -17,22 +17,21 @@ native \"rust\" mod rustrt {\n     type void;\n     type rust_port;\n \n-    fn chan_id_send<~T>(target_task : task_id, target_port : port_id,\n-                        data : -T);\n+    fn chan_id_send<~T>(target_task: task_id, target_port: port_id, data: -T);\n \n-    fn new_port(unit_sz : uint) -> *rust_port;\n-    fn del_port(po : *rust_port);\n-    fn drop_port(po : *rust_port);\n-    fn get_port_id(po : *rust_port) -> port_id;\n+    fn new_port(unit_sz: uint) -> *rust_port;\n+    fn del_port(po: *rust_port);\n+    fn drop_port(po: *rust_port);\n+    fn get_port_id(po: *rust_port) -> port_id;\n }\n \n native \"rust-intrinsic\" mod rusti {\n-    fn recv<~T>(port : *rustrt::rust_port) -> T;\n+    fn recv<~T>(port: *rustrt::rust_port) -> T;\n }\n \n type port_id = int;\n \n-type chan_handle<~T> = { task : task_id, port : port_id};\n+type chan_handle<~T> = {task: task_id, port: port_id};\n \n tag chan<~T> { chan_t(chan_handle<T>); }\n type _chan<~T> = chan<T>;\n@@ -44,36 +43,25 @@ resource port_ptr(po: *rustrt::rust_port) {\n \n tag port<~T> { port_t(@port_ptr); }\n \n-obj port_obj<~T>(raw_port : port<T>) {\n-    fn mk_chan() -> chan<T> {\n-        chan(raw_port)\n-    }\n+obj port_obj<~T>(raw_port: port<T>) {\n+    fn mk_chan() -> chan<T> { chan(raw_port) }\n \n-    fn recv() -> T {\n-        recv(raw_port)\n-    }\n+    fn recv() -> T { recv(raw_port) }\n }\n type _port<~T> = port_obj<T>;\n \n-fn mk_port<~T>() -> _port<T> {\n-    ret port_obj::<T>(port::<T>());\n-}\n+fn mk_port<~T>() -> _port<T> { ret port_obj::<T>(port::<T>()); }\n \n-fn send<~T>(ch : &chan<T>, data : -T) {\n+fn send<~T>(ch: &chan<T>, data: -T) {\n     rustrt::chan_id_send(ch.task, ch.port, data);\n }\n \n fn port<~T>() -> port<T> {\n     port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n }\n \n-fn recv<~T>(p : &port<T>) -> T {\n-    ret rusti::recv(***p)\n-}\n+fn recv<~T>(p: &port<T>) -> T { ret rusti::recv(***p) }\n \n-fn chan<~T>(p : &port<T>) -> chan<T> {\n-    chan_t({\n-        task: task::get_task_id(),\n-        port: rustrt::get_port_id(***p)\n-    })\n+fn chan<~T>(p: &port<T>) -> chan<T> {\n+    chan_t({task: task::get_task_id(), port: rustrt::get_port_id(***p)})\n }"}, {"sha": "5b2d8db418ba05ca3b08a00b48a91d6b116eeb0f", "filename": "src/lib/deque.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -6,14 +6,14 @@\n  */\n type t<T> =\n     obj {\n-        fn size() -> uint ;\n-        fn add_front(&T) ;\n-        fn add_back(&T) ;\n-        fn pop_front() -> T ;\n-        fn pop_back() -> T ;\n-        fn peek_front() -> T ;\n-        fn peek_back() -> T ;\n-        fn get(int) -> T ;\n+        fn size() -> uint;\n+        fn add_front(&T);\n+        fn add_back(&T);\n+        fn pop_front() -> T;\n+        fn pop_back() -> T;\n+        fn peek_front() -> T;\n+        fn peek_back() -> T;\n+        fn get(int) -> T;\n     };\n \n fn create<@T>() -> t<T> {\n@@ -26,24 +26,25 @@ fn create<@T>() -> t<T> {\n       */\n \n \n+\n     fn grow<@T>(nelts: uint, lo: uint, elts: &[mutable cell<T>]) ->\n        [mutable cell<T>] {\n         assert (nelts == vec::len(elts));\n-        let rv = ~[mutable];\n+        let rv = [mutable];\n \n         let i = 0u;\n         let nalloc = uint::next_power_of_two(nelts + 1u);\n         while i < nalloc {\n             if i < nelts {\n-                rv += ~[mutable elts.((lo + i) % nelts)];\n-            } else { rv += ~[mutable option::none]; }\n+                rv += [mutable elts[(lo + i) % nelts]];\n+            } else { rv += [mutable option::none]; }\n             i += 1u;\n         }\n \n         ret rv;\n     }\n     fn get<@T>(elts: &[mutable cell<T>], i: uint) -> T {\n-        ret alt elts.(i) { option::some(t) { t } _ { fail } };\n+        ret alt elts[i] { option::some(t) { t } _ { fail } };\n     }\n     obj deque<@T>(mutable nelts: uint,\n                   mutable lo: uint,\n@@ -60,7 +61,7 @@ fn create<@T>() -> t<T> {\n                 lo = vec::len::<cell<T>>(elts) - 1u;\n                 hi = nelts;\n             }\n-            elts.(lo) = option::some::<T>(t);\n+            elts[lo] = option::some::<T>(t);\n             nelts += 1u;\n         }\n         fn add_back(t: &T) {\n@@ -69,7 +70,7 @@ fn create<@T>() -> t<T> {\n                 lo = 0u;\n                 hi = nelts;\n             }\n-            elts.(hi) = option::some::<T>(t);\n+            elts[hi] = option::some::<T>(t);\n             hi = (hi + 1u) % vec::len::<cell<T>>(elts);\n             nelts += 1u;\n         }\n@@ -80,7 +81,7 @@ fn create<@T>() -> t<T> {\n          */\n         fn pop_front() -> T {\n             let t: T = get::<T>(elts, lo);\n-            elts.(lo) = option::none::<T>;\n+            elts[lo] = option::none::<T>;\n             lo = (lo + 1u) % vec::len::<cell<T>>(elts);\n             nelts -= 1u;\n             ret t;\n@@ -90,7 +91,7 @@ fn create<@T>() -> t<T> {\n                 hi = vec::len::<cell<T>>(elts) - 1u;\n             } else { hi -= 1u; }\n             let t: T = get::<T>(elts, hi);\n-            elts.(hi) = option::none::<T>;\n+            elts[hi] = option::none::<T>;\n             nelts -= 1u;\n             ret t;\n         }"}, {"sha": "09d0bee1a601414b86c14a049ad4c58d39d981be", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -18,23 +18,23 @@ type ebml_state = {ebml_tag: ebml_tag, tag_pos: uint, data_pos: uint};\n type doc = {data: @[u8], start: uint, end: uint};\n \n fn vint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n-    let a = data.(start);\n+    let a = data[start];\n     if a & 0x80u8 != 0u8 { ret {val: a & 0x7fu8 as uint, next: start + 1u}; }\n     if a & 0x40u8 != 0u8 {\n-        ret {val: (a & 0x3fu8 as uint) << 8u | (data.(start + 1u) as uint),\n+        ret {val: (a & 0x3fu8 as uint) << 8u | (data[start + 1u] as uint),\n              next: start + 2u};\n-    } else if (a & 0x20u8 != 0u8) {\n+    } else if a & 0x20u8 != 0u8 {\n         ret {val:\n                  (a & 0x1fu8 as uint) << 16u |\n-                     (data.(start + 1u) as uint) << 8u |\n-                     (data.(start + 2u) as uint),\n+                     (data[start + 1u] as uint) << 8u |\n+                     (data[start + 2u] as uint),\n              next: start + 3u};\n-    } else if (a & 0x10u8 != 0u8) {\n+    } else if a & 0x10u8 != 0u8 {\n         ret {val:\n                  (a & 0x0fu8 as uint) << 24u |\n-                     (data.(start + 1u) as uint) << 16u |\n-                     (data.(start + 2u) as uint) << 8u |\n-                     (data.(start + 3u) as uint),\n+                     (data[start + 1u] as uint) << 16u |\n+                     (data[start + 2u] as uint) << 8u |\n+                     (data[start + 3u] as uint),\n              next: start + 4u};\n     } else { log_err \"vint too big\"; fail; }\n }\n@@ -105,7 +105,7 @@ fn be_uint_from_bytes(data: &@[u8], start: uint, size: uint) -> uint {\n     let pos = start;\n     while sz > 0u {\n         sz -= 1u;\n-        val += (data.(pos) as uint) << sz * 8u;\n+        val += (data[pos] as uint) << sz * 8u;\n         pos += 1u;\n     }\n     ret val;\n@@ -122,17 +122,17 @@ type writer = {writer: io::buf_writer, mutable size_positions: [uint]};\n fn write_sized_vint(w: &io::buf_writer, n: uint, size: uint) {\n     let buf: [u8];\n     alt size {\n-      1u { buf = ~[0x80u8 | (n as u8)]; }\n-      2u { buf = ~[0x40u8 | (n >> 8u as u8), n & 0xffu as u8]; }\n+      1u { buf = [0x80u8 | (n as u8)]; }\n+      2u { buf = [0x40u8 | (n >> 8u as u8), n & 0xffu as u8]; }\n       3u {\n         buf =\n-            ~[0x20u8 | (n >> 16u as u8), n >> 8u & 0xffu as u8,\n-              n & 0xffu as u8];\n+            [0x20u8 | (n >> 16u as u8), n >> 8u & 0xffu as u8,\n+             n & 0xffu as u8];\n       }\n       4u {\n         buf =\n-            ~[0x10u8 | (n >> 24u as u8), n >> 16u & 0xffu as u8,\n-              n >> 8u & 0xffu as u8, n & 0xffu as u8];\n+            [0x10u8 | (n >> 24u as u8), n >> 16u & 0xffu as u8,\n+             n >> 8u & 0xffu as u8, n & 0xffu as u8];\n       }\n       _ { log_err \"vint to write too big\"; fail; }\n     }\n@@ -149,7 +149,7 @@ fn write_vint(w: &io::buf_writer, n: uint) {\n }\n \n fn create_writer(w: &io::buf_writer) -> writer {\n-    let size_positions: [uint] = ~[];\n+    let size_positions: [uint] = [];\n     ret {writer: w, mutable size_positions: size_positions};\n }\n \n@@ -161,8 +161,8 @@ fn start_tag(w: &writer, tag_id: uint) {\n     write_vint(w.writer, tag_id);\n     // Write a placeholder four-byte size.\n \n-    w.size_positions += ~[w.writer.tell()];\n-    let zeroes: [u8] = ~[0u8, 0u8, 0u8, 0u8];\n+    w.size_positions += [w.writer.tell()];\n+    let zeroes: [u8] = [0u8, 0u8, 0u8, 0u8];\n     w.writer.write(zeroes);\n }\n "}, {"sha": "6f2a27a958de526e45a4422e481845e3bc1ee6dc", "filename": "src/lib/either.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -5,32 +5,33 @@ import option::none;\n \n tag t<T, U> { left(T); right(U); }\n \n-fn either<T, U, V>(f_left: &block(&T) -> V, f_right: &block(&U) -> V,\n-                   value: &t<T, U>) -> V {\n+fn either<T, U,\n+          V>(f_left: &block(&T) -> V, f_right: &block(&U) -> V,\n+             value: &t<T, U>) -> V {\n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n \n fn lefts<T, U>(eithers: &[t<T, U>]) -> [T] {\n-    let result: [T] = ~[];\n+    let result: [T] = [];\n     for elt: t<T, U> in eithers {\n-        alt elt { left(l) { result += ~[l] } _ {/* fallthrough */ } }\n+        alt elt { left(l) { result += [l] } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n fn rights<T, U>(eithers: &[t<T, U>]) -> [U] {\n-    let result: [U] = ~[];\n+    let result: [U] = [];\n     for elt: t<T, U> in eithers {\n-        alt elt { right(r) { result += ~[r] } _ {/* fallthrough */ } }\n+        alt elt { right(r) { result += [r] } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n fn partition<T, U>(eithers: &[t<T, U>]) -> {lefts: [T], rights: [U]} {\n-    let lefts: [T] = ~[];\n-    let rights: [U] = ~[];\n+    let lefts: [T] = [];\n+    let rights: [U] = [];\n     for elt: t<T, U> in eithers {\n-        alt elt { left(l) { lefts += ~[l] } right(r) { rights += ~[r] } }\n+        alt elt { left(l) { lefts += [l] } right(r) { rights += [r] } }\n     }\n     ret {lefts: lefts, rights: rights};\n }"}, {"sha": "7f7605a1d85e8401e8fc5819892e19914416beee", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -69,16 +69,16 @@ mod ct {\n \n     // A fragment of the output sequence\n     tag piece { piece_string(str); piece_conv(conv); }\n-    type error_fn = fn(str) -> !  ;\n+    type error_fn = fn(str) -> ! ;\n \n     fn parse_fmt_string(s: str, error: error_fn) -> [piece] {\n-        let pieces: [piece] = ~[];\n+        let pieces: [piece] = [];\n         let lim = str::byte_len(s);\n         let buf = \"\";\n         fn flush_buf(buf: str, pieces: &mutable [piece]) -> str {\n             if str::byte_len(buf) > 0u {\n                 let piece = piece_string(buf);\n-                pieces += ~[piece];\n+                pieces += [piece];\n             }\n             ret \"\";\n         }\n@@ -96,7 +96,7 @@ mod ct {\n                 } else {\n                     buf = flush_buf(buf, pieces);\n                     let rs = parse_conversion(s, i, lim, error);\n-                    pieces += ~[rs.piece];\n+                    pieces += [rs.piece];\n                     i = rs.next;\n                 }\n             } else { buf += curr; i += 1u; }\n@@ -107,7 +107,7 @@ mod ct {\n     fn peek_num(s: str, i: uint, lim: uint) ->\n        option::t<{num: uint, next: uint}> {\n         if i >= lim { ret none; }\n-        let c = s.(i);\n+        let c = s[i];\n         if !('0' as u8 <= c && c <= '9' as u8) { ret option::none; }\n         let n = c - ('0' as u8) as uint;\n         ret alt peek_num(s, i + 1u, lim) {\n@@ -143,15 +143,15 @@ mod ct {\n               some(t) {\n                 let n = t.num;\n                 let j = t.next;\n-                if j < lim && s.(j) == '$' as u8 {\n+                if j < lim && s[j] == '$' as u8 {\n                     {param: some(n as int), next: j + 1u}\n                 } else { {param: none, next: i} }\n               }\n             };\n     }\n     fn parse_flags(s: str, i: uint, lim: uint) ->\n        {flags: [flag], next: uint} {\n-        let noflags: [flag] = ~[];\n+        let noflags: [flag] = [];\n         if i >= lim { ret {flags: noflags, next: i}; }\n \n         // FIXME: This recursion generates illegal instructions if the return\n@@ -161,27 +161,27 @@ mod ct {\n             let next = parse_flags(s, i + 1u, lim);\n             let rest = next.flags;\n             let j = next.next;\n-            let curr: [flag] = ~[f];\n+            let curr: [flag] = [f];\n             ret @{flags: curr + rest, next: j};\n         }\n         let more = bind more_(_, s, i, lim);\n-        let f = s.(i);\n+        let f = s[i];\n         ret if f == '-' as u8 {\n                 *more(flag_left_justify)\n-            } else if (f == '0' as u8) {\n+            } else if f == '0' as u8 {\n                 *more(flag_left_zero_pad)\n-            } else if (f == ' ' as u8) {\n+            } else if f == ' ' as u8 {\n                 *more(flag_space_for_sign)\n-            } else if (f == '+' as u8) {\n+            } else if f == '+' as u8 {\n                 *more(flag_sign_always)\n-            } else if (f == '#' as u8) {\n+            } else if f == '#' as u8 {\n                 *more(flag_alternate)\n             } else { {flags: noflags, next: i} };\n     }\n     fn parse_count(s: str, i: uint, lim: uint) -> {count: count, next: uint} {\n         ret if i >= lim {\n                 {count: count_implied, next: i}\n-            } else if (s.(i) == '*' as u8) {\n+            } else if s[i] == '*' as u8 {\n                 let param = parse_parameter(s, i + 1u, lim);\n                 let j = param.next;\n                 alt param.param {\n@@ -202,7 +202,7 @@ mod ct {\n        {count: count, next: uint} {\n         ret if i >= lim {\n                 {count: count_implied, next: i}\n-            } else if (s.(i) == '.' as u8) {\n+            } else if s[i] == '.' as u8 {\n                 let count = parse_count(s, i + 1u, lim);\n \n \n@@ -223,21 +223,21 @@ mod ct {\n         let t =\n             if str::eq(tstr, \"b\") {\n                 ty_bool\n-            } else if (str::eq(tstr, \"s\")) {\n+            } else if str::eq(tstr, \"s\") {\n                 ty_str\n-            } else if (str::eq(tstr, \"c\")) {\n+            } else if str::eq(tstr, \"c\") {\n                 ty_char\n-            } else if (str::eq(tstr, \"d\") || str::eq(tstr, \"i\")) {\n+            } else if str::eq(tstr, \"d\") || str::eq(tstr, \"i\") {\n                 ty_int(signed)\n-            } else if (str::eq(tstr, \"u\")) {\n+            } else if str::eq(tstr, \"u\") {\n                 ty_int(unsigned)\n-            } else if (str::eq(tstr, \"x\")) {\n+            } else if str::eq(tstr, \"x\") {\n                 ty_hex(case_lower)\n-            } else if (str::eq(tstr, \"X\")) {\n+            } else if str::eq(tstr, \"X\") {\n                 ty_hex(case_upper)\n-            } else if (str::eq(tstr, \"t\")) {\n+            } else if str::eq(tstr, \"t\") {\n                 ty_bits\n-            } else if (str::eq(tstr, \"o\")) {\n+            } else if str::eq(tstr, \"o\") {\n                 ty_octal\n             } else { error(\"unknown type in conversion: \" + tstr) };\n         ret {ty: t, next: i + 1u};\n@@ -277,7 +277,7 @@ mod rt {\n         if 0 <= i {\n             if have_flag(cv.flags, flag_sign_always) {\n                 s = \"+\" + s;\n-            } else if (have_flag(cv.flags, flag_space_for_sign)) {\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n                 s = \" \" + s;\n             }\n         }\n@@ -404,9 +404,9 @@ mod rt {\n         // instead.\n \n         if signed && zero_padding && str::byte_len(s) > 0u {\n-            let head = s.(0);\n+            let head = s[0];\n             if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n-                let headstr = str::unsafe_from_bytes(~[head]);\n+                let headstr = str::unsafe_from_bytes([head]);\n                 let bytelen = str::byte_len(s);\n                 let numpart = str::substr(s, 1u, bytelen - 1u);\n                 ret headstr + padstr + numpart;"}, {"sha": "c49d77815a32f2d2dfce02a5e6148fdbede6d4ea", "filename": "src/lib/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -35,7 +35,7 @@ fn basename(p: path) -> path {\n // FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n fn connect(pre: path, post: path) -> path {\n     let len = str::byte_len(pre);\n-    ret if pre.(len - 1u) == os_fs::path_sep as u8 {\n+    ret if pre[len - 1u] == os_fs::path_sep as u8 {\n \n             // Trailing '/'?\n             pre + post\n@@ -46,11 +46,11 @@ fn file_is_dir(p: path) -> bool { ret rustrt::rust_file_is_dir(p) != 0; }\n \n fn list_dir(p: path) -> [str] {\n     let pl = str::byte_len(p);\n-    if pl == 0u || p.(pl - 1u) as char != os_fs::path_sep { p += path_sep(); }\n-    let full_paths: [str] = ~[];\n+    if pl == 0u || p[pl - 1u] as char != os_fs::path_sep { p += path_sep(); }\n+    let full_paths: [str] = [];\n     for filename: str in os_fs::list_dir(p) {\n         if !str::eq(filename, \".\") {\n-            if !str::eq(filename, \"..\") { full_paths += ~[p + filename]; }\n+            if !str::eq(filename, \"..\") { full_paths += [p + filename]; }\n         }\n     }\n     ret full_paths;"}, {"sha": "80bc7747b47f1659fd01a8e6ab0c5a3270ea0191", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -28,7 +28,7 @@ fn getenv(n: str) -> option::t<str> {\n         let res = os::kernel32::GetEnvironmentVariableA(nbuf, vbuf, nsize);\n         if res == 0u {\n             ret option::none;\n-        } else if (res < nsize) {\n+        } else if res < nsize {\n             ret option::some(str::str_from_cstr(vbuf));\n         } else { nsize = res; }\n     }"}, {"sha": "95747e3c453225fdd55ba34092679edee0a0109a", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -68,7 +68,7 @@ tag optval { val(str); given; }\n type match = {opts: [opt], vals: [mutable [optval]], free: [str]};\n \n fn is_arg(arg: str) -> bool {\n-    ret str::byte_len(arg) > 1u && arg.(0) == '-' as u8;\n+    ret str::byte_len(arg) > 1u && arg[0] == '-' as u8;\n }\n \n fn name_str(nm: name) -> str {\n@@ -78,7 +78,7 @@ fn name_str(nm: name) -> str {\n fn find_opt(opts: &[opt], nm: name) -> option::t<uint> {\n     let i = 0u;\n     let l = vec::len::<opt>(opts);\n-    while i < l { if opts.(i).name == nm { ret some::<uint>(i); } i += 1u; }\n+    while i < l { if opts[i].name == nm { ret some::<uint>(i); } i += 1u; }\n     ret none::<uint>;\n }\n \n@@ -108,41 +108,41 @@ tag result { success(match); failure(fail_); }\n \n fn getopts(args: &[str], opts: &[opt]) -> result {\n     let n_opts = vec::len::<opt>(opts);\n-    fn f(_x: uint) -> [optval] { ret ~[]; }\n+    fn f(_x: uint) -> [optval] { ret []; }\n     let vals = vec::init_fn_mut::<[optval]>(f, n_opts);\n-    let free: [str] = ~[];\n+    let free: [str] = [];\n     let l = vec::len::<str>(args);\n     let i = 0u;\n     while i < l {\n-        let cur = args.(i);\n+        let cur = args[i];\n         let curlen = str::byte_len(cur);\n         if !is_arg(cur) {\n-            free += ~[cur];\n-        } else if (str::eq(cur, \"--\")) {\n+            free += [cur];\n+        } else if str::eq(cur, \"--\") {\n             let j = i + 1u;\n-            while j < l { free += ~[args.(j)]; j += 1u; }\n+            while j < l { free += [args[j]]; j += 1u; }\n             break;\n         } else {\n             let names;\n             let i_arg = option::none::<str>;\n-            if cur.(1) == '-' as u8 {\n+            if cur[1] == '-' as u8 {\n                 let tail = str::slice(cur, 2u, curlen);\n                 let eq = str::index(tail, '=' as u8);\n                 if eq == -1 {\n-                    names = ~[long(tail)];\n+                    names = [long(tail)];\n                 } else {\n-                    names = ~[long(str::slice(tail, 0u, eq as uint))];\n+                    names = [long(str::slice(tail, 0u, eq as uint))];\n                     i_arg =\n                         option::some::<str>(str::slice(tail,\n                                                        (eq as uint) + 1u,\n                                                        curlen - 2u));\n                 }\n             } else {\n                 let j = 1u;\n-                names = ~[];\n+                names = [];\n                 while j < curlen {\n                     let range = str::char_range_at(cur, j);\n-                    names += ~[short(range.ch)];\n+                    names += [short(range.ch)];\n                     j = range.next;\n                 }\n             }\n@@ -154,27 +154,27 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n                   some(id) { optid = id; }\n                   none. { ret failure(unrecognized_option(name_str(nm))); }\n                 }\n-                alt opts.(optid).hasarg {\n+                alt opts[optid].hasarg {\n                   no. {\n                     if !option::is_none::<str>(i_arg) {\n                         ret failure(unexpected_argument(name_str(nm)));\n                     }\n-                    vals.(optid) += ~[given];\n+                    vals[optid] += [given];\n                   }\n                   maybe. {\n                     if !option::is_none::<str>(i_arg) {\n-                        vals.(optid) += ~[val(option::get(i_arg))];\n-                    } else if (name_pos < vec::len::<name>(names) ||\n-                                   i + 1u == l || is_arg(args.(i + 1u))) {\n-                        vals.(optid) += ~[given];\n-                    } else { i += 1u; vals.(optid) += ~[val(args.(i))]; }\n+                        vals[optid] += [val(option::get(i_arg))];\n+                    } else if name_pos < vec::len::<name>(names) ||\n+                                  i + 1u == l || is_arg(args[i + 1u]) {\n+                        vals[optid] += [given];\n+                    } else { i += 1u; vals[optid] += [val(args[i])]; }\n                   }\n                   yes. {\n                     if !option::is_none::<str>(i_arg) {\n-                        vals.(optid) += ~[val(option::get::<str>(i_arg))];\n-                    } else if (i + 1u == l) {\n+                        vals[optid] += [val(option::get::<str>(i_arg))];\n+                    } else if i + 1u == l {\n                         ret failure(argument_missing(name_str(nm)));\n-                    } else { i += 1u; vals.(optid) += ~[val(args.(i))]; }\n+                    } else { i += 1u; vals[optid] += [val(args[i])]; }\n                   }\n                 }\n             }\n@@ -183,16 +183,16 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n     }\n     i = 0u;\n     while i < n_opts {\n-        let n = vec::len::<optval>(vals.(i));\n-        let occ = opts.(i).occur;\n+        let n = vec::len::<optval>(vals[i]);\n+        let occ = opts[i].occur;\n         if occ == req {\n             if n == 0u {\n-                ret failure(option_missing(name_str(opts.(i).name)));\n+                ret failure(option_missing(name_str(opts[i].name)));\n             }\n         }\n         if occ != multi {\n             if n > 1u {\n-                ret failure(option_duplicated(name_str(opts.(i).name)));\n+                ret failure(option_duplicated(name_str(opts[i].name)));\n             }\n         }\n         i += 1u;\n@@ -202,12 +202,12 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n \n fn opt_vals(m: &match, nm: str) -> [optval] {\n     ret alt find_opt(m.opts, mkname(nm)) {\n-          some(id) { m.vals.(id) }\n+          some(id) { m.vals[id] }\n           none. { log_err \"No option '\" + nm + \"' defined.\"; fail }\n         };\n }\n \n-fn opt_val(m: &match, nm: str) -> optval { ret opt_vals(m, nm).(0); }\n+fn opt_val(m: &match, nm: str) -> optval { ret opt_vals(m, nm)[0]; }\n \n fn opt_present(m: &match, nm: str) -> bool {\n     ret vec::len::<optval>(opt_vals(m, nm)) > 0u;\n@@ -218,17 +218,17 @@ fn opt_str(m: &match, nm: str) -> str {\n }\n \n fn opt_strs(m: &match, nm: str) -> [str] {\n-    let acc: [str] = ~[];\n+    let acc: [str] = [];\n     for v: optval in opt_vals(m, nm) {\n-        alt v { val(s) { acc += ~[s]; } _ { } }\n+        alt v { val(s) { acc += [s]; } _ { } }\n     }\n     ret acc;\n }\n \n fn opt_maybe_str(m: &match, nm: str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n-    ret alt vals.(0) { val(s) { some::<str>(s) } _ { none::<str> } };\n+    ret alt vals[0] { val(s) { some::<str>(s) } _ { none::<str> } };\n }\n \n \n@@ -238,7 +238,7 @@ fn opt_maybe_str(m: &match, nm: str) -> option::t<str> {\n fn opt_default(m: &match, nm: str, def: str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n-    ret alt vals.(0) { val(s) { some::<str>(s) } _ { some::<str>(def) } }\n+    ret alt vals[0] { val(s) { some::<str>(s) } _ { some::<str>(def) } }\n }\n // Local Variables:\n // mode: rust;"}, {"sha": "fd4cd09f27916662b1b44a2d88d975cb4cd88030", "filename": "src/lib/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -52,7 +52,7 @@ fn str(i: int) -> str { ret to_str(i, 10u); }\n fn pow(base: int, exponent: uint) -> int {\n     ret if exponent == 0u {\n             1\n-        } else if (base == 0) {\n+        } else if base == 0 {\n             0\n         } else {\n             let accum = base;"}, {"sha": "454cfd1041fa1e03ef57dbb0c33ebb9953234538", "filename": "src/lib/io.rs", "status": "modified", "additions": 60, "deletions": 73, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -15,53 +15,49 @@ tag seek_style { seek_set; seek_end; seek_cur; }\n \n // The raw underlying reader class. All readers must implement this.\n type buf_reader =\n-\n     // FIXME: Seekable really should be orthogonal. We will need\n     // inheritance.\n     obj {\n-        fn read(uint) -> [u8] ;\n-        fn read_byte() -> int ;\n-        fn unread_byte(int) ;\n-        fn eof() -> bool ;\n-        fn seek(int, seek_style) ;\n-        fn tell() -> uint ;\n+        fn read(uint) -> [u8];\n+        fn read_byte() -> int;\n+        fn unread_byte(int);\n+        fn eof() -> bool;\n+        fn seek(int, seek_style);\n+        fn tell() -> uint;\n     };\n \n \n // Convenience methods for reading.\n type reader =\n-\n     // FIXME: This should inherit from buf_reader.\n-     // FIXME: eventually u64\n+    // FIXME: eventually u64\n \n     obj {\n-        fn get_buf_reader() -> buf_reader ;\n-        fn read_byte() -> int ;\n-        fn unread_byte(int) ;\n-        fn read_bytes(uint) -> [u8] ;\n-        fn read_char() -> char ;\n-        fn eof() -> bool ;\n-        fn read_line() -> str ;\n-        fn read_c_str() -> str ;\n-        fn read_le_uint(uint) -> uint ;\n-        fn read_le_int(uint) -> int ;\n-        fn read_be_uint(uint) -> uint ;\n-        fn read_whole_stream() -> [u8] ;\n-        fn seek(int, seek_style) ;\n-        fn tell() -> uint ;\n+        fn get_buf_reader() -> buf_reader;\n+        fn read_byte() -> int;\n+        fn unread_byte(int);\n+        fn read_bytes(uint) -> [u8];\n+        fn read_char() -> char;\n+        fn eof() -> bool;\n+        fn read_line() -> str;\n+        fn read_c_str() -> str;\n+        fn read_le_uint(uint) -> uint;\n+        fn read_le_int(uint) -> int;\n+        fn read_be_uint(uint) -> uint;\n+        fn read_whole_stream() -> [u8];\n+        fn seek(int, seek_style);\n+        fn tell() -> uint;\n     };\n \n fn convert_whence(whence: seek_style) -> int {\n     ret alt whence { seek_set. { 0 } seek_cur. { 1 } seek_end. { 2 } };\n }\n \n-resource FILE_res(f: os::libc::FILE) {\n-    os::libc::fclose(f);\n-}\n+resource FILE_res(f: os::libc::FILE) { os::libc::fclose(f); }\n \n obj FILE_buf_reader(f: os::libc::FILE, res: option::t<@FILE_res>) {\n     fn read(len: uint) -> [u8] {\n-        let buf = ~[];\n+        let buf = [];\n         vec::reserve::<u8>(buf, len);\n         let read = os::libc::fread(vec::to_ptr::<u8>(buf), 1u, len, f);\n         vec::unsafe::set_len::<u8>(buf, read);\n@@ -73,9 +69,7 @@ obj FILE_buf_reader(f: os::libc::FILE, res: option::t<@FILE_res>) {\n     fn seek(offset: int, whence: seek_style) {\n         assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0);\n     }\n-    fn tell() -> uint {\n-        ret os::libc::ftell(f) as uint;\n-    }\n+    fn tell() -> uint { ret os::libc::ftell(f) as uint; }\n }\n \n \n@@ -111,24 +105,24 @@ obj new_reader(rdr: buf_reader) {\n     }\n     fn eof() -> bool { ret rdr.eof(); }\n     fn read_line() -> str {\n-        let buf: [u8] = ~[];\n+        let buf: [u8] = [];\n         // No break yet in rustc\n \n         let go_on = true;\n         while go_on {\n             let ch = rdr.read_byte();\n             if ch == -1 || ch == 10 {\n                 go_on = false;\n-            } else { buf += ~[ch as u8]; }\n+            } else { buf += [ch as u8]; }\n         }\n         ret str::unsafe_from_bytes(buf);\n     }\n     fn read_c_str() -> str {\n-        let buf: [u8] = ~[];\n+        let buf: [u8] = [];\n         let go_on = true;\n         while go_on {\n             let ch = rdr.read_byte();\n-            if ch < 1 { go_on = false; } else { buf += ~[ch as u8]; }\n+            if ch < 1 { go_on = false; } else { buf += [ch as u8]; }\n         }\n         ret str::unsafe_from_bytes(buf);\n     }\n@@ -166,7 +160,7 @@ obj new_reader(rdr: buf_reader) {\n         ret val;\n     }\n     fn read_whole_stream() -> [u8] {\n-        let buf: [u8] = ~[];\n+        let buf: [u8] = [];\n         while !rdr.eof() { buf += rdr.read(2048u); }\n         ret buf;\n     }\n@@ -205,7 +199,7 @@ obj byte_buf_reader(bbuf: byte_buf) {\n     }\n     fn read_byte() -> int {\n         if bbuf.pos == vec::len::<u8>(bbuf.buf) { ret -1; }\n-        let b = bbuf.buf.(bbuf.pos);\n+        let b = bbuf.buf[bbuf.pos];\n         bbuf.pos += 1u;\n         ret b as int;\n     }\n@@ -232,15 +226,14 @@ fn string_reader(s: &str) -> reader {\n tag fileflag { append; create; truncate; none; }\n \n type buf_writer =\n-\n     // FIXME: Seekable really should be orthogonal. We will need\n     // inheritance.\n-     // FIXME: eventually u64\n+    // FIXME: eventually u64\n \n     obj {\n-        fn write(&[u8]) ;\n-        fn seek(int, seek_style) ;\n-        fn tell() -> uint ;\n+        fn write(&[u8]);\n+        fn seek(int, seek_style);\n+        fn tell() -> uint;\n     };\n \n obj FILE_writer(f: os::libc::FILE, res: option::t<@FILE_res>) {\n@@ -253,14 +246,10 @@ obj FILE_writer(f: os::libc::FILE, res: option::t<@FILE_res>) {\n     fn seek(offset: int, whence: seek_style) {\n         assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0);\n     }\n-    fn tell() -> uint {\n-        ret os::libc::ftell(f) as uint;\n-    }\n+    fn tell() -> uint { ret os::libc::ftell(f) as uint; }\n }\n \n-resource fd_res(fd: int) {\n-    os::libc::close(fd);\n-}\n+resource fd_res(fd: int) { os::libc::close(fd); }\n \n obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n     fn write(v: &[u8]) {\n@@ -312,32 +301,31 @@ fn file_buf_writer(path: str, flags: &[fileflag]) -> buf_writer {\n }\n \n type writer =\n-\n     // write_str will continue to do utf-8 output only. an alternative\n     // function will be provided for general encoded string output\n     obj {\n-        fn get_buf_writer() -> buf_writer ;\n-        fn write_str(str) ;\n-        fn write_line(str) ;\n-        fn write_char(char) ;\n-        fn write_int(int) ;\n-        fn write_uint(uint) ;\n-        fn write_bytes(&[u8]) ;\n-        fn write_le_uint(uint, uint) ;\n-        fn write_le_int(int, uint) ;\n-        fn write_be_uint(uint, uint) ;\n+        fn get_buf_writer() -> buf_writer;\n+        fn write_str(str);\n+        fn write_line(str);\n+        fn write_char(char);\n+        fn write_int(int);\n+        fn write_uint(uint);\n+        fn write_bytes(&[u8]);\n+        fn write_le_uint(uint, uint);\n+        fn write_le_int(int, uint);\n+        fn write_be_uint(uint, uint);\n     };\n \n fn uint_to_le_bytes(n: uint, size: uint) -> [u8] {\n-    let bytes: [u8] = ~[];\n-    while size > 0u { bytes += ~[n & 255u as u8]; n >>= 8u; size -= 1u; }\n+    let bytes: [u8] = [];\n+    while size > 0u { bytes += [n & 255u as u8]; n >>= 8u; size -= 1u; }\n     ret bytes;\n }\n \n fn uint_to_be_bytes(n: uint, size: uint) -> [u8] {\n-    let bytes: [u8] = ~[];\n+    let bytes: [u8] = [];\n     let i = size - 1u as int;\n-    while i >= 0 { bytes += ~[n >> (i * 8 as uint) & 255u as u8]; i -= 1; }\n+    while i >= 0 { bytes += [n >> (i * 8 as uint) & 255u as u8]; i -= 1; }\n     ret bytes;\n }\n \n@@ -354,9 +342,7 @@ obj new_writer(out: buf_writer) {\n         out.write(str::bytes(str::from_char(ch)));\n     }\n     fn write_int(n: int) { out.write(str::bytes(int::to_str(n, 10u))); }\n-    fn write_uint(n: uint) {\n-        out.write(str::bytes(uint::to_str(n, 10u)));\n-    }\n+    fn write_uint(n: uint) { out.write(str::bytes(uint::to_str(n, 10u))); }\n     fn write_bytes(bytes: &[u8]) { out.write(bytes); }\n     fn write_le_uint(n: uint, size: uint) {\n         out.write(uint_to_le_bytes(n, size));\n@@ -391,8 +377,8 @@ fn stdout() -> writer { ret new_writer(fd_buf_writer(1, option::none)); }\n \n type str_writer =\n     obj {\n-        fn get_writer() -> writer ;\n-        fn get_str() -> str ;\n+        fn get_writer() -> writer;\n+        fn get_str() -> str;\n     };\n \n type mutable_byte_buf = @{mutable buf: [mutable u8], mutable pos: uint};\n@@ -402,7 +388,7 @@ obj byte_buf_writer(buf: mutable_byte_buf) {\n         // Fast path.\n \n         if buf.pos == vec::len(buf.buf) {\n-            for b: u8 in v { buf.buf += ~[mutable b]; }\n+            for b: u8 in v { buf.buf += [mutable b]; }\n             buf.pos += vec::len::<u8>(v);\n             ret;\n         }\n@@ -411,10 +397,10 @@ obj byte_buf_writer(buf: mutable_byte_buf) {\n         let vlen = vec::len::<u8>(v);\n         let vpos = 0u;\n         while vpos < vlen {\n-            let b = v.(vpos);\n+            let b = v[vpos];\n             if buf.pos == vec::len(buf.buf) {\n-                buf.buf += ~[mutable b];\n-            } else { buf.buf.(buf.pos) = b; }\n+                buf.buf += [mutable b];\n+            } else { buf.buf[buf.pos] = b; }\n             buf.pos += 1u;\n             vpos += 1u;\n         }\n@@ -430,7 +416,7 @@ obj byte_buf_writer(buf: mutable_byte_buf) {\n fn string_writer() -> str_writer {\n     // FIXME: yikes, this is bad. Needs fixing of mutable syntax.\n \n-    let b: [mutable u8] = ~[mutable 0u8];\n+    let b: [mutable u8] = [mutable 0u8];\n     vec::pop(b);\n     let buf: mutable_byte_buf = @{mutable buf: b, mutable pos: 0u};\n     obj str_writer_wrap(wr: writer, buf: mutable_byte_buf) {\n@@ -451,7 +437,7 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n       seek_cur. { bpos += offset; }\n       seek_end. { bpos = blen + offset; }\n     }\n-    if bpos < 0 { bpos = 0; } else if (bpos > blen) { bpos = blen; }\n+    if bpos < 0 { bpos = 0; } else if bpos > blen { bpos = blen; }\n     ret bpos as uint;\n }\n \n@@ -460,6 +446,7 @@ fn read_whole_file_str(file: &str) -> str {\n }\n \n fn read_whole_file(file: &str) -> [u8] {\n+\n     // FIXME: There's a lot of copying here\n     file_reader(file).read_whole_stream()\n }"}, {"sha": "4f3cc5b22386580aa07f8e30bb4b051d6c2d5f07", "filename": "src/lib/list.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -13,7 +13,7 @@ fn from_vec<@T>(v: &[T]) -> list<T> {\n     ret l;\n }\n \n-fn foldl<@T, @U>(ls_: &list<T>, u: &U, f: &block(&T, &U) -> U ) -> U {\n+fn foldl<@T, @U>(ls_: &list<T>, u: &U, f: &block(&T, &U) -> U) -> U {\n     let accum: U = u;\n     let ls = ls_;\n     while true {\n@@ -25,8 +25,8 @@ fn foldl<@T, @U>(ls_: &list<T>, u: &U, f: &block(&T, &U) -> U ) -> U {\n     ret accum;\n }\n \n-fn find<@T, @U>(ls_: &list<T>, f: &block(&T) -> option::t<U>)\n-    -> option::t<U> {\n+fn find<@T, @U>(ls_: &list<T>, f: &block(&T) -> option::t<U>) ->\n+   option::t<U> {\n     let ls = ls_;\n     while true {\n         alt ls {\n@@ -56,26 +56,17 @@ fn length<@T>(ls: &list<T>) -> uint {\n }\n \n fn cdr<@T>(ls: &list<T>) -> list<T> {\n-    alt ls {\n-      cons(_, tl) { ret *tl; }\n-      nil. { fail \"list empty\" }\n-    }\n+    alt ls { cons(_, tl) { ret *tl; } nil. { fail \"list empty\" } }\n }\n \n fn car<@T>(ls: &list<T>) -> T {\n-    alt ls {\n-      cons(hd, _) { ret hd; }\n-      nil. { fail \"list empty\" }\n-    }\n+    alt ls { cons(hd, _) { ret hd; } nil. { fail \"list empty\" } }\n }\n \n fn append<@T>(l: &list<T>, m: &list<T>) -> list<T> {\n     alt l {\n       nil. { ret m; }\n-      cons(x, xs) {\n-        let rest = append(*xs, m);\n-        ret cons(x, @rest);\n-      }\n+      cons(x, xs) { let rest = append(*xs, m); ret cons(x, @rest); }\n     }\n }\n "}, {"sha": "d54eae03d105763a3421dcc4f2a290ce31bb661c", "filename": "src/lib/map.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,21 +1,21 @@\n /**\n  * Hashmap implementation.\n  */\n-type hashfn<K> = fn(&K) -> uint ;\n+type hashfn<K> = fn(&K) -> uint;\n \n-type eqfn<K> = fn(&K, &K) -> bool ;\n+type eqfn<K> = fn(&K, &K) -> bool;\n \n type hashmap<K, V> =\n     obj {\n-        fn size() -> uint ;\n-        fn insert(&K, &V) -> bool ;\n-        fn contains_key(&K) -> bool ;\n-        fn get(&K) -> V ;\n-        fn find(&K) -> option::t<V> ;\n-        fn remove(&K) -> option::t<V> ;\n-        fn rehash() ;\n-        iter items() -> @{key: K, val: V} ;\n-        iter keys() -> K ;\n+        fn size() -> uint;\n+        fn insert(&K, &V) -> bool;\n+        fn contains_key(&K) -> bool;\n+        fn get(&K) -> V;\n+        fn find(&K) -> option::t<V>;\n+        fn remove(&K) -> option::t<V>;\n+        fn rehash();\n+        iter items() -> @{key: K, val: V};\n+        iter keys() -> K;\n     };\n type hashset<K> = hashmap<K, ()>;\n \n@@ -26,7 +26,7 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n \n     let load_factor: util::rational = {num: 3, den: 4};\n     tag bucket<@K, @V> { nil; deleted; some(K, V); }\n-    fn make_buckets<@K, @V>(nbkts: uint) -> [mutable (bucket<K, V>)] {\n+    fn make_buckets<@K, @V>(nbkts: uint) -> [mutable bucket<K, V>] {\n         ret vec::init_elt_mut::<bucket<K, V>>(nil::<K, V>, nbkts);\n     }\n     // Derive two hash functions from the one given by taking the upper\n@@ -53,37 +53,36 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n      * will fail.\n      */\n \n-    fn insert_common<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n-                             bkts: &[mutable bucket<K, V>], nbkts: uint,\n-                             key: &K, val: &V) -> bool {\n+    fn insert_common<@K,\n+                     @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n+                         bkts: &[mutable bucket<K, V>], nbkts: uint, key: &K,\n+                         val: &V) -> bool {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n         while i < nbkts {\n             let j: uint = hash(h, nbkts, i);\n-            alt bkts.(j) {\n+            alt bkts[j] {\n               some(k, _) {\n                 // Copy key to please alias analysis.\n \n                 let k_ = k;\n-                if eqer(key, k_) {\n-                    bkts.(j) = some(k_, val);\n-                    ret false;\n-                }\n+                if eqer(key, k_) { bkts[j] = some(k_, val); ret false; }\n                 i += 1u;\n               }\n-              _ { bkts.(j) = some(key, val); ret true; }\n+              _ { bkts[j] = some(key, val); ret true; }\n             }\n         }\n         fail; // full table\n     }\n-    fn find_common<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n-                           bkts: &[mutable bucket<K, V>], nbkts: uint,\n-                           key: &K) -> option::t<V> {\n+    fn find_common<@K,\n+                   @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n+                       bkts: &[mutable bucket<K, V>], nbkts: uint, key: &K) ->\n+       option::t<V> {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n         while i < nbkts {\n             let j: uint = hash(h, nbkts, i);\n-            alt bkts.(j) {\n+            alt bkts[j] {\n               some(k, v) {\n                 // Copy to please alias analysis.\n                 let k_ = k;\n@@ -97,9 +96,10 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n         }\n         ret option::none;\n     }\n-    fn rehash<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n-                      oldbkts: &[mutable bucket<K, V>], _noldbkts: uint,\n-                      newbkts: &[mutable bucket<K, V>], nnewbkts: uint) {\n+    fn rehash<@K,\n+              @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n+                  oldbkts: &[mutable bucket<K, V>], _noldbkts: uint,\n+                  newbkts: &[mutable bucket<K, V>], nnewbkts: uint) {\n         for b: bucket<K, V> in oldbkts {\n             alt b {\n               some(k_, v_) {\n@@ -111,12 +111,13 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n             }\n         }\n     }\n-    obj hashmap<@K, @V>(hasher: hashfn<K>,\n-                        eqer: eqfn<K>,\n-                        mutable bkts: [mutable bucket<K, V>],\n-                        mutable nbkts: uint,\n-                        mutable nelts: uint,\n-                        lf: util::rational) {\n+    obj hashmap<@K,\n+                @V>(hasher: hashfn<K>,\n+                    eqer: eqfn<K>,\n+                    mutable bkts: [mutable bucket<K, V>],\n+                    mutable nbkts: uint,\n+                    mutable nelts: uint,\n+                    lf: util::rational) {\n         fn size() -> uint { ret nelts; }\n         fn insert(key: &K, val: &V) -> bool {\n             let load: util::rational =\n@@ -154,12 +155,12 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n             let h: uint = hasher(key);\n             while i < nbkts {\n                 let j: uint = hash(h, nbkts, i);\n-                alt bkts.(j) {\n+                alt bkts[j] {\n                   some(k, v) {\n                     let k_ = k;\n                     let vo = option::some(v);\n                     if eqer(key, k_) {\n-                        bkts.(j) = deleted;\n+                        bkts[j] = deleted;\n                         nelts -= 1u;\n                         ret vo;\n                     }"}, {"sha": "83923d6b987b32c83b076b027f18234b09958a4c", "filename": "src/lib/net.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fnet.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,29 +2,20 @@ import str;\n import vec;\n import uint;\n \n-tag ip_addr {\n-    ipv4(u8, u8, u8, u8);\n-}\n+tag ip_addr { ipv4(u8, u8, u8, u8); }\n \n-fn format_addr(ip : ip_addr) -> str {\n-    alt(ip) {\n+fn format_addr(ip: ip_addr) -> str {\n+    alt ip {\n       ipv4(a, b, c, d) {\n-        #fmt(\"%u.%u.%u.%u\",\n-             a as uint,\n-             b as uint,\n-             c as uint,\n-             d as uint)\n+        #fmt[\"%u.%u.%u.%u\", a as uint, b as uint, c as uint, d as uint]\n       }\n       _ { fail \"Unsupported address type\"; }\n     }\n }\n \n-fn parse_addr(ip : str) -> ip_addr {\n-    let parts = vec::map(uint::from_str, str::split(ip, \".\".(0)));\n+fn parse_addr(ip: str) -> ip_addr {\n+    let parts = vec::map(uint::from_str, str::split(ip, \".\"[0]));\n     if vec::len(parts) != 4u { fail \"Too many dots in IP address\"; }\n     for i in parts { if i > 255u { fail \"Invalid IP Address part.\"; } }\n-    ipv4(parts.(0) as u8,\n-         parts.(1) as u8,\n-         parts.(2) as u8,\n-         parts.(3) as u8)\n+    ipv4(parts[0] as u8, parts[1] as u8, parts[2] as u8, parts[3] as u8)\n }"}, {"sha": "ea14ef2b867e6d7e2f6993d62e290ec3987fa6df", "filename": "src/lib/option.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -3,10 +3,7 @@\n tag t<@T> { none; some(T); }\n \n fn get<@T>(opt: &t<T>) -> T {\n-    alt opt {\n-      some(x) { x }\n-      none. { fail \"option none\" }\n-    }\n+    alt opt { some(x) { x } none. { fail \"option none\" } }\n }\n \n fn map<@T, @U>(f: &block(&T) -> U, opt: &t<T>) -> t<U> {"}, {"sha": "fee8bbe06baecc4e482fb9a1793c32d66cc41f5a", "filename": "src/lib/rand.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frand.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -11,17 +11,16 @@ native \"rust\" mod rustrt {\n     fn rand_free(c: rctx);\n }\n \n-type rng = obj { fn next() -> u32; };\n+type rng =\n+    obj {\n+        fn next() -> u32;\n+    };\n \n-resource rand_res(c: rustrt::rctx) {\n-    rustrt::rand_free(c);\n-}\n+resource rand_res(c: rustrt::rctx) { rustrt::rand_free(c); }\n \n fn mk_rng() -> rng {\n     obj rt_rng(c: @rand_res) {\n-        fn next() -> u32 {\n-            ret rustrt::rand_next(**c);\n-        }\n+        fn next() -> u32 { ret rustrt::rand_next(**c); }\n     }\n     ret rt_rng(@rand_res(rustrt::rand_new()));\n }"}, {"sha": "fb593bca58a88125192086c13c5235b42afbc60c", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -13,9 +13,9 @@ native \"rust\" mod rustrt {\n }\n \n fn arg_vec(prog: str, args: &[str]) -> [sbuf] {\n-    let argptrs = ~[str::buf(prog)];\n-    for arg: str in args { argptrs += ~[str::buf(arg)]; }\n-    argptrs += ~[0 as sbuf];\n+    let argptrs = [str::buf(prog)];\n+    for arg: str in args { argptrs += [str::buf(arg)]; }\n+    argptrs += [0 as sbuf];\n     ret argptrs;\n }\n \n@@ -24,8 +24,8 @@ fn spawn_process(prog: str, args: &[str], in_fd: int, out_fd: int,\n     // Note: we have to hold on to this vector reference while we hold a\n     // pointer to its buffer\n     let argv = arg_vec(prog, args);\n-    let pid = rustrt::rust_run_program(\n-        vec::to_ptr(argv), in_fd, out_fd, err_fd);\n+    let pid =\n+        rustrt::rust_run_program(vec::to_ptr(argv), in_fd, out_fd, err_fd);\n     ret pid;\n }\n \n@@ -44,16 +44,15 @@ type program =\n         fn destroy();\n     };\n \n-resource program_res(p: program) {\n-    p.destroy();\n-}\n+resource program_res(p: program) { p.destroy(); }\n \n fn start_program(prog: str, args: &[str]) -> @program_res {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n-    let pid = spawn_process(prog, args, pipe_input.in, pipe_output.out,\n-                            pipe_err.out);\n+    let pid =\n+        spawn_process(prog, args, pipe_input.in, pipe_output.out,\n+                      pipe_err.out);\n \n     if pid == -1 { fail; }\n     os::libc::close(pipe_input.in);\n@@ -66,16 +65,13 @@ fn start_program(prog: str, args: &[str]) -> @program_res {\n                     mutable finished: bool) {\n         fn get_id() -> int { ret pid; }\n         fn input() -> io::writer {\n-            ret io::new_writer(\n-                io::fd_buf_writer(in_fd, option::none));\n+            ret io::new_writer(io::fd_buf_writer(in_fd, option::none));\n         }\n         fn output() -> io::reader {\n-            ret io::new_reader(\n-                io::FILE_buf_reader(out_file, option::none));\n+            ret io::new_reader(io::FILE_buf_reader(out_file, option::none));\n         }\n         fn err() -> io::reader {\n-            ret io::new_reader(\n-                io::FILE_buf_reader(err_file, option::none));\n+            ret io::new_reader(io::FILE_buf_reader(err_file, option::none));\n         }\n         fn close_input() {\n             let invalid_fd = -1;\n@@ -96,11 +92,9 @@ fn start_program(prog: str, args: &[str]) -> @program_res {\n             os::libc::fclose(err_file);\n         }\n     }\n-    ret @program_res(new_program(pid,\n-                                 pipe_input.out,\n+    ret @program_res(new_program(pid, pipe_input.out,\n                                  os::fd_FILE(pipe_output.in),\n-                                 os::fd_FILE(pipe_err.in),\n-                                 false));\n+                                 os::fd_FILE(pipe_err.in), false));\n }\n \n fn read_all(rd: &io::reader) -> str {\n@@ -112,8 +106,8 @@ fn read_all(rd: &io::reader) -> str {\n     ret buf;\n }\n \n-fn program_output(prog: str, args: [str])\n-    -> {status: int, out: str, err: str} {\n+fn program_output(prog: str, args: [str]) ->\n+   {status: int, out: str, err: str} {\n     let pr = start_program(prog, args);\n     pr.close_input();\n     ret {status: pr.finish(),"}, {"sha": "db6fad1578407611fedb9c44da6561d83d8065be", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -9,7 +9,6 @@ export sha1;\n export mk_sha1;\n \n type sha1 =\n-\n     // Provide message input as bytes\n \n \n@@ -25,11 +24,11 @@ type sha1 =\n     // Reset the sha1 state for reuse. This is called\n     // automatically during construction\n     obj {\n-        fn input(&[u8]) ;\n-        fn input_str(&str) ;\n-        fn result() -> [u8] ;\n-        fn result_str() -> str ;\n-        fn reset() ;\n+        fn input(&[u8]);\n+        fn input_str(&str);\n+        fn result() -> [u8];\n+        fn result_str() -> str;\n+        fn reset();\n     };\n \n \n@@ -65,7 +64,7 @@ fn mk_sha1() -> sha1 {\n \n         assert (!st.computed);\n         for element: u8 in msg {\n-            st.msg_block.(st.msg_block_idx) = element;\n+            st.msg_block[st.msg_block_idx] = element;\n             st.msg_block_idx += 1u;\n             st.len_low += 8u32;\n             if st.len_low == 0u32 {\n@@ -92,30 +91,29 @@ fn mk_sha1() -> sha1 {\n         t = 0;\n         while t < 16 {\n             let tmp;\n-            tmp = (st.msg_block.(t * 4) as u32) << 24u32;\n-            tmp = tmp | (st.msg_block.(t * 4 + 1) as u32) << 16u32;\n-            tmp = tmp | (st.msg_block.(t * 4 + 2) as u32) << 8u32;\n-            tmp = tmp | (st.msg_block.(t * 4 + 3) as u32);\n-            w.(t) = tmp;\n+            tmp = (st.msg_block[t * 4] as u32) << 24u32;\n+            tmp = tmp | (st.msg_block[t * 4 + 1] as u32) << 16u32;\n+            tmp = tmp | (st.msg_block[t * 4 + 2] as u32) << 8u32;\n+            tmp = tmp | (st.msg_block[t * 4 + 3] as u32);\n+            w[t] = tmp;\n             t += 1;\n         }\n         // Initialize the rest of vector w\n \n         while t < 80 {\n-            let val = w.(t - 3) ^ w.(t - 8) ^ w.(t - 14) ^ w.(t - 16);\n-            w.(t) = circular_shift(1u32, val);\n+            let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n+            w[t] = circular_shift(1u32, val);\n             t += 1;\n         }\n-        let a = st.h.(0);\n-        let b = st.h.(1);\n-        let c = st.h.(2);\n-        let d = st.h.(3);\n-        let e = st.h.(4);\n+        let a = st.h[0];\n+        let b = st.h[1];\n+        let c = st.h[2];\n+        let d = st.h[3];\n+        let e = st.h[4];\n         let temp: u32;\n         t = 0;\n         while t < 20 {\n-            temp =\n-                circular_shift(5u32, a) + (b & c | !b & d) + e + w.(t) + k0;\n+            temp = circular_shift(5u32, a) + (b & c | !b & d) + e + w[t] + k0;\n             e = d;\n             d = c;\n             c = circular_shift(30u32, b);\n@@ -124,7 +122,7 @@ fn mk_sha1() -> sha1 {\n             t += 1;\n         }\n         while t < 40 {\n-            temp = circular_shift(5u32, a) + (b ^ c ^ d) + e + w.(t) + k1;\n+            temp = circular_shift(5u32, a) + (b ^ c ^ d) + e + w[t] + k1;\n             e = d;\n             d = c;\n             c = circular_shift(30u32, b);\n@@ -134,8 +132,8 @@ fn mk_sha1() -> sha1 {\n         }\n         while t < 60 {\n             temp =\n-                circular_shift(5u32, a) + (b & c | b & d | c & d) + e + w.(t)\n-                    + k2;\n+                circular_shift(5u32, a) + (b & c | b & d | c & d) + e + w[t] +\n+                    k2;\n             e = d;\n             d = c;\n             c = circular_shift(30u32, b);\n@@ -144,33 +142,33 @@ fn mk_sha1() -> sha1 {\n             t += 1;\n         }\n         while t < 80 {\n-            temp = circular_shift(5u32, a) + (b ^ c ^ d) + e + w.(t) + k3;\n+            temp = circular_shift(5u32, a) + (b ^ c ^ d) + e + w[t] + k3;\n             e = d;\n             d = c;\n             c = circular_shift(30u32, b);\n             b = a;\n             a = temp;\n             t += 1;\n         }\n-        st.h.(0) = st.h.(0) + a;\n-        st.h.(1) = st.h.(1) + b;\n-        st.h.(2) = st.h.(2) + c;\n-        st.h.(3) = st.h.(3) + d;\n-        st.h.(4) = st.h.(4) + e;\n+        st.h[0] = st.h[0] + a;\n+        st.h[1] = st.h[1] + b;\n+        st.h[2] = st.h[2] + c;\n+        st.h[3] = st.h[3] + d;\n+        st.h[4] = st.h[4] + e;\n         st.msg_block_idx = 0u;\n     }\n     fn circular_shift(bits: u32, word: u32) -> u32 {\n         ret word << bits | word >> 32u32 - bits;\n     }\n     fn mk_result(st: &sha1state) -> [u8] {\n         if !st.computed { pad_msg(st); st.computed = true; }\n-        let rs: [u8] = ~[];\n+        let rs: [u8] = [];\n         for hpart: u32 in st.h {\n             let a = hpart >> 24u32 & 0xFFu32 as u8;\n             let b = hpart >> 16u32 & 0xFFu32 as u8;\n             let c = hpart >> 8u32 & 0xFFu32 as u8;\n             let d = hpart & 0xFFu32 as u8;\n-            rs += ~[a, b, c, d];\n+            rs += [a, b, c, d];\n         }\n         ret rs;\n     }\n@@ -195,31 +193,31 @@ fn mk_sha1() -> sha1 {\n          */\n \n         if st.msg_block_idx > 55u {\n-            st.msg_block.(st.msg_block_idx) = 0x80u8;\n+            st.msg_block[st.msg_block_idx] = 0x80u8;\n             st.msg_block_idx += 1u;\n             while st.msg_block_idx < msg_block_len {\n-                st.msg_block.(st.msg_block_idx) = 0u8;\n+                st.msg_block[st.msg_block_idx] = 0u8;\n                 st.msg_block_idx += 1u;\n             }\n             process_msg_block(st);\n         } else {\n-            st.msg_block.(st.msg_block_idx) = 0x80u8;\n+            st.msg_block[st.msg_block_idx] = 0x80u8;\n             st.msg_block_idx += 1u;\n         }\n         while st.msg_block_idx < 56u {\n-            st.msg_block.(st.msg_block_idx) = 0u8;\n+            st.msg_block[st.msg_block_idx] = 0u8;\n             st.msg_block_idx += 1u;\n         }\n         // Store the message length as the last 8 octets\n \n-        st.msg_block.(56) = st.len_high >> 24u32 & 0xFFu32 as u8;\n-        st.msg_block.(57) = st.len_high >> 16u32 & 0xFFu32 as u8;\n-        st.msg_block.(58) = st.len_high >> 8u32 & 0xFFu32 as u8;\n-        st.msg_block.(59) = st.len_high & 0xFFu32 as u8;\n-        st.msg_block.(60) = st.len_low >> 24u32 & 0xFFu32 as u8;\n-        st.msg_block.(61) = st.len_low >> 16u32 & 0xFFu32 as u8;\n-        st.msg_block.(62) = st.len_low >> 8u32 & 0xFFu32 as u8;\n-        st.msg_block.(63) = st.len_low & 0xFFu32 as u8;\n+        st.msg_block[56] = st.len_high >> 24u32 & 0xFFu32 as u8;\n+        st.msg_block[57] = st.len_high >> 16u32 & 0xFFu32 as u8;\n+        st.msg_block[58] = st.len_high >> 8u32 & 0xFFu32 as u8;\n+        st.msg_block[59] = st.len_high & 0xFFu32 as u8;\n+        st.msg_block[60] = st.len_low >> 24u32 & 0xFFu32 as u8;\n+        st.msg_block[61] = st.len_low >> 16u32 & 0xFFu32 as u8;\n+        st.msg_block[62] = st.len_low >> 8u32 & 0xFFu32 as u8;\n+        st.msg_block[63] = st.len_low & 0xFFu32 as u8;\n         process_msg_block(st);\n     }\n     obj sha1(st: sha1state) {\n@@ -230,11 +228,11 @@ fn mk_sha1() -> sha1 {\n             st.len_low = 0u32;\n             st.len_high = 0u32;\n             st.msg_block_idx = 0u;\n-            st.h.(0) = 0x67452301u32;\n-            st.h.(1) = 0xEFCDAB89u32;\n-            st.h.(2) = 0x98BADCFEu32;\n-            st.h.(3) = 0x10325476u32;\n-            st.h.(4) = 0xC3D2E1F0u32;\n+            st.h[0] = 0x67452301u32;\n+            st.h[1] = 0xEFCDAB89u32;\n+            st.h[2] = 0x98BADCFEu32;\n+            st.h[3] = 0x10325476u32;\n+            st.h[4] = 0xC3D2E1F0u32;\n             st.computed = false;\n         }\n         fn input(msg: &[u8]) { add_input(st, msg); }"}, {"sha": "b506f92a97be9f155fbd29844de5a15807681e7b", "filename": "src/lib/sio.rs", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fsio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fsio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsio.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -7,25 +7,17 @@ import str;\n import net;\n \n type ctx = aio::ctx;\n-type client = { ctx: ctx, client: aio::client,\n-               evt: _port<aio::socket_event> };\n-type server = { ctx: ctx, server: aio::server,\n-               evt: _port<aio::server_event> };\n+type client = {ctx: ctx, client: aio::client, evt: _port<aio::socket_event>};\n+type server = {ctx: ctx, server: aio::server, evt: _port<aio::server_event>};\n \n-fn new() -> ctx {\n-    ret aio::new();\n-}\n+fn new() -> ctx { ret aio::new(); }\n \n-fn destroy(ctx: ctx) {\n-    send(ctx, aio::quit);\n-}\n+fn destroy(ctx: ctx) { send(ctx, aio::quit); }\n \n fn make_socket(ctx: ctx, p: _port<aio::socket_event>) -> client {\n     let evt: aio::socket_event = p.recv();\n     alt evt {\n-      aio::connected(client) {\n-        ret { ctx: ctx, client: client, evt: p };\n-      }\n+      aio::connected(client) { ret {ctx: ctx, client: client, evt: p}; }\n       _ { fail \"Could not connect to client\"; }\n     }\n }\n@@ -38,22 +30,17 @@ fn connect_to(ctx: ctx, ip: net::ip_addr, portnum: int) -> client {\n \n fn read(c: client) -> [u8] {\n     alt c.evt.recv() {\n-        aio::closed. {\n-            ret ~[];\n-        }\n-        aio::received(buf) {\n-            ret buf;\n-        }\n+      aio::closed. { ret []; }\n+      aio::received(buf) { ret buf; }\n     }\n }\n \n fn create_server(ctx: ctx, ip: net::ip_addr, portnum: int) -> server {\n     let evt: _port<aio::server_event> = mk_port();\n     let p: _port<aio::server> = mk_port();\n-    send(ctx, aio::serve(ip, portnum,\n-                         evt.mk_chan(), p.mk_chan()));\n+    send(ctx, aio::serve(ip, portnum, evt.mk_chan(), p.mk_chan()));\n     let srv: aio::server = p.recv();\n-    ret { ctx: ctx, server: srv, evt: evt };\n+    ret {ctx: ctx, server: srv, evt: evt};\n }\n \n fn accept_from(server: server) -> client {\n@@ -85,15 +72,8 @@ fn close_server(server: server) {\n fn close_client(client: client) {\n     send(client.ctx, aio::close_client(client.client));\n     let evt: aio::socket_event;\n-    do {\n-        evt = client.evt.recv();\n-        alt evt {\n-          aio::closed. {\n-            ret;\n-          }\n-          _ {}\n-        }\n-    } while (true);\n+    do  { evt = client.evt.recv(); alt evt { aio::closed. { ret; } _ { } } }\n+        while true\n }\n \n // Local Variables:"}, {"sha": "d5dcd6bcc7829c91f99dfeab308de886cfe90f32", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -10,7 +10,7 @@ import option::some;\n type smallintmap<T> = @{mutable v: [mutable option::t<T>]};\n \n fn mk<@T>() -> smallintmap<T> {\n-    let v: [mutable option::t<T>] = ~[mutable];\n+    let v: [mutable option::t<T>] = [mutable];\n     ret @{mutable v: v};\n }\n \n@@ -19,7 +19,7 @@ fn insert<@T>(m: &smallintmap<T>, key: uint, val: &T) {\n }\n \n fn find<@T>(m: &smallintmap<T>, key: uint) -> option::t<T> {\n-    if key < vec::len::<option::t<T>>(m.v) { ret m.v.(key); }\n+    if key < vec::len::<option::t<T>>(m.v) { ret m.v[key]; }\n     ret none::<T>;\n }\n "}, {"sha": "2a43bde42beef11e8baa5cf5fac226f9e84d80c6", "filename": "src/lib/sort.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -6,20 +6,20 @@ export merge_sort;\n export quick_sort;\n export quick_sort3;\n \n-type lteq<T> = block(&T, &T) -> bool ;\n+type lteq<T> = block(&T, &T) -> bool;\n \n fn merge_sort<@T>(le: &lteq<T>, v: &[T]) -> [T] {\n     fn merge<@T>(le: &lteq<T>, a: &[T], b: &[T]) -> [T] {\n-        let rs: [T] = ~[];\n+        let rs: [T] = [];\n         let a_len: uint = len::<T>(a);\n         let a_ix: uint = 0u;\n         let b_len: uint = len::<T>(b);\n         let b_ix: uint = 0u;\n         while a_ix < a_len && b_ix < b_len {\n-            if le(a.(a_ix), b.(b_ix)) {\n-                rs += ~[a.(a_ix)];\n+            if le(a[a_ix], b[b_ix]) {\n+                rs += [a[a_ix]];\n                 a_ix += 1u;\n-            } else { rs += ~[b.(b_ix)]; b_ix += 1u; }\n+            } else { rs += [b[b_ix]]; b_ix += 1u; }\n         }\n         rs += slice::<T>(a, a_ix, a_len);\n         rs += slice::<T>(b, b_ix, b_len);\n@@ -34,19 +34,19 @@ fn merge_sort<@T>(le: &lteq<T>, v: &[T]) -> [T] {\n }\n \n fn swap<@T>(arr: &[mutable T], x: uint, y: uint) {\n-    let a = arr.(x);\n-    arr.(x) = arr.(y);\n-    arr.(y) = a;\n+    let a = arr[x];\n+    arr[x] = arr[y];\n+    arr[y] = a;\n }\n \n fn part<@T>(compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n             right: uint, pivot: uint) -> uint {\n-    let pivot_value = arr.(pivot);\n+    let pivot_value = arr[pivot];\n     swap::<T>(arr, pivot, right);\n     let storage_index: uint = left;\n     let i: uint = left;\n     while i < right {\n-        if compare_func({ arr.(i) }, pivot_value) {\n+        if compare_func({ arr[i] }, pivot_value) {\n             swap::<T>(arr, i, storage_index);\n             storage_index += 1u;\n         }\n@@ -82,26 +82,26 @@ fn quick_sort<@T>(compare_func: &lteq<T>, arr: &[mutable T]) {\n fn qsort3<@T>(compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n               arr: &[mutable T], left: int, right: int) {\n     if right <= left { ret; }\n-    let v: T = arr.(right);\n+    let v: T = arr[right];\n     let i: int = left - 1;\n     let j: int = right;\n     let p: int = i;\n     let q: int = j;\n     while true {\n         i += 1;\n-        while compare_func_lt({ arr.(i) }, v) { i += 1; }\n+        while compare_func_lt({ arr[i] }, v) { i += 1; }\n         j -= 1;\n-        while compare_func_lt(v, { arr.(j) }) {\n+        while compare_func_lt(v, { arr[j] }) {\n             if j == left { break; }\n             j -= 1;\n         }\n         if i >= j { break; }\n         swap::<T>(arr, i as uint, j as uint);\n-        if compare_func_eq({ arr.(i) }, v) {\n+        if compare_func_eq({ arr[i] }, v) {\n             p += 1;\n             swap::<T>(arr, p as uint, i as uint);\n         }\n-        if compare_func_eq(v, { arr.(j) }) {\n+        if compare_func_eq(v, { arr[j] }) {\n             q -= 1;\n             swap::<T>(arr, j as uint, q as uint);\n         }\n@@ -131,7 +131,7 @@ fn quick_sort3<@T>(compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n                    arr: &[mutable T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, 0,\n-              (len::<T>(arr) as int) - 1);\n+                (len::<T>(arr) as int) - 1);\n }\n \n // Local Variables:"}, {"sha": "98e59f70b4f2b7ad8d5d8f4d6fa7aaabd3029c92", "filename": "src/lib/str.rs", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -73,8 +73,8 @@ fn eq(a: &str, b: &str) -> bool {\n     if byte_len(b) != i { ret false; }\n     while i > 0u {\n         i -= 1u;\n-        let cha = a.(i);\n-        let chb = b.(i);\n+        let cha = a[i];\n+        let chb = b[i];\n         if cha != chb { ret false; }\n     }\n     ret true;\n@@ -87,9 +87,9 @@ fn lteq(a: &str, b: &str) -> bool {\n     if j < n { n = j; }\n     let x: uint = 0u;\n     while x < n {\n-        let cha = a.(x);\n-        let chb = b.(x);\n-        if cha < chb { ret true; } else if (cha > chb) { ret false; }\n+        let cha = a[x];\n+        let chb = b[x];\n+        if cha < chb { ret true; } else if cha > chb { ret false; }\n         x += 1u;\n     }\n     ret i <= j;\n@@ -134,12 +134,12 @@ fn is_utf8(v: &[u8]) -> bool {\n     let i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n-        let chsize = utf8_char_width(v.(i));\n+        let chsize = utf8_char_width(v[i]);\n         if chsize == 0u { ret false; }\n         if i + chsize > total { ret false; }\n         i += 1u;\n         while chsize > 1u {\n-            if v.(i) & 192u8 != tag_cont_u8 { ret false; }\n+            if v[i] & 192u8 != tag_cont_u8 { ret false; }\n             i += 1u;\n             chsize -= 1u;\n         }\n@@ -149,7 +149,7 @@ fn is_utf8(v: &[u8]) -> bool {\n \n fn is_ascii(s: str) -> bool {\n     let i: uint = byte_len(s);\n-    while i > 0u { i -= 1u; if s.(i) & 128u8 != 0u8 { ret false; } }\n+    while i > 0u { i -= 1u; if s[i] & 128u8 != 0u8 { ret false; } }\n     ret true;\n }\n \n@@ -165,9 +165,7 @@ fn is_whitespace(s: str) -> bool {\n     let i = 0u;\n     let len = char_len(s);\n     while i < len {\n-        if !char::is_whitespace(char_at(s, i)) {\n-            ret false;\n-        }\n+        if !char::is_whitespace(char_at(s, i)) { ret false; }\n         i += 1u\n     }\n     ret true;\n@@ -192,7 +190,7 @@ fn unsafe_from_bytes(v: &[mutable? u8]) -> str {\n     ret rustrt::str_from_ivec(v);\n }\n \n-fn unsafe_from_byte(u: u8) -> str { ret rustrt::str_from_ivec(~[u]); }\n+fn unsafe_from_byte(u: u8) -> str { ret rustrt::str_from_ivec([u]); }\n \n fn str_from_cstr(cstr: sbuf) -> str { ret rustrt::str_from_cstr(cstr); }\n \n@@ -204,19 +202,19 @@ fn push_utf8_bytes(s: &mutable str, ch: char) {\n     let code = ch as uint;\n     if code < max_one_b {\n         s = rustrt::str_push_byte(s, code);\n-    } else if (code < max_two_b) {\n+    } else if code < max_two_b {\n         s = rustrt::str_push_byte(s, code >> 6u & 31u | tag_two_b);\n         s = rustrt::str_push_byte(s, code & 63u | tag_cont);\n-    } else if (code < max_three_b) {\n+    } else if code < max_three_b {\n         s = rustrt::str_push_byte(s, code >> 12u & 15u | tag_three_b);\n         s = rustrt::str_push_byte(s, code >> 6u & 63u | tag_cont);\n         s = rustrt::str_push_byte(s, code & 63u | tag_cont);\n-    } else if (code < max_four_b) {\n+    } else if code < max_four_b {\n         s = rustrt::str_push_byte(s, code >> 18u & 7u | tag_four_b);\n         s = rustrt::str_push_byte(s, code >> 12u & 63u | tag_cont);\n         s = rustrt::str_push_byte(s, code >> 6u & 63u | tag_cont);\n         s = rustrt::str_push_byte(s, code & 63u | tag_cont);\n-    } else if (code < max_five_b) {\n+    } else if code < max_five_b {\n         s = rustrt::str_push_byte(s, code >> 24u & 3u | tag_five_b);\n         s = rustrt::str_push_byte(s, code >> 18u & 63u | tag_cont);\n         s = rustrt::str_push_byte(s, code >> 12u & 63u | tag_cont);\n@@ -259,15 +257,15 @@ fn utf8_char_width(b: u8) -> uint {\n }\n \n fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n-    let b0 = s.(i);\n+    let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n     if w == 1u { ret {ch: b0 as char, next: i + 1u}; }\n     let val = 0u;\n     let end = i + w;\n     i += 1u;\n     while i < end {\n-        let byte = s.(i);\n+        let byte = s[i];\n         assert (byte & 192u8 == tag_cont_u8);\n         val <<= 6u;\n         val += byte & 63u8 as uint;\n@@ -288,7 +286,7 @@ fn char_len(s: str) -> uint {\n     let len = 0u;\n     let total = byte_len(s);\n     while i < total {\n-        let chsize = utf8_char_width(s.(i));\n+        let chsize = utf8_char_width(s[i]);\n         assert (chsize > 0u);\n         len += 1u;\n         i += chsize;\n@@ -298,12 +296,12 @@ fn char_len(s: str) -> uint {\n }\n \n fn to_chars(s: str) -> [char] {\n-    let buf: [char] = ~[];\n+    let buf: [char] = [];\n     let i = 0u;\n     let len = byte_len(s);\n     while i < len {\n         let cur = char_range_at(s, i);\n-        buf += ~[cur.ch];\n+        buf += [cur.ch];\n         i = cur.next;\n     }\n     ret buf;\n@@ -313,7 +311,7 @@ fn push_char(s: &mutable str, ch: char) { s += from_char(ch); }\n \n fn pop_char(s: &mutable str) -> char {\n     let end = byte_len(s);\n-    while end > 0u && s.(end - 1u) & 192u8 == tag_cont_u8 { end -= 1u; }\n+    while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n     assert (end > 0u);\n     let ch = char_at(s, end - 1u);\n     s = substr(s, 0u, end - 1u);\n@@ -343,7 +341,7 @@ fn index(s: str, c: u8) -> int {\n \n fn rindex(s: str, c: u8) -> int {\n     let n: int = str::byte_len(s) as int;\n-    while n >= 0 { if s.(n) == c { ret n; } n -= 1; }\n+    while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n     ret n;\n }\n \n@@ -353,7 +351,7 @@ fn find(haystack: str, needle: str) -> int {\n     if needle_len == 0 { ret 0; }\n     fn match_at(haystack: &str, needle: &str, i: int) -> bool {\n         let j: int = i;\n-        for c: u8 in needle { if haystack.(j) != c { ret false; } j += 1; }\n+        for c: u8 in needle { if haystack[j] != c { ret false; } j += 1; }\n         ret true;\n     }\n     let i: int = 0;\n@@ -377,7 +375,7 @@ fn ends_with(haystack: str, needle: str) -> bool {\n     let needle_len: uint = byte_len(needle);\n     ret if needle_len == 0u {\n             true\n-        } else if (needle_len > haystack_len) {\n+        } else if needle_len > haystack_len {\n             false\n         } else {\n             eq(substr(haystack, haystack_len - needle_len, needle_len),\n@@ -397,26 +395,27 @@ fn slice(s: str, begin: uint, end: uint) -> str {\n     ret rustrt::str_slice(s, begin, end);\n }\n \n-fn safe_slice(s: str, begin: uint, end: uint): le(begin, end) -> str {\n+fn safe_slice(s: str, begin: uint, end: uint) : le(begin, end) -> str {\n     assert (end <=\n                 str::byte_len(s)); // would need some magic to\n                                    // make this a precondition\n \n+\n     ret rustrt::str_slice(s, begin, end);\n }\n \n fn shift_byte(s: &mutable str) -> u8 {\n     let len = byte_len(s);\n     assert (len > 0u);\n-    let b = s.(0);\n+    let b = s[0];\n     s = substr(s, 1u, len - 1u);\n     ret b;\n }\n \n fn pop_byte(s: &mutable str) -> u8 {\n     let len = byte_len(s);\n     assert (len > 0u);\n-    let b = s.(len - 1u);\n+    let b = s[len - 1u];\n     s = substr(s, 0u, len - 1u);\n     ret b;\n }\n@@ -433,17 +432,17 @@ fn unshift_byte(s: &mutable str, b: u8) {\n }\n \n fn split(s: str, sep: u8) -> [str] {\n-    let v: [str] = ~[];\n+    let v: [str] = [];\n     let accum: str = \"\";\n     let ends_with_sep: bool = false;\n     for c: u8 in s {\n         if c == sep {\n-            v += ~[accum];\n+            v += [accum];\n             accum = \"\";\n             ends_with_sep = true;\n         } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n     }\n-    if str::byte_len(accum) != 0u || ends_with_sep { v += ~[accum]; }\n+    if str::byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n     ret v;\n }\n \n@@ -486,10 +485,10 @@ fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str {\n     check (is_not_empty(from));\n     if byte_len(s) == 0u {\n         ret \"\";\n-    } else if (starts_with(s, from)) {\n+    } else if starts_with(s, from) {\n         ret to + replace(slice(s, byte_len(from), byte_len(s)), from, to);\n     } else {\n-        ret unsafe_from_byte(s.(0)) +\n+        ret unsafe_from_byte(s[0]) +\n                 replace(slice(s, 1u, byte_len(s)), from, to);\n     }\n }\n@@ -503,9 +502,7 @@ fn trim_left(s: &str) -> str {\n     fn count_whities(s: &[char]) -> uint {\n         let i = 0u;\n         while i < vec::len(s) {\n-            if !char::is_whitespace(s.(i)) {\n-                break;\n-            }\n+            if !char::is_whitespace(s[i]) { break; }\n             i += 1u;\n         }\n         ret i;\n@@ -519,9 +516,7 @@ fn trim_right(s: &str) -> str {\n     fn count_whities(s: &[char]) -> uint {\n         let i = vec::len(s);\n         while 0u < i {\n-            if !char::is_whitespace(s.(i - 1u)) {\n-                break;\n-            }\n+            if !char::is_whitespace(s[i - 1u]) { break; }\n             i -= 1u;\n         }\n         ret i;\n@@ -531,9 +526,7 @@ fn trim_right(s: &str) -> str {\n     ret from_chars(vec::slice(chars, 0u, whities));\n }\n \n-fn trim(s: &str) -> str {\n-    trim_left(trim_right(s))\n-}\n+fn trim(s: &str) -> str { trim_left(trim_right(s)) }\n \n // Local Variables:\n // mode: rust;"}, {"sha": "fd971b274770baec420ceaed059438cc4363caa3", "filename": "src/lib/task.rs", "status": "modified", "additions": 64, "deletions": 82, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -19,43 +19,35 @@ native \"rust\" mod rustrt {\n     fn set_min_stack(stack_size: uint);\n \n     fn new_task() -> task_id;\n-    fn drop_task(task : *rust_task);\n-    fn get_task_pointer(id : task_id) -> *rust_task;\n-    fn start_task(id : task_id);\n+    fn drop_task(task: *rust_task);\n+    fn get_task_pointer(id: task_id) -> *rust_task;\n+    fn start_task(id: task_id);\n     fn get_task_trampoline() -> u32;\n \n-    fn migrate_alloc(alloc : *u8, target : task_id);\n+    fn migrate_alloc(alloc: *u8, target: task_id);\n \n-    fn leak<@T>(thing : -T);\n+    fn leak<@T>(thing: -T);\n }\n \n-type rust_task = {\n-    id : task,\n-    mutable notify_enabled : u8,\n-    mutable notify_chan : comm::chan_handle<task_notification>,\n-    ctx : task_context,\n-    stack_ptr : *u8\n-};\n-\n-type task_context = {\n-    regs : x86_registers,\n-    next : *u8\n-};\n-\n-resource rust_task_ptr(task : *rust_task) {\n-    rustrt::drop_task(task);\n-}\n+type rust_task =\n+    {id: task,\n+     mutable notify_enabled: u8,\n+     mutable notify_chan: comm::chan_handle<task_notification>,\n+     ctx: task_context,\n+     stack_ptr: *u8};\n+\n+type task_context = {regs: x86_registers, next: *u8};\n+\n+resource rust_task_ptr(task: *rust_task) { rustrt::drop_task(task); }\n \n-fn get_task_ptr(id : task) -> rust_task_ptr {\n+fn get_task_ptr(id: task) -> rust_task_ptr {\n     ret rust_task_ptr(rustrt::get_task_pointer(id));\n }\n \n type task = int;\n type task_id = task;\n \n-fn get_task_id() -> task_id {\n-    rustrt::get_task_id()\n-}\n+fn get_task_id() -> task_id { rustrt::get_task_id() }\n \n /**\n  * Hints the scheduler to yield this task for a specified ammount of time.\n@@ -68,22 +60,20 @@ fn yield() { ret rustrt::task_yield(); }\n \n tag task_result { tr_success; tr_failure; }\n \n-tag task_notification {\n-    exit(task, task_result);\n-}\n+tag task_notification { exit(task, task_result); }\n \n-fn join(task_port : (task_id, comm::port<task_notification>))\n-    -> task_result {\n+fn join(task_port: (task_id, comm::port<task_notification>)) -> task_result {\n     let (id, port) = task_port;\n     alt comm::recv::<task_notification>(port) {\n       exit(_id, res) {\n-        if _id == id { ret res }\n-        else { fail #fmt(\"join received id %d, expected %d\", _id, id) }\n+        if _id == id {\n+            ret res\n+        } else { fail #fmt[\"join received id %d, expected %d\", _id, id] }\n       }\n     }\n }\n \n-fn join_id(t : task_id) -> task_result {\n+fn join_id(t: task_id) -> task_result {\n     alt rustrt::task_join(t) { 0 { tr_success } _ { tr_failure } }\n }\n \n@@ -93,33 +83,25 @@ fn pin() { rustrt::pin_task(); }\n \n fn unpin() { rustrt::unpin_task(); }\n \n-fn set_min_stack(stack_size : uint) {\n-    rustrt::set_min_stack(stack_size);\n-}\n+fn set_min_stack(stack_size: uint) { rustrt::set_min_stack(stack_size); }\n \n-fn _spawn(thunk : -fn() -> ()) -> task {\n-    spawn(thunk)\n-}\n+fn _spawn(thunk: -fn()) -> task { spawn(thunk) }\n \n-fn spawn(thunk : -fn() -> ()) -> task {\n-    spawn_inner(thunk, none)\n-}\n+fn spawn(thunk: -fn()) -> task { spawn_inner(thunk, none) }\n \n-fn spawn_notify(thunk : -fn() -> (), notify : comm::chan<task_notification>)\n-    -> task {\n+fn spawn_notify(thunk: -fn(), notify: comm::chan<task_notification>) -> task {\n     spawn_inner(thunk, some(notify))\n }\n \n-fn spawn_joinable(thunk : -fn()) -> (task_id, comm::port<task_notification>) {\n+fn spawn_joinable(thunk: -fn()) -> (task_id, comm::port<task_notification>) {\n     let p = comm::port::<task_notification>();\n     let id = spawn_notify(thunk, comm::chan::<task_notification>(p));\n     ret (id, p);\n }\n \n // FIXME: make this a fn~ once those are supported.\n-fn spawn_inner(thunk : -fn() -> (),\n-               notify : option<comm::chan<task_notification>>)\n-    -> task_id {\n+fn spawn_inner(thunk: -fn(), notify: option<comm::chan<task_notification>>) ->\n+   task_id {\n     let id = rustrt::new_task();\n \n     // the order of arguments are outptr, taskptr, envptr.\n@@ -129,21 +111,21 @@ fn spawn_inner(thunk : -fn() -> (),\n     // set up the task pointer\n     let task_ptr = get_task_ptr(id);\n     let regs = ptr::addr_of((**task_ptr).ctx.regs);\n-    (*regs).edx = cast(*task_ptr);\n+    (*regs).edx = cast(*task_ptr);;\n     (*regs).esp = cast((**task_ptr).stack_ptr);\n \n-    assert ptr::null() != (**task_ptr).stack_ptr;\n+    assert (ptr::null() != (**task_ptr).stack_ptr);\n \n-    let raw_thunk : { code: u32, env: u32 } = cast(thunk);\n+    let raw_thunk: {code: u32, env: u32} = cast(thunk);\n     (*regs).eip = raw_thunk.code;\n \n     // set up notifications if they are enabled.\n     alt notify {\n       some(c) {\n-        (**task_ptr).notify_enabled = 1u8;\n+        (**task_ptr).notify_enabled = 1u8;;\n         (**task_ptr).notify_chan = *c;\n       }\n-      none {}\n+      none { }\n     };\n \n     // okay, now we align the stack and add the environment pointer and a fake\n@@ -153,15 +135,15 @@ fn spawn_inner(thunk : -fn() -> (),\n     // -4 for the return address.\n     (*regs).esp = align_down((*regs).esp - 12u32) - 4u32;\n \n-    let ra : *mutable u32 = cast((*regs).esp);\n-    let env : *mutable u32 = cast((*regs).esp+4u32);\n-    let tptr : *mutable u32 = cast((*regs).esp+12u32);\n+    let ra: *mutable u32 = cast((*regs).esp);\n+    let env: *mutable u32 = cast((*regs).esp + 4u32);\n+    let tptr: *mutable u32 = cast((*regs).esp + 12u32);\n \n     // put the return pointer in ecx.\n-    (*regs).ecx = (*regs).esp + 8u32;\n+    (*regs).ecx = (*regs).esp + 8u32;;\n \n-    *tptr = cast(*task_ptr);\n-    *env = raw_thunk.env;\n+    *tptr = cast(*task_ptr);;\n+    *env = raw_thunk.env;;\n     *ra = rustrt::get_task_trampoline();\n \n     rustrt::migrate_alloc(cast(raw_thunk.env), id);\n@@ -173,31 +155,31 @@ fn spawn_inner(thunk : -fn() -> (),\n }\n \n // Who says we can't write an operating system in Rust?\n-type x86_registers = {\n+type x86_registers =\n     // This needs to match the structure in context.h\n-    mutable eax : u32,\n-    mutable ebx : u32,\n-    mutable ecx : u32,\n-    mutable edx : u32,\n-    mutable ebp : u32,\n-    mutable esi : u32,\n-    mutable edi : u32,\n-    mutable esp : u32,\n-\n-    mutable cs : u16,\n-    mutable ds : u16,\n-    mutable ss : u16,\n-    mutable es : u16,\n-    mutable fs : u16,\n-    mutable gs : u16,\n-\n-    mutable eflags : u32,\n-    mutable eip : u32\n-};\n-\n-fn align_down(x : u32) -> u32 {\n+\n+\n+    {mutable eax: u32,\n+     mutable ebx: u32,\n+     mutable ecx: u32,\n+     mutable edx: u32,\n+     mutable ebp: u32,\n+     mutable esi: u32,\n+     mutable edi: u32,\n+     mutable esp: u32,\n+     mutable cs: u16,\n+     mutable ds: u16,\n+     mutable ss: u16,\n+     mutable es: u16,\n+     mutable fs: u16,\n+     mutable gs: u16,\n+     mutable eflags: u32,\n+     mutable eip: u32};\n+\n+fn align_down(x: u32) -> u32 {\n+\n     // Aligns x down to 16 bytes\n-    x & !(15u32)\n+    x & !15u32\n }\n \n // Local Variables:"}, {"sha": "cfec5ff6b8feb96947542cbdf24e549be02d2b3b", "filename": "src/lib/term.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fterm.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -40,15 +40,15 @@ const color_bright_cyan: u8 = 14u8;\n \n const color_bright_white: u8 = 15u8;\n \n-fn esc(writer: io::buf_writer) { writer.write(~[0x1bu8, '[' as u8]); }\n+fn esc(writer: io::buf_writer) { writer.write([0x1bu8, '[' as u8]); }\n \n fn reset(writer: io::buf_writer) {\n     esc(writer);\n-    writer.write(~['0' as u8, 'm' as u8]);\n+    writer.write(['0' as u8, 'm' as u8]);\n }\n \n fn color_supported() -> bool {\n-    let supported_terms = ~[\"xterm-color\", \"xterm\", \"screen-bce\"];\n+    let supported_terms = [\"xterm-color\", \"xterm\", \"screen-bce\"];\n     ret alt generic_os::getenv(\"TERM\") {\n           option::some(env) {\n             for term: str in supported_terms {\n@@ -63,8 +63,8 @@ fn color_supported() -> bool {\n fn set_color(writer: io::buf_writer, first_char: u8, color: u8) {\n     assert (color < 16u8);\n     esc(writer);\n-    if color >= 8u8 { writer.write(~['1' as u8, ';' as u8]); color -= 8u8; }\n-    writer.write(~[first_char, ('0' as u8) + color, 'm' as u8]);\n+    if color >= 8u8 { writer.write(['1' as u8, ';' as u8]); color -= 8u8; }\n+    writer.write([first_char, ('0' as u8) + color, 'm' as u8]);\n }\n \n fn fg(writer: io::buf_writer, color: u8) {"}, {"sha": "72e5eb755970e5af242fc4022488ba1868d33679", "filename": "src/lib/test.rs", "status": "modified", "additions": 44, "deletions": 58, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -41,7 +41,7 @@ type test_name = str;\n // the test succeeds; if the function fails then the test fails. We\n // may need to come up with a more clever definition of test in order\n // to support isolation of tests into tasks.\n-type test_fn = fn() ;\n+type test_fn = fn();\n \n // The definition of a single test. A test runner will run a list of\n // these.\n@@ -69,7 +69,7 @@ fn parse_opts(args: &[str]) : vec::is_not_empty(args) -> opt_res {\n     // FIXME (#649): Shouldn't have to check here\n     check (vec::is_not_empty(args));\n     let args_ = vec::tail(args);\n-    let opts = ~[getopts::optflag(\"ignored\")];\n+    let opts = [getopts::optflag(\"ignored\")];\n     let match =\n         alt getopts::getopts(args_, opts) {\n           getopts::success(m) { m }\n@@ -78,7 +78,7 @@ fn parse_opts(args: &[str]) : vec::is_not_empty(args) -> opt_res {\n \n     let filter =\n         if vec::len(match.free) > 0u {\n-            option::some(match.free.(0))\n+            option::some(match.free[0])\n         } else { option::none };\n \n     let run_ignored = getopts::opt_present(match, \"ignored\");\n@@ -106,25 +106,22 @@ fn run_tests_console(opts: &test_opts, tests: &[test_desc]) -> bool {\n fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n                       to_task: &test_to_task) -> bool {\n \n-    type test_state = @{\n-        out: io::writer,\n-        use_color: bool,\n-        mutable total: uint,\n-        mutable passed: uint,\n-        mutable failed: uint,\n-        mutable ignored: uint,\n-        mutable failures: [test_desc]\n-    };\n+    type test_state =\n+        @{out: io::writer,\n+          use_color: bool,\n+          mutable total: uint,\n+          mutable passed: uint,\n+          mutable failed: uint,\n+          mutable ignored: uint,\n+          mutable failures: [test_desc]};\n \n     fn callback(event: testevent, st: test_state) {\n         alt event {\n           te_filtered(filtered_tests) {\n             st.total = vec::len(filtered_tests);\n-            st.out.write_line(#fmt(\"\\nrunning %u tests\", st.total));\n-          }\n-          te_wait(test) {\n-            st.out.write_str(#fmt(\"test %s ... \", test.name));\n+            st.out.write_line(#fmt[\"\\nrunning %u tests\", st.total]);\n           }\n+          te_wait(test) { st.out.write_str(#fmt[\"test %s ... \", test.name]); }\n           te_result(test, result) {\n             alt result {\n               tr_ok. {\n@@ -136,7 +133,7 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(\"\");\n-                st.failures += ~[test];\n+                st.failures += [test];\n               }\n               tr_ignored. {\n                 st.ignored += 1u;\n@@ -148,37 +145,35 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n         }\n     }\n \n-    let st = @{\n-        out: io::stdout(),\n-        use_color: use_color(),\n-        mutable total: 0u,\n-        mutable passed: 0u,\n-        mutable failed: 0u,\n-        mutable ignored: 0u,\n-        mutable failures: ~[]\n-    };\n+    let st =\n+        @{out: io::stdout(),\n+          use_color: use_color(),\n+          mutable total: 0u,\n+          mutable passed: 0u,\n+          mutable failed: 0u,\n+          mutable ignored: 0u,\n+          mutable failures: []};\n \n-    run_tests(opts, tests, to_task,\n-              bind callback(_, st));\n+    run_tests(opts, tests, to_task, bind callback(_, st));\n \n-    assert st.passed + st.failed + st.ignored == st.total;\n+    assert (st.passed + st.failed + st.ignored == st.total);\n     let success = st.failed == 0u;\n \n     if !success {\n         st.out.write_line(\"\\nfailures:\");\n         for test: test_desc in st.failures {\n             let testname = test.name; // Satisfy alias analysis\n-            st.out.write_line(#fmt(\"    %s\", testname));\n+            st.out.write_line(#fmt[\"    %s\", testname]);\n         }\n     }\n \n-    st.out.write_str(#fmt(\"\\nresult: \"));\n+    st.out.write_str(#fmt[\"\\nresult: \"]);\n     if success {\n         // There's no parallelism at this point so it's safe to use color\n         write_ok(st.out, true);\n     } else { write_failed(st.out, true); }\n-    st.out.write_str(#fmt(\". %u passed; %u failed; %u ignored\\n\\n\",\n-                       st.passed, st.failed, st.ignored));\n+    st.out.write_str(#fmt[\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n+                          st.failed, st.ignored]);\n \n     ret success;\n \n@@ -206,18 +201,16 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n     }\n }\n \n-fn use_color() -> bool {\n-    ret get_concurrency() == 1u;\n-}\n+fn use_color() -> bool { ret get_concurrency() == 1u; }\n \n tag testevent {\n     te_filtered([test_desc]);\n     te_wait(test_desc);\n     te_result(test_desc, test_result);\n }\n \n-fn run_tests(opts: &test_opts, tests: &[test_desc],\n-             to_task: &test_to_task, callback: fn(testevent)) {\n+fn run_tests(opts: &test_opts, tests: &[test_desc], to_task: &test_to_task,\n+             callback: fn(testevent)) {\n \n     let filtered_tests = filter_tests(opts, tests);\n \n@@ -227,19 +220,19 @@ fn run_tests(opts: &test_opts, tests: &[test_desc],\n     // provide a great user experience because you might sit waiting for the\n     // result of a particular test for an unusually long amount of time.\n     let concurrency = get_concurrency();\n-    log #fmt(\"using %u test tasks\", concurrency);\n+    log #fmt[\"using %u test tasks\", concurrency];\n     let total = vec::len(filtered_tests);\n     let run_idx = 0u;\n     let wait_idx = 0u;\n-    let futures = ~[];\n+    let futures = [];\n \n     while wait_idx < total {\n         while vec::len(futures) < concurrency && run_idx < total {\n-            futures += ~[run_test(filtered_tests.(run_idx), to_task)];\n+            futures += [run_test(filtered_tests[run_idx], to_task)];\n             run_idx += 1u;\n         }\n \n-        let future = futures.(0);\n+        let future = futures[0];\n         callback(te_wait(future.test));\n         let result = future.wait();\n         callback(te_result(future.test, result));\n@@ -306,33 +299,26 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n     ret filtered;\n }\n \n-type test_future =\n-    {test: test_desc, wait: fn() -> test_result };\n+type test_future = {test: test_desc, wait: fn() -> test_result};\n \n fn run_test(test: &test_desc, to_task: &test_to_task) -> test_future {\n     if !test.ignore {\n         let test_task = to_task(test.fn);\n         ret {test: test,\n              wait:\n-             bind fn (test_task: joinable)-> test_result {\n-                 alt task::join(test_task) {\n-                   task::tr_success. { tr_ok }\n-                   task::tr_failure. { tr_failed }\n-                 }\n-             }(test_task)};\n-    } else {\n-        ret {test: test,\n-             wait: fn () -> test_result { tr_ignored }};\n-    }\n+                 bind fn (test_task: joinable) -> test_result {\n+                          alt task::join(test_task) {\n+                            task::tr_success. { tr_ok }\n+                            task::tr_failure. { tr_failed }\n+                          }\n+                      }(test_task)};\n+    } else { ret {test: test, wait: fn () -> test_result { tr_ignored }}; }\n }\n \n // We need to run our tests in another task in order to trap test failures.\n // This function only works with functions that don't contain closures.\n fn default_test_to_task(f: &fn()) -> joinable {\n-    fn run_task(f: fn()) {\n-        configure_test_task();\n-        f();\n-    }\n+    fn run_task(f: fn()) { configure_test_task(); f(); }\n     ret task::spawn_joinable(bind run_task(f));\n }\n "}, {"sha": "c92bdb61f304bc2a3bb1c35fbec8c87a7e98d875", "filename": "src/lib/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftime.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -18,4 +18,4 @@ fn precise_time_ns() -> u64 { let ns = 0u64; rustrt::nano_time(ns); ret ns; }\n \n fn precise_time_s() -> float {\n     ret (precise_time_ns() as float) / 1000000000.;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "8082f7aef0d527805ca31c647bb53c8ccfc096fe", "filename": "src/lib/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fu64.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -33,4 +33,4 @@ fn to_str(n: u64, radix: uint) -> str {\n     ret s;\n }\n \n-fn str(n: u64) -> str { ret to_str(n, 10u); }\n\\ No newline at end of file\n+fn str(n: u64) -> str { ret to_str(n, 10u); }"}, {"sha": "f225a2a7ca3c0fb8585e17c1d400d88beea5db2b", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -10,11 +10,11 @@ type node = option::t<uint>;\n \n type ufind = {mutable nodes: [mutable node]};\n \n-fn make() -> ufind { ret {mutable nodes: ~[mutable]}; }\n+fn make() -> ufind { ret {mutable nodes: [mutable]}; }\n \n fn make_set(ufnd: &ufind) -> uint {\n     let idx = vec::len(ufnd.nodes);\n-    ufnd.nodes += ~[mutable none::<uint>];\n+    ufnd.nodes += [mutable none::<uint>];\n     ret idx;\n }\n \n@@ -26,7 +26,7 @@ fn grow(ufnd: &ufind, n: uint) {\n }\n \n fn find(ufnd: &ufind, n: uint) -> uint {\n-    alt ufnd.nodes.(n) {\n+    alt ufnd.nodes[n] {\n       none. { ret n; }\n       some(m) { let m_ = m; be find(ufnd, m_); }\n     }\n@@ -36,10 +36,8 @@ fn union(ufnd: &ufind, m: uint, n: uint) {\n     let m_root = find(ufnd, m);\n     let n_root = find(ufnd, n);\n     if m_root < n_root {\n-        ufnd.nodes.(n_root) = some::<uint>(m_root);\n-    } else if (m_root > n_root) {\n-        ufnd.nodes.(m_root) = some::<uint>(n_root);\n-    }\n+        ufnd.nodes[n_root] = some::<uint>(m_root);\n+    } else if m_root > n_root { ufnd.nodes[m_root] = some::<uint>(n_root); }\n }\n \n fn set_count(ufnd: &ufind) -> uint { ret vec::len::<node>(ufnd.nodes); }"}, {"sha": "94517b29f2784ef0fe444392edcbcd3fd4185ceb", "filename": "src/lib/uint.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -51,17 +51,15 @@ fn parse_buf(buf: &[u8], radix: uint) -> uint {\n     let power = 1u;\n     let n = 0u;\n     while true {\n-        n += (buf.(i) - ('0' as u8) as uint) * power;\n+        n += (buf[i] - ('0' as u8) as uint) * power;\n         power *= radix;\n         if i == 0u { ret n; }\n         i -= 1u;\n     }\n     fail;\n }\n \n-fn from_str(s : &str) -> uint {\n-    parse_buf(str::bytes(s), 10u)\n-}\n+fn from_str(s: &str) -> uint { parse_buf(str::bytes(s), 10u) }\n \n fn to_str(num: uint, radix: uint) -> str {\n     let n = num;\n@@ -95,7 +93,7 @@ fn to_str(num: uint, radix: uint) -> str {\n     }\n     let s1: str = \"\";\n     let len: uint = str::byte_len(s);\n-    while len != 0u { len -= 1u; s1 += str::unsafe_from_byte(s.(len)); }\n+    while len != 0u { len -= 1u; s1 += str::unsafe_from_byte(s[len]); }\n     ret s1;\n }\n fn str(i: uint) -> str { ret to_str(i, 10u); }"}, {"sha": "dde4fc7505bf9973a8c9268f128779ad61bd9c74", "filename": "src/lib/vec.rs", "status": "modified", "additions": 51, "deletions": 58, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -28,51 +28,51 @@ fn to_ptr<T>(v: &[T]) -> *T { ret rustrt::ivec_to_ptr(v); }\n \n fn len<T>(v: &[mutable? T]) -> uint { ret rusti::ivec_len(v); }\n \n-type init_op<T> = fn(uint) -> T ;\n+type init_op<T> = fn(uint) -> T;\n \n fn init_fn<@T>(op: &init_op<T>, n_elts: uint) -> [T] {\n-    let v = ~[];\n+    let v = [];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n-    while i < n_elts { v += ~[op(i)]; i += 1u; }\n+    while i < n_elts { v += [op(i)]; i += 1u; }\n     ret v;\n }\n \n // TODO: Remove me once we have slots.\n fn init_fn_mut<@T>(op: &init_op<T>, n_elts: uint) -> [mutable T] {\n-    let v = ~[mutable];\n+    let v = [mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n-    while i < n_elts { v += ~[mutable op(i)]; i += 1u; }\n+    while i < n_elts { v += [mutable op(i)]; i += 1u; }\n     ret v;\n }\n \n fn init_elt<@T>(t: &T, n_elts: uint) -> [T] {\n-    let v = ~[];\n+    let v = [];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n-    while i < n_elts { v += ~[t]; i += 1u; }\n+    while i < n_elts { v += [t]; i += 1u; }\n     ret v;\n }\n \n // TODO: Remove me once we have slots.\n fn init_elt_mut<@T>(t: &T, n_elts: uint) -> [mutable T] {\n-    let v = ~[mutable];\n+    let v = [mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n-    while i < n_elts { v += ~[mutable t]; i += 1u; }\n+    while i < n_elts { v += [mutable t]; i += 1u; }\n     ret v;\n }\n \n fn to_mut<@T>(v: &[T]) -> [mutable T] {\n-    let vres = ~[mutable];\n-    for t: T in v { vres += ~[mutable t]; }\n+    let vres = [mutable];\n+    for t: T in v { vres += [mutable t]; }\n     ret vres;\n }\n \n fn from_mut<@T>(v: &[mutable T]) -> [T] {\n-    let vres = ~[];\n-    for t: T in v { vres += ~[t]; }\n+    let vres = [];\n+    for t: T in v { vres += [t]; }\n     ret vres;\n }\n \n@@ -88,7 +88,7 @@ pred is_not_empty<T>(v: &[mutable? T]) -> bool { ret !is_empty(v); }\n // Accessors\n \n /// Returns the first element of a vector\n-fn head<@T>(v: &[mutable? T]) : is_not_empty(v) -> T { ret v.(0); }\n+fn head<@T>(v: &[mutable? T]) : is_not_empty(v) -> T { ret v[0]; }\n \n /// Returns all but the first element of a vector\n fn tail<@T>(v: &[mutable? T]) : is_not_empty(v) -> [mutable? T] {\n@@ -98,28 +98,28 @@ fn tail<@T>(v: &[mutable? T]) : is_not_empty(v) -> [mutable? T] {\n /// Returns the last element of `v`.\n fn last<@T>(v: &[mutable? T]) -> option::t<T> {\n     if len(v) == 0u { ret none; }\n-    ret some(v.(len(v) - 1u));\n+    ret some(v[len(v) - 1u]);\n }\n \n /// Returns a copy of the elements from [`start`..`end`) from `v`.\n fn slice<@T>(v: &[mutable? T], start: uint, end: uint) -> [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n-    let result = ~[];\n+    let result = [];\n     reserve(result, end - start);\n     let i = start;\n-    while i < end { result += ~[v.(i)]; i += 1u; }\n+    while i < end { result += [v[i]]; i += 1u; }\n     ret result;\n }\n \n // TODO: Remove me once we have slots.\n fn slice_mut<@T>(v: &[mutable? T], start: uint, end: uint) -> [mutable T] {\n     assert (start <= end);\n     assert (end <= len(v));\n-    let result = ~[mutable];\n+    let result = [mutable];\n     reserve(result, end - start);\n     let i = start;\n-    while i < end { result += ~[mutable v.(i)]; i += 1u; }\n+    while i < end { result += [mutable v[i]]; i += 1u; }\n     ret result;\n }\n \n@@ -129,7 +129,7 @@ fn slice_mut<@T>(v: &[mutable? T], start: uint, end: uint) -> [mutable T] {\n fn shift<@T>(v: &mutable [mutable? T]) -> T {\n     let ln = len::<T>(v);\n     assert (ln > 0u);\n-    let e = v.(0);\n+    let e = v[0];\n     v = slice::<T>(v, 1u, ln);\n     ret e;\n }\n@@ -139,7 +139,7 @@ fn pop<@T>(v: &mutable [mutable? T]) -> T {\n     let ln = len(v);\n     assert (ln > 0u);\n     ln -= 1u;\n-    let e = v.(ln);\n+    let e = v[ln];\n     v = slice(v, 0u, ln);\n     ret e;\n }\n@@ -153,72 +153,71 @@ fn pop<@T>(v: &mutable [mutable? T]) -> T {\n fn grow<@T>(v: &mutable [T], n: uint, initval: &T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n-    while i < n { v += ~[initval]; i += 1u; }\n+    while i < n { v += [initval]; i += 1u; }\n }\n \n // TODO: Remove me once we have slots.\n fn grow_mut<@T>(v: &mutable [mutable T], n: uint, initval: &T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n-    while i < n { v += ~[mutable initval]; i += 1u; }\n+    while i < n { v += [mutable initval]; i += 1u; }\n }\n \n /// Calls `f` `n` times and appends the results of these calls to the given\n /// vector.\n-fn grow_fn<@T>(v: &mutable [T], n: uint, init_fn: fn(uint) -> T ) {\n+fn grow_fn<@T>(v: &mutable [T], n: uint, init_fn: fn(uint) -> T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n-    while i < n { v += ~[init_fn(i)]; i += 1u; }\n+    while i < n { v += [init_fn(i)]; i += 1u; }\n }\n \n /// Sets the element at position `index` to `val`. If `index` is past the end\n /// of the vector, expands the vector by replicating `initval` to fill the\n /// intervening space.\n fn grow_set<@T>(v: &mutable [mutable T], index: uint, initval: &T, val: &T) {\n     if index >= len(v) { grow_mut(v, index - len(v) + 1u, initval); }\n-    v.(index) = val;\n+    v[index] = val;\n }\n \n \n // Functional utilities\n \n-fn map<@T, @U>(f: &block(&T) -> U , v: &[mutable? T]) -> [U] {\n-    let result = ~[];\n+fn map<@T, @U>(f: &block(&T) -> U, v: &[mutable? T]) -> [U] {\n+    let result = [];\n     reserve(result, len(v));\n     for elem: T in v {\n         let elem2 = elem; // satisfies alias checker\n-        result += ~[f(elem2)];\n+        result += [f(elem2)];\n     }\n     ret result;\n }\n \n-fn map2<@T, @U, @V>(f: &block(&T, &U) -> V, v0: &[T], v1: &[U])\n-    -> [V] {\n+fn map2<@T, @U, @V>(f: &block(&T, &U) -> V, v0: &[T], v1: &[U]) -> [V] {\n     let v0_len = len::<T>(v0);\n     if v0_len != len::<U>(v1) { fail; }\n-    let u: [V] = ~[];\n+    let u: [V] = [];\n     let i = 0u;\n-    while i < v0_len { u += ~[f({ v0.(i) }, { v1.(i) })]; i += 1u; }\n+    while i < v0_len { u += [f({ v0[i] }, { v1[i] })]; i += 1u; }\n     ret u;\n }\n \n-fn filter_map<@T, @U>(f: &block(&T) -> option::t<U>,\n-                      v: &[mutable? T]) -> [U] {\n-    let result = ~[];\n+fn filter_map<@T, @U>(f: &block(&T) -> option::t<U>, v: &[mutable? T]) ->\n+   [U] {\n+    let result = [];\n     for elem: T in v {\n         let elem2 = elem; // satisfies alias checker\n         alt f(elem2) {\n           none. {/* no-op */ }\n-          some(result_elem) { result += ~[result_elem]; }\n+          some(result_elem) { result += [result_elem]; }\n         }\n     }\n     ret result;\n }\n \n-fn foldl<@T, @U>(p: &block(&U, &T) -> U , z: &U, v: &[mutable? T]) -> U {\n+fn foldl<@T, @U>(p: &block(&U, &T) -> U, z: &U, v: &[mutable? T]) -> U {\n     let sz = len(v);\n     if sz == 0u { ret z; }\n-    let first = v.(0);\n+    let first = v[0];\n     let rest = slice(v, 1u, sz);\n     ret p(foldl(p, z, rest), first);\n }\n@@ -251,42 +250,36 @@ fn find<@T>(f: &block(&T) -> bool, v: &[T]) -> option::t<T> {\n \n fn position<@T>(x: &T, v: &[T]) -> option::t<uint> {\n     let i: uint = 0u;\n-    while i < len(v) { if x == v.(i) { ret some::<uint>(i); } i += 1u; }\n+    while i < len(v) { if x == v[i] { ret some::<uint>(i); } i += 1u; }\n     ret none;\n }\n \n fn position_pred<T>(f: fn(&T) -> bool, v: &[T]) -> option::t<uint> {\n     let i: uint = 0u;\n-    while i < len(v) { if f(v.(i)) { ret some::<uint>(i); } i += 1u; }\n+    while i < len(v) { if f(v[i]) { ret some::<uint>(i); } i += 1u; }\n     ret none;\n }\n \n fn unzip<@T, @U>(v: &[(T, U)]) -> ([T], [U]) {\n-    let as = ~[], bs = ~[];\n-    for (a, b) in v {\n-        as += ~[a];\n-        bs += ~[b];\n-    }\n+    let as = [], bs = [];\n+    for (a, b) in v { as += [a]; bs += [b]; }\n     ret (as, bs);\n }\n \n // FIXME make the lengths being equal a constraint\n fn zip<@T, @U>(v: &[T], u: &[U]) -> [(T, U)] {\n-    let zipped = ~[];\n+    let zipped = [];\n     let sz = len(v), i = 0u;\n     assert (sz == len(u));\n-    while i < sz {\n-        zipped += ~[(v.(i), u.(i))];\n-        i += 1u;\n-    }\n+    while i < sz { zipped += [(v[i], u[i])]; i += 1u; }\n     ret zipped;\n }\n \n // Swaps two elements in a vector\n fn swap<@T>(v: &[mutable T], a: uint, b: uint) {\n-    let t: T = v.(a);\n-    v.(a) = v.(b);\n-    v.(b) = t;\n+    let t: T = v[a];\n+    v[a] = v[b];\n+    v[b] = t;\n }\n \n // In place vector reversal\n@@ -299,11 +292,11 @@ fn reverse<@T>(v: &[mutable T]) {\n \n // Functional vector reversal. Returns a reversed copy of v.\n fn reversed<@T>(v: &[T]) -> [T] {\n-    let rs: [T] = ~[];\n+    let rs: [T] = [];\n     let i = len::<T>(v);\n     if i == 0u { ret rs; } else { i -= 1u; }\n-    while i != 0u { rs += ~[v.(i)]; i -= 1u; }\n-    rs += ~[v.(0)];\n+    while i != 0u { rs += [v[i]]; i -= 1u; }\n+    rs += [v[0]];\n     ret rs;\n }\n \n@@ -328,7 +321,7 @@ mod unsafe {\n     }\n \n     fn from_buf<T>(ptr: *T, bytes: uint) -> [T] {\n-        let v = ~[];\n+        let v = [];\n         copy_from_buf(v, ptr, bytes);\n         ret v;\n     }"}, {"sha": "5890e1f4443abd64b3eba45248694b5e7cfe6c08", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -5,9 +5,7 @@ native \"rust\" mod rustrt {\n     fn rust_file_is_dir(path: str) -> int;\n }\n \n-fn list_dir(path: str) -> [str] {\n-    ret *rustrt::rust_list_files(path + \"*\");\n-}\n+fn list_dir(path: str) -> [str] { ret *rustrt::rust_list_files(path + \"*\"); }\n \n fn path_is_absolute(p: str) -> bool {\n     ret str::char_at(p, 0u) == '/' ||"}, {"sha": "57944b5ff5395fbac8fd6438c898424c1cf317dd", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -30,7 +30,7 @@ mod libc_constants {\n     fn O_TRUNC() -> int { ret 512; }\n     fn O_TEXT() -> int { ret 16384; }\n     fn O_BINARY() -> int { ret 32768; }\n-    fn O_NOINHERIT() -> int { ret 0x0080; }\n+    fn O_NOINHERIT() -> int { ret 128; }\n     fn S_IRUSR() -> uint {\n         ret 256u; // really _S_IREAD  in win32\n \n@@ -59,12 +59,13 @@ fn pipe() -> {in: int, out: int} {\n     // which means to pass it to a subprocess they need to be duplicated\n     // first, as in rust_run_program.\n     let fds = {mutable in: 0, mutable out: 0};\n-    let res = os::libc::_pipe(ptr::addr_of(fds.in), 1024u,\n-                            libc_constants::O_BINARY()\n-                            | libc_constants::O_NOINHERIT());\n-    assert res == 0;\n-    assert fds.in != -1 && fds.in != 0;\n-    assert fds.out != -1 && fds.in != 0;\n+    let res =\n+        os::libc::_pipe(ptr::addr_of(fds.in), 1024u,\n+                        libc_constants::O_BINARY() |\n+                            libc_constants::O_NOINHERIT());\n+    assert (res == 0);\n+    assert (fds.in != -1 && fds.in != 0);\n+    assert (fds.out != -1 && fds.in != 0);\n     ret {in: fds.in, out: fds.out};\n }\n "}, {"sha": "aa79590a24687aeeca9f91397180b9eb59ee827b", "filename": "src/test/bench/99bob-iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-iter.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -32,7 +32,7 @@ fn sub(t: str, n: int) -> str {\n       _ { ns = int::to_str(n, 10u) + \" bottles\"; }\n     }\n     while i < str::byte_len(t) {\n-        if t.(i) == '#' as u8 { b += ns; } else { str::push_byte(b, t.(i)); }\n+        if t[i] == '#' as u8 { b += ns; } else { str::push_byte(b, t[i]); }\n         i += 1u;\n     }\n     ret b;"}, {"sha": "fdfce9dfae520711c735147491022ad44ef8ace6", "filename": "src/test/bench/99bob-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-pattern.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -56,4 +56,4 @@ fn main() {\n     let b: bottle = multiple(99);\n     let running: bool = true;\n     while running { show(b); log \"\"; running = more(b); b = next(b); }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2db6321d257a928b0e4e8f5615b036068697f0fc", "filename": "src/test/bench/99bob-simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-simple.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -32,7 +32,7 @@ fn sub(t: str, n: int) -> str {\n       _ { ns = int::to_str(n, 10u) + \" bottles\"; }\n     }\n     while i < str::byte_len(t) {\n-        if t.(i) == '#' as u8 { b += ns; } else { str::push_byte(b, t.(i)); }\n+        if t[i] == '#' as u8 { b += ns; } else { str::push_byte(b, t[i]); }\n         i += 1u;\n     }\n     ret b;\n@@ -45,4 +45,4 @@ fn main() {\n     while n > 0 { log sub(b1(), n); log sub(b2(), n - 1); log \"\"; n -= 1; }\n     log b7();\n     log sub(b8(), 99);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "af5e22f48ea81443a531cc0214f4d0787fc9b97d", "filename": "src/test/bench/99bob-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2F99bob-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2F99bob-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-tail.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -36,4 +36,4 @@ fn main() {\n         log \"\";\n     }\n     multiple(99);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "46b8cc443bfdbb3fe811ad144eadfde1da225d66", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -22,4 +22,4 @@ fn main() {\n \n     // assert (ack(4,1) == 65533);\n \n-}\n\\ No newline at end of file\n+}"}, {"sha": "d6a44e6eb823c502bdbe596f8d00ec05b35bccf9", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -28,8 +28,8 @@ fn main() {\n     } else { max_depth = n; }\n     let stretch_depth = max_depth + 1;\n     let stretch_tree = bottom_up_tree(0, stretch_depth);\n-    log #fmt(\"stretch tree of depth %d\\t check: %d\", stretch_depth,\n-             item_check(stretch_tree));\n+    log #fmt[\"stretch tree of depth %d\\t check: %d\", stretch_depth,\n+             item_check(stretch_tree)];\n     let long_lived_tree = bottom_up_tree(0, max_depth);\n     let depth = min_depth;\n     while depth <= max_depth {\n@@ -43,10 +43,10 @@ fn main() {\n             chk += item_check(temp_tree);\n             i += 1;\n         }\n-        log #fmt(\"%d\\t trees of depth %d\\t check: %d\", iterations * 2, depth,\n-                 chk);\n+        log #fmt[\"%d\\t trees of depth %d\\t check: %d\", iterations * 2, depth,\n+                 chk];\n         depth += 2;\n     }\n-    log #fmt(\"long lived trees of depth %d\\t check: %d\", max_depth,\n-             item_check(long_lived_tree));\n-}\n\\ No newline at end of file\n+    log #fmt[\"long lived trees of depth %d\\t check: %d\", max_depth,\n+             item_check(long_lived_tree)];\n+}"}, {"sha": "8e7b2cbe269d933198b5bfc442f6ef7558fc68c2", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -20,21 +20,21 @@ fn fannkuch(n: int) -> int {\n     r = n;\n     while r > 0 {\n         i = 0;\n-        while r != 1 { count.(r - 1) = r; r -= 1; }\n-        while i < n { perm.(i) = perm1.(i); i += 1; }\n+        while r != 1 { count[r - 1] = r; r -= 1; }\n+        while i < n { perm[i] = perm1[i]; i += 1; }\n         // Count flips and update max and checksum\n \n         f = 0;\n-        k = perm.(0);\n+        k = perm[0];\n         while k != 0 {\n             i = 0;\n             while 2 * i < k {\n-                let t = perm.(i);\n-                perm.(i) = perm.(k - i);\n-                perm.(k - i) = t;\n+                let t = perm[i];\n+                perm[i] = perm[k - i];\n+                perm[k - i] = t;\n                 i += 1;\n             }\n-            k = perm.(0);\n+            k = perm[0];\n             f += 1;\n         }\n         if f > flips { flips = f; }\n@@ -44,12 +44,12 @@ fn fannkuch(n: int) -> int {\n         let go = true;\n         while go {\n             if r == n { log checksum; ret flips; }\n-            let p0 = perm1.(0);\n+            let p0 = perm1[0];\n             i = 0;\n-            while i < r { let j = i + 1; perm1.(i) = perm1.(j); i = j; }\n-            perm1.(r) = p0;\n-            count.(r) -= 1;\n-            if count.(r) > 0 { go = false; } else { r += 1; }\n+            while i < r { let j = i + 1; perm1[i] = perm1[j]; i = j; }\n+            perm1[r] = p0;\n+            count[r] -= 1;\n+            if count[r] > 0 { go = false; } else { r += 1; }\n         }\n         nperm += 1;\n     }\n@@ -58,5 +58,5 @@ fn fannkuch(n: int) -> int {\n \n fn main(args: [str]) {\n     let n = 7;\n-    log #fmt(\"Pfannkuchen(%d) = %d\", n, fannkuch(n));\n+    log #fmt[\"Pfannkuchen(%d) = %d\", n, fannkuch(n)];\n }"}, {"sha": "80e0108867ddc93c8175270bfb08de5e115f92e4", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -25,20 +25,20 @@ type aminoacids = {ch: char, prob: u32};\n \n fn make_cumulative(aa: &[aminoacids]) -> [aminoacids] {\n     let cp: u32 = 0u32;\n-    let ans: [aminoacids] = ~[];\n-    for a: aminoacids in aa { cp += a.prob; ans += ~[{ch: a.ch, prob: cp}]; }\n+    let ans: [aminoacids] = [];\n+    for a: aminoacids in aa { cp += a.prob; ans += [{ch: a.ch, prob: cp}]; }\n     ret ans;\n }\n \n fn select_random(r: u32, genelist: &[aminoacids]) -> char {\n-    if r < genelist.(0).prob { ret genelist.(0).ch; }\n+    if r < genelist[0].prob { ret genelist[0].ch; }\n     fn bisect(v: &[aminoacids], lo: uint, hi: uint, target: u32) -> char {\n         if hi > lo + 1u {\n             let mid: uint = lo + (hi - lo) / 2u;\n-            if target < v.(mid).prob {\n+            if target < v[mid].prob {\n                 be bisect(v, lo, mid, target);\n             } else { be bisect(v, mid, hi, target); }\n-        } else { ret v.(hi).ch; }\n+        } else { ret v[hi].ch; }\n     }\n     ret bisect(genelist, 0u, vec::len::<aminoacids>(genelist) - 1u, r);\n }\n@@ -59,7 +59,7 @@ fn make_repeat_fasta(id: str, desc: str, s: str, n: int) {\n     let op: str = \"\";\n     let sl: uint = str::byte_len(s);\n     for each i: uint in uint::range(0u, n as uint) {\n-        str::push_byte(op, s.(i % sl));\n+        str::push_byte(op, s[i % sl]);\n         if str::byte_len(op) >= LINE_LENGTH() { log op; op = \"\"; }\n     }\n     if str::byte_len(op) > 0u { log op; }\n@@ -69,16 +69,14 @@ fn acid(ch: char, prob: u32) -> aminoacids { ret {ch: ch, prob: prob}; }\n \n fn main(args: [str]) {\n     let iub: [aminoacids] =\n-        make_cumulative(\n-            ~[acid('a', 27u32), acid('c', 12u32), acid('g', 12u32),\n-              acid('t', 27u32), acid('B', 2u32), acid('D', 2u32),\n-              acid('H', 2u32), acid('K', 2u32), acid('M', 2u32),\n-              acid('N', 2u32), acid('R', 2u32), acid('S', 2u32),\n-              acid('V', 2u32), acid('W', 2u32), acid('Y', 2u32)]);\n+        make_cumulative([acid('a', 27u32), acid('c', 12u32), acid('g', 12u32),\n+                         acid('t', 27u32), acid('B', 2u32), acid('D', 2u32),\n+                         acid('H', 2u32), acid('K', 2u32), acid('M', 2u32),\n+                         acid('N', 2u32), acid('R', 2u32), acid('S', 2u32),\n+                         acid('V', 2u32), acid('W', 2u32), acid('Y', 2u32)]);\n     let homosapiens: [aminoacids] =\n-        make_cumulative(\n-            ~[acid('a', 30u32), acid('c', 20u32), acid('g', 20u32),\n-              acid('t', 30u32)]);\n+        make_cumulative([acid('a', 30u32), acid('c', 20u32), acid('g', 20u32),\n+                         acid('t', 30u32)]);\n     let alu: str =\n         \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\" +\n             \"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\" +"}, {"sha": "a4b5f2588d44c4b4406194bb44c857e4f64e5cf6", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -16,4 +16,4 @@ fn main() {\n     assert (fib(15) == 610);\n     log fib(8);\n     log fib(15);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "5e88804198182243d3434c8766d4663f17534603", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     // during 'make check' under valgrind\n     // 5000000\n     // 50000000\n-    let inputs: [int] = ~[50000, 500000];\n+    let inputs: [int] = [50000, 500000];\n \n     let bodies: [Body::props] = NBodySystem::MakeNBodySystem();\n \n@@ -34,7 +34,7 @@ mod NBodySystem {\n     fn MakeNBodySystem() -> [Body::props] {\n         // these each return a Body::props\n         let bodies: [Body::props] =\n-            ~[Body::sun(), Body::jupiter(), Body::saturn(), Body::uranus(),\n+            [Body::sun(), Body::jupiter(), Body::saturn(), Body::uranus(),\n              Body::neptune()];\n \n         let px: float = 0.0;\n@@ -43,15 +43,15 @@ mod NBodySystem {\n \n         let i: int = 0;\n         while i < 5 {\n-            px += bodies.(i).vx * bodies.(i).mass;\n-            py += bodies.(i).vy * bodies.(i).mass;\n-            pz += bodies.(i).vz * bodies.(i).mass;\n+            px += bodies[i].vx * bodies[i].mass;\n+            py += bodies[i].vy * bodies[i].mass;\n+            pz += bodies[i].vz * bodies[i].mass;\n \n             i += 1;\n         }\n \n         // side-effecting\n-        Body::offsetMomentum(bodies.(0), px, py, pz);\n+        Body::offsetMomentum(bodies[0], px, py, pz);\n \n         ret bodies;\n     }\n@@ -61,13 +61,13 @@ mod NBodySystem {\n         let i: int = 0;\n         while i < 5 {\n             let j: int = i + 1;\n-            while j < 5 { advance_one(bodies.(i), bodies.(j), dt); j += 1; }\n+            while j < 5 { advance_one(bodies[i], bodies[j], dt); j += 1; }\n \n             i += 1;\n         }\n \n         i = 0;\n-        while i < 5 { move(bodies.(i), dt); i += 1; }\n+        while i < 5 { move(bodies[i], dt); i += 1; }\n     }\n \n     fn advance_one(bi: &Body::props, bj: &Body::props, dt: float) {\n@@ -105,19 +105,18 @@ mod NBodySystem {\n         let i: int = 0;\n         while i < 5 {\n             e +=\n-                0.5 * bodies.(i).mass *\n-                    (bodies.(i).vx * bodies.(i).vx +\n-                         bodies.(i).vy * bodies.(i).vy +\n-                         bodies.(i).vz * bodies.(i).vz);\n+                0.5 * bodies[i].mass *\n+                    (bodies[i].vx * bodies[i].vx + bodies[i].vy * bodies[i].vy\n+                         + bodies[i].vz * bodies[i].vz);\n \n             let j: int = i + 1;\n             while j < 5 {\n-                dx = bodies.(i).x - bodies.(j).x;\n-                dy = bodies.(i).y - bodies.(j).y;\n-                dz = bodies.(i).z - bodies.(j).z;\n+                dx = bodies[i].x - bodies[j].x;\n+                dy = bodies[i].y - bodies[j].y;\n+                dz = bodies[i].z - bodies[j].z;\n \n                 distance = llvm::sqrt(dx * dx + dy * dy + dz * dz);\n-                e -= bodies.(i).mass * bodies.(j).mass / distance;\n+                e -= bodies[i].mass * bodies[j].mass / distance;\n \n                 j += 1;\n             }\n@@ -133,7 +132,7 @@ mod Body {\n \n     const PI: float = 3.141592653589793;\n     const SOLAR_MASS: float = 39.478417604357432;\n-     // was 4 * PI * PI originally\n+    // was 4 * PI * PI originally\n     const DAYS_PER_YEAR: float = 365.24;\n \n     type props ="}, {"sha": "60b54cbe33d442ebfe27a74eecae0ec4bad9cadc", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -30,7 +30,7 @@ fn fib(n: int) -> int {\n     fn pfib(c: _chan<int>, n: int) {\n         if n == 0 {\n             send(c, 0);\n-        } else if (n <= 2) {\n+        } else if n <= 2 {\n             send(c, 1);\n         } else {\n             let p = mk_port::<int>();\n@@ -50,7 +50,7 @@ fn fib(n: int) -> int {\n type config = {stress: bool};\n \n fn parse_opts(argv: [str]) -> config {\n-    let opts = ~[getopts::optflag(\"stress\")];\n+    let opts = [getopts::optflag(\"stress\")];\n \n     let opt_args = vec::slice(argv, 1u, vec::len(argv));\n \n@@ -67,7 +67,7 @@ fn stress_task(id: int) {\n         let n = 15;\n         assert (fib(n) == fib(n));\n         i += 1;\n-        log_err #fmt(\"%d: Completed %d iterations\", id, i);\n+        log_err #fmt[\"%d: Completed %d iterations\", id, i];\n     }\n }\n \n@@ -91,7 +91,7 @@ fn main(argv: [str]) {\n         if opts.stress {\n             stress(2);\n         } else {\n-            let max = uint::parse_buf(str::bytes(argv.(1)), 10u) as int;\n+            let max = uint::parse_buf(str::bytes(argv[1]), 10u) as int;\n \n             let num_trials = 10;\n \n@@ -106,8 +106,8 @@ fn main(argv: [str]) {\n \n                     let elapsed = stop - start;\n \n-                    out.write_line(#fmt(\"%d\\t%d\\t%s\", n, fibn,\n-                                        u64::str(elapsed)));\n+                    out.write_line(#fmt[\"%d\\t%d\\t%s\", n, fibn,\n+                                        u64::str(elapsed)]);\n                 }\n             }\n         }"}, {"sha": "150853e23289ba4b0642a8cc28071811c276ef83", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -6,25 +6,17 @@ import std::str;\n \n fn f(n: uint) {\n     let i = 0u;\n-    while i < n {\n-        let thunk = g;\n-        task::join_id(task::spawn(thunk));\n-        i += 1u;\n-    }\n+    while i < n { let thunk = g; task::join_id(task::spawn(thunk)); i += 1u; }\n }\n \n-fn g() {}\n+fn g() { }\n \n fn main(args: [str]) {\n \n-    let n = if vec::len(args) < 2u {\n-        10u\n-    } else {\n-        uint::parse_buf(str::bytes(args.(1)), 10u)\n-    };\n+    let n =\n+        if vec::len(args) < 2u {\n+            10u\n+        } else { uint::parse_buf(str::bytes(args[1]), 10u) };\n     let i = 0u;\n-    while i < n {\n-        task::spawn(bind f(n));\n-        i += 1u;\n-    }\n+    while i < n { task::spawn(bind f(n)); i += 1u; }\n }"}, {"sha": "7d0effb4a7f9d899545161ac8f98a7db45433812", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -42,14 +42,7 @@ fn reduce(word: str, get: map_reduce::getter) {\n     let count = 0;\n \n \n-    while true {\n-        alt get() {\n-          some(_) {\n-            count += 1;\n-          }\n-          none. { break }\n-        }\n-    }\n+    while true { alt get() { some(_) { count += 1; } none. { break } } }\n }\n \n mod map_reduce {\n@@ -59,13 +52,13 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter = fn(str, int) ;\n+    type putter = fn(str, int);\n \n-    type mapper = fn(str, putter) ;\n+    type mapper = fn(str, putter);\n \n-    type getter = fn() -> option<int> ;\n+    type getter = fn() -> option<int>;\n \n-    type reducer = fn(str, getter) ;\n+    type reducer = fn(str, getter);\n \n     tag ctrl_proto {\n         find_reducer([u8], _chan<_chan<reduce_proto>>);\n@@ -75,9 +68,9 @@ mod map_reduce {\n     tag reduce_proto { emit_val(int); done; ref; release; }\n \n     fn start_mappers(ctrl: _chan<ctrl_proto>, inputs: &[str]) -> [task_id] {\n-        let tasks = ~[];\n+        let tasks = [];\n         for i: str in inputs {\n-            tasks += ~[task::spawn(bind map_task(ctrl, i))];\n+            tasks += [task::spawn(bind map_task(ctrl, i))];\n         }\n         ret tasks;\n     }\n@@ -108,7 +101,7 @@ mod map_reduce {\n \n         map(input, bind emit(intermediates, ctrl, _, _));\n \n-        for each kv: @{key: str, val: _chan<reduce_proto>}  in\n+        for each kv: @{key: str, val: _chan<reduce_proto>} in\n                  intermediates.items() {\n             send(kv.val, release);\n         }\n@@ -178,8 +171,7 @@ mod map_reduce {\n                   none. {\n                     // log_err \"creating new reducer for \" + k;\n                     let p = mk_port();\n-                    tasks +=\n-                        ~[task::spawn(bind reduce_task(k, p.mk_chan()))];\n+                    tasks += [task::spawn(bind reduce_task(k, p.mk_chan()))];\n                     c = p.recv();\n                     reducers.insert(k, c);\n                   }\n@@ -202,7 +194,7 @@ fn main(argv: [str]) {\n     if vec::len(argv) < 2u {\n         let out = io::stdout();\n \n-        out.write_line(#fmt(\"Usage: %s <filename> ...\", argv.(0)));\n+        out.write_line(#fmt[\"Usage: %s <filename> ...\", argv[0]]);\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program."}, {"sha": "068e8c65ff514cb8da273f322c44dacee3070760", "filename": "src/test/compile-fail/alias-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Falias-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Falias-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falias-mismatch.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -5,5 +5,5 @@ import std::vec::map;\n fn main() {\n     fn f(i: uint) -> bool { true }\n \n-    let a = map(f, ~[5u]);\n-}\n\\ No newline at end of file\n+    let a = map(f, [5u]);\n+}"}, {"sha": "8be70d8e29f251e9af282e5480e2392609cf1a92", "filename": "src/test/compile-fail/aliasness-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Faliasness-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Faliasness-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faliasness-mismatch.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -3,6 +3,6 @@\n \n fn f(x: &int) { log_err x; }\n fn h(x: int) { log_err x; }\n-fn main() { let g: fn(int)  = f; g(10); g = h; g(10); }\n+fn main() { let g: fn(int) = f; g(10); g = h; g(10); }\n \n "}, {"sha": "246d186b06ce05eae01e59158d962de2f5eb68ae", "filename": "src/test/compile-fail/alt-join.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-join.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -5,11 +5,8 @@\n fn my_fail() -> ! { fail; }\n \n fn main() {\n-    alt (true) {\n-      false { my_fail(); }\n-      true {}\n-    }\n+    alt true { false { my_fail(); } true { } }\n \n     log x;\n-    let x:int;\n-}\n\\ No newline at end of file\n+    let x: int;\n+}"}, {"sha": "75e63ab2cc6323100a626614a42f29428d16abe2", "filename": "src/test/compile-fail/and-init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fand-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fand-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fand-init.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -5,4 +5,4 @@ fn main() {\n \n     log false && { i = 5; true };\n     log i;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "62aad13d150ebb13b30ed93cb496b95aa78fe55c", "filename": "src/test/compile-fail/arg-count-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,4 +2,4 @@\n \n fn f(x: int) { }\n \n-fn main() { let i: (); i = f(); }\n\\ No newline at end of file\n+fn main() { let i: (); i = f(); }"}, {"sha": "8934a12b27a2025263f4538de806f4713586df18", "filename": "src/test/compile-fail/arg-type-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -3,4 +3,4 @@\n \n fn f(x: int) { }\n \n-fn main() { let i: (); i = f(()); }\n\\ No newline at end of file\n+fn main() { let i: (); i = f(()); }"}, {"sha": "b291b6d47b63ff65f974f78e74a0aafd699f9503", "filename": "src/test/compile-fail/assign-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fassign-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fassign-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-alias.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,4 +2,4 @@\n \n fn f(i: &int) { i += 2; }\n \n-fn main() { f(1); }\n\\ No newline at end of file\n+fn main() { f(1); }"}, {"sha": "b218ddd122a38ec539c11c293cf5274244a2ba14", "filename": "src/test/compile-fail/auto-deref-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-deref-bind.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: mismatched types\n \n fn add1(i: int) -> int { ret i + 1; }\n-fn main() { let f = @add1; let g = bind f(5); }\n\\ No newline at end of file\n+fn main() { let f = @add1; let g = bind f(5); }"}, {"sha": "011358ac10cc3afeafc0a8dc6034e6ade9679648", "filename": "src/test/compile-fail/bad-bang-ann-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -4,4 +4,4 @@\n \n fn bad_bang(i: uint) -> ! { log 3; }\n \n-fn main() { bad_bang(5u); }\n\\ No newline at end of file\n+fn main() { bad_bang(5u); }"}, {"sha": "2ba862ff57f7f8c58153f3de41722a0d32500921", "filename": "src/test/compile-fail/bad-bang-ann-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -4,4 +4,4 @@\n \n fn bad_bang(i: uint) -> ! { ret 7u; }\n \n-fn main() { bad_bang(5u); }\n\\ No newline at end of file\n+fn main() { bad_bang(5u); }"}, {"sha": "e67013998a1ce3cd0bdfd9ec232532020529da37", "filename": "src/test/compile-fail/bad-bang-ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -4,4 +4,4 @@\n \n fn bad_bang(i: uint) -> ! { if i < 0u { } else { fail; } }\n \n-fn main() { bad_bang(5u); }\n\\ No newline at end of file\n+fn main() { bad_bang(5u); }"}, {"sha": "8e8441e55ac983f97acfdff4f3ace22b480ae9a6", "filename": "src/test/compile-fail/bad-env-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -3,4 +3,4 @@ fn foo() {\n     let x: int;\n     fn bar() { log x; }\n }\n-fn main() { foo(); }\n\\ No newline at end of file\n+fn main() { foo(); }"}, {"sha": "40a0a39e7c692c5205107d1bbbfb2a8105ca3f0e", "filename": "src/test/compile-fail/bad-env-capture2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,4 +2,4 @@\n fn foo(x: int) {\n     fn bar() { log x; }\n }\n-fn main() { foo(2); }\n\\ No newline at end of file\n+fn main() { foo(2); }"}, {"sha": "1ff3602ee8894c69cf54a6545a4823ef4688afb2", "filename": "src/test/compile-fail/bad-env-capture3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -5,4 +5,4 @@ obj foo(x: int) {\n     }\n }\n \n-fn main() { foo(2); }\n\\ No newline at end of file\n+fn main() { foo(2); }"}, {"sha": "725f88129b982b86c9bb4f2ecb6977e0b292cb5c", "filename": "src/test/compile-fail/bad-main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-main.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:wrong type in main function\n \n-fn main(x: int) { }\n\\ No newline at end of file\n+fn main(x: int) { }"}, {"sha": "c5b67b9401b849806e7fb1c536e1a453bdefed33", "filename": "src/test/compile-fail/bad-module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-module.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: unresolved import: vec\n import vec;\n \n-fn main() { let foo = vec::len([]); }\n\\ No newline at end of file\n+fn main() { let foo = vec::len([]); }"}, {"sha": "54ae70a86612d214fca5c4ca93d42987a3a595ae", "filename": "src/test/compile-fail/bad-record-pat-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:did not expect a record with a field q\n \n-fn main() { alt {x: 1, y: 2} { {x: x, q: q} { } } }\n\\ No newline at end of file\n+fn main() { alt {x: 1, y: 2} { {x: x, q: q} { } } }"}, {"sha": "1b12d274ce8f4e798ab7b1ae940d68fa396af407", "filename": "src/test/compile-fail/bad-record-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:expected a record with 2 fields, found one with 1\n \n-fn main() { alt {x: 1, y: 2} { {x: x} { } } }\n\\ No newline at end of file\n+fn main() { alt {x: 1, y: 2} { {x: x} { } } }"}, {"sha": "d13fca4486c5cb2fabacba01bae159ca49e2fc54", "filename": "src/test/compile-fail/bang-tailexpr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbang-tailexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbang-tailexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbang-tailexpr.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern: some control paths may return\n fn f() -> ! { 3 }\n-fn main(){}\n+fn main() { }"}, {"sha": "86515aeea6a7d1c43cd08a93784c953084817b00", "filename": "src/test/compile-fail/binop-add-tup-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup-assign.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:+ cannot be applied to type `{x: bool}`\n \n-fn main() { let x = {x: true}; x += {x: false}; }\n\\ No newline at end of file\n+fn main() { let x = {x: true}; x += {x: false}; }"}, {"sha": "fadb35503e23403b716ffd83f98c6bce3e7983ca", "filename": "src/test/compile-fail/binop-add-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-add-tup.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:+ cannot be applied to type `{x: bool}`\n \n-fn main() { let x = {x: true} + {x: false}; }\n\\ No newline at end of file\n+fn main() { let x = {x: true} + {x: false}; }"}, {"sha": "65e0996fa627b4c41f452699a274d48c64f5b751", "filename": "src/test/compile-fail/binop-bitxor-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:^ cannot be applied to type `str`\n \n-fn main() { let x = \"a\" ^ \"b\"; }\n\\ No newline at end of file\n+fn main() { let x = \"a\" ^ \"b\"; }"}, {"sha": "7b7b165d49b627d565215be89da13c7503a8300e", "filename": "src/test/compile-fail/binop-logic-float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-logic-float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-logic-float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-logic-float.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:|| cannot be applied to type `f32`\n \n-fn main() { let x = 1.0_f32 || 2.0_f32; }\n\\ No newline at end of file\n+fn main() { let x = 1.0_f32 || 2.0_f32; }"}, {"sha": "ef8643bd7b42e285a5e972d56c2c02943bffd0bc", "filename": "src/test/compile-fail/binop-logic-int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:&& cannot be applied to type `int`\n \n-fn main() { let x = 1 && 2; }\n\\ No newline at end of file\n+fn main() { let x = 1 && 2; }"}, {"sha": "7c912f58d1e6893450a952a00eda92050299d162", "filename": "src/test/compile-fail/binop-mul-bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-mul-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-mul-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-mul-bool.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:* cannot be applied to type `bool`\n \n-fn main() { let x = true * false; }\n\\ No newline at end of file\n+fn main() { let x = true * false; }"}, {"sha": "630cd288a4924c8e13926fe4e51ec276f689bbb7", "filename": "src/test/compile-fail/binop-sub-obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-sub-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-sub-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-sub-obj.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:- cannot be applied to type `obj\n \n-fn main() { let x = obj () {  } - obj () {  }; }\n\\ No newline at end of file\n+fn main() { let x = obj () { } - obj () { }; }"}, {"sha": "9cb6dea536024340e914c3419c719d57d33eef5f", "filename": "src/test/compile-fail/binop-typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-typeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbinop-typeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-typeck.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,4 +1,4 @@\n // error-pattern:mismatched types\n // issue #500\n \n-fn main() { let x = true; let y = 1; let z = x + y; }\n\\ No newline at end of file\n+fn main() { let x = true; let y = 1; let z = x + y; }"}, {"sha": "bb3e53028c29bc679fc6d6a7892f7d93770a22d2", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -3,11 +3,11 @@\n // Make sure that fn-to-block coercion isn't incorrectly lifted over\n // other tycons.\n \n-fn coerce(b: &block() ) -> fn()  {\n-    fn lol(f: &fn(&block() ) -> fn()  , g: &block() ) -> fn()  { ret f(g); }\n-    fn fn_id(f: &fn() ) -> fn()  { ret f }\n+fn coerce(b: &block()) -> fn() {\n+    fn lol(f: &fn(&block()) -> fn(), g: &block()) -> fn() { ret f(g); }\n+    fn fn_id(f: &fn()) -> fn() { ret f }\n     ret lol(fn_id, b);\n }\n \n \n-fn main() { let i = 8; let f = coerce(block () { log_err i; }); f(); }\n\\ No newline at end of file\n+fn main() { let i = 8; let f = coerce(block () { log_err i; }); f(); }"}, {"sha": "6a6c708cf8813ff81e3df40e7f003f9f81057930", "filename": "src/test/compile-fail/block-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: non-copyable\n \n-fn lol(f: &block() ) -> block()  { ret f; }\n-fn main() { let i = 8; let f = lol(block () { log_err i; }); f(); }\n\\ No newline at end of file\n+fn lol(f: &block()) -> block() { ret f; }\n+fn main() { let i = 8; let f = lol(block () { log_err i; }); f(); }"}, {"sha": "9028d5fa4356ab5dd52ba4bcc97fc7ebf46109a7", "filename": "src/test/compile-fail/block-uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: Unsatisfied precondition constraint\n \n-fn force(f: &block() ) { f(); }\n-fn main() { let x: int; force(block () { log_err x; }); }\n\\ No newline at end of file\n+fn force(f: &block()) { f(); }\n+fn main() { let x: int; force(block () { log_err x; }); }"}, {"sha": "3783dc83dd04983a1c19c5e7a3c47436e32eecb6", "filename": "src/test/compile-fail/break-outside-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -4,4 +4,4 @@ fn main() {\n \n     let rs: {t: str} = {t: pth};\n \n-}\n\\ No newline at end of file\n+}"}, {"sha": "9a82a95ade200fde4795a1b6ef4458638027a3e4", "filename": "src/test/compile-fail/break-uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -11,4 +11,4 @@ fn foo() -> int {\n     ret 17;\n }\n \n-fn main() { log foo(); }\n\\ No newline at end of file\n+fn main() { log foo(); }"}, {"sha": "d1fda52fae63e93016c106579397258b69e1522c", "filename": "src/test/compile-fail/break-uninit2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -11,4 +11,4 @@ fn foo() -> int {\n     ret 17;\n }\n \n-fn main() { log foo(); }\n\\ No newline at end of file\n+fn main() { log foo(); }"}, {"sha": "877884bf7f90dd5f4c7dabfe648afa93b7112f0e", "filename": "src/test/compile-fail/capture1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fcapture1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fcapture1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcapture1.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -5,4 +5,4 @@\n fn main() {\n     let bar: int = 5;\n     fn foo() -> int { ret bar; }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "85d8c7850cfbc9e47157c9258ff8e99f98b9bbb8", "filename": "src/test/compile-fail/constructor-as-cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fconstructor-as-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fconstructor-as-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconstructor-as-cast.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,10 +1,10 @@\n // error-pattern: unresolved name: base\n type base =\n     obj {\n-        fn foo() ;\n+        fn foo();\n     };\n obj derived() {\n     fn foo() { }\n     fn bar() { }\n }\n-fn main() { let d: derived = derived(); let b: base = base(d); }\n\\ No newline at end of file\n+fn main() { let d: derived = derived(); let b: base = base(d); }"}, {"sha": "9e5e6f816667800b64347407de12a86dc6dc264d", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,4 +2,4 @@\n \n resource foo(i: int) { }\n \n-fn main() { let x <- foo(10); let y = x; }\n\\ No newline at end of file\n+fn main() { let x <- foo(10); let y = x; }"}, {"sha": "490f8ae9b2194eb2696d4aa9f2051555710b719b", "filename": "src/test/compile-fail/cross-crate-glob-collision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -10,4 +10,4 @@ mod alternate_supplier {\n     fn member() { }\n }\n \n-fn main() { member() }\n\\ No newline at end of file\n+fn main() { member() }"}, {"sha": "01ec855bf7cc39b715f4c642c1053bd27b003bae", "filename": "src/test/compile-fail/direct-obj-fn-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -4,4 +4,4 @@ obj x() {\n     fn hello() { log \"hello\"; }\n }\n \n-fn main() { x.hello(); }\n\\ No newline at end of file\n+fn main() { x.hello(); }"}, {"sha": "f7d03b89354aca70abbae7e956c748a747b15b8f", "filename": "src/test/compile-fail/do-while-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fdo-while-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fdo-while-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo-while-constraints.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -7,4 +7,4 @@ fn main() {\n         log y;\n         do  { do  { do  { x <- y; } while true } while true } while true\n     } while true\n-}\n\\ No newline at end of file\n+}"}, {"sha": "90fcd26ea9f7f483e7ae5d56d6a35765dce68bc2", "filename": "src/test/compile-fail/do-while-pred-constraints.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fdo-while-pred-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fdo-while-pred-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo-while-pred-constraints.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,24 +1,14 @@\n // error-pattern: Unsatisfied precondition constraint (for example, even(y\n \n-fn print_even(y: int) : even(y) {\n-  log y;\n-}\n+fn print_even(y: int) : even(y) { log y; }\n \n-pred even(y: int) -> bool {\n-  true\n-}\n+pred even(y: int) -> bool { true }\n \n fn main() {\n-  let y: int = 42;\n-  check even(y);\n-  do {\n-    print_even(y);\n-    do {\n-      do {\n-    do {\n-      y += 1;\n-    } while (true);\n-      } while (true);\n-    } while (true);\n-  } while (true);\n+    let y: int = 42;\n+    check (even(y));\n+    do  {\n+        print_even(y);\n+        do  { do  { do  { y += 1; } while true } while true } while true\n+    } while true\n }"}, {"sha": "c7f0a12d061b7e7393ada8de3857e38d053298d4", "filename": "src/test/compile-fail/dup-link-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fdup-link-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fdup-link-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdup-link-name.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,4 +2,4 @@\n \n #[link(name = \"test\", name)];\n \n-fn main() { }\n\\ No newline at end of file\n+fn main() { }"}, {"sha": "30075a1cadb97d12124b11bd6d8e53dd0254bb60", "filename": "src/test/compile-fail/export-fully-qualified.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -13,4 +13,4 @@ mod foo {\n     fn baz() { }\n }\n \n-fn main() { }\n\\ No newline at end of file\n+fn main() { }"}, {"sha": "f5ed4c4f3a78818330701ceb941ba036003a1341", "filename": "src/test/compile-fail/export-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-import.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -11,4 +11,4 @@ mod m {\n }\n \n \n-fn main() { unexported(); }\n\\ No newline at end of file\n+fn main() { unexported(); }"}, {"sha": "2d10cb49270a95daa88dc898164b9d60d6252c0c", "filename": "src/test/compile-fail/export-no-tag-variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport-no-tag-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport-no-tag-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-no-tag-variants.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -9,4 +9,4 @@ mod foo {\n     tag t { t1; }\n }\n \n-fn main() { let x = foo::t1; }\n\\ No newline at end of file\n+fn main() { let x = foo::t1; }"}, {"sha": "33496480c025a6e7ce2f78bf2e80feecdd0a5191", "filename": "src/test/compile-fail/export-tag-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-tag-variant.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -8,4 +8,4 @@ mod foo {\n     tag y { y1; }\n }\n \n-fn main() { let z = foo::y1; }\n\\ No newline at end of file\n+fn main() { let z = foo::y1; }"}, {"sha": "55d33160d343c2ed0609504fd7efad686ce6aa36", "filename": "src/test/compile-fail/export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -5,4 +5,4 @@ mod foo {\n     fn z(y: int) { log y; }\n }\n \n-fn main() { foo::z(10); }\n\\ No newline at end of file\n+fn main() { foo::z(10); }"}, {"sha": "28919efdd49861783ac79efdb351e643fa20f830", "filename": "src/test/compile-fail/export2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -14,4 +14,4 @@ mod bar {\n     fn y() { }\n }\n \n-fn main() { foo::x(); }\n\\ No newline at end of file\n+fn main() { foo::x(); }"}, {"sha": "ec63c1f07d0f91f0779f23252556056cacb00b16", "filename": "src/test/compile-fail/ext-nonexistent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,2 +1,2 @@\n // error-pattern:macro undefined\n-fn main() { #iamnotanextensionthatexists(\"\"); }\n\\ No newline at end of file\n+fn main() { #iamnotanextensionthatexists[\"\"]; }"}, {"sha": "0857ac990c0a393c94f3e6818d3478928bc24a0d", "filename": "src/test/compile-fail/extend-non-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextend-non-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextend-non-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextend-non-object.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -10,4 +10,4 @@ fn main() {\n             with\n             x\n         };\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ec73f0a7a45d0653cefe957ee3726d0d07a7ce4f", "filename": "src/test/compile-fail/extenv-no-args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,5 +1,3 @@\n // error-pattern:malformed #env call\n \n-fn main() {\n-    #env();\n-}\n+fn main() { #env[]; }"}, {"sha": "57d50b2e54d24c5f361c6084928fe7c469b44754", "filename": "src/test/compile-fail/extenv-not-string-literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:requires a string\n \n-fn main() { #env(10); }\n\\ No newline at end of file\n+fn main() { #env[10]; }"}, {"sha": "945546fd6cb49f2da01ddbed0768cbba519c4cf9", "filename": "src/test/compile-fail/extenv-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:malformed #env call\n \n-fn main() { #env(\"one\", \"two\"); }\n\\ No newline at end of file\n+fn main() { #env[\"one\", \"two\"]; }"}, {"sha": "9e1cbc557d4c1acc9ca7d25af311d56a4f1c7a56", "filename": "src/test/compile-fail/extfmt-missing-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:missing type\n \n-fn main() { #fmt(\"%+\"); }\n\\ No newline at end of file\n+fn main() { #fmt[\"%+\"]; }"}, {"sha": "7c13ef99dc5c9614dad382c9f8f25251a71e8ba3", "filename": "src/test/compile-fail/extfmt-no-args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,5 +1,3 @@\n // error-pattern:format string\n \n-fn main() {\n-    #fmt();\n-}\n\\ No newline at end of file\n+fn main() { #fmt[]; }"}, {"sha": "445455f33d8bae901a3f7ea584fff3d34c5cc997", "filename": "src/test/compile-fail/extfmt-non-literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     // #fmt's first argument must be a literal.  Hopefully this\n     // restriction can be eased eventually to just require a\n     // compile-time constant.\n-    let x = #fmt(\"a\" + \"b\");\n-}\n\\ No newline at end of file\n+    let x = #fmt[\"a\" + \"b\"];\n+}"}, {"sha": "8a2d7c4bbed304241a7012f624f509758ec07a4a", "filename": "src/test/compile-fail/extfmt-non-literal2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     // #fmt's first argument must be a literal.  Hopefully this\n     // restriction can be eased eventually to just require a\n     // compile-time constant.\n-    let x = #fmt(20);\n-}\n\\ No newline at end of file\n+    let x = #fmt[20];\n+}"}, {"sha": "849a836060d2dbc2c1adb3685cb7add28891e3f2", "filename": "src/test/compile-fail/extfmt-not-enough-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,4 +2,4 @@\n \n use std;\n \n-fn main() { let s = #fmt(\"%s%s%s\", \"test\", \"test\"); }\n\\ No newline at end of file\n+fn main() { let s = #fmt[\"%s%s%s\", \"test\", \"test\"]; }"}, {"sha": "4c91da227e1bb2b417d6815ca6a940f45476bb34", "filename": "src/test/compile-fail/extfmt-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,4 +2,4 @@\n \n use std;\n \n-fn main() { let s = #fmt(\"%s\", \"test\", \"test\"); }\n\\ No newline at end of file\n+fn main() { let s = #fmt[\"%s\", \"test\", \"test\"]; }"}, {"sha": "3a35a1d727b95222633d3583112e4f27555caec9", "filename": "src/test/compile-fail/extfmt-unknown-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:unknown type\n \n-fn main() { #fmt(\"%w\"); }\n\\ No newline at end of file\n+fn main() { #fmt[\"%w\"]; }"}, {"sha": "4ac41efb31227b6fb3b4415f280b5a966af3d290", "filename": "src/test/compile-fail/extfmt-unsigned-plus.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,5 +2,5 @@\n \n fn main() {\n     // Can't use a sign on unsigned conversions\n-    #fmt(\"%+u\", 10u);\n-}\n\\ No newline at end of file\n+    #fmt[\"%+u\", 10u];\n+}"}, {"sha": "6393548eb3d2ded19ea9458779d7f65e754c6053", "filename": "src/test/compile-fail/extfmt-unsigned-space.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,5 +2,5 @@\n \n fn main() {\n     // Can't use a space on unsigned conversions\n-    #fmt(\"% u\", 10u);\n-}\n\\ No newline at end of file\n+    #fmt[\"% u\", 10u];\n+}"}, {"sha": "3b7d0ce1767939d2e673aae3c183a2df651add81", "filename": "src/test/compile-fail/extfmt-unterminated-conv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:unterminated conversion\n \n-fn main() { #fmt(\"%\"); }\n\\ No newline at end of file\n+fn main() { #fmt[\"%\"]; }"}, {"sha": "72ae83062eb7ba34e37dcdc8e27d8c6b6e1ca25c", "filename": "src/test/compile-fail/fail-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:mismatched types\n \n-fn main() { fail 5; }\n\\ No newline at end of file\n+fn main() { fail 5; }"}, {"sha": "8ea86d80a7b05d10f3d9b23361b85914d59f08a6", "filename": "src/test/compile-fail/fail-type-err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,2 +1,2 @@\n // error-pattern:expected str but found [int]\n-fn main() { fail ~[0]; }\n\\ No newline at end of file\n+fn main() { fail [0]; }"}, {"sha": "2349bfe90dc471edb0a8b19546bee4934ae328ed", "filename": "src/test/compile-fail/fn-bad-block-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffn-bad-block-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffn-bad-block-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-bad-block-type.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,4 +2,4 @@\n \n fn f() -> int { true }\n \n-fn main() { }\n\\ No newline at end of file\n+fn main() { }"}, {"sha": "87287edca7194afb6fd0c423540a41f7284cb6fe", "filename": "src/test/compile-fail/fn-compare-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -4,4 +4,4 @@ fn main() {\n     fn f() { }\n     fn g(i: int) { }\n     let x = f == g;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "9ace741d83695756e7358f58d65bb75790559337", "filename": "src/test/compile-fail/fn-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -6,4 +6,4 @@ fn main() {\n     let a: uint = 4u;\n     let b: uint = 1u;\n     log_err safe_slice(\"kitties\", a, b);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "935542e85e78c14dbd09d9759ec3f0ffafa1d8af", "filename": "src/test/compile-fail/fn-expr-type-state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffn-expr-type-state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffn-expr-type-state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-expr-type-state.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -4,4 +4,4 @@ fn main() {\n     // Typestate should work even in a lambda. we should reject this program.\n     let f = fn () -> int { let i: int; ret i; };\n     log_err f();\n-}\n\\ No newline at end of file\n+}"}, {"sha": "d4f49f9646691f6cd880334d546dac25d231796e", "filename": "src/test/compile-fail/fn-expr-typestate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffn-expr-typestate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffn-expr-typestate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-expr-typestate-2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:Unsatisfied precondition\n \n-fn main() { let j = fn () -> int { let i: int; ret i; }(); log_err j; }\n\\ No newline at end of file\n+fn main() { let j = fn () -> int { let i: int; ret i; }(); log_err j; }"}, {"sha": "0d184978769e5de4ab336c376a75dea5e8efe9e7", "filename": "src/test/compile-fail/for-each-over-bs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffor-each-over-bs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffor-each-over-bs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-each-over-bs.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,2 +1,2 @@\n // error-pattern:sequence in for each loop not a call\n-fn main() { for each p in 1 {} }\n+fn main() { for each p in 1 { } }"}, {"sha": "5d91e3212df521fefbc0d999d8853756a65ef1c1", "filename": "src/test/compile-fail/forgot-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -5,4 +5,4 @@ fn god_exists(a: int) -> bool { be god_exists(a); }\n \n fn f(a: int) -> int { if god_exists(a) { ret 5; } }\n \n-fn main() { f(12); }\n\\ No newline at end of file\n+fn main() { f(12); }"}, {"sha": "7d070c47f4634fa4994f3f152c347ecfde894e2a", "filename": "src/test/compile-fail/fru-extra-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -8,4 +8,4 @@ fn main() {\n     let origin: point = {x: 0, y: 0};\n \n     let origin3d: point = {z: 0 with origin};\n-}\n\\ No newline at end of file\n+}"}, {"sha": "447f6f44dc57011bf914ff75bf3e43bc4a53a209", "filename": "src/test/compile-fail/fru-typestate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -9,4 +9,4 @@ fn main() {\n \n     let right: point = {x: 10 with origin};\n     origin = {x: 0, y: 0};\n-}\n\\ No newline at end of file\n+}"}, {"sha": "bfb7a277492f0c8843cff9c5e5f24f9c3079621d", "filename": "src/test/compile-fail/if-branch-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:mismatched types\n \n-fn main() { let x = if true { 10 } else { 10u }; }\n\\ No newline at end of file\n+fn main() { let x = if true { 10 } else { 10u }; }"}, {"sha": "9ce0d6f8ef51fcdb17a2169edc82810032da7a21", "filename": "src/test/compile-fail/if-check-precond-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -2,11 +2,11 @@\n pred even(x: uint) -> bool {\n     if x < 2u {\n         ret false;\n-    } else if (x == 2u) { ret true; } else { ret even(x - 2u); }\n+    } else if x == 2u { ret true; } else { ret even(x - 2u); }\n }\n \n fn print_even(x: uint) : even(x) { log x; }\n \n fn foo(x: uint) { if check even(x) { fail; } else { print_even(x); } }\n \n-fn main() { foo(3u); }\n\\ No newline at end of file\n+fn main() { foo(3u); }"}, {"sha": "d8c262bd6b370e1904e62dbef39212f831d7886a", "filename": "src/test/compile-fail/if-typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fif-typeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fif-typeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-typeck.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49", "patch": "@@ -7,4 +7,4 @@ fn main() {\n \n     // f is not a bool\n     if f { }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "73e14bfc753f65c500307f16a909347c70ac7360", "filename": "src/test/compile-fail/import-from-dup.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-from-dup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-from-dup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-from-dup.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "bcd9ee7da433672644d797e6e6c5265bcbecf49c", "filename": "src/test/compile-fail/import-from-missing.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "d0cbcf57ad3c912022d7dbc53f4edc6fe32b48e4", "filename": "src/test/compile-fail/import-glob-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "c9595777c272b1bf7502610a120cbef5bbc35f35", "filename": "src/test/compile-fail/import-glob-circular.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "3965ad5fc4d5d440ec06c4d849fe820fd23d573c", "filename": "src/test/compile-fail/import-glob-export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-glob-export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-glob-export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-export.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "55a8878381d948f17246da23078dc8433a477e0d", "filename": "src/test/compile-fail/import-glob-multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "4040f8333f98e14eb694e8057e921cc1378dd03e", "filename": "src/test/compile-fail/import-loop-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "6aa88db603d7ef1cb04008859d4d139571bde30d", "filename": "src/test/compile-fail/import-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "71f17b0c34a5fbc5ab497932c1277dd804cbb1a8", "filename": "src/test/compile-fail/import5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimport5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport5.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "05433ba17ed6ffa05c0dfcb0742bf0ab972185f2", "filename": "src/test/compile-fail/impure-pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "709c5b628eee3ea3b9e4d04c9889f99c4b541899", "filename": "src/test/compile-fail/infinite-vec-type-recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "409b0e599500c95bd3f875acf7263855f8b5a611", "filename": "src/test/compile-fail/lambda-mutate-nested.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "cb891aad374ab07a305da9c6d4336e5a4915bf38", "filename": "src/test/compile-fail/lambda-mutate.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "d1796da90374b950d4b85dbe2647c60449f1f460", "filename": "src/test/compile-fail/let-destruct-refutable.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Flet-destruct-refutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Flet-destruct-refutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flet-destruct-refutable.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "a802301756cae569d4288fb119907067626eb33d", "filename": "src/test/compile-fail/macro-2.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "5943e575a48f287cad56b24bf635e2b1289f4f58", "filename": "src/test/compile-fail/macro.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "e3d5ca40d0820db29271d7edd5e2e0599cb64bbc", "filename": "src/test/compile-fail/main-wrong-type-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "2be4af77008702f13ebddc362b0ae9a6ddc956f1", "filename": "src/test/compile-fail/main-wrong-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "e30a2dbe7df9d3b4ea5de522c3a222f22527b75d", "filename": "src/test/compile-fail/minus-string.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fminus-string.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "e531cbdc6cc3a443408193ae6f86681b5f75f24e", "filename": "src/test/compile-fail/missing-main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmissing-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmissing-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-main.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "0fc48fd950a41f7a26946654eaa9a21c2e3aa24f", "filename": "src/test/compile-fail/missing-return2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "9b60e5dae9a5a9c86b5d94a59079eea0de78fd6f", "filename": "src/test/compile-fail/move-arg.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "ddb6375e36d86127ef28f10cbabeaccc2cc615a6", "filename": "src/test/compile-fail/native-type-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnative-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnative-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnative-type-mismatch.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "7a249c657fd0d653f227057cebd629b05bee4dc3", "filename": "src/test/compile-fail/nested-ty-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "65e21baf78b05231f60284bba1a86ef04521cb7f", "filename": "src/test/compile-fail/no-constraint-prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "876c668e8c619cb2993f4a350f30cebd87a4dc39", "filename": "src/test/compile-fail/no-self-dispatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fno-self-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fno-self-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-self-dispatch.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "852db46e9df11413e0f146c0f2d387e77b2b3bdc", "filename": "src/test/compile-fail/not-a-pred-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "3ca98a5c1ce8b1d2140ea91d4919ff0bcfa9e63b", "filename": "src/test/compile-fail/not-a-pred-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-3.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "8ba91d0e26e54aa147c9b4664e7a45f5e2fcdbd5", "filename": "src/test/compile-fail/not-a-pred-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "80e227ffb161198aaf5d013d099fefda136edb4c", "filename": "src/test/compile-fail/not-a-pred.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "6ba399ba00cb96b2e4608a5d9e0e6c735503f29e", "filename": "src/test/compile-fail/not-pred-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "6c600158d21ef23ea7e75429fcfb334c9afd8748", "filename": "src/test/compile-fail/occurs-check-2.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "aba5b5c5928281332749b3cdc5525080e238e4f8", "filename": "src/test/compile-fail/occurs-check.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "8103864c154c9b804b4ad878b5f0a2ddac3c0353", "filename": "src/test/compile-fail/or-init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2For-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2For-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2For-init.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "dc71c2c1e42a4b01e46dadf73ace7212ac25393e", "filename": "src/test/compile-fail/or-patter-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "c4ec5bef8c65423a87137a226be5f4358a2f4701", "filename": "src/test/compile-fail/output-type-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Foutput-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Foutput-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foutput-type-mismatch.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "10c6f1443ec8f4a17eba6febb8a17b6649066d96", "filename": "src/test/compile-fail/pred-assign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "50344120a98e81ea23dd95d85209f9d93daa3a15", "filename": "src/test/compile-fail/pred-not-bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fpred-not-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fpred-not-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-not-bool.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "9e6c86c0737d8b52658c6977c5c9e993180b4493", "filename": "src/test/compile-fail/pred-on-wrong-slots.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "8fe7b19acf56da94975581c1e42a678c1aa3ee24", "filename": "src/test/compile-fail/pred-swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "35f884fbff9ee5bc74134e75950a704132da13e3", "filename": "src/test/compile-fail/rec-extend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Frec-extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Frec-extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frec-extend.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "50bcf32dd7f5f3d553494defad9119332e9a1eee", "filename": "src/test/compile-fail/rec-missing-fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "71db7e4192f591a4cee1759a4222ba065d554f1d", "filename": "src/test/compile-fail/ret-non-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "1978ec5f420be081b006e8f280d8461e3214c309", "filename": "src/test/compile-fail/return-uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "6261fda60ac1bb1b0421a31531a2135a1eea6763", "filename": "src/test/compile-fail/self-call-non-obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fself-call-non-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fself-call-non-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-call-non-obj.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "820ebd655f51db3eb01a242524bd9c5b7d13237d", "filename": "src/test/compile-fail/slot-as-pred.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "4d3d13373dc93d4c2f030d1add802867716146bd", "filename": "src/test/compile-fail/spawn-non-nil-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "2bb54464157d236fe26be79c61f178217d259a4f", "filename": "src/test/compile-fail/swap-no-lval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "27fdc61137982f9b902cd05064b89cd2c0a31861", "filename": "src/test/compile-fail/swap-uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fswap-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fswap-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fswap-uninit.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "c121458f233d950644b45b42db406fd2cd94959e", "filename": "src/test/compile-fail/tail-typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftail-typeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftail-typeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftail-typeck.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "19be0933c48d3a706420fe016ff8e67e5c1026e0", "filename": "src/test/compile-fail/type-arg-out-of-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "363af271986999676f9b1c64fec8e0abe4875a8a", "filename": "src/test/compile-fail/type-mismatch-multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "d2ddf61b0bc082b155f2a472d43a72d9b82d35d3", "filename": "src/test/compile-fail/type-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftype-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftype-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-mismatch.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "c38c6f5d244912f0766d13ae000fb3749870289f", "filename": "src/test/compile-fail/type-recursive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "9f26de765bed730200b4f3c55a9f9080b4c01914", "filename": "src/test/compile-fail/type-shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "ee637fed666eac36ef68c2e011a8b3f8533573e0", "filename": "src/test/compile-fail/unreachable-arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "ad7296ef1b4488d0831318a219f66ad1ebb5024f", "filename": "src/test/compile-fail/unsafe-alias-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "80eaa661d1d6f4e96d59eab3278f16ee5d751e08", "filename": "src/test/compile-fail/unsafe-alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "fb42b188a7cf4767a1e35d81b3ab992bff0e16b1", "filename": "src/test/compile-fail/unsafe-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "22d5396c1cbcda0b169039c70620d93b8210e32e", "filename": "src/test/compile-fail/unsafe-for.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "2f2a395778eaa206cf0352cf7df2c9f22151b5ab", "filename": "src/test/compile-fail/unsafe-mutable-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "3fb1827441e5df13e087038643a9e57c9917902b", "filename": "src/test/compile-fail/use-after-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "965c262237dbe72e7a10145957b05cfbb13f6cb1", "filename": "src/test/compile-fail/use-after-send.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "04d67263c36704dcc2a927a07a5eeeda00f6a5e8", "filename": "src/test/compile-fail/use-meta-dup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-meta-dup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-meta-dup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-meta-dup.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "fef50525a1e737fb165ed7828daf15ed0b5393f2", "filename": "src/test/compile-fail/use-meta-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-meta-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-meta-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-meta-mismatch.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "4d35567ea4f9c00c0f06e873866f444253aad3dd", "filename": "src/test/compile-fail/use-uninit-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "5b7c619f36f8b384ff61a73a187e831e14fdcdf1", "filename": "src/test/compile-fail/use-uninit-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-uninit-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-uninit-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit-3.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "75e60bdbce3c89abe532d92a2266f081e9e537c0", "filename": "src/test/compile-fail/use-uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "1ec888670c49e27d4f9714aa25e8fc6594a7d2ca", "filename": "src/test/compile-fail/vec-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-field.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "80463e3ead383f1ae1ea53d71a590b2fd6bb0283", "filename": "src/test/compile-fail/vector-no-ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "e70090dd59ea27b8333ce025d21c574a6e242172", "filename": "src/test/compile-fail/while-bypass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwhile-bypass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwhile-bypass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-bypass.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "5ff3adf34c300fdb7f7237ae2c7d96f3042507b6", "filename": "src/test/compile-fail/while-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwhile-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwhile-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-expr.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "557ff099cbf5141b3b128d9b6c68a02b1f3cb719", "filename": "src/test/compile-fail/while-loop-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwhile-loop-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwhile-loop-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-loop-constraints.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "5920d25230fa4f66064e821a7ffa8f440a53d77d", "filename": "src/test/compile-fail/while-loop-pred-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwhile-loop-pred-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwhile-loop-pred-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-loop-pred-constraints.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "2cfcb31ccbc351574afe544e9814faddcdbb2afe", "filename": "src/test/compile-fail/writing-through-read-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "0462824c276e92b1c32885bdf5c147cc441f811f", "filename": "src/test/compile-fail/writing-through-uninit-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwriting-through-uninit-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwriting-through-uninit-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-through-uninit-vec.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "cc35f54512006d876409f8fc5e9e6d303f2a2a96", "filename": "src/test/compile-fail/writing-to-immutable-obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-obj.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "ad0ceed8ee30c0b86e83d4383ba679552c01608a", "filename": "src/test/compile-fail/writing-to-immutable-rec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-rec.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "6f0f7c5350406520eeb0145bc7b26295a76ef23f", "filename": "src/test/compile-fail/writing-to-immutable-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "82293a8f706bb9b3c775795b4b522a33ee0c26b7", "filename": "src/test/compile-fail/wrong-ret-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwrong-ret-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompile-fail%2Fwrong-ret-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwrong-ret-type.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "ab0415fd7c12662afdde88131fa969781a290ef9", "filename": "src/test/compiletest/common.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcommon.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "d045875e295bd13c4cd0823bc6642484f779ebbe", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 43, "deletions": 51, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "6e464038b185830c8bfe4059b7297604864d2406", "filename": "src/test/compiletest/procsrv.rs", "status": "modified", "additions": 40, "deletions": 53, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fprocsrv.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "c3572e20cbaeeb0ae922f5977f1bfa3df8981ce4", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 85, "deletions": 108, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "3dcd8699927a8e123ea96fedd688b968fe23134e", "filename": "src/test/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Futil.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "252eb0270dad463835c64a64093349dec250a5dc", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 10, "deletions": 42, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "e598e96db24aa3385c337032355cb81b0ecf313a", "filename": "src/test/pretty/empty-lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Fempty-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Fempty-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fempty-lines.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "852b9f316ce0fca5bf0662b3136f406d01abd30e", "filename": "src/test/pretty/example2.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Fexample2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Fexample2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fexample2.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "0f67570e72280b57b8a3e7ed5dd9b0037241f288", "filename": "src/test/pretty/unary-op-disambig.rs", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Funary-op-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Funary-op-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Funary-op-disambig.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "2cd5fffdf7598f476e0ce30786f9b5429a86f6c6", "filename": "src/test/pretty/vec-comments.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Fvec-comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Fvec-comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-comments.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "60265eebcf7f89a3108eb1f6cb8cfcd95432947e", "filename": "src/test/pretty/vec-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Fvec-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Fpretty%2Fvec-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-type.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "355892d5a13e1629a9f302be15658bf8d2213aec", "filename": "src/test/run-fail/alt-bot-fail.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "2ac519e64194e6a4150433cd89fcb8261fbd071b", "filename": "src/test/run-fail/alt-disc-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "afdaa553ba6659352d5b4c9936a9b7839205649a", "filename": "src/test/run-fail/args-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fargs-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fargs-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fargs-fail.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "aa4d829a100520c0476a5b36a4dd8ef716fede05", "filename": "src/test/run-fail/bug-811.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "3ab257de397fb28538fc8dd6ee6756866f61f5db", "filename": "src/test/run-fail/do-while-body-fails.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fdo-while-body-fails.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fdo-while-body-fails.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdo-while-body-fails.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "b45e443759c51206c7ac13feeb8fc33c553407ae", "filename": "src/test/run-fail/explicit-fail-msg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "396f12d5caf51cb4a0d9f01c8947fb3c89e797ae", "filename": "src/test/run-fail/explicit-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "bf6898ed2971f8edce5b10d8952e86b3da7cd67f", "filename": "src/test/run-fail/expr-alt-fail-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "230497135cd32e8514984bb8f5746c6168a56b5e", "filename": "src/test/run-fail/expr-alt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "24d0fa4c4aaf51f2e37d5ff91a6de2e09939f8b8", "filename": "src/test/run-fail/expr-fn-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexpr-fn-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexpr-fn-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-fn-fail.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "406302532fa203e628e310153449b0ba6df48028", "filename": "src/test/run-fail/expr-if-fail-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexpr-if-fail-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexpr-if-fail-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-if-fail-fn.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "24cd815c244e9894acbedd46b3fd7d898faa66de", "filename": "src/test/run-fail/expr-if-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexpr-if-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fexpr-if-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-if-fail.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "e657bf7d9a6ecd75b740a910cdb5f62c74187c8d", "filename": "src/test/run-fail/fail-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffail-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffail-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-arg.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "a8e5100935203722b96853c30ffb0be386894988", "filename": "src/test/run-fail/fail-main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffail-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffail-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-main.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "75e6f7e886e1873ad64f7c19119c79306faba7a0", "filename": "src/test/run-fail/fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "2d3e35b41af1277429e731fde3bde94cafbcf06c", "filename": "src/test/run-fail/fmt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffmt-fail.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "a5309b616272035f31947180b46fed658f9883e7", "filename": "src/test/run-fail/fn-constraint-claim.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "3499d44ceff428dfb5aa9ca87fcd103a5224d1d9", "filename": "src/test/run-fail/fn-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "885c92deab8fb6d43a1fba4bd338b266a761480d", "filename": "src/test/run-fail/if-check-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-check-fail.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "4afd83c1b97e509e6050f0b2d32705ddea6e7239", "filename": "src/test/run-fail/non-exhaustive-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fnon-exhaustive-match.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "a2f9420825c6215fd46b5a2028a6476cd249d738", "filename": "src/test/run-fail/pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fpred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fpred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpred.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "461b2c65b44c8fb6237af5233aa1c0d1032877ca", "filename": "src/test/run-fail/rhs-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Frhs-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Frhs-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frhs-type.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "3d12bce20c9159cd515f92e69af27d3fa515f988", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "54329ca63b5566271c249d8a19491fc74fd3c26d", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "87c8295840ecb8982b0fbd37217674ea95c3fac7", "filename": "src/test/run-fail/vec-underrun.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}, {"sha": "6077bbf6723b8a98065f2f742000c97551c3e18a", "filename": "src/test/run-pass/alloca-from-derived-tydesc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518dc52f85c2efb67aaa1208c02e9a7e0bdaca49/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs?ref=518dc52f85c2efb67aaa1208c02e9a7e0bdaca49"}]}