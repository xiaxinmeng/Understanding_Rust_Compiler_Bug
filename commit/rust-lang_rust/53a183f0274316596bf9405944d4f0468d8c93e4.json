{"sha": "53a183f0274316596bf9405944d4f0468d8c93e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYTE4M2YwMjc0MzE2NTk2YmY5NDA1OTQ0ZDRmMDQ2OGQ4YzkzZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-26T18:43:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-26T18:43:56Z"}, "message": "Auto merge of #23359 - erickt:quote, r=pnkfelix\n\nThis PR allows the quote macros to unquote trait items, impl items, where clauses, and paths.", "tree": {"sha": "76fc0dfd1e757dffa30f5d317a9bba19d24b609f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76fc0dfd1e757dffa30f5d317a9bba19d24b609f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53a183f0274316596bf9405944d4f0468d8c93e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53a183f0274316596bf9405944d4f0468d8c93e4", "html_url": "https://github.com/rust-lang/rust/commit/53a183f0274316596bf9405944d4f0468d8c93e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53a183f0274316596bf9405944d4f0468d8c93e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "199bdcfeff5cfafd1f8e8ff583d7209272469879", "url": "https://api.github.com/repos/rust-lang/rust/commits/199bdcfeff5cfafd1f8e8ff583d7209272469879", "html_url": "https://github.com/rust-lang/rust/commit/199bdcfeff5cfafd1f8e8ff583d7209272469879"}, {"sha": "a17f5563b855cfaa1be0c1564a1e484dbb8e97a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a17f5563b855cfaa1be0c1564a1e484dbb8e97a2", "html_url": "https://github.com/rust-lang/rust/commit/a17f5563b855cfaa1be0c1564a1e484dbb8e97a2"}], "stats": {"total": 70, "additions": 41, "deletions": 29}, "files": [{"sha": "5bbcdea879dff3d90d64303daa33c0fdb71ff40a", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53a183f0274316596bf9405944d4f0468d8c93e4/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a183f0274316596bf9405944d4f0468d8c93e4/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=53a183f0274316596bf9405944d4f0468d8c93e4", "patch": "@@ -171,10 +171,12 @@ pub mod rt {\n         }\n     }\n \n+    impl_to_source! { ast::Path, path_to_string }\n     impl_to_source! { ast::Ty, ty_to_string }\n     impl_to_source! { ast::Block, block_to_string }\n     impl_to_source! { ast::Arg, arg_to_string }\n     impl_to_source! { Generics, generics_to_string }\n+    impl_to_source! { ast::WhereClause, where_clause_to_string }\n     impl_to_source! { P<ast::Item>, item_to_string }\n     impl_to_source! { P<ast::ImplItem>, impl_item_to_string }\n     impl_to_source! { P<ast::TraitItem>, trait_item_to_string }\n@@ -310,6 +312,7 @@ pub mod rt {\n     }\n \n     impl_to_tokens! { ast::Ident }\n+    impl_to_tokens! { ast::Path }\n     impl_to_tokens! { P<ast::Item> }\n     impl_to_tokens! { P<ast::ImplItem> }\n     impl_to_tokens! { P<ast::TraitItem> }\n@@ -319,6 +322,7 @@ pub mod rt {\n     impl_to_tokens! { ast::Ty }\n     impl_to_tokens_lifetime! { &'a [ast::Ty] }\n     impl_to_tokens! { Generics }\n+    impl_to_tokens! { ast::WhereClause }\n     impl_to_tokens! { P<ast::Stmt> }\n     impl_to_tokens! { P<ast::Expr> }\n     impl_to_tokens! { ast::Block }"}, {"sha": "786970ce252965f652cedb01d6c2c5e419e159ac", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/53a183f0274316596bf9405944d4f0468d8c93e4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a183f0274316596bf9405944d4f0468d8c93e4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=53a183f0274316596bf9405944d4f0468d8c93e4", "patch": "@@ -1126,7 +1126,7 @@ impl<'a> Parser<'a> {\n                     p.parse_arg_general(false)\n                 });\n \n-                p.parse_where_clause(&mut generics);\n+                generics.where_clause = p.parse_where_clause();\n                 let sig = ast::MethodSig {\n                     unsafety: style,\n                     decl: d,\n@@ -3932,9 +3932,14 @@ impl<'a> Parser<'a> {\n     /// ```\n     /// where T : Trait<U, V> + 'b, 'a : 'b\n     /// ```\n-    fn parse_where_clause(&mut self, generics: &mut ast::Generics) {\n+    fn parse_where_clause(&mut self) -> ast::WhereClause {\n+        let mut where_clause = WhereClause {\n+            id: ast::DUMMY_NODE_ID,\n+            predicates: Vec::new(),\n+        };\n+\n         if !self.eat_keyword(keywords::Where) {\n-            return\n+            return where_clause;\n         }\n \n         let mut parsed_something = false;\n@@ -3957,7 +3962,7 @@ impl<'a> Parser<'a> {\n                     let hi = self.span.hi;\n                     let span = mk_sp(lo, hi);\n \n-                    generics.where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n+                    where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n                         ast::WhereRegionPredicate {\n                             span: span,\n                             lifetime: bounded_lifetime,\n@@ -3992,7 +3997,7 @@ impl<'a> Parser<'a> {\n                                            at least one bound in it\");\n                         }\n \n-                        generics.where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n+                        where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n                                 ast::WhereBoundPredicate {\n                                     span: span,\n                                     bound_lifetimes: bound_lifetimes,\n@@ -4005,7 +4010,7 @@ impl<'a> Parser<'a> {\n                         // let ty = self.parse_ty();\n                         let hi = self.span.hi;\n                         let span = mk_sp(lo, hi);\n-                        // generics.where_clause.predicates.push(\n+                        // where_clause.predicates.push(\n                         //     ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                         //         id: ast::DUMMY_NODE_ID,\n                         //         span: span,\n@@ -4036,6 +4041,8 @@ impl<'a> Parser<'a> {\n                           \"a `where` clause must have at least one predicate \\\n                            in it\");\n         }\n+\n+        where_clause\n     }\n \n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n@@ -4354,7 +4361,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_fn(&mut self, unsafety: Unsafety, abi: abi::Abi) -> ItemInfo {\n         let (ident, mut generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(false);\n-        self.parse_where_clause(&mut generics);\n+        generics.where_clause = self.parse_where_clause();\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         (ident, ItemFn(decl, unsafety, abi, generics, body), Some(inner_attrs))\n     }\n@@ -4439,7 +4446,7 @@ impl<'a> Parser<'a> {\n             let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n                     p.parse_arg()\n                 });\n-            self.parse_where_clause(&mut generics);\n+            generics.where_clause = self.parse_where_clause();\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n             (ident, inner_attrs, MethodImplItem(ast::MethodSig {\n                 generics: generics,\n@@ -4460,7 +4467,7 @@ impl<'a> Parser<'a> {\n         // Parse supertrait bounds.\n         let bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n \n-        self.parse_where_clause(&mut tps);\n+        tps.where_clause = self.parse_where_clause();\n \n         let meths = self.parse_trait_items();\n         (ident, ItemTrait(unsafety, tps, bounds, meths), None)\n@@ -4531,7 +4538,7 @@ impl<'a> Parser<'a> {\n             if opt_trait.is_some() {\n                 ty = self.parse_ty_sum();\n             }\n-            self.parse_where_clause(&mut generics);\n+            generics.where_clause = self.parse_where_clause();\n \n             self.expect(&token::OpenDelim(token::Brace));\n             let attrs = self.parse_inner_attributes();\n@@ -4603,7 +4610,7 @@ impl<'a> Parser<'a> {\n         // struct.\n \n         let (fields, ctor_id) = if self.token.is_keyword(keywords::Where) {\n-            self.parse_where_clause(&mut generics);\n+            generics.where_clause = self.parse_where_clause();\n             if self.eat(&token::Semi) {\n                 // If we see a: `struct Foo<T> where T: Copy;` style decl.\n                 (Vec::new(), Some(ast::DUMMY_NODE_ID))\n@@ -4684,12 +4691,12 @@ impl<'a> Parser<'a> {\n                     token::get_ident(class_name.clone())));\n             }\n \n-            self.parse_where_clause(generics);\n+            generics.where_clause = self.parse_where_clause();\n             self.expect(&token::Semi);\n             fields\n         // This is the case where we just see struct Foo<T> where T: Copy;\n         } else if self.token.is_keyword(keywords::Where) {\n-            self.parse_where_clause(generics);\n+            generics.where_clause = self.parse_where_clause();\n             self.expect(&token::Semi);\n             Vec::new()\n         // This case is where we see: `struct Foo<T>;`\n@@ -4937,7 +4944,7 @@ impl<'a> Parser<'a> {\n \n         let (ident, mut generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(true);\n-        self.parse_where_clause(&mut generics);\n+        generics.where_clause = self.parse_where_clause();\n         let hi = self.span.hi;\n         self.expect(&token::Semi);\n         P(ast::ForeignItem {\n@@ -5074,7 +5081,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_type(&mut self) -> ItemInfo {\n         let ident = self.parse_ident();\n         let mut tps = self.parse_generics();\n-        self.parse_where_clause(&mut tps);\n+        tps.where_clause = self.parse_where_clause();\n         self.expect(&token::Eq);\n         let ty = self.parse_ty_sum();\n         self.expect(&token::Semi);\n@@ -5174,7 +5181,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_enum(&mut self) -> ItemInfo {\n         let id = self.parse_ident();\n         let mut generics = self.parse_generics();\n-        self.parse_where_clause(&mut generics);\n+        generics.where_clause = self.parse_where_clause();\n         self.expect(&token::OpenDelim(token::Brace));\n \n         let enum_definition = self.parse_enum_def(&generics);"}, {"sha": "da1b7a7bdde50e93ec50a11aac7702b4db45b759", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/53a183f0274316596bf9405944d4f0468d8c93e4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a183f0274316596bf9405944d4f0468d8c93e4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=53a183f0274316596bf9405944d4f0468d8c93e4", "patch": "@@ -367,6 +367,10 @@ pub fn generics_to_string(generics: &ast::Generics) -> String {\n     $to_string(|s| s.print_generics(generics))\n }\n \n+pub fn where_clause_to_string(i: &ast::WhereClause) -> String {\n+    $to_string(|s| s.print_where_clause(i))\n+}\n+\n pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n     $to_string(|s| s.print_fn_block_args(p))\n }\n@@ -917,7 +921,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_type(&**ty));\n-                try!(self.print_where_clause(params));\n+                try!(self.print_where_clause(&params.where_clause));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer ibox\n             }\n@@ -980,7 +984,7 @@ impl<'a> State<'a> {\n                 }\n \n                 try!(self.print_type(&**ty));\n-                try!(self.print_where_clause(generics));\n+                try!(self.print_where_clause(&generics.where_clause));\n \n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n@@ -1008,7 +1012,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n                 try!(self.print_bounds(\":\", &real_bounds[..]));\n-                try!(self.print_where_clause(generics));\n+                try!(self.print_where_clause(&generics.where_clause));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n                 for trait_item in trait_items {\n@@ -1066,7 +1070,7 @@ impl<'a> State<'a> {\n         try!(self.head(&visibility_qualified(visibility, \"enum\")));\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n-        try!(self.print_where_clause(generics));\n+        try!(self.print_where_clause(&generics.where_clause));\n         try!(space(&mut self.s));\n         self.print_variants(&enum_definition.variants, span)\n     }\n@@ -1120,12 +1124,12 @@ impl<'a> State<'a> {\n                 ));\n                 try!(self.pclose());\n             }\n-            try!(self.print_where_clause(generics));\n+            try!(self.print_where_clause(&generics.where_clause));\n             try!(word(&mut self.s, \";\"));\n             try!(self.end());\n             self.end() // close the outer-box\n         } else {\n-            try!(self.print_where_clause(generics));\n+            try!(self.print_where_clause(&generics.where_clause));\n             try!(self.nbsp());\n             try!(self.bopen());\n             try!(self.hardbreak_if_not_bol());\n@@ -2348,7 +2352,7 @@ impl<'a> State<'a> {\n         }\n         try!(self.print_generics(generics));\n         try!(self.print_fn_args_and_ret(decl, opt_explicit_self));\n-        self.print_where_clause(generics)\n+        self.print_where_clause(&generics.where_clause)\n     }\n \n     pub fn print_fn_args(&mut self, decl: &ast::FnDecl,\n@@ -2531,19 +2535,16 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_where_clause(&mut self, generics: &ast::Generics)\n+    pub fn print_where_clause(&mut self, where_clause: &ast::WhereClause)\n                               -> io::Result<()> {\n-        if generics.where_clause.predicates.len() == 0 {\n+        if where_clause.predicates.len() == 0 {\n             return Ok(())\n         }\n \n         try!(space(&mut self.s));\n         try!(self.word_space(\"where\"));\n \n-        for (i, predicate) in generics.where_clause\n-                                      .predicates\n-                                      .iter()\n-                                      .enumerate() {\n+        for (i, predicate) in where_clause.predicates.iter().enumerate() {\n             if i != 0 {\n                 try!(self.word_space(\",\"));\n             }"}]}