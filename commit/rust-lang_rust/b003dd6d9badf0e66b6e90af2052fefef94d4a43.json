{"sha": "b003dd6d9badf0e66b6e90af2052fefef94d4a43", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMDNkZDZkOWJhZGYwZTY2YjZlOTBhZjIwNTJmZWZlZjk0ZDRhNDM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-07T15:55:29Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-10T21:12:57Z"}, "message": "expand: Merge `expand_{bang,attr,derive}_invoc` into a single function\n\nIt's more convenient to have all this highly related stuff together on one screen (for future refactorings).\nThe `expand_invoc` function is compact enough now, after all the previous refactorings.", "tree": {"sha": "9484511e257ea720bff4c751c09bd769e21dcb46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9484511e257ea720bff4c751c09bd769e21dcb46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b003dd6d9badf0e66b6e90af2052fefef94d4a43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b003dd6d9badf0e66b6e90af2052fefef94d4a43", "html_url": "https://github.com/rust-lang/rust/commit/b003dd6d9badf0e66b6e90af2052fefef94d4a43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b003dd6d9badf0e66b6e90af2052fefef94d4a43/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "374a80a86de4dabae4975fae04fb67cc6e6dc0bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/374a80a86de4dabae4975fae04fb67cc6e6dc0bb", "html_url": "https://github.com/rust-lang/rust/commit/374a80a86de4dabae4975fae04fb67cc6e6dc0bb"}], "stats": {"total": 196, "additions": 79, "deletions": 117}, "files": [{"sha": "f1235e7174f2c8e9d35ce3d8d20acfa9f40feb9e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 78, "deletions": 116, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/b003dd6d9badf0e66b6e90af2052fefef94d4a43/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b003dd6d9badf0e66b6e90af2052fefef94d4a43/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b003dd6d9badf0e66b6e90af2052fefef94d4a43", "patch": "@@ -327,7 +327,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             // FIXME(jseyfried): Refactor out the following logic\n             let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n-                let fragment = self.expand_invoc(invoc, &ext);\n+                let fragment = self.expand_invoc(invoc, &ext.kind);\n                 self.collect_invocations(fragment, &[])\n             } else if let InvocationKind::Attr { attr: None, traits, item, .. } = invoc.kind {\n                 if !item.derive_allowed() {\n@@ -474,12 +474,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> AstFragment {\n-        if invoc.fragment_kind == AstFragmentKind::ForeignItems &&\n-           !self.cx.ecfg.macros_in_extern() {\n-            if let SyntaxExtensionKind::NonMacroAttr { .. } = ext.kind {} else {\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtensionKind) -> AstFragment {\n+        let (fragment_kind, span) = (invoc.fragment_kind, invoc.span());\n+        if fragment_kind == AstFragmentKind::ForeignItems && !self.cx.ecfg.macros_in_extern() {\n+            if let SyntaxExtensionKind::NonMacroAttr { .. } = ext {} else {\n                 emit_feature_err(&self.cx.parse_sess, sym::macros_in_extern,\n-                                 invoc.span(), GateIssue::Language,\n+                                 span, GateIssue::Language,\n                                  \"macro invocations in `extern {}` blocks are experimental\");\n             }\n         }\n@@ -499,58 +499,84 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         match invoc.kind {\n-            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n-            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n-            InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext),\n-        }\n-    }\n-\n-    fn expand_attr_invoc(&mut self,\n-                         invoc: Invocation,\n-                         ext: &SyntaxExtension)\n-                         -> AstFragment {\n-        let (attr, mut item) = match invoc.kind {\n-            InvocationKind::Attr { attr: Some(attr), item, .. } => (attr, item),\n-            _ => unreachable!(),\n-        };\n-\n-        match &ext.kind {\n-            SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n-                attr::mark_known(&attr);\n-                if *mark_used {\n-                    attr::mark_used(&attr);\n+            InvocationKind::Bang { mac, .. } => match ext {\n+                SyntaxExtensionKind::Bang(expander) => {\n+                    self.gate_proc_macro_expansion_kind(span, fragment_kind);\n+                    let tok_result = expander.expand(self.cx, span, mac.node.stream());\n+                    let result =\n+                        self.parse_ast_fragment(tok_result, fragment_kind, &mac.node.path, span);\n+                    self.gate_proc_macro_expansion(span, &result);\n+                    result\n+                }\n+                SyntaxExtensionKind::LegacyBang(expander) => {\n+                    let tok_result = expander.expand(self.cx, span, mac.node.stream());\n+                    if let Some(result) = fragment_kind.make_from(tok_result) {\n+                        result\n+                    } else {\n+                        let msg = format!(\"non-{kind} macro in {kind} position: {path}\",\n+                                          kind = fragment_kind.name(), path = mac.node.path);\n+                        self.cx.span_err(span, &msg);\n+                        self.cx.trace_macros_diag();\n+                        fragment_kind.dummy(span)\n+                    }\n                 }\n-                item.visit_attrs(|attrs| attrs.push(attr));\n-                invoc.fragment_kind.expect_from_annotatables(iter::once(item))\n+                _ => unreachable!()\n             }\n-            SyntaxExtensionKind::LegacyAttr(expander) => {\n-                match attr.parse_meta(self.cx.parse_sess) {\n-                    Ok(meta) => {\n-                        let item = expander.expand(self.cx, attr.span, &meta, item);\n-                        invoc.fragment_kind.expect_from_annotatables(item)\n+            InvocationKind::Attr { attr: Some(attr), mut item, .. } => match ext {\n+                SyntaxExtensionKind::Attr(expander) => {\n+                    self.gate_proc_macro_attr_item(span, &item);\n+                    let item_tok = TokenTree::token(token::Interpolated(Lrc::new(match item {\n+                        Annotatable::Item(item) => token::NtItem(item),\n+                        Annotatable::TraitItem(item) => token::NtTraitItem(item.into_inner()),\n+                        Annotatable::ImplItem(item) => token::NtImplItem(item.into_inner()),\n+                        Annotatable::ForeignItem(item) => token::NtForeignItem(item.into_inner()),\n+                        Annotatable::Stmt(stmt) => token::NtStmt(stmt.into_inner()),\n+                        Annotatable::Expr(expr) => token::NtExpr(expr),\n+                    })), DUMMY_SP).into();\n+                    let input = self.extract_proc_macro_attr_input(attr.tokens, span);\n+                    let tok_result = expander.expand(self.cx, span, input, item_tok);\n+                    let res = self.parse_ast_fragment(tok_result, fragment_kind, &attr.path, span);\n+                    self.gate_proc_macro_expansion(span, &res);\n+                    res\n+                }\n+                SyntaxExtensionKind::LegacyAttr(expander) => {\n+                    match attr.parse_meta(self.cx.parse_sess) {\n+                        Ok(meta) => {\n+                            let item = expander.expand(self.cx, span, &meta, item);\n+                            fragment_kind.expect_from_annotatables(item)\n+                        }\n+                        Err(mut err) => {\n+                            err.emit();\n+                            fragment_kind.dummy(span)\n+                        }\n                     }\n-                    Err(mut err) => {\n-                        err.emit();\n-                        invoc.fragment_kind.dummy(attr.span)\n+                }\n+                SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n+                    attr::mark_known(&attr);\n+                    if *mark_used {\n+                        attr::mark_used(&attr);\n                     }\n+                    item.visit_attrs(|attrs| attrs.push(attr));\n+                    fragment_kind.expect_from_annotatables(iter::once(item))\n                 }\n+                _ => unreachable!()\n             }\n-            SyntaxExtensionKind::Attr(expander) => {\n-                self.gate_proc_macro_attr_item(attr.span, &item);\n-                let item_tok = TokenTree::token(token::Interpolated(Lrc::new(match item {\n-                    Annotatable::Item(item) => token::NtItem(item),\n-                    Annotatable::TraitItem(item) => token::NtTraitItem(item.into_inner()),\n-                    Annotatable::ImplItem(item) => token::NtImplItem(item.into_inner()),\n-                    Annotatable::ForeignItem(item) => token::NtForeignItem(item.into_inner()),\n-                    Annotatable::Stmt(stmt) => token::NtStmt(stmt.into_inner()),\n-                    Annotatable::Expr(expr) => token::NtExpr(expr),\n-                })), DUMMY_SP).into();\n-                let input = self.extract_proc_macro_attr_input(attr.tokens, attr.span);\n-                let tok_result = expander.expand(self.cx, attr.span, input, item_tok);\n-                let res = self.parse_ast_fragment(tok_result, invoc.fragment_kind,\n-                                                  &attr.path, attr.span);\n-                self.gate_proc_macro_expansion(attr.span, &res);\n-                res\n+            InvocationKind::Derive { path, item, item_with_markers } => match ext {\n+                SyntaxExtensionKind::Derive(expander) |\n+                SyntaxExtensionKind::LegacyDerive(expander) => {\n+                    let (path, item) = match ext {\n+                        SyntaxExtensionKind::LegacyDerive(..) => (path, item_with_markers),\n+                        _ => (path, item),\n+                    };\n+                    if !item.derive_allowed() {\n+                        return fragment_kind.dummy(span);\n+                    }\n+                    let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span, path };\n+                    let span = span.with_ctxt(self.cx.backtrace());\n+                    let items = expander.expand(self.cx, span, &meta, item);\n+                    fragment_kind.expect_from_annotatables(items)\n+                }\n+                _ => unreachable!()\n             }\n             _ => unreachable!()\n         }\n@@ -634,42 +660,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    /// Expand a macro invocation. Returns the resulting expanded AST fragment.\n-    fn expand_bang_invoc(&mut self,\n-                         invoc: Invocation,\n-                         ext: &SyntaxExtension)\n-                         -> AstFragment {\n-        let kind = invoc.fragment_kind;\n-        let (mac, span) = match invoc.kind {\n-            InvocationKind::Bang { mac, span } => (mac, span),\n-            _ => unreachable!(),\n-        };\n-        let path = &mac.node.path;\n-\n-        match &ext.kind {\n-            SyntaxExtensionKind::Bang(expander) => {\n-                self.gate_proc_macro_expansion_kind(span, kind);\n-                let tok_result = expander.expand(self.cx, span, mac.node.stream());\n-                let result = self.parse_ast_fragment(tok_result, kind, path, span);\n-                self.gate_proc_macro_expansion(span, &result);\n-                result\n-            }\n-            SyntaxExtensionKind::LegacyBang(expander) => {\n-                let tok_result = expander.expand(self.cx, span, mac.node.stream());\n-                if let Some(result) = kind.make_from(tok_result) {\n-                    result\n-                } else {\n-                    let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n-                                    name = path.segments[0].ident.name, kind = kind.name());\n-                    self.cx.span_err(path.span, &msg);\n-                    self.cx.trace_macros_diag();\n-                    kind.dummy(span)\n-                }\n-            }\n-            _ => unreachable!()\n-        }\n-    }\n-\n     fn gate_proc_macro_expansion_kind(&self, span: Span, kind: AstFragmentKind) {\n         let kind = match kind {\n             AstFragmentKind::Expr => \"expressions\",\n@@ -694,34 +684,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         );\n     }\n \n-    /// Expand a derive invocation. Returns the resulting expanded AST fragment.\n-    fn expand_derive_invoc(&mut self,\n-                           invoc: Invocation,\n-                           ext: &SyntaxExtension)\n-                           -> AstFragment {\n-        let (path, item) = match invoc.kind {\n-            InvocationKind::Derive { path, item, item_with_markers } => match ext.kind {\n-                SyntaxExtensionKind::LegacyDerive(..) => (path, item_with_markers),\n-                _ => (path, item),\n-            }\n-            _ => unreachable!(),\n-        };\n-        if !item.derive_allowed() {\n-            return invoc.fragment_kind.dummy(path.span);\n-        }\n-\n-        match &ext.kind {\n-            SyntaxExtensionKind::Derive(expander) |\n-            SyntaxExtensionKind::LegacyDerive(expander) => {\n-                let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span: path.span, path };\n-                let span = meta.span.with_ctxt(self.cx.backtrace());\n-                let items = expander.expand(self.cx, span, &meta, item);\n-                invoc.fragment_kind.expect_from_annotatables(items)\n-            }\n-            _ => unreachable!()\n-        }\n-    }\n-\n     fn parse_ast_fragment(&mut self,\n                           toks: TokenStream,\n                           kind: AstFragmentKind,"}, {"sha": "2539a6d51561caa8788c21431c94d919b1a9ad70", "filename": "src/test/ui/macros/macro-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b003dd6d9badf0e66b6e90af2052fefef94d4a43/src%2Ftest%2Fui%2Fmacros%2Fmacro-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b003dd6d9badf0e66b6e90af2052fefef94d4a43/src%2Ftest%2Fui%2Fmacros%2Fmacro-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-error.stderr?ref=b003dd6d9badf0e66b6e90af2052fefef94d4a43", "patch": "@@ -8,7 +8,7 @@ error: non-type macro in type position: cfg\n   --> $DIR/macro-error.rs:8:12\n    |\n LL |     let _: cfg!(foo) = ();\n-   |            ^^^\n+   |            ^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}]}