{"sha": "f9ef8cd55512842f2481aac6332dbfb92df58c52", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZWY4Y2Q1NTUxMjg0MmYyNDgxYWFjNjMzMmRiZmI5MmRmNThjNTI=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-01-27T13:09:18Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-02-19T23:57:38Z"}, "message": "Refactored code into Searcher traits with naive implementations\n\nMade the family of Split iterators use the Pattern API\n\nRenamed the Matcher traits into Searcher", "tree": {"sha": "ca3ad91d959a4cc95780dfed26f40337ffc72014", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca3ad91d959a4cc95780dfed26f40337ffc72014"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9ef8cd55512842f2481aac6332dbfb92df58c52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9ef8cd55512842f2481aac6332dbfb92df58c52", "html_url": "https://github.com/rust-lang/rust/commit/f9ef8cd55512842f2481aac6332dbfb92df58c52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9ef8cd55512842f2481aac6332dbfb92df58c52/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13ea9062a918e3e60d82186135610a575bf92394", "url": "https://api.github.com/repos/rust-lang/rust/commits/13ea9062a918e3e60d82186135610a575bf92394", "html_url": "https://github.com/rust-lang/rust/commit/13ea9062a918e3e60d82186135610a575bf92394"}], "stats": {"total": 866, "additions": 476, "deletions": 390}, "files": [{"sha": "30de253fbad42891d239d7bdc5a028395a379a1a", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=f9ef8cd55512842f2481aac6332dbfb92df58c52", "patch": "@@ -23,7 +23,7 @@\n #![feature(env)]\n #![feature(core)]\n \n-#![deny(warnings)]\n+// #![deny(warnings)]\n \n extern crate test;\n extern crate getopts;"}, {"sha": "dff331ac6200769d04c8d04e96a0cddf57372c99", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=f9ef8cd55512842f2481aac6332dbfb92df58c52", "patch": "@@ -706,7 +706,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"might have its iterator type changed\")]\n-    fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n+    fn match_indices<'a, 'b>(&'a self, pat: &'b str) -> MatchIndices<'a, &'b str> {\n         core_str::StrExt::match_indices(&self[..], pat)\n     }\n \n@@ -723,7 +723,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"might get removed in the future in favor of a more generic split()\")]\n-    fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n+    fn split_str<'a, 'b>(&'a self, pat: &'b str) -> SplitStr<'a, &'b str> {\n         core_str::StrExt::split_str(&self[..], pat)\n     }\n "}, {"sha": "8e27ae1cea97039342dceb76b1e04b541d6faa41", "filename": "src/libcore/char.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=f9ef8cd55512842f2481aac6332dbfb92df58c52", "patch": "@@ -22,13 +22,13 @@ use option::Option;\n use slice::SliceExt;\n \n // UTF-8 ranges and tags for encoding characters\n-static TAG_CONT: u8    = 0b1000_0000u8;\n-static TAG_TWO_B: u8   = 0b1100_0000u8;\n-static TAG_THREE_B: u8 = 0b1110_0000u8;\n-static TAG_FOUR_B: u8  = 0b1111_0000u8;\n-static MAX_ONE_B: u32   =     0x80u32;\n-static MAX_TWO_B: u32   =    0x800u32;\n-static MAX_THREE_B: u32 =  0x10000u32;\n+const TAG_CONT: u8    = 0b1000_0000u8;\n+const TAG_TWO_B: u8   = 0b1100_0000u8;\n+const TAG_THREE_B: u8 = 0b1110_0000u8;\n+const TAG_FOUR_B: u8  = 0b1111_0000u8;\n+const MAX_ONE_B: u32   =     0x80u32;\n+const MAX_TWO_B: u32   =    0x800u32;\n+const MAX_THREE_B: u32 =  0x10000u32;\n \n /*\n     Lu  Uppercase_Letter        an uppercase letter\n@@ -398,11 +398,14 @@ impl CharExt for char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> usize {\n         let code = self as u32;\n-        match () {\n-            _ if code < MAX_ONE_B   => 1,\n-            _ if code < MAX_TWO_B   => 2,\n-            _ if code < MAX_THREE_B => 3,\n-            _  => 4,\n+        if code < MAX_ONE_B {\n+            1\n+        } else if code < MAX_TWO_B {\n+            2\n+        } else if code < MAX_THREE_B {\n+            3\n+        } else {\n+            4\n         }\n     }\n "}, {"sha": "2debcaa5813421c0951b434f85c8b01f44001c1d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=f9ef8cd55512842f2481aac6332dbfb92df58c52", "patch": "@@ -657,6 +657,8 @@ macro_rules! iterator {\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n+                    ::intrinsics::assume(!self.ptr.is_null());\n+                    ::intrinsics::assume(!self.end.is_null());\n                     if self.ptr == self.end {\n                         None\n                     } else {\n@@ -693,6 +695,8 @@ macro_rules! iterator {\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n+                    ::intrinsics::assume(!self.ptr.is_null());\n+                    ::intrinsics::assume(!self.end.is_null());\n                     if self.end == self.ptr {\n                         None\n                     } else {"}, {"sha": "bdb3b854fe2c0142501f6f9f0a2c566b19baad5a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 232, "deletions": 334, "changes": 566, "blob_url": "https://github.com/rust-lang/rust/blob/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=f9ef8cd55512842f2481aac6332dbfb92df58c52", "patch": "@@ -16,7 +16,7 @@\n \n #![doc(primitive = \"str\")]\n \n-use self::Searcher::{Naive, TwoWay, TwoWayLong};\n+use self::OldSearcher::{TwoWay, TwoWayLong};\n \n use clone::Clone;\n use cmp::{self, Eq};\n@@ -35,9 +35,9 @@ use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n use usize;\n-use clone::Clone;\n \n-pub use self::pattern::{Pattern, Matcher, ReverseMatcher, DoubleEndedMatcher};\n+pub use self::pattern::Pattern;\n+pub use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher, SearchStep};\n \n mod pattern;\n \n@@ -46,7 +46,7 @@ macro_rules! delegate_iter {\n         delegate_iter!{$te : $ti}\n         impl<'a> ExactSizeIterator for $ti {\n             #[inline]\n-            fn len(&self) -> uint {\n+            fn len(&self) -> usize {\n                 self.0.len()\n             }\n         }\n@@ -61,7 +61,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -83,7 +83,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -105,7 +105,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -184,7 +184,7 @@ pub enum Utf8Error {\n     /// The offset is guaranteed to be in bounds of the slice in question, and\n     /// the byte at the specified offset was the first invalid byte in the\n     /// sequence detected.\n-    InvalidByte(uint),\n+    InvalidByte(usize),\n \n     /// The byte slice was invalid because more bytes were needed but no more\n     /// bytes were available.\n@@ -256,7 +256,7 @@ impl CharEq for char {\n     fn matches(&mut self, c: char) -> bool { *self == c }\n \n     #[inline]\n-    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n+    fn only_ascii(&self) -> bool { (*self as usize) < 128 }\n }\n \n impl<F> CharEq for F where F: FnMut(char) -> bool {\n@@ -343,6 +343,7 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n /// Reads the next code point out of a byte iterator (assuming a\n /// UTF-8-like encoding).\n #[unstable(feature = \"core\")]\n+#[inline]\n pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Decode UTF-8\n     let x = match bytes.next() {\n@@ -374,6 +375,38 @@ pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     Some(ch)\n }\n \n+/// Reads the last code point out of a byte iterator (assuming a\n+/// UTF-8-like encoding).\n+#[unstable(feature = \"core\")]\n+#[inline]\n+pub fn next_code_point_reverse(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n+    // Decode UTF-8\n+    let w = match bytes.next_back() {\n+        None => return None,\n+        Some(&next_byte) if next_byte < 128 => return Some(next_byte as u32),\n+        Some(&back_byte) => back_byte,\n+    };\n+\n+    // Multibyte case follows\n+    // Decode from a byte combination out of: [x [y [z w]]]\n+    let mut ch;\n+    let z = unwrap_or_0(bytes.next_back());\n+    ch = utf8_first_byte!(z, 2);\n+    if utf8_is_cont_byte!(z) {\n+        let y = unwrap_or_0(bytes.next_back());\n+        ch = utf8_first_byte!(y, 3);\n+        if utf8_is_cont_byte!(y) {\n+            let x = unwrap_or_0(bytes.next_back());\n+            ch = utf8_first_byte!(x, 4);\n+            ch = utf8_acc_cont_byte!(ch, y);\n+        }\n+        ch = utf8_acc_cont_byte!(ch, z);\n+    }\n+    ch = utf8_acc_cont_byte!(ch, w);\n+\n+    Some(ch)\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n@@ -389,7 +422,7 @@ impl<'a> Iterator for Chars<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (len, _) = self.iter.size_hint();\n         (len.saturating_add(3) / 4, Some(len))\n     }\n@@ -399,33 +432,12 @@ impl<'a> Iterator for Chars<'a> {\n impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n-        let w = match self.iter.next_back() {\n-            None => return None,\n-            Some(&back_byte) if back_byte < 128 => return Some(back_byte as char),\n-            Some(&back_byte) => back_byte,\n-        };\n-\n-        // Multibyte case follows\n-        // Decode from a byte combination out of: [x [y [z w]]]\n-        let mut ch;\n-        let z = unwrap_or_0(self.iter.next_back());\n-        ch = utf8_first_byte!(z, 2);\n-        if utf8_is_cont_byte!(z) {\n-            let y = unwrap_or_0(self.iter.next_back());\n-            ch = utf8_first_byte!(y, 3);\n-            if utf8_is_cont_byte!(y) {\n-                let x = unwrap_or_0(self.iter.next_back());\n-                ch = utf8_first_byte!(x, 4);\n-                ch = utf8_acc_cont_byte!(ch, y);\n+        next_code_point_reverse(&mut self.iter).map(|ch| {\n+            // str invariant says `ch` is a valid Unicode Scalar Value\n+            unsafe {\n+                mem::transmute(ch)\n             }\n-            ch = utf8_acc_cont_byte!(ch, z);\n-        }\n-        ch = utf8_acc_cont_byte!(ch, w);\n-\n-        // str invariant says `ch` is a valid Unicode Scalar Value\n-        unsafe {\n-            Some(mem::transmute(ch))\n-        }\n+        })\n     }\n }\n \n@@ -434,16 +446,16 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n-    front_offset: uint,\n+    front_offset: usize,\n     iter: Chars<'a>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for CharIndices<'a> {\n-    type Item = (uint, char);\n+    type Item = (usize, char);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, char)> {\n+    fn next(&mut self) -> Option<(usize, char)> {\n         let (pre_len, _) = self.iter.iter.size_hint();\n         match self.iter.next() {\n             None => None,\n@@ -457,15 +469,15 @@ impl<'a> Iterator for CharIndices<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, char)> {\n+    fn next_back(&mut self) -> Option<(usize, char)> {\n         match self.iter.next_back() {\n             None => None,\n             Some(ch) => {\n@@ -501,24 +513,22 @@ impl<'a> Fn<(&'a u8,)> for BytesDeref {\n }\n \n /// An iterator over the substrings of a string, separated by `sep`.\n-#[derive(Clone)]\n-struct CharSplits<'a, Sep> {\n+struct CharSplits<'a, P: Pattern<'a>> {\n     /// The slice remaining to be iterated\n-    string: &'a str,\n-    sep: Sep,\n+    start: usize,\n+    end: usize,\n+    matcher: P::Searcher,\n     /// Whether an empty string at the end is allowed\n     allow_trailing_empty: bool,\n-    only_ascii: bool,\n     finished: bool,\n }\n \n /// An iterator over the substrings of a string, separated by `sep`,\n /// splitting at most `count` times.\n-#[derive(Clone)]\n-struct CharSplitsN<'a, Sep> {\n-    iter: CharSplits<'a, Sep>,\n+struct CharSplitsN<'a, P: Pattern<'a>> {\n+    iter: CharSplits<'a, P>,\n     /// The number of splits remaining\n-    count: uint,\n+    count: usize,\n     invert: bool,\n }\n \n@@ -534,46 +544,34 @@ pub struct LinesAny<'a> {\n     inner: Map<Lines<'a>, fn(&str) -> &str>,\n }\n \n-impl<'a, Sep> CharSplits<'a, Sep> {\n+impl<'a, P: Pattern<'a>> CharSplits<'a, P> {\n     #[inline]\n     fn get_end(&mut self) -> Option<&'a str> {\n-        if !self.finished && (self.allow_trailing_empty || self.string.len() > 0) {\n+        if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n             self.finished = true;\n-            Some(self.string)\n+            unsafe {\n+                let string = self.matcher.haystack().slice_unchecked(self.start, self.end);\n+                Some(string)\n+            }\n         } else {\n             None\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n+impl<'a, P: Pattern<'a>> Iterator for CharSplits<'a, P> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n \n-        let mut next_split = None;\n-        if self.only_ascii {\n-            for (idx, byte) in self.string.bytes().enumerate() {\n-                if self.sep.matches(byte as char) && byte < 128u8 {\n-                    next_split = Some((idx, idx + 1));\n-                    break;\n-                }\n-            }\n-        } else {\n-            for (idx, ch) in self.string.char_indices() {\n-                if self.sep.matches(ch) {\n-                    next_split = Some((idx, self.string.char_range_at(idx).next));\n-                    break;\n-                }\n-            }\n-        }\n-        match next_split {\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match() {\n             Some((a, b)) => unsafe {\n-                let elt = self.string.slice_unchecked(0, a);\n-                self.string = self.string.slice_unchecked(b, self.string.len());\n+                let elt = haystack.slice_unchecked(self.start, a);\n+                self.start = b;\n                 Some(elt)\n             },\n             None => self.get_end(),\n@@ -582,7 +580,8 @@ impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n+impl<'a, P: Pattern<'a>> DoubleEndedIterator for CharSplits<'a, P>\n+where P::Searcher: DoubleEndedSearcher<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n@@ -594,31 +593,18 @@ impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n                 _ => if self.finished { return None }\n             }\n         }\n-        let len = self.string.len();\n-        let mut next_split = None;\n-\n-        if self.only_ascii {\n-            for (idx, byte) in self.string.bytes().enumerate().rev() {\n-                if self.sep.matches(byte as char) && byte < 128u8 {\n-                    next_split = Some((idx, idx + 1));\n-                    break;\n-                }\n-            }\n-        } else {\n-            for (idx, ch) in self.string.char_indices().rev() {\n-                if self.sep.matches(ch) {\n-                    next_split = Some((idx, self.string.char_range_at(idx).next));\n-                    break;\n-                }\n-            }\n-        }\n-        match next_split {\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n             Some((a, b)) => unsafe {\n-                let elt = self.string.slice_unchecked(b, len);\n-                self.string = self.string.slice_unchecked(0, a);\n+                let elt = haystack.slice_unchecked(b, self.end);\n+                self.end = a;\n                 Some(elt)\n             },\n-            None => { self.finished = true; Some(self.string) }\n+            None => unsafe {\n+                self.finished = true;\n+                Some(haystack.slice_unchecked(self.start, self.end))\n+            },\n         }\n     }\n }\n@@ -638,44 +624,18 @@ impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n     }\n }\n \n-/// The internal state of an iterator that searches for matches of a substring\n-/// within a larger string using naive search\n-#[derive(Clone)]\n-struct NaiveSearcher {\n-    position: uint\n-}\n-\n-impl NaiveSearcher {\n-    fn new() -> NaiveSearcher {\n-        NaiveSearcher { position: 0 }\n-    }\n-\n-    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n-        while self.position + needle.len() <= haystack.len() {\n-            if &haystack[self.position .. self.position + needle.len()] == needle {\n-                let match_pos = self.position;\n-                self.position += needle.len(); // add 1 for all matches\n-                return Some((match_pos, match_pos + needle.len()));\n-            } else {\n-                self.position += 1;\n-            }\n-        }\n-        None\n-    }\n-}\n-\n /// The internal state of an iterator that searches for matches of a substring\n /// within a larger string using two-way search\n #[derive(Clone)]\n struct TwoWaySearcher {\n     // constants\n-    crit_pos: uint,\n-    period: uint,\n+    crit_pos: usize,\n+    period: usize,\n     byteset: u64,\n \n     // variables\n-    position: uint,\n-    memory: uint\n+    position: usize,\n+    memory: usize\n }\n \n /*\n@@ -749,6 +709,7 @@ struct TwoWaySearcher {\n \n */\n impl TwoWaySearcher {\n+    #[allow(dead_code)]\n     fn new(needle: &[u8]) -> TwoWaySearcher {\n         let (crit_pos_false, period_false) = TwoWaySearcher::maximal_suffix(needle, false);\n         let (crit_pos_true, period_true) = TwoWaySearcher::maximal_suffix(needle, true);\n@@ -762,7 +723,7 @@ impl TwoWaySearcher {\n \n         // This isn't in the original algorithm, as far as I'm aware.\n         let byteset = needle.iter()\n-                            .fold(0, |a, &b| (1 << ((b & 0x3f) as uint)) | a);\n+                            .fold(0, |a, &b| (1 << ((b & 0x3f) as usize)) | a);\n \n         // A particularly readable explanation of what's going on here can be found\n         // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n@@ -800,7 +761,7 @@ impl TwoWaySearcher {\n     // How far we can jump when we encounter a mismatch is all based on the fact\n     // that (u, v) is a critical factorization for the needle.\n     #[inline]\n-    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> Option<(uint, uint)> {\n+    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> Option<(usize, usize)> {\n         'search: loop {\n             // Check that we have room to search in\n             if self.position + needle.len() > haystack.len() {\n@@ -810,7 +771,7 @@ impl TwoWaySearcher {\n             // Quickly skip by large portions unrelated to our substring\n             if (self.byteset >>\n                     ((haystack[self.position + needle.len() - 1] & 0x3f)\n-                     as uint)) & 1 == 0 {\n+                     as usize)) & 1 == 0 {\n                 self.position += needle.len();\n                 if !long_period {\n                     self.memory = 0;\n@@ -857,7 +818,8 @@ impl TwoWaySearcher {\n     // Specifically, returns (i, p), where i is the starting index of v in some\n     // critical factorization (u, v) and p = period(v)\n     #[inline]\n-    fn maximal_suffix(arr: &[u8], reversed: bool) -> (uint, uint) {\n+    #[allow(dead_code)]\n+    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n         let mut left = -1; // Corresponds to i in the paper\n         let mut right = 0; // Corresponds to j in the paper\n         let mut offset = 1; // Corresponds to k in the paper\n@@ -901,26 +863,24 @@ impl TwoWaySearcher {\n /// The internal state of an iterator that searches for matches of a substring\n /// within a larger string using a dynamically chosen search algorithm\n #[derive(Clone)]\n-enum Searcher {\n-    EmptyNeedle { pos: usize, done: bool },\n-    Naive(NaiveSearcher),\n+enum OldSearcher {\n     TwoWay(TwoWaySearcher),\n-    TwoWayLong(TwoWaySearcher)\n+    TwoWayLong(TwoWaySearcher),\n }\n \n-impl Searcher {\n-    fn new(haystack: &[u8], needle: &[u8]) -> Searcher {\n+impl OldSearcher {\n+    #[allow(dead_code)]\n+    fn new(haystack: &[u8], needle: &[u8]) -> OldSearcher {\n         if needle.len() == 0 {\n-            Searcher::EmptyNeedle {\n-                pos: 0,\n-                done: false\n-            }\n+            // Handle specially\n+            unimplemented!()\n         // FIXME: Tune this.\n         // FIXME(#16715): This unsigned integer addition will probably not\n         // overflow because that would mean that the memory almost solely\n         // consists of the needle. Needs #16715 to be formally fixed.\n         } else if needle.len() + 20 > haystack.len() {\n-            Naive(NaiveSearcher::new())\n+            // Use naive searcher\n+            unimplemented!()\n         } else {\n             let searcher = TwoWaySearcher::new(needle);\n             if searcher.memory == usize::MAX { // If the period is long\n@@ -933,101 +893,55 @@ impl Searcher {\n }\n \n #[derive(Clone)]\n-#[unstable(feature = \"core\", reason = \"type may be removed\")]\n struct OldMatchIndices<'a, 'b> {\n     // constants\n     haystack: &'a str,\n     needle: &'b str,\n-    searcher: Searcher\n+    searcher: OldSearcher\n }\n \n+// FIXME: #21637 Prevents a Clone impl\n /// An iterator over the start and end indices of the matches of a\n /// substring within a larger string\n #[unstable(feature = \"core\", reason = \"type may be removed\")]\n-pub struct MatchIndices<'a, P: Pattern<'a>>(P::Matcher);\n+pub struct MatchIndices<'a, P: Pattern<'a>>(P::Searcher);\n \n-#[stable]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, P: Pattern<'a>> Iterator for MatchIndices<'a, P> {\n-    type Item = (uint, uint);\n+    type Item = (usize, usize);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n-        Matcher::next(&mut self.0)\n+    fn next(&mut self) -> Option<(usize, usize)> {\n+        self.0.next_match()\n     }\n }\n \n /// An iterator over the substrings of a string separated by a given\n /// search string\n #[unstable(feature = \"core\", reason = \"type may be removed\")]\n-pub struct SplitStr<'a, 'b> {\n-    it: pattern::StrMatcher<'a, 'b>,\n-    last_end: uint,\n-    finished: bool\n-}\n+pub struct SplitStr<'a, P: Pattern<'a>>(Split<'a, P>);\n+impl<'a, P: Pattern<'a>> Iterator for SplitStr<'a, P> {\n+    type Item = &'a str;\n \n-impl<'a, 'b> Clone for SplitStr<'a, 'b> {\n-    fn clone(&self) -> Self {\n-        SplitStr {\n-            it: Clone::clone(&self.it),\n-            ..*self\n-        }\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        Iterator::next(&mut self.0)\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b> Iterator for OldMatchIndices<'a, 'b> {\n-    type Item = (uint, uint);\n-\n+impl<'a, 'b>  OldMatchIndices<'a, 'b> {\n     #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n+    #[allow(dead_code)]\n+    fn next(&mut self) -> Option<(usize, usize)> {\n         match self.searcher {\n-            Naive(ref mut searcher)\n-                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes()),\n             TwoWay(ref mut searcher)\n                 => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), false),\n             TwoWayLong(ref mut searcher)\n                 => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), true),\n-            Searcher::EmptyNeedle { ref mut pos, ref mut done } => {\n-                if !*done {\n-                    let r = Some((*pos, *pos));\n-                    if *pos == self.haystack.len() {\n-                        *done = true;\n-                    } else {\n-                        use char::CharExt;\n-                        *pos += self.haystack.char_at(*pos).len_utf8();\n-                    }\n-                    r\n-                } else {\n-                    None\n-                }\n-            }\n         }\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b> Iterator for SplitStr<'a, 'b> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        if self.finished { return None; }\n-        let haystack = Matcher::haystack(&self.it);\n-        match Matcher::next(&mut self.it) {\n-            Some((from, to)) => {\n-                let ret = Some(&haystack[self.last_end..from]);\n-                self.last_end = to;\n-                ret\n-            }\n-            None => {\n-                self.finished = true;\n-                Some(&haystack[self.last_end..])\n-            }\n-        }\n-    }\n-}\n-\n-\n /*\n Section: Comparing strings\n */\n@@ -1038,9 +952,8 @@ Section: Comparing strings\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[inline]\n fn eq_slice_(a: &str, b: &str) -> bool {\n-    // NOTE: In theory n should be libc::size_t and not usize, but libc is not available here\n     #[allow(improper_ctypes)]\n-    extern { fn memcmp(s1: *const i8, s2: *const i8, n: uint) -> i32; }\n+    extern { fn memcmp(s1: *const i8, s2: *const i8, n: usize) -> i32; }\n     a.len() == b.len() && unsafe {\n         memcmp(a.as_ptr() as *const i8,\n                b.as_ptr() as *const i8,\n@@ -1097,7 +1010,7 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n         // ASCII characters are always valid, so only large\n         // bytes need more examination.\n         if first >= 128 {\n-            let w = UTF8_CHAR_WIDTH[first as uint] as uint;\n+            let w = UTF8_CHAR_WIDTH[first as usize] as usize;\n             let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n@@ -1172,7 +1085,7 @@ pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n     /// Index of the first byte of the next `char`\n-    pub next: uint,\n+    pub next: usize,\n }\n \n /// Mask of the value bits of a continuation byte\n@@ -1257,10 +1170,10 @@ mod traits {\n     /// // &s[3 .. 100];\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::Range<uint>> for str {\n+    impl ops::Index<ops::Range<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::Range<uint>) -> &str {\n+        fn index(&self, index: &ops::Range<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if index.start <= index.end &&\n                self.is_char_boundary(index.start) &&\n@@ -1280,10 +1193,10 @@ mod traits {\n     /// Panics when `end` does not point to a valid character, or is\n     /// out of bounds.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeTo<uint>> for str {\n+    impl ops::Index<ops::RangeTo<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n+        fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if self.is_char_boundary(index.end) {\n                 unsafe { self.slice_unchecked(0, index.end) }\n@@ -1300,10 +1213,10 @@ mod traits {\n     /// Panics when `begin` does not point to a valid character, or is\n     /// out of bounds.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeFrom<uint>> for str {\n+    impl ops::Index<ops::RangeFrom<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n+        fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if self.is_char_boundary(index.start) {\n                 unsafe { self.slice_unchecked(index.start, self.len()) }\n@@ -1344,28 +1257,40 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n }\n \n /// Return type of `StrExt::split`\n-#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Split<'a, P>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str : Split<'a, P>}\n+pub struct Split<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, P: Pattern<'a>> Iterator for Split<'a, P> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next()\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, P: Pattern<'a>> DoubleEndedIterator for Split<'a, P>\n+where P::Searcher: DoubleEndedSearcher<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back()\n+    }\n+}\n \n /// Return type of `StrExt::split_terminator`\n-#[derive(Clone)]\n #[unstable(feature = \"core\",\n            reason = \"might get removed in favour of a constructor method on Split\")]\n-pub struct SplitTerminator<'a, P>(CharSplits<'a, P>);\n+pub struct SplitTerminator<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n \n /// Return type of `StrExt::splitn`\n-#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SplitN<'a, P>(CharSplitsN<'a, P>);\n+pub struct SplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n /// Return type of `StrExt::rsplitn`\n-#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RSplitN<'a, P>(CharSplitsN<'a, P>);\n+pub struct RSplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n \n /// Methods for string slices\n@@ -1379,44 +1304,45 @@ pub trait StrExt {\n     fn chars<'a>(&'a self) -> Chars<'a>;\n     fn bytes<'a>(&'a self) -> Bytes<'a>;\n     fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n-    fn split<'a, P: CharEq>(&'a self, pat: P) -> Split<'a, P>;\n-    fn splitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> SplitN<'a, P>;\n-    fn split_terminator<'a, P: CharEq>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n-    fn rsplitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> RSplitN<'a, P>;\n+    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;\n+    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n+    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>;\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n-    fn split_str<'a, 'b>(&'a self, pat: &'b str) -> SplitStr<'a, 'b>;\n+    fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P>;\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n-    fn char_len(&self) -> uint;\n-    fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-    unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-    fn starts_with(&self, pat: &str) -> bool;\n-    fn ends_with(&self, pat: &str) -> bool;\n+    fn char_len(&self) -> usize;\n+    fn slice_chars<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n+    unsafe fn slice_unchecked<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n+    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n+    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n+        where P::Searcher: ReverseSearcher<'a>;\n     fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Matcher: DoubleEndedMatcher<'a>;\n+        where P::Searcher: DoubleEndedSearcher<'a>;\n     fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str;\n     fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Matcher: ReverseMatcher<'a>;\n-    fn is_char_boundary(&self, index: uint) -> bool;\n-    fn char_range_at(&self, start: uint) -> CharRange;\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n-    fn char_at(&self, i: uint) -> char;\n-    fn char_at_reverse(&self, i: uint) -> char;\n+        where P::Searcher: ReverseSearcher<'a>;\n+    fn is_char_boundary(&self, index: usize) -> bool;\n+    fn char_range_at(&self, start: usize) -> CharRange;\n+    fn char_range_at_reverse(&self, start: usize) -> CharRange;\n+    fn char_at(&self, i: usize) -> char;\n+    fn char_at_reverse(&self, i: usize) -> char;\n     fn as_bytes<'a>(&'a self) -> &'a [u8];\n-    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<uint>;\n-    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<uint>\n-        where P::Matcher: ReverseMatcher<'a>;\n-    fn find_str(&self, pat: &str) -> Option<uint>;\n+    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n+    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n+        where P::Searcher: ReverseSearcher<'a>;\n+    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n-    fn subslice_offset(&self, inner: &str) -> uint;\n+    fn subslice_offset(&self, inner: &str) -> usize;\n     fn as_ptr(&self) -> *const u8;\n-    fn len(&self) -> uint;\n+    fn len(&self) -> usize;\n     fn is_empty(&self) -> bool;\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n }\n \n #[inline(never)]\n-fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n+fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     assert!(begin <= end);\n     panic!(\"index {} and/or {} in `{}` do not lie on character boundary\",\n           begin, end, s);\n@@ -1449,18 +1375,18 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n+    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n         Split(CharSplits {\n-            string: self,\n-            only_ascii: pat.only_ascii(),\n-            sep: pat,\n+            start: 0,\n+            end: self.len(),\n+            matcher: pat.into_matcher(self),\n             allow_trailing_empty: true,\n             finished: false,\n         })\n     }\n \n     #[inline]\n-    fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n+    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n         SplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1469,15 +1395,15 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n+    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n         SplitTerminator(CharSplits {\n             allow_trailing_empty: false,\n             ..self.split(pat).0\n         })\n     }\n \n     #[inline]\n-    fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n         RSplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1491,12 +1417,8 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn split_str<'a, 'b>(&'a self, sep: &'b str) -> SplitStr<'a, 'b> {\n-        SplitStr {\n-            it: self.match_indices(sep).0,\n-            last_end: 0,\n-            finished: false\n-        }\n+    fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P> {\n+        SplitStr(self.split(pat))\n     }\n \n     #[inline]\n@@ -1516,9 +1438,9 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_len(&self) -> uint { self.chars().count() }\n+    fn char_len(&self) -> usize { self.chars().count() }\n \n-    fn slice_chars(&self, begin: uint, end: uint) -> &str {\n+    fn slice_chars(&self, begin: usize, end: usize) -> &str {\n         assert!(begin <= end);\n         let mut count = 0;\n         let mut begin_byte = None;\n@@ -1542,91 +1464,73 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n+    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n         mem::transmute(Slice {\n             data: self.as_ptr().offset(begin as int),\n             len: end - begin,\n         })\n     }\n \n     #[inline]\n-    fn starts_with(&self, needle: &str) -> bool {\n-        let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == &self.as_bytes()[..n]\n+    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        pat.match_starts_at(self, 0)\n     }\n \n     #[inline]\n-    fn ends_with(&self, needle: &str) -> bool {\n-        let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == &self.as_bytes()[m-n..]\n+    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n+    where P::Searcher: ReverseSearcher<'a> {\n+        pat.match_ends_at(self, self.len())\n     }\n \n     #[inline]\n     fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-    where P::Matcher: DoubleEndedMatcher<'a> {\n+    where P::Searcher: DoubleEndedSearcher<'a> {\n         let mut i = 0;\n+        let mut j = self.len();\n         let mut matcher = pat.into_matcher(self);\n-        let mut possible_end_match = None;\n-        while let Some((a, b)) = Matcher::next(&mut matcher) {\n-            if a == i {\n-                i = b;\n-            } else {\n-                possible_end_match = Some((a, b));\n-                break;\n-            }\n+        if let Some((a, b)) = matcher.next_reject() {\n+            i = a;\n+            j = b; // Rember earliest known match, correct it below if\n+                   // last match is different\n         }\n-        let mut j = self.len();\n-        while let Some((a, b)) = ReverseMatcher::next_back(&mut matcher)\n-                .or_else(|| possible_end_match.take()) {\n-            if b == j {\n-                j = a;\n-            } else {\n-                break;\n-            }\n+        if let Some((_, b)) = matcher.next_reject_back() {\n+            j = b;\n         }\n         unsafe {\n-            // Matcher is known to return valid indices\n+            // Searcher is known to return valid indices\n             self.slice_unchecked(i, j)\n         }\n     }\n \n     #[inline]\n-    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &str {\n+    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n         let mut i = 0;\n         let mut matcher = pat.into_matcher(self);\n-        while let Some((a, b)) = Matcher::next(&mut matcher) {\n-            if a == i {\n-                i = b;\n-            } else {\n-                break;\n-            }\n+        if let Some((a, _)) = matcher.next_reject() {\n+            i = a;\n         }\n         unsafe {\n-            // Matcher is known to return valid indices\n+            // Searcher is known to return valid indices\n             self.slice_unchecked(i, self.len())\n         }\n     }\n \n     #[inline]\n-    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &str\n-    where P::Matcher: ReverseMatcher<'a> {\n-        let mut i = self.len();\n+    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+    where P::Searcher: ReverseSearcher<'a> {\n+        let mut j = self.len();\n         let mut matcher = pat.into_matcher(self);\n-        while let Some((a, b)) = ReverseMatcher::next_back(&mut matcher) {\n-            if b == i {\n-                i = a;\n-            } else {\n-                break;\n-            }\n+        if let Some((_, b)) = matcher.next_reject_back() {\n+            j = b;\n         }\n         unsafe {\n-            // Matcher is known to return valid indices\n-            self.slice_unchecked(0, i)\n+            // Searcher is known to return valid indices\n+            self.slice_unchecked(0, j)\n         }\n     }\n \n     #[inline]\n-    fn is_char_boundary(&self, index: uint) -> bool {\n+    fn is_char_boundary(&self, index: usize) -> bool {\n         if index == self.len() { return true; }\n         match self.as_bytes().get(index) {\n             None => false,\n@@ -1635,13 +1539,13 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_range_at(&self, i: uint) -> CharRange {\n+    fn char_range_at(&self, i: usize) -> CharRange {\n         let (c, n) = char_range_at_raw(self.as_bytes(), i);\n         CharRange { ch: unsafe { mem::transmute(c) }, next: n }\n     }\n \n     #[inline]\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n+    fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         let mut prev = start;\n \n         prev = prev.saturating_sub(1);\n@@ -1650,14 +1554,14 @@ impl StrExt for str {\n         }\n \n         // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n-        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n+        fn multibyte_char_range_at_reverse(s: &str, mut i: usize) -> CharRange {\n             // while there is a previous byte == 10......\n             while i > 0 && s.as_bytes()[i] & !CONT_MASK == TAG_CONT_U8 {\n                 i -= 1;\n             }\n \n             let mut val = s.as_bytes()[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+            let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n             assert!((w != 0));\n \n             val = utf8_first_byte!(val, w);\n@@ -1672,12 +1576,12 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_at(&self, i: uint) -> char {\n+    fn char_at(&self, i: usize) -> char {\n         self.char_range_at(i).ch\n     }\n \n     #[inline]\n-    fn char_at_reverse(&self, i: uint) -> char {\n+    fn char_at_reverse(&self, i: usize) -> char {\n         self.char_range_at_reverse(i).ch\n     }\n \n@@ -1686,23 +1590,17 @@ impl StrExt for str {\n         unsafe { mem::transmute(self) }\n     }\n \n-    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<uint> {\n-        Matcher::next(&mut pat.into_matcher(self)).map(|(i, _)| i)\n+    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n+        pat.into_matcher(self).next_match().map(|(i, _)| i)\n     }\n \n-    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<uint>\n-    where P::Matcher: ReverseMatcher<'a> {\n-        ReverseMatcher::next_back(&mut pat.into_matcher(self)).map(|(i, _)| i)\n+    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n+    where P::Searcher: ReverseSearcher<'a> {\n+        pat.into_matcher(self).next_match_back().map(|(i, _)| i)\n     }\n \n-    fn find_str(&self, needle: &str) -> Option<uint> {\n-        if needle.is_empty() {\n-            Some(0)\n-        } else {\n-            self.match_indices(needle)\n-                .next()\n-                .map(|(start, _end)| start)\n-        }\n+    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n+        self.find(pat)\n     }\n \n     #[inline]\n@@ -1716,10 +1614,10 @@ impl StrExt for str {\n         }\n     }\n \n-    fn subslice_offset(&self, inner: &str) -> uint {\n-        let a_start = self.as_ptr() as uint;\n+    fn subslice_offset(&self, inner: &str) -> usize {\n+        let a_start = self.as_ptr() as usize;\n         let a_end = a_start + self.len();\n-        let b_start = inner.as_ptr() as uint;\n+        let b_start = inner.as_ptr() as usize;\n         let b_end = b_start + inner.len();\n \n         assert!(a_start <= b_start);\n@@ -1733,7 +1631,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn len(&self) -> uint { self.repr().len }\n+    fn len(&self) -> usize { self.repr().len }\n \n     #[inline]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n@@ -1746,15 +1644,15 @@ impl StrExt for str {\n /// index of the next code point.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub fn char_range_at_raw(bytes: &[u8], i: uint) -> (u32, usize) {\n+pub fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n     if bytes[i] < 128u8 {\n         return (bytes[i] as u32, i + 1);\n     }\n \n     // Multibyte case is a fn to allow char_range_at to inline cleanly\n-    fn multibyte_char_range_at(bytes: &[u8], i: uint) -> (u32, usize) {\n+    fn multibyte_char_range_at(bytes: &[u8], i: usize) -> (u32, usize) {\n         let mut val = bytes[i] as u32;\n-        let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+        let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n         assert!((w != 0));\n \n         val = utf8_first_byte!(val, w);\n@@ -1781,7 +1679,7 @@ impl<'a> Iterator for Lines<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1797,7 +1695,7 @@ impl<'a> Iterator for LinesAny<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "2b77d877cf4fd682854e6d74e433935e989ab41b", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 219, "deletions": 38, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=f9ef8cd55512842f2481aac6332dbfb92df58c52", "patch": "@@ -16,99 +16,280 @@ use super::CharEq;\n // Pattern\n \n pub trait Pattern<'a>: Sized {\n-    type Matcher: Matcher<'a>;\n-    fn into_matcher(self, haystack: &'a str) -> Self::Matcher;\n+    type Searcher: Searcher<'a>;\n+    fn into_matcher(self, haystack: &'a str) -> Self::Searcher;\n \n     #[inline]\n     fn is_contained_in(self, haystack: &'a str) -> bool {\n-        Matcher::next(&mut self.into_matcher(haystack)).is_some()\n+        self.into_matcher(haystack).next_match().is_some()\n+    }\n+\n+    #[inline]\n+    fn match_starts_at(self, haystack: &'a str, idx: usize) -> bool {\n+        let mut matcher = self.into_matcher(haystack);\n+        loop {\n+            match matcher.next() {\n+                SearchStep::Match(i, _) if i == idx => return true,\n+                SearchStep::Match(i, _)\n+                | SearchStep::Reject(i, _) if i >= idx => break,\n+                SearchStep::Done => break,\n+                _ => continue,\n+            }\n+        }\n+        false\n+    }\n+\n+    #[inline]\n+    fn match_ends_at(self, haystack: &'a str, idx: usize) -> bool\n+    where Self::Searcher: ReverseSearcher<'a> {\n+        let mut matcher = self.into_matcher(haystack);\n+        loop {\n+            match matcher.next_back() {\n+                SearchStep::Match(_, j) if idx == j => return true,\n+                SearchStep::Match(_, j)\n+                | SearchStep::Reject(_, j) if idx >= j => break,\n+                SearchStep::Done => break,\n+                _ => continue,\n+            }\n+        }\n+        false\n     }\n }\n \n-// Matcher\n+// Searcher\n+\n+pub enum SearchStep {\n+    Match(usize, usize),\n+    Reject(usize, usize),\n+    Done\n+}\n \n-pub unsafe trait Matcher<'a> {\n+pub unsafe trait Searcher<'a> {\n     fn haystack(&self) -> &'a str;\n-    fn next(&mut self) -> Option<(usize, usize)>;\n+    fn next(&mut self) -> SearchStep;\n+    #[inline]\n+    fn next_match(&mut self) -> Option<(usize, usize)> {\n+        loop {\n+            match self.next() {\n+                SearchStep::Match(a, b) => return Some((a, b)),\n+                SearchStep::Done => return None,\n+                _ => continue,\n+            }\n+        }\n+    }\n+    #[inline]\n+    fn next_reject(&mut self) -> Option<(usize, usize)>{\n+        loop {\n+            match self.next() {\n+                SearchStep::Reject(a, b) => return Some((a, b)),\n+                SearchStep::Done => return None,\n+                _ => continue,\n+            }\n+        }\n+    }\n }\n \n-pub unsafe trait ReverseMatcher<'a>: Matcher<'a> {\n-    fn next_back(&mut self) -> Option<(usize, usize)>;\n+pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n+    fn next_back(&mut self) -> SearchStep;\n+    #[inline]\n+    fn next_match_back(&mut self) -> Option<(usize, usize)>{\n+        loop {\n+            match self.next_back() {\n+                SearchStep::Match(a, b) => return Some((a, b)),\n+                SearchStep::Done => return None,\n+                _ => continue,\n+            }\n+        }\n+    }\n+    #[inline]\n+    fn next_reject_back(&mut self) -> Option<(usize, usize)>{\n+        loop {\n+            match self.next_back() {\n+                SearchStep::Reject(a, b) => return Some((a, b)),\n+                SearchStep::Done => return None,\n+                _ => continue,\n+            }\n+        }\n+    }\n }\n \n-pub trait DoubleEndedMatcher<'a>: ReverseMatcher<'a> {}\n+pub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}\n \n // Impl for CharEq\n \n-struct CharEqMatcher<'a, C>(C, &'a str, super::CharIndices<'a>);\n+pub struct CharEqSearcher<'a, C> {\n+    char_eq: C,\n+    haystack: &'a str,\n+    char_indices: super::CharIndices<'a>,\n+    #[allow(dead_code)]\n+    ascii_only: bool,\n+}\n \n impl<'a, C: CharEq> Pattern<'a> for C {\n-    type Matcher = CharEqMatcher<'a, C>;\n+    type Searcher = CharEqSearcher<'a, C>;\n \n     #[inline]\n-    fn into_matcher(self, haystack: &'a str) -> CharEqMatcher<'a, C> {\n-        CharEqMatcher(self, haystack, haystack.char_indices())\n+    fn into_matcher(self, haystack: &'a str) -> CharEqSearcher<'a, C> {\n+        CharEqSearcher {\n+            ascii_only: self.only_ascii(),\n+            haystack: haystack,\n+            char_eq: self,\n+            char_indices: haystack.char_indices(),\n+        }\n     }\n }\n \n-unsafe impl<'a, C: CharEq> Matcher<'a> for CharEqMatcher<'a, C> {\n+unsafe impl<'a, C: CharEq> Searcher<'a> for CharEqSearcher<'a, C> {\n     #[inline]\n     fn haystack(&self) -> &'a str {\n-        self.1\n+        self.haystack\n     }\n \n     #[inline]\n-    fn next(&mut self) -> Option<(usize, usize)> {\n-        while let Some((i, c)) = self.2.next() {\n-            if self.0.matches(c) {\n-                return Some((i, i + c.len_utf8()));\n+    fn next(&mut self) -> SearchStep {\n+        let s = &mut self.char_indices;\n+        // Compare lengths of the internal byte slice iterator\n+        // to find length of current char\n+        let (pre_len, _) = s.iter.iter.size_hint();\n+        if let Some((i, c)) = s.next() {\n+            let (len, _) = s.iter.iter.size_hint();\n+            let char_len = pre_len - len;\n+            if self.char_eq.matches(c) {\n+                return SearchStep::Match(i, i + char_len);\n+            } else {\n+                return SearchStep::Reject(i, i + char_len);\n             }\n         }\n-        None\n+        SearchStep::Done\n     }\n }\n \n-unsafe impl<'a, C: CharEq> ReverseMatcher<'a> for CharEqMatcher<'a, C> {\n+unsafe impl<'a, C: CharEq> ReverseSearcher<'a> for CharEqSearcher<'a, C> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(usize, usize)> {\n-        while let Some((i, c)) = self.2.next_back() {\n-            if self.0.matches(c) {\n-                return Some((i, i + c.len_utf8()));\n+    fn next_back(&mut self) -> SearchStep {\n+        let s = &mut self.char_indices;\n+        // Compare lengths of the internal byte slice iterator\n+        // to find length of current char\n+        let (pre_len, _) = s.iter.iter.size_hint();\n+        if let Some((i, c)) = s.next_back() {\n+            let (len, _) = s.iter.iter.size_hint();\n+            let char_len = pre_len - len;\n+            if self.char_eq.matches(c) {\n+                return SearchStep::Match(i, i + char_len);\n+            } else {\n+                return SearchStep::Reject(i, i + char_len);\n             }\n         }\n-        None\n+        SearchStep::Done\n     }\n }\n \n-impl<'a, C: CharEq> DoubleEndedMatcher<'a> for CharEqMatcher<'a, C> {}\n+impl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}\n \n // Impl for &str\n \n+// TODO: Optimize the naive implementation here\n+\n #[derive(Clone)]\n-pub struct StrMatcher<'a, 'b>(super::OldMatchIndices<'a, 'b>);\n+pub struct StrSearcher<'a, 'b> {\n+    haystack: &'a str,\n+    needle: &'b str,\n+    start: usize,\n+    end: usize,\n+    done: bool,\n+}\n \n impl<'a, 'b> Pattern<'a> for &'b str {\n-    type Matcher = StrMatcher<'a, 'b>;\n+    type Searcher = StrSearcher<'a, 'b>;\n \n     #[inline]\n-    fn into_matcher(self, haystack: &'a str) -> StrMatcher<'a, 'b> {\n-        let mi = super::OldMatchIndices {\n+    fn into_matcher(self, haystack: &'a str) -> StrSearcher<'a, 'b> {\n+        StrSearcher {\n             haystack: haystack,\n             needle: self,\n-            searcher: super::Searcher::new(haystack.as_bytes(), self.as_bytes())\n-        };\n-        StrMatcher(mi)\n+            start: 0,\n+            end: haystack.len(),\n+            done: false,\n+        }\n     }\n }\n \n-unsafe impl<'a, 'b> Matcher<'a> for StrMatcher<'a, 'b>  {\n+unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b>  {\n     #[inline]\n     fn haystack(&self) -> &'a str {\n-        self.0.haystack\n+        self.haystack\n     }\n \n     #[inline]\n-    fn next(&mut self) -> Option<(usize, usize)> {\n-        self.0.next()\n+    fn next(&mut self) -> SearchStep {\n+        str_search_step(self,\n+        |m: &mut StrSearcher| {\n+            // Forward step for empty needle\n+            let current_start = m.start;\n+            if !m.done {\n+                m.start = m.haystack.char_range_at(current_start).next;\n+            }\n+            SearchStep::Match(current_start, current_start)\n+        },\n+        |m: &mut StrSearcher| {\n+            // Forward step for nonempty needle\n+            let possible_match = &m.haystack[m.start .. m.start + m.needle.len()];\n+            let current_start = m.start;\n+            if possible_match == m.needle {\n+                m.start += m.needle.len();\n+                SearchStep::Match(current_start, m.start)\n+            } else {\n+                m.start += possible_match.chars().next().unwrap().len_utf8();\n+                SearchStep::Reject(current_start, m.start)\n+            }\n+        })\n+    }\n+}\n+\n+unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b>  {\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep {\n+        str_search_step(self,\n+        |m: &mut StrSearcher| {\n+            // Backward step for empty needle\n+            let current_end = m.end;\n+            if !m.done {\n+                m.end = m.haystack.char_range_at_reverse(current_end).next;\n+            }\n+            SearchStep::Match(current_end, current_end)\n+        },\n+        |m: &mut StrSearcher| {\n+            // Backward step for nonempty needle\n+            let possible_match = &m.haystack[m.end - m.needle.len() .. m.end];\n+            let current_end = m.end;\n+            if possible_match == m.needle {\n+                m.end -= m.needle.len();\n+                SearchStep::Match(m.end, current_end)\n+            } else {\n+                m.end -= possible_match.chars().rev().next().unwrap().len_utf8();\n+                SearchStep::Reject(m.end, current_end)\n+            }\n+        })\n+    }\n+}\n+\n+fn str_search_step<F, G>(mut m: &mut StrSearcher, f: F, g: G) -> SearchStep\n+where F: FnOnce(&mut StrSearcher) -> SearchStep,\n+      G: FnOnce(&mut StrSearcher) -> SearchStep\n+{\n+    if m.done {\n+        SearchStep::Done\n+    } else if m.needle.len() == 0 && m.start <= m.end {\n+        // Case for needle == \"\"\n+        if m.start == m.end {\n+            m.done = true;\n+        }\n+        f(&mut m)\n+    } else if m.start + m.needle.len() <= m.end {\n+        // Case for needle != \"\"\n+        g(&mut m)\n+    } else {\n+        m.done = true;\n+        SearchStep::Done\n     }\n }"}, {"sha": "9bd7cf9833e90a78d597918a73fbb88de426954a", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ef8cd55512842f2481aac6332dbfb92df58c52/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=f9ef8cd55512842f2481aac6332dbfb92df58c52", "patch": "@@ -207,15 +207,15 @@ malesuada sollicitudin quam eu fermentum!\");\n \n     make_test!(trim_ascii_char, s, {\n         use std::ascii::AsciiExt;\n-        s.trim_matches(|&mut: c: char| c.is_ascii())\n+        s.trim_matches(|c: char| c.is_ascii())\n     });\n     make_test!(trim_left_ascii_char, s, {\n         use std::ascii::AsciiExt;\n-        s.trim_left_matches(|&mut: c: char| c.is_ascii())\n+        s.trim_left_matches(|c: char| c.is_ascii())\n     });\n     make_test!(trim_right_ascii_char, s, {\n         use std::ascii::AsciiExt;\n-        s.trim_right_matches(|&mut: c: char| c.is_ascii())\n+        s.trim_right_matches(|c: char| c.is_ascii())\n     });\n \n     make_test!(find_underscore_char, s, s.find('_'));"}]}