{"sha": "488b999fc20896318192f8e22709095cccd0a6bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4OGI5OTlmYzIwODk2MzE4MTkyZjhlMjI3MDkwOTVjY2NkMGE2YmY=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-05T23:50:35Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-19T09:36:39Z"}, "message": "BTreeMap: test invariants more thoroughly and more readably", "tree": {"sha": "e25ed147d4a6cb7a36beb7be8bae94e2fc3137f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e25ed147d4a6cb7a36beb7be8bae94e2fc3137f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/488b999fc20896318192f8e22709095cccd0a6bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/488b999fc20896318192f8e22709095cccd0a6bf", "html_url": "https://github.com/rust-lang/rust/commit/488b999fc20896318192f8e22709095cccd0a6bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/488b999fc20896318192f8e22709095cccd0a6bf/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c38ddb8040edce1b05bc09a0e8439472e9f67623", "url": "https://api.github.com/repos/rust-lang/rust/commits/c38ddb8040edce1b05bc09a0e8439472e9f67623", "html_url": "https://github.com/rust-lang/rust/commit/c38ddb8040edce1b05bc09a0e8439472e9f67623"}], "stats": {"total": 194, "additions": 115, "deletions": 79}, "files": [{"sha": "b51b95a635c87ba9cb60acc80db0eba0424cf49c", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 10, "deletions": 79, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/488b999fc20896318192f8e22709095cccd0a6bf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488b999fc20896318192f8e22709095cccd0a6bf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=488b999fc20896318192f8e22709095cccd0a6bf", "patch": "@@ -1,4 +1,4 @@\n-use super::super::{navigate::Position, node, DeterministicRng};\n+use super::super::{node, DeterministicRng};\n use super::Entry::{Occupied, Vacant};\n use super::*;\n use crate::boxed::Box;\n@@ -7,7 +7,7 @@ use crate::rc::Rc;\n use crate::string::{String, ToString};\n use crate::vec::Vec;\n use std::convert::TryFrom;\n-use std::iter::FromIterator;\n+use std::iter::{self, FromIterator};\n use std::mem;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n@@ -42,19 +42,6 @@ fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>\n     }\n }\n \n-struct SeriesChecker<T> {\n-    previous: Option<T>,\n-}\n-\n-impl<T: Copy + Debug + Ord> SeriesChecker<T> {\n-    fn is_ascending(&mut self, next: T) {\n-        if let Some(previous) = self.previous {\n-            assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n-        }\n-        self.previous = Some(next);\n-    }\n-}\n-\n impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n     /// Panics if the map (or the code navigating it) is corrupted.\n     fn check(&self)\n@@ -63,44 +50,10 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n     {\n         if let Some(root) = &self.root {\n             let root_node = root.node_as_ref();\n-            let mut checker = SeriesChecker { previous: None };\n-            let mut internal_length = 0;\n-            let mut internal_kv_count = 0;\n-            let mut leaf_length = 0;\n-            root_node.visit_nodes_in_order(|pos| match pos {\n-                Position::Leaf(node) => {\n-                    let is_root = root_node.height() == 0;\n-                    let min_len = if is_root { 0 } else { node::MIN_LEN };\n-                    assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n-\n-                    for idx in 0..node.len() {\n-                        let key = *unsafe { node.key_at(idx) };\n-                        checker.is_ascending(key);\n-                    }\n-                    leaf_length += node.len();\n-                }\n-                Position::Internal(node) => {\n-                    let is_root = root_node.height() == node.height();\n-                    let min_len = if is_root { 1 } else { node::MIN_LEN };\n-                    assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n-\n-                    for idx in 0..=node.len() {\n-                        let edge = unsafe { node::Handle::new_edge(node, idx) };\n-                        assert!(edge.descend().ascend().ok().unwrap() == edge);\n-                    }\n-\n-                    internal_length += node.len();\n-                }\n-                Position::InternalKV(kv) => {\n-                    let key = *kv.into_kv().0;\n-                    checker.is_ascending(key);\n-\n-                    internal_kv_count += 1;\n-                }\n-            });\n-            assert_eq!(internal_length, internal_kv_count);\n-            assert_eq!(root_node.calc_length(), internal_length + leaf_length);\n-            assert_eq!(self.length, internal_length + leaf_length);\n+            assert!(root_node.ascend().is_err());\n+            root_node.assert_back_pointers();\n+            root_node.assert_ascending();\n+            assert_eq!(self.length, root_node.assert_and_add_lengths());\n         } else {\n             assert_eq!(self.length, 0);\n         }\n@@ -116,28 +69,7 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n         K: Debug,\n     {\n         if let Some(root) = self.root.as_ref() {\n-            let mut result = String::new();\n-            let root_node = root.node_as_ref();\n-            root_node.visit_nodes_in_order(|pos| match pos {\n-                Position::Leaf(leaf) => {\n-                    let depth = root_node.height();\n-                    let indent = \"  \".repeat(depth);\n-                    result += &format!(\"\\n{}\", indent);\n-                    for idx in 0..leaf.len() {\n-                        if idx > 0 {\n-                            result += \", \";\n-                        }\n-                        result += &format!(\"{:?}\", unsafe { leaf.key_at(idx) });\n-                    }\n-                }\n-                Position::Internal(_) => {}\n-                Position::InternalKV(kv) => {\n-                    let depth = root_node.height() - kv.into_node().height();\n-                    let indent = \"  \".repeat(depth);\n-                    result += &format!(\"\\n{}{:?}\", indent, kv.into_kv().0);\n-                }\n-            });\n-            result\n+            root.node_as_ref().dump_keys()\n         } else {\n             String::from(\"not yet allocated\")\n         }\n@@ -170,7 +102,6 @@ fn test_levels() {\n         let last_key = *map.last_key_value().unwrap().0;\n         map.insert(last_key + 1, ());\n     }\n-    println!(\"{}\", map.dump_keys());\n     map.check();\n     // Structure:\n     // - 1 element in internal root node with 2 children\n@@ -372,7 +303,7 @@ fn test_iter_rev() {\n fn do_test_iter_mut_mutation<T>(size: usize)\n where\n     T: Copy + Debug + Ord + TryFrom<usize>,\n-    <T as std::convert::TryFrom<usize>>::Error: std::fmt::Debug,\n+    <T as TryFrom<usize>>::Error: Debug,\n {\n     let zero = T::try_from(0).unwrap();\n     let mut map: BTreeMap<T, T> = (0..size).map(|i| (T::try_from(i).unwrap(), zero)).collect();\n@@ -857,7 +788,7 @@ mod test_drain_filter {\n     fn consuming_nothing() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: BTreeMap<_, _> = pairs.collect();\n-        assert!(map.drain_filter(|_, _| false).eq(std::iter::empty()));\n+        assert!(map.drain_filter(|_, _| false).eq(iter::empty()));\n         map.check();\n     }\n \n@@ -878,7 +809,7 @@ mod test_drain_filter {\n                 *v += 6;\n                 false\n             })\n-            .eq(std::iter::empty())\n+            .eq(iter::empty())\n         );\n         assert!(map.keys().copied().eq(0..3));\n         assert!(map.values().copied().eq(6..9));"}, {"sha": "e56fc2aa51e7c1dfc8bbef4dd57c1cca6327a60e", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/488b999fc20896318192f8e22709095cccd0a6bf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488b999fc20896318192f8e22709095cccd0a6bf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=488b999fc20896318192f8e22709095cccd0a6bf", "patch": "@@ -1,6 +1,111 @@\n+use super::super::navigate;\n use super::*;\n+use crate::fmt::Debug;\n+use crate::string::String;\n use core::cmp::Ordering::*;\n \n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n+    pub fn assert_back_pointers(self) {\n+        match self.force() {\n+            ForceResult::Leaf(_) => {}\n+            ForceResult::Internal(node) => {\n+                for idx in 0..=node.len() {\n+                    let edge = unsafe { Handle::new_edge(node, idx) };\n+                    let child = edge.descend();\n+                    assert!(child.ascend().ok() == Some(edge));\n+                    child.assert_back_pointers();\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn assert_ascending(self)\n+    where\n+        K: Copy + Debug + Ord,\n+    {\n+        struct SeriesChecker<T> {\n+            previous: Option<T>,\n+        }\n+        impl<T: Copy + Debug + Ord> SeriesChecker<T> {\n+            fn is_ascending(&mut self, next: T) {\n+                if let Some(previous) = self.previous {\n+                    assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n+                }\n+                self.previous = Some(next);\n+            }\n+        }\n+\n+        let mut checker = SeriesChecker { previous: None };\n+        self.visit_nodes_in_order(|pos| match pos {\n+            navigate::Position::Leaf(node) => {\n+                for idx in 0..node.len() {\n+                    let key = *unsafe { node.key_at(idx) };\n+                    checker.is_ascending(key);\n+                }\n+            }\n+            navigate::Position::InternalKV(kv) => {\n+                let key = *kv.into_kv().0;\n+                checker.is_ascending(key);\n+            }\n+            navigate::Position::Internal(_) => {}\n+        });\n+    }\n+\n+    pub fn assert_and_add_lengths(self) -> usize {\n+        let mut internal_length = 0;\n+        let mut internal_kv_count = 0;\n+        let mut leaf_length = 0;\n+        self.visit_nodes_in_order(|pos| match pos {\n+            navigate::Position::Leaf(node) => {\n+                let is_root = self.height() == 0;\n+                let min_len = if is_root { 0 } else { MIN_LEN };\n+                assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n+                leaf_length += node.len();\n+            }\n+            navigate::Position::Internal(node) => {\n+                let is_root = self.height() == node.height();\n+                let min_len = if is_root { 1 } else { MIN_LEN };\n+                assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n+                internal_length += node.len();\n+            }\n+            navigate::Position::InternalKV(_) => {\n+                internal_kv_count += 1;\n+            }\n+        });\n+        assert_eq!(internal_length, internal_kv_count);\n+        let total = internal_length + leaf_length;\n+        assert_eq!(self.calc_length(), total);\n+        total\n+    }\n+\n+    pub fn dump_keys(self) -> String\n+    where\n+        K: Debug,\n+    {\n+        let mut result = String::new();\n+        self.visit_nodes_in_order(|pos| match pos {\n+            navigate::Position::Leaf(leaf) => {\n+                let depth = self.height();\n+                let indent = \"  \".repeat(depth);\n+                result += &format!(\"\\n{}\", indent);\n+                for idx in 0..leaf.len() {\n+                    if idx > 0 {\n+                        result += \", \";\n+                    }\n+                    result += &format!(\"{:?}\", unsafe { leaf.key_at(idx) });\n+                }\n+            }\n+            navigate::Position::Internal(_) => {}\n+            navigate::Position::InternalKV(kv) => {\n+                let depth = self.height() - kv.into_node().height();\n+                let indent = \"  \".repeat(depth);\n+                result += &format!(\"\\n{}{:?}\", indent, kv.into_kv().0);\n+            }\n+        });\n+        result\n+    }\n+}\n+\n #[test]\n fn test_splitpoint() {\n     for idx in 0..=CAPACITY {"}]}