{"sha": "4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNTJlNWE1ZWNmYjBlYzQ3ZjNjMjI1ZjBmMGY5MGFkYzEyYzAzMzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-05T18:44:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-07T06:40:31Z"}, "message": "make size_of and align_of take an optional value", "tree": {"sha": "be6437488f39c1310dddf2a1e574c6f948f8b90a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be6437488f39c1310dddf2a1e574c6f948f8b90a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335", "html_url": "https://github.com/rust-lang/rust/commit/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2074e06278ded95dcbc9b8ff0db1396e5b2da92a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2074e06278ded95dcbc9b8ff0db1396e5b2da92a", "html_url": "https://github.com/rust-lang/rust/commit/2074e06278ded95dcbc9b8ff0db1396e5b2da92a"}], "stats": {"total": 236, "additions": 135, "deletions": 101}, "files": [{"sha": "e5abe49f8ed5a6c4e3d0aebad02f358b35579aee", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 92, "deletions": 88, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335", "patch": "@@ -415,28 +415,31 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n }\n \n fn size_of(cx: @block_ctxt, t: ty::t) -> result {\n-    size_of_(cx, t, align_total)\n+    let {bcx, sz, align} = metrics(cx, t, none);\n+    rslt(bcx, align)\n }\n \n-tag align_mode {\n-    align_total;\n-    align_next(ty::t);\n-}\n-\n-fn size_of_(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n-    let ccx = bcx_ccx(cx);\n-    if check type_has_static_size(ccx, t) {\n-        let sp = cx.sp;\n-        rslt(cx, llsize_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n-    } else { dynamic_size_of(cx, t, mode) }\n+fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n+    let {bcx, sz, align} = metrics(cx, t, none);\n+    rslt(bcx, align)\n }\n \n-fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n+// Computes the size/alignment of the type `t`.  `opt_v`, if provided, should\n+// be a pointer to the instance of type `t` whose size/alignment are being\n+// computed.  For most types, `opt_v` is not needed, because all instances\n+// have the same size/alignment.  However, for opaque types like closures, the\n+// instance is required.\n+fn metrics(bcx: @block_ctxt, t: ty::t, opt_v: option<ValueRef>)\n+    -> metrics_result {\n     let ccx = bcx_ccx(cx);\n     if check type_has_static_size(ccx, t) {\n         let sp = cx.sp;\n-        rslt(cx, llalign_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n-    } else { dynamic_align_of(cx, t) }\n+        let sz = llsize_of(bcx_ccx(cx), type_of(ccx, sp, t));\n+        let align = llalign_of(bcx_ccx(cx), type_of(ccx, sp, t));\n+        ret {bcx: bcx, sz: sz, align: align};\n+    } else {\n+        ret dynamic_metrics(bcx, t, opt_v);\n+    }\n }\n \n fn alloca(cx: @block_ctxt, t: TypeRef) -> ValueRef {\n@@ -542,9 +545,18 @@ fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n     }\n }\n \n-fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n-    fn align_elements(cx: @block_ctxt, elts: [ty::t],\n-                      mode: align_mode) -> result {\n+type metrics_result = {\n+    bcx: @block_ctxt,\n+    sz: ValueRef,\n+    align: ValueRef\n+};\n+\n+fn dynamic_metrics(bcx: @block_ctxt,\n+                   elts: [ty::t],\n+                   opts_v: option<ValueRef>) -> metrics_result {\n+    fn compute_elements_metrics(bcx: @block_ctxt,\n+                                elts: [ty::t],\n+                                opt_v: option<ValueRef>) -> metrics_result {\n         //\n         // C padding rules:\n         //\n@@ -553,49 +565,44 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n         //   - Pad after final structure member so that whole structure\n         //     is aligned to max alignment of interior.\n         //\n-\n-        let off = C_int(bcx_ccx(cx), 0);\n-        let max_align = C_int(bcx_ccx(cx), 1);\n-        let bcx = cx;\n+        let bcx = bcx;\n+        let off = C_int(bcx_ccx(bcx), 0);\n+        let max_align = C_int(bcx_ccx(bcx), 1);\n         for e: ty::t in elts {\n-            let elt_align = align_of(bcx, e);\n+            let opt_ev = option::map(opt_v) {|v| ptr_offs(bcx, v, off) };\n+            let elt_align = align_of(bcx, e, opt_ev);\n             bcx = elt_align.bcx;\n-            let elt_size = size_of(bcx, e);\n+            let elt_size = size_of(bcx, e, opt_ev);\n             bcx = elt_size.bcx;\n             let aligned_off = align_to(bcx, off, elt_align.val);\n             off = Add(bcx, aligned_off, elt_size.val);\n             max_align = umax(bcx, max_align, elt_align.val);\n         }\n-        off = alt mode {\n-          align_total. {\n-            align_to(bcx, off, max_align)\n-          }\n-          align_next(t) {\n-            let {bcx, val: align} = align_of(bcx, t);\n-            align_to(bcx, off, align)\n-          }\n-        };\n-        ret rslt(bcx, off);\n+        ret { bcx: bcx, sz: off, align: max_align };\n     }\n-    alt ty::struct(bcx_tcx(cx), t) {\n+\n+    alt ty::struct(bcx_tcx(bcx), t) {\n       ty::ty_param(p, _) {\n-        let szptr = field_of_tydesc(cx, t, false, abi::tydesc_field_size);\n-        ret rslt(szptr.bcx, Load(szptr.bcx, szptr.val));\n+        let {bcx, value: szptr} =\n+            field_of_tydesc(bcx, t, false, abi::tydesc_field_size);\n+        let {bcx, value: aptr} =\n+            field_of_tydesc(bcx, t, false, abi::tydesc_field_align);\n+        ret { bcx: bcx, sz: Load(szptr), align: Load(align) };\n       }\n       ty::ty_rec(flds) {\n         let tys: [ty::t] = [];\n         for f: ty::field in flds { tys += [f.mt.ty]; }\n-        ret align_elements(cx, tys, mode);\n+        ret compute_elements_metrics(bcx, tys, opt_v);\n       }\n       ty::ty_tup(elts) {\n         let tys = [];\n         for tp in elts { tys += [tp]; }\n-        ret align_elements(cx, tys, mode);\n+        ret compute_elements_metrics(bcx, tys, opt_v);\n       }\n       ty::ty_tag(tid, tps) {\n-        let bcx = cx;\n+        let bcx = bcx;\n         let ccx = bcx_ccx(bcx);\n-        // Compute max(variant sizes).\n+        // Compute max(variant sizes) and max(variant alignments).\n \n         let max_size: ValueRef = alloca(bcx, ccx.int_type);\n         Store(bcx, C_int(ccx, 0), max_size);\n@@ -606,10 +613,10 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n             let raw_tys: [ty::t] = variant.args;\n             let tys: [ty::t] = [];\n             for raw_ty: ty::t in raw_tys {\n-                let t = ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty);\n+                let t = ty::substitute_type_params(bcx_tcx(bcx), tps, raw_ty);\n                 tys += [t];\n             }\n-            let rslt = align_elements(bcx, tys, mode);\n+            let rslt = align_elements(bcx, tys, opt_v);\n             bcx = rslt.bcx;\n             let this_size = rslt.val;\n             let old_max_size = Load(bcx, max_size);\n@@ -620,52 +627,49 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n             if vec::len(*variants) != 1u {\n                 Add(bcx, max_size_val, llsize_of(ccx, ccx.int_type))\n             } else { max_size_val };\n-        ret rslt(bcx, total_size);\n+        let total_align = C_int(bcx_ccx(bcx), 1); // FIXME: stub\n+        ret {bcx: bcx, sz: total_size, align: total_align};\n+      }\n+      ty::ty_opaque_closure. {\n+        // Unlike most other types, the type of an opaque closure does not\n+        // fully specify its size.  This is because the opaque closure type\n+        // only says that this is a closure over some data, but doesn't say\n+        // how much data there is (hence the word opaque).  This is an\n+        // unavoidable consequence of the way that closures encapsulate the\n+        // closed over data.  Therefore the only way to know the\n+        // size/alignment of a particular opaque closure instance is to load\n+        // the type descriptor from the instance and consult its\n+        // size/alignment fields.  Note that it is meaningless to say \"what is\n+        // the size of the type opaque closure?\" One can only ask \"what is the\n+        // size of this particular opaque closure?\"\n+        let v = alt opt_v {\n+          none. { fail \"Require value to compute metrics of opaque closures\"; }\n+          some(v) { v }\n+        };\n+        let v = PointerCast(bcx, v, T_ptr(T_opaque_closure(bcx_ccx(bcx))));\n+        let tdptrptr = GEPi(bcx, v, [0, abi::closure_elt_tydesc]);\n+        let tdptr = Load(bcx, tdptrptr);\n+        let sz = Load(bcx, GEPi(bcx, tdptr, [0, abi::tydesc_field_size]));\n+        let align = Load(bcx, GEPi(bcx, tdptr, [0, abi::tydesc_field_align]));\n+        ret { bcx: bcx, sz: sz, align: sz };\n       }\n     }\n }\n \n-fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n-// FIXME: Typestate constraint that shows this alt is\n-// exhaustive\n-    alt ty::struct(bcx_tcx(cx), t) {\n-      ty::ty_param(p, _) {\n-        let aptr = field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n-        ret rslt(aptr.bcx, Load(aptr.bcx, aptr.val));\n-      }\n-      ty::ty_rec(flds) {\n-        let a = C_int(bcx_ccx(cx), 1);\n-        let bcx = cx;\n-        for f: ty::field in flds {\n-            let align = align_of(bcx, f.mt.ty);\n-            bcx = align.bcx;\n-            a = umax(bcx, a, align.val);\n-        }\n-        ret rslt(bcx, a);\n-      }\n-      ty::ty_tag(_, _) {\n-        ret rslt(cx, C_int(bcx_ccx(cx), 1)); // FIXME: stub\n-      }\n-      ty::ty_tup(elts) {\n-        let a = C_int(bcx_ccx(cx), 1);\n-        let bcx = cx;\n-        for e in elts {\n-            let align = align_of(bcx, e);\n-            bcx = align.bcx;\n-            a = umax(bcx, a, align.val);\n-        }\n-        ret rslt(bcx, a);\n-      }\n-    }\n+// Given a pointer p, returns a pointer sz(p) (i.e., inc'd by sz bytes).\n+// The type of the returned pointer is always i8*.  If you care about the\n+// return type, use bump_ptr().\n+fn ptr_offs(bcx: @block_ctxt, base: ValueRef, sz: ValueRef) -> ValueRef {\n+    let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n+    GEP(bcx, raw, [sz]);\n }\n \n // Increment a pointer by a given amount and then cast it to be a pointer\n // to a given type.\n fn bump_ptr(bcx: @block_ctxt, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n-    let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n-    let bumped = GEP(bcx, raw, [sz]);\n     let ccx = bcx_ccx(bcx);\n+    let bumped = ptr_offs(bcx, base, sz);\n     if check type_has_static_size(ccx, t) {\n         let sp = bcx.sp;\n         let typ = T_ptr(type_of(ccx, sp, t));\n@@ -686,11 +690,11 @@ fn GEP_tup_like_1(cx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n // ty::struct and knows what to do when it runs into a ty_param stuck in the\n // middle of the thing it's GEP'ing into. Much like size_of and align_of,\n // above.\n-fn GEP_tup_like(cx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n-    : type_is_tup_like(cx, t) -> result {\n+fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n+    : type_is_tup_like(bcx, t) -> result {\n     // It might be a static-known type. Handle this.\n-    if !ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n-        ret rslt(cx, GEPi(cx, base, ixs));\n+    if !ty::type_has_dynamic_size(bcx_tcx(bcx), t) {\n+        ret rslt(bcx, GEPi(bcx, base, ixs));\n     }\n     // It is a dynamic-containing type that, if we convert directly to an LLVM\n     // TypeRef, will be all wrong; there's no proper LLVM type to represent\n@@ -751,15 +755,15 @@ fn GEP_tup_like(cx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n     // the tuple parens are associative so it doesn't matter that we've\n     // flattened the incoming structure.\n \n-    let s = split_type(bcx_ccx(cx), t, ixs, 0u);\n+    let s = split_type(bcx_ccx(bcx), t, ixs, 0u);\n \n     let args = [];\n     for typ: ty::t in s.prefix { args += [typ]; }\n-    let prefix_ty = ty::mk_tup(bcx_tcx(cx), args);\n-\n-    let bcx = cx;\n-    let sz = size_of_(bcx, prefix_ty, align_next(s.target));\n-    ret rslt(sz.bcx, bump_ptr(sz.bcx, s.target, base, sz.val));\n+    let prefix_ty = ty::mk_tup(bcx_tcx(bcx), args);\n+    let {bcx, val: prefix_sz} = size_of(bcx, prefix_ty);\n+    let {bcx, val: align} = align_of(bcx, s.target);\n+    let sz = align_to(bcx, prefix_sz, align);\n+    ret rslt(bcx, bump_ptr(bcx, s.target, base, sz));\n }\n \n "}, {"sha": "2b97f7b325568df85c42714cd2702597374dead6", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335", "patch": "@@ -35,22 +35,17 @@ fn trans_uniq(bcx: @block_ctxt, contents: @ast::expr,\n \n fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t)\n     : type_is_unique_box(cx, uniq_ty) -> result {\n+    ret alloc_uniq_(cx, uniq_ty, none);\n+}\n \n-    let bcx = cx;\n+fn alloc_uniq_(bcx: @block_ctxt, uniq_ty: ty::t, opt_v: option<ValueRef>)\n+    : type_is_unique_box(cx, uniq_ty) -> result {\n     let contents_ty = content_ty(bcx, uniq_ty);\n-    let r = size_of(bcx, contents_ty);\n-    bcx = r.bcx;\n-    let llsz = r.val;\n-\n+    let {bcx, sz: llsz, align: _} = metrics(bcx, contents_ty, opt_v);\n     let ccx = bcx_ccx(bcx);\n     check non_ty_var(ccx, contents_ty);\n     let llptrty = T_ptr(type_of_inner(ccx, bcx.sp, contents_ty));\n-\n-    r = trans_shared_malloc(bcx, llptrty, llsz);\n-    bcx = r.bcx;\n-    let llptr = r.val;\n-\n-    ret rslt(bcx, llptr);\n+    ret trans_shared_malloc(bcx, llptrty, llsz);\n }\n \n fn make_free_glue(cx: @block_ctxt, vptr: ValueRef, t: ty::t)\n@@ -88,7 +83,7 @@ fn duplicate(bcx: @block_ctxt, v: ValueRef, t: ty::t)\n     : type_is_unique_box(bcx, t) -> result {\n \n     let content_ty = content_ty(bcx, t);\n-    let {bcx, val: llptr} = alloc_uniq(bcx, t);\n+    let {bcx, val: llptr} = alloc_uniq_(bcx, t, v);\n \n     let src = load_if_immediate(bcx, v, content_ty);\n     let dst = llptr;"}, {"sha": "3732bdd203ae468478dd7a37efd4c33fc122d975", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335", "patch": "@@ -1151,7 +1151,10 @@ pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool unchecked {\n     that the type context tracks about types should be immutable.)\n     */\n     type_structurally_contains(cx, ty, fn (sty: sty) -> bool {\n-        alt sty { ty_param(_, _) { true } _ { false }}\n+        alt sty {\n+          ty_opaque_closure. | ty_param(_, _) { true }\n+          _ { false }\n+        }\n     })\n }\n "}, {"sha": "cec033d0c78764b23b6b0a867aada12c77c26f67", "filename": "src/test/run-pass/sendfn-deep-copy.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs?ref=4f52e5a5ecfb0ec47f3c225f0f0f90adc12c0335", "patch": "@@ -0,0 +1,32 @@\n+use std;\n+\n+import std::comm;\n+import std::comm::chan;\n+import std::comm::send;\n+\n+fn main() { test05(); }\n+\n+fn mk_counter<copy A>() -> sendfn(A) -> (A,uint) {\n+    // The only reason that the counter is generic is so that it closes\n+    // over both a type descriptor and some data.\n+    let v = [mutable 0u];\n+    ret sendfn(a: A) -> (A,uint) {\n+        let n = v[0];\n+        v[0] = n + 1u;\n+        (a, n)\n+    };\n+}\n+\n+fn test05() {\n+    let fp0 = mk_counter::<float>();\n+\n+    assert (5.3f, 0u) == fp0(5.3f);\n+    assert (5.5f, 1u) == fp0(5.5f);\n+\n+    let fp1 = copy fp0;\n+\n+    assert (5.3f, 2u) == fp0(5.3f);\n+    assert (5.3f, 2u) == fp1(5.3f);\n+    assert (5.5f, 3u) == fp0(5.5f);\n+    assert (5.5f, 3u) == fp1(5.5f);\n+}"}]}