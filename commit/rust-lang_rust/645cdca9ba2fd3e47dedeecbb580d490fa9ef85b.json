{"sha": "645cdca9ba2fd3e47dedeecbb580d490fa9ef85b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NWNkY2E5YmEyZmQzZTQ3ZGVkZWVjYmI1ODBkNDkwZmE5ZWY4NWI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-22T14:42:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-22T17:29:31Z"}, "message": "reduce visibility of a bunch of stuff in ext::tt", "tree": {"sha": "a420dade7ad542d29242ca441886e0313def1532", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a420dade7ad542d29242ca441886e0313def1532"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b", "html_url": "https://github.com/rust-lang/rust/commit/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ff32c07da9d97e6dc315a4a5c9ffbb797cb27bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff32c07da9d97e6dc315a4a5c9ffbb797cb27bb", "html_url": "https://github.com/rust-lang/rust/commit/4ff32c07da9d97e6dc315a4a5c9ffbb797cb27bb"}], "stats": {"total": 108, "additions": 50, "deletions": 58}, "files": [{"sha": "73ad0670659b5fd08633b44304b8a52ec32a6500", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=645cdca9ba2fd3e47dedeecbb580d490fa9ef85b", "patch": "@@ -18,7 +18,7 @@ use syntax::ext::base::{self, InvocationRes, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, AstFragmentKind, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n-use syntax::ext::tt::macro_rules;\n+use syntax::ext::compile_declarative_macro;\n use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::GateIssue;\n use syntax::symbol::{Symbol, kw, sym};\n@@ -843,7 +843,7 @@ impl<'a> Resolver<'a> {\n     /// Compile the macro into a `SyntaxExtension` and possibly replace it with a pre-defined\n     /// extension partially or entirely for built-in macros and legacy plugin macros.\n     crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> SyntaxExtension {\n-        let mut result = macro_rules::compile(\n+        let mut result = compile_declarative_macro(\n             &self.session.parse_sess, self.session.features_untracked(), item, edition\n         );\n "}, {"sha": "a1734689595f0fef810f20b84dc2735a5595036b", "filename": "src/libsyntax/ext/tt/macro_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_check.rs?ref=645cdca9ba2fd3e47dedeecbb580d490fa9ef85b", "patch": "@@ -196,7 +196,7 @@ struct MacroState<'a> {\n /// - `node_id` is used to emit lints\n /// - `span` is used when no spans are available\n /// - `lhses` and `rhses` should have the same length and represent the macro definition\n-pub fn check_meta_variables(\n+crate fn check_meta_variables(\n     sess: &ParseSess,\n     node_id: NodeId,\n     span: Span,"}, {"sha": "a34a0344f27403b5256ab4175fe32ad7c50ad08b", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=645cdca9ba2fd3e47dedeecbb580d490fa9ef85b", "patch": "@@ -70,8 +70,8 @@\n //! eof: [a $( a )* a b \u00b7]\n //! ```\n \n-pub use NamedMatch::*;\n-pub use ParseResult::*;\n+crate use NamedMatch::*;\n+crate use ParseResult::*;\n use TokenTreeOrTokenTreeSlice::*;\n \n use crate::ast::{Ident, Name};\n@@ -267,7 +267,7 @@ impl<'root, 'tt> DerefMut for MatcherPosHandle<'root, 'tt> {\n }\n \n /// Represents the possible results of an attempted parse.\n-pub enum ParseResult<T> {\n+crate enum ParseResult<T> {\n     /// Parsed successfully.\n     Success(T),\n     /// Arm failed to match. If the second parameter is `token::Eof`, it indicates an unexpected\n@@ -279,10 +279,10 @@ pub enum ParseResult<T> {\n \n /// A `ParseResult` where the `Success` variant contains a mapping of `Ident`s to `NamedMatch`es.\n /// This represents the mapping of metavars to the token trees they bind to.\n-pub type NamedParseResult = ParseResult<FxHashMap<Ident, NamedMatch>>;\n+crate type NamedParseResult = ParseResult<FxHashMap<Ident, NamedMatch>>;\n \n /// Count how many metavars are named in the given matcher `ms`.\n-pub fn count_names(ms: &[TokenTree]) -> usize {\n+crate fn count_names(ms: &[TokenTree]) -> usize {\n     ms.iter().fold(0, |count, elt| {\n         count + match *elt {\n             TokenTree::Sequence(_, ref seq) => seq.num_captures,\n@@ -352,7 +352,7 @@ fn initial_matcher_pos<'root, 'tt>(ms: &'tt [TokenTree], open: Span) -> MatcherP\n /// only on the nesting depth of `ast::TTSeq`s in the originating\n /// token tree it was derived from.\n #[derive(Debug, Clone)]\n-pub enum NamedMatch {\n+crate enum NamedMatch {\n     MatchedSeq(Lrc<NamedMatchVec>, DelimSpan),\n     MatchedNonterminal(Lrc<Nonterminal>),\n }\n@@ -415,7 +415,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n \n /// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For\n /// other tokens, this is \"unexpected token...\".\n-pub fn parse_failure_msg(tok: &Token) -> String {\n+crate fn parse_failure_msg(tok: &Token) -> String {\n     match tok.kind {\n         token::Eof => \"unexpected end of macro invocation\".to_string(),\n         _ => format!(\n@@ -648,7 +648,7 @@ fn inner_parse_loop<'root, 'tt>(\n /// - `directory`: Information about the file locations (needed for the black-box parser)\n /// - `recurse_into_modules`: Whether or not to recurse into modules (needed for the black-box\n ///   parser)\n-pub fn parse(\n+crate fn parse(\n     sess: &ParseSess,\n     tts: TokenStream,\n     ms: &[TokenTree],"}, {"sha": "90dfa6e7ac8a49013a436d86861d7f7b76040bfa", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=645cdca9ba2fd3e47dedeecbb580d490fa9ef85b", "patch": "@@ -35,7 +35,7 @@ const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n                                         `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, \\\n                                         `literal`, `path`, `meta`, `tt`, `item` and `vis`\";\n \n-pub struct ParserAnyMacro<'a> {\n+crate struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n \n     /// Span of the expansion site of the macro this parser is for\n@@ -45,7 +45,11 @@ pub struct ParserAnyMacro<'a> {\n     arm_span: Span,\n }\n \n-pub fn annotate_err_with_kind(err: &mut DiagnosticBuilder<'_>, kind: AstFragmentKind, span: Span) {\n+crate fn annotate_err_with_kind(\n+    err: &mut DiagnosticBuilder<'_>,\n+    kind: AstFragmentKind,\n+    span: Span,\n+) {\n     match kind {\n         AstFragmentKind::Ty => {\n             err.span_label(span, \"this macro call doesn't expand to a type\");\n@@ -58,7 +62,7 @@ pub fn annotate_err_with_kind(err: &mut DiagnosticBuilder<'_>, kind: AstFragment\n }\n \n impl<'a> ParserAnyMacro<'a> {\n-    pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n+    crate fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro { site_span, macro_ident, ref mut parser, arm_span } = *self;\n         let fragment = panictry!(parser.parse_ast_fragment(kind, true).map_err(|mut e| {\n             if parser.token == token::Eof && e.message().ends_with(\", found `<eof>`\") {\n@@ -284,8 +288,8 @@ fn generic_extension<'cx>(\n //\n // Holy self-referential!\n \n-/// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile(\n+/// Converts a macro item into a syntax extension.\n+pub fn compile_declarative_macro(\n     sess: &ParseSess,\n     features: &Features,\n     def: &ast::Item,"}, {"sha": "d161e6638bf7553bd6d0b0def630a3d1f6bdeae8", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=645cdca9ba2fd3e47dedeecbb580d490fa9ef85b", "patch": "@@ -16,14 +16,14 @@ use std::iter::Peekable;\n /// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n /// that the delimiter itself might be `NoDelim`.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-pub struct Delimited {\n-    pub delim: token::DelimToken,\n-    pub tts: Vec<TokenTree>,\n+crate struct Delimited {\n+    crate delim: token::DelimToken,\n+    crate tts: Vec<TokenTree>,\n }\n \n impl Delimited {\n     /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter.\n-    pub fn open_tt(&self, span: Span) -> TokenTree {\n+    crate fn open_tt(&self, span: Span) -> TokenTree {\n         let open_span = if span.is_dummy() {\n             span\n         } else {\n@@ -33,7 +33,7 @@ impl Delimited {\n     }\n \n     /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter.\n-    pub fn close_tt(&self, span: Span) -> TokenTree {\n+    crate fn close_tt(&self, span: Span) -> TokenTree {\n         let close_span = if span.is_dummy() {\n             span\n         } else {\n@@ -44,33 +44,33 @@ impl Delimited {\n }\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-pub struct SequenceRepetition {\n+crate struct SequenceRepetition {\n     /// The sequence of token trees\n-    pub tts: Vec<TokenTree>,\n+    crate tts: Vec<TokenTree>,\n     /// The optional separator\n-    pub separator: Option<Token>,\n+    crate separator: Option<Token>,\n     /// Whether the sequence can be repeated zero (*), or one or more times (+)\n-    pub kleene: KleeneToken,\n+    crate kleene: KleeneToken,\n     /// The number of `Match`s that appear in the sequence (and subsequences)\n-    pub num_captures: usize,\n+    crate num_captures: usize,\n }\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n-pub struct KleeneToken {\n-    pub span: Span,\n-    pub op: KleeneOp,\n+crate struct KleeneToken {\n+    crate span: Span,\n+    crate op: KleeneOp,\n }\n \n impl KleeneToken {\n-    pub fn new(op: KleeneOp, span: Span) -> KleeneToken {\n+    crate fn new(op: KleeneOp, span: Span) -> KleeneToken {\n         KleeneToken { span, op }\n     }\n }\n \n /// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum KleeneOp {\n+crate enum KleeneOp {\n     /// Kleene star (`*`) for zero or more repetitions\n     ZeroOrMore,\n     /// Kleene plus (`+`) for one or more repetitions\n@@ -82,7 +82,7 @@ pub enum KleeneOp {\n /// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, and `$(...)`\n /// are \"first-class\" token trees. Useful for parsing macros.\n #[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n-pub enum TokenTree {\n+crate enum TokenTree {\n     Token(Token),\n     Delimited(DelimSpan, Lrc<Delimited>),\n     /// A kleene-style repetition sequence\n@@ -99,7 +99,7 @@ pub enum TokenTree {\n \n impl TokenTree {\n     /// Return the number of tokens in the tree.\n-    pub fn len(&self) -> usize {\n+    crate fn len(&self) -> usize {\n         match *self {\n             TokenTree::Delimited(_, ref delimed) => match delimed.delim {\n                 token::NoDelim => delimed.tts.len(),\n@@ -110,37 +110,24 @@ impl TokenTree {\n         }\n     }\n \n-    /// Returns `true` if the given token tree contains no other tokens. This is vacuously true for\n-    /// single tokens or metavar/decls, but may be false for delimited trees or sequences.\n-    pub fn is_empty(&self) -> bool {\n-        match *self {\n-            TokenTree::Delimited(_, ref delimed) => match delimed.delim {\n-                token::NoDelim => delimed.tts.is_empty(),\n-                _ => false,\n-            },\n-            TokenTree::Sequence(_, ref seq) => seq.tts.is_empty(),\n-            _ => true,\n-        }\n-    }\n-\n     /// Returns `true` if the given token tree is delimited.\n-    pub fn is_delimited(&self) -> bool {\n+    crate fn is_delimited(&self) -> bool {\n         match *self {\n             TokenTree::Delimited(..) => true,\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the given token tree is a token of the given kind.\n-    pub fn is_token(&self, expected_kind: &TokenKind) -> bool {\n+    crate fn is_token(&self, expected_kind: &TokenKind) -> bool {\n         match self {\n             TokenTree::Token(Token { kind: actual_kind, .. }) => actual_kind == expected_kind,\n             _ => false,\n         }\n     }\n \n     /// Gets the `index`-th sub-token-tree. This only makes sense for delimited trees and sequences.\n-    pub fn get_tt(&self, index: usize) -> TokenTree {\n+    crate fn get_tt(&self, index: usize) -> TokenTree {\n         match (self, index) {\n             (&TokenTree::Delimited(_, ref delimed), _) if delimed.delim == token::NoDelim => {\n                 delimed.tts[index].clone()\n@@ -160,7 +147,7 @@ impl TokenTree {\n     }\n \n     /// Retrieves the `TokenTree`'s span.\n-    pub fn span(&self) -> Span {\n+    crate fn span(&self) -> Span {\n         match *self {\n             TokenTree::Token(Token { span, .. })\n             | TokenTree::MetaVar(span, _)\n@@ -195,7 +182,7 @@ impl TokenTree {\n /// # Returns\n ///\n /// A collection of `self::TokenTree`. There may also be some errors emitted to `sess`.\n-pub fn parse(\n+crate fn parse(\n     input: tokenstream::TokenStream,\n     expect_matchers: bool,\n     sess: &ParseSess,"}, {"sha": "c06f43021021a9b48a351a015caf8313c8626c85", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=645cdca9ba2fd3e47dedeecbb580d490fa9ef85b", "patch": "@@ -162,18 +162,19 @@ pub mod ext {\n     mod proc_macro_server;\n \n     pub use syntax_pos::hygiene;\n+    pub use tt::macro_rules::compile_declarative_macro;\n     pub mod allocator;\n     pub mod base;\n     pub mod build;\n     pub mod expand;\n     pub mod proc_macro;\n \n-    pub mod tt {\n-        pub mod transcribe;\n-        pub mod macro_check;\n-        pub mod macro_parser;\n-        pub mod macro_rules;\n-        pub mod quoted;\n+    crate mod tt {\n+        crate mod transcribe;\n+        crate mod macro_check;\n+        crate mod macro_parser;\n+        crate mod macro_rules;\n+        crate mod quoted;\n     }\n }\n "}, {"sha": "15fc4b02041b78a703f09d20ce8156c620d53376", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/645cdca9ba2fd3e47dedeecbb580d490fa9ef85b/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=645cdca9ba2fd3e47dedeecbb580d490fa9ef85b", "patch": "@@ -64,7 +64,7 @@ where\n \n impl TokenTree {\n     /// Use this token tree as a matcher to parse given tts.\n-    pub fn parse(cx: &base::ExtCtxt<'_>, mtch: &[quoted::TokenTree], tts: TokenStream)\n+    crate fn parse(cx: &base::ExtCtxt<'_>, mtch: &[quoted::TokenTree], tts: TokenStream)\n                  -> macro_parser::NamedParseResult {\n         // `None` is because we're not interpolating\n         let directory = Directory {"}]}