{"sha": "05b4554e77ef32a97060b1bfffd1f621bf15bb88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YjQ1NTRlNzdlZjMyYTk3MDYwYjFiZmZmZDFmNjIxYmYxNWJiODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-05T22:56:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-05T22:56:15Z"}, "message": "Auto merge of #59741 - Centril:rollup-3us4b8q, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #58894 (Fix invalid bounds string generation in rustdoc)\n - #59599 (Updated RELEASES.md for 1.34.0)\n - #59624 (SGX target: Use linker option to avoid code CGU assignment kludge)\n - #59696 (Remove invalid assertion back::link::from add_upstream_rust_crates().)\n - #59707 (Add missing tryfrom example)\n - #59727 (wasi: Use shared API for preopened fds)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "245d505fa744308ff7ffd95a061c6c41f536638f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/245d505fa744308ff7ffd95a061c6c41f536638f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05b4554e77ef32a97060b1bfffd1f621bf15bb88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05b4554e77ef32a97060b1bfffd1f621bf15bb88", "html_url": "https://github.com/rust-lang/rust/commit/05b4554e77ef32a97060b1bfffd1f621bf15bb88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05b4554e77ef32a97060b1bfffd1f621bf15bb88/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acd8dd6a50d505057a7d7ad8d0d7a4c2bd274200", "url": "https://api.github.com/repos/rust-lang/rust/commits/acd8dd6a50d505057a7d7ad8d0d7a4c2bd274200", "html_url": "https://github.com/rust-lang/rust/commit/acd8dd6a50d505057a7d7ad8d0d7a4c2bd274200"}, {"sha": "8455818b319f47bbe3505ff5307e21d9c4acb869", "url": "https://api.github.com/repos/rust-lang/rust/commits/8455818b319f47bbe3505ff5307e21d9c4acb869", "html_url": "https://github.com/rust-lang/rust/commit/8455818b319f47bbe3505ff5307e21d9c4acb869"}], "stats": {"total": 500, "additions": 356, "deletions": 144}, "files": [{"sha": "821889d64a5fb10fb595eea1a8b95d3866e44625", "filename": "RELEASES.md", "status": "modified", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -1,3 +1,149 @@\n+Version 1.34.0 (2019-04-11)\n+==========================\n+\n+Language\n+--------\n+- [You can now use `#[deprecated = \"reason\"]`][58166] as a shorthand for\n+  `#[deprecated(note = \"reason\")]`. This was previously allowed by mistake\n+  but had no effect.\n+- [You can now accept token streams in `#[attr()]`,`#[attr[]]`, and\n+  `#[attr{}]` procedural macros.][57367]\n+- [You can now write `extern crate self as foo;`][57407] to import your\n+  crate's root into the extern prelude.\n+\n+\n+Compiler\n+--------\n+- [You can now target `riscv64imac-unknown-none-elf` and\n+  `riscv64gc-unknown-none-elf`.][58406]\n+- [You can now enable linker plugin LTO optimisations with\n+  `-C linker-plugin-lto`.][58057] This allows rustc to compile your Rust code\n+  into LLVM bitcode allowing LLVM to perform LTO optimisations across C/C++ FFI\n+  boundaries.\n+- [You can now target `powerpc64-unknown-freebsd`.][57809]\n+\n+\n+Libraries\n+---------\n+- [The trait bounds have been removed on some of `HashMap<K, V, S>`'s and\n+  `HashSet<T, S>`'s basic methods.][58370] Most notably you no longer require\n+  the `Hash` trait to create an iterator.\n+- [The `Ord` trait bounds have been removed on some of `BinaryHeap<T>`'s basic\n+  methods.][58421] Most notably you no longer require the `Ord` trait to create\n+  an iterator.\n+- [The methods `overflowing_neg` and `wrapping_neg` are now `const` functions\n+  for all numeric types.][58044]\n+- [Indexing a `str` is now generic over all types that\n+  implement `SliceIndex<str>`.][57604]\n+- [`str::trim`, `str::trim_matches`, `str::trim_{start, end}`, and\n+  `str::trim_{start, end}_matches` are now `#[must_use]`][57106] and will\n+  produce a warning if their returning type is unused.\n+- [The methods `checked_pow`, `saturating_pow`, `wrapping_pow`, and\n+  `overflowing_pow` are now available for all numeric types.][57873] These are\n+  equivalvent to methods such as `wrapping_add` for the `pow` operation.\n+\n+\n+Stabilized APIs\n+---------------\n+\n+#### std & core\n+* [`Any::type_id`]\n+* [`Error::type_id`]\n+* [`atomic::AtomicI16`]\n+* [`atomic::AtomicI32`]\n+* [`atomic::AtomicI64`]\n+* [`atomic::AtomicI8`]\n+* [`atomic::AtomicU16`]\n+* [`atomic::AtomicU32`]\n+* [`atomic::AtomicU64`]\n+* [`atomic::AtomicU8`]\n+* [`convert::Infallible`]\n+* [`convert::TryFrom`]\n+* [`convert::TryInto`]\n+* [`iter::from_fn`]\n+* [`iter::successors`]\n+* [`num::NonZeroI128`]\n+* [`num::NonZeroI16`]\n+* [`num::NonZeroI32`]\n+* [`num::NonZeroI64`]\n+* [`num::NonZeroI8`]\n+* [`num::NonZeroIsize`]\n+* [`slice::sort_by_cached_key`]\n+* [`str::escape_debug`]\n+* [`str::escape_default`]\n+* [`str::escape_unicode`]\n+* [`str::split_ascii_whitespace`]\n+\n+#### std\n+* [`Instant::checked_add`]\n+* [`Instant::checked_sub`]\n+* [`SystemTime::checked_add`]\n+* [`SystemTime::checked_sub`]\n+\n+Cargo\n+-----\n+- [You can now use alternative registries to crates.io.][cargo/6654]\n+\n+Misc\n+----\n+- [You can now use the `?` operator in your documentation tests without manually\n+  adding `fn main() -> Result<(), _> {}`.][56470]\n+\n+Compatibility Notes\n+-------------------\n+- [`Command::before_exec` is now deprecated in favor of the\n+  unsafe method `Command::pre_exec`.][58059]\n+- [Use of `ATOMIC_{BOOL, ISIZE, USIZE}_INIT` is now deprecated.][57425] As you\n+  can now use `const` functions in `static` variables.\n+\n+[58370]: https://github.com/rust-lang/rust/pull/58370/\n+[58406]: https://github.com/rust-lang/rust/pull/58406/\n+[58421]: https://github.com/rust-lang/rust/pull/58421/\n+[58166]: https://github.com/rust-lang/rust/pull/58166/\n+[58044]: https://github.com/rust-lang/rust/pull/58044/\n+[58057]: https://github.com/rust-lang/rust/pull/58057/\n+[58059]: https://github.com/rust-lang/rust/pull/58059/\n+[57809]: https://github.com/rust-lang/rust/pull/57809/\n+[57873]: https://github.com/rust-lang/rust/pull/57873/\n+[57604]: https://github.com/rust-lang/rust/pull/57604/\n+[57367]: https://github.com/rust-lang/rust/pull/57367/\n+[57407]: https://github.com/rust-lang/rust/pull/57407/\n+[57425]: https://github.com/rust-lang/rust/pull/57425/\n+[57106]: https://github.com/rust-lang/rust/pull/57106/\n+[56470]: https://github.com/rust-lang/rust/pull/56470/\n+[cargo/6654]: https://github.com/rust-lang/cargo/pull/6654/\n+[`Any::type_id`]: https://doc.rust-lang.org/std/any/trait.Any.html#tymethod.type_id\n+[`Error::type_id`]: https://doc.rust-lang.org/std/error/trait.Error.html#tymethod.type_id\n+[`atomic::AtomicI16`]: https://doc.rust-lang.org/std/atomic/struct.AtomicI16.html\n+[`atomic::AtomicI32`]: https://doc.rust-lang.org/std/atomic/struct.AtomicI32.html\n+[`atomic::AtomicI64`]: https://doc.rust-lang.org/std/atomic/struct.AtomicI64.html\n+[`atomic::AtomicI8`]: https://doc.rust-lang.org/std/atomic/struct.AtomicI8.html\n+[`atomic::AtomicU16`]: https://doc.rust-lang.org/std/atomic/struct.AtomicU16.html\n+[`atomic::AtomicU32`]: https://doc.rust-lang.org/std/atomic/struct.AtomicU32.html\n+[`atomic::AtomicU64`]: https://doc.rust-lang.org/std/atomic/struct.AtomicU64.html\n+[`atomic::AtomicU8`]: https://doc.rust-lang.org/std/atomic/struct.AtomicU8.html\n+[`convert::Infallible`]: https://doc.rust-lang.org/std/convert/enum.Infallible.html\n+[`convert::TryFrom`]: https://doc.rust-lang.org/std/convert/trait.TryFrom.html\n+[`convert::TryInto`]: https://doc.rust-lang.org/std/convert/trait.TryInto.html\n+[`iter::from_fn`]: https://doc.rust-lang.org/std/iter/fn.from_fn.html\n+[`iter::successors`]: https://doc.rust-lang.org/std/iter/fn.successors.html\n+[`num::NonZeroI128`]: https://doc.rust-lang.org/std/num/struct.NonZeroI128.html\n+[`num::NonZeroI16`]: https://doc.rust-lang.org/std/num/struct.NonZeroI16.html\n+[`num::NonZeroI32`]: https://doc.rust-lang.org/std/num/struct.NonZeroI32.html\n+[`num::NonZeroI64`]: https://doc.rust-lang.org/std/num/struct.NonZeroI64.html\n+[`num::NonZeroI8`]: https://doc.rust-lang.org/std/num/struct.NonZeroI8.html\n+[`num::NonZeroIsize`]: https://doc.rust-lang.org/std/num/struct.NonZeroIsize.html\n+[`slice::sort_by_cached_key`]: https://doc.rust-lang.org/std/slice/fn.sort_by_cached_key\n+[`str::escape_debug`]: https://doc.rust-lang.org/std/primitive.str.html#method.escape_debug\n+[`str::escape_default`]: https://doc.rust-lang.org/std/primitive.str.html#method.escape_default\n+[`str::escape_unicode`]: https://doc.rust-lang.org/std/primitive.str.html#method.escape_unicode\n+[`str::split_ascii_whitespace`]: https://doc.rust-lang.org/std/primitive.str.html#method.split_ascii_whitespace\n+[`Instant::checked_add`]: https://doc.rust-lang.org/std/time/struct.Instant.html#method.checked_add\n+[`Instant::checked_sub`]: https://doc.rust-lang.org/std/time/struct.Instant.html#method.checked_sub\n+[`SystemTime::checked_add`]: https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.checked_add\n+[`SystemTime::checked_sub`]: https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.checked_sub\n+\n+\n Version 1.33.0 (2019-02-28)\n ==========================\n \n@@ -99,6 +245,8 @@ Stabilized APIs\n \n Cargo\n -----\n+- [You can now publish crates that require a feature flag to compile with\n+  `cargo publish --features` or `cargo publish --all-features`.][cargo/6453]\n - [Cargo should now rebuild a crate if a file was modified during the initial\n   build.][cargo/6484]\n \n@@ -135,6 +283,7 @@ Compatibility Notes\n [57535]: https://github.com/rust-lang/rust/pull/57535/\n [57566]: https://github.com/rust-lang/rust/pull/57566/\n [57615]: https://github.com/rust-lang/rust/pull/57615/\n+[cargo/6453]: https://github.com/rust-lang/cargo/pull/6453/\n [cargo/6484]: https://github.com/rust-lang/cargo/pull/6484/\n [`unix::FileExt::read_exact_at`]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.read_exact_at\n [`unix::FileExt::write_all_at`]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.write_all_at"}, {"sha": "965286e5bcf645d087eab6f1c758b0b19dcb7b79", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -12,7 +12,7 @@ export PATH=`pwd`/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n git clone https://github.com/CraneStation/wasi-sysroot\n \n cd wasi-sysroot\n-git reset --hard 320054e84f8f2440def3b1c8700cedb8fd697bf8\n+git reset --hard e5f14be38362f1ab83302895a6e74b2ffd0e2302\n make -j$(nproc) INSTALL_DIR=/wasm32-unknown-wasi install\n \n cd .."}, {"sha": "e903bd936c484769705ce7440a005c70585d72e7", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -429,6 +429,26 @@ pub trait TryInto<T>: Sized {\n /// When the `!` type is stablized `Infallible` and `!` will be\n /// equivalent.\n ///\n+/// `TryFrom<T>` can be implemented as follows:\n+///\n+/// ```\n+/// use std::convert::TryFrom;\n+///\n+/// struct SuperiorThanZero(i32);\n+///\n+/// impl TryFrom<i32> for SuperiorThanZero {\n+///     type Error = &'static str;\n+///\n+///     fn try_from(value: i32) -> Result<Self, Self::Error> {\n+///         if value < 0 {\n+///             Err(\"SuperiorThanZero only accepts value superior than zero!\")\n+///         } else {\n+///             Ok(SuperiorThanZero(value))\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n /// # Examples\n ///\n /// As described, [`i32`] implements `TryFrom<i64>`:"}, {"sha": "19419a72b94dd57476590f4e6b7e069a953c1904", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -1396,10 +1396,6 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n     fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n-        // If we're performing LTO, then it should have been previously required\n-        // that all upstream rust dependencies were available in an rlib format.\n-        assert!(!are_upstream_rust_objects_already_included(sess));\n-\n         // Just need to tell the linker about where the library lives and\n         // what its name is\n         let parent = cratepath.parent();"}, {"sha": "46cf4cd8ae3530dd9ac6c0e68588be969b4d4b46", "filename": "src/librustc_target/spec/x86_64_fortanix_unknown_sgx.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -21,6 +21,15 @@ pub fn target() -> Result<Target, String> {\n         \"-Wl,--no-undefined-version\",\n         \"-Wl,-Bsymbolic\",\n         \"-Wl,--export-dynamic\",\n+        // The following symbols are needed by libunwind, which is linked after\n+        // libstd. Make sure they're included in the link.\n+        \"-Wl,-u,__rust_abort\",\n+        \"-Wl,-u,__rust_c_alloc\",\n+        \"-Wl,-u,__rust_c_dealloc\",\n+        \"-Wl,-u,__rust_print_err\",\n+        \"-Wl,-u,__rust_rwlock_rdlock\",\n+        \"-Wl,-u,__rust_rwlock_unlock\",\n+        \"-Wl,-u,__rust_rwlock_wrlock\",\n     ];\n \n     const EXPORT_SYMBOLS: &[&str] = &["}, {"sha": "0cd7fe9159493a98f4aca418ff0c5b490da37f59", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -1918,7 +1918,10 @@ fn explicit_predicates_of<'a, 'tcx>(\n         }\n     }\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = match tcx.hir().as_local_hir_id(def_id) {\n+        Some(hir_id) => hir_id,\n+        None => return tcx.predicates_of(def_id),\n+    };\n     let node = tcx.hir().get_by_hir_id(hir_id);\n \n     let mut is_trait = None;"}, {"sha": "555cb1bd64f6e16abfc39572409e538d175783a6", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -568,7 +568,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 (replaced.clone(), replaced.clean(self.cx))\n             });\n \n-        let full_generics = (&type_generics, &tcx.predicates_of(did));\n+        let full_generics = (&type_generics, &tcx.explicit_predicates_of(did));\n         let Generics {\n             params: mut generic_params,\n             .."}, {"sha": "570c61f1ffc99840532419e3f7013bc9ed851226", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                                      .collect();\n \n                         let ty = self.cx.get_real_ty(def_id, def_ctor, &real_name, generics);\n-                        let predicates = infcx.tcx.predicates_of(impl_def_id);\n+                        let predicates = infcx.tcx.explicit_predicates_of(impl_def_id);\n \n                         impls.push(Item {\n                             source: infcx.tcx.def_span(impl_def_id).clean(self.cx),"}, {"sha": "8da71cf708aa085fac99d61aa8644c11711fbc52", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -228,7 +228,7 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n }\n \n fn build_enum(cx: &DocContext<'_>, did: DefId) -> clean::Enum {\n-    let predicates = cx.tcx.predicates_of(did);\n+    let predicates = cx.tcx.explicit_predicates_of(did);\n \n     clean::Enum {\n         generics: (cx.tcx.generics_of(did), &predicates).clean(cx),\n@@ -238,7 +238,7 @@ fn build_enum(cx: &DocContext<'_>, did: DefId) -> clean::Enum {\n }\n \n fn build_struct(cx: &DocContext<'_>, did: DefId) -> clean::Struct {\n-    let predicates = cx.tcx.predicates_of(did);\n+    let predicates = cx.tcx.explicit_predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n     clean::Struct {\n@@ -254,7 +254,7 @@ fn build_struct(cx: &DocContext<'_>, did: DefId) -> clean::Struct {\n }\n \n fn build_union(cx: &DocContext<'_>, did: DefId) -> clean::Union {\n-    let predicates = cx.tcx.predicates_of(did);\n+    let predicates = cx.tcx.explicit_predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n     clean::Union {\n@@ -266,7 +266,7 @@ fn build_union(cx: &DocContext<'_>, did: DefId) -> clean::Union {\n }\n \n fn build_type_alias(cx: &DocContext<'_>, did: DefId) -> clean::Typedef {\n-    let predicates = cx.tcx.predicates_of(did);\n+    let predicates = cx.tcx.explicit_predicates_of(did);\n \n     clean::Typedef {\n         type_: cx.tcx.type_of(did).clean(cx),\n@@ -325,7 +325,7 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, ret: &mut Vec<clean::Item>) {\n         }\n     }\n \n-    let predicates = tcx.predicates_of(did);\n+    let predicates = tcx.explicit_predicates_of(did);\n     let (trait_items, generics) = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n         match tcx.hir().expect_item_by_hir_id(hir_id).node {\n             hir::ItemKind::Impl(.., ref gen, _, _, ref item_ids) => {"}, {"sha": "e994c661fdceb9f229691ac72210131bc7e46ba8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -2288,7 +2288,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n             }\n             ty::AssociatedKind::Method => {\n                 let generics = (cx.tcx.generics_of(self.def_id),\n-                                &cx.tcx.predicates_of(self.def_id)).clean(cx);\n+                                &cx.tcx.explicit_predicates_of(self.def_id)).clean(cx);\n                 let sig = cx.tcx.fn_sig(self.def_id);\n                 let mut decl = (self.def_id, sig).clean(cx);\n \n@@ -2361,7 +2361,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     // are actually located on the trait/impl itself, so we need to load\n                     // all of the generics from there and then look for bounds that are\n                     // applied to this associated type in question.\n-                    let predicates = cx.tcx.predicates_of(did);\n+                    let predicates = cx.tcx.explicit_predicates_of(did);\n                     let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n                     let mut bounds = generics.where_predicates.iter().filter_map(|pred| {\n                         let (name, self_type, trait_, bounds) = match *pred {\n@@ -3069,7 +3069,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::Opaque(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n-                let predicates_of = cx.tcx.predicates_of(def_id);\n+                let predicates_of = cx.tcx.explicit_predicates_of(def_id);\n                 let substs = cx.tcx.lift(&substs).expect(\"Opaque lift failed\");\n                 let bounds = predicates_of.instantiate(cx.tcx, substs);\n                 let mut regions = vec![];"}, {"sha": "b385d567dd8c4324fc9bc8ed7a1e941baa36dee0", "filename": "src/libstd/sys/sgx/alloc.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -1,4 +1,4 @@\n-use crate::alloc::{GlobalAlloc, Layout, System};\n+use crate::alloc::{self, GlobalAlloc, Layout, System};\n \n use super::waitqueue::SpinMutex;\n \n@@ -30,3 +30,17 @@ unsafe impl GlobalAlloc for System {\n         DLMALLOC.lock().realloc(ptr, layout.size(), layout.align(), new_size)\n     }\n }\n+\n+// The following functions are needed by libunwind. These symbols are named\n+// in pre-link args for the target specification, so keep that in sync.\n+#[cfg(not(test))]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_c_alloc(size: usize, align: usize) -> *mut u8 {\n+    alloc::alloc(Layout::from_size_align_unchecked(size, align))\n+}\n+\n+#[cfg(not(test))]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_c_dealloc(ptr: *mut u8, size: usize, align: usize) {\n+    alloc::dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n+}"}, {"sha": "a99a534f41e3ce69e073fa16024b0426a7252406", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -130,6 +130,15 @@ pub unsafe fn abort_internal() -> ! {\n     abi::usercalls::exit(true)\n }\n \n+// This function is needed by the panic runtime. The symbol is named in\n+// pre-link args for the target specification, so keep that in sync.\n+#[cfg(not(test))]\n+#[no_mangle]\n+// NB. used by both libunwind and libpanic_abort\n+pub unsafe extern \"C\" fn __rust_abort() {\n+    abort_internal();\n+}\n+\n pub fn hashmap_random_keys() -> (u64, u64) {\n     fn rdrand64() -> u64 {\n         unsafe {"}, {"sha": "30c47e44eef8ecfaa794238a95c0a3d2de13ea8c", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -1,10 +1,4 @@\n-#[cfg(not(test))]\n-use crate::alloc::{self, Layout};\n use crate::num::NonZeroUsize;\n-#[cfg(not(test))]\n-use crate::slice;\n-#[cfg(not(test))]\n-use crate::str;\n \n use super::waitqueue::{\n     try_lock_or_false, NotifiedTcs, SpinMutex, SpinMutexGuard, WaitQueue, WaitVariable,\n@@ -165,10 +159,11 @@ impl RWLock {\n     pub unsafe fn destroy(&self) {}\n }\n \n+// The following functions are needed by libunwind. These symbols are named\n+// in pre-link args for the target specification, so keep that in sync.\n #[cfg(not(test))]\n const EINVAL: i32 = 22;\n \n-// used by libunwind port\n #[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_rwlock_rdlock(p: *mut RWLock) -> i32 {\n@@ -198,39 +193,6 @@ pub unsafe extern \"C\" fn __rust_rwlock_unlock(p: *mut RWLock) -> i32 {\n     return 0;\n }\n \n-// the following functions are also used by the libunwind port. They're\n-// included here to make sure parallel codegen and LTO don't mess things up.\n-#[cfg(not(test))]\n-#[no_mangle]\n-pub unsafe extern \"C\" fn __rust_print_err(m: *mut u8, s: i32) {\n-    if s < 0 {\n-        return;\n-    }\n-    let buf = slice::from_raw_parts(m as *const u8, s as _);\n-    if let Ok(s) = str::from_utf8(&buf[..buf.iter().position(|&b| b == 0).unwrap_or(buf.len())]) {\n-        eprint!(\"{}\", s);\n-    }\n-}\n-\n-#[cfg(not(test))]\n-#[no_mangle]\n-// NB. used by both libunwind and libpanic_abort\n-pub unsafe extern \"C\" fn __rust_abort() {\n-    crate::sys::abort_internal();\n-}\n-\n-#[cfg(not(test))]\n-#[no_mangle]\n-pub unsafe extern \"C\" fn __rust_c_alloc(size: usize, align: usize) -> *mut u8 {\n-    alloc::alloc(Layout::from_size_align_unchecked(size, align))\n-}\n-\n-#[cfg(not(test))]\n-#[no_mangle]\n-pub unsafe extern \"C\" fn __rust_c_dealloc(ptr: *mut u8, size: usize, align: usize) {\n-    alloc::dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "a575401f5f60dc28fba903ebf0e6d8bc7a764c67", "filename": "src/libstd/sys/sgx/stdio.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -2,6 +2,10 @@ use fortanix_sgx_abi as abi;\n \n use crate::io;\n use crate::sys::fd::FileDesc;\n+#[cfg(not(test))]\n+use crate::slice;\n+#[cfg(not(test))]\n+use crate::str;\n \n pub struct Stdin(());\n pub struct Stdout(());\n@@ -62,3 +66,17 @@ pub fn is_ebadf(err: &io::Error) -> bool {\n pub fn panic_output() -> Option<impl io::Write> {\n     super::abi::panic::SgxPanicOutput::new()\n }\n+\n+// This function is needed by libunwind. The symbol is named in pre-link args\n+// for the target specification, so keep that in sync.\n+#[cfg(not(test))]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_print_err(m: *mut u8, s: i32) {\n+    if s < 0 {\n+        return;\n+    }\n+    let buf = slice::from_raw_parts(m as *const u8, s as _);\n+    if let Ok(s) = str::from_utf8(&buf[..buf.iter().position(|&b| b == 0).unwrap_or(buf.len())]) {\n+        eprint!(\"{}\", s);\n+    }\n+}"}, {"sha": "589593299d6093ec80ee2d22a6fe60e88d22a0bf", "filename": "src/libstd/sys/wasi/fs.rs", "status": "modified", "additions": 86, "deletions": 87, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -1,17 +1,15 @@\n-use crate::collections::HashMap;\n-use crate::ffi::{OsStr, OsString};\n+use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n use crate::io::{self, IoVec, IoVecMut, SeekFrom};\n use crate::iter;\n use crate::mem::{self, ManuallyDrop};\n use crate::os::wasi::ffi::{OsStrExt, OsStringExt};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n-use crate::sync::atomic::{AtomicPtr, Ordering::SeqCst};\n use crate::sync::Arc;\n use crate::sys::fd::{DirCookie, WasiFd};\n use crate::sys::time::SystemTime;\n-use crate::sys::{cvt_wasi, unsupported};\n+use crate::sys::unsupported;\n use crate::sys_common::FromInner;\n \n pub use crate::sys_common::fs::copy;\n@@ -230,7 +228,11 @@ impl DirEntry {\n     }\n \n     pub fn metadata(&self) -> io::Result<FileAttr> {\n-        metadata_at(&self.inner.dir.fd, 0, OsStr::from_bytes(&self.name).as_ref())\n+        metadata_at(\n+            &self.inner.dir.fd,\n+            0,\n+            OsStr::from_bytes(&self.name).as_ref(),\n+        )\n     }\n \n     pub fn file_type(&self) -> io::Result<FileType> {\n@@ -377,8 +379,8 @@ impl OpenOptions {\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let (dir, file) = open_parent(path)?;\n-        open_at(&dir, file, opts)\n+        let (dir, file) = open_parent(path, libc::__WASI_RIGHT_PATH_OPEN)?;\n+        open_at(&dir, &file, opts)\n     }\n \n     pub fn open_at(&self, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n@@ -475,7 +477,7 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let (dir, file) = open_parent(p)?;\n+        let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_CREATE_DIRECTORY)?;\n         dir.create_directory(file.as_os_str().as_bytes())\n     }\n }\n@@ -506,13 +508,13 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p)?;\n+    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_UNLINK_FILE)?;\n     dir.unlink_file(file.as_os_str().as_bytes())\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let (old, old_file) = open_parent(old)?;\n-    let (new, new_file) = open_parent(new)?;\n+    let (old, old_file) = open_parent(old, libc::__WASI_RIGHT_PATH_RENAME_SOURCE)?;\n+    let (new, new_file) = open_parent(new, libc::__WASI_RIGHT_PATH_RENAME_TARGET)?;\n     old.rename(\n         old_file.as_os_str().as_bytes(),\n         &new,\n@@ -527,13 +529,13 @@ pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p)?;\n+    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_REMOVE_DIRECTORY)?;\n     dir.remove_directory(file.as_os_str().as_bytes())\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let (dir, file) = open_parent(p)?;\n-    read_link(&dir, file)\n+    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_READLINK)?;\n+    read_link(&dir, &file)\n }\n \n fn read_link(fd: &WasiFd, file: &Path) -> io::Result<PathBuf> {\n@@ -568,13 +570,13 @@ fn read_link(fd: &WasiFd, file: &Path) -> io::Result<PathBuf> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (dst, dst_file) = open_parent(dst)?;\n+    let (dst, dst_file) = open_parent(dst, libc::__WASI_RIGHT_PATH_SYMLINK)?;\n     dst.symlink(src.as_os_str().as_bytes(), dst_file.as_os_str().as_bytes())\n }\n \n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (src, src_file) = open_parent(src)?;\n-    let (dst, dst_file) = open_parent(dst)?;\n+    let (src, src_file) = open_parent(src, libc::__WASI_RIGHT_PATH_LINK_SOURCE)?;\n+    let (dst, dst_file) = open_parent(dst, libc::__WASI_RIGHT_PATH_LINK_TARGET)?;\n     src.link(\n         libc::__WASI_LOOKUP_SYMLINK_FOLLOW,\n         src_file.as_os_str().as_bytes(),\n@@ -584,13 +586,13 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p)?;\n-    metadata_at(&dir, libc::__WASI_LOOKUP_SYMLINK_FOLLOW, file)\n+    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_FILESTAT_GET)?;\n+    metadata_at(&dir, libc::__WASI_LOOKUP_SYMLINK_FOLLOW, &file)\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p)?;\n-    metadata_at(&dir, 0, file)\n+    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_FILESTAT_GET)?;\n+    metadata_at(&dir, 0, &file)\n }\n \n fn metadata_at(\n@@ -621,72 +623,69 @@ fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n     Ok(File { fd })\n }\n \n-// FIXME: we shouldn't implement this. It'd be much better to share this between\n-// libc (the wasi-sysroot) and Rust as the logic here is likely far more tricky\n-// than what we're executing below. For now this is a stopgap to enable this\n-// module, but we should add an official API in upstream wasi-libc which looks\n-// like this.\n-//\n-// In the meantime this is highly unlikely to be correct. It allows some basic\n-// testing but is not at all robust.\n-fn open_parent(p: &Path) -> io::Result<(&'static WasiFd, &Path)> {\n-    let map = preopened_map();\n-    for ancestor in p.ancestors() {\n-        if let Some(fd) = map.get(ancestor) {\n-            let tail = p.strip_prefix(ancestor).unwrap();\n-            let tail = if tail == Path::new(\"\") {\n-                \".\".as_ref()\n-            } else {\n-                tail\n-            };\n-            return Ok((fd, tail))\n-        }\n-    }\n-    let msg = format!(\"failed to find a preopened file descriptor to open {:?}\", p);\n-    return Err(io::Error::new(io::ErrorKind::Other, msg));\n-\n-    type Preopened = HashMap<PathBuf, ManuallyDrop<WasiFd>>;\n-    fn preopened_map() -> &'static Preopened {\n-        static PTR: AtomicPtr<Preopened> = AtomicPtr::new(ptr::null_mut());\n-        unsafe {\n-            let ptr = PTR.load(SeqCst);\n-            if !ptr.is_null() {\n-                return &*ptr;\n-            }\n-\n-            let mut map = Box::new(HashMap::new());\n-            for fd in 3.. {\n-                let mut buf = mem::zeroed();\n-                if cvt_wasi(libc::__wasi_fd_prestat_get(fd, &mut buf)).is_err() {\n-                    break;\n-                }\n-                if buf.pr_type != libc::__WASI_PREOPENTYPE_DIR {\n-                    continue;\n-                }\n-                let len = buf.u.dir.pr_name_len;\n-                let mut v = vec![0u8; len];\n-                let res = cvt_wasi(libc::__wasi_fd_prestat_dir_name(\n-                    fd,\n-                    v.as_mut_ptr() as *mut i8,\n-                    v.len(),\n-                ));\n-                if res.is_err() {\n-                    continue;\n-                }\n-                let path = PathBuf::from(OsString::from_vec(v));\n-                map.insert(path, ManuallyDrop::new(WasiFd::from_raw(fd)));\n-            }\n-            let ptr = Box::into_raw(map);\n-            match PTR.compare_exchange(ptr::null_mut(), ptr, SeqCst, SeqCst) {\n-                Ok(_) => &*ptr,\n-\n-                // If we lost the race for initialization clean up the map we\n-                // made and just use the one that's already there\n-                Err(other) => {\n-                    drop(Box::from_raw(ptr));\n-                    &*other\n-                }\n-            }\n+/// Attempts to open a bare path `p`.\n+///\n+/// WASI has no fundamental capability to do this. All syscalls and operations\n+/// are relative to already-open file descriptors. The C library, however,\n+/// manages a map of preopened file descriptors to their path, and then the C\n+/// library provides an API to look at this. In other words, when you want to\n+/// open a path `p`, you have to find a previously opened file descriptor in a\n+/// global table and then see if `p` is relative to that file descriptor.\n+///\n+/// This function, if successful, will return two items:\n+///\n+/// * The first is a `ManuallyDrop<WasiFd>`. This represents a preopened file\n+///   descriptor which we don't have ownership of, but we can use. You shouldn't\n+///   actually drop the `fd`.\n+///\n+/// * The second is a path that should be a part of `p` and represents a\n+///   relative traversal from the file descriptor specified to the desired\n+///   location `p`.\n+///\n+/// If successful you can use the returned file descriptor to perform\n+/// file-descriptor-relative operations on the path returned as well. The\n+/// `rights` argument indicates what operations are desired on the returned file\n+/// descriptor, and if successful the returned file descriptor should have the\n+/// appropriate rights for performing `rights` actions.\n+///\n+/// Note that this can fail if `p` doesn't look like it can be opened relative\n+/// to any preopened file descriptor.\n+fn open_parent(\n+    p: &Path,\n+    rights: libc::__wasi_rights_t,\n+) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n+    let p = CString::new(p.as_os_str().as_bytes())?;\n+    unsafe {\n+        let mut ret = ptr::null();\n+        let fd = __wasilibc_find_relpath(p.as_ptr(), rights, 0, &mut ret);\n+        if fd == -1 {\n+            let msg = format!(\n+                \"failed to find a preopened file descriptor \\\n+                 through which {:?} could be opened\",\n+                p\n+            );\n+            return Err(io::Error::new(io::ErrorKind::Other, msg));\n         }\n+        let path = Path::new(OsStr::from_bytes(CStr::from_ptr(ret).to_bytes()));\n+\n+        // FIXME: right now `path` is a pointer into `p`, the `CString` above.\n+        // When we return `p` is deallocated and we can't use it, so we need to\n+        // currently separately allocate `path`. If this becomes an issue though\n+        // we should probably turn this into a closure-taking interface or take\n+        // `&CString` and then pass off `&Path` tied to the same lifetime.\n+        let path = path.to_path_buf();\n+\n+        return Ok((ManuallyDrop::new(WasiFd::from_raw(fd as u32)), path));\n+    }\n+\n+    // FIXME(rust-lang/libc#1314) use the `libc` crate for this when the API\n+    // there is published\n+    extern \"C\" {\n+        pub fn __wasilibc_find_relpath(\n+            path: *const libc::c_char,\n+            rights_base: libc::__wasi_rights_t,\n+            rights_inheriting: libc::__wasi_rights_t,\n+            relative_path: *mut *const libc::c_char,\n+        ) -> libc::c_int;\n     }\n }"}, {"sha": "ab8ee6c2ef7e11aa80d0824c9c072ea467c7b378", "filename": "src/test/run-make-fulldeps/lto-dylib-dep/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Ftest%2Frun-make-fulldeps%2Flto-dylib-dep%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Ftest%2Frun-make-fulldeps%2Flto-dylib-dep%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flto-dylib-dep%2FMakefile?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -0,0 +1,10 @@\n+-include ../tools.mk\n+\n+# Test that we don't run into an assertion when using a Rust dylib dependency\n+# while compiling with full LTO.\n+# See https://github.com/rust-lang/rust/issues/59137\n+\n+all:\n+\t$(RUSTC) a_dylib.rs --crate-type=dylib -C prefer-dynamic\n+\t$(RUSTC) main.rs -C lto\n+\t$(call RUN,main)"}, {"sha": "c5a35296f89ed8342304b4a975eba225f4c6068d", "filename": "src/test/run-make-fulldeps/lto-dylib-dep/a_dylib.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Ftest%2Frun-make-fulldeps%2Flto-dylib-dep%2Fa_dylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Ftest%2Frun-make-fulldeps%2Flto-dylib-dep%2Fa_dylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flto-dylib-dep%2Fa_dylib.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -0,0 +1,4 @@\n+\n+pub fn foo() {\n+    println!(\"bar\");\n+}"}, {"sha": "af0955e7f3520fa7c36483156c465092e9a4de82", "filename": "src/test/run-make-fulldeps/lto-dylib-dep/main.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Ftest%2Frun-make-fulldeps%2Flto-dylib-dep%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Ftest%2Frun-make-fulldeps%2Flto-dylib-dep%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flto-dylib-dep%2Fmain.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -0,0 +1,6 @@\n+\n+extern crate a_dylib;\n+\n+fn main() {\n+    a_dylib::foo();\n+}"}, {"sha": "f530d8a654f011dd440e2122ad49c317ad685282", "filename": "src/test/rustdoc/useless_lifetime_bound.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Ftest%2Frustdoc%2Fuseless_lifetime_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05b4554e77ef32a97060b1bfffd1f621bf15bb88/src%2Ftest%2Frustdoc%2Fuseless_lifetime_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fuseless_lifetime_bound.rs?ref=05b4554e77ef32a97060b1bfffd1f621bf15bb88", "patch": "@@ -0,0 +1,13 @@\n+use std::marker::PhantomData;\n+\n+// @has useless_lifetime_bound/struct.Scope.html\n+// @!has - '//*[@class=\"rust struct\"]' \"'env: 'env\"\n+pub struct Scope<'env> {\n+    _marker: PhantomData<&'env mut &'env ()>,\n+}\n+\n+// @has useless_lifetime_bound/struct.Scope.html\n+// @!has - '//*[@class=\"rust struct\"]' \"T: 'a + 'a\"\n+pub struct SomeStruct<'a, T: 'a> {\n+    _marker: PhantomData<&'a T>,\n+}"}]}