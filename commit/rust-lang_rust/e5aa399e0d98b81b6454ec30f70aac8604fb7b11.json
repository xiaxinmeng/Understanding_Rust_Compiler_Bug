{"sha": "e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1YWEzOTllMGQ5OGI4MWI2NDU0ZWMzMGY3MGFhYzg2MDRmYjdiMTE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-13T19:46:14Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-13T19:46:25Z"}, "message": "rustc and std: teach about #[bench], modernize to use quote_expr! some.", "tree": {"sha": "ba22a293be74c354a7f98c300fd7e92203905f14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba22a293be74c354a7f98c300fd7e92203905f14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "html_url": "https://github.com/rust-lang/rust/commit/e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebe99637fda18617684a7ae720247315701f19d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe99637fda18617684a7ae720247315701f19d3", "html_url": "https://github.com/rust-lang/rust/commit/ebe99637fda18617684a7ae720247315701f19d3"}], "stats": {"total": 1012, "additions": 610, "deletions": 402}, "files": [{"sha": "ccd1b899ce34f3b6934d8852e6a27d79409945c9", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "patch": "@@ -33,7 +33,7 @@ mod errors;\n use std::getopts;\n use std::test;\n \n-use core::result;\n+use core::{result, either};\n use result::{Ok, Err};\n \n use common::config;\n@@ -158,7 +158,11 @@ pub fn test_opts(config: config) -> test::TestOpts {\n     test::TestOpts {\n         filter: config.filter,\n         run_ignored: config.run_ignored,\n-        logfile: config.logfile.map(|s| s.to_str()),\n+        logfile: copy config.logfile,\n+        run_tests: true,\n+        run_benchmarks: false,\n+        save_results: option::None,\n+        compare_results: option::None\n     }\n }\n \n@@ -210,13 +214,15 @@ pub fn make_test(config: config, testfile: &Path) -> test::TestDescAndFn {\n     }\n }\n \n-pub fn make_test_name(config: config, testfile: &Path) -> ~str {\n-    fmt!(\"[%s] %s\", mode_str(config.mode), testfile.to_str())\n+pub fn make_test_name(config: config, testfile: &Path) -> test::TestName {\n+    test::DynTestName(fmt!(\"[%s] %s\",\n+                           mode_str(config.mode),\n+                           testfile.to_str()))\n }\n \n pub fn make_test_closure(config: config, testfile: &Path) -> test::TestFn {\n     let testfile = testfile.to_str();\n-    fn~() { runtest::run(config, testfile) }\n+    test::DynTestFn(fn~() { runtest::run(config, testfile) })\n }\n \n // Local Variables:"}, {"sha": "b8f60c1a2d906a59a0a5c9fa1e10317004b6c5a8", "filename": "src/libcore/either.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "patch": "@@ -145,7 +145,7 @@ pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     }\n }\n \n-impl<T, U> Either<T, U> {\n+pub impl<T, U> Either<T, U> {\n     #[inline(always)]\n     fn either<V>(&self, f_left: fn(&T) -> V, f_right: fn(&U) -> V) -> V {\n         either(f_left, f_right, self)"}, {"sha": "bc5a42262ca9cfc722d953594b3930ebe4d16b8b", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "patch": "@@ -39,7 +39,7 @@ pub trait One {\n     static pure fn one() -> Self;\n }\n \n-pub pure fn abs<T: cmp::Ord Num Zero>(v: T) -> T {\n+pub pure fn abs<T: Ord Num Zero>(v: T) -> T {\n     if v < Zero::zero() { v.neg() } else { v }\n }\n "}, {"sha": "caa2035389d6342fdb8f3ef40c10e18ed948e51a", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 151, "deletions": 307, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "patch": "@@ -21,18 +21,21 @@ use core::option;\n use core::vec;\n use syntax::ast_util::*;\n use syntax::attr;\n-use syntax::codemap::{dummy_sp, span};\n+use syntax::codemap::{dummy_sp, span, ExpandedFrom};\n use syntax::codemap;\n use syntax::fold;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::attr::attrs_contains_name;\n \n+use syntax::ext::base::{mk_ctxt, ext_ctxt};\n+\n type node_id_gen = fn@() -> ast::node_id;\n \n type test = {\n     span: span,\n     path: ~[ast::ident],\n+    bench: bool,\n     ignore: bool,\n     should_fail: bool\n };\n@@ -41,6 +44,7 @@ struct TestCtxt {\n     sess: session::Session,\n     crate: @ast::crate,\n     path: ~[ast::ident],\n+      ext_cx: ext_ctxt,\n     testfns: ~[test]\n }\n \n@@ -68,25 +72,32 @@ fn generate_test_harness(sess: session::Session,\n     let cx: @mut TestCtxt = @mut TestCtxt {\n         sess: sess,\n         crate: crate,\n+        ext_cx: mk_ctxt(sess.parse_sess, copy sess.opts.cfg),\n         path: ~[],\n         testfns: ~[]\n     };\n \n+    cx.ext_cx.bt_push(ExpandedFrom({call_site: dummy_sp(),\n+                                    callie: {name: ~\"test\",\n+                                             span: None}}));\n+\n     let precursor = @fold::AstFoldFns {\n         fold_crate: fold::wrap(|a,b| fold_crate(cx, a, b) ),\n         fold_item: |a,b| fold_item(cx, a, b),\n         fold_mod: |a,b| fold_mod(cx, a, b),.. *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(*crate);\n+    cx.ext_cx.bt_pop();\n     return res;\n }\n \n fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     do config::strip_items(crate) |attrs| {\n-        !attr::contains_name(attr::attr_metas(attrs), ~\"test\")\n+        !attr::contains_name(attr::attr_metas(attrs), ~\"test\") &&\n+        !attr::contains_name(attr::attr_metas(attrs), ~\"bench\")\n     }\n }\n \n@@ -132,7 +143,7 @@ fn fold_item(cx: @mut TestCtxt, &&i: @ast::item, fld: fold::ast_fold)\n     debug!(\"current path: %s\",\n            ast_util::path_name_i(cx.path, cx.sess.parse_sess.interner));\n \n-    if is_test_fn(i) {\n+    if is_test_fn(i) || is_bench_fn(i) {\n         match i.node {\n           ast::item_fn(_, purity, _, _) if purity == ast::unsafe_fn => {\n             let sess = cx.sess;\n@@ -143,10 +154,12 @@ fn fold_item(cx: @mut TestCtxt, &&i: @ast::item, fld: fold::ast_fold)\n           _ => {\n             debug!(\"this is a test function\");\n             let test = {span: i.span,\n-                        path: /*bad*/copy cx.path, ignore: is_ignored(cx, i),\n+                        path: /*bad*/copy cx.path,\n+                        bench: is_bench_fn(i),\n+                        ignore: is_ignored(cx, i),\n                         should_fail: should_fail(i)};\n             cx.testfns.push(test);\n-            debug!(\"have %u test functions\", cx.testfns.len());\n+            debug!(\"have %u test/bench functions\", cx.testfns.len());\n           }\n         }\n     }\n@@ -176,6 +189,31 @@ fn is_test_fn(i: @ast::item) -> bool {\n     return has_test_attr && has_test_signature(i);\n }\n \n+fn is_bench_fn(i: @ast::item) -> bool {\n+    let has_bench_attr =\n+        vec::len(attr::find_attrs_by_name(i.attrs, ~\"bench\")) > 0u;\n+\n+    fn has_test_signature(i: @ast::item) -> bool {\n+        match /*bad*/copy i.node {\n+            ast::item_fn(decl, _, tps, _) => {\n+                let input_cnt = vec::len(decl.inputs);\n+                let no_output = match decl.output.node {\n+                    ast::ty_nil => true,\n+                    _ => false\n+                };\n+                let tparm_cnt = vec::len(tps);\n+                // NB: inadequate check, but we're running\n+                // well before resolve, can't get too deep.\n+                input_cnt == 1u\n+                    && no_output && tparm_cnt == 0u\n+            }\n+          _ => false\n+        }\n+    }\n+\n+    return has_bench_attr && has_test_signature(i);\n+}\n+\n fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, \"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n@@ -194,7 +232,7 @@ fn should_fail(i: @ast::item) -> bool {\n     vec::len(attr::find_attrs_by_name(i.attrs, ~\"should_fail\")) > 0u\n }\n \n-fn add_test_module(cx: @mut TestCtxt, +m: ast::_mod) -> ast::_mod {\n+fn add_test_module(cx: &TestCtxt, +m: ast::_mod) -> ast::_mod {\n     let testmod = mk_test_module(cx);\n     ast::_mod {\n         items: vec::append_one(/*bad*/copy m.items, testmod),\n@@ -207,47 +245,84 @@ fn add_test_module(cx: @mut TestCtxt, +m: ast::_mod) -> ast::_mod {\n We're going to be building a module that looks more or less like:\n \n mod __test {\n-  fn main(args: ~[str]) -> int {\n-    std::test::test_main(args, tests())\n+  #[!resolve_unexported]\n+  extern mod std (name = \"std\", vers = \"...\");\n+  fn main() {\n+    #[main];\n+    std::test::test_main_static(::os::args(), tests)\n   }\n \n-  fn tests() -> ~[std::test::test_desc] {\n+  const tests : &static/[std::test::TestDescAndFn] = &[\n     ... the list of tests in the crate ...\n-  }\n+  ];\n }\n \n */\n \n-fn mk_test_module(cx: @mut TestCtxt) -> @ast::item {\n+fn mk_std(cx: &TestCtxt) -> @ast::view_item {\n+    let vers = ast::lit_str(@~\"0.6\");\n+    let vers = nospan(vers);\n+    let mi = ast::meta_name_value(~\"vers\", vers);\n+    let mi = nospan(mi);\n+    let id_std = cx.sess.ident_of(~\"std\");\n+    let vi = if is_std(cx) {\n+        ast::view_item_import(\n+            ~[@nospan(ast::view_path_simple(id_std,\n+                                            path_node(~[id_std]),\n+                                            ast::type_value_ns,\n+                                            cx.sess.next_node_id()))])\n+    } else {\n+        ast::view_item_use(id_std, ~[@mi],\n+                           cx.sess.next_node_id())\n+    };\n+    let vi = ast::view_item {\n+        node: vi,\n+        attrs: ~[],\n+        vis: ast::private,\n+        span: dummy_sp()\n+    };\n+    return @vi;\n+}\n+\n+fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n+\n     // Link to std\n-    let std = mk_std(cx);\n-    let view_items = if is_std(cx) { ~[] } else { ~[std] };\n-    // A function that generates a vector of test descriptors to feed to the\n-    // test runner\n-    let testsfn = mk_tests(cx);\n+    let view_items = ~[mk_std(cx)];\n+\n+    // A constant vector of test descriptors.\n+    let tests = mk_tests(cx);\n+\n     // The synthesized main function which will call the console test runner\n     // with our list of tests\n-    let mainfn = mk_main(cx);\n+    let ext_cx = cx.ext_cx;\n+    let mainfn = (quote_item!(\n+        pub fn main() {\n+            #[main];\n+            std::test::test_main_static(::os::args(), tests);\n+        }\n+    )).get();\n+\n     let testmod = ast::_mod {\n         view_items: view_items,\n-        items: ~[mainfn, testsfn],\n+        items: ~[mainfn, tests],\n     };\n     let item_ = ast::item_mod(testmod);\n+\n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_attr =\n         attr::mk_attr(attr::mk_word_item(~\"!resolve_unexported\"));\n-    let sess = cx.sess;\n+\n     let item = ast::item {\n-        ident: sess.ident_of(~\"__test\"),\n+        ident: cx.sess.ident_of(~\"__test\"),\n         attrs: ~[resolve_unexported_attr],\n-        id: sess.next_node_id(),\n+        id: cx.sess.next_node_id(),\n         node: item_,\n         vis: ast::public,\n         span: dummy_sp(),\n-    };\n+     };\n \n     debug!(\"Synthetic test module:\\n%s\\n\",\n-           pprust::item_to_str(@copy item, sess.intr()));\n+           pprust::item_to_str(@copy item, cx.sess.intr()));\n \n     return @item;\n }\n@@ -258,10 +333,10 @@ fn nospan<T: Copy>(t: T) -> codemap::spanned<T> {\n \n fn path_node(+ids: ~[ast::ident]) -> @ast::path {\n     @ast::path { span: dummy_sp(),\n-                 global: false,\n-                 idents: ids,\n-                 rp: None,\n-                 types: ~[] }\n+                global: false,\n+                idents: ids,\n+                rp: None,\n+                types: ~[] }\n }\n \n fn path_node_global(+ids: ~[ast::ident]) -> @ast::path {\n@@ -272,56 +347,22 @@ fn path_node_global(+ids: ~[ast::ident]) -> @ast::path {\n                  types: ~[] }\n }\n \n-fn mk_std(cx: @mut TestCtxt) -> @ast::view_item {\n-    let vers = ast::lit_str(@~\"0.6\");\n-    let vers = nospan(vers);\n-    let mi = ast::meta_name_value(~\"vers\", vers);\n-    let mi = nospan(mi);\n-    let sess = cx.sess;\n-    let vi = ast::view_item_use(sess.ident_of(~\"std\"),\n-                                ~[@mi],\n-                                sess.next_node_id());\n-    let vi = ast::view_item {\n-        node: vi,\n-        attrs: ~[],\n-        vis: ast::private,\n-        span: dummy_sp()\n-    };\n-\n-    return @vi;\n-}\n \n-fn mk_tests(cx: @mut TestCtxt) -> @ast::item {\n-    let ret_ty = mk_test_desc_and_fn_vec_ty(cx);\n+fn mk_tests(cx: &TestCtxt) -> @ast::item {\n \n-    let decl = ast::fn_decl {\n-        inputs: ~[],\n-        output: ret_ty,\n-        cf: ast::return_val,\n-    };\n+    let ext_cx = cx.ext_cx;\n \n     // The vector of test_descs for this crate\n-    let test_descs = mk_test_desc_and_fn_vec(cx);\n-\n-    let sess = cx.sess;\n-    let body_: ast::blk_ = default_block(~[],\n-                                         option::Some(test_descs),\n-                                         sess.next_node_id());\n-    let body = nospan(body_);\n+    let test_descs = mk_test_descs(cx);\n \n-    let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n-    let item = ast::item {\n-        ident: sess.ident_of(~\"tests\"),\n-        attrs: ~[],\n-        id: sess.next_node_id(),\n-        node: item_,\n-        vis: ast::public,\n-        span: dummy_sp(),\n-    };\n-    return @item;\n+    (quote_item!(\n+        pub const tests : &static/[self::std::test::TestDescAndFn] =\n+            $test_descs\n+        ;\n+    )).get()\n }\n \n-fn is_std(cx: @mut TestCtxt) -> bool {\n+fn is_std(cx: &TestCtxt) -> bool {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n         match attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n@@ -332,55 +373,11 @@ fn is_std(cx: @mut TestCtxt) -> bool {\n     return is_std;\n }\n \n-fn mk_path(cx: @mut TestCtxt, +path: ~[ast::ident]) -> @ast::path {\n-    // For tests that are inside of std we don't want to prefix\n-    // the paths with std::\n-    let sess = cx.sess;\n-    if is_std(cx) {\n-        path_node_global(path)\n-    } else {\n-        path_node(~[ sess.ident_of(~\"self\"), sess.ident_of(~\"std\") ] + path)\n-    }\n-}\n-\n-// The ast::Ty of ~[std::test::test_desc]\n-fn mk_test_desc_and_fn_vec_ty(cx: @mut TestCtxt) -> @ast::Ty {\n-    let sess = cx.sess;\n-    let test_desc_and_fn_ty_path = mk_path(cx, ~[\n-        sess.ident_of(~\"test\"),\n-        sess.ident_of(~\"TestDescAndFn\")\n-    ]);\n-\n-    let test_desc_and_fn_ty = ast::Ty {\n-        id: sess.next_node_id(),\n-        node: ast::ty_path(test_desc_and_fn_ty_path, sess.next_node_id()),\n-        span: dummy_sp(),\n-    };\n-\n-    let vec_mt = ast::mt {ty: @test_desc_and_fn_ty,\n-                          mutbl: ast::m_imm};\n-\n-    let inner_ty = @ast::Ty {\n-        id: sess.next_node_id(),\n-        node: ast::ty_vec(vec_mt),\n-        span: dummy_sp(),\n-    };\n-\n-    @ast::Ty {\n-        id: sess.next_node_id(),\n-        node: ast::ty_uniq(ast::mt { ty: inner_ty, mutbl: ast::m_imm }),\n-        span: dummy_sp(),\n-    }\n-}\n-\n-fn mk_test_desc_and_fn_vec(cx: @mut TestCtxt) -> @ast::expr {\n+fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n-    {\n-        let testfns = &mut cx.testfns;\n-        for testfns.each |test| {\n-            descs.push(mk_test_desc_and_fn_rec(cx, *test));\n-        }\n+    for cx.testfns.each |test| {\n+        descs.push(mk_test_desc_and_fn_rec(cx, *test));\n     }\n \n     let sess = cx.sess;\n@@ -394,223 +391,70 @@ fn mk_test_desc_and_fn_vec(cx: @mut TestCtxt) -> @ast::expr {\n     @ast::expr {\n         id: sess.next_node_id(),\n         callee_id: sess.next_node_id(),\n-        node: ast::expr_vstore(inner_expr, ast::expr_vstore_uniq),\n+        node: ast::expr_vstore(inner_expr, ast::expr_vstore_slice),\n         span: dummy_sp(),\n     }\n }\n \n-fn mk_test_desc_and_fn_rec(cx: @mut TestCtxt, test: test) -> @ast::expr {\n+fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: test) -> @ast::expr {\n     let span = test.span;\n     let path = /*bad*/copy test.path;\n \n-    let sess = cx.sess;\n-    debug!(\"encoding %s\",\n-           ast_util::path_name_i(path, sess.parse_sess.interner));\n+    let ext_cx = cx.ext_cx;\n+\n+    debug!(\"encoding %s\", ast_util::path_name_i(path,\n+                                                cx.sess.parse_sess.interner));\n \n     let name_lit: ast::lit =\n         nospan(ast::lit_str(@ast_util::path_name_i(\n             path,\n-            sess.parse_sess.interner)));\n-\n-    let name_expr_inner = @ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: ast::expr_lit(@name_lit),\n-        span: span,\n-    };\n-\n-    let name_expr = ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: ast::expr_vstore(name_expr_inner, ast::expr_vstore_uniq),\n-        span: dummy_sp(),\n-    };\n-\n-    let name_field = nospan(ast::field_ {\n-        mutbl: ast::m_imm,\n-        ident: sess.ident_of(~\"name\"),\n-        expr: @name_expr,\n-    });\n-\n-    let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n-\n-    let ignore_expr = ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: ast::expr_lit(@ignore_lit),\n-        span: span,\n-    };\n-\n-    let ignore_field = nospan(ast::field_ {\n-        mutbl: ast::m_imm,\n-        ident: sess.ident_of(~\"ignore\"),\n-        expr: @ignore_expr,\n-    });\n-\n-    let fail_lit: ast::lit = nospan(ast::lit_bool(test.should_fail));\n-\n-    let fail_expr = ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: ast::expr_lit(@fail_lit),\n-        span: span,\n-    };\n-\n-    let fail_field = nospan(ast::field_ {\n-        mutbl: ast::m_imm,\n-        ident: sess.ident_of(~\"should_fail\"),\n-        expr: @fail_expr,\n-    });\n-\n-    let test_desc_path =\n-        mk_path(cx, ~[ sess.ident_of(~\"test\"), sess.ident_of(~\"TestDesc\") ]);\n+            cx.sess.parse_sess.interner)));\n \n-    let desc_rec_ = ast::expr_struct(\n-        test_desc_path,\n-        ~[name_field, ignore_field, fail_field],\n-        option::None\n-    );\n-\n-    let desc_rec = @ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: desc_rec_,\n-        span: span,\n+    let name_expr = @ast::expr {\n+          id: cx.sess.next_node_id(),\n+          callee_id: cx.sess.next_node_id(),\n+          node: ast::expr_lit(@name_lit),\n+          span: span\n     };\n \n-    let desc_field = nospan(ast::field_ {\n-        mutbl: ast::m_imm,\n-        ident: sess.ident_of(~\"desc\"),\n-        expr: desc_rec\n-    });\n-\n     let fn_path = path_node_global(path);\n \n     let fn_expr = @ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n+        id: cx.sess.next_node_id(),\n+        callee_id: cx.sess.next_node_id(),\n         node: ast::expr_path(fn_path),\n         span: span,\n     };\n \n-    let fn_field = nospan(ast::field_ {\n-        mutbl: ast::m_imm,\n-        ident: sess.ident_of(~\"testfn\"),\n-        expr: fn_expr,\n-    });\n-\n-    let test_desc_and_fn_path =\n-        mk_path(cx, ~[sess.ident_of(~\"test\"),\n-                      sess.ident_of(~\"TestDescAndFn\")]);\n-\n-    let desc_and_fn_rec = @ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: ast::expr_struct(test_desc_and_fn_path,\n-                               ~[fn_field, desc_field],\n-                               option::None),\n-        span: span,\n-    };\n-\n-    return desc_and_fn_rec;\n-}\n-\n-fn mk_main(cx: @mut TestCtxt) -> @ast::item {\n-    let sess = cx.sess;\n-    let ret_ty = ast::Ty {\n-        id: sess.next_node_id(),\n-        node: ast::ty_nil,\n-        span: dummy_sp(),\n-    };\n-\n-    let decl = ast::fn_decl {\n-        inputs: ~[],\n-        output: @ret_ty,\n-        cf: ast::return_val,\n-    };\n-\n-    let test_main_call_expr = mk_test_main_call(cx);\n-\n-    let body_: ast::blk_ =\n-        default_block(~[],\n-                      option::Some(test_main_call_expr),\n-                      sess.next_node_id());\n-    let body = codemap::spanned { node: body_, span: dummy_sp() };\n-\n-    let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n-    let item = ast::item {\n-        ident: sess.ident_of(~\"main\"),\n-        attrs: ~[attr::mk_attr(attr::mk_word_item(~\"main\"))],\n-        id: sess.next_node_id(),\n-        node: item_,\n-        vis: ast::public,\n-        span: dummy_sp(),\n-    };\n-    return @item;\n-}\n-\n-fn mk_test_main_call(cx: @mut TestCtxt) -> @ast::expr {\n-    // Call os::args to generate the vector of test_descs\n-    let sess = cx.sess;\n-    let args_path = path_node_global(~[\n-        sess.ident_of(~\"os\"),\n-        sess.ident_of(~\"args\")\n-    ]);\n-\n-    let args_path_expr = ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: ast::expr_path(args_path),\n-        span: dummy_sp(),\n-    };\n-\n-    let args_call_expr = ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: ast::expr_call(@args_path_expr, ~[], ast::NoSugar),\n-        span: dummy_sp(),\n-    };\n-\n-    // Call __test::test to generate the vector of test_descs\n-    let test_path = path_node(~[ sess.ident_of(~\"tests\") ]);\n-\n-    let test_path_expr = ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: ast::expr_path(test_path),\n-        span: dummy_sp(),\n-    };\n-\n-    let test_call_expr = ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: ast::expr_call(@test_path_expr, ~[], ast::NoSugar),\n-        span: dummy_sp(),\n+    let t_expr = if test.bench {\n+        quote_expr!( self::std::test::StaticBenchFn($fn_expr) )\n+    } else {\n+        quote_expr!( self::std::test::StaticTestFn($fn_expr) )\n     };\n \n-    // Call std::test::test_main\n-    let test_main_path = mk_path(cx, ~[\n-        sess.ident_of(~\"test\"),\n-        sess.ident_of(~\"test_main\")\n-    ]);\n-\n-    let test_main_path_expr = ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: ast::expr_path(test_main_path),\n-        span: dummy_sp(),\n+    let ignore_expr = if test.ignore {\n+        quote_expr!( true )\n+    } else {\n+        quote_expr!( false )\n     };\n \n-    let test_main_call_expr = ast::expr {\n-        id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n-        node: ast::expr_call(@test_main_path_expr,\n-                             ~[@args_call_expr, @test_call_expr],\n-                             ast::NoSugar),\n-        span: dummy_sp(),\n+    let fail_expr = if test.should_fail {\n+        quote_expr!( true )\n+    } else {\n+        quote_expr!( false )\n     };\n \n-    return @test_main_call_expr;\n+    let e = quote_expr!(\n+        self::std::test::TestDescAndFn {\n+            desc: self::std::test::TestDesc {\n+                name: self::std::test::StaticTestName($name_expr),\n+                ignore: $ignore_expr,\n+                should_fail: $fail_expr\n+            },\n+            testfn: $t_expr,\n+        }\n+    );\n+    e\n }\n \n // Local Variables:"}, {"sha": "8890da1587d9ca94c08154a1c51ac80856c8a0b2", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "patch": "@@ -127,15 +127,15 @@ pub fn check_expr(sess: Session,\n                               items without type parameters\");\n             }\n             match def_map.find(&e.id) {\n-              Some(def_const(def_id)) |\n-                Some(def_fn(def_id, _)) |\n-                Some(def_variant(_, def_id)) |\n-                Some(def_struct(def_id)) => {\n+                Some(def_variant(_, _)) |\n+                Some(def_struct(_)) => { }\n+\n+                Some(def_const(def_id)) |\n+                Some(def_fn(def_id, _)) => {\n                 if !ast_util::is_local(def_id) {\n                     sess.span_err(\n                         e.span, ~\"paths in constants may only refer to \\\n-                                 crate-local constants, functions, or \\\n-                                 structs\");\n+                                 crate-local constants or functions\");\n                 }\n               }\n               Some(def) => {"}, {"sha": "2048cb6c59f0d7d6e7f7b1160a5c6628cc73c523", "filename": "src/libstd/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibstd%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibstd%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstats.rs?ref=e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "patch": "@@ -52,7 +52,7 @@ impl &[f64] : Stats {\n \n     fn median(self) -> f64 {\n         assert self.len() != 0;\n-        let tmp = vec::to_mut(vec::from_slice(self));\n+        let tmp = vec::cast_to_mut(vec::from_slice(self));\n         sort::tim_sort(tmp);\n         if tmp.len() & 1 == 0 {\n             let m = tmp.len() / 2;"}, {"sha": "3c2baae6d57c1caa50b4e45342f9050c0de0ee83", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "patch": "@@ -115,6 +115,7 @@ pub mod serialize;\n #[doc(hidden)] // FIXME #3538\n mod std {\n     pub use serialize;\n+    pub use test;\n }\n \n // Local Variables:"}, {"sha": "f3e96826a8e597bda9d51d56d595cf1c6b24a7f5", "filename": "src/libstd/test.rs", "status": "modified", "additions": 435, "deletions": 78, "changes": 513, "blob_url": "https://github.com/rust-lang/rust/blob/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "patch": "@@ -20,6 +20,8 @@ use sort;\n use term;\n \n use core::cmp::Eq;\n+\n+use core::to_str::ToStr;\n use core::either::Either;\n use core::either;\n use core::io::WriterUtil;\n@@ -43,13 +45,62 @@ extern mod rustrt {\n // paths; i.e. it should be a series of identifiers seperated by double\n // colons. This way if some test runner wants to arrange the tests\n // hierarchically it may.\n-pub type TestName = ~str;\n+\n+#[cfg(stage0)]\n+pub enum TestName {\n+    // Stage0 doesn't understand sendable &static/str yet\n+    StaticTestName(&static/[u8]),\n+    DynTestName(~str)\n+}\n+\n+#[cfg(stage0)]\n+impl ToStr for TestName {\n+    pure fn to_str(&self) -> ~str {\n+        match self {\n+            &StaticTestName(s) => str::from_bytes(s),\n+            &DynTestName(s) => s.to_str()\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub enum TestName {\n+    StaticTestName(&static/str),\n+    DynTestName(~str)\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl ToStr for TestName {\n+    pure fn to_str(&self) -> ~str {\n+        match self {\n+            &StaticTestName(s) => s.to_str(),\n+            &DynTestName(s) => s.to_str()\n+        }\n+    }\n+}\n \n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function fails then the test fails. We\n // may need to come up with a more clever definition of test in order\n // to support isolation of tests into tasks.\n-pub type TestFn = ~fn();\n+pub enum TestFn {\n+    StaticTestFn(extern fn()),\n+    StaticBenchFn(extern fn(&mut BenchHarness)),\n+    DynTestFn(~fn()),\n+    DynBenchFn(~fn(&mut BenchHarness))\n+}\n+\n+// Structure passed to BenchFns\n+pub struct BenchHarness {\n+    iterations: u64,\n+    ns_start: u64,\n+    ns_end: u64,\n+    bytes: u64\n+}\n \n // The definition of a single test. A test runner will run a list of\n // these.\n@@ -65,7 +116,7 @@ pub struct TestDescAndFn {\n }\n \n // The default console test runner. It accepts the command line\n-// arguments and a vector of test_descs (generated at compile time).\n+// arguments and a vector of test_descs.\n pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n     let opts =\n         match parse_opts(args) {\n@@ -75,18 +126,51 @@ pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n     if !run_tests_console(&opts, tests) { die!(~\"Some tests failed\"); }\n }\n \n+// A variant optimized for invocation with a static test vector.\n+// This will fail (intentionally) when fed any dynamic tests, because\n+// it is copying the static values out into a dynamic vector and cannot\n+// copy dynamic values. It is doing this because from this point on\n+// a ~[TestDescAndFn] is used in order to effect ownership-transfer\n+// semantics into parallel test runners, which in turn requires a ~[]\n+// rather than a &[].\n+pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n+    let owned_tests = do tests.map |t| {\n+        match t.testfn {\n+            StaticTestFn(f) =>\n+            TestDescAndFn { testfn: StaticTestFn(f), desc: copy t.desc },\n+\n+            StaticBenchFn(f) =>\n+            TestDescAndFn { testfn: StaticBenchFn(f), desc: copy t.desc },\n+\n+            _ => {\n+                die! (~\"non-static tests passed to test::test_main_static\");\n+            }\n+        }\n+    };\n+    test_main(args, owned_tests)\n+}\n+\n pub struct TestOpts {\n     filter: Option<~str>,\n     run_ignored: bool,\n-    logfile: Option<~str>,\n+    run_tests: bool,\n+    run_benchmarks: bool,\n+    save_results: Option<Path>,\n+    compare_results: Option<Path>,\n+    logfile: Option<Path>\n }\n \n type OptRes = Either<TestOpts, ~str>;\n \n // Parses command line arguments into test options\n pub fn parse_opts(args: &[~str]) -> OptRes {\n     let args_ = vec::tail(args);\n-    let opts = ~[getopts::optflag(~\"ignored\"), getopts::optopt(~\"logfile\")];\n+    let opts = ~[getopts::optflag(~\"ignored\"),\n+                 getopts::optflag(~\"test\"),\n+                 getopts::optflag(~\"bench\"),\n+                 getopts::optopt(~\"save\"),\n+                 getopts::optopt(~\"diff\"),\n+                 getopts::optopt(~\"logfile\")];\n     let matches =\n         match getopts::getopts(args_, opts) {\n           Ok(move m) => m,\n@@ -99,19 +183,41 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n         } else { option::None };\n \n     let run_ignored = getopts::opt_present(&matches, ~\"ignored\");\n+\n     let logfile = getopts::opt_maybe_str(&matches, ~\"logfile\");\n+    let logfile = logfile.map(|s| Path(*s));\n+\n+    let run_benchmarks = getopts::opt_present(&matches, ~\"bench\");\n+    let run_tests = ! run_benchmarks ||\n+        getopts::opt_present(&matches, ~\"test\");\n+\n+    let save_results = getopts::opt_maybe_str(&matches, ~\"save\");\n+    let save_results = save_results.map(|s| Path(*s));\n+\n+    let compare_results = getopts::opt_maybe_str(&matches, ~\"diff\");\n+    let compare_results = compare_results.map(|s| Path(*s));\n \n     let test_opts = TestOpts {\n         filter: filter,\n         run_ignored: run_ignored,\n-        logfile: logfile,\n+        run_tests: run_tests,\n+        run_benchmarks: run_benchmarks,\n+        save_results: save_results,\n+        compare_results: compare_results,\n+        logfile: logfile\n     };\n \n     either::Left(test_opts)\n }\n \n #[deriving_eq]\n-pub enum TestResult { TrOk, TrFailed, TrIgnored, }\n+pub struct BenchSamples {\n+    ns_iter_samples: ~[f64],\n+    mb_s: uint\n+}\n+\n+#[deriving_eq]\n+pub enum TestResult { TrOk, TrFailed, TrIgnored, TrBench(BenchSamples) }\n \n struct ConsoleTestState {\n     out: io::Writer,\n@@ -121,6 +227,7 @@ struct ConsoleTestState {\n     mut passed: uint,\n     mut failed: uint,\n     mut ignored: uint,\n+    mut benchmarked: uint,\n     mut failures: ~[TestDesc]\n }\n \n@@ -137,7 +244,7 @@ pub fn run_tests_console(opts: &TestOpts,\n             st.out.write_line(fmt!(\"\\nrunning %u %s\", st.total, noun));\n           }\n           TeWait(ref test) => st.out.write_str(\n-              fmt!(\"test %s ... \", test.name)),\n+              fmt!(\"test %s ... \", test.name.to_str())),\n           TeResult(copy test, result) => {\n             match st.log_out {\n                 Some(f) => write_log(f, result, &test),\n@@ -160,14 +267,21 @@ pub fn run_tests_console(opts: &TestOpts,\n                 write_ignored(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n               }\n+              TrBench(bs) => {\n+                st.benchmarked += 1u;\n+                write_bench(st.out, st.use_color);\n+                st.out.write_line(fmt!(\": %s\",\n+                                       fmt_bench_samples(&bs)));\n+              }\n             }\n           }\n         }\n     }\n \n     let log_out = match opts.logfile {\n-        Some(ref path) => match io::file_writer(&Path(*path),\n-                                            ~[io::Create, io::Truncate]) {\n+        Some(ref path) => match io::file_writer(path,\n+                                                ~[io::Create,\n+                                                  io::Truncate]) {\n           result::Ok(w) => Some(w),\n           result::Err(ref s) => {\n               die!(fmt!(\"can't open output file: %s\", *s))\n@@ -176,20 +290,23 @@ pub fn run_tests_console(opts: &TestOpts,\n         None => None\n     };\n \n-    let st =\n-        @ConsoleTestState{out: io::stdout(),\n-          log_out: log_out,\n-          use_color: use_color(),\n-          mut total: 0,\n-          mut passed: 0,\n-          mut failed: 0,\n-          mut ignored: 0,\n-          mut failures: ~[]};\n+    let st = @ConsoleTestState {\n+        out: io::stdout(),\n+        log_out: log_out,\n+        use_color: use_color(),\n+        mut total: 0u,\n+        mut passed: 0u,\n+        mut failed: 0u,\n+        mut ignored: 0u,\n+        mut benchmarked: 0u,\n+        mut failures: ~[]\n+    };\n \n     run_tests(opts, tests, |x| callback(&x, st));\n \n-    assert (st.passed + st.failed + st.ignored == st.total);\n-    let success = st.failed == 0;\n+    assert (st.passed + st.failed +\n+            st.ignored + st.benchmarked == st.total);\n+    let success = st.failed == 0u;\n \n     if !success {\n         print_failures(st);\n@@ -199,19 +316,36 @@ pub fn run_tests_console(opts: &TestOpts,\n     if success {\n         // There's no parallelism at this point so it's safe to use color\n         write_ok(st.out, true);\n-    } else { write_failed(st.out, true); }\n-    st.out.write_str(fmt!(\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n-                          st.failed, st.ignored));\n+    } else {\n+        write_failed(st.out, true);\n+    }\n+    st.out.write_str(fmt!(\". %u passed; %u failed; %u ignored\\n\\n\",\n+                          st.passed, st.failed, st.ignored));\n \n     return success;\n \n+    fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n+        use stats::Stats;\n+        if bs.mb_s != 0 {\n+            fmt!(\"%u ns/iter (+/- %u) = %u MB/s\",\n+                 bs.ns_iter_samples.median() as uint,\n+                 3 * (bs.ns_iter_samples.median_abs_dev() as uint),\n+                 bs.mb_s)\n+        } else {\n+            fmt!(\"%u ns/iter (+/- %u)\",\n+                 bs.ns_iter_samples.median() as uint,\n+                 3 * (bs.ns_iter_samples.median_abs_dev() as uint))\n+        }\n+    }\n+\n     fn write_log(out: io::Writer, result: TestResult, test: &TestDesc) {\n         out.write_line(fmt!(\"%s %s\",\n                     match result {\n                         TrOk => ~\"ok\",\n                         TrFailed => ~\"failed\",\n-                        TrIgnored => ~\"ignored\"\n-                    }, test.name));\n+                        TrIgnored => ~\"ignored\",\n+                        TrBench(ref bs) => fmt_bench_samples(bs)\n+                    }, test.name.to_str()));\n     }\n \n     fn write_ok(out: io::Writer, use_color: bool) {\n@@ -226,6 +360,10 @@ pub fn run_tests_console(opts: &TestOpts,\n         write_pretty(out, ~\"ignored\", term::color_yellow, use_color);\n     }\n \n+    fn write_bench(out: io::Writer, use_color: bool) {\n+        write_pretty(out, ~\"bench\", term::color_cyan, use_color);\n+    }\n+\n     fn write_pretty(out: io::Writer, word: &str, color: u8, use_color: bool) {\n         if use_color && term::color_supported() {\n             term::fg(out, color);\n@@ -239,11 +377,10 @@ pub fn run_tests_console(opts: &TestOpts,\n \n fn print_failures(st: @ConsoleTestState) {\n     st.out.write_line(~\"\\nfailures:\");\n-    let failures = copy st.failures;\n-    let failures = vec::map(failures, |test| test.name);\n-    let failures = do sort::merge_sort(failures) |x, y| { str::le(*x, *y) };\n+    let failures = vec::cast_to_mut(st.failures.map(|t| t.name.to_str()));\n+    sort::tim_sort(failures);\n     for vec::each(failures) |name| {\n-        st.out.write_line(fmt!(\"    %s\", *name));\n+        st.out.write_line(fmt!(\"    %s\", name.to_str()));\n     }\n }\n \n@@ -253,26 +390,28 @@ fn should_sort_failures_before_printing_them() {\n \n     let s = do io::with_str_writer |wr| {\n         let test_a = TestDesc {\n-            name: ~\"a\",\n+            name: StaticTestName(\"a\"),\n             ignore: false,\n             should_fail: false\n         };\n \n         let test_b = TestDesc {\n-            name: ~\"b\",\n+            name: StaticTestName(\"b\"),\n             ignore: false,\n             should_fail: false\n         };\n \n-        let st =\n-            @ConsoleTestState{out: wr,\n-              log_out: option::None,\n-              use_color: false,\n-              mut total: 0,\n-              mut passed: 0,\n-              mut failed: 0,\n-              mut ignored: 0,\n-              mut failures: ~[move test_b, move test_a]};\n+        let st = @ConsoleTestState {\n+            out: wr,\n+            log_out: option::None,\n+            use_color: false,\n+            mut total: 0u,\n+            mut passed: 0u,\n+            mut failed: 0u,\n+            mut ignored: 0u,\n+            mut benchmarked: 0u,\n+            mut failures: ~[move test_b, move test_a]\n+        };\n \n         print_failures(st);\n     };\n@@ -300,6 +439,15 @@ fn run_tests(opts: &TestOpts,\n     let filtered_descs = filtered_tests.map(|t| t.desc);\n     callback(TeFiltered(filtered_descs));\n \n+    let mut (filtered_tests,\n+             filtered_benchs) =\n+        do vec::partition(filtered_tests) |e| {\n+        match e.testfn {\n+            StaticTestFn(_) | DynTestFn(_) => true,\n+            StaticBenchFn(_) | DynBenchFn(_) => false\n+        }\n+    };\n+\n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n     let concurrency = get_concurrency();\n@@ -321,7 +469,7 @@ fn run_tests(opts: &TestOpts,\n                 // that hang forever.\n                 callback(TeWait(test.desc));\n             }\n-            run_test(test, ch.clone());\n+            run_test(!opts.run_tests, test, ch.clone());\n             pending += 1;\n         }\n \n@@ -332,6 +480,14 @@ fn run_tests(opts: &TestOpts,\n         callback(TeResult(desc, result));\n         pending -= 1;\n     }\n+\n+    // All benchmarks run at the end, in serial.\n+    do vec::consume(filtered_benchs) |_, b| {\n+        callback(TeWait(copy b.desc));\n+        run_test(!opts.run_benchmarks, b, ch.clone());\n+        let (test, result) = p.recv();\n+        callback(TeResult(move test, result));\n+    }\n }\n \n // Windows tends to dislike being overloaded with threads.\n@@ -368,7 +524,7 @@ pub fn filter_tests(\n \n         fn filter_fn(test: TestDescAndFn, filter_str: &str) ->\n             Option<TestDescAndFn> {\n-            if str::contains(test.desc.name, filter_str) {\n+            if str::contains(test.desc.name.to_str(), filter_str) {\n                 return option::Some(test);\n             } else { return option::None; }\n         }\n@@ -391,13 +547,12 @@ pub fn filter_tests(\n                 None\n             }\n         };\n-\n         vec::filter_map(filtered, |x| filter(x))\n     };\n \n     // Sort the tests alphabetically\n     pure fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n-        str::le(t1.desc.name, t2.desc.name)\n+        str::le(t1.desc.name.to_str(), t2.desc.name.to_str())\n     }\n     sort::quick_sort(filtered, lteq);\n \n@@ -409,24 +564,47 @@ struct TestFuture {\n     wait: fn@() -> TestResult,\n }\n \n-pub fn run_test(test: TestDescAndFn, monitor_ch: SharedChan<MonitorMsg>) {\n+pub fn run_test(force_ignore: bool,\n+                test: TestDescAndFn,\n+                monitor_ch: SharedChan<MonitorMsg>) {\n+\n     let TestDescAndFn {desc, testfn} = test;\n \n-    if desc.ignore {\n+    if force_ignore || desc.ignore {\n         monitor_ch.send((desc, TrIgnored));\n         return;\n     }\n \n-    let testfn_cell = ::cell::Cell(testfn);\n-    do task::spawn {\n-        let mut result_future = None; // task::future_result(builder);\n-        task::task().unlinked().future_result(|+r| {\n-            result_future = Some(move r);\n-        }).spawn(testfn_cell.take());\n-        let task_result = option::unwrap(move result_future).recv();\n-        let test_result = calc_result(&desc, task_result == task::Success);\n-        monitor_ch.send((desc, test_result));\n-    };\n+    fn run_test_inner(desc: TestDesc,\n+                      monitor_ch: SharedChan<MonitorMsg>,\n+                      testfn: ~fn()) {\n+        let testfn_cell = ::cell::Cell(testfn);\n+        do task::spawn {\n+            let mut result_future = None; // task::future_result(builder);\n+            task::task().unlinked().future_result(|+r| {\n+                result_future = Some(move r);\n+            }).spawn(testfn_cell.take());\n+            let task_result = option::unwrap(move result_future).recv();\n+            let test_result = calc_result(&desc,\n+                                          task_result == task::Success);\n+            monitor_ch.send((desc, test_result));\n+        }\n+    }\n+\n+    match testfn {\n+        DynBenchFn(benchfn) => {\n+            let bs = ::test::bench::benchmark(benchfn);\n+            monitor_ch.send((desc, TrBench(bs)));\n+            return;\n+        }\n+        StaticBenchFn(benchfn) => {\n+            let bs = ::test::bench::benchmark(benchfn);\n+            monitor_ch.send((desc, TrBench(bs)));\n+            return;\n+        }\n+        DynTestFn(f) => run_test_inner(desc, monitor_ch, f),\n+        StaticTestFn(f) => run_test_inner(desc, monitor_ch, || f())\n+    }\n }\n \n fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n@@ -439,10 +617,180 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n     }\n }\n \n+pub mod bench {\n+\n+    use rand;\n+    use u64;\n+    use vec;\n+    use time::precise_time_ns;\n+    use test::{BenchHarness, BenchSamples};\n+    use stats::Stats;\n+    use num;\n+    use rand;\n+\n+    pub impl BenchHarness {\n+\n+        /// Callback for benchmark functions to run in their body.\n+        pub fn iter(&mut self, inner:&fn()) {\n+            self.ns_start = precise_time_ns();\n+            let k = self.iterations;\n+            for u64::range(0, k) |_| {\n+                inner();\n+            }\n+            self.ns_end = precise_time_ns();\n+        }\n+\n+        fn ns_elapsed(&mut self) -> u64 {\n+            if self.ns_start == 0 || self.ns_end == 0 {\n+                0\n+            } else {\n+                self.ns_end - self.ns_start\n+            }\n+        }\n+\n+        fn ns_per_iter(&mut self) -> u64 {\n+            if self.iterations == 0 {\n+                0\n+            } else {\n+                self.ns_elapsed() / self.iterations\n+            }\n+        }\n+\n+        fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n+            self.iterations = n;\n+            debug!(\"running benchmark for %u iterations\",\n+                   n as uint);\n+            f(self);\n+        }\n+\n+        // This is the Go benchmark algorithm. It produces a single\n+        // datapoint and always tries to run for 1s.\n+        pub fn go_bench(&mut self, f: &fn(&mut BenchHarness)) {\n+\n+            // Rounds a number down to the nearest power of 10.\n+            fn round_down_10(n: u64) -> u64 {\n+                let mut n = n;\n+                let mut res = 1;\n+                while n > 10 {\n+                    n = n / 10;\n+                    res *= 10;\n+                }\n+                res\n+            }\n+\n+            // Rounds x up to a number of the form [1eX, 2eX, 5eX].\n+            fn round_up(n: u64) -> u64 {\n+                let base = round_down_10(n);\n+                if n < (2 * base) {\n+                    2 * base\n+                } else if n < (5 * base) {\n+                    5 * base\n+                } else {\n+                    10 * base\n+                }\n+            }\n+\n+            // Initial bench run to get ballpark figure.\n+            let mut n = 1_u64;\n+            self.bench_n(n, f);\n+\n+            while n < 1_000_000_000 &&\n+                self.ns_elapsed() < 1_000_000_000 {\n+                let last = n;\n+\n+                // Try to estimate iter count for 1s falling back to 1bn\n+                // iterations if first run took < 1ns.\n+                if self.ns_per_iter() == 0 {\n+                    n = 1_000_000_000;\n+                } else {\n+                    n = 1_000_000_000 / self.ns_per_iter();\n+                }\n+\n+                n = u64::max(u64::min(n+n/2, 100*last), last+1);\n+                n = round_up(n);\n+                self.bench_n(n, f);\n+            }\n+        }\n+\n+        // This is a more statistics-driven benchmark algorithm.\n+        // It stops as quickly as 50ms, so long as the statistical\n+        // properties are satisfactory. If those properties are\n+        // not met, it may run as long as the Go algorithm.\n+        pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n+\n+            let rng = rand::Rng();\n+            let mut magnitude = 10;\n+            let mut prev_madp = 0.0;\n+\n+            loop {\n+\n+                let n_samples = rng.gen_uint_range(50, 60);\n+                let n_iter = rng.gen_uint_range(magnitude,\n+                                                magnitude * 2);\n+\n+                let samples = do vec::from_fn(n_samples) |_| {\n+                    self.bench_n(n_iter as u64, f);\n+                    self.ns_per_iter() as f64\n+                };\n+\n+                // Eliminate outliers\n+                let med = samples.median();\n+                let mad = samples.median_abs_dev();\n+                let samples = do vec::filter(samples) |f| {\n+                    num::abs(*f - med) <= 3.0 * mad\n+                };\n+\n+                debug!(\"%u samples, median %f, MAD=%f, %u survived filter\",\n+                       n_samples, med as float, mad as float,\n+                       samples.len());\n+\n+                if samples.len() != 0 {\n+                    // If we have _any_ cluster of signal...\n+                    let curr_madp = samples.median_abs_dev_pct();\n+                    if self.ns_elapsed() > 1_000_000 &&\n+                        (curr_madp < 1.0 ||\n+                         num::abs(curr_madp - prev_madp) < 0.1) {\n+                        return samples;\n+                    }\n+                    prev_madp = curr_madp;\n+\n+                    if n_iter > 20_000_000 ||\n+                        self.ns_elapsed() > 20_000_000 {\n+                        return samples;\n+                    }\n+                }\n+\n+                magnitude *= 2;\n+            }\n+        }\n+    }\n+\n+    pub fn benchmark(f: &fn(&mut BenchHarness)) -> BenchSamples {\n+\n+        let mut bs = BenchHarness {\n+            iterations: 0,\n+            ns_start: 0,\n+            ns_end: 0,\n+            bytes: 0\n+        };\n+\n+        let ns_iter_samples = bs.auto_bench(f);\n+\n+        let iter_s = 1_000_000_000 / (ns_iter_samples.median() as u64);\n+        let mb_s = (bs.bytes * iter_s) / 1_000_000;\n+\n+        BenchSamples {\n+            ns_iter_samples: ns_iter_samples,\n+            mb_s: mb_s as uint\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts,\n-               TestDesc, TestDescAndFn};\n+               TestDesc, TestDescAndFn,\n+               StaticTestName, DynTestName, DynTestFn};\n     use test::{TestOpts, run_test};\n \n     use core::either;\n@@ -455,15 +803,15 @@ mod tests {\n         fn f() { die!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n-                name: ~\"whatever\",\n+                name: StaticTestName(\"whatever\"),\n                 ignore: true,\n                 should_fail: false\n             },\n-            testfn: f,\n+            testfn: DynTestFn(fn~() { f()}),\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n-        run_test(desc, ch);\n+        run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert res != TrOk;\n     }\n@@ -473,15 +821,15 @@ mod tests {\n         fn f() { }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n-                name: ~\"whatever\",\n+                name: StaticTestName(\"whatever\"),\n                 ignore: true,\n                 should_fail: false\n             },\n-            testfn: f,\n+            testfn: DynTestFn(fn~() { f()}),\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n-        run_test(desc, ch);\n+        run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert res == TrIgnored;\n     }\n@@ -492,15 +840,15 @@ mod tests {\n         fn f() { die!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n-                name: ~\"whatever\",\n+                name: StaticTestName(\"whatever\"),\n                 ignore: false,\n                 should_fail: true\n             },\n-            testfn: f,\n+            testfn: DynTestFn(fn~() { f() }),\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n-        run_test(desc, ch);\n+        run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert res == TrOk;\n     }\n@@ -510,15 +858,15 @@ mod tests {\n         fn f() { }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n-                name: ~\"whatever\",\n+                name: StaticTestName(\"whatever\"),\n                 ignore: false,\n                 should_fail: true\n             },\n-            testfn: f,\n+            testfn: DynTestFn(fn~() { f() }),\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n-        run_test(desc, ch);\n+        run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert res == TrFailed;\n     }\n@@ -554,30 +902,34 @@ mod tests {\n             filter: option::None,\n             run_ignored: true,\n             logfile: option::None,\n+            run_tests: true,\n+            run_benchmarks: false,\n+            save_results: option::None,\n+            compare_results: option::None\n         };\n \n         let tests = ~[\n             TestDescAndFn {\n                 desc: TestDesc {\n-                    name: ~\"1\",\n+                    name: StaticTestName(\"1\"),\n                     ignore: true,\n                     should_fail: false,\n                 },\n-                testfn: dummy,\n+                testfn: DynTestFn(fn~() { }),\n             },\n             TestDescAndFn {\n                 desc: TestDesc {\n-                    name: ~\"2\",\n+                    name: StaticTestName(\"2\"),\n                     ignore: false,\n                     should_fail: false\n                 },\n-                testfn: dummy,\n+                testfn: DynTestFn(fn~() { }),\n             },\n         ];\n         let filtered = filter_tests(&opts, tests);\n \n         assert (vec::len(filtered) == 1);\n-        assert (filtered[0].desc.name == ~\"1\");\n+        assert (filtered[0].desc.name.to_str() == ~\"1\");\n         assert (filtered[0].desc.ignore == false);\n     }\n \n@@ -587,6 +939,10 @@ mod tests {\n             filter: option::None,\n             run_ignored: false,\n             logfile: option::None,\n+            run_tests: true,\n+            run_benchmarks: false,\n+            save_results: option::None,\n+            compare_results: option::None\n         };\n \n         let names =\n@@ -603,10 +959,11 @@ mod tests {\n             for vec::each(names) |name| {\n                 let test = TestDescAndFn {\n                     desc: TestDesc {\n-                        name: *name, ignore: false,\n+                        name: DynTestName(*name),\n+                        ignore: false,\n                         should_fail: false\n                     },\n-                    testfn: testfn,\n+                    testfn: DynTestFn(copy testfn),\n                 };\n                 tests.push(move test);\n             }\n@@ -627,7 +984,7 @@ mod tests {\n \n         for vec::each(pairs) |p| {\n             match *p {\n-                (ref a, ref b) => { assert (*a == b.desc.name); }\n+                (ref a, ref b) => { assert (*a == b.desc.name.to_str()); }\n             }\n         }\n     }"}, {"sha": "6028d8c71d31b55a898f47750f624191566eee81", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5aa399e0d98b81b6454ec30f70aac8604fb7b11/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=e5aa399e0d98b81b6454ec30f70aac8604fb7b11", "patch": "@@ -26,13 +26,13 @@ fn shouldnotignore() {\n #[test]\n fn checktests() {\n     // Pull the tests out of the secreturn test module\n-    let tests = __test::tests();\n+    let tests = __test::tests;\n \n     assert vec::any(\n         tests,\n-        |t| t.desc.name == ~\"shouldignore\" && t.desc.ignore);\n+        |t| t.desc.name.to_str() == ~\"shouldignore\" && t.desc.ignore);\n \n     assert vec::any(\n         tests,\n-        |t| t.desc.name == ~\"shouldnotignore\" && !t.desc.ignore);\n+        |t| t.desc.name.to_str() == ~\"shouldnotignore\" && !t.desc.ignore);\n }\n\\ No newline at end of file"}]}