{"sha": "54b2cad8b341434c7c0edb153a0fa662fb2981f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YjJjYWQ4YjM0MTQzNGM3YzBlZGIxNTNhMGZhNjYyZmIyOTgxZjE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-23T19:43:58Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-23T22:41:08Z"}, "message": "libsyntax: Remove `fn() unsafe { ... }`. r=graydon", "tree": {"sha": "72e8fa6637f1d5250b826ef4436e00993e2d3388", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72e8fa6637f1d5250b826ef4436e00993e2d3388"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54b2cad8b341434c7c0edb153a0fa662fb2981f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54b2cad8b341434c7c0edb153a0fa662fb2981f1", "html_url": "https://github.com/rust-lang/rust/commit/54b2cad8b341434c7c0edb153a0fa662fb2981f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54b2cad8b341434c7c0edb153a0fa662fb2981f1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d1b81143b947fa33745a78cf00af12cda437149", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d1b81143b947fa33745a78cf00af12cda437149", "html_url": "https://github.com/rust-lang/rust/commit/1d1b81143b947fa33745a78cf00af12cda437149"}], "stats": {"total": 5264, "additions": 2823, "deletions": 2441}, "files": [{"sha": "2a28b767d0a1a01d5022334dfb738180ffed65d7", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -33,34 +33,36 @@ fn load_errors(testfile: &Path) -> ~[expected_error] {\n     return error_patterns;\n }\n \n-fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] unsafe {\n-    let error_tag = ~\"//~\";\n-    let mut idx;\n-    match str::find_str(line, error_tag) {\n-      None => return ~[],\n-      Some(nn) => { idx = (nn as uint) + str::len(error_tag); }\n-    }\n+fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] {\n+    unsafe {\n+        let error_tag = ~\"//~\";\n+        let mut idx;\n+        match str::find_str(line, error_tag) {\n+          None => return ~[],\n+          Some(nn) => { idx = (nn as uint) + str::len(error_tag); }\n+        }\n \n-    // \"//~^^^ kind msg\" denotes a message expected\n-    // three lines above current line:\n-    let mut adjust_line = 0u;\n-    let len = str::len(line);\n-    while idx < len && line[idx] == ('^' as u8) {\n-        adjust_line += 1u;\n-        idx += 1u;\n-    }\n+        // \"//~^^^ kind msg\" denotes a message expected\n+        // three lines above current line:\n+        let mut adjust_line = 0u;\n+        let len = str::len(line);\n+        while idx < len && line[idx] == ('^' as u8) {\n+            adjust_line += 1u;\n+            idx += 1u;\n+        }\n \n-    // Extract kind:\n-    while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-    let start_kind = idx;\n-    while idx < len && line[idx] != (' ' as u8) { idx += 1u; }\n-    let kind = str::to_lower(str::slice(line, start_kind, idx));\n+        // Extract kind:\n+        while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n+        let start_kind = idx;\n+        while idx < len && line[idx] != (' ' as u8) { idx += 1u; }\n+        let kind = str::to_lower(str::slice(line, start_kind, idx));\n \n-    // Extract msg:\n-    while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-    let msg = str::slice(line, idx, len);\n+        // Extract msg:\n+        while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n+        let msg = str::slice(line, idx, len);\n \n-    debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n+        debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n \n-    return ~[{line: line_num - adjust_line, kind: kind, msg: msg}];\n+        return ~[{line: line_num - adjust_line, kind: kind, msg: msg}];\n+    }\n }"}, {"sha": "e0a170c74455c4466ed3f164e65f20f50e8b2c08", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -146,15 +146,17 @@ fn parse_name_directive(line: ~str, directive: ~str) -> bool {\n }\n \n fn parse_name_value_directive(line: ~str,\n-                              directive: ~str) -> Option<~str> unsafe {\n-    let keycolon = directive + ~\":\";\n-    match str::find_str(line, keycolon) {\n-        Some(colon) => {\n-            let value = str::slice(line, colon + str::len(keycolon),\n-                                   str::len(line));\n-            debug!(\"%s: %s\", directive,  value);\n-            Some(value)\n+                              directive: ~str) -> Option<~str> {\n+    unsafe {\n+        let keycolon = directive + ~\":\";\n+        match str::find_str(line, keycolon) {\n+            Some(colon) => {\n+                let value = str::slice(line, colon + str::len(keycolon),\n+                                       str::len(line));\n+                debug!(\"%s: %s\", directive,  value);\n+                Some(value)\n+            }\n+            None => None\n         }\n-        None => None\n     }\n }"}, {"sha": "eb89827e17a1af842a0f8a551a5822bf6a32fbd4", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -1135,28 +1135,30 @@ fn get_temp_workdir(c: &Cargo) -> Path {\n     }\n }\n \n-fn cmd_install(c: &Cargo) unsafe {\n-    let wd = get_temp_workdir(c);\n+fn cmd_install(c: &Cargo) {\n+    unsafe {\n+        let wd = get_temp_workdir(c);\n \n-    if vec::len(c.opts.free) == 2u {\n-        let cwd = os::getcwd();\n-        let status = run::run_program(~\"cp\", ~[~\"-R\", cwd.to_str(),\n-                                               wd.to_str()]);\n+        if vec::len(c.opts.free) == 2u {\n+            let cwd = os::getcwd();\n+            let status = run::run_program(~\"cp\", ~[~\"-R\", cwd.to_str(),\n+                                                   wd.to_str()]);\n \n-        if status != 0 {\n-            fail fmt!(\"could not copy directory: %s\", cwd.to_str());\n-        }\n+            if status != 0 {\n+                fail fmt!(\"could not copy directory: %s\", cwd.to_str());\n+            }\n \n-        install_source(c, &wd);\n-        return;\n-    }\n+            install_source(c, &wd);\n+            return;\n+        }\n \n-    sync(c);\n+        sync(c);\n \n-    let query = c.opts.free[2];\n-    c.current_install = query.to_str();\n+        let query = c.opts.free[2];\n+        c.current_install = query.to_str();\n \n-    install_query(c, &wd, query);\n+        install_query(c, &wd, query);\n+    }\n }\n \n fn sync(c: &Cargo) {"}, {"sha": "c221df293dcdb68df2568038f7c345f02af85269", "filename": "src/libcore/oldcomm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Foldcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Foldcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foldcomm.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -121,8 +121,9 @@ pub fn listen<T: Owned, U>(f: fn(Chan<T>) -> U) -> U {\n }\n \n struct PortPtr<T:Owned> {\n-    po: *rust_port,\n-  drop unsafe {\n+  po: *rust_port,\n+  drop {\n+    unsafe {\n       do task::unkillable {\n         // Once the port is detached it's guaranteed not to receive further\n         // messages\n@@ -140,6 +141,7 @@ struct PortPtr<T:Owned> {\n             recv_::<T>(self.po);\n         }\n         rustrt::del_port(self.po);\n+      }\n     }\n   }\n }\n@@ -209,7 +211,7 @@ pub fn send<T: Owned>(ch: Chan<T>, data: T) {\n         let Chan_(p) = ch;\n         let data_ptr = ptr::addr_of(&data) as *();\n         let res = rustrt::rust_port_id_send(p, data_ptr);\n-        if res != 0 unsafe {\n+        if res != 0 {\n             // Data sent successfully\n             cast::forget(move data);\n         }"}, {"sha": "d30d0905a0f3c601dfd78980686a47c9be29aee3", "filename": "src/libcore/os.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -86,8 +86,10 @@ pub fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n     -> Option<~str> {\n     let buf = vec::cast_to_mut(vec::from_elem(tmpbuf_sz, 0u8 as c_char));\n     do vec::as_mut_buf(buf) |b, sz| {\n-        if f(b, sz as size_t) unsafe {\n-            Some(str::raw::from_buf(b as *u8))\n+        if f(b, sz as size_t) {\n+            unsafe {\n+                Some(str::raw::from_buf(b as *u8))\n+            }\n         } else {\n             None\n         }"}, {"sha": "b32357e735654c6a2af9cad41284ff1374703a70", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -193,8 +193,10 @@ impl PacketHeader {\n         reinterpret_cast(&self.buffer)\n     }\n \n-    fn set_buffer<T: Owned>(b: ~Buffer<T>) unsafe {\n-        self.buffer = reinterpret_cast(&b);\n+    fn set_buffer<T: Owned>(b: ~Buffer<T>) {\n+        unsafe {\n+            self.buffer = reinterpret_cast(&b);\n+        }\n     }\n }\n \n@@ -356,19 +358,21 @@ pub unsafe fn get_buffer<T: Owned>(p: *PacketHeader) -> ~Buffer<T> {\n struct BufferResource<T: Owned> {\n     buffer: ~Buffer<T>,\n \n-    drop unsafe {\n-        let b = move_it!(self.buffer);\n-        //let p = ptr::addr_of(*b);\n-        //error!(\"drop %?\", p);\n-        let old_count = atomic_sub_rel(&mut b.header.ref_count, 1);\n-        //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n-        if old_count == 1 {\n-            // The new count is 0.\n-\n-            // go go gadget drop glue\n-        }\n-        else {\n-            forget(move b)\n+    drop {\n+        unsafe {\n+            let b = move_it!(self.buffer);\n+            //let p = ptr::addr_of(*b);\n+            //error!(\"drop %?\", p);\n+            let old_count = atomic_sub_rel(&mut b.header.ref_count, 1);\n+            //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n+            if old_count == 1 {\n+                // The new count is 0.\n+\n+                // go go gadget drop glue\n+            }\n+            else {\n+                forget(move b)\n+            }\n         }\n     }\n }\n@@ -641,18 +645,20 @@ fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n \n     let mut data_avail = false;\n     let mut ready_packet = pkts.len();\n-    for pkts.eachi |i, p| unsafe {\n-        let p = unsafe { &*p.header() };\n-        let old = p.mark_blocked(this);\n-        match old {\n-          Full | Terminated => {\n-            data_avail = true;\n-            ready_packet = i;\n-            (*p).state = old;\n-            break;\n-          }\n-          Blocked => fail ~\"blocking on blocked packet\",\n-          Empty => ()\n+    for pkts.eachi |i, p| {\n+        unsafe {\n+            let p = &*p.header();\n+            let old = p.mark_blocked(this);\n+            match old {\n+              Full | Terminated => {\n+                data_avail = true;\n+                ready_packet = i;\n+                (*p).state = old;\n+                break;\n+              }\n+              Blocked => fail ~\"blocking on blocked packet\",\n+              Empty => ()\n+            }\n         }\n     }\n \n@@ -1072,23 +1078,27 @@ impl<T: Owned> Port<T>: GenericPort<T> {\n }\n \n impl<T: Owned> Port<T>: Peekable<T> {\n-    pure fn peek() -> bool unsafe {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        let peek = match &endp {\n-          &Some(ref endp) => pipes::peek(endp),\n-          &None => fail ~\"peeking empty stream\"\n-        };\n-        self.endp <-> endp;\n-        peek\n+    pure fn peek() -> bool {\n+        unsafe {\n+            let mut endp = None;\n+            endp <-> self.endp;\n+            let peek = match &endp {\n+              &Some(ref endp) => pipes::peek(endp),\n+              &None => fail ~\"peeking empty stream\"\n+            };\n+            self.endp <-> endp;\n+            peek\n+        }\n     }\n }\n \n impl<T: Owned> Port<T>: Selectable {\n-    pure fn header() -> *PacketHeader unsafe {\n-        match self.endp {\n-          Some(ref endp) => endp.header(),\n-          None => fail ~\"peeking empty stream\"\n+    pure fn header() -> *PacketHeader {\n+        unsafe {\n+            match self.endp {\n+              Some(ref endp) => endp.header(),\n+              None => fail ~\"peeking empty stream\"\n+            }\n         }\n     }\n }"}, {"sha": "1d6260db1302d365e965113484934544e2c10cbd", "filename": "src/libcore/private.rs", "status": "modified", "additions": 64, "deletions": 52, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -64,22 +64,26 @@ pub unsafe fn run_in_bare_thread(f: ~fn()) {\n     let (port, chan) = pipes::stream();\n     // FIXME #4525: Unfortunate that this creates an extra scheduler but it's\n     // necessary since rust_raw_thread_join_delete is blocking\n-    do task::spawn_sched(task::SingleThreaded) unsafe {\n-        let closure: &fn() = || {\n-            f()\n-        };\n-        let thread = rustrt::rust_raw_thread_start(closure);\n-        rustrt::rust_raw_thread_join_delete(thread);\n-        chan.send(());\n+    do task::spawn_sched(task::SingleThreaded) {\n+        unsafe {\n+            let closure: &fn() = || {\n+                f()\n+            };\n+            let thread = rustrt::rust_raw_thread_start(closure);\n+            rustrt::rust_raw_thread_join_delete(thread);\n+            chan.send(());\n+        }\n     }\n     port.recv();\n }\n \n #[test]\n-fn test_run_in_bare_thread() unsafe {\n-    let i = 100;\n-    do run_in_bare_thread {\n-        assert i == 100;\n+fn test_run_in_bare_thread() {\n+    unsafe {\n+        let i = 100;\n+        do run_in_bare_thread {\n+            assert i == 100;\n+        }\n     }\n }\n \n@@ -273,8 +277,10 @@ pub unsafe fn weaken_task(f: fn(oldcomm::Port<()>)) {\n \n     struct Unweaken {\n       ch: oldcomm::Chan<()>,\n-      drop unsafe {\n-        rustrt::rust_task_unweaken(cast::reinterpret_cast(&self.ch));\n+      drop {\n+        unsafe {\n+            rustrt::rust_task_unweaken(cast::reinterpret_cast(&self.ch));\n+        }\n       }\n     }\n \n@@ -359,37 +365,40 @@ struct ArcData<T> {\n \n struct ArcDestruct<T> {\n     mut data: *libc::c_void,\n-    drop unsafe {\n-        if self.data.is_null() {\n-            return; // Happens when destructing an unwrapper's handle.\n-        }\n-        do task::unkillable {\n-            let data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n-            let new_count = rusti::atomic_xsub(&mut data.count, 1) - 1;\n-            assert new_count >= 0;\n-            if new_count == 0 {\n-                // Were we really last, or should we hand off to an unwrapper?\n-                // It's safe to not xchg because the unwrapper will set the\n-                // unwrap lock *before* dropping his/her reference. In effect,\n-                // being here means we're the only *awake* task with the data.\n-                if data.unwrapper != 0 {\n-                    let p: UnwrapProto =\n-                        cast::reinterpret_cast(&data.unwrapper);\n-                    let (message, response) = option::swap_unwrap(p);\n-                    // Send 'ready' and wait for a response.\n-                    pipes::send_one(move message, ());\n-                    // Unkillable wait. Message guaranteed to come.\n-                    if pipes::recv_one(move response) {\n-                        // Other task got the data.\n-                        cast::forget(move data);\n+    drop {\n+        unsafe {\n+            if self.data.is_null() {\n+                return; // Happens when destructing an unwrapper's handle.\n+            }\n+            do task::unkillable {\n+                let data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n+                let new_count = rusti::atomic_xsub(&mut data.count, 1) - 1;\n+                assert new_count >= 0;\n+                if new_count == 0 {\n+                    // Were we really last, or should we hand off to an\n+                    // unwrapper? It's safe to not xchg because the unwrapper\n+                    // will set the unwrap lock *before* dropping his/her\n+                    // reference. In effect, being here means we're the only\n+                    // *awake* task with the data.\n+                    if data.unwrapper != 0 {\n+                        let p: UnwrapProto =\n+                            cast::reinterpret_cast(&data.unwrapper);\n+                        let (message, response) = option::swap_unwrap(p);\n+                        // Send 'ready' and wait for a response.\n+                        pipes::send_one(move message, ());\n+                        // Unkillable wait. Message guaranteed to come.\n+                        if pipes::recv_one(move response) {\n+                            // Other task got the data.\n+                            cast::forget(move data);\n+                        } else {\n+                            // Other task was killed. drop glue takes over.\n+                        }\n                     } else {\n-                        // Other task was killed. drop glue takes over.\n+                        // drop glue takes over.\n                     }\n                 } else {\n-                    // drop glue takes over.\n+                    cast::forget(move data);\n                 }\n-            } else {\n-                cast::forget(move data);\n             }\n         }\n     }\n@@ -406,18 +415,21 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n     struct DeathThroes<T> {\n         mut ptr:      Option<~ArcData<T>>,\n         mut response: Option<pipes::ChanOne<bool>>,\n-        drop unsafe {\n-            let response = option::swap_unwrap(&mut self.response);\n-            // In case we get killed early, we need to tell the person who\n-            // tried to wake us whether they should hand-off the data to us.\n-            if task::failing() {\n-                pipes::send_one(move response, false);\n-                // Either this swap_unwrap or the one below (at \"Got here\")\n-                // ought to run.\n-                cast::forget(option::swap_unwrap(&mut self.ptr));\n-            } else {\n-                assert self.ptr.is_none();\n-                pipes::send_one(move response, true);\n+        drop {\n+            unsafe {\n+                let response = option::swap_unwrap(&mut self.response);\n+                // In case we get killed early, we need to tell the person who\n+                // tried to wake us whether they should hand-off the data to\n+                // us.\n+                if task::failing() {\n+                    pipes::send_one(move response, false);\n+                    // Either this swap_unwrap or the one below (at \"Got\n+                    // here\") ought to run.\n+                    cast::forget(option::swap_unwrap(&mut self.ptr));\n+                } else {\n+                    assert self.ptr.is_none();\n+                    pipes::send_one(move response, true);\n+                }\n             }\n         }\n     }"}, {"sha": "f059c119f4989285fbbc18acf093bbde698f7762", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -165,8 +165,10 @@ pub pure fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n   (I couldn't think of a cutesy name for this one.)\n */\n #[inline(always)]\n-pub pure fn to_uint<T>(thing: &T) -> uint unsafe {\n-    cast::reinterpret_cast(&thing)\n+pub pure fn to_uint<T>(thing: &T) -> uint {\n+    unsafe {\n+        cast::reinterpret_cast(&thing)\n+    }\n }\n \n /// Determine if two borrowed pointers point to the same thing.\n@@ -215,10 +217,12 @@ impl<T> *mut T: Ptr<T> {\n #[cfg(notest)]\n impl<T> *const T : Eq {\n     #[inline(always)]\n-    pure fn eq(&self, other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&(*self));\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a == b;\n+    pure fn eq(&self, other: &*const T) -> bool {\n+        unsafe {\n+            let a: uint = cast::reinterpret_cast(&(*self));\n+            let b: uint = cast::reinterpret_cast(&(*other));\n+            return a == b;\n+        }\n     }\n     #[inline(always)]\n     pure fn ne(&self, other: &*const T) -> bool { !(*self).eq(other) }\n@@ -228,28 +232,36 @@ impl<T> *const T : Eq {\n #[cfg(notest)]\n impl<T> *const T : Ord {\n     #[inline(always)]\n-    pure fn lt(&self, other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&(*self));\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a < b;\n+    pure fn lt(&self, other: &*const T) -> bool {\n+        unsafe {\n+            let a: uint = cast::reinterpret_cast(&(*self));\n+            let b: uint = cast::reinterpret_cast(&(*other));\n+            return a < b;\n+        }\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&(*self));\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a <= b;\n+    pure fn le(&self, other: &*const T) -> bool {\n+        unsafe {\n+            let a: uint = cast::reinterpret_cast(&(*self));\n+            let b: uint = cast::reinterpret_cast(&(*other));\n+            return a <= b;\n+        }\n     }\n     #[inline(always)]\n-    pure fn ge(&self, other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&(*self));\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a >= b;\n+    pure fn ge(&self, other: &*const T) -> bool {\n+        unsafe {\n+            let a: uint = cast::reinterpret_cast(&(*self));\n+            let b: uint = cast::reinterpret_cast(&(*other));\n+            return a >= b;\n+        }\n     }\n     #[inline(always)]\n-    pure fn gt(&self, other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&(*self));\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a > b;\n+    pure fn gt(&self, other: &*const T) -> bool {\n+        unsafe {\n+            let a: uint = cast::reinterpret_cast(&(*self));\n+            let b: uint = cast::reinterpret_cast(&(*other));\n+            return a > b;\n+        }\n     }\n }\n "}, {"sha": "12246255b773457970d7ea4c2c32865956fa770c", "filename": "src/libcore/str.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -366,10 +366,12 @@ Section: Transforming strings\n  *\n  * The result vector is not null-terminated.\n  */\n-pub pure fn to_bytes(s: &str) -> ~[u8] unsafe {\n-    let mut v: ~[u8] = ::cast::transmute(from_slice(s));\n-    vec::raw::set_len(&mut v, len(s));\n-    v\n+pub pure fn to_bytes(s: &str) -> ~[u8] {\n+    unsafe {\n+        let mut v: ~[u8] = ::cast::transmute(from_slice(s));\n+        vec::raw::set_len(&mut v, len(s));\n+        v\n+    }\n }\n \n /// Work with the string as a byte slice, not including trailing null.\n@@ -454,8 +456,10 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n         let mut i = 0u, start = 0u;\n         while i < l && done < count {\n             if s[i] == b {\n-                if allow_empty || start < i unsafe {\n-                    result.push(unsafe { raw::slice_bytes(s, start, i) });\n+                if allow_empty || start < i {\n+                    unsafe {\n+                        result.push(raw::slice_bytes(s, start, i));\n+                    }\n                 }\n                 start = i + 1u;\n                 done += 1u;\n@@ -497,16 +501,20 @@ pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n     while i < l && done < count {\n         let CharRange {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n-            if allow_empty || start < i unsafe {\n-                result.push(unsafe { raw::slice_bytes(s, start, i)});\n+            if allow_empty || start < i {\n+                unsafe {\n+                    result.push(raw::slice_bytes(s, start, i));\n+                }\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n-    if allow_empty || start < l unsafe {\n-        result.push(unsafe { raw::slice_bytes(s, start, l) });\n+    if allow_empty || start < l {\n+        unsafe {\n+            result.push(raw::slice_bytes(s, start, l));\n+        }\n     }\n     result\n }\n@@ -1490,17 +1498,20 @@ pub pure fn to_utf16(s: &str) -> ~[u16] {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n         let mut ch = cch as u32;\n \n-        if (ch & 0xFFFF_u32) == ch unsafe {\n-            // The BMP falls through (assuming non-surrogate, as it should)\n-            assert ch <= 0xD7FF_u32 || ch >= 0xE000_u32;\n-            u.push(ch as u16)\n-        } else unsafe {\n-            // Supplementary planes break into surrogates.\n-            assert ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32;\n-            ch -= 0x1_0000_u32;\n-            let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n-            let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            u.push_all(~[w1, w2])\n+        unsafe {\n+            if (ch & 0xFFFF_u32) == ch {\n+                // The BMP falls through (assuming non-surrogate, as it\n+                // should)\n+                assert ch <= 0xD7FF_u32 || ch >= 0xE000_u32;\n+                u.push(ch as u16)\n+            } else {\n+                // Supplementary planes break into surrogates.\n+                assert ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32;\n+                ch -= 0x1_0000_u32;\n+                let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n+                let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n+                u.push_all(~[w1, w2])\n+            }\n         }\n     }\n     u"}, {"sha": "914eccd3d86c0d2119515aab70a2517b47087aed", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -213,24 +213,26 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn synthesize_closure() unsafe {\n-        let x = 10;\n-        let f: fn(int) -> int = |y| x + y;\n+    pub fn synthesize_closure() {\n+        unsafe {\n+            let x = 10;\n+            let f: fn(int) -> int = |y| x + y;\n \n-        assert f(20) == 30;\n+            assert f(20) == 30;\n \n-        let original_closure: Closure = cast::transmute(move f);\n+            let original_closure: Closure = cast::transmute(move f);\n \n-        let actual_function_pointer = original_closure.code;\n-        let environment = original_closure.env;\n+            let actual_function_pointer = original_closure.code;\n+            let environment = original_closure.env;\n \n-        let new_closure = Closure {\n-            code: actual_function_pointer,\n-            env: environment\n-        };\n+            let new_closure = Closure {\n+                code: actual_function_pointer,\n+                env: environment\n+            };\n \n-        let new_f: fn(int) -> int = cast::transmute(move new_closure);\n-        assert new_f(20) == 30;\n+            let new_f: fn(int) -> int = cast::transmute(move new_closure);\n+            assert new_f(20) == 30;\n+        }\n     }\n }\n "}, {"sha": "05a4e35b249e40d44b2653b8bbfac19b061a16bd", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 99, "deletions": 74, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -86,79 +86,97 @@ pub unsafe fn local_data_modify<T: Durable>(\n }\n \n #[test]\n-fn test_tls_multitask() unsafe {\n-    fn my_key(_x: @~str) { }\n-    local_data_set(my_key, @~\"parent data\");\n-    do task::spawn unsafe {\n-        assert local_data_get(my_key).is_none(); // TLS shouldn't carry over.\n-        local_data_set(my_key, @~\"child data\");\n-        assert *(local_data_get(my_key).get()) == ~\"child data\";\n-        // should be cleaned up for us\n+fn test_tls_multitask() {\n+    unsafe {\n+        fn my_key(_x: @~str) { }\n+        local_data_set(my_key, @~\"parent data\");\n+        do task::spawn {\n+            unsafe {\n+                // TLS shouldn't carry over.\n+                assert local_data_get(my_key).is_none();\n+                local_data_set(my_key, @~\"child data\");\n+                assert *(local_data_get(my_key).get()) == ~\"child data\";\n+                // should be cleaned up for us\n+            }\n+        }\n+        // Must work multiple times\n+        assert *(local_data_get(my_key).get()) == ~\"parent data\";\n+        assert *(local_data_get(my_key).get()) == ~\"parent data\";\n+        assert *(local_data_get(my_key).get()) == ~\"parent data\";\n     }\n-    // Must work multiple times\n-    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n-    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n-    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n }\n \n #[test]\n-fn test_tls_overwrite() unsafe {\n-    fn my_key(_x: @~str) { }\n-    local_data_set(my_key, @~\"first data\");\n-    local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n-    assert *(local_data_get(my_key).get()) == ~\"next data\";\n+fn test_tls_overwrite() {\n+    unsafe {\n+        fn my_key(_x: @~str) { }\n+        local_data_set(my_key, @~\"first data\");\n+        local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n+        assert *(local_data_get(my_key).get()) == ~\"next data\";\n+    }\n }\n \n #[test]\n-fn test_tls_pop() unsafe {\n-    fn my_key(_x: @~str) { }\n-    local_data_set(my_key, @~\"weasel\");\n-    assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n-    // Pop must remove the data from the map.\n-    assert local_data_pop(my_key).is_none();\n+fn test_tls_pop() {\n+    unsafe {\n+        fn my_key(_x: @~str) { }\n+        local_data_set(my_key, @~\"weasel\");\n+        assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n+        // Pop must remove the data from the map.\n+        assert local_data_pop(my_key).is_none();\n+    }\n }\n \n #[test]\n-fn test_tls_modify() unsafe {\n-    fn my_key(_x: @~str) { }\n-    local_data_modify(my_key, |data| {\n-        match data {\n-            Some(@ref val) => fail ~\"unwelcome value: \" + *val,\n-            None       => Some(@~\"first data\")\n-        }\n-    });\n-    local_data_modify(my_key, |data| {\n-        match data {\n-            Some(@~\"first data\") => Some(@~\"next data\"),\n-            Some(@ref val)           => fail ~\"wrong value: \" + *val,\n-            None                 => fail ~\"missing value\"\n-        }\n-    });\n-    assert *(local_data_pop(my_key).get()) == ~\"next data\";\n+fn test_tls_modify() {\n+    unsafe {\n+        fn my_key(_x: @~str) { }\n+        local_data_modify(my_key, |data| {\n+            match data {\n+                Some(@ref val) => fail ~\"unwelcome value: \" + *val,\n+                None       => Some(@~\"first data\")\n+            }\n+        });\n+        local_data_modify(my_key, |data| {\n+            match data {\n+                Some(@~\"first data\") => Some(@~\"next data\"),\n+                Some(@ref val)           => fail ~\"wrong value: \" + *val,\n+                None                 => fail ~\"missing value\"\n+            }\n+        });\n+        assert *(local_data_pop(my_key).get()) == ~\"next data\";\n+    }\n }\n \n #[test]\n-fn test_tls_crust_automorestack_memorial_bug() unsafe {\n-    // This might result in a stack-canary clobber if the runtime fails to set\n-    // sp_limit to 0 when calling the cleanup extern - it might automatically\n-    // jump over to the rust stack, which causes next_c_sp to get recorded as\n-    // Something within a rust stack segment. Then a subsequent upcall (esp.\n-    // for logging, think vsnprintf) would run on a stack smaller than 1 MB.\n-    fn my_key(_x: @~str) { }\n-    do task::spawn {\n-        unsafe { local_data_set(my_key, @~\"hax\"); }\n+fn test_tls_crust_automorestack_memorial_bug() {\n+    unsafe {\n+        // This might result in a stack-canary clobber if the runtime fails to\n+        // set sp_limit to 0 when calling the cleanup extern - it might\n+        // automatically jump over to the rust stack, which causes next_c_sp\n+        // to get recorded as something within a rust stack segment. Then a\n+        // subsequent upcall (esp. for logging, think vsnprintf) would run on\n+        // a stack smaller than 1 MB.\n+        fn my_key(_x: @~str) { }\n+        do task::spawn {\n+            unsafe { local_data_set(my_key, @~\"hax\"); }\n+        }\n     }\n }\n \n #[test]\n-fn test_tls_multiple_types() unsafe {\n-    fn str_key(_x: @~str) { }\n-    fn box_key(_x: @@()) { }\n-    fn int_key(_x: @int) { }\n-    do task::spawn unsafe {\n-        local_data_set(str_key, @~\"string data\");\n-        local_data_set(box_key, @@());\n-        local_data_set(int_key, @42);\n+fn test_tls_multiple_types() {\n+    unsafe {\n+        fn str_key(_x: @~str) { }\n+        fn box_key(_x: @@()) { }\n+        fn int_key(_x: @int) { }\n+        do task::spawn {\n+            unsafe {\n+                local_data_set(str_key, @~\"string data\");\n+                local_data_set(box_key, @@());\n+                local_data_set(int_key, @42);\n+            }\n+        }\n     }\n }\n \n@@ -167,31 +185,38 @@ fn test_tls_overwrite_multiple_types() {\n     fn str_key(_x: @~str) { }\n     fn box_key(_x: @@()) { }\n     fn int_key(_x: @int) { }\n-    do task::spawn unsafe {\n-        local_data_set(str_key, @~\"string data\");\n-        local_data_set(int_key, @42);\n-        // This could cause a segfault if overwriting-destruction is done with\n-        // the crazy polymorphic transmute rather than the provided finaliser.\n-        local_data_set(int_key, @31337);\n+    do task::spawn {\n+        unsafe {\n+            local_data_set(str_key, @~\"string data\");\n+            local_data_set(int_key, @42);\n+            // This could cause a segfault if overwriting-destruction is done\n+            // with the crazy polymorphic transmute rather than the provided\n+            // finaliser.\n+            local_data_set(int_key, @31337);\n+        }\n     }\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-fn test_tls_cleanup_on_failure() unsafe {\n-    fn str_key(_x: @~str) { }\n-    fn box_key(_x: @@()) { }\n-    fn int_key(_x: @int) { }\n-    local_data_set(str_key, @~\"parent data\");\n-    local_data_set(box_key, @@());\n-    do task::spawn unsafe { // spawn_linked\n-        local_data_set(str_key, @~\"string data\");\n+fn test_tls_cleanup_on_failure() {\n+    unsafe {\n+        fn str_key(_x: @~str) { }\n+        fn box_key(_x: @@()) { }\n+        fn int_key(_x: @int) { }\n+        local_data_set(str_key, @~\"parent data\");\n         local_data_set(box_key, @@());\n-        local_data_set(int_key, @42);\n+        do task::spawn {\n+            unsafe { // spawn_linked\n+                local_data_set(str_key, @~\"string data\");\n+                local_data_set(box_key, @@());\n+                local_data_set(int_key, @42);\n+                fail;\n+            }\n+        }\n+        // Not quite nondeterministic.\n+        local_data_set(int_key, @31337);\n         fail;\n     }\n-    // Not quite nondeterministic.\n-    local_data_set(int_key, @31337);\n-    fail;\n }"}, {"sha": "e6aa5b35bb88b7687d49a2761078eef34b23f8f4", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -29,10 +29,12 @@ pub trait LocalData { }\n impl<T: Durable> @T: LocalData { }\n \n impl LocalData: Eq {\n-    pure fn eq(&self, other: &@LocalData) -> bool unsafe {\n-        let ptr_a: (uint, uint) = cast::reinterpret_cast(&(*self));\n-        let ptr_b: (uint, uint) = cast::reinterpret_cast(other);\n-        return ptr_a == ptr_b;\n+    pure fn eq(&self, other: &@LocalData) -> bool {\n+        unsafe {\n+            let ptr_a: (uint, uint) = cast::reinterpret_cast(&(*self));\n+            let ptr_b: (uint, uint) = cast::reinterpret_cast(other);\n+            return ptr_a == ptr_b;\n+        }\n     }\n     pure fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n }\n@@ -43,11 +45,14 @@ type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n \n-extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n-    assert !map_ptr.is_null();\n-    // Get and keep the single reference that was created at the beginning.\n-    let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);\n-    // All local_data will be destroyed along with the map.\n+extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n+    unsafe {\n+        assert !map_ptr.is_null();\n+        // Get and keep the single reference that was created at the\n+        // beginning.\n+        let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);\n+        // All local_data will be destroyed along with the map.\n+    }\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already."}, {"sha": "3f2f2e99ee810de10cdacfea3ae6549c44056e77", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -114,17 +114,21 @@ impl<A: ToStr Copy, B: ToStr Copy, C: ToStr Copy> (A, B, C): ToStr {\n \n impl<A: ToStr> ~[A]: ToStr {\n     #[inline(always)]\n-    pure fn to_str() -> ~str unsafe {\n-        // Bleh -- not really unsafe\n-        // push_str and push_char\n-        let mut acc = ~\"[\", first = true;\n-        for vec::each(self) |elt| unsafe {\n-            if first { first = false; }\n-            else { str::push_str(&mut acc, ~\", \"); }\n-            str::push_str(&mut acc, elt.to_str());\n+    pure fn to_str() -> ~str {\n+        unsafe {\n+            // Bleh -- not really unsafe\n+            // push_str and push_char\n+            let mut acc = ~\"[\", first = true;\n+            for vec::each(self) |elt| {\n+                unsafe {\n+                    if first { first = false; }\n+                    else { str::push_str(&mut acc, ~\", \"); }\n+                    str::push_str(&mut acc, elt.to_str());\n+                }\n+            }\n+            str::push_char(&mut acc, ']');\n+            move acc\n         }\n-        str::push_char(&mut acc, ']');\n-        move acc\n     }\n }\n "}, {"sha": "ee30d7939b7a23752cad3f593597e69b9a870e1f", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 96, "deletions": 84, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -450,51 +450,52 @@ pub pure fn partitioned<T: Copy>(v: &[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n // Mutators\n \n /// Removes the first element from a vector and return it\n-pub fn shift<T>(v: &mut ~[T]) -> T unsafe {\n+pub fn shift<T>(v: &mut ~[T]) -> T {\n+    unsafe {\n+        assert v.is_not_empty();\n \n-    assert v.is_not_empty();\n+        if v.len() == 1 { return v.pop() }\n \n-    if v.len() == 1 { return v.pop() }\n+        if v.len() == 2 {\n+            let last = v.pop();\n+            let first = v.pop();\n+            v.push(last);\n+            return first;\n+        }\n \n-    if v.len() == 2 {\n-        let last = v.pop();\n-        let first = v.pop();\n-        v.push(last);\n-        return first;\n-    }\n+        let ln = v.len();\n+        let next_ln = v.len() - 1;\n \n-    let ln = v.len();\n-    let next_ln = v.len() - 1;\n+        // Save the last element. We're going to overwrite its position\n+        let mut work_elt = v.pop();\n+        // We still should have room to work where what last element was\n+        assert capacity(v) >= ln;\n+        // Pretend like we have the original length so we can use\n+        // the vector copy_memory to overwrite the hole we just made\n+        raw::set_len(&mut *v, ln);\n \n-    // Save the last element. We're going to overwrite its position\n-    let mut work_elt = v.pop();\n-    // We still should have room to work where what last element was\n-    assert capacity(v) >= ln;\n-    // Pretend like we have the original length so we can use\n-    // the vector copy_memory to overwrite the hole we just made\n-    raw::set_len(&mut *v, ln);\n+        // Memcopy the head element (the one we want) to the location we just\n+        // popped. For the moment it unsafely exists at both the head and last\n+        // positions\n+        let first_slice = view(*v, 0, 1);\n+        let last_slice = mut_view(*v, next_ln, ln);\n+        raw::copy_memory(last_slice, first_slice, 1);\n \n-    // Memcopy the head element (the one we want) to the location we just\n-    // popped. For the moment it unsafely exists at both the head and last\n-    // positions\n-    let first_slice = view(*v, 0, 1);\n-    let last_slice = mut_view(*v, next_ln, ln);\n-    raw::copy_memory(last_slice, first_slice, 1);\n+        // Memcopy everything to the left one element\n+        let init_slice = mut_view(*v, 0, next_ln);\n+        let tail_slice = view(*v, 1, ln);\n+        raw::copy_memory(init_slice, tail_slice, next_ln);\n \n-    // Memcopy everything to the left one element\n-    let init_slice = mut_view(*v, 0, next_ln);\n-    let tail_slice = view(*v, 1, ln);\n-    raw::copy_memory(init_slice, tail_slice, next_ln);\n+        // Set the new length. Now the vector is back to normal\n+        raw::set_len(&mut *v, next_ln);\n \n-    // Set the new length. Now the vector is back to normal\n-    raw::set_len(&mut *v, next_ln);\n+        // Swap out the element we want from the end\n+        let vp = raw::to_mut_ptr(*v);\n+        let vp = ptr::mut_offset(vp, next_ln - 1);\n+        *vp <-> work_elt;\n \n-    // Swap out the element we want from the end\n-    let vp = raw::to_mut_ptr(*v);\n-    let vp = ptr::mut_offset(vp, next_ln - 1);\n-    *vp <-> work_elt;\n-\n-    return work_elt;\n+        return work_elt;\n+    }\n }\n \n /// Prepend an element to the vector\n@@ -532,23 +533,25 @@ pub fn remove<T>(v: &mut ~[T], i: uint) -> T {\n     v.pop()\n }\n \n-pub fn consume<T>(v: ~[T], f: fn(uint, v: T)) unsafe {\n-    let mut v = v; // FIXME(#3488)\n-\n-    do as_mut_buf(v) |p, ln| {\n-        for uint::range(0, ln) |i| {\n-            // NB: This unsafe operation counts on init writing 0s to the\n-            // holes we create in the vector. That ensures that, if the\n-            // iterator fails then we won't try to clean up the consumed\n-            // elements during unwinding\n-            let mut x = rusti::init();\n-            let p = ptr::mut_offset(p, i);\n-            x <-> *p;\n-            f(i, x);\n+pub fn consume<T>(v: ~[T], f: fn(uint, v: T)) {\n+    unsafe {\n+        let mut v = v; // FIXME(#3488)\n+\n+        do as_mut_buf(v) |p, ln| {\n+            for uint::range(0, ln) |i| {\n+                // NB: This unsafe operation counts on init writing 0s to the\n+                // holes we create in the vector. That ensures that, if the\n+                // iterator fails then we won't try to clean up the consumed\n+                // elements during unwinding\n+                let mut x = rusti::init();\n+                let p = ptr::mut_offset(p, i);\n+                x <-> *p;\n+                f(i, x);\n+            }\n         }\n-    }\n \n-    raw::set_len(&mut v, 0);\n+        raw::set_len(&mut v, 0);\n+    }\n }\n \n pub fn consume_mut<T>(v: ~[mut T], f: fn(uint, v: T)) {\n@@ -666,36 +669,39 @@ pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n  * Remove consecutive repeated elements from a vector; if the vector is\n  * sorted, this removes all duplicates.\n  */\n-pub fn dedup<T: Eq>(v: &mut ~[T]) unsafe {\n-    if v.len() < 1 { return; }\n-    let mut last_written = 0, next_to_read = 1;\n-    do as_const_buf(*v) |p, ln| {\n-        // We have a mutable reference to v, so we can make arbitrary changes.\n-        // (cf. push and pop)\n-        let p = p as *mut T;\n-        // last_written < next_to_read <= ln\n-        while next_to_read < ln {\n-            // last_written < next_to_read < ln\n-            if *ptr::mut_offset(p, next_to_read) ==\n-                *ptr::mut_offset(p, last_written) {\n-                // FIXME #4204 Should be rusti::uninit() - don't need to zero\n-                let mut dropped = rusti::init();\n-                dropped <-> *ptr::mut_offset(p, next_to_read);\n-            } else {\n-                last_written += 1;\n-                // last_written <= next_to_read < ln\n-                if next_to_read != last_written {\n-                    *ptr::mut_offset(p, last_written) <->\n-                        *ptr::mut_offset(p, next_to_read);\n+pub fn dedup<T: Eq>(v: &mut ~[T]) {\n+    unsafe {\n+        if v.len() < 1 { return; }\n+        let mut last_written = 0, next_to_read = 1;\n+        do as_const_buf(*v) |p, ln| {\n+            // We have a mutable reference to v, so we can make arbitrary\n+            // changes. (cf. push and pop)\n+            let p = p as *mut T;\n+            // last_written < next_to_read <= ln\n+            while next_to_read < ln {\n+                // last_written < next_to_read < ln\n+                if *ptr::mut_offset(p, next_to_read) ==\n+                    *ptr::mut_offset(p, last_written) {\n+                    // FIXME #4204 Should be rusti::uninit() - don't need to\n+                    // zero\n+                    let mut dropped = rusti::init();\n+                    dropped <-> *ptr::mut_offset(p, next_to_read);\n+                } else {\n+                    last_written += 1;\n+                    // last_written <= next_to_read < ln\n+                    if next_to_read != last_written {\n+                        *ptr::mut_offset(p, last_written) <->\n+                            *ptr::mut_offset(p, next_to_read);\n+                    }\n                 }\n+                // last_written <= next_to_read < ln\n+                next_to_read += 1;\n+                // last_written < next_to_read <= ln\n             }\n-            // last_written <= next_to_read < ln\n-            next_to_read += 1;\n-            // last_written < next_to_read <= ln\n         }\n+        // last_written < next_to_read == ln\n+        raw::set_len(v, last_written + 1);\n     }\n-    // last_written < next_to_read == ln\n-    raw::set_len(v, last_written + 1);\n }\n \n \n@@ -1215,7 +1221,9 @@ pub pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n     let sz = len(v);\n     let mut i = 0u;\n     assert sz == len(u);\n-    while i < sz unsafe { zipped.push((v[i], u[i])); i += 1u; }\n+    while i < sz {\n+        unsafe { zipped.push((v[i], u[i])); i += 1u; }\n+    }\n     zipped\n }\n \n@@ -1454,8 +1462,10 @@ pub pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     assert 1u <= nn;\n     for vec::eachi (xx) |ii, _x| {\n         let len = vec::len(xx);\n-        if ii+nn <= len unsafe {\n-            ww.push(vec::slice(xx, ii, ii+nn));\n+        if ii+nn <= len {\n+            unsafe {\n+                ww.push(vec::slice(xx, ii, ii+nn));\n+            }\n         }\n     }\n     ww\n@@ -3909,10 +3919,12 @@ mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    fn test_copy_memory_oob() unsafe {\n-        let a = [mut 1, 2, 3, 4];\n-        let b = [1, 2, 3, 4, 5];\n-        raw::copy_memory(a, b, 5);\n+    fn test_copy_memory_oob() {\n+        unsafe {\n+            let a = [mut 1, 2, 3, 4];\n+            let b = [1, 2, 3, 4, 5];\n+            raw::copy_memory(a, b, 5);\n+        }\n     }\n \n }"}, {"sha": "03639b289e7a96b116ed6ecb3ef70897fd220383", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -59,12 +59,14 @@ impl output_type : cmp::Eq {\n     pure fn ne(&self, other: &output_type) -> bool { !(*self).eq(other) }\n }\n \n-pub fn llvm_err(sess: Session, +msg: ~str) -> ! unsafe {\n-    let cstr = llvm::LLVMRustGetLastError();\n-    if cstr == ptr::null() {\n-        sess.fatal(msg);\n-    } else {\n-        sess.fatal(msg + ~\": \" + str::raw::from_c_str(cstr));\n+pub fn llvm_err(sess: Session, +msg: ~str) -> ! {\n+    unsafe {\n+        let cstr = llvm::LLVMRustGetLastError();\n+        if cstr == ptr::null() {\n+            sess.fatal(msg);\n+        } else {\n+            sess.fatal(msg + ~\": \" + str::raw::from_c_str(cstr));\n+        }\n     }\n }\n \n@@ -121,50 +123,52 @@ pub mod jit {\n             pm: PassManagerRef,\n             m: ModuleRef,\n             opt: c_int,\n-            stacks: bool) unsafe {\n-        let manager = llvm::LLVMRustPrepareJIT(rusti::morestack_addr());\n-\n-        // We need to tell JIT where to resolve all linked\n-        // symbols from. The equivalent of -lstd, -lcore, etc.\n-        // By default the JIT will resolve symbols from the std and\n-        // core linked into rustc. We don't want that,\n-        // incase the user wants to use an older std library.\n-\n-        let cstore = sess.cstore;\n-        for cstore::get_used_crate_files(cstore).each |cratepath| {\n-            let path = cratepath.to_str();\n-\n-            debug!(\"linking: %s\", path);\n-\n-            let _: () = str::as_c_str(\n-                path,\n-                |buf_t| {\n-                    if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n-                        llvm_err(sess, ~\"Could not link\");\n-                    }\n-                    debug!(\"linked: %s\", path);\n-                });\n-        }\n+            stacks: bool) {\n+        unsafe {\n+            let manager = llvm::LLVMRustPrepareJIT(rusti::morestack_addr());\n+\n+            // We need to tell JIT where to resolve all linked\n+            // symbols from. The equivalent of -lstd, -lcore, etc.\n+            // By default the JIT will resolve symbols from the std and\n+            // core linked into rustc. We don't want that,\n+            // incase the user wants to use an older std library.\n+\n+            let cstore = sess.cstore;\n+            for cstore::get_used_crate_files(cstore).each |cratepath| {\n+                let path = cratepath.to_str();\n+\n+                debug!(\"linking: %s\", path);\n+\n+                let _: () = str::as_c_str(\n+                    path,\n+                    |buf_t| {\n+                        if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n+                            llvm_err(sess, ~\"Could not link\");\n+                        }\n+                        debug!(\"linked: %s\", path);\n+                    });\n+            }\n \n-        // The execute function will return a void pointer\n-        // to the _rust_main function. We can do closure\n-        // magic here to turn it straight into a callable rust\n-        // closure. It will also cleanup the memory manager\n-        // for us.\n+            // The execute function will return a void pointer\n+            // to the _rust_main function. We can do closure\n+            // magic here to turn it straight into a callable rust\n+            // closure. It will also cleanup the memory manager\n+            // for us.\n \n-        let entry = llvm::LLVMRustExecuteJIT(manager,\n-                                             pm, m, opt, stacks);\n+            let entry = llvm::LLVMRustExecuteJIT(manager,\n+                                                 pm, m, opt, stacks);\n \n-        if ptr::is_null(entry) {\n-            llvm_err(sess, ~\"Could not JIT\");\n-        } else {\n-            let closure = Closure {\n-                code: entry,\n-                env: ptr::null()\n-            };\n-            let func: fn(++argv: ~[~str]) = cast::transmute(move closure);\n+            if ptr::is_null(entry) {\n+                llvm_err(sess, ~\"Could not JIT\");\n+            } else {\n+                let closure = Closure {\n+                    code: entry,\n+                    env: ptr::null()\n+                };\n+                let func: fn(++argv: ~[~str]) = cast::transmute(move closure);\n \n-            func(~[/*bad*/copy sess.opts.binary]);\n+                func(~[/*bad*/copy sess.opts.binary]);\n+            }\n         }\n     }\n }\n@@ -576,8 +580,10 @@ fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n     return {name: name, vers: vers, extras_hash: extras_hash};\n }\n \n-fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str unsafe {\n-    symbol_hasher.result_str()\n+fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str {\n+    unsafe {\n+        symbol_hasher.result_str()\n+    }\n }\n \n "}, {"sha": "d647e8f9a2629a8355b1041dd703862112be0101", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -1386,7 +1386,7 @@ fn float_width(llt: TypeRef) -> uint {\n     }\n }\n \n-fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] unsafe {\n+fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] {\n     unsafe {\n         let args = vec::from_elem(llvm::LLVMCountParamTypes(fn_ty) as uint,\n                                  0 as TypeRef);"}, {"sha": "8c9998ee25a19510987887686abac69340feabb0", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -201,51 +201,53 @@ fn metadata_matches(extern_metas: ~[@ast::meta_item],\n }\n \n fn get_metadata_section(os: os,\n-                        filename: &Path) -> Option<@~[u8]> unsafe {\n-    let mb = str::as_c_str(filename.to_str(), |buf| {\n-        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-    });\n-    if mb as int == 0 { return option::None::<@~[u8]>; }\n-    let of = match mk_object_file(mb) {\n-        option::Some(of) => of,\n-        _ => return option::None::<@~[u8]>\n-    };\n-    let si = mk_section_iter(of.llof);\n-    while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n-        let name_buf = llvm::LLVMGetSectionName(si.llsi);\n-        let name = unsafe { str::raw::from_c_str(name_buf) };\n-        if name == meta_section_name(os) {\n-            let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-            let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n-            let mut found = None;\n-            unsafe {\n-                let cvbuf: *u8 = cast::reinterpret_cast(&cbuf);\n-                let vlen = vec::len(encoder::metadata_encoding_version);\n-                debug!(\"checking %u bytes of metadata-version stamp\",\n-                       vlen);\n-                let minsz = uint::min(vlen, csz);\n-                let mut version_ok = false;\n-                do vec::raw::buf_as_slice(cvbuf, minsz) |buf0| {\n-                    version_ok = (buf0 ==\n-                                  encoder::metadata_encoding_version);\n-                }\n-                if !version_ok { return None; }\n+                        filename: &Path) -> Option<@~[u8]> {\n+    unsafe {\n+        let mb = str::as_c_str(filename.to_str(), |buf| {\n+            llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+        });\n+        if mb as int == 0 { return option::None::<@~[u8]>; }\n+        let of = match mk_object_file(mb) {\n+            option::Some(of) => of,\n+            _ => return option::None::<@~[u8]>\n+        };\n+        let si = mk_section_iter(of.llof);\n+        while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n+            let name_buf = llvm::LLVMGetSectionName(si.llsi);\n+            let name = unsafe { str::raw::from_c_str(name_buf) };\n+            if name == meta_section_name(os) {\n+                let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n+                let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n+                let mut found = None;\n+                unsafe {\n+                    let cvbuf: *u8 = cast::reinterpret_cast(&cbuf);\n+                    let vlen = vec::len(encoder::metadata_encoding_version);\n+                    debug!(\"checking %u bytes of metadata-version stamp\",\n+                           vlen);\n+                    let minsz = uint::min(vlen, csz);\n+                    let mut version_ok = false;\n+                    do vec::raw::buf_as_slice(cvbuf, minsz) |buf0| {\n+                        version_ok = (buf0 ==\n+                                      encoder::metadata_encoding_version);\n+                    }\n+                    if !version_ok { return None; }\n \n-                let cvbuf1 = ptr::offset(cvbuf, vlen);\n-                debug!(\"inflating %u bytes of compressed metadata\",\n-                       csz - vlen);\n-                do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n-                    let inflated = flate::inflate_bytes(bytes);\n-                    found = move Some(@(move inflated));\n-                }\n-                if found != None {\n-                    return found;\n+                    let cvbuf1 = ptr::offset(cvbuf, vlen);\n+                    debug!(\"inflating %u bytes of compressed metadata\",\n+                           csz - vlen);\n+                    do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n+                        let inflated = flate::inflate_bytes(bytes);\n+                        found = move Some(@(move inflated));\n+                    }\n+                    if found != None {\n+                        return found;\n+                    }\n                 }\n             }\n+            llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        llvm::LLVMMoveToNextSection(si.llsi);\n+        return option::None::<@~[u8]>;\n     }\n-    return option::None::<@~[u8]>;\n }\n \n fn meta_section_name(os: os) -> ~str {"}, {"sha": "5b7453ebf4c16a986c841ce4f923eb142542f53a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -2255,14 +2255,16 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef) {\n                              val_ty(crate_map)], ccx.int_type);\n         let start = decl_cdecl_fn(ccx.llmod, ~\"rust_start\", start_ty);\n \n-        let args = if ccx.sess.building_library unsafe {\n-            ~[rust_main,\n-              llvm::LLVMConstInt(T_i32(), 0u as c_ulonglong, False),\n-              llvm::LLVMConstInt(T_i32(), 0u as c_ulonglong, False),\n-              crate_map]\n-        } else unsafe {\n-            ~[rust_main, llvm::LLVMGetParam(llfn, 0 as c_uint),\n-              llvm::LLVMGetParam(llfn, 1 as c_uint), crate_map]\n+        let args = unsafe {\n+            if ccx.sess.building_library {\n+                ~[rust_main,\n+                  llvm::LLVMConstInt(T_i32(), 0u as c_ulonglong, False),\n+                  llvm::LLVMConstInt(T_i32(), 0u as c_ulonglong, False),\n+                  crate_map]\n+            } else {\n+                ~[rust_main, llvm::LLVMGetParam(llfn, 0 as c_uint),\n+                  llvm::LLVMGetParam(llfn, 1 as c_uint), crate_map]\n+            }\n         };\n \n         let result = unsafe {"}, {"sha": "060bef1a44c62845935b5b0be1a2bf21196fb01f", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -176,9 +176,11 @@ fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n // lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n-fn noname() -> *libc::c_char unsafe {\n-    const cnull: uint = 0u;\n-    return cast::reinterpret_cast(&ptr::addr_of(&cnull));\n+fn noname() -> *libc::c_char {\n+    unsafe {\n+        const cnull: uint = 0u;\n+        return cast::reinterpret_cast(&ptr::addr_of(&cnull));\n+    }\n }\n \n fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],"}, {"sha": "5c727b0970de0fd6bce5d5e81fa2f16582bd26b8", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -660,7 +660,7 @@ fn val_str(tn: type_names, v: ValueRef) -> @str {\n }\n \n // Returns the nth element of the given LLVM structure type.\n-fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef unsafe {\n+fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n     unsafe {\n         let elt_count = llvm::LLVMCountStructElementTypes(llstructty) as uint;\n         assert (n < elt_count);\n@@ -832,10 +832,12 @@ fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n     return T_int(targ_cfg);\n }\n \n-fn T_fn(inputs: ~[TypeRef], output: TypeRef) -> TypeRef unsafe {\n-    return llvm::LLVMFunctionType(output, to_ptr(inputs),\n-                               inputs.len() as c_uint,\n-                               False);\n+fn T_fn(inputs: ~[TypeRef], output: TypeRef) -> TypeRef {\n+    unsafe {\n+        return llvm::LLVMFunctionType(output, to_ptr(inputs),\n+                                   inputs.len() as c_uint,\n+                                   False);\n+    }\n }\n \n fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n@@ -854,7 +856,7 @@ fn T_root(t: TypeRef, addrspace: addrspace) -> TypeRef {\n     }\n }\n \n-fn T_struct(elts: ~[TypeRef]) -> TypeRef unsafe {\n+fn T_struct(elts: ~[TypeRef]) -> TypeRef {\n     unsafe {\n         return llvm::LLVMStructType(to_ptr(elts),\n                                     elts.len() as c_uint,\n@@ -869,7 +871,7 @@ fn T_named_struct(name: ~str) -> TypeRef {\n     }\n }\n \n-fn set_struct_body(t: TypeRef, elts: ~[TypeRef]) unsafe {\n+fn set_struct_body(t: TypeRef, elts: ~[TypeRef]) {\n     unsafe {\n         llvm::LLVMStructSetBody(t,\n                                 to_ptr(elts),\n@@ -908,7 +910,7 @@ fn T_task(targ_cfg: @session::config) -> TypeRef {\n     return t;\n }\n \n-fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef unsafe {\n+fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     unsafe {\n@@ -1188,7 +1190,7 @@ fn C_postr(s: ~str) -> ValueRef {\n     }\n }\n \n-fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n+fn C_zero_byte_arr(size: uint) -> ValueRef {\n     unsafe {\n         let mut i = 0u;\n         let mut elts: ~[ValueRef] = ~[];\n@@ -1215,22 +1217,22 @@ fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n     }\n }\n \n-fn C_array(ty: TypeRef, elts: ~[ValueRef]) -> ValueRef unsafe {\n+fn C_array(ty: TypeRef, elts: ~[ValueRef]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstArray(ty, vec::raw::to_ptr(elts),\n                                  elts.len() as c_uint);\n     }\n }\n \n-fn C_bytes(bytes: ~[u8]) -> ValueRef unsafe {\n+fn C_bytes(bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstString(\n             cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n             bytes.len() as c_uint, True);\n     }\n }\n \n-fn C_bytes_plus_null(bytes: ~[u8]) -> ValueRef unsafe {\n+fn C_bytes_plus_null(bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstString(\n             cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),"}, {"sha": "6b368555637bbac1364ce319844bff159c4a3446", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 150, "deletions": 136, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -86,7 +86,7 @@ fn lli64(val: int) -> ValueRef {\n fn lli1(bval: bool) -> ValueRef {\n     C_bool(bval)\n }\n-fn llmdnode(elems: ~[ValueRef]) -> ValueRef unsafe {\n+fn llmdnode(elems: ~[ValueRef]) -> ValueRef {\n     unsafe {\n         llvm::LLVMMDNode(vec::raw::to_ptr(elems),\n                          vec::len(elems) as libc::c_uint)\n@@ -95,8 +95,10 @@ fn llmdnode(elems: ~[ValueRef]) -> ValueRef unsafe {\n fn llunused() -> ValueRef {\n     lli32(0x0)\n }\n-fn llnull() -> ValueRef unsafe {\n-    cast::reinterpret_cast(&ptr::null::<ValueRef>())\n+fn llnull() -> ValueRef {\n+    unsafe {\n+        cast::reinterpret_cast(&ptr::null::<ValueRef>())\n+    }\n }\n \n fn add_named_metadata(cx: @crate_ctxt, name: ~str, val: ValueRef) {\n@@ -154,68 +156,75 @@ enum debug_metadata {\n     retval_metadata(@metadata<retval_md>),\n }\n \n-fn cast_safely<T: Copy, U>(val: T) -> U unsafe {\n-    let val2 = val;\n-    return cast::transmute(move val2);\n+fn cast_safely<T: Copy, U>(val: T) -> U {\n+    unsafe {\n+        let val2 = val;\n+        return cast::transmute(move val2);\n+    }\n }\n \n-fn md_from_metadata<T>(val: debug_metadata) -> T unsafe {\n-    match val {\n-      file_metadata(md) => cast_safely(md),\n-      compile_unit_metadata(md) => cast_safely(md),\n-      subprogram_metadata(md) => cast_safely(md),\n-      local_var_metadata(md) => cast_safely(md),\n-      tydesc_metadata(md) => cast_safely(md),\n-      block_metadata(md) => cast_safely(md),\n-      argument_metadata(md) => cast_safely(md),\n-      retval_metadata(md) => cast_safely(md)\n+fn md_from_metadata<T>(val: debug_metadata) -> T {\n+    unsafe {\n+        match val {\n+          file_metadata(md) => cast_safely(md),\n+          compile_unit_metadata(md) => cast_safely(md),\n+          subprogram_metadata(md) => cast_safely(md),\n+          local_var_metadata(md) => cast_safely(md),\n+          tydesc_metadata(md) => cast_safely(md),\n+          block_metadata(md) => cast_safely(md),\n+          argument_metadata(md) => cast_safely(md),\n+          retval_metadata(md) => cast_safely(md)\n+        }\n     }\n }\n \n fn cached_metadata<T: Copy>(cache: metadata_cache, mdtag: int,\n-                           eq: fn(md: T) -> bool) -> Option<T> unsafe {\n-    if cache.contains_key(mdtag) {\n-        let items = cache.get(mdtag);\n-        for items.each |item| {\n-            let md: T = md_from_metadata::<T>(*item);\n-            if eq(md) {\n-                return option::Some(md);\n+                           eq: fn(md: T) -> bool) -> Option<T> {\n+    unsafe {\n+        if cache.contains_key(mdtag) {\n+            let items = cache.get(mdtag);\n+            for items.each |item| {\n+                let md: T = md_from_metadata::<T>(*item);\n+                if eq(md) {\n+                    return option::Some(md);\n+                }\n             }\n         }\n+        return option::None;\n     }\n-    return option::None;\n }\n \n-fn create_compile_unit(cx: @crate_ctxt)\n-    -> @metadata<compile_unit_md> unsafe {\n-    let cache = get_cache(cx);\n-    let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n-    let tg = CompileUnitTag;\n-    match cached_metadata::<@metadata<compile_unit_md>>(cache, tg,\n-                        |md| md.data.name == crate_name) {\n-      option::Some(md) => return md,\n-      option::None => ()\n-    }\n-\n-    let (_, work_dir) = get_file_path_and_dir(cx.sess.working_dir.to_str(),\n-                                              crate_name);\n-    let unit_metadata = ~[lltag(tg),\n-                         llunused(),\n-                         lli32(DW_LANG_RUST),\n-                         llstr(copy crate_name),\n-                         llstr(work_dir),\n-                         llstr(env!(\"CFG_VERSION\")),\n-                         lli1(true), // deprecated: main compile unit\n-                         lli1(cx.sess.opts.optimize != session::No),\n-                         llstr(~\"\"), // flags (???)\n-                         lli32(0) // runtime version (???)\n-                        ];\n-    let unit_node = llmdnode(unit_metadata);\n-    add_named_metadata(cx, ~\"llvm.dbg.cu\", unit_node);\n-    let mdval = @{node: unit_node, data: {name: crate_name}};\n-    update_cache(cache, tg, compile_unit_metadata(mdval));\n+fn create_compile_unit(cx: @crate_ctxt) -> @metadata<compile_unit_md> {\n+    unsafe {\n+        let cache = get_cache(cx);\n+        let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n+        let tg = CompileUnitTag;\n+        match cached_metadata::<@metadata<compile_unit_md>>(cache, tg,\n+                            |md| md.data.name == crate_name) {\n+          option::Some(md) => return md,\n+          option::None => ()\n+        }\n \n-    return mdval;\n+        let (_, work_dir) = get_file_path_and_dir(\n+            cx.sess.working_dir.to_str(), crate_name);\n+        let unit_metadata = ~[lltag(tg),\n+                             llunused(),\n+                             lli32(DW_LANG_RUST),\n+                             llstr(copy crate_name),\n+                             llstr(work_dir),\n+                             llstr(env!(\"CFG_VERSION\")),\n+                             lli1(true), // deprecated: main compile unit\n+                             lli1(cx.sess.opts.optimize != session::No),\n+                             llstr(~\"\"), // flags (???)\n+                             lli32(0) // runtime version (???)\n+                            ];\n+        let unit_node = llmdnode(unit_metadata);\n+        add_named_metadata(cx, ~\"llvm.dbg.cu\", unit_node);\n+        let mdval = @{node: unit_node, data: {name: crate_name}};\n+        update_cache(cache, tg, compile_unit_metadata(mdval));\n+\n+        return mdval;\n+    }\n }\n \n fn get_cache(cx: @crate_ctxt) -> metadata_cache {\n@@ -646,94 +655,99 @@ fn create_var(type_tag: int, context: ValueRef, +name: ~str, file: ValueRef,\n }\n \n fn create_local_var(bcx: block, local: @ast::local)\n-    -> @metadata<local_var_md> unsafe {\n-    let cx = bcx.ccx();\n-    let cache = get_cache(cx);\n-    let tg = AutoVariableTag;\n-    match cached_metadata::<@metadata<local_var_md>>(\n-        cache, tg, |md| md.data.id == local.node.id) {\n-      option::Some(md) => return md,\n-      option::None => ()\n-    }\n-\n-    let name = match local.node.pat.node {\n-      ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n-      // FIXME this should be handled (#2533)\n-      _ => fail ~\"no single variable name for local\"\n-    };\n-    let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n-    let ty = node_id_type(bcx, local.node.id);\n-    let tymd = create_ty(cx, ty, local.node.ty);\n-    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n-    let context = match bcx.parent {\n-        None => create_function(bcx.fcx).node,\n-        Some(_) => create_block(bcx).node\n-    };\n-    let mdnode = create_var(tg, context, cx.sess.str_of(name), filemd.node,\n-                            loc.line as int, tymd.node);\n-    let mdval = @{node: mdnode, data: {id: local.node.id}};\n-    update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n-\n-    let llptr = match bcx.fcx.lllocals.find(local.node.id) {\n-      option::Some(local_mem(v)) => v,\n-      option::Some(_) => {\n-        bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n-                something weird\");\n-      }\n-      option::None => {\n-        match bcx.fcx.lllocals.get(local.node.pat.id) {\n-          local_imm(v) => v,\n-          _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n-                                                     something weird\")\n+    -> @metadata<local_var_md> {\n+    unsafe {\n+        let cx = bcx.ccx();\n+        let cache = get_cache(cx);\n+        let tg = AutoVariableTag;\n+        match cached_metadata::<@metadata<local_var_md>>(\n+            cache, tg, |md| md.data.id == local.node.id) {\n+          option::Some(md) => return md,\n+          option::None => ()\n         }\n-      }\n-    };\n-    let declargs = ~[llmdnode(~[llptr]), mdnode];\n-    trans::build::Call(bcx, cx.intrinsics.get(~\"llvm.dbg.declare\"),\n-                       declargs);\n-    return mdval;\n-}\n \n-fn create_arg(bcx: block, arg: ast::arg, sp: span)\n-    -> Option<@metadata<argument_md>> unsafe {\n-    let fcx = bcx.fcx, cx = fcx.ccx;\n-    let cache = get_cache(cx);\n-    let tg = ArgVariableTag;\n-    match cached_metadata::<@metadata<argument_md>>(\n-        cache, ArgVariableTag, |md| md.data.id == arg.id) {\n-      option::Some(md) => return Some(md),\n-      option::None => ()\n+        let name = match local.node.pat.node {\n+          ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n+          // FIXME this should be handled (#2533)\n+          _ => fail ~\"no single variable name for local\"\n+        };\n+        let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n+        let ty = node_id_type(bcx, local.node.id);\n+        let tymd = create_ty(cx, ty, local.node.ty);\n+        let filemd = create_file(cx, /*bad*/copy loc.file.name);\n+        let context = match bcx.parent {\n+            None => create_function(bcx.fcx).node,\n+            Some(_) => create_block(bcx).node\n+        };\n+        let mdnode = create_var(tg, context, cx.sess.str_of(name),\n+                                filemd.node, loc.line as int, tymd.node);\n+        let mdval = @{node: mdnode, data: {id: local.node.id}};\n+        update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n+\n+        let llptr = match bcx.fcx.lllocals.find(local.node.id) {\n+          option::Some(local_mem(v)) => v,\n+          option::Some(_) => {\n+            bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n+                    something weird\");\n+          }\n+          option::None => {\n+            match bcx.fcx.lllocals.get(local.node.pat.id) {\n+              local_imm(v) => v,\n+              _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n+                                                         something weird\")\n+            }\n+          }\n+        };\n+        let declargs = ~[llmdnode(~[llptr]), mdnode];\n+        trans::build::Call(bcx, cx.intrinsics.get(~\"llvm.dbg.declare\"),\n+                           declargs);\n+        return mdval;\n     }\n+}\n \n-    let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n-    let ty = node_id_type(bcx, arg.id);\n-    let tymd = create_ty(cx, ty, arg.ty);\n-    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n-    let context = create_function(bcx.fcx);\n-\n-    match arg.pat.node {\n-        ast::pat_ident(_, path, _) => {\n-            // XXX: This is wrong; it should work for multiple bindings.\n-            let mdnode = create_var(tg,\n-                                    context.node,\n-                                    cx.sess.str_of(path.idents.last()),\n-                                    filemd.node,\n-                                    loc.line as int,\n-                                    tymd.node);\n-\n-            let mdval = @{node: mdnode, data: {id: arg.id}};\n-            update_cache(cache, tg, argument_metadata(mdval));\n-\n-            let llptr = match fcx.llargs.get(arg.id) {\n-              local_mem(v) | local_imm(v) => v,\n-            };\n-            let declargs = ~[llmdnode(~[llptr]), mdnode];\n-            trans::build::Call(bcx, cx.intrinsics.get(~\"llvm.dbg.declare\"),\n-                               declargs);\n-            return Some(mdval);\n+fn create_arg(bcx: block, arg: ast::arg, sp: span)\n+    -> Option<@metadata<argument_md>> {\n+    unsafe {\n+        let fcx = bcx.fcx, cx = fcx.ccx;\n+        let cache = get_cache(cx);\n+        let tg = ArgVariableTag;\n+        match cached_metadata::<@metadata<argument_md>>(\n+            cache, ArgVariableTag, |md| md.data.id == arg.id) {\n+          option::Some(md) => return Some(md),\n+          option::None => ()\n         }\n-        _ => {\n-            return None;\n+\n+        let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n+        let ty = node_id_type(bcx, arg.id);\n+        let tymd = create_ty(cx, ty, arg.ty);\n+        let filemd = create_file(cx, /*bad*/copy loc.file.name);\n+        let context = create_function(bcx.fcx);\n+\n+        match arg.pat.node {\n+            ast::pat_ident(_, path, _) => {\n+                // XXX: This is wrong; it should work for multiple bindings.\n+                let mdnode = create_var(tg,\n+                                        context.node,\n+                                        cx.sess.str_of(path.idents.last()),\n+                                        filemd.node,\n+                                        loc.line as int,\n+                                        tymd.node);\n+\n+                let mdval = @{node: mdnode, data: {id: arg.id}};\n+                update_cache(cache, tg, argument_metadata(mdval));\n+\n+                let llptr = match fcx.llargs.get(arg.id) {\n+                  local_mem(v) | local_imm(v) => v,\n+                };\n+                let declargs = ~[llmdnode(~[llptr]), mdnode];\n+                trans::build::Call(bcx,\n+                                   cx.intrinsics.get(~\"llvm.dbg.declare\"),\n+                                   declargs);\n+                return Some(mdval);\n+            }\n+            _ => {\n+                return None;\n+            }\n         }\n     }\n }"}, {"sha": "5607e55d4908e3e8735ec850f8b3ef754bfb4c82", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -498,11 +498,13 @@ type t_box = @{sty: sty,\n enum t_opaque {}\n type t = *t_opaque;\n \n-pure fn get(t: t) -> t_box unsafe {\n-    let t2 = cast::reinterpret_cast::<t, t_box>(&t);\n-    let t3 = t2;\n-    cast::forget(move t2);\n-    t3\n+pure fn get(t: t) -> t_box {\n+    unsafe {\n+        let t2 = cast::reinterpret_cast::<t, t_box>(&t);\n+        let t3 = t2;\n+        cast::forget(move t2);\n+        t3\n+    }\n }\n \n pure fn tbox_has_flag(tb: t_box, flag: tbox_flag) -> bool {"}, {"sha": "57b338f4aa1c66deba3fd99685140631240da96c", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -141,9 +141,11 @@ impl BigBitv {\n             let w0 = self.storage[i] & mask;\n             let w1 = b.storage[i] & mask;\n             let w = op(w0, w1) & mask;\n-            if w0 != w unsafe {\n-                changed = true;\n-                self.storage[i] = w;\n+            if w0 != w {\n+                unsafe {\n+                    changed = true;\n+                    self.storage[i] = w;\n+                }\n             }\n             true\n         }"}, {"sha": "e3cc6797abf21869ee551b7a73ef4b952268dea9", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 110, "deletions": 108, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -219,126 +219,128 @@ pub type Result = result::Result<Matches, Fail_>;\n  * `opt_str`, etc. to interrogate results.  Returns `err(Fail_)` on failure.\n  * Use <fail_str> to get an error message.\n  */\n-pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n-    let n_opts = opts.len();\n-    fn f(_x: uint) -> ~[Optval] { return ~[]; }\n-    let vals = vec::cast_to_mut(vec::from_fn(n_opts, f));\n-    let mut free: ~[~str] = ~[];\n-    let l = args.len();\n-    let mut i = 0;\n-    while i < l {\n-        let cur = args[i];\n-        let curlen = cur.len();\n-        if !is_arg(cur) {\n-            free.push(cur);\n-        } else if cur == ~\"--\" {\n-            let mut j = i + 1;\n-            while j < l { free.push(args[j]); j += 1; }\n-            break;\n-        } else {\n-            let mut names;\n-            let mut i_arg = None;\n-            if cur[1] == '-' as u8 {\n-                let tail = str::slice(cur, 2, curlen);\n-                let tail_eq = str::splitn_char(tail, '=', 1);\n-                if tail_eq.len() <= 1 {\n-                    names = ~[Long(tail)];\n-                } else {\n-                    names =\n-                        ~[Long(tail_eq[0])];\n-                    i_arg = Some(tail_eq[1]);\n-                }\n+pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n+    unsafe {\n+        let n_opts = opts.len();\n+        fn f(_x: uint) -> ~[Optval] { return ~[]; }\n+        let vals = vec::cast_to_mut(vec::from_fn(n_opts, f));\n+        let mut free: ~[~str] = ~[];\n+        let l = args.len();\n+        let mut i = 0;\n+        while i < l {\n+            let cur = args[i];\n+            let curlen = cur.len();\n+            if !is_arg(cur) {\n+                free.push(cur);\n+            } else if cur == ~\"--\" {\n+                let mut j = i + 1;\n+                while j < l { free.push(args[j]); j += 1; }\n+                break;\n             } else {\n-                let mut j = 1;\n-                let mut last_valid_opt_id = None;\n-                names = ~[];\n-                while j < curlen {\n-                    let range = str::char_range_at(cur, j);\n-                    let opt = Short(range.ch);\n-\n-                    /* In a series of potential options (eg. -aheJ), if we see\n-                       one which takes an argument, we assume all subsequent\n-                       characters make up the argument. This allows options\n-                       such as -L/usr/local/lib/foo to be interpreted\n-                       correctly\n-                    */\n-\n-                    match find_opt(opts, opt) {\n-                      Some(id) => last_valid_opt_id = Some(id),\n-                      None => {\n-                        let arg_follows =\n-                            last_valid_opt_id.is_some() &&\n-                            match opts[last_valid_opt_id.get()]\n-                              .hasarg {\n-\n-                              Yes | Maybe => true,\n-                              No => false\n-                            };\n-                        if arg_follows && j < curlen {\n-                            i_arg = Some(cur.slice(j, curlen));\n-                            break;\n-                        } else {\n-                            last_valid_opt_id = None;\n+                let mut names;\n+                let mut i_arg = None;\n+                if cur[1] == '-' as u8 {\n+                    let tail = str::slice(cur, 2, curlen);\n+                    let tail_eq = str::splitn_char(tail, '=', 1);\n+                    if tail_eq.len() <= 1 {\n+                        names = ~[Long(tail)];\n+                    } else {\n+                        names =\n+                            ~[Long(tail_eq[0])];\n+                        i_arg = Some(tail_eq[1]);\n+                    }\n+                } else {\n+                    let mut j = 1;\n+                    let mut last_valid_opt_id = None;\n+                    names = ~[];\n+                    while j < curlen {\n+                        let range = str::char_range_at(cur, j);\n+                        let opt = Short(range.ch);\n+\n+                        /* In a series of potential options (eg. -aheJ), if we\n+                           see one which takes an argument, we assume all\n+                           subsequent characters make up the argument. This\n+                           allows options such as -L/usr/local/lib/foo to be\n+                           interpreted correctly\n+                        */\n+\n+                        match find_opt(opts, opt) {\n+                          Some(id) => last_valid_opt_id = Some(id),\n+                          None => {\n+                            let arg_follows =\n+                                last_valid_opt_id.is_some() &&\n+                                match opts[last_valid_opt_id.get()]\n+                                  .hasarg {\n+\n+                                  Yes | Maybe => true,\n+                                  No => false\n+                                };\n+                            if arg_follows && j < curlen {\n+                                i_arg = Some(cur.slice(j, curlen));\n+                                break;\n+                            } else {\n+                                last_valid_opt_id = None;\n+                            }\n+                          }\n                         }\n-                      }\n+                        names.push(opt);\n+                        j = range.next;\n                     }\n-                    names.push(opt);\n-                    j = range.next;\n                 }\n-            }\n-            let mut name_pos = 0;\n-            for names.each() |nm| {\n-                name_pos += 1;\n-                let optid = match find_opt(opts, *nm) {\n-                  Some(id) => id,\n-                  None => return Err(UnrecognizedOption(name_str(nm)))\n-                };\n-                match opts[optid].hasarg {\n-                  No => {\n-                    if !i_arg.is_none() {\n-                        return Err(UnexpectedArgument(name_str(nm)));\n-                    }\n-                    vals[optid].push(Given);\n-                  }\n-                  Maybe => {\n-                    if !i_arg.is_none() {\n-                        vals[optid].push(Val(i_arg.get()));\n-                    } else if name_pos < names.len() ||\n-                                  i + 1 == l || is_arg(args[i + 1]) {\n+                let mut name_pos = 0;\n+                for names.each() |nm| {\n+                    name_pos += 1;\n+                    let optid = match find_opt(opts, *nm) {\n+                      Some(id) => id,\n+                      None => return Err(UnrecognizedOption(name_str(nm)))\n+                    };\n+                    match opts[optid].hasarg {\n+                      No => {\n+                        if !i_arg.is_none() {\n+                            return Err(UnexpectedArgument(name_str(nm)));\n+                        }\n                         vals[optid].push(Given);\n-                    } else { i += 1; vals[optid].push(Val(args[i])); }\n-                  }\n-                  Yes => {\n-                    if !i_arg.is_none() {\n-                        vals[optid].push(Val(i_arg.get()));\n-                    } else if i + 1 == l {\n-                        return Err(ArgumentMissing(name_str(nm)));\n-                    } else { i += 1; vals[optid].push(Val(args[i])); }\n-                  }\n+                      }\n+                      Maybe => {\n+                        if !i_arg.is_none() {\n+                            vals[optid].push(Val(i_arg.get()));\n+                        } else if name_pos < names.len() ||\n+                                      i + 1 == l || is_arg(args[i + 1]) {\n+                            vals[optid].push(Given);\n+                        } else { i += 1; vals[optid].push(Val(args[i])); }\n+                      }\n+                      Yes => {\n+                        if !i_arg.is_none() {\n+                            vals[optid].push(Val(i_arg.get()));\n+                        } else if i + 1 == l {\n+                            return Err(ArgumentMissing(name_str(nm)));\n+                        } else { i += 1; vals[optid].push(Val(args[i])); }\n+                      }\n+                    }\n                 }\n             }\n+            i += 1;\n         }\n-        i += 1;\n-    }\n-    i = 0u;\n-    while i < n_opts {\n-        let n = vals[i].len();\n-        let occ = opts[i].occur;\n-        if occ == Req {\n-            if n == 0 {\n-                return Err(OptionMissing(name_str(&(opts[i].name))));\n+        i = 0u;\n+        while i < n_opts {\n+            let n = vals[i].len();\n+            let occ = opts[i].occur;\n+            if occ == Req {\n+                if n == 0 {\n+                    return Err(OptionMissing(name_str(&(opts[i].name))));\n+                }\n             }\n-        }\n-        if occ != Multi {\n-            if n > 1 {\n-                return Err(OptionDuplicated(name_str(&(opts[i].name))));\n+            if occ != Multi {\n+                if n > 1 {\n+                    return Err(OptionDuplicated(name_str(&(opts[i].name))));\n+                }\n             }\n+            i += 1;\n         }\n-        i += 1;\n+        return Ok(Matches {opts: vec::from_slice(opts),\n+                   vals: vec::cast_from_mut(move vals),\n+                   free: free});\n     }\n-    return Ok(Matches {opts: vec::from_slice(opts),\n-               vals: vec::cast_from_mut(move vals),\n-               free: free});\n }\n \n fn opt_vals(mm: &Matches, nm: &str) -> ~[Optval] {"}, {"sha": "be7a9dcc6dc0a4a4fda4ae931c4849243954da98", "filename": "src/libstd/json.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -337,9 +337,11 @@ pub fn to_writer(wr: io::Writer, json: &Json) {\n }\n \n /// Encodes a json value into a string\n-pub pure fn to_str(json: &Json) -> ~str unsafe {\n-    // ugh, should be safe\n-    io::with_str_writer(|wr| to_writer(wr, json))\n+pub pure fn to_str(json: &Json) -> ~str {\n+    unsafe {\n+        // ugh, should be safe\n+        io::with_str_writer(|wr| to_writer(wr, json))\n+    }\n }\n \n /// Encodes a json value into a io::writer"}, {"sha": "0b4c45da28ebfb4fe9f6f10aeabbcb8e6e82abfd", "filename": "src/libstd/map.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -435,9 +435,11 @@ pub mod chained {\n     }\n \n     impl<K:Eq IterBytes Hash Copy ToStr, V: ToStr Copy> T<K, V>: ToStr {\n-        pure fn to_str() -> ~str unsafe {\n-            // Meh -- this should be safe\n-            do io::with_str_writer |wr| { self.to_writer(wr) }\n+        pure fn to_str() -> ~str {\n+            unsafe {\n+                // Meh -- this should be safe\n+                do io::with_str_writer |wr| { self.to_writer(wr) }\n+            }\n         }\n     }\n "}, {"sha": "d273138ed3db5f458c4ab0e52321e63f6c0c0d4d", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 79, "deletions": 73, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -117,32 +117,36 @@ enum IpGetAddrErr {\n pub fn get_addr(node: &str, iotask: iotask)\n         -> result::Result<~[IpAddr], IpGetAddrErr> {\n     do oldcomm::listen |output_ch| {\n-        do str::as_buf(node) |node_ptr, len| unsafe {\n-            log(debug, fmt!(\"slice len %?\", len));\n-            let handle = create_uv_getaddrinfo_t();\n-            let handle_ptr = ptr::addr_of(&handle);\n-            let handle_data: GetAddrData = {\n-                output_ch: output_ch\n-            };\n-            let handle_data_ptr = ptr::addr_of(&handle_data);\n-            do interact(iotask) |loop_ptr| unsafe {\n-                let result = uv_getaddrinfo(\n-                    loop_ptr,\n-                    handle_ptr,\n-                    get_addr_cb,\n-                    node_ptr,\n-                    ptr::null(),\n-                    ptr::null());\n-                match result {\n-                  0i32 => {\n-                    set_data_for_req(handle_ptr, handle_data_ptr);\n-                  }\n-                  _ => {\n-                    output_ch.send(result::Err(GetAddrUnknownError));\n-                  }\n-                }\n-            };\n-            output_ch.recv()\n+        do str::as_buf(node) |node_ptr, len| {\n+            unsafe {\n+                log(debug, fmt!(\"slice len %?\", len));\n+                let handle = create_uv_getaddrinfo_t();\n+                let handle_ptr = ptr::addr_of(&handle);\n+                let handle_data: GetAddrData = {\n+                    output_ch: output_ch\n+                };\n+                let handle_data_ptr = ptr::addr_of(&handle_data);\n+                do interact(iotask) |loop_ptr| {\n+                    unsafe {\n+                        let result = uv_getaddrinfo(\n+                            loop_ptr,\n+                            handle_ptr,\n+                            get_addr_cb,\n+                            node_ptr,\n+                            ptr::null(),\n+                            ptr::null());\n+                        match result {\n+                          0i32 => {\n+                            set_data_for_req(handle_ptr, handle_data_ptr);\n+                          }\n+                          _ => {\n+                            output_ch.send(result::Err(GetAddrUnknownError));\n+                          }\n+                        }\n+                    }\n+                };\n+                output_ch.recv()\n+            }\n         }\n     }\n }\n@@ -300,62 +304,64 @@ type GetAddrData = {\n };\n \n extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n-                      res: *addrinfo) unsafe {\n-    log(debug, ~\"in get_addr_cb\");\n-    let handle_data = get_data_for_req(handle) as\n-        *GetAddrData;\n-    if status == 0i32 {\n-        if res != (ptr::null::<addrinfo>()) {\n-            let mut out_vec = ~[];\n-            log(debug, fmt!(\"initial addrinfo: %?\", res));\n-            let mut curr_addr = res;\n-            loop {\n-                let new_ip_addr = if ll::is_ipv4_addrinfo(curr_addr) {\n-                    Ipv4(copy((\n-                        *ll::addrinfo_as_sockaddr_in(curr_addr))))\n-                }\n-                else if ll::is_ipv6_addrinfo(curr_addr) {\n-                    Ipv6(copy((\n-                        *ll::addrinfo_as_sockaddr_in6(curr_addr))))\n-                }\n-                else {\n-                    log(debug, ~\"curr_addr is not of family AF_INET or \"+\n-                        ~\"AF_INET6. Error.\");\n-                    (*handle_data).output_ch.send(\n-                        result::Err(GetAddrUnknownError));\n-                    break;\n-                };\n-                out_vec.push(move new_ip_addr);\n+                      res: *addrinfo) {\n+    unsafe {\n+        log(debug, ~\"in get_addr_cb\");\n+        let handle_data = get_data_for_req(handle) as\n+            *GetAddrData;\n+        if status == 0i32 {\n+            if res != (ptr::null::<addrinfo>()) {\n+                let mut out_vec = ~[];\n+                log(debug, fmt!(\"initial addrinfo: %?\", res));\n+                let mut curr_addr = res;\n+                loop {\n+                    let new_ip_addr = if ll::is_ipv4_addrinfo(curr_addr) {\n+                        Ipv4(copy((\n+                            *ll::addrinfo_as_sockaddr_in(curr_addr))))\n+                    }\n+                    else if ll::is_ipv6_addrinfo(curr_addr) {\n+                        Ipv6(copy((\n+                            *ll::addrinfo_as_sockaddr_in6(curr_addr))))\n+                    }\n+                    else {\n+                        log(debug, ~\"curr_addr is not of family AF_INET or \"+\n+                            ~\"AF_INET6. Error.\");\n+                        (*handle_data).output_ch.send(\n+                            result::Err(GetAddrUnknownError));\n+                        break;\n+                    };\n+                    out_vec.push(move new_ip_addr);\n \n-                let next_addr = ll::get_next_addrinfo(curr_addr);\n-                if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n-                    log(debug, ~\"null next_addr encountered. no mas\");\n-                    break;\n-                }\n-                else {\n-                    curr_addr = next_addr;\n-                    log(debug, fmt!(\"next_addr addrinfo: %?\", curr_addr));\n+                    let next_addr = ll::get_next_addrinfo(curr_addr);\n+                    if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n+                        log(debug, ~\"null next_addr encountered. no mas\");\n+                        break;\n+                    }\n+                    else {\n+                        curr_addr = next_addr;\n+                        log(debug, fmt!(\"next_addr addrinfo: %?\", curr_addr));\n+                    }\n                 }\n+                log(debug, fmt!(\"successful process addrinfo result, len: %?\",\n+                                vec::len(out_vec)));\n+                (*handle_data).output_ch.send(result::Ok(move out_vec));\n+            }\n+            else {\n+                log(debug, ~\"addrinfo pointer is NULL\");\n+                (*handle_data).output_ch.send(\n+                    result::Err(GetAddrUnknownError));\n             }\n-            log(debug, fmt!(\"successful process addrinfo result, len: %?\",\n-                            vec::len(out_vec)));\n-            (*handle_data).output_ch.send(result::Ok(move out_vec));\n         }\n         else {\n-            log(debug, ~\"addrinfo pointer is NULL\");\n+            log(debug, ~\"status != 0 error in get_addr_cb\");\n             (*handle_data).output_ch.send(\n                 result::Err(GetAddrUnknownError));\n         }\n+        if res != (ptr::null::<addrinfo>()) {\n+            uv_freeaddrinfo(res);\n+        }\n+        log(debug, ~\"leaving get_addr_cb\");\n     }\n-    else {\n-        log(debug, ~\"status != 0 error in get_addr_cb\");\n-        (*handle_data).output_ch.send(\n-            result::Err(GetAddrUnknownError));\n-    }\n-    if res != (ptr::null::<addrinfo>()) {\n-        uv_freeaddrinfo(res);\n-    }\n-    log(debug, ~\"leaving get_addr_cb\");\n }\n \n #[cfg(test)]"}, {"sha": "aeb0c2cb6130d8c546aec34767eb45cd37cb0978", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 681, "deletions": 579, "changes": 1260, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -143,124 +143,129 @@ pub enum TcpConnectErrData {\n  */\n pub fn connect(input_ip: ip::IpAddr, port: uint,\n            iotask: IoTask)\n-    -> result::Result<TcpSocket, TcpConnectErrData> unsafe {\n-    let result_po = oldcomm::Port::<ConnAttempt>();\n-    let closed_signal_po = oldcomm::Port::<()>();\n-    let conn_data = {\n-        result_ch: oldcomm::Chan(&result_po),\n-        closed_signal_ch: oldcomm::Chan(&closed_signal_po)\n-    };\n-    let conn_data_ptr = ptr::addr_of(&conn_data);\n-    let reader_po = oldcomm::Port::<result::Result<~[u8], TcpErrData>>();\n-    let stream_handle_ptr = malloc_uv_tcp_t();\n-    *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n-    let socket_data = @{\n-        reader_po: reader_po,\n-        reader_ch: oldcomm::Chan(&reader_po),\n-        stream_handle_ptr: stream_handle_ptr,\n-        connect_req: uv::ll::connect_t(),\n-        write_req: uv::ll::write_t(),\n-        ipv6: match input_ip {\n-            ip::Ipv4(_) => { false }\n-            ip::Ipv6(_) => { true }\n-        },\n-        iotask: iotask\n-    };\n-    let socket_data_ptr = ptr::addr_of(&(*socket_data));\n-    log(debug, fmt!(\"tcp_connect result_ch %?\", conn_data.result_ch));\n-    // get an unsafe representation of our stream_handle_ptr that\n-    // we can send into the interact cb to be handled in libuv..\n-    log(debug, fmt!(\"stream_handle_ptr outside interact %?\",\n-        stream_handle_ptr));\n-    do iotask::interact(iotask) |move input_ip, loop_ptr| unsafe {\n-        log(debug, ~\"in interact cb for tcp client connect..\");\n-        log(debug, fmt!(\"stream_handle_ptr in interact %?\",\n+    -> result::Result<TcpSocket, TcpConnectErrData> {\n+    unsafe {\n+        let result_po = oldcomm::Port::<ConnAttempt>();\n+        let closed_signal_po = oldcomm::Port::<()>();\n+        let conn_data = {\n+            result_ch: oldcomm::Chan(&result_po),\n+            closed_signal_ch: oldcomm::Chan(&closed_signal_po)\n+        };\n+        let conn_data_ptr = ptr::addr_of(&conn_data);\n+        let reader_po = oldcomm::Port::<result::Result<~[u8], TcpErrData>>();\n+        let stream_handle_ptr = malloc_uv_tcp_t();\n+        *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n+        let socket_data = @{\n+            reader_po: reader_po,\n+            reader_ch: oldcomm::Chan(&reader_po),\n+            stream_handle_ptr: stream_handle_ptr,\n+            connect_req: uv::ll::connect_t(),\n+            write_req: uv::ll::write_t(),\n+            ipv6: match input_ip {\n+                ip::Ipv4(_) => { false }\n+                ip::Ipv6(_) => { true }\n+            },\n+            iotask: iotask\n+        };\n+        let socket_data_ptr = ptr::addr_of(&(*socket_data));\n+        log(debug, fmt!(\"tcp_connect result_ch %?\", conn_data.result_ch));\n+        // get an unsafe representation of our stream_handle_ptr that\n+        // we can send into the interact cb to be handled in libuv..\n+        log(debug, fmt!(\"stream_handle_ptr outside interact %?\",\n             stream_handle_ptr));\n-        match uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n-          0i32 => {\n-            log(debug, ~\"tcp_init successful\");\n-            log(debug, ~\"dealing w/ ipv4 connection..\");\n-            let connect_req_ptr =\n-                ptr::addr_of(&((*socket_data_ptr).connect_req));\n-            let addr_str = ip::format_addr(&input_ip);\n-            let connect_result = match input_ip {\n-              ip::Ipv4(ref addr) => {\n-                // have to \"recreate\" the sockaddr_in/6\n-                // since the ip_addr discards the port\n-                // info.. should probably add an additional\n-                // rust type that actually is closer to\n-                // what the libuv API expects (ip str + port num)\n-                log(debug, fmt!(\"addr: %?\", addr));\n-                let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n-                uv::ll::tcp_connect(\n-                    connect_req_ptr,\n-                    stream_handle_ptr,\n-                    ptr::addr_of(&in_addr),\n-                    tcp_connect_on_connect_cb)\n-              }\n-              ip::Ipv6(ref addr) => {\n-                log(debug, fmt!(\"addr: %?\", addr));\n-                let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n-                uv::ll::tcp_connect6(\n-                    connect_req_ptr,\n-                    stream_handle_ptr,\n-                    ptr::addr_of(&in_addr),\n-                    tcp_connect_on_connect_cb)\n-              }\n-            };\n-            match connect_result {\n-              0i32 => {\n-                log(debug, ~\"tcp_connect successful\");\n-                // reusable data that we'll have for the\n-                // duration..\n-                uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                           socket_data_ptr as\n-                                              *libc::c_void);\n-                // just so the connect_cb can send the\n-                // outcome..\n-                uv::ll::set_data_for_req(connect_req_ptr,\n-                                         conn_data_ptr);\n-                log(debug, ~\"leaving tcp_connect interact cb...\");\n-                // let tcp_connect_on_connect_cb send on\n-                // the result_ch, now..\n-              }\n-              _ => {\n-                // immediate connect failure.. probably a garbage\n-                // ip or somesuch\n-                let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                oldcomm::send((*conn_data_ptr).result_ch,\n-                           ConnFailure(err_data.to_tcp_err()));\n-                uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                               conn_data_ptr);\n-                uv::ll::close(stream_handle_ptr, stream_error_close_cb);\n-              }\n+        do iotask::interact(iotask) |move input_ip, loop_ptr| {\n+            unsafe {\n+                log(debug, ~\"in interact cb for tcp client connect..\");\n+                log(debug, fmt!(\"stream_handle_ptr in interact %?\",\n+                    stream_handle_ptr));\n+                match uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n+                  0i32 => {\n+                    log(debug, ~\"tcp_init successful\");\n+                    log(debug, ~\"dealing w/ ipv4 connection..\");\n+                    let connect_req_ptr =\n+                        ptr::addr_of(&((*socket_data_ptr).connect_req));\n+                    let addr_str = ip::format_addr(&input_ip);\n+                    let connect_result = match input_ip {\n+                      ip::Ipv4(ref addr) => {\n+                        // have to \"recreate\" the sockaddr_in/6\n+                        // since the ip_addr discards the port\n+                        // info.. should probably add an additional\n+                        // rust type that actually is closer to\n+                        // what the libuv API expects (ip str + port num)\n+                        log(debug, fmt!(\"addr: %?\", addr));\n+                        let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n+                        uv::ll::tcp_connect(\n+                            connect_req_ptr,\n+                            stream_handle_ptr,\n+                            ptr::addr_of(&in_addr),\n+                            tcp_connect_on_connect_cb)\n+                      }\n+                      ip::Ipv6(ref addr) => {\n+                        log(debug, fmt!(\"addr: %?\", addr));\n+                        let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n+                        uv::ll::tcp_connect6(\n+                            connect_req_ptr,\n+                            stream_handle_ptr,\n+                            ptr::addr_of(&in_addr),\n+                            tcp_connect_on_connect_cb)\n+                      }\n+                    };\n+                    match connect_result {\n+                      0i32 => {\n+                        log(debug, ~\"tcp_connect successful\");\n+                        // reusable data that we'll have for the\n+                        // duration..\n+                        uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n+                                                   socket_data_ptr as\n+                                                      *libc::c_void);\n+                        // just so the connect_cb can send the\n+                        // outcome..\n+                        uv::ll::set_data_for_req(connect_req_ptr,\n+                                                 conn_data_ptr);\n+                        log(debug, ~\"leaving tcp_connect interact cb...\");\n+                        // let tcp_connect_on_connect_cb send on\n+                        // the result_ch, now..\n+                      }\n+                      _ => {\n+                        // immediate connect failure.. probably a garbage\n+                        // ip or somesuch\n+                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                        oldcomm::send((*conn_data_ptr).result_ch,\n+                                   ConnFailure(err_data.to_tcp_err()));\n+                        uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n+                                                       conn_data_ptr);\n+                        uv::ll::close(stream_handle_ptr,\n+                                      stream_error_close_cb);\n+                      }\n+                    }\n+                  }\n+                  _ => {\n+                    // failure to create a tcp handle\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    oldcomm::send((*conn_data_ptr).result_ch,\n+                               ConnFailure(err_data.to_tcp_err()));\n+                  }\n+                }\n             }\n-        }\n-          _ => {\n-            // failure to create a tcp handle\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            oldcomm::send((*conn_data_ptr).result_ch,\n-                       ConnFailure(err_data.to_tcp_err()));\n+        };\n+        match oldcomm::recv(result_po) {\n+          ConnSuccess => {\n+            log(debug, ~\"tcp::connect - received success on result_po\");\n+            result::Ok(TcpSocket(socket_data))\n+          }\n+          ConnFailure(ref err_data) => {\n+            oldcomm::recv(closed_signal_po);\n+            log(debug, ~\"tcp::connect - received failure on result_po\");\n+            // still have to free the malloc'd stream handle..\n+            rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n+                                               as *libc::c_void);\n+            let tcp_conn_err = match err_data.err_name {\n+              ~\"ECONNREFUSED\" => ConnectionRefused,\n+              _ => GenericConnectErr(err_data.err_name, err_data.err_msg)\n+            };\n+            result::Err(tcp_conn_err)\n           }\n         }\n-    };\n-    match oldcomm::recv(result_po) {\n-      ConnSuccess => {\n-        log(debug, ~\"tcp::connect - received success on result_po\");\n-        result::Ok(TcpSocket(socket_data))\n-      }\n-      ConnFailure(ref err_data) => {\n-        oldcomm::recv(closed_signal_po);\n-        log(debug, ~\"tcp::connect - received failure on result_po\");\n-        // still have to free the malloc'd stream handle..\n-        rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n-                                           as *libc::c_void);\n-        let tcp_conn_err = match err_data.err_name {\n-          ~\"ECONNREFUSED\" => ConnectionRefused,\n-          _ => GenericConnectErr(err_data.err_name, err_data.err_msg)\n-        };\n-        result::Err(tcp_conn_err)\n-      }\n     }\n }\n \n@@ -279,9 +284,11 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n  * `tcp_err_data` value as the `err` variant\n  */\n pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n-    -> result::Result<(), TcpErrData> unsafe {\n-    let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n-    write_common_impl(socket_data_ptr, raw_write_data)\n+    -> result::Result<(), TcpErrData> {\n+    unsafe {\n+        let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n+        write_common_impl(socket_data_ptr, raw_write_data)\n+    }\n }\n \n /**\n@@ -316,11 +323,13 @@ pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n  * value as the `err` variant\n  */\n pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n-    -> future::Future<result::Result<(), TcpErrData>> unsafe {\n-    let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n-    do future_spawn {\n-        let data_copy = copy(raw_write_data);\n-        write_common_impl(socket_data_ptr, data_copy)\n+    -> future::Future<result::Result<(), TcpErrData>> {\n+    unsafe {\n+        let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n+        do future_spawn {\n+            let data_copy = copy(raw_write_data);\n+            write_common_impl(socket_data_ptr, data_copy)\n+        }\n     }\n }\n \n@@ -341,9 +350,11 @@ pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n  */\n pub fn read_start(sock: &TcpSocket)\n     -> result::Result<oldcomm::Port<\n-        result::Result<~[u8], TcpErrData>>, TcpErrData> unsafe {\n-    let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n-    read_start_common_impl(socket_data)\n+        result::Result<~[u8], TcpErrData>>, TcpErrData> {\n+    unsafe {\n+        let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n+        read_start_common_impl(socket_data)\n+    }\n }\n \n /**\n@@ -355,10 +366,13 @@ pub fn read_start(sock: &TcpSocket)\n  */\n pub fn read_stop(sock: &TcpSocket,\n              read_port: oldcomm::Port<result::Result<~[u8], TcpErrData>>) ->\n-    result::Result<(), TcpErrData> unsafe {\n-    log(debug, fmt!(\"taking the read_port out of commission %?\", read_port));\n-    let socket_data = ptr::addr_of(&(*sock.socket_data));\n-    read_stop_common_impl(socket_data)\n+    result::Result<(), TcpErrData> {\n+    unsafe {\n+        log(debug,\n+            fmt!(\"taking the read_port out of commission %?\", read_port));\n+        let socket_data = ptr::addr_of(&(*sock.socket_data));\n+        read_stop_common_impl(socket_data)\n+    }\n }\n \n /**\n@@ -489,73 +503,74 @@ fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n  * as the `err` variant of a `result`.\n  */\n pub fn accept(new_conn: TcpNewConnection)\n-    -> result::Result<TcpSocket, TcpErrData> unsafe {\n-\n-    match new_conn{\n-      NewTcpConn(server_handle_ptr) => {\n-        let server_data_ptr = uv::ll::get_data_for_uv_handle(\n-            server_handle_ptr) as *TcpListenFcData;\n-        let reader_po = oldcomm::Port();\n-        let iotask = (*server_data_ptr).iotask;\n-        let stream_handle_ptr = malloc_uv_tcp_t();\n-        *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n-        let client_socket_data = @{\n-            reader_po: reader_po,\n-            reader_ch: oldcomm::Chan(&reader_po),\n-            stream_handle_ptr : stream_handle_ptr,\n-            connect_req : uv::ll::connect_t(),\n-            write_req : uv::ll::write_t(),\n-            ipv6: (*server_data_ptr).ipv6,\n-            iotask : iotask\n-        };\n-        let client_socket_data_ptr = ptr::addr_of(&(*client_socket_data));\n-        let client_stream_handle_ptr =\n-            (*client_socket_data_ptr).stream_handle_ptr;\n-\n-        let result_po = oldcomm::Port::<Option<TcpErrData>>();\n-        let result_ch = oldcomm::Chan(&result_po);\n-\n-        // UNSAFE LIBUV INTERACTION BEGIN\n-        // .. normally this happens within the context of\n-        // a call to uv::hl::interact.. but we're breaking\n-        // the rules here because this always has to be\n-        // called within the context of a listen() new_connect_cb\n-        // callback (or it will likely fail and drown your cat)\n-        log(debug, ~\"in interact cb for tcp::accept\");\n-        let loop_ptr = uv::ll::get_loop_for_uv_handle(\n-            server_handle_ptr);\n-        match uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n-          0i32 => {\n-            log(debug, ~\"uv_tcp_init successful for client stream\");\n-            match uv::ll::accept(\n-                server_handle_ptr as *libc::c_void,\n-                client_stream_handle_ptr as *libc::c_void) {\n+    -> result::Result<TcpSocket, TcpErrData> {\n+    unsafe {\n+        match new_conn {\n+          NewTcpConn(server_handle_ptr) => {\n+            let server_data_ptr = uv::ll::get_data_for_uv_handle(\n+                server_handle_ptr) as *TcpListenFcData;\n+            let reader_po = oldcomm::Port();\n+            let iotask = (*server_data_ptr).iotask;\n+            let stream_handle_ptr = malloc_uv_tcp_t();\n+            *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n+            let client_socket_data = @{\n+                reader_po: reader_po,\n+                reader_ch: oldcomm::Chan(&reader_po),\n+                stream_handle_ptr : stream_handle_ptr,\n+                connect_req : uv::ll::connect_t(),\n+                write_req : uv::ll::write_t(),\n+                ipv6: (*server_data_ptr).ipv6,\n+                iotask : iotask\n+            };\n+            let client_socket_data_ptr = ptr::addr_of(&(*client_socket_data));\n+            let client_stream_handle_ptr =\n+                (*client_socket_data_ptr).stream_handle_ptr;\n+\n+            let result_po = oldcomm::Port::<Option<TcpErrData>>();\n+            let result_ch = oldcomm::Chan(&result_po);\n+\n+            // UNSAFE LIBUV INTERACTION BEGIN\n+            // .. normally this happens within the context of\n+            // a call to uv::hl::interact.. but we're breaking\n+            // the rules here because this always has to be\n+            // called within the context of a listen() new_connect_cb\n+            // callback (or it will likely fail and drown your cat)\n+            log(debug, ~\"in interact cb for tcp::accept\");\n+            let loop_ptr = uv::ll::get_loop_for_uv_handle(\n+                server_handle_ptr);\n+            match uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n               0i32 => {\n-                log(debug, ~\"successfully accepted client connection\");\n-                uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n-                                               client_socket_data_ptr\n-                                                   as *libc::c_void);\n-                oldcomm::send(result_ch, None);\n+                log(debug, ~\"uv_tcp_init successful for client stream\");\n+                match uv::ll::accept(\n+                    server_handle_ptr as *libc::c_void,\n+                    client_stream_handle_ptr as *libc::c_void) {\n+                  0i32 => {\n+                    log(debug, ~\"successfully accepted client connection\");\n+                    uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n+                                                   client_socket_data_ptr\n+                                                       as *libc::c_void);\n+                    oldcomm::send(result_ch, None);\n+                  }\n+                  _ => {\n+                    log(debug, ~\"failed to accept client conn\");\n+                    oldcomm::send(result_ch, Some(\n+                        uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n+                  }\n+                }\n               }\n               _ => {\n-                log(debug, ~\"failed to accept client conn\");\n+                log(debug, ~\"failed to init client stream\");\n                 oldcomm::send(result_ch, Some(\n                     uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n               }\n             }\n-          }\n-          _ => {\n-            log(debug, ~\"failed to init client stream\");\n-            oldcomm::send(result_ch, Some(\n-                uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n+            // UNSAFE LIBUV INTERACTION END\n+            match oldcomm::recv(result_po) {\n+              Some(copy err_data) => result::Err(err_data),\n+              None => result::Ok(TcpSocket(client_socket_data))\n+            }\n           }\n         }\n-        // UNSAFE LIBUV INTERACTION END\n-        match oldcomm::recv(result_po) {\n-          Some(copy err_data) => result::Err(err_data),\n-          None => result::Ok(TcpSocket(client_socket_data))\n-        }\n-      }\n     }\n }\n \n@@ -592,146 +607,165 @@ pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n           new_connect_cb: fn~(TcpNewConnection,\n                                oldcomm::Chan<Option<TcpErrData>>))\n-    -> result::Result<(), TcpListenErrData> unsafe {\n-    do listen_common(move host_ip, port, backlog, iotask,\n-                     move on_establish_cb)\n-        // on_connect_cb\n-        |move new_connect_cb, handle| unsafe {\n-            let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n-                as *TcpListenFcData;\n-            let new_conn = NewTcpConn(handle);\n-            let kill_ch = (*server_data_ptr).kill_ch;\n-            new_connect_cb(new_conn, kill_ch);\n+    -> result::Result<(), TcpListenErrData> {\n+    unsafe {\n+        do listen_common(move host_ip, port, backlog, iotask,\n+                         move on_establish_cb)\n+            // on_connect_cb\n+            |move new_connect_cb, handle| {\n+                unsafe {\n+                    let server_data_ptr =\n+                        uv::ll::get_data_for_uv_handle(handle)\n+                        as *TcpListenFcData;\n+                    let new_conn = NewTcpConn(handle);\n+                    let kill_ch = (*server_data_ptr).kill_ch;\n+                    new_connect_cb(new_conn, kill_ch);\n+                }\n+            }\n     }\n }\n \n fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n           on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n           on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n-    -> result::Result<(), TcpListenErrData> unsafe {\n-    let stream_closed_po = oldcomm::Port::<()>();\n-    let kill_po = oldcomm::Port::<Option<TcpErrData>>();\n-    let kill_ch = oldcomm::Chan(&kill_po);\n-    let server_stream = uv::ll::tcp_t();\n-    let server_stream_ptr = ptr::addr_of(&server_stream);\n-    let server_data = {\n-        server_stream_ptr: server_stream_ptr,\n-        stream_closed_ch: oldcomm::Chan(&stream_closed_po),\n-        kill_ch: kill_ch,\n-        on_connect_cb: move on_connect_cb,\n-        iotask: iotask,\n-        ipv6: match &host_ip {\n-            &ip::Ipv4(_) => { false }\n-            &ip::Ipv6(_) => { true }\n-        },\n-        mut active: true\n-    };\n-    let server_data_ptr = ptr::addr_of(&server_data);\n-\n-    let setup_result = do oldcomm::listen |setup_ch| {\n-        // this is to address a compiler warning about\n-        // an implicit copy.. it seems that double nested\n-        // will defeat a move sigil, as is done to the host_ip\n-        // arg above.. this same pattern works w/o complaint in\n-        // tcp::connect (because the iotask::interact cb isn't\n-        // nested within a core::comm::listen block)\n-        let loc_ip = copy(host_ip);\n-        do iotask::interact(iotask) |move loc_ip, loop_ptr| unsafe {\n-            match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n-              0i32 => {\n-                uv::ll::set_data_for_uv_handle(\n-                    server_stream_ptr,\n-                    server_data_ptr);\n-                let addr_str = ip::format_addr(&loc_ip);\n-                let bind_result = match loc_ip {\n-                  ip::Ipv4(ref addr) => {\n-                    log(debug, fmt!(\"addr: %?\", addr));\n-                    let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n-                    uv::ll::tcp_bind(server_stream_ptr,\n-                                     ptr::addr_of(&in_addr))\n-                  }\n-                  ip::Ipv6(ref addr) => {\n-                    log(debug, fmt!(\"addr: %?\", addr));\n-                    let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n-                    uv::ll::tcp_bind6(server_stream_ptr,\n-                                     ptr::addr_of(&in_addr))\n-                  }\n-                };\n-                match bind_result {\n-                  0i32 => {\n-                    match uv::ll::listen(server_stream_ptr,\n-                                       backlog as libc::c_int,\n-                                       tcp_lfc_on_connection_cb) {\n-                      0i32 => oldcomm::send(setup_ch, None),\n+    -> result::Result<(), TcpListenErrData> {\n+    unsafe {\n+        let stream_closed_po = oldcomm::Port::<()>();\n+        let kill_po = oldcomm::Port::<Option<TcpErrData>>();\n+        let kill_ch = oldcomm::Chan(&kill_po);\n+        let server_stream = uv::ll::tcp_t();\n+        let server_stream_ptr = ptr::addr_of(&server_stream);\n+        let server_data = {\n+            server_stream_ptr: server_stream_ptr,\n+            stream_closed_ch: oldcomm::Chan(&stream_closed_po),\n+            kill_ch: kill_ch,\n+            on_connect_cb: move on_connect_cb,\n+            iotask: iotask,\n+            ipv6: match &host_ip {\n+                &ip::Ipv4(_) => { false }\n+                &ip::Ipv6(_) => { true }\n+            },\n+            mut active: true\n+        };\n+        let server_data_ptr = ptr::addr_of(&server_data);\n+\n+        let setup_result = do oldcomm::listen |setup_ch| {\n+            // this is to address a compiler warning about\n+            // an implicit copy.. it seems that double nested\n+            // will defeat a move sigil, as is done to the host_ip\n+            // arg above.. this same pattern works w/o complaint in\n+            // tcp::connect (because the iotask::interact cb isn't\n+            // nested within a core::comm::listen block)\n+            let loc_ip = copy(host_ip);\n+            do iotask::interact(iotask) |move loc_ip, loop_ptr| {\n+                unsafe {\n+                    match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n+                      0i32 => {\n+                        uv::ll::set_data_for_uv_handle(\n+                            server_stream_ptr,\n+                            server_data_ptr);\n+                        let addr_str = ip::format_addr(&loc_ip);\n+                        let bind_result = match loc_ip {\n+                          ip::Ipv4(ref addr) => {\n+                            log(debug, fmt!(\"addr: %?\", addr));\n+                            let in_addr = uv::ll::ip4_addr(addr_str,\n+                                                           port as int);\n+                            uv::ll::tcp_bind(server_stream_ptr,\n+                                             ptr::addr_of(&in_addr))\n+                          }\n+                          ip::Ipv6(ref addr) => {\n+                            log(debug, fmt!(\"addr: %?\", addr));\n+                            let in_addr = uv::ll::ip6_addr(addr_str,\n+                                                           port as int);\n+                            uv::ll::tcp_bind6(server_stream_ptr,\n+                                             ptr::addr_of(&in_addr))\n+                          }\n+                        };\n+                        match bind_result {\n+                          0i32 => {\n+                            match uv::ll::listen(server_stream_ptr,\n+                                               backlog as libc::c_int,\n+                                               tcp_lfc_on_connection_cb) {\n+                              0i32 => oldcomm::send(setup_ch, None),\n+                              _ => {\n+                                log(debug, ~\"failure to uv_listen()\");\n+                                let err_data = uv::ll::get_last_err_data(\n+                                    loop_ptr);\n+                                oldcomm::send(setup_ch, Some(err_data));\n+                              }\n+                            }\n+                          }\n+                          _ => {\n+                            log(debug, ~\"failure to uv_tcp_bind\");\n+                            let err_data = uv::ll::get_last_err_data(\n+                                loop_ptr);\n+                            oldcomm::send(setup_ch, Some(err_data));\n+                          }\n+                        }\n+                      }\n                       _ => {\n-                        log(debug, ~\"failure to uv_listen()\");\n+                        log(debug, ~\"failure to uv_tcp_init\");\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n                         oldcomm::send(setup_ch, Some(err_data));\n                       }\n                     }\n-                  }\n-                  _ => {\n-                    log(debug, ~\"failure to uv_tcp_bind\");\n-                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    oldcomm::send(setup_ch, Some(err_data));\n-                  }\n+                };\n+            }\n+            setup_ch.recv()\n+        };\n+        match setup_result {\n+          Some(ref err_data) => {\n+            do iotask::interact(iotask) |loop_ptr| {\n+                unsafe {\n+                    log(debug,\n+                        fmt!(\"tcp::listen post-kill recv hl interact %?\",\n+                             loop_ptr));\n+                    (*server_data_ptr).active = false;\n+                    uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n                 }\n+            };\n+            stream_closed_po.recv();\n+            match err_data.err_name {\n+              ~\"EACCES\" => {\n+                log(debug, ~\"Got EACCES error\");\n+                result::Err(AccessDenied)\n+              }\n+              ~\"EADDRINUSE\" => {\n+                log(debug, ~\"Got EADDRINUSE error\");\n+                result::Err(AddressInUse)\n               }\n               _ => {\n-                log(debug, ~\"failure to uv_tcp_init\");\n-                let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                oldcomm::send(setup_ch, Some(err_data));\n+                log(debug, fmt!(\"Got '%s' '%s' libuv error\",\n+                                err_data.err_name, err_data.err_msg));\n+                result::Err(\n+                    GenericListenErr(err_data.err_name, err_data.err_msg))\n               }\n             }\n-        };\n-        setup_ch.recv()\n-    };\n-    match setup_result {\n-      Some(ref err_data) => {\n-        do iotask::interact(iotask) |loop_ptr| unsafe {\n-            log(debug, fmt!(\"tcp::listen post-kill recv hl interact %?\",\n-                            loop_ptr));\n-            (*server_data_ptr).active = false;\n-            uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n-        };\n-        stream_closed_po.recv();\n-        match err_data.err_name {\n-          ~\"EACCES\" => {\n-            log(debug, ~\"Got EACCES error\");\n-            result::Err(AccessDenied)\n           }\n-          ~\"EADDRINUSE\" => {\n-            log(debug, ~\"Got EADDRINUSE error\");\n-            result::Err(AddressInUse)\n-          }\n-          _ => {\n-            log(debug, fmt!(\"Got '%s' '%s' libuv error\",\n-                            err_data.err_name, err_data.err_msg));\n-            result::Err(\n-                GenericListenErr(err_data.err_name, err_data.err_msg))\n+          None => {\n+            on_establish_cb(kill_ch);\n+            let kill_result = oldcomm::recv(kill_po);\n+            do iotask::interact(iotask) |loop_ptr| {\n+                unsafe {\n+                    log(debug,\n+                        fmt!(\"tcp::listen post-kill recv hl interact %?\",\n+                             loop_ptr));\n+                    (*server_data_ptr).active = false;\n+                    uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n+                }\n+            };\n+            stream_closed_po.recv();\n+            match kill_result {\n+              // some failure post bind/listen\n+              Some(ref err_data) => result::Err(GenericListenErr(\n+                  err_data.err_name,\n+                  err_data.err_msg)),\n+              // clean exit\n+              None => result::Ok(())\n+            }\n           }\n         }\n-      }\n-      None => {\n-        on_establish_cb(kill_ch);\n-        let kill_result = oldcomm::recv(kill_po);\n-        do iotask::interact(iotask) |loop_ptr| unsafe {\n-            log(debug, fmt!(\"tcp::listen post-kill recv hl interact %?\",\n-                            loop_ptr));\n-            (*server_data_ptr).active = false;\n-            uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n-        };\n-        stream_closed_po.recv();\n-        match kill_result {\n-          // some failure post bind/listen\n-          Some(ref err_data) => result::Err(GenericListenErr(\n-              err_data.err_name,\n-              err_data.err_msg)),\n-          // clean exit\n-          None => result::Ok(())\n-        }\n-      }\n     }\n }\n \n@@ -859,15 +893,20 @@ impl TcpSocketBuf: io::Reader {\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n impl TcpSocketBuf: io::Writer {\n-    pub fn write(&self, data: &[const u8]) unsafe {\n-        let socket_data_ptr =\n-            ptr::addr_of(&(*((*(self.data)).sock).socket_data));\n-        let w_result = write_common_impl(socket_data_ptr,\n-                                        vec::slice(data, 0, vec::len(data)));\n-        if w_result.is_err() {\n-            let err_data = w_result.get_err();\n-            log(debug, fmt!(\"ERROR sock_buf as io::writer.writer err: %? %?\",\n-                             err_data.err_name, err_data.err_msg));\n+    pub fn write(&self, data: &[const u8]) {\n+        unsafe {\n+            let socket_data_ptr =\n+                ptr::addr_of(&(*((*(self.data)).sock).socket_data));\n+            let w_result = write_common_impl(socket_data_ptr,\n+                                            vec::slice(data,\n+                                                       0,\n+                                                       vec::len(data)));\n+            if w_result.is_err() {\n+                let err_data = w_result.get_err();\n+                log(debug,\n+                    fmt!(\"ERROR sock_buf as io::writer.writer err: %? %?\",\n+                         err_data.err_name, err_data.err_msg));\n+            }\n         }\n     }\n     fn seek(&self, dist: int, seek: io::SeekStyle) {\n@@ -887,122 +926,140 @@ impl TcpSocketBuf: io::Writer {\n \n // INTERNAL API\n \n-fn tear_down_socket_data(socket_data: @TcpSocketData) unsafe {\n-    let closed_po = oldcomm::Port::<()>();\n-    let closed_ch = oldcomm::Chan(&closed_po);\n-    let close_data = {\n-        closed_ch: closed_ch\n-    };\n-    let close_data_ptr = ptr::addr_of(&close_data);\n-    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n-        log(debug, fmt!(\"interact dtor for tcp_socket stream %? loop %?\",\n-            stream_handle_ptr, loop_ptr));\n-        uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                       close_data_ptr);\n-        uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n-    };\n-    oldcomm::recv(closed_po);\n-    //the line below will most likely crash\n-    //log(debug, fmt!(\"about to free socket_data at %?\", socket_data));\n-    rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n-                                       as *libc::c_void);\n-    log(debug, ~\"exiting dtor for tcp_socket\");\n+fn tear_down_socket_data(socket_data: @TcpSocketData) {\n+    unsafe {\n+        let closed_po = oldcomm::Port::<()>();\n+        let closed_ch = oldcomm::Chan(&closed_po);\n+        let close_data = {\n+            closed_ch: closed_ch\n+        };\n+        let close_data_ptr = ptr::addr_of(&close_data);\n+        let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n+        do iotask::interact((*socket_data).iotask) |loop_ptr| {\n+            unsafe {\n+                log(debug,\n+                    fmt!(\"interact dtor for tcp_socket stream %? loop %?\",\n+                    stream_handle_ptr, loop_ptr));\n+                uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n+                                               close_data_ptr);\n+                uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n+            }\n+        };\n+        oldcomm::recv(closed_po);\n+        //the line below will most likely crash\n+        //log(debug, fmt!(\"about to free socket_data at %?\", socket_data));\n+        rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n+                                           as *libc::c_void);\n+        log(debug, ~\"exiting dtor for tcp_socket\");\n+    }\n }\n \n // shared implementation for tcp::read\n fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n-    -> result::Result<~[u8],TcpErrData> unsafe {\n-    use timer;\n-\n-    log(debug, ~\"starting tcp::read\");\n-    let iotask = (*socket_data).iotask;\n-    let rs_result = read_start_common_impl(socket_data);\n-    if result::is_err(&rs_result) {\n-        let err_data = result::get_err(&rs_result);\n-        result::Err(err_data)\n-    }\n-    else {\n-        log(debug, ~\"tcp::read before recv_timeout\");\n-        let read_result = if timeout_msecs > 0u {\n-            timer::recv_timeout(\n-               iotask, timeout_msecs, result::get(&rs_result))\n-        } else {\n-            Some(oldcomm::recv(result::get(&rs_result)))\n-        };\n-        log(debug, ~\"tcp::read after recv_timeout\");\n-        match move read_result {\n-          None => {\n-            log(debug, ~\"tcp::read: timed out..\");\n-            let err_data = {\n-                err_name: ~\"TIMEOUT\",\n-                err_msg: ~\"req timed out\"\n-            };\n-            read_stop_common_impl(socket_data);\n+    -> result::Result<~[u8],TcpErrData> {\n+    unsafe {\n+        use timer;\n+\n+        log(debug, ~\"starting tcp::read\");\n+        let iotask = (*socket_data).iotask;\n+        let rs_result = read_start_common_impl(socket_data);\n+        if result::is_err(&rs_result) {\n+            let err_data = result::get_err(&rs_result);\n             result::Err(err_data)\n-          }\n-          Some(move data_result) => {\n-            log(debug, ~\"tcp::read got data\");\n-            read_stop_common_impl(socket_data);\n-            data_result\n-          }\n+        }\n+        else {\n+            log(debug, ~\"tcp::read before recv_timeout\");\n+            let read_result = if timeout_msecs > 0u {\n+                timer::recv_timeout(\n+                   iotask, timeout_msecs, result::get(&rs_result))\n+            } else {\n+                Some(oldcomm::recv(result::get(&rs_result)))\n+            };\n+            log(debug, ~\"tcp::read after recv_timeout\");\n+            match move read_result {\n+              None => {\n+                log(debug, ~\"tcp::read: timed out..\");\n+                let err_data = {\n+                    err_name: ~\"TIMEOUT\",\n+                    err_msg: ~\"req timed out\"\n+                };\n+                read_stop_common_impl(socket_data);\n+                result::Err(err_data)\n+              }\n+              Some(move data_result) => {\n+                log(debug, ~\"tcp::read got data\");\n+                read_stop_common_impl(socket_data);\n+                data_result\n+              }\n+            }\n         }\n     }\n }\n \n // shared impl for read_stop\n fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n-    result::Result<(), TcpErrData> unsafe {\n-    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    let stop_po = oldcomm::Port::<Option<TcpErrData>>();\n-    let stop_ch = oldcomm::Chan(&stop_po);\n-    do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n-        log(debug, ~\"in interact cb for tcp::read_stop\");\n-        match uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n-          0i32 => {\n-            log(debug, ~\"successfully called uv_read_stop\");\n-            oldcomm::send(stop_ch, None);\n-          }\n-          _ => {\n-            log(debug, ~\"failure in calling uv_read_stop\");\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            oldcomm::send(stop_ch, Some(err_data.to_tcp_err()));\n-          }\n+    result::Result<(), TcpErrData> {\n+    unsafe {\n+        let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n+        let stop_po = oldcomm::Port::<Option<TcpErrData>>();\n+        let stop_ch = oldcomm::Chan(&stop_po);\n+        do iotask::interact((*socket_data).iotask) |loop_ptr| {\n+            unsafe {\n+                log(debug, ~\"in interact cb for tcp::read_stop\");\n+                match uv::ll::read_stop(stream_handle_ptr as\n+                                        *uv::ll::uv_stream_t) {\n+                  0i32 => {\n+                    log(debug, ~\"successfully called uv_read_stop\");\n+                    oldcomm::send(stop_ch, None);\n+                  }\n+                  _ => {\n+                    log(debug, ~\"failure in calling uv_read_stop\");\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    oldcomm::send(stop_ch, Some(err_data.to_tcp_err()));\n+                  }\n+                }\n+            }\n+        };\n+        match oldcomm::recv(stop_po) {\n+          Some(ref err_data) => result::Err(err_data.to_tcp_err()),\n+          None => result::Ok(())\n         }\n-    };\n-    match oldcomm::recv(stop_po) {\n-      Some(ref err_data) => result::Err(err_data.to_tcp_err()),\n-      None => result::Ok(())\n     }\n }\n \n // shared impl for read_start\n fn read_start_common_impl(socket_data: *TcpSocketData)\n     -> result::Result<oldcomm::Port<\n-        result::Result<~[u8], TcpErrData>>, TcpErrData> unsafe {\n-    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    let start_po = oldcomm::Port::<Option<uv::ll::uv_err_data>>();\n-    let start_ch = oldcomm::Chan(&start_po);\n-    log(debug, ~\"in tcp::read_start before interact loop\");\n-    do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n-        log(debug, fmt!(\"in tcp::read_start interact cb %?\", loop_ptr));\n-        match uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n-                               on_alloc_cb,\n-                               on_tcp_read_cb) {\n-          0i32 => {\n-            log(debug, ~\"success doing uv_read_start\");\n-            oldcomm::send(start_ch, None);\n-          }\n-          _ => {\n-            log(debug, ~\"error attempting uv_read_start\");\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            oldcomm::send(start_ch, Some(err_data));\n-          }\n+        result::Result<~[u8], TcpErrData>>, TcpErrData> {\n+    unsafe {\n+        let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n+        let start_po = oldcomm::Port::<Option<uv::ll::uv_err_data>>();\n+        let start_ch = oldcomm::Chan(&start_po);\n+        log(debug, ~\"in tcp::read_start before interact loop\");\n+        do iotask::interact((*socket_data).iotask) |loop_ptr| {\n+            unsafe {\n+                log(debug,\n+                    fmt!(\"in tcp::read_start interact cb %?\", loop_ptr));\n+                match uv::ll::read_start(stream_handle_ptr as\n+                                         *uv::ll::uv_stream_t,\n+                                         on_alloc_cb,\n+                                         on_tcp_read_cb) {\n+                  0i32 => {\n+                    log(debug, ~\"success doing uv_read_start\");\n+                    oldcomm::send(start_ch, None);\n+                  }\n+                  _ => {\n+                    log(debug, ~\"error attempting uv_read_start\");\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    oldcomm::send(start_ch, Some(err_data));\n+                  }\n+                }\n+            }\n+        };\n+        match oldcomm::recv(start_po) {\n+          Some(ref err_data) => result::Err(err_data.to_tcp_err()),\n+          None => result::Ok((*socket_data).reader_po)\n         }\n-    };\n-    match oldcomm::recv(start_po) {\n-      Some(ref err_data) => result::Err(err_data.to_tcp_err()),\n-      None => result::Ok((*socket_data).reader_po)\n     }\n }\n \n@@ -1011,44 +1068,49 @@ fn read_start_common_impl(socket_data: *TcpSocketData)\n // shared implementation used by write and write_future\n fn write_common_impl(socket_data_ptr: *TcpSocketData,\n                      raw_write_data: ~[u8])\n-    -> result::Result<(), TcpErrData> unsafe {\n-    let write_req_ptr = ptr::addr_of(&((*socket_data_ptr).write_req));\n-    let stream_handle_ptr =\n-        (*socket_data_ptr).stream_handle_ptr;\n-    let write_buf_vec =  ~[ uv::ll::buf_init(\n-        vec::raw::to_ptr(raw_write_data),\n-        vec::len(raw_write_data)) ];\n-    let write_buf_vec_ptr = ptr::addr_of(&write_buf_vec);\n-    let result_po = oldcomm::Port::<TcpWriteResult>();\n-    let write_data = {\n-        result_ch: oldcomm::Chan(&result_po)\n-    };\n-    let write_data_ptr = ptr::addr_of(&write_data);\n-    do iotask::interact((*socket_data_ptr).iotask) |loop_ptr| unsafe {\n-        log(debug, fmt!(\"in interact cb for tcp::write %?\", loop_ptr));\n-        match uv::ll::write(write_req_ptr,\n-                          stream_handle_ptr,\n-                          write_buf_vec_ptr,\n-                          tcp_write_complete_cb) {\n-          0i32 => {\n-            log(debug, ~\"uv_write() invoked successfully\");\n-            uv::ll::set_data_for_req(write_req_ptr, write_data_ptr);\n-          }\n-          _ => {\n-            log(debug, ~\"error invoking uv_write()\");\n-            let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            oldcomm::send((*write_data_ptr).result_ch,\n-                       TcpWriteError(err_data.to_tcp_err()));\n-          }\n+    -> result::Result<(), TcpErrData> {\n+    unsafe {\n+        let write_req_ptr = ptr::addr_of(&((*socket_data_ptr).write_req));\n+        let stream_handle_ptr =\n+            (*socket_data_ptr).stream_handle_ptr;\n+        let write_buf_vec =  ~[ uv::ll::buf_init(\n+            vec::raw::to_ptr(raw_write_data),\n+            vec::len(raw_write_data)) ];\n+        let write_buf_vec_ptr = ptr::addr_of(&write_buf_vec);\n+        let result_po = oldcomm::Port::<TcpWriteResult>();\n+        let write_data = {\n+            result_ch: oldcomm::Chan(&result_po)\n+        };\n+        let write_data_ptr = ptr::addr_of(&write_data);\n+        do iotask::interact((*socket_data_ptr).iotask) |loop_ptr| {\n+            unsafe {\n+                log(debug, fmt!(\"in interact cb for tcp::write %?\",\n+                                loop_ptr));\n+                match uv::ll::write(write_req_ptr,\n+                                  stream_handle_ptr,\n+                                  write_buf_vec_ptr,\n+                                  tcp_write_complete_cb) {\n+                  0i32 => {\n+                    log(debug, ~\"uv_write() invoked successfully\");\n+                    uv::ll::set_data_for_req(write_req_ptr, write_data_ptr);\n+                  }\n+                  _ => {\n+                    log(debug, ~\"error invoking uv_write()\");\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    oldcomm::send((*write_data_ptr).result_ch,\n+                               TcpWriteError(err_data.to_tcp_err()));\n+                  }\n+                }\n+            }\n+        };\n+        // FIXME (#2656): Instead of passing unsafe pointers to local data,\n+        // and waiting here for the write to complete, we should transfer\n+        // ownership of everything to the I/O task and let it deal with the\n+        // aftermath, so we don't have to sit here blocking.\n+        match oldcomm::recv(result_po) {\n+          TcpWriteSuccess => result::Ok(()),\n+          TcpWriteError(ref err_data) => result::Err(err_data.to_tcp_err())\n         }\n-    };\n-    // FIXME (#2656): Instead of passing unsafe pointers to local data,\n-    // and waiting here for the write to complete, we should transfer\n-    // ownership of everything to the I/O task and let it deal with the\n-    // aftermath, so we don't have to sit here blocking.\n-    match oldcomm::recv(result_po) {\n-      TcpWriteSuccess => result::Ok(()),\n-      TcpWriteError(ref err_data) => result::Err(err_data.to_tcp_err())\n     }\n }\n \n@@ -1066,34 +1128,40 @@ type TcpListenFcData = {\n     mut active: bool\n };\n \n-extern fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n-    let server_data_ptr = uv::ll::get_data_for_uv_handle(\n-        handle) as *TcpListenFcData;\n-    oldcomm::send((*server_data_ptr).stream_closed_ch, ());\n+extern fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) {\n+    unsafe {\n+        let server_data_ptr = uv::ll::get_data_for_uv_handle(\n+            handle) as *TcpListenFcData;\n+        oldcomm::send((*server_data_ptr).stream_closed_ch, ());\n+    }\n }\n \n extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n-                                     status: libc::c_int) unsafe {\n-    let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n-        as *TcpListenFcData;\n-    let kill_ch = (*server_data_ptr).kill_ch;\n-    if (*server_data_ptr).active {\n-        match status {\n-          0i32 => ((*server_data_ptr).on_connect_cb)(handle),\n-          _ => {\n-            let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n-            oldcomm::send(kill_ch,\n-                       Some(uv::ll::get_last_err_data(loop_ptr)\n-                            .to_tcp_err()));\n-            (*server_data_ptr).active = false;\n-          }\n+                                     status: libc::c_int) {\n+    unsafe {\n+        let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n+            as *TcpListenFcData;\n+        let kill_ch = (*server_data_ptr).kill_ch;\n+        if (*server_data_ptr).active {\n+            match status {\n+              0i32 => ((*server_data_ptr).on_connect_cb)(handle),\n+              _ => {\n+                let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n+                oldcomm::send(kill_ch,\n+                           Some(uv::ll::get_last_err_data(loop_ptr)\n+                                .to_tcp_err()));\n+                (*server_data_ptr).active = false;\n+              }\n+            }\n         }\n     }\n }\n \n-fn malloc_uv_tcp_t() -> *uv::ll::uv_tcp_t unsafe {\n-    rustrt::rust_uv_current_kernel_malloc(\n-        rustrt::rust_uv_helper_uv_tcp_t_size()) as *uv::ll::uv_tcp_t\n+fn malloc_uv_tcp_t() -> *uv::ll::uv_tcp_t {\n+    unsafe {\n+        rustrt::rust_uv_current_kernel_malloc(\n+            rustrt::rust_uv_helper_uv_tcp_t_size()) as *uv::ll::uv_tcp_t\n+    }\n }\n \n enum TcpConnectResult {\n@@ -1129,76 +1197,84 @@ impl uv::ll::uv_err_data: ToTcpErr {\n \n extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n                     nread: libc::ssize_t,\n-                    ++buf: uv::ll::uv_buf_t) unsafe {\n-    log(debug, fmt!(\"entering on_tcp_read_cb stream: %? nread: %?\",\n-                    stream, nread));\n-    let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n-    let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n-        as *TcpSocketData;\n-    match nread as int {\n-      // incoming err.. probably eof\n-      -1 => {\n-        let err_data = uv::ll::get_last_err_data(loop_ptr).to_tcp_err();\n-        log(debug, fmt!(\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n-                        err_data.err_name, err_data.err_msg));\n-        let reader_ch = (*socket_data_ptr).reader_ch;\n-        oldcomm::send(reader_ch, result::Err(err_data));\n-      }\n-      // do nothing .. unneeded buf\n-      0 => (),\n-      // have data\n-      _ => {\n-        // we have data\n-        log(debug, fmt!(\"tcp on_read_cb nread: %d\", nread as int));\n-        let reader_ch = (*socket_data_ptr).reader_ch;\n-        let buf_base = uv::ll::get_base_from_buf(buf);\n-        let new_bytes = vec::from_buf(buf_base, nread as uint);\n-        oldcomm::send(reader_ch, result::Ok(new_bytes));\n-      }\n+                    ++buf: uv::ll::uv_buf_t) {\n+    unsafe {\n+        log(debug, fmt!(\"entering on_tcp_read_cb stream: %? nread: %?\",\n+                        stream, nread));\n+        let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n+        let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n+            as *TcpSocketData;\n+        match nread as int {\n+          // incoming err.. probably eof\n+          -1 => {\n+            let err_data = uv::ll::get_last_err_data(loop_ptr).to_tcp_err();\n+            log(debug, fmt!(\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n+                            err_data.err_name, err_data.err_msg));\n+            let reader_ch = (*socket_data_ptr).reader_ch;\n+            oldcomm::send(reader_ch, result::Err(err_data));\n+          }\n+          // do nothing .. unneeded buf\n+          0 => (),\n+          // have data\n+          _ => {\n+            // we have data\n+            log(debug, fmt!(\"tcp on_read_cb nread: %d\", nread as int));\n+            let reader_ch = (*socket_data_ptr).reader_ch;\n+            let buf_base = uv::ll::get_base_from_buf(buf);\n+            let new_bytes = vec::from_buf(buf_base, nread as uint);\n+            oldcomm::send(reader_ch, result::Ok(new_bytes));\n+          }\n+        }\n+        uv::ll::free_base_of_buf(buf);\n+        log(debug, ~\"exiting on_tcp_read_cb\");\n     }\n-    uv::ll::free_base_of_buf(buf);\n-    log(debug, ~\"exiting on_tcp_read_cb\");\n }\n \n extern fn on_alloc_cb(handle: *libc::c_void,\n                       suggested_size: size_t)\n-    -> uv::ll::uv_buf_t unsafe {\n-    log(debug, ~\"tcp read on_alloc_cb!\");\n-    let char_ptr = uv::ll::malloc_buf_base_of(suggested_size);\n-    log(debug, fmt!(\"tcp read on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n-                     handle,\n-                     char_ptr as uint,\n-                     suggested_size as uint));\n-    uv::ll::buf_init(char_ptr, suggested_size as uint)\n+    -> uv::ll::uv_buf_t {\n+    unsafe {\n+        log(debug, ~\"tcp read on_alloc_cb!\");\n+        let char_ptr = uv::ll::malloc_buf_base_of(suggested_size);\n+        log(debug, fmt!(\"tcp read on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n+                         handle,\n+                         char_ptr as uint,\n+                         suggested_size as uint));\n+        uv::ll::buf_init(char_ptr, suggested_size as uint)\n+    }\n }\n \n type TcpSocketCloseData = {\n     closed_ch: oldcomm::Chan<()>\n };\n \n-extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n-    let data = uv::ll::get_data_for_uv_handle(handle)\n-        as *TcpSocketCloseData;\n-    let closed_ch = (*data).closed_ch;\n-    oldcomm::send(closed_ch, ());\n-    log(debug, ~\"tcp_socket_dtor_close_cb exiting..\");\n+extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) {\n+    unsafe {\n+        let data = uv::ll::get_data_for_uv_handle(handle)\n+            as *TcpSocketCloseData;\n+        let closed_ch = (*data).closed_ch;\n+        oldcomm::send(closed_ch, ());\n+        log(debug, ~\"tcp_socket_dtor_close_cb exiting..\");\n+    }\n }\n \n extern fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n-                              status: libc::c_int) unsafe {\n-    let write_data_ptr = uv::ll::get_data_for_req(write_req)\n-        as *WriteReqData;\n-    if status == 0i32 {\n-        log(debug, ~\"successful write complete\");\n-        oldcomm::send((*write_data_ptr).result_ch, TcpWriteSuccess);\n-    } else {\n-        let stream_handle_ptr = uv::ll::get_stream_handle_from_write_req(\n-            write_req);\n-        let loop_ptr = uv::ll::get_loop_for_uv_handle(stream_handle_ptr);\n-        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-        log(debug, ~\"failure to write\");\n-        oldcomm::send((*write_data_ptr).result_ch,\n-                         TcpWriteError(err_data));\n+                              status: libc::c_int) {\n+    unsafe {\n+        let write_data_ptr = uv::ll::get_data_for_req(write_req)\n+            as *WriteReqData;\n+        if status == 0i32 {\n+            log(debug, ~\"successful write complete\");\n+            oldcomm::send((*write_data_ptr).result_ch, TcpWriteSuccess);\n+        } else {\n+            let stream_handle_ptr = uv::ll::get_stream_handle_from_write_req(\n+                write_req);\n+            let loop_ptr = uv::ll::get_loop_for_uv_handle(stream_handle_ptr);\n+            let err_data = uv::ll::get_last_err_data(loop_ptr);\n+            log(debug, ~\"failure to write\");\n+            oldcomm::send((*write_data_ptr).result_ch,\n+                             TcpWriteError(err_data));\n+        }\n     }\n }\n \n@@ -1211,43 +1287,49 @@ type ConnectReqData = {\n     closed_signal_ch: oldcomm::Chan<()>\n };\n \n-extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n-    let data = uv::ll::get_data_for_uv_handle(handle) as\n-        *ConnectReqData;\n-    oldcomm::send((*data).closed_signal_ch, ());\n-    log(debug, fmt!(\"exiting steam_error_close_cb for %?\", handle));\n+extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) {\n+    unsafe {\n+        let data = uv::ll::get_data_for_uv_handle(handle) as\n+            *ConnectReqData;\n+        oldcomm::send((*data).closed_signal_ch, ());\n+        log(debug, fmt!(\"exiting steam_error_close_cb for %?\", handle));\n+    }\n }\n \n-extern fn tcp_connect_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n-    log(debug, fmt!(\"closed client tcp handle %?\", handle));\n+extern fn tcp_connect_close_cb(handle: *uv::ll::uv_tcp_t) {\n+    unsafe {\n+        log(debug, fmt!(\"closed client tcp handle %?\", handle));\n+    }\n }\n \n extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n-                                   status: libc::c_int) unsafe {\n-    let conn_data_ptr = (uv::ll::get_data_for_req(connect_req_ptr)\n-                      as *ConnectReqData);\n-    let result_ch = (*conn_data_ptr).result_ch;\n-    log(debug, fmt!(\"tcp_connect result_ch %?\", result_ch));\n-    let tcp_stream_ptr =\n-        uv::ll::get_stream_handle_from_connect_req(connect_req_ptr);\n-    match status {\n-      0i32 => {\n-        log(debug, ~\"successful tcp connection!\");\n-        oldcomm::send(result_ch, ConnSuccess);\n-      }\n-      _ => {\n-        log(debug, ~\"error in tcp_connect_on_connect_cb\");\n-        let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n-        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-        log(debug, fmt!(\"err_data %? %?\", err_data.err_name,\n-                        err_data.err_msg));\n-        oldcomm::send(result_ch, ConnFailure(err_data));\n-        uv::ll::set_data_for_uv_handle(tcp_stream_ptr,\n-                                       conn_data_ptr);\n-        uv::ll::close(tcp_stream_ptr, stream_error_close_cb);\n-      }\n+                                   status: libc::c_int) {\n+    unsafe {\n+        let conn_data_ptr = (uv::ll::get_data_for_req(connect_req_ptr)\n+                          as *ConnectReqData);\n+        let result_ch = (*conn_data_ptr).result_ch;\n+        log(debug, fmt!(\"tcp_connect result_ch %?\", result_ch));\n+        let tcp_stream_ptr =\n+            uv::ll::get_stream_handle_from_connect_req(connect_req_ptr);\n+        match status {\n+          0i32 => {\n+            log(debug, ~\"successful tcp connection!\");\n+            oldcomm::send(result_ch, ConnSuccess);\n+          }\n+          _ => {\n+            log(debug, ~\"error in tcp_connect_on_connect_cb\");\n+            let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n+            let err_data = uv::ll::get_last_err_data(loop_ptr);\n+            log(debug, fmt!(\"err_data %? %?\", err_data.err_name,\n+                            err_data.err_msg));\n+            oldcomm::send(result_ch, ConnFailure(err_data));\n+            uv::ll::set_data_for_uv_handle(tcp_stream_ptr,\n+                                           conn_data_ptr);\n+            uv::ll::close(tcp_stream_ptr, stream_error_close_cb);\n+          }\n+        }\n+        log(debug, ~\"leaving tcp_connect_on_connect_cb\");\n     }\n-    log(debug, ~\"leaving tcp_connect_on_connect_cb\");\n }\n \n enum ConnAttempt {\n@@ -1298,25 +1380,35 @@ pub mod test {\n             use net::tcp::test::*;\n \n             #[test]\n-            fn test_gl_tcp_server_and_client_ipv4() unsafe {\n-                use net::tcp::test::tcp_ipv4_server_and_client_test::*;\n-                impl_gl_tcp_ipv4_server_and_client();\n+            fn test_gl_tcp_server_and_client_ipv4() {\n+                unsafe {\n+                    use net::tcp::test::tcp_ipv4_server_and_client_test::*;\n+                    impl_gl_tcp_ipv4_server_and_client();\n+                }\n             }\n             #[test]\n-            fn test_gl_tcp_get_peer_addr() unsafe {\n-                impl_gl_tcp_ipv4_get_peer_addr();\n+            fn test_gl_tcp_get_peer_addr() {\n+                unsafe {\n+                    impl_gl_tcp_ipv4_get_peer_addr();\n+                }\n             }\n             #[test]\n-            fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n-                impl_gl_tcp_ipv4_client_error_connection_refused();\n+            fn test_gl_tcp_ipv4_client_error_connection_refused() {\n+                unsafe {\n+                    impl_gl_tcp_ipv4_client_error_connection_refused();\n+                }\n             }\n             #[test]\n-            fn test_gl_tcp_server_address_in_use() unsafe {\n-                impl_gl_tcp_ipv4_server_address_in_use();\n+            fn test_gl_tcp_server_address_in_use() {\n+                unsafe {\n+                    impl_gl_tcp_ipv4_server_address_in_use();\n+                }\n             }\n             #[test]\n-            fn test_gl_tcp_server_access_denied() unsafe {\n-                impl_gl_tcp_ipv4_server_access_denied();\n+            fn test_gl_tcp_server_access_denied() {\n+                unsafe {\n+                    impl_gl_tcp_ipv4_server_access_denied();\n+                }\n             }\n             // Strange failure on Windows. --pcwalton\n             #[test]\n@@ -1336,29 +1428,39 @@ pub mod test {\n \n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_gl_tcp_server_and_client_ipv4() unsafe {\n-                impl_gl_tcp_ipv4_server_and_client();\n+            fn test_gl_tcp_server_and_client_ipv4() {\n+                unsafe {\n+                    impl_gl_tcp_ipv4_server_and_client();\n+                }\n             }\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_gl_tcp_get_peer_addr() unsafe {\n-                impl_gl_tcp_ipv4_get_peer_addr();\n+            fn test_gl_tcp_get_peer_addr() {\n+                unsafe {\n+                    impl_gl_tcp_ipv4_get_peer_addr();\n+                }\n             }\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n-                impl_gl_tcp_ipv4_client_error_connection_refused();\n+            fn test_gl_tcp_ipv4_client_error_connection_refused() {\n+                unsafe {\n+                    impl_gl_tcp_ipv4_client_error_connection_refused();\n+                }\n             }\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_gl_tcp_server_address_in_use() unsafe {\n-                impl_gl_tcp_ipv4_server_address_in_use();\n+            fn test_gl_tcp_server_address_in_use() {\n+                unsafe {\n+                    impl_gl_tcp_ipv4_server_address_in_use();\n+                }\n             }\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n             #[ignore(cfg(windows), reason = \"deadlocking bots\")]\n-            fn test_gl_tcp_server_access_denied() unsafe {\n-                impl_gl_tcp_ipv4_server_access_denied();\n+            fn test_gl_tcp_server_access_denied() {\n+                unsafe {\n+                    impl_gl_tcp_ipv4_server_access_denied();\n+                }\n             }\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]"}, {"sha": "5b377d9d932f18367a710d070f394ed65e3c47a5", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -361,20 +361,22 @@ pure fn query_from_str(rawquery: &str) -> Query {\n     return query;\n }\n \n-pub pure fn query_to_str(query: &Query) -> ~str unsafe {\n-    // FIXME(#3722): unsafe only because decode_inner does (string) IO\n-    let mut strvec = ~[];\n-    for query.each |kv| {\n-        match kv {\n-            &(ref k, ref v) => {\n-                strvec.push(fmt!(\"%s=%s\",\n-                    encode_component(*k),\n-                    encode_component(*v))\n-                );\n+pub pure fn query_to_str(query: &Query) -> ~str {\n+    unsafe {\n+        // FIXME(#3722): unsafe only because decode_inner does (string) IO\n+        let mut strvec = ~[];\n+        for query.each |kv| {\n+            match kv {\n+                &(ref k, ref v) => {\n+                    strvec.push(fmt!(\"%s=%s\",\n+                        encode_component(*k),\n+                        encode_component(*v))\n+                    );\n+                }\n             }\n         }\n+        return str::connect(strvec, ~\"&\");\n     }\n-    return str::connect(strvec, ~\"&\");\n }\n \n // returns the scheme and the rest of the url, or a parsing error"}, {"sha": "b5b30599d48d5c48d931e55520fd70d0f3197963", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -131,41 +131,46 @@ impl <T: Ord> PriorityQueue<T> {\n     // vector over the junk element.  This reduces the constant factor\n     // compared to using swaps, which involves twice as many moves.\n \n-    priv fn siftup(&mut self, start: uint, pos: uint) unsafe {\n-        let mut pos = pos;\n-        let new = move *addr_of(&self.data[pos]);\n-\n-        while pos > start {\n-            let parent = (pos - 1) >> 1;\n-            if new > self.data[parent] {\n-                rusti::move_val_init(&mut self.data[pos],\n-                                     move *addr_of(&self.data[parent]));\n-                pos = parent;\n-                loop\n+    priv fn siftup(&mut self, start: uint, pos: uint) {\n+        unsafe {\n+            let mut pos = pos;\n+            let new = move *addr_of(&self.data[pos]);\n+\n+            while pos > start {\n+                let parent = (pos - 1) >> 1;\n+                if new > self.data[parent] {\n+                    rusti::move_val_init(&mut self.data[pos],\n+                                         move *addr_of(&self.data[parent]));\n+                    pos = parent;\n+                    loop\n+                }\n+                break\n             }\n-            break\n+            rusti::move_val_init(&mut self.data[pos], move new);\n         }\n-        rusti::move_val_init(&mut self.data[pos], move new);\n     }\n \n-    priv fn siftdown_range(&mut self, pos: uint, end: uint) unsafe {\n-        let mut pos = pos;\n-        let start = pos;\n-        let new = move *addr_of(&self.data[pos]);\n-\n-        let mut child = 2 * pos + 1;\n-        while child < end {\n-            let right = child + 1;\n-            if right < end && !(self.data[child] > self.data[right]) {\n-                child = right;\n+    priv fn siftdown_range(&mut self, pos: uint, end: uint) {\n+        unsafe {\n+            let mut pos = pos;\n+            let start = pos;\n+            let new = move *addr_of(&self.data[pos]);\n+\n+            let mut child = 2 * pos + 1;\n+            while child < end {\n+                let right = child + 1;\n+                if right < end && !(self.data[child] > self.data[right]) {\n+                    child = right;\n+                }\n+                rusti::move_val_init(&mut self.data[pos],\n+                                     move *addr_of(&self.data[child]));\n+                pos = child;\n+                child = 2 * pos + 1;\n             }\n-            rusti::move_val_init(&mut self.data[pos],\n-                                 move *addr_of(&self.data[child]));\n-            pos = child;\n-            child = 2 * pos + 1;\n+\n+            rusti::move_val_init(&mut self.data[pos], move new);\n+            self.siftup(start, pos);\n         }\n-        rusti::move_val_init(&mut self.data[pos], move new);\n-        self.siftup(start, pos);\n     }\n \n     priv fn siftdown(&mut self, pos: uint) {"}, {"sha": "aa8f77d4cd203f5be1628e97eca3d22d797daf1f", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -55,11 +55,13 @@ pub unsafe fn load_history(file: ~str) -> bool {\n \n /// Print out a prompt and then wait for input and return it\n pub unsafe fn read(prompt: ~str) -> Option<~str> {\n-    do str::as_c_str(prompt) |buf| unsafe {\n-        let line = rustrt::linenoise(buf);\n+    do str::as_c_str(prompt) |buf| {\n+        unsafe {\n+            let line = rustrt::linenoise(buf);\n \n-        if line.is_null() { None }\n-        else { Some(str::raw::from_c_str(line)) }\n+            if line.is_null() { None }\n+            else { Some(str::raw::from_c_str(line)) }\n+        }\n     }\n }\n \n@@ -68,18 +70,23 @@ pub type CompletionCb = fn~(~str, fn(~str));\n fn complete_key(_v: @CompletionCb) {}\n \n /// Bind to the main completion callback\n-pub unsafe fn complete(cb: CompletionCb) unsafe {\n-    task::local_data::local_data_set(complete_key, @(move cb));\n+pub unsafe fn complete(cb: CompletionCb) {\n+    unsafe {\n+        task::local_data::local_data_set(complete_key, @(move cb));\n \n-    extern fn callback(line: *c_char, completions: *()) unsafe {\n-        let cb = copy *task::local_data::local_data_get(complete_key).get();\n+        extern fn callback(line: *c_char, completions: *()) {\n+            unsafe {\n+                let cb = copy *task::local_data::local_data_get(complete_key)\n+                    .get();\n \n-        do cb(str::raw::from_c_str(line)) |suggestion| {\n-            do str::as_c_str(suggestion) |buf| {\n-                rustrt::linenoiseAddCompletion(completions, buf);\n+                do cb(str::raw::from_c_str(line)) |suggestion| {\n+                    do str::as_c_str(suggestion) |buf| {\n+                        rustrt::linenoiseAddCompletion(completions, buf);\n+                    }\n+                }\n             }\n         }\n-    }\n \n-    rustrt::linenoiseSetCompletionCallback(callback);\n+        rustrt::linenoiseSetCompletionCallback(callback);\n+    }\n }"}, {"sha": "c469824f48d7a0492c4fef88193b71aaeabbb2f9", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -831,28 +831,30 @@ pub mod node {\n         return forest[0];\n     }\n \n-    pub fn serialize_node(node: @Node) -> ~str unsafe {\n-        let mut buf = vec::cast_to_mut(vec::from_elem(byte_len(node), 0u8));\n-        let mut offset = 0u;//Current position in the buffer\n-        let it = leaf_iterator::start(node);\n-        loop {\n-            match (leaf_iterator::next(&it)) {\n-              option::None => break,\n-              option::Some(x) => {\n-                //FIXME (#2744): Replace with memcpy or something similar\n-                let mut local_buf: ~[u8] =\n-                    cast::reinterpret_cast(&*x.content);\n-                let mut i = x.byte_offset;\n-                while i < x.byte_len {\n-                    buf[offset] = local_buf[i];\n-                    offset += 1u;\n-                    i      += 1u;\n+    pub fn serialize_node(node: @Node) -> ~str {\n+        unsafe {\n+            let mut buf = vec::cast_to_mut(vec::from_elem(byte_len(node), 0));\n+            let mut offset = 0u;//Current position in the buffer\n+            let it = leaf_iterator::start(node);\n+            loop {\n+                match (leaf_iterator::next(&it)) {\n+                  option::None => break,\n+                  option::Some(x) => {\n+                    //FIXME (#2744): Replace with memcpy or something similar\n+                    let mut local_buf: ~[u8] =\n+                        cast::reinterpret_cast(&*x.content);\n+                    let mut i = x.byte_offset;\n+                    while i < x.byte_len {\n+                        buf[offset] = local_buf[i];\n+                        offset += 1u;\n+                        i      += 1u;\n+                    }\n+                    cast::forget(move local_buf);\n+                  }\n                 }\n-                cast::forget(move local_buf);\n-              }\n             }\n+            return cast::transmute(move buf);\n         }\n-        return cast::transmute(move buf);\n     }\n \n     /**\n@@ -862,17 +864,19 @@ pub mod node {\n      *\n      * This function executes in linear time.\n      */\n-    pub fn flatten(node: @Node) -> @Node unsafe {\n-        match (*node) {\n-          Leaf(_) => return node,\n-          Concat(ref x) => {\n-            return @Leaf({\n-                byte_offset: 0u,\n-                byte_len:    x.byte_len,\n-                char_len:    x.char_len,\n-                content:     @serialize_node(node)\n-            })\n-          }\n+    pub fn flatten(node: @Node) -> @Node {\n+        unsafe {\n+            match (*node) {\n+              Leaf(_) => return node,\n+              Concat(ref x) => {\n+                return @Leaf({\n+                    byte_offset: 0u,\n+                    byte_len:    x.byte_len,\n+                    char_len:    x.char_len,\n+                    content:     @serialize_node(node)\n+                })\n+              }\n+            }\n         }\n     }\n \n@@ -1284,17 +1288,19 @@ mod tests {\n           node::Empty => return ~\"\",\n           node::Content(x) => {\n             let str = @mut ~\"\";\n-            fn aux(str: @mut ~str, node: @node::Node) unsafe {\n-                match (*node) {\n-                  node::Leaf(x) => {\n-                    *str += str::slice(\n-                        *x.content, x.byte_offset,\n-                        x.byte_offset + x.byte_len);\n-                  }\n-                  node::Concat(ref x) => {\n-                    aux(str, x.left);\n-                    aux(str, x.right);\n-                  }\n+            fn aux(str: @mut ~str, node: @node::Node) {\n+                unsafe {\n+                    match (*node) {\n+                      node::Leaf(x) => {\n+                        *str += str::slice(\n+                            *x.content, x.byte_offset,\n+                            x.byte_offset + x.byte_len);\n+                      }\n+                      node::Concat(ref x) => {\n+                        aux(str, x.left);\n+                        aux(str, x.right);\n+                      }\n+                    }\n                 }\n             }\n             aux(str, x);"}, {"sha": "7a524eb79851d93d9c1f5d7862913cabf411254a", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 84, "deletions": 82, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -282,97 +282,99 @@ mod tests {\n     use core::vec;\n \n     #[test]\n-    fn test() unsafe {\n-        type Test = {input: ~str, output: ~[u8]};\n+    fn test() {\n+        unsafe {\n+            type Test = {input: ~str, output: ~[u8]};\n \n-        fn a_million_letter_a() -> ~str {\n-            let mut i = 0;\n-            let mut rs = ~\"\";\n-            while i < 100000 {\n-                str::push_str(&mut rs, ~\"aaaaaaaaaa\");\n-                i += 1;\n+            fn a_million_letter_a() -> ~str {\n+                let mut i = 0;\n+                let mut rs = ~\"\";\n+                while i < 100000 {\n+                    str::push_str(&mut rs, ~\"aaaaaaaaaa\");\n+                    i += 1;\n+                }\n+                return rs;\n             }\n-            return rs;\n-        }\n-        // Test messages from FIPS 180-1\n+            // Test messages from FIPS 180-1\n \n-        let fips_180_1_tests: ~[Test] =\n-            ~[{input: ~\"abc\",\n-              output:\n-                  ~[0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n-                   0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n-                   0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n-                   0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n-                   0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8]},\n-             {input:\n-                  ~\"abcdbcdecdefdefgefghfghighij\" +\n-                  ~\"hijkijkljklmklmnlmnomnopnopq\",\n-              output:\n-                  ~[0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n-                   0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n-                   0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n-                   0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n-                   0xE5u8, 0x46u8, 0x70u8, 0xF1u8]},\n-             {input: a_million_letter_a(),\n-              output:\n-                  ~[0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n-                   0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n-                   0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n-                   0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n-                   0x65u8, 0x34u8, 0x01u8, 0x6Fu8]}];\n-        // Examples from wikipedia\n+            let fips_180_1_tests: ~[Test] =\n+                ~[{input: ~\"abc\",\n+                  output:\n+                      ~[0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n+                       0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n+                       0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n+                       0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n+                       0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8]},\n+                 {input:\n+                      ~\"abcdbcdecdefdefgefghfghighij\" +\n+                      ~\"hijkijkljklmklmnlmnomnopnopq\",\n+                  output:\n+                      ~[0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n+                       0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n+                       0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n+                       0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n+                       0xE5u8, 0x46u8, 0x70u8, 0xF1u8]},\n+                 {input: a_million_letter_a(),\n+                  output:\n+                      ~[0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n+                       0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n+                       0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n+                       0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n+                       0x65u8, 0x34u8, 0x01u8, 0x6Fu8]}];\n+            // Examples from wikipedia\n \n-        let wikipedia_tests: ~[Test] =\n-            ~[{input: ~\"The quick brown fox jumps over the lazy dog\",\n-              output:\n-                  ~[0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n-                   0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n-                   0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n-                   0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n-                   0x1bu8, 0x93u8, 0xebu8, 0x12u8]},\n-             {input: ~\"The quick brown fox jumps over the lazy cog\",\n-              output:\n-                  ~[0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n-                   0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n-                   0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n-                   0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n-                   0x10u8, 0x0du8, 0xb4u8, 0xb3u8]}];\n-        let tests = fips_180_1_tests + wikipedia_tests;\n-        fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n-            assert (vec::len::<u8>(v0) == vec::len::<u8>(v1));\n-            let len = vec::len::<u8>(v0);\n-            let mut i = 0u;\n-            while i < len {\n-                let a = v0[i];\n-                let b = v1[i];\n-                assert (a == b);\n-                i += 1u;\n+            let wikipedia_tests: ~[Test] =\n+                ~[{input: ~\"The quick brown fox jumps over the lazy dog\",\n+                  output:\n+                      ~[0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n+                       0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n+                       0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n+                       0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n+                       0x1bu8, 0x93u8, 0xebu8, 0x12u8]},\n+                 {input: ~\"The quick brown fox jumps over the lazy cog\",\n+                  output:\n+                      ~[0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n+                       0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n+                       0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n+                       0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n+                       0x10u8, 0x0du8, 0xb4u8, 0xb3u8]}];\n+            let tests = fips_180_1_tests + wikipedia_tests;\n+            fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n+                assert (vec::len::<u8>(v0) == vec::len::<u8>(v1));\n+                let len = vec::len::<u8>(v0);\n+                let mut i = 0u;\n+                while i < len {\n+                    let a = v0[i];\n+                    let b = v1[i];\n+                    assert (a == b);\n+                    i += 1u;\n+                }\n             }\n-        }\n-        // Test that it works when accepting the message all at once\n+            // Test that it works when accepting the message all at once\n \n-        let sh = sha1::sha1();\n-        for vec::each(tests) |t| {\n-            sh.input_str(t.input);\n-            let out = sh.result();\n-            check_vec_eq(t.output, out);\n-            sh.reset();\n-        }\n+            let sh = sha1::sha1();\n+            for vec::each(tests) |t| {\n+                sh.input_str(t.input);\n+                let out = sh.result();\n+                check_vec_eq(t.output, out);\n+                sh.reset();\n+            }\n \n \n-        // Test that it works when accepting the message in pieces\n-        for vec::each(tests) |t| {\n-            let len = str::len(t.input);\n-            let mut left = len;\n-            while left > 0u {\n-                let take = (left + 1u) / 2u;\n-                sh.input_str(str::slice(t.input, len - left,\n-                             take + len - left));\n-                left = left - take;\n+            // Test that it works when accepting the message in pieces\n+            for vec::each(tests) |t| {\n+                let len = str::len(t.input);\n+                let mut left = len;\n+                while left > 0u {\n+                    let take = (left + 1u) / 2u;\n+                    sh.input_str(str::slice(t.input, len - left,\n+                                 take + len - left));\n+                    left = left - take;\n+                }\n+                let out = sh.result();\n+                check_vec_eq(t.output, out);\n+                sh.reset();\n             }\n-            let out = sh.result();\n-            check_vec_eq(t.output, out);\n-            sh.reset();\n         }\n     }\n "}, {"sha": "f8147c532e679e05b27b84e0e35eb6a352ef025f", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -49,26 +49,28 @@ pub fn delayed_send<T: Owned>(iotask: IoTask,\n             let timer_done_ch_ptr = ptr::addr_of(&timer_done_ch);\n             let timer = uv::ll::timer_t();\n             let timer_ptr = ptr::addr_of(&timer);\n-            do iotask::interact(iotask) |loop_ptr| unsafe {\n-                let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n-                if (init_result == 0i32) {\n-                    let start_result = uv::ll::timer_start(\n-                        timer_ptr, delayed_send_cb, msecs, 0u);\n-                    if (start_result == 0i32) {\n-                        uv::ll::set_data_for_uv_handle(\n-                            timer_ptr,\n-                            timer_done_ch_ptr as *libc::c_void);\n-                    }\n-                    else {\n+            do iotask::interact(iotask) |loop_ptr| {\n+                unsafe {\n+                    let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n+                    if (init_result == 0i32) {\n+                        let start_result = uv::ll::timer_start(\n+                            timer_ptr, delayed_send_cb, msecs, 0u);\n+                        if (start_result == 0i32) {\n+                            uv::ll::set_data_for_uv_handle(\n+                                timer_ptr,\n+                                timer_done_ch_ptr as *libc::c_void);\n+                        } else {\n+                            let error_msg = uv::ll::get_last_err_info(\n+                                loop_ptr);\n+                            fail ~\"timer::delayed_send() start failed: \" +\n+                                error_msg;\n+                        }\n+                    } else {\n                         let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-                        fail ~\"timer::delayed_send() start failed: \" +\n+                        fail ~\"timer::delayed_send() init failed: \" +\n                             error_msg;\n                     }\n                 }\n-                else {\n-                    let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-                    fail ~\"timer::delayed_send() init failed: \"+error_msg;\n-                }\n             };\n             // delayed_send_cb has been processed by libuv\n             oldcomm::recv(timer_done_po);\n@@ -138,27 +140,31 @@ pub fn recv_timeout<T: Copy Owned>(iotask: IoTask,\n \n // INTERNAL API\n extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n-                                status: libc::c_int) unsafe {\n-    log(debug, fmt!(\"delayed_send_cb handle %? status %?\", handle, status));\n-    let timer_done_ch =\n-        *(uv::ll::get_data_for_uv_handle(handle) as *oldcomm::Chan<()>);\n-    let stop_result = uv::ll::timer_stop(handle);\n-    if (stop_result == 0i32) {\n-        oldcomm::send(timer_done_ch, ());\n-        uv::ll::close(handle, delayed_send_close_cb);\n-    }\n-    else {\n-        let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n-        let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-        fail ~\"timer::sleep() init failed: \"+error_msg;\n+                                status: libc::c_int) {\n+    unsafe {\n+        log(debug,\n+            fmt!(\"delayed_send_cb handle %? status %?\", handle, status));\n+        let timer_done_ch =\n+            *(uv::ll::get_data_for_uv_handle(handle) as *oldcomm::Chan<()>);\n+        let stop_result = uv::ll::timer_stop(handle);\n+        if (stop_result == 0i32) {\n+            oldcomm::send(timer_done_ch, ());\n+            uv::ll::close(handle, delayed_send_close_cb);\n+        } else {\n+            let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n+            let error_msg = uv::ll::get_last_err_info(loop_ptr);\n+            fail ~\"timer::sleep() init failed: \"+error_msg;\n+        }\n     }\n }\n \n-extern fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) unsafe {\n-    log(debug, fmt!(\"delayed_send_close_cb handle %?\", handle));\n-    let timer_done_ch =\n-        *(uv::ll::get_data_for_uv_handle(handle) as *oldcomm::Chan<()>);\n-    oldcomm::send(timer_done_ch, ());\n+extern fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) {\n+    unsafe {\n+        log(debug, fmt!(\"delayed_send_close_cb handle %?\", handle));\n+        let timer_done_ch =\n+            *(uv::ll::get_data_for_uv_handle(handle) as *oldcomm::Chan<()>);\n+        oldcomm::send(timer_done_ch, ());\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "4b77e914ffb2a18dd8e1ea0cc9c9c57b1cc34dd0", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -51,14 +51,16 @@ impl <K: Eq Ord, V: Eq> TreeMap<K, V>: Eq {\n         } else {\n             let mut x = self.iter();\n             let mut y = other.iter();\n-            for self.len().times unsafe { // unsafe as a purity workaround\n-                // ICE: x.next() != y.next()\n+            for self.len().times {\n+                unsafe { // unsafe as a purity workaround\n+                    // ICE: x.next() != y.next()\n \n-                let (x1, x2) = x.next().unwrap();\n-                let (y1, y2) = y.next().unwrap();\n+                    let (x1, x2) = x.next().unwrap();\n+                    let (y1, y2) = y.next().unwrap();\n \n-                if x1 != y1 || x2 != y2 {\n-                    return false\n+                    if x1 != y1 || x2 != y2 {\n+                        return false\n+                    }\n                 }\n             }\n             true"}, {"sha": "3a2c3b7c135e0a2f70316407e5825f73069b82c4", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 137, "deletions": 117, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -47,55 +47,59 @@ pub fn get() -> IoTask {\n }\n \n #[doc(hidden)]\n-fn get_monitor_task_gl() -> IoTask unsafe {\n-\n-    let monitor_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n-\n-    debug!(\"ENTERING global_loop::get() loop chan: %?\",\n-           monitor_loop_chan_ptr);\n-\n-    debug!(\"before priv::chan_from_global_ptr\");\n-    type MonChan = Chan<IoTask>;\n-\n-    let monitor_ch =\n-        do chan_from_global_ptr::<MonChan>(monitor_loop_chan_ptr,\n-                                           || {\n-                                                task::task().sched_mode\n-                                                (task::SingleThreaded)\n-                                                .unlinked()\n-                                           }) |msg_po| unsafe {\n-        debug!(\"global monitor task starting\");\n-\n-        // As a weak task the runtime will notify us when to exit\n-        do weaken_task() |weak_exit_po| {\n-            debug!(\"global monitor task is now weak\");\n-            let hl_loop = spawn_loop();\n-            loop {\n-                debug!(\"in outer_loop...\");\n-                match select2(weak_exit_po, msg_po) {\n-                  Left(weak_exit) => {\n-                    // all normal tasks have ended, tell the\n-                    // libuv loop to tear_down, then exit\n-                    debug!(\"weak_exit_po recv'd msg: %?\", weak_exit);\n-                    iotask::exit(hl_loop);\n-                    break;\n-                  }\n-                  Right(fetch_ch) => {\n-                    debug!(\"hl_loop req recv'd: %?\", fetch_ch);\n-                    fetch_ch.send(hl_loop);\n-                  }\n-                }\n+fn get_monitor_task_gl() -> IoTask {\n+    unsafe {\n+        let monitor_loop_chan_ptr =\n+            rustrt::rust_uv_get_kernel_global_chan_ptr();\n+\n+        debug!(\"ENTERING global_loop::get() loop chan: %?\",\n+               monitor_loop_chan_ptr);\n+\n+        debug!(\"before priv::chan_from_global_ptr\");\n+        type MonChan = Chan<IoTask>;\n+\n+        let monitor_ch =\n+            do chan_from_global_ptr::<MonChan>(monitor_loop_chan_ptr,\n+                                               || {\n+                                                    task::task().sched_mode\n+                                                    (task::SingleThreaded)\n+                                                    .unlinked()\n+                                               }) |msg_po| {\n+            unsafe {\n+                debug!(\"global monitor task starting\");\n+\n+                // As a weak task the runtime will notify us when to exit\n+                do weaken_task() |weak_exit_po| {\n+                    debug!(\"global monitor task is now weak\");\n+                    let hl_loop = spawn_loop();\n+                    loop {\n+                        debug!(\"in outer_loop...\");\n+                        match select2(weak_exit_po, msg_po) {\n+                          Left(weak_exit) => {\n+                            // all normal tasks have ended, tell the\n+                            // libuv loop to tear_down, then exit\n+                            debug!(\"weak_exit_po recv'd msg: %?\", weak_exit);\n+                            iotask::exit(hl_loop);\n+                            break;\n+                          }\n+                          Right(fetch_ch) => {\n+                            debug!(\"hl_loop req recv'd: %?\", fetch_ch);\n+                            fetch_ch.send(hl_loop);\n+                          }\n+                        }\n+                    }\n+                    debug!(\"global monitor task is leaving weakend state\");\n+                };\n+                debug!(\"global monitor task exiting\");\n             }\n-            debug!(\"global monitor task is leaving weakend state\");\n         };\n-        debug!(\"global monitor task exiting\");\n-    };\n \n-    // once we have a chan to the monitor loop, we ask it for\n-    // the libuv loop's async handle\n-    do listen |fetch_ch| {\n-        monitor_ch.send(fetch_ch);\n-        fetch_ch.recv()\n+        // once we have a chan to the monitor loop, we ask it for\n+        // the libuv loop's async handle\n+        do listen |fetch_ch| {\n+            monitor_ch.send(fetch_ch);\n+            fetch_ch.recv()\n+        }\n     }\n }\n \n@@ -135,91 +139,107 @@ mod test {\n     use core::ptr;\n     use core::task;\n \n-    extern fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) unsafe {\n-        let exit_ch_ptr = ll::get_data_for_uv_handle(\n-            timer_ptr as *libc::c_void) as *oldcomm::Chan<bool>;\n-        let exit_ch = *exit_ch_ptr;\n-        oldcomm::send(exit_ch, true);\n-        log(debug, fmt!(\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n-                       exit_ch_ptr));\n+    extern fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) {\n+        unsafe {\n+            let exit_ch_ptr = ll::get_data_for_uv_handle(\n+                timer_ptr as *libc::c_void) as *oldcomm::Chan<bool>;\n+            let exit_ch = *exit_ch_ptr;\n+            oldcomm::send(exit_ch, true);\n+            log(debug,\n+                fmt!(\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n+                     exit_ch_ptr));\n+        }\n     }\n     extern fn simple_timer_cb(timer_ptr: *ll::uv_timer_t,\n-                             _status: libc::c_int) unsafe {\n-        log(debug, ~\"in simple timer cb\");\n-        ll::timer_stop(timer_ptr);\n-        let hl_loop = get_gl();\n-        do iotask::interact(hl_loop) |_loop_ptr| unsafe {\n-            log(debug, ~\"closing timer\");\n-            ll::close(timer_ptr, simple_timer_close_cb);\n-            log(debug, ~\"about to deref exit_ch_ptr\");\n-            log(debug, ~\"after msg sent on deref'd exit_ch\");\n-        };\n-        log(debug, ~\"exiting simple timer cb\");\n+                             _status: libc::c_int) {\n+        unsafe {\n+            log(debug, ~\"in simple timer cb\");\n+            ll::timer_stop(timer_ptr);\n+            let hl_loop = get_gl();\n+            do iotask::interact(hl_loop) |_loop_ptr| {\n+                unsafe {\n+                    log(debug, ~\"closing timer\");\n+                    ll::close(timer_ptr, simple_timer_close_cb);\n+                    log(debug, ~\"about to deref exit_ch_ptr\");\n+                    log(debug, ~\"after msg sent on deref'd exit_ch\");\n+                }\n+            };\n+            log(debug, ~\"exiting simple timer cb\");\n+        }\n     }\n \n-    fn impl_uv_hl_simple_timer(iotask: IoTask) unsafe {\n-        let exit_po = oldcomm::Port::<bool>();\n-        let exit_ch = oldcomm::Chan(&exit_po);\n-        let exit_ch_ptr = ptr::addr_of(&exit_ch);\n-        log(debug, fmt!(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n-                       exit_ch_ptr));\n-        let timer_handle = ll::timer_t();\n-        let timer_ptr = ptr::addr_of(&timer_handle);\n-        do iotask::interact(iotask) |loop_ptr| unsafe {\n-            log(debug, ~\"user code inside interact loop!!!\");\n-            let init_status = ll::timer_init(loop_ptr, timer_ptr);\n-            if(init_status == 0i32) {\n-                ll::set_data_for_uv_handle(\n-                    timer_ptr as *libc::c_void,\n-                    exit_ch_ptr as *libc::c_void);\n-                let start_status = ll::timer_start(timer_ptr, simple_timer_cb,\n-                                                   1u, 0u);\n-                if(start_status == 0i32) {\n-                }\n-                else {\n-                    fail ~\"failure on ll::timer_start()\";\n+    fn impl_uv_hl_simple_timer(iotask: IoTask) {\n+        unsafe {\n+            let exit_po = oldcomm::Port::<bool>();\n+            let exit_ch = oldcomm::Chan(&exit_po);\n+            let exit_ch_ptr = ptr::addr_of(&exit_ch);\n+            log(debug, fmt!(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n+                           exit_ch_ptr));\n+            let timer_handle = ll::timer_t();\n+            let timer_ptr = ptr::addr_of(&timer_handle);\n+            do iotask::interact(iotask) |loop_ptr| {\n+                unsafe {\n+                    log(debug, ~\"user code inside interact loop!!!\");\n+                    let init_status = ll::timer_init(loop_ptr, timer_ptr);\n+                    if(init_status == 0i32) {\n+                        ll::set_data_for_uv_handle(\n+                            timer_ptr as *libc::c_void,\n+                            exit_ch_ptr as *libc::c_void);\n+                        let start_status = ll::timer_start(timer_ptr,\n+                                                           simple_timer_cb,\n+                                                           1u,\n+                                                           0u);\n+                        if start_status != 0 {\n+                            fail ~\"failure on ll::timer_start()\";\n+                        }\n+                    } else {\n+                        fail ~\"failure on ll::timer_init()\";\n+                    }\n                 }\n-            }\n-            else {\n-                fail ~\"failure on ll::timer_init()\";\n-            }\n-        };\n-        oldcomm::recv(exit_po);\n-        log(debug, ~\"global_loop timer test: msg recv on exit_po, done..\");\n+            };\n+            oldcomm::recv(exit_po);\n+            log(debug,\n+                ~\"global_loop timer test: msg recv on exit_po, done..\");\n+        }\n     }\n \n     #[test]\n-    fn test_gl_uv_global_loop_high_level_global_timer() unsafe {\n-        let hl_loop = get_gl();\n-        let exit_po = oldcomm::Port::<()>();\n-        let exit_ch = oldcomm::Chan(&exit_po);\n-        task::spawn_sched(task::ManualThreads(1u), || {\n+    fn test_gl_uv_global_loop_high_level_global_timer() {\n+        unsafe {\n+            let hl_loop = get_gl();\n+            let exit_po = oldcomm::Port::<()>();\n+            let exit_ch = oldcomm::Chan(&exit_po);\n+            task::spawn_sched(task::ManualThreads(1u), || {\n+                impl_uv_hl_simple_timer(hl_loop);\n+                oldcomm::send(exit_ch, ());\n+            });\n             impl_uv_hl_simple_timer(hl_loop);\n-            oldcomm::send(exit_ch, ());\n-        });\n-        impl_uv_hl_simple_timer(hl_loop);\n-        oldcomm::recv(exit_po);\n+            oldcomm::recv(exit_po);\n+        }\n     }\n \n     // keeping this test ignored until some kind of stress-test-harness\n     // is set up for the build bots\n     #[test]\n     #[ignore]\n-    fn test_stress_gl_uv_global_loop_high_level_global_timer() unsafe {\n-        let hl_loop = get_gl();\n-        let exit_po = oldcomm::Port::<()>();\n-        let exit_ch = oldcomm::Chan(&exit_po);\n-        let cycles = 5000u;\n-        for iter::repeat(cycles) {\n-            task::spawn_sched(task::ManualThreads(1u), || {\n-                impl_uv_hl_simple_timer(hl_loop);\n-                oldcomm::send(exit_ch, ());\n-            });\n-        };\n-        for iter::repeat(cycles) {\n-            oldcomm::recv(exit_po);\n-        };\n-        log(debug, ~\"test_stress_gl_uv_global_loop_high_level_global_timer\"+\n-            ~\" exiting sucessfully!\");\n+    fn test_stress_gl_uv_global_loop_high_level_global_timer() {\n+        unsafe {\n+            let hl_loop = get_gl();\n+            let exit_po = oldcomm::Port::<()>();\n+            let exit_ch = oldcomm::Chan(&exit_po);\n+            let cycles = 5000u;\n+            for iter::repeat(cycles) {\n+                task::spawn_sched(task::ManualThreads(1u), || {\n+                    impl_uv_hl_simple_timer(hl_loop);\n+                    oldcomm::send(exit_ch, ());\n+                });\n+            };\n+            for iter::repeat(cycles) {\n+                oldcomm::recv(exit_po);\n+            };\n+            log(debug,\n+                ~\"test_stress_gl_uv_global_loop_high_level_global_timer\"+\n+                ~\" exiting sucessfully!\");\n+        }\n     }\n }"}, {"sha": "667708cfb3fe9ff64c61c0e601b97d19f1272588", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 136, "deletions": 112, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -83,8 +83,10 @@ pub unsafe fn interact(iotask: IoTask,\n  * async handle and do a sanity check to make sure that all other handles are\n  * closed, causing a failure otherwise.\n  */\n-pub fn exit(iotask: IoTask) unsafe {\n-    send_msg(iotask, TeardownLoop);\n+pub fn exit(iotask: IoTask) {\n+    unsafe {\n+        send_msg(iotask, TeardownLoop);\n+    }\n }\n \n \n@@ -96,38 +98,39 @@ enum IoTaskMsg {\n }\n \n /// Run the loop and begin handling messages\n-fn run_loop(iotask_ch: Chan<IoTask>) unsafe {\n-\n-    let loop_ptr = ll::loop_new();\n-\n-    // set up the special async handle we'll use to allow multi-task\n-    // communication with this loop\n-    let async = ll::async_t();\n-    let async_handle = addr_of(&async);\n-\n-    // associate the async handle with the loop\n-    ll::async_init(loop_ptr, async_handle, wake_up_cb);\n-\n-    // initialize our loop data and store it in the loop\n-    let data: IoTaskLoopData = {\n-        async_handle: async_handle,\n-        msg_po: Port()\n-    };\n-    ll::set_data_for_uv_handle(async_handle, addr_of(&data));\n-\n-    // Send out a handle through which folks can talk to us\n-    // while we dwell in the I/O loop\n-    let iotask = IoTask_({\n-        async_handle: async_handle,\n-        op_chan: data.msg_po.chan()\n-    });\n-    iotask_ch.send(iotask);\n-\n-    log(debug, ~\"about to run uv loop\");\n-    // enter the loop... this blocks until the loop is done..\n-    ll::run(loop_ptr);\n-    log(debug, ~\"uv loop ended\");\n-    ll::loop_delete(loop_ptr);\n+fn run_loop(iotask_ch: Chan<IoTask>) {\n+    unsafe {\n+        let loop_ptr = ll::loop_new();\n+\n+        // set up the special async handle we'll use to allow multi-task\n+        // communication with this loop\n+        let async = ll::async_t();\n+        let async_handle = addr_of(&async);\n+\n+        // associate the async handle with the loop\n+        ll::async_init(loop_ptr, async_handle, wake_up_cb);\n+\n+        // initialize our loop data and store it in the loop\n+        let data: IoTaskLoopData = {\n+            async_handle: async_handle,\n+            msg_po: Port()\n+        };\n+        ll::set_data_for_uv_handle(async_handle, addr_of(&data));\n+\n+        // Send out a handle through which folks can talk to us\n+        // while we dwell in the I/O loop\n+        let iotask = IoTask_({\n+            async_handle: async_handle,\n+            op_chan: data.msg_po.chan()\n+        });\n+        iotask_ch.send(iotask);\n+\n+        log(debug, ~\"about to run uv loop\");\n+        // enter the loop... this blocks until the loop is done..\n+        ll::run(loop_ptr);\n+        log(debug, ~\"uv loop ended\");\n+        ll::loop_delete(loop_ptr);\n+    }\n }\n \n // data that lives for the lifetime of the high-evel oo\n@@ -136,43 +139,51 @@ type IoTaskLoopData = {\n     msg_po: Port<IoTaskMsg>\n };\n \n-fn send_msg(iotask: IoTask,\n-            msg: IoTaskMsg) unsafe {\n-    iotask.op_chan.send(move msg);\n-    ll::async_send(iotask.async_handle);\n+fn send_msg(iotask: IoTask, msg: IoTaskMsg) {\n+    unsafe {\n+        iotask.op_chan.send(move msg);\n+        ll::async_send(iotask.async_handle);\n+    }\n }\n \n /// Dispatch all pending messages\n extern fn wake_up_cb(async_handle: *ll::uv_async_t,\n-                    status: int) unsafe {\n-\n-    log(debug, fmt!(\"wake_up_cb extern.. handle: %? status: %?\",\n-                     async_handle, status));\n-\n-    let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n-    let data = ll::get_data_for_uv_handle(async_handle) as *IoTaskLoopData;\n-    let msg_po = (*data).msg_po;\n-\n-    while msg_po.peek() {\n-        match msg_po.recv() {\n-          Interaction(ref cb) => (*cb)(loop_ptr),\n-          TeardownLoop => begin_teardown(data)\n+                    status: int) {\n+    unsafe {\n+        log(debug, fmt!(\"wake_up_cb extern.. handle: %? status: %?\",\n+                         async_handle, status));\n+\n+        let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n+        let data = ll::get_data_for_uv_handle(async_handle)\n+            as *IoTaskLoopData;\n+        let msg_po = (*data).msg_po;\n+\n+        while msg_po.peek() {\n+            match msg_po.recv() {\n+              Interaction(ref cb) => (*cb)(loop_ptr),\n+              TeardownLoop => begin_teardown(data)\n+            }\n         }\n     }\n }\n \n-fn begin_teardown(data: *IoTaskLoopData) unsafe {\n-    log(debug, ~\"iotask begin_teardown() called, close async_handle\");\n-    let async_handle = (*data).async_handle;\n-    ll::close(async_handle as *c_void, tear_down_close_cb);\n+fn begin_teardown(data: *IoTaskLoopData) {\n+    unsafe {\n+        log(debug, ~\"iotask begin_teardown() called, close async_handle\");\n+        let async_handle = (*data).async_handle;\n+        ll::close(async_handle as *c_void, tear_down_close_cb);\n+    }\n }\n \n-extern fn tear_down_close_cb(handle: *ll::uv_async_t) unsafe {\n-    let loop_ptr = ll::get_loop_for_uv_handle(handle);\n-    let loop_refs = ll::loop_refcount(loop_ptr);\n-    log(debug, fmt!(\"tear_down_close_cb called, closing handle at %? refs %?\",\n-                    handle, loop_refs));\n-    assert loop_refs == 1i32;\n+extern fn tear_down_close_cb(handle: *ll::uv_async_t) {\n+    unsafe {\n+        let loop_ptr = ll::get_loop_for_uv_handle(handle);\n+        let loop_refs = ll::loop_refcount(loop_ptr);\n+        log(debug,\n+            fmt!(\"tear_down_close_cb called, closing handle at %? refs %?\",\n+                 handle, loop_refs));\n+        assert loop_refs == 1i32;\n+    }\n }\n \n #[cfg(test)]\n@@ -188,37 +199,46 @@ mod test {\n     use core::ptr;\n     use core::task;\n \n-    extern fn async_close_cb(handle: *ll::uv_async_t) unsafe {\n-        log(debug, fmt!(\"async_close_cb handle %?\", handle));\n-        let exit_ch = (*(ll::get_data_for_uv_handle(handle)\n-                        as *AhData)).exit_ch;\n-        oldcomm::send(exit_ch, ());\n+    extern fn async_close_cb(handle: *ll::uv_async_t) {\n+        unsafe {\n+            log(debug, fmt!(\"async_close_cb handle %?\", handle));\n+            let exit_ch = (*(ll::get_data_for_uv_handle(handle)\n+                            as *AhData)).exit_ch;\n+            oldcomm::send(exit_ch, ());\n+        }\n     }\n-    extern fn async_handle_cb(handle: *ll::uv_async_t, status: libc::c_int)\n+    extern fn async_handle_cb(handle: *ll::uv_async_t, status: libc::c_int) {\n         unsafe {\n-        log(debug, fmt!(\"async_handle_cb handle %? status %?\",handle,status));\n-        ll::close(handle, async_close_cb);\n+            log(debug,\n+                fmt!(\"async_handle_cb handle %? status %?\",handle,status));\n+            ll::close(handle, async_close_cb);\n+        }\n     }\n     type AhData = {\n         iotask: IoTask,\n         exit_ch: oldcomm::Chan<()>\n     };\n-    fn impl_uv_iotask_async(iotask: IoTask) unsafe {\n-        let async_handle = ll::async_t();\n-        let ah_ptr = ptr::addr_of(&async_handle);\n-        let exit_po = oldcomm::Port::<()>();\n-        let exit_ch = oldcomm::Chan(&exit_po);\n-        let ah_data = {\n-            iotask: iotask,\n-            exit_ch: exit_ch\n-        };\n-        let ah_data_ptr = ptr::addr_of(&ah_data);\n-        do interact(iotask) |loop_ptr| unsafe {\n-            ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n-            ll::set_data_for_uv_handle(ah_ptr, ah_data_ptr as *libc::c_void);\n-            ll::async_send(ah_ptr);\n-        };\n-        oldcomm::recv(exit_po);\n+    fn impl_uv_iotask_async(iotask: IoTask) {\n+        unsafe {\n+            let async_handle = ll::async_t();\n+            let ah_ptr = ptr::addr_of(&async_handle);\n+            let exit_po = oldcomm::Port::<()>();\n+            let exit_ch = oldcomm::Chan(&exit_po);\n+            let ah_data = {\n+                iotask: iotask,\n+                exit_ch: exit_ch\n+            };\n+            let ah_data_ptr = ptr::addr_of(&ah_data);\n+            do interact(iotask) |loop_ptr| {\n+                unsafe {\n+                    ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n+                    ll::set_data_for_uv_handle(ah_ptr,\n+                                               ah_data_ptr as *libc::c_void);\n+                    ll::async_send(ah_ptr);\n+                }\n+            };\n+            oldcomm::recv(exit_po);\n+        }\n     }\n \n     // this fn documents the bear minimum neccesary to roll your own\n@@ -233,8 +253,10 @@ mod test {\n         return oldcomm::recv(iotask_port);\n     }\n \n-    extern fn lifetime_handle_close(handle: *libc::c_void) unsafe {\n-        log(debug, fmt!(\"lifetime_handle_close ptr %?\", handle));\n+    extern fn lifetime_handle_close(handle: *libc::c_void) {\n+        unsafe {\n+            log(debug, fmt!(\"lifetime_handle_close ptr %?\", handle));\n+        }\n     }\n \n     extern fn lifetime_async_callback(handle: *libc::c_void,\n@@ -244,31 +266,33 @@ mod test {\n     }\n \n     #[test]\n-    fn test_uv_iotask_async() unsafe {\n-        let exit_po = oldcomm::Port::<()>();\n-        let exit_ch = oldcomm::Chan(&exit_po);\n-        let iotask = spawn_test_loop(exit_ch);\n-\n-        // using this handle to manage the lifetime of the high_level_loop,\n-        // as it will exit the first time one of the impl_uv_hl_async() is\n-        // cleaned up with no one ref'd handles on the loop (Which can happen\n-        // under race-condition type situations.. this ensures that the loop\n-        // lives until, at least, all of the impl_uv_hl_async() runs have been\n-        // called, at least.\n-        let work_exit_po = oldcomm::Port::<()>();\n-        let work_exit_ch = oldcomm::Chan(&work_exit_po);\n-        for iter::repeat(7u) {\n-            do task::spawn_sched(task::ManualThreads(1u)) {\n-                impl_uv_iotask_async(iotask);\n-                oldcomm::send(work_exit_ch, ());\n+    fn test_uv_iotask_async() {\n+        unsafe {\n+            let exit_po = oldcomm::Port::<()>();\n+            let exit_ch = oldcomm::Chan(&exit_po);\n+            let iotask = spawn_test_loop(exit_ch);\n+\n+            // using this handle to manage the lifetime of the\n+            // high_level_loop, as it will exit the first time one of the\n+            // impl_uv_hl_async() is cleaned up with no one ref'd handles on\n+            // the loop (Which can happen under race-condition type\n+            // situations.. this ensures that the loop lives until, at least,\n+            // all of the impl_uv_hl_async() runs have been called, at least.\n+            let work_exit_po = oldcomm::Port::<()>();\n+            let work_exit_ch = oldcomm::Chan(&work_exit_po);\n+            for iter::repeat(7u) {\n+                do task::spawn_sched(task::ManualThreads(1u)) {\n+                    impl_uv_iotask_async(iotask);\n+                    oldcomm::send(work_exit_ch, ());\n+                };\n             };\n-        };\n-        for iter::repeat(7u) {\n-            oldcomm::recv(work_exit_po);\n-        };\n-        log(debug, ~\"sending teardown_loop msg..\");\n-        exit(iotask);\n-        oldcomm::recv(exit_po);\n-        log(debug, ~\"after recv on exit_po.. exiting..\");\n+            for iter::repeat(7u) {\n+                oldcomm::recv(work_exit_po);\n+            };\n+            log(debug, ~\"sending teardown_loop msg..\");\n+            exit(iotask);\n+            oldcomm::recv(exit_po);\n+            log(debug, ~\"after recv on exit_po.. exiting..\");\n+        }\n     }\n }"}, {"sha": "17b11945028316412d17f24a9b4b90a67dfd6de8", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 413, "deletions": 382, "changes": 795, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -1103,304 +1103,325 @@ pub mod test {\n \n     extern fn on_alloc_cb(handle: *libc::c_void,\n                          suggested_size: libc::size_t)\n-        -> uv_buf_t unsafe {\n-        log(debug, ~\"on_alloc_cb!\");\n-        let char_ptr = malloc_buf_base_of(suggested_size);\n-        log(debug, fmt!(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n-                         handle,\n-                         char_ptr as uint,\n-                         suggested_size as uint));\n-        return buf_init(char_ptr, suggested_size as uint);\n+        -> uv_buf_t {\n+        unsafe {\n+            log(debug, ~\"on_alloc_cb!\");\n+            let char_ptr = malloc_buf_base_of(suggested_size);\n+            log(debug, fmt!(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n+                             handle,\n+                             char_ptr as uint,\n+                             suggested_size as uint));\n+            return buf_init(char_ptr, suggested_size as uint);\n+        }\n     }\n \n     extern fn on_read_cb(stream: *uv_stream_t,\n                         nread: libc::ssize_t,\n-                        ++buf: uv_buf_t) unsafe {\n-        let nread = nread as int;\n-        log(debug, fmt!(\"CLIENT entering on_read_cb nred: %d\",\n-                        nread));\n-        if (nread > 0) {\n-            // we have data\n-            log(debug, fmt!(\"CLIENT read: data! nread: %d\", nread));\n-            read_stop(stream);\n-            let client_data =\n-                get_data_for_uv_handle(stream as *libc::c_void)\n-                  as *request_wrapper;\n-            let buf_base = get_base_from_buf(buf);\n-            let buf_len = get_len_from_buf(buf);\n-            let bytes = vec::from_buf(buf_base, buf_len as uint);\n-            let read_chan = *((*client_data).read_chan);\n-            let msg_from_server = str::from_bytes(bytes);\n-            oldcomm::send(read_chan, msg_from_server);\n-            close(stream as *libc::c_void, after_close_cb)\n-        }\n-        else if (nread == -1) {\n-            // err .. possibly EOF\n-            log(debug, ~\"read: eof!\");\n-        }\n-        else {\n-            // nread == 0 .. do nothing, just free buf as below\n-            log(debug, ~\"read: do nothing!\");\n+                        ++buf: uv_buf_t) {\n+        unsafe {\n+            let nread = nread as int;\n+            log(debug, fmt!(\"CLIENT entering on_read_cb nred: %d\",\n+                            nread));\n+            if (nread > 0) {\n+                // we have data\n+                log(debug, fmt!(\"CLIENT read: data! nread: %d\", nread));\n+                read_stop(stream);\n+                let client_data =\n+                    get_data_for_uv_handle(stream as *libc::c_void)\n+                      as *request_wrapper;\n+                let buf_base = get_base_from_buf(buf);\n+                let buf_len = get_len_from_buf(buf);\n+                let bytes = vec::from_buf(buf_base, buf_len as uint);\n+                let read_chan = *((*client_data).read_chan);\n+                let msg_from_server = str::from_bytes(bytes);\n+                oldcomm::send(read_chan, msg_from_server);\n+                close(stream as *libc::c_void, after_close_cb)\n+            }\n+            else if (nread == -1) {\n+                // err .. possibly EOF\n+                log(debug, ~\"read: eof!\");\n+            }\n+            else {\n+                // nread == 0 .. do nothing, just free buf as below\n+                log(debug, ~\"read: do nothing!\");\n+            }\n+            // when we're done\n+            free_base_of_buf(buf);\n+            log(debug, ~\"CLIENT exiting on_read_cb\");\n         }\n-        // when we're done\n-        free_base_of_buf(buf);\n-        log(debug, ~\"CLIENT exiting on_read_cb\");\n     }\n \n     extern fn on_write_complete_cb(write_req: *uv_write_t,\n-                                  status: libc::c_int) unsafe {\n-        log(debug, fmt!(\"CLIENT beginning on_write_complete_cb status: %d\",\n-                         status as int));\n-        let stream = get_stream_handle_from_write_req(write_req);\n-        log(debug, fmt!(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n-            stream as int, write_req as int));\n-        let result = read_start(stream, on_alloc_cb, on_read_cb);\n-        log(debug, fmt!(\"CLIENT ending on_write_complete_cb .. status: %d\",\n-                         result as int));\n+                                  status: libc::c_int) {\n+        unsafe {\n+            log(debug,\n+                fmt!(\"CLIENT beginning on_write_complete_cb status: %d\",\n+                     status as int));\n+            let stream = get_stream_handle_from_write_req(write_req);\n+            log(debug,\n+                fmt!(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n+                stream as int, write_req as int));\n+            let result = read_start(stream, on_alloc_cb, on_read_cb);\n+            log(debug,\n+                fmt!(\"CLIENT ending on_write_complete_cb .. status: %d\",\n+                     result as int));\n+        }\n     }\n \n     extern fn on_connect_cb(connect_req_ptr: *uv_connect_t,\n-                                 status: libc::c_int) unsafe {\n-        log(debug, fmt!(\"beginning on_connect_cb .. status: %d\",\n-                         status as int));\n-        let stream =\n-            get_stream_handle_from_connect_req(connect_req_ptr);\n-        if (status == 0i32) {\n-            log(debug, ~\"on_connect_cb: in status=0 if..\");\n-            let client_data = get_data_for_req(\n-                connect_req_ptr as *libc::c_void)\n-                as *request_wrapper;\n-            let write_handle = (*client_data).write_req;\n-            log(debug, fmt!(\"on_connect_cb: tcp: %d write_hdl: %d\",\n-                            stream as int, write_handle as int));\n-            let write_result = write(write_handle,\n-                              stream as *libc::c_void,\n-                              (*client_data).req_buf,\n-                              on_write_complete_cb);\n-            log(debug, fmt!(\"on_connect_cb: write() status: %d\",\n-                             write_result as int));\n-        }\n-        else {\n-            let test_loop = get_loop_for_uv_handle(\n-                stream as *libc::c_void);\n-            let err_msg = get_last_err_info(test_loop);\n-            log(debug, err_msg);\n-            assert false;\n+                                 status: libc::c_int) {\n+        unsafe {\n+            log(debug, fmt!(\"beginning on_connect_cb .. status: %d\",\n+                             status as int));\n+            let stream =\n+                get_stream_handle_from_connect_req(connect_req_ptr);\n+            if (status == 0i32) {\n+                log(debug, ~\"on_connect_cb: in status=0 if..\");\n+                let client_data = get_data_for_req(\n+                    connect_req_ptr as *libc::c_void)\n+                    as *request_wrapper;\n+                let write_handle = (*client_data).write_req;\n+                log(debug, fmt!(\"on_connect_cb: tcp: %d write_hdl: %d\",\n+                                stream as int, write_handle as int));\n+                let write_result = write(write_handle,\n+                                  stream as *libc::c_void,\n+                                  (*client_data).req_buf,\n+                                  on_write_complete_cb);\n+                log(debug, fmt!(\"on_connect_cb: write() status: %d\",\n+                                 write_result as int));\n+            }\n+            else {\n+                let test_loop = get_loop_for_uv_handle(\n+                    stream as *libc::c_void);\n+                let err_msg = get_last_err_info(test_loop);\n+                log(debug, err_msg);\n+                assert false;\n+            }\n+            log(debug, ~\"finishing on_connect_cb\");\n         }\n-        log(debug, ~\"finishing on_connect_cb\");\n     }\n \n     fn impl_uv_tcp_request(ip: &str, port: int, req_str: &str,\n-                          client_chan: *oldcomm::Chan<~str>) unsafe {\n-        let test_loop = loop_new();\n-        let tcp_handle = tcp_t();\n-        let tcp_handle_ptr = ptr::addr_of(&tcp_handle);\n-        let connect_handle = connect_t();\n-        let connect_req_ptr = ptr::addr_of(&connect_handle);\n-\n-        // this is the persistent payload of data that we\n-        // need to pass around to get this example to work.\n-        // In C, this would be a malloc'd or stack-allocated\n-        // struct that we'd cast to a void* and store as the\n-        // data field in our uv_connect_t struct\n-        let req_str_bytes = str::to_bytes(req_str);\n-        let req_msg_ptr: *u8 = vec::raw::to_ptr(req_str_bytes);\n-        log(debug, fmt!(\"req_msg ptr: %u\", req_msg_ptr as uint));\n-        let req_msg = ~[\n-            buf_init(req_msg_ptr, vec::len(req_str_bytes))\n-        ];\n-        // this is the enclosing record, we'll pass a ptr to\n-        // this to C..\n-        let write_handle = write_t();\n-        let write_handle_ptr = ptr::addr_of(&write_handle);\n-        log(debug, fmt!(\"tcp req: tcp stream: %d write_handle: %d\",\n-                         tcp_handle_ptr as int,\n-                         write_handle_ptr as int));\n-        let client_data = { writer_handle: write_handle_ptr,\n-                    req_buf: ptr::addr_of(&req_msg),\n-                    read_chan: client_chan };\n-\n-        let tcp_init_result = tcp_init(\n-            test_loop as *libc::c_void, tcp_handle_ptr);\n-        if (tcp_init_result == 0i32) {\n-            log(debug, ~\"sucessful tcp_init_result\");\n-\n-            log(debug, ~\"building addr...\");\n-            let addr = ip4_addr(ip, port);\n-            // FIXME ref #2064\n-            let addr_ptr = ptr::addr_of(&addr);\n-            log(debug, fmt!(\"after build addr in rust. port: %u\",\n-                             addr.sin_port as uint));\n-\n-            // this should set up the connection request..\n-            log(debug, fmt!(\"b4 call tcp_connect connect cb: %u \",\n-                            on_connect_cb as uint));\n-            let tcp_connect_result = tcp_connect(\n-                connect_req_ptr, tcp_handle_ptr,\n-                addr_ptr, on_connect_cb);\n-            if (tcp_connect_result == 0i32) {\n-                // not set the data on the connect_req\n-                // until its initialized\n-                set_data_for_req(\n-                    connect_req_ptr as *libc::c_void,\n-                    ptr::addr_of(&client_data) as *libc::c_void);\n-                set_data_for_uv_handle(\n-                    tcp_handle_ptr as *libc::c_void,\n-                    ptr::addr_of(&client_data) as *libc::c_void);\n-                log(debug, ~\"before run tcp req loop\");\n-                run(test_loop);\n-                log(debug, ~\"after run tcp req loop\");\n+                          client_chan: *oldcomm::Chan<~str>) {\n+        unsafe {\n+            let test_loop = loop_new();\n+            let tcp_handle = tcp_t();\n+            let tcp_handle_ptr = ptr::addr_of(&tcp_handle);\n+            let connect_handle = connect_t();\n+            let connect_req_ptr = ptr::addr_of(&connect_handle);\n+\n+            // this is the persistent payload of data that we\n+            // need to pass around to get this example to work.\n+            // In C, this would be a malloc'd or stack-allocated\n+            // struct that we'd cast to a void* and store as the\n+            // data field in our uv_connect_t struct\n+            let req_str_bytes = str::to_bytes(req_str);\n+            let req_msg_ptr: *u8 = vec::raw::to_ptr(req_str_bytes);\n+            log(debug, fmt!(\"req_msg ptr: %u\", req_msg_ptr as uint));\n+            let req_msg = ~[\n+                buf_init(req_msg_ptr, vec::len(req_str_bytes))\n+            ];\n+            // this is the enclosing record, we'll pass a ptr to\n+            // this to C..\n+            let write_handle = write_t();\n+            let write_handle_ptr = ptr::addr_of(&write_handle);\n+            log(debug, fmt!(\"tcp req: tcp stream: %d write_handle: %d\",\n+                             tcp_handle_ptr as int,\n+                             write_handle_ptr as int));\n+            let client_data = { writer_handle: write_handle_ptr,\n+                        req_buf: ptr::addr_of(&req_msg),\n+                        read_chan: client_chan };\n+\n+            let tcp_init_result = tcp_init(\n+                test_loop as *libc::c_void, tcp_handle_ptr);\n+            if (tcp_init_result == 0i32) {\n+                log(debug, ~\"sucessful tcp_init_result\");\n+\n+                log(debug, ~\"building addr...\");\n+                let addr = ip4_addr(ip, port);\n+                // FIXME ref #2064\n+                let addr_ptr = ptr::addr_of(&addr);\n+                log(debug, fmt!(\"after build addr in rust. port: %u\",\n+                                 addr.sin_port as uint));\n+\n+                // this should set up the connection request..\n+                log(debug, fmt!(\"b4 call tcp_connect connect cb: %u \",\n+                                on_connect_cb as uint));\n+                let tcp_connect_result = tcp_connect(\n+                    connect_req_ptr, tcp_handle_ptr,\n+                    addr_ptr, on_connect_cb);\n+                if (tcp_connect_result == 0i32) {\n+                    // not set the data on the connect_req\n+                    // until its initialized\n+                    set_data_for_req(\n+                        connect_req_ptr as *libc::c_void,\n+                        ptr::addr_of(&client_data) as *libc::c_void);\n+                    set_data_for_uv_handle(\n+                        tcp_handle_ptr as *libc::c_void,\n+                        ptr::addr_of(&client_data) as *libc::c_void);\n+                    log(debug, ~\"before run tcp req loop\");\n+                    run(test_loop);\n+                    log(debug, ~\"after run tcp req loop\");\n+                }\n+                else {\n+                   log(debug, ~\"tcp_connect() failure\");\n+                   assert false;\n+                }\n             }\n             else {\n-               log(debug, ~\"tcp_connect() failure\");\n-               assert false;\n+                log(debug, ~\"tcp_init() failure\");\n+                assert false;\n             }\n+            loop_delete(test_loop);\n         }\n-        else {\n-            log(debug, ~\"tcp_init() failure\");\n-            assert false;\n-        }\n-        loop_delete(test_loop);\n-\n     }\n \n-    extern fn server_after_close_cb(handle: *libc::c_void) unsafe {\n-        log(debug, fmt!(\"SERVER server stream closed, should exit.. h: %?\",\n-                   handle));\n+    extern fn server_after_close_cb(handle: *libc::c_void) {\n+        unsafe {\n+            log(debug, fmt!(\"SERVER server stream closed, should exit. h: %?\",\n+                       handle));\n+        }\n     }\n \n-    extern fn client_stream_after_close_cb(handle: *libc::c_void)\n+    extern fn client_stream_after_close_cb(handle: *libc::c_void) {\n         unsafe {\n-        log(debug,\n-            ~\"SERVER: closed client stream, now closing server stream\");\n-        let client_data = get_data_for_uv_handle(\n-            handle) as\n-            *tcp_server_data;\n-        close((*client_data).server as *libc::c_void,\n-                      server_after_close_cb);\n+            log(debug,\n+                ~\"SERVER: closed client stream, now closing server stream\");\n+            let client_data = get_data_for_uv_handle(\n+                handle) as\n+                *tcp_server_data;\n+            close((*client_data).server as *libc::c_void,\n+                          server_after_close_cb);\n+        }\n     }\n \n-    extern fn after_server_resp_write(req: *uv_write_t) unsafe {\n-        let client_stream_ptr =\n-            get_stream_handle_from_write_req(req);\n-        log(debug, ~\"SERVER: resp sent... closing client stream\");\n-        close(client_stream_ptr as *libc::c_void,\n-                      client_stream_after_close_cb)\n+    extern fn after_server_resp_write(req: *uv_write_t) {\n+        unsafe {\n+            let client_stream_ptr =\n+                get_stream_handle_from_write_req(req);\n+            log(debug, ~\"SERVER: resp sent... closing client stream\");\n+            close(client_stream_ptr as *libc::c_void,\n+                          client_stream_after_close_cb)\n+        }\n     }\n \n     extern fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n                                nread: libc::ssize_t,\n-                               ++buf: uv_buf_t) unsafe {\n-        let nread = nread as int;\n-        if (nread > 0) {\n-            // we have data\n-            log(debug, fmt!(\"SERVER read: data! nread: %d\", nread));\n-\n-            // pull out the contents of the write from the client\n-            let buf_base = get_base_from_buf(buf);\n-            let buf_len = get_len_from_buf(buf) as uint;\n-            log(debug, fmt!(\"SERVER buf base: %u, len: %u, nread: %d\",\n-                            buf_base as uint,\n-                            buf_len as uint,\n-                            nread));\n-            let bytes = vec::from_buf(buf_base, buf_len);\n-            let request_str = str::from_bytes(bytes);\n-\n-            let client_data = get_data_for_uv_handle(\n-                client_stream_ptr as *libc::c_void) as *tcp_server_data;\n-\n-            let server_kill_msg = (*client_data).server_kill_msg;\n-            let write_req = (*client_data).server_write_req;\n-            if (str::contains(request_str, server_kill_msg)) {\n-                log(debug, ~\"SERVER: client req contains kill_msg!\");\n-                log(debug, ~\"SERVER: sending response to client\");\n-                read_stop(client_stream_ptr);\n-                let server_chan = *((*client_data).server_chan);\n-                oldcomm::send(server_chan, request_str);\n-                let write_result = write(\n-                    write_req,\n-                    client_stream_ptr as *libc::c_void,\n-                    (*client_data).server_resp_buf,\n-                    after_server_resp_write);\n-                log(debug, fmt!(\"SERVER: resp write result: %d\",\n-                            write_result as int));\n-                if (write_result != 0i32) {\n-                    log(debug, ~\"bad result for server resp write()\");\n-                    log(debug, get_last_err_info(\n-                        get_loop_for_uv_handle(client_stream_ptr\n-                            as *libc::c_void)));\n-                    assert false;\n+                               ++buf: uv_buf_t) {\n+        unsafe {\n+            let nread = nread as int;\n+            if (nread > 0) {\n+                // we have data\n+                log(debug, fmt!(\"SERVER read: data! nread: %d\", nread));\n+\n+                // pull out the contents of the write from the client\n+                let buf_base = get_base_from_buf(buf);\n+                let buf_len = get_len_from_buf(buf) as uint;\n+                log(debug, fmt!(\"SERVER buf base: %u, len: %u, nread: %d\",\n+                                buf_base as uint,\n+                                buf_len as uint,\n+                                nread));\n+                let bytes = vec::from_buf(buf_base, buf_len);\n+                let request_str = str::from_bytes(bytes);\n+\n+                let client_data = get_data_for_uv_handle(\n+                    client_stream_ptr as *libc::c_void) as *tcp_server_data;\n+\n+                let server_kill_msg = (*client_data).server_kill_msg;\n+                let write_req = (*client_data).server_write_req;\n+                if (str::contains(request_str, server_kill_msg)) {\n+                    log(debug, ~\"SERVER: client req contains kill_msg!\");\n+                    log(debug, ~\"SERVER: sending response to client\");\n+                    read_stop(client_stream_ptr);\n+                    let server_chan = *((*client_data).server_chan);\n+                    oldcomm::send(server_chan, request_str);\n+                    let write_result = write(\n+                        write_req,\n+                        client_stream_ptr as *libc::c_void,\n+                        (*client_data).server_resp_buf,\n+                        after_server_resp_write);\n+                    log(debug, fmt!(\"SERVER: resp write result: %d\",\n+                                write_result as int));\n+                    if (write_result != 0i32) {\n+                        log(debug, ~\"bad result for server resp write()\");\n+                        log(debug, get_last_err_info(\n+                            get_loop_for_uv_handle(client_stream_ptr\n+                                as *libc::c_void)));\n+                        assert false;\n+                    }\n+                }\n+                else {\n+                    log(debug, ~\"SERVER: client req !contain kill_msg!\");\n                 }\n             }\n+            else if (nread == -1) {\n+                // err .. possibly EOF\n+                log(debug, ~\"read: eof!\");\n+            }\n             else {\n-                log(debug, ~\"SERVER: client req !contain kill_msg!\");\n+                // nread == 0 .. do nothing, just free buf as below\n+                log(debug, ~\"read: do nothing!\");\n             }\n+            // when we're done\n+            free_base_of_buf(buf);\n+            log(debug, ~\"SERVER exiting on_read_cb\");\n         }\n-        else if (nread == -1) {\n-            // err .. possibly EOF\n-            log(debug, ~\"read: eof!\");\n-        }\n-        else {\n-            // nread == 0 .. do nothing, just free buf as below\n-            log(debug, ~\"read: do nothing!\");\n-        }\n-        // when we're done\n-        free_base_of_buf(buf);\n-        log(debug, ~\"SERVER exiting on_read_cb\");\n     }\n \n     extern fn server_connection_cb(server_stream_ptr:\n                                     *uv_stream_t,\n-                                  status: libc::c_int) unsafe {\n-        log(debug, ~\"client connecting!\");\n-        let test_loop = get_loop_for_uv_handle(\n-                               server_stream_ptr as *libc::c_void);\n-        if status != 0i32 {\n-            let err_msg = get_last_err_info(test_loop);\n-            log(debug, fmt!(\"server_connect_cb: non-zero status: %?\",\n-                         err_msg));\n-            return;\n-        }\n-        let server_data = get_data_for_uv_handle(\n-            server_stream_ptr as *libc::c_void) as *tcp_server_data;\n-        let client_stream_ptr = (*server_data).client;\n-        let client_init_result = tcp_init(test_loop,\n-                                                  client_stream_ptr);\n-        set_data_for_uv_handle(\n-            client_stream_ptr as *libc::c_void,\n-            server_data as *libc::c_void);\n-        if (client_init_result == 0i32) {\n-            log(debug, ~\"successfully initialized client stream\");\n-            let accept_result = accept(server_stream_ptr as\n-                                                 *libc::c_void,\n-                                               client_stream_ptr as\n-                                                 *libc::c_void);\n-            if (accept_result == 0i32) {\n-                // start reading\n-                let read_result = read_start(\n-                    client_stream_ptr as *uv_stream_t,\n-                                                     on_alloc_cb,\n-                                                     on_server_read_cb);\n-                if (read_result == 0i32) {\n-                    log(debug, ~\"successful server read start\");\n+                                  status: libc::c_int) {\n+        unsafe {\n+            log(debug, ~\"client connecting!\");\n+            let test_loop = get_loop_for_uv_handle(\n+                                   server_stream_ptr as *libc::c_void);\n+            if status != 0i32 {\n+                let err_msg = get_last_err_info(test_loop);\n+                log(debug, fmt!(\"server_connect_cb: non-zero status: %?\",\n+                             err_msg));\n+                return;\n+            }\n+            let server_data = get_data_for_uv_handle(\n+                server_stream_ptr as *libc::c_void) as *tcp_server_data;\n+            let client_stream_ptr = (*server_data).client;\n+            let client_init_result = tcp_init(test_loop,\n+                                                      client_stream_ptr);\n+            set_data_for_uv_handle(\n+                client_stream_ptr as *libc::c_void,\n+                server_data as *libc::c_void);\n+            if (client_init_result == 0i32) {\n+                log(debug, ~\"successfully initialized client stream\");\n+                let accept_result = accept(server_stream_ptr as\n+                                                     *libc::c_void,\n+                                                   client_stream_ptr as\n+                                                     *libc::c_void);\n+                if (accept_result == 0i32) {\n+                    // start reading\n+                    let read_result = read_start(\n+                        client_stream_ptr as *uv_stream_t,\n+                                                         on_alloc_cb,\n+                                                         on_server_read_cb);\n+                    if (read_result == 0i32) {\n+                        log(debug, ~\"successful server read start\");\n+                    }\n+                    else {\n+                        log(debug, fmt!(\"server_connection_cb: bad read:%d\",\n+                                        read_result as int));\n+                        assert false;\n+                    }\n                 }\n                 else {\n-                    log(debug, fmt!(\"server_connection_cb: bad read:%d\",\n-                                    read_result as int));\n+                    log(debug, fmt!(\"server_connection_cb: bad accept: %d\",\n+                                accept_result as int));\n                     assert false;\n                 }\n             }\n             else {\n-                log(debug, fmt!(\"server_connection_cb: bad accept: %d\",\n-                            accept_result as int));\n+                log(debug, fmt!(\"server_connection_cb: bad client init: %d\",\n+                            client_init_result as int));\n                 assert false;\n             }\n         }\n-        else {\n-            log(debug, fmt!(\"server_connection_cb: bad client init: %d\",\n-                        client_init_result as int));\n-            assert false;\n-        }\n     }\n \n     type tcp_server_data = {\n@@ -1422,162 +1443,168 @@ pub mod test {\n     }\n \n     extern fn continue_async_cb(async_handle: *uv_async_t,\n-                               status: libc::c_int) unsafe {\n-        // once we're in the body of this callback,\n-        // the tcp server's loop is set up, so we\n-        // can continue on to let the tcp client\n-        // do its thang\n-        let data = get_data_for_uv_handle(\n-            async_handle as *libc::c_void) as *async_handle_data;\n-        let continue_chan = *((*data).continue_chan);\n-        let should_continue = status == 0i32;\n-        oldcomm::send(continue_chan, should_continue);\n-        close(async_handle as *libc::c_void, async_close_cb);\n+                               status: libc::c_int) {\n+        unsafe {\n+            // once we're in the body of this callback,\n+            // the tcp server's loop is set up, so we\n+            // can continue on to let the tcp client\n+            // do its thang\n+            let data = get_data_for_uv_handle(\n+                async_handle as *libc::c_void) as *async_handle_data;\n+            let continue_chan = *((*data).continue_chan);\n+            let should_continue = status == 0i32;\n+            oldcomm::send(continue_chan, should_continue);\n+            close(async_handle as *libc::c_void, async_close_cb);\n+        }\n     }\n \n     fn impl_uv_tcp_server(server_ip: &str,\n                           server_port: int,\n                           +kill_server_msg: ~str,\n                           +server_resp_msg: ~str,\n                           server_chan: *oldcomm::Chan<~str>,\n-                          continue_chan: *oldcomm::Chan<bool>) unsafe {\n-        let test_loop = loop_new();\n-        let tcp_server = tcp_t();\n-        let tcp_server_ptr = ptr::addr_of(&tcp_server);\n-\n-        let tcp_client = tcp_t();\n-        let tcp_client_ptr = ptr::addr_of(&tcp_client);\n-\n-        let server_write_req = write_t();\n-        let server_write_req_ptr = ptr::addr_of(&server_write_req);\n-\n-        let resp_str_bytes = str::to_bytes(server_resp_msg);\n-        let resp_msg_ptr: *u8 = vec::raw::to_ptr(resp_str_bytes);\n-        log(debug, fmt!(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n-        let resp_msg = ~[\n-            buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n-        ];\n-\n-        let continue_async_handle = async_t();\n-        let continue_async_handle_ptr =\n-            ptr::addr_of(&continue_async_handle);\n-        let async_data =\n-            { continue_chan: continue_chan };\n-        let async_data_ptr = ptr::addr_of(&async_data);\n-\n-        let server_data: tcp_server_data = {\n-            client: tcp_client_ptr,\n-            server: tcp_server_ptr,\n-            server_kill_msg: kill_server_msg,\n-            server_resp_buf: ptr::addr_of(&resp_msg),\n-            server_chan: server_chan,\n-            server_write_req: server_write_req_ptr\n-        };\n-        let server_data_ptr = ptr::addr_of(&server_data);\n-        set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n-                                       server_data_ptr as *libc::c_void);\n-\n-        // uv_tcp_init()\n-        let tcp_init_result = tcp_init(\n-            test_loop as *libc::c_void, tcp_server_ptr);\n-        if (tcp_init_result == 0i32) {\n-            let server_addr = ip4_addr(server_ip, server_port);\n-            // FIXME ref #2064\n-            let server_addr_ptr = ptr::addr_of(&server_addr);\n-\n-            // uv_tcp_bind()\n-            let bind_result = tcp_bind(tcp_server_ptr,\n-                                               server_addr_ptr);\n-            if (bind_result == 0i32) {\n-                log(debug, ~\"successful uv_tcp_bind, listening\");\n-\n-                // uv_listen()\n-                let listen_result = listen(tcp_server_ptr as\n-                                                     *libc::c_void,\n-                                                   128i32,\n-                                                   server_connection_cb);\n-                if (listen_result == 0i32) {\n-                    // let the test know it can set up the tcp server,\n-                    // now.. this may still present a race, not sure..\n-                    let async_result = async_init(test_loop,\n-                                       continue_async_handle_ptr,\n-                                       continue_async_cb);\n-                    if (async_result == 0i32) {\n-                        set_data_for_uv_handle(\n-                            continue_async_handle_ptr as *libc::c_void,\n-                            async_data_ptr as *libc::c_void);\n-                        async_send(continue_async_handle_ptr);\n-                        // uv_run()\n-                        run(test_loop);\n-                        log(debug, ~\"server uv::run() has returned\");\n+                          continue_chan: *oldcomm::Chan<bool>) {\n+        unsafe {\n+            let test_loop = loop_new();\n+            let tcp_server = tcp_t();\n+            let tcp_server_ptr = ptr::addr_of(&tcp_server);\n+\n+            let tcp_client = tcp_t();\n+            let tcp_client_ptr = ptr::addr_of(&tcp_client);\n+\n+            let server_write_req = write_t();\n+            let server_write_req_ptr = ptr::addr_of(&server_write_req);\n+\n+            let resp_str_bytes = str::to_bytes(server_resp_msg);\n+            let resp_msg_ptr: *u8 = vec::raw::to_ptr(resp_str_bytes);\n+            log(debug, fmt!(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n+            let resp_msg = ~[\n+                buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n+            ];\n+\n+            let continue_async_handle = async_t();\n+            let continue_async_handle_ptr =\n+                ptr::addr_of(&continue_async_handle);\n+            let async_data =\n+                { continue_chan: continue_chan };\n+            let async_data_ptr = ptr::addr_of(&async_data);\n+\n+            let server_data: tcp_server_data = {\n+                client: tcp_client_ptr,\n+                server: tcp_server_ptr,\n+                server_kill_msg: kill_server_msg,\n+                server_resp_buf: ptr::addr_of(&resp_msg),\n+                server_chan: server_chan,\n+                server_write_req: server_write_req_ptr\n+            };\n+            let server_data_ptr = ptr::addr_of(&server_data);\n+            set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n+                                           server_data_ptr as *libc::c_void);\n+\n+            // uv_tcp_init()\n+            let tcp_init_result = tcp_init(\n+                test_loop as *libc::c_void, tcp_server_ptr);\n+            if (tcp_init_result == 0i32) {\n+                let server_addr = ip4_addr(server_ip, server_port);\n+                // FIXME ref #2064\n+                let server_addr_ptr = ptr::addr_of(&server_addr);\n+\n+                // uv_tcp_bind()\n+                let bind_result = tcp_bind(tcp_server_ptr,\n+                                                   server_addr_ptr);\n+                if (bind_result == 0i32) {\n+                    log(debug, ~\"successful uv_tcp_bind, listening\");\n+\n+                    // uv_listen()\n+                    let listen_result = listen(tcp_server_ptr as\n+                                                         *libc::c_void,\n+                                                       128i32,\n+                                                       server_connection_cb);\n+                    if (listen_result == 0i32) {\n+                        // let the test know it can set up the tcp server,\n+                        // now.. this may still present a race, not sure..\n+                        let async_result = async_init(test_loop,\n+                                           continue_async_handle_ptr,\n+                                           continue_async_cb);\n+                        if (async_result == 0i32) {\n+                            set_data_for_uv_handle(\n+                                continue_async_handle_ptr as *libc::c_void,\n+                                async_data_ptr as *libc::c_void);\n+                            async_send(continue_async_handle_ptr);\n+                            // uv_run()\n+                            run(test_loop);\n+                            log(debug, ~\"server uv::run() has returned\");\n+                        }\n+                        else {\n+                            log(debug, fmt!(\"uv_async_init failure: %d\",\n+                                    async_result as int));\n+                            assert false;\n+                        }\n                     }\n                     else {\n-                        log(debug, fmt!(\"uv_async_init failure: %d\",\n-                                async_result as int));\n+                        log(debug, fmt!(\"non-zero result on uv_listen: %d\",\n+                                    listen_result as int));\n                         assert false;\n                     }\n                 }\n                 else {\n-                    log(debug, fmt!(\"non-zero result on uv_listen: %d\",\n-                                listen_result as int));\n+                    log(debug, fmt!(\"non-zero result on uv_tcp_bind: %d\",\n+                                bind_result as int));\n                     assert false;\n                 }\n             }\n             else {\n-                log(debug, fmt!(\"non-zero result on uv_tcp_bind: %d\",\n-                            bind_result as int));\n+                log(debug, fmt!(\"non-zero result on uv_tcp_init: %d\",\n+                            tcp_init_result as int));\n                 assert false;\n             }\n+            loop_delete(test_loop);\n         }\n-        else {\n-            log(debug, fmt!(\"non-zero result on uv_tcp_init: %d\",\n-                        tcp_init_result as int));\n-            assert false;\n-        }\n-        loop_delete(test_loop);\n     }\n \n     // this is the impl for a test that is (maybe) ran on a\n     // per-platform/arch basis below\n-    fn impl_uv_tcp_server_and_request() unsafe {\n-        let bind_ip = ~\"0.0.0.0\";\n-        let request_ip = ~\"127.0.0.1\";\n-        let port = 8886;\n-        let kill_server_msg = ~\"does a dog have buddha nature?\";\n-        let server_resp_msg = ~\"mu!\";\n-        let client_port = oldcomm::Port::<~str>();\n-        let client_chan = oldcomm::Chan::<~str>(&client_port);\n-        let server_port = oldcomm::Port::<~str>();\n-        let server_chan = oldcomm::Chan::<~str>(&server_port);\n-\n-        let continue_port = oldcomm::Port::<bool>();\n-        let continue_chan = oldcomm::Chan::<bool>(&continue_port);\n-        let continue_chan_ptr = ptr::addr_of(&continue_chan);\n-\n-        do task::spawn_sched(task::ManualThreads(1)) {\n-            impl_uv_tcp_server(bind_ip, port,\n-                               kill_server_msg,\n-                               server_resp_msg,\n-                               ptr::addr_of(&server_chan),\n-                               continue_chan_ptr);\n-        };\n+    fn impl_uv_tcp_server_and_request() {\n+        unsafe {\n+            let bind_ip = ~\"0.0.0.0\";\n+            let request_ip = ~\"127.0.0.1\";\n+            let port = 8886;\n+            let kill_server_msg = ~\"does a dog have buddha nature?\";\n+            let server_resp_msg = ~\"mu!\";\n+            let client_port = oldcomm::Port::<~str>();\n+            let client_chan = oldcomm::Chan::<~str>(&client_port);\n+            let server_port = oldcomm::Port::<~str>();\n+            let server_chan = oldcomm::Chan::<~str>(&server_port);\n+\n+            let continue_port = oldcomm::Port::<bool>();\n+            let continue_chan = oldcomm::Chan::<bool>(&continue_port);\n+            let continue_chan_ptr = ptr::addr_of(&continue_chan);\n+\n+            do task::spawn_sched(task::ManualThreads(1)) {\n+                impl_uv_tcp_server(bind_ip, port,\n+                                   kill_server_msg,\n+                                   server_resp_msg,\n+                                   ptr::addr_of(&server_chan),\n+                                   continue_chan_ptr);\n+            };\n \n-        // block until the server up is.. possibly a race?\n-        log(debug, ~\"before receiving on server continue_port\");\n-        oldcomm::recv(continue_port);\n-        log(debug, ~\"received on continue port, set up tcp client\");\n+            // block until the server up is.. possibly a race?\n+            log(debug, ~\"before receiving on server continue_port\");\n+            oldcomm::recv(continue_port);\n+            log(debug, ~\"received on continue port, set up tcp client\");\n \n-        do task::spawn_sched(task::ManualThreads(1u)) {\n-            impl_uv_tcp_request(request_ip, port,\n-                               kill_server_msg,\n-                               ptr::addr_of(&client_chan));\n-        };\n+            do task::spawn_sched(task::ManualThreads(1u)) {\n+                impl_uv_tcp_request(request_ip, port,\n+                                   kill_server_msg,\n+                                   ptr::addr_of(&client_chan));\n+            };\n \n-        let msg_from_client = oldcomm::recv(server_port);\n-        let msg_from_server = oldcomm::recv(client_port);\n+            let msg_from_client = oldcomm::recv(server_port);\n+            let msg_from_server = oldcomm::recv(client_port);\n \n-        assert str::contains(msg_from_client, kill_server_msg);\n-        assert str::contains(msg_from_server, server_resp_msg);\n+            assert str::contains(msg_from_client, kill_server_msg);\n+            assert str::contains(msg_from_server, server_resp_msg);\n+        }\n     }\n \n     // FIXME don't run on fbsd or linux 32 bit(#2064)\n@@ -1590,8 +1617,10 @@ pub mod test {\n         pub mod impl64 {\n             use uv_ll::test::*;\n             #[test]\n-            pub fn test_uv_ll_tcp_server_and_request() unsafe {\n-                impl_uv_tcp_server_and_request();\n+            pub fn test_uv_ll_tcp_server_and_request() {\n+                unsafe {\n+                    impl_uv_tcp_server_and_request();\n+                }\n             }\n         }\n         #[cfg(target_arch=\"x86\")]\n@@ -1600,8 +1629,10 @@ pub mod test {\n             use uv_ll::test::*;\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n-            pub fn test_uv_ll_tcp_server_and_request() unsafe {\n-                impl_uv_tcp_server_and_request();\n+            pub fn test_uv_ll_tcp_server_and_request() {\n+                unsafe {\n+                    impl_uv_tcp_server_and_request();\n+                }\n             }\n         }\n     }"}, {"sha": "7a7c2312f5640714418ce7e201eb3912ef4445b6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -208,14 +208,16 @@ pub impl FileMap {\n         self.lines.push(pos);\n     }\n \n-    pub fn get_line(&self, line: int) -> ~str unsafe {\n-        let begin: BytePos = self.lines[line] - self.start_pos;\n-        let begin = begin.to_uint();\n-        let end = match str::find_char_from(*self.src, '\\n', begin) {\n-            Some(e) => e,\n-            None => str::len(*self.src)\n-        };\n-        str::slice(*self.src, begin, end)\n+    pub fn get_line(&self, line: int) -> ~str {\n+        unsafe {\n+            let begin: BytePos = self.lines[line] - self.start_pos;\n+            let begin = begin.to_uint();\n+            let end = match str::find_char_from(*self.src, '\\n', begin) {\n+                Some(e) => e,\n+                None => str::len(*self.src)\n+            };\n+            str::slice(*self.src, begin, end)\n+        }\n     }\n \n     pub fn record_multibyte_char(&self, pos: BytePos, bytes: uint) {"}, {"sha": "1574a037a4638074db8deaeaeea731d042d382b9", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -157,11 +157,13 @@ fn byte_offset(rdr: string_reader) -> BytePos {\n     (rdr.pos - rdr.filemap.start_pos)\n }\n \n-fn get_str_from(rdr: string_reader, start: BytePos) -> ~str unsafe {\n-    // I'm pretty skeptical about this subtraction. What if there's a\n-    // multi-byte character before the mark?\n-    return str::slice(*rdr.src, start.to_uint() - 1u,\n-                      byte_offset(rdr).to_uint() - 1u);\n+fn get_str_from(rdr: string_reader, start: BytePos) -> ~str {\n+    unsafe {\n+        // I'm pretty skeptical about this subtraction. What if there's a\n+        // multi-byte character before the mark?\n+        return str::slice(*rdr.src, start.to_uint() - 1u,\n+                          byte_offset(rdr).to_uint() - 1u);\n+    }\n }\n \n fn bump(rdr: string_reader) {"}, {"sha": "67f6c4bed3f95f89d5d382b9f14dabee86a2c905", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -44,7 +44,8 @@ pub enum ObsoleteSyntax {\n     ObsoletePrivSection,\n     ObsoleteModeInFnType,\n     ObsoleteMoveInit,\n-    ObsoleteBinaryMove\n+    ObsoleteBinaryMove,\n+    ObsoleteUnsafeBlock\n }\n \n impl ObsoleteSyntax : cmp::Eq {\n@@ -118,6 +119,10 @@ impl Parser {\n             ObsoleteBinaryMove => (\n                 \"binary move\",\n                 \"Write `foo = move bar` instead\"\n+            ),\n+            ObsoleteUnsafeBlock => (\n+                \"non-standalone unsafe block\",\n+                \"use an inner `unsafe { ... }` block instead\"\n             )\n         };\n "}, {"sha": "4b8aa5c3f310da82945eeef03b1e35a98e73ebe7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -69,6 +69,7 @@ use parse::obsolete::{ObsoleteLet, ObsoleteFieldTerminator};\n use parse::obsolete::{ObsoleteMoveInit, ObsoleteBinaryMove};\n use parse::obsolete::{ObsoleteStructCtor, ObsoleteWith, ObsoleteClassMethod};\n use parse::obsolete::{ObsoleteSyntax, ObsoleteLowerCaseKindBounds};\n+use parse::obsolete::{ObsoleteUnsafeBlock};\n use parse::prec::{as_prec, token_to_binop};\n use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, special_idents};\n@@ -2336,12 +2337,13 @@ impl Parser {\n         }\n \n         let lo = self.span.lo;\n-        let us = self.eat_keyword(~\"unsafe\");\n+        if self.eat_keyword(~\"unsafe\") {\n+            self.obsolete(copy self.span, ObsoleteUnsafeBlock);\n+        }\n         self.expect(token::LBRACE);\n         let {inner: move inner, next: move next} =\n             maybe_parse_inner_attrs_and_next(self, parse_attrs);\n-        let blk_check_mode = if us { unsafe_blk } else { default_blk };\n-        return (inner, self.parse_block_tail_(lo, blk_check_mode, next));\n+        return (inner, self.parse_block_tail_(lo, default_blk, next));\n     }\n \n     fn parse_block_no_value() -> blk {"}, {"sha": "b6a9bce934fa9d4f2e9e034b6421a104d2dee650", "filename": "src/test/run-fail/too-much-recursion-unwinding.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-fail%2Ftoo-much-recursion-unwinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-fail%2Ftoo-much-recursion-unwinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftoo-much-recursion-unwinding.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -21,20 +21,24 @@ fn recurse() {\n \n struct r {\n     recursed: *mut bool,\n-    drop unsafe { \n-        if !*(self.recursed) {\n-            *(self.recursed) = true;\n-            recurse();\n+    drop {\n+        unsafe {\n+            if !*(self.recursed) {\n+                *(self.recursed) = true;\n+                recurse();\n+            }\n         }\n     }\n }\n \n-fn r(recursed: *mut bool) -> r unsafe {\n-    r { recursed: recursed }\n+fn r(recursed: *mut bool) -> r {\n+    unsafe {\n+        r { recursed: recursed }\n+    }\n }\n \n fn main() {\n     let mut recursed = false;\n     let _r = r(ptr::mut_addr_of(&recursed));\n     recurse();\n-}\n\\ No newline at end of file\n+}"}, {"sha": "b38651b3165ef803b9bb80176dccd0be2a6247c1", "filename": "src/test/run-fail/unwind-box-res.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-res.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -32,11 +32,13 @@ fn r(v: *int) -> r {\n     }\n }\n \n-fn main() unsafe {\n-    let i1 = ~0;\n-    let i1p = cast::reinterpret_cast(&i1);\n-    cast::forget(move i1);\n-    let x = @r(i1p);\n-    failfn();\n-    log(error, x);\n+fn main() {\n+    unsafe {\n+        let i1 = ~0;\n+        let i1p = cast::reinterpret_cast(&i1);\n+        cast::forget(move i1);\n+        let x = @r(i1p);\n+        failfn();\n+        log(error, x);\n+    }\n }"}, {"sha": "4f58e41766b84978cfd42f7413f0f24473ef3fef", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -62,19 +62,21 @@ fn test_box() {\n     assert (@10 == @10);\n }\n \n-fn test_ptr() unsafe {\n-    let p1: *u8 = ::core::cast::reinterpret_cast(&0);\n-    let p2: *u8 = ::core::cast::reinterpret_cast(&0);\n-    let p3: *u8 = ::core::cast::reinterpret_cast(&1);\n+fn test_ptr() {\n+    unsafe {\n+        let p1: *u8 = ::core::cast::reinterpret_cast(&0);\n+        let p2: *u8 = ::core::cast::reinterpret_cast(&0);\n+        let p3: *u8 = ::core::cast::reinterpret_cast(&1);\n \n-    assert p1 == p2;\n-    assert p1 != p3;\n-    assert p1 < p3;\n-    assert p1 <= p3;\n-    assert p3 > p1;\n-    assert p3 >= p3;\n-    assert p1 <= p2;\n-    assert p1 >= p2;\n+        assert p1 == p2;\n+        assert p1 != p3;\n+        assert p1 < p3;\n+        assert p1 <= p3;\n+        assert p3 > p1;\n+        assert p3 >= p3;\n+        assert p1 <= p2;\n+        assert p1 >= p2;\n+    }\n }\n \n #[abi = \"cdecl\"]"}, {"sha": "9df30d90d1c413620450690f521f0cf910064343", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -19,10 +19,12 @@ extern mod libc {\n     fn my_strlen(str: *u8) -> uint;\n }\n \n-fn strlen(str: ~str) -> uint unsafe {\n-    // C string is terminated with a zero\n-    let bytes = str::to_bytes(str) + ~[0u8];\n-    return libc::my_strlen(vec::raw::to_ptr(bytes));\n+fn strlen(str: ~str) -> uint {\n+    unsafe {\n+        // C string is terminated with a zero\n+        let bytes = str::to_bytes(str) + ~[0u8];\n+        return libc::my_strlen(vec::raw::to_ptr(bytes));\n+    }\n }\n \n fn main() {"}, {"sha": "c15616d9f9f80c4facc650c2f6143c1e06955679", "filename": "src/test/run-pass/issue-2214.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2214.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -14,8 +14,10 @@ use core::cast;\n use core::libc::{c_double, c_int};\n use core::f64::*;\n \n-fn to_c_int(v: &mut int) -> &mut c_int unsafe {\n-    cast::reinterpret_cast(&v)\n+fn to_c_int(v: &mut int) -> &mut c_int {\n+    unsafe {\n+        cast::reinterpret_cast(&v)\n+    }\n }\n \n fn lgamma(n: c_double, value: &mut int) -> c_double {"}, {"sha": "871d349b24ba00610d1be744fb70f99c288ccffe", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -34,13 +34,15 @@ pub mod pipes {\n         mut payload: Option<T>\n     };\n \n-    pub fn packet<T: Owned>() -> *packet<T> unsafe {\n-        let p: *packet<T> = cast::transmute(~{\n-            mut state: empty,\n-            mut blocked_task: None::<task::Task>,\n-            mut payload: None::<T>\n-        });\n-        p\n+    pub fn packet<T: Owned>() -> *packet<T> {\n+        unsafe {\n+            let p: *packet<T> = cast::transmute(~{\n+                mut state: empty,\n+                mut blocked_task: None::<task::Task>,\n+                mut payload: None::<T>\n+            });\n+            p\n+        }\n     }\n \n     #[abi = \"rust-intrinsic\"]\n@@ -218,22 +220,26 @@ pub mod pingpong {\n     pub enum ping = ::pipes::send_packet<pong>;\n     pub enum pong = ::pipes::send_packet<ping>;\n \n-    pub fn liberate_ping(-p: ping) -> ::pipes::send_packet<pong> unsafe {\n-        let addr : *::pipes::send_packet<pong> = match &p {\n-          &ping(ref x) => { cast::transmute(ptr::addr_of(x)) }\n-        };\n-        let liberated_value = move *addr;\n-        cast::forget(move p);\n-        move liberated_value\n+    pub fn liberate_ping(-p: ping) -> ::pipes::send_packet<pong> {\n+        unsafe {\n+            let addr : *::pipes::send_packet<pong> = match &p {\n+              &ping(ref x) => { cast::transmute(ptr::addr_of(x)) }\n+            };\n+            let liberated_value = move *addr;\n+            cast::forget(move p);\n+            move liberated_value\n+        }\n     }\n \n-    pub fn liberate_pong(-p: pong) -> ::pipes::send_packet<ping> unsafe {\n-        let addr : *::pipes::send_packet<ping> = match &p {\n-          &pong(ref x) => { cast::transmute(ptr::addr_of(x)) }\n-        };\n-        let liberated_value = move *addr;\n-        cast::forget(move p);\n-        move liberated_value\n+    pub fn liberate_pong(-p: pong) -> ::pipes::send_packet<ping> {\n+        unsafe {\n+            let addr : *::pipes::send_packet<ping> = match &p {\n+              &pong(ref x) => { cast::transmute(ptr::addr_of(x)) }\n+            };\n+            let liberated_value = move *addr;\n+            cast::forget(move p);\n+            move liberated_value\n+        }\n     }\n \n     pub fn init() -> (client::ping, server::ping) {"}, {"sha": "9a0fbdfb77a14fac19dd0426d063fe706ac84e7e", "filename": "src/test/run-pass/issue-2723-b.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fissue-2723-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fissue-2723-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2723-b.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -14,6 +14,8 @@\n extern mod issue_2723_a;\n use issue_2723_a::*;\n \n-fn main() unsafe {\n-  f(~[2]);\n-}\n\\ No newline at end of file\n+fn main() {\n+    unsafe {\n+        f(~[2]);\n+    }\n+}"}, {"sha": "2ab4989f52cf5f697e65e24a7ce1d6d2121fbd29", "filename": "src/test/run-pass/loop-unsafe.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1d1b81143b947fa33745a78cf00af12cda437149/src%2Ftest%2Frun-pass%2Floop-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1b81143b947fa33745a78cf00af12cda437149/src%2Ftest%2Frun-pass%2Floop-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-unsafe.rs?ref=1d1b81143b947fa33745a78cf00af12cda437149", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Tests that \"loop unsafe\" isn't misparsed.\n-\n-fn main() {\n-    loop unsafe {\n-        io::println(\"Hello world!\");\n-        return ();\n-    }\n-}\n-"}, {"sha": "09de165002795579906b804d5bd50e4de9461a66", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -23,9 +23,11 @@ type ccx = {\n     x: int\n };\n \n-fn alloc(_bcx : &arena) -> &bcx unsafe {\n-    return cast::reinterpret_cast(\n-        &libc::malloc(sys::size_of::<bcx/&blk>() as libc::size_t));\n+fn alloc(_bcx : &arena) -> &bcx {   \n+    unsafe {\n+        return cast::reinterpret_cast(\n+            &libc::malloc(sys::size_of::<bcx/&blk>() as libc::size_t));\n+    }\n }\n \n fn h(bcx : &bcx) -> &bcx {"}, {"sha": "80aaad5c90fa6538c29acb8b70247545143459b8", "filename": "src/test/run-pass/resource-cycle.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -26,9 +26,11 @@ impl r : Drop {\n     }\n }\n \n-fn r(v: *int) -> r unsafe {\n-    r {\n-        v: v\n+fn r(v: *int) -> r {\n+    unsafe {\n+        r {\n+            v: v\n+        }\n     }\n }\n \n@@ -37,41 +39,43 @@ enum t = {\n     r: r\n };\n \n-fn main() unsafe {\n-    let i1 = ~0;\n-    let i1p = cast::reinterpret_cast(&i1);\n-    cast::forget(move i1);\n-    let i2 = ~0;\n-    let i2p = cast::reinterpret_cast(&i2);\n-    cast::forget(move i2);\n+fn main() {\n+    unsafe {\n+        let i1 = ~0;\n+        let i1p = cast::reinterpret_cast(&i1);\n+        cast::forget(move i1);\n+        let i2 = ~0;\n+        let i2p = cast::reinterpret_cast(&i2);\n+        cast::forget(move i2);\n \n-    let x1 = @t({\n-        mut next: None,\n-          r: {\n-          let rs = r(i1p);\n-          debug!(\"r = %x\",\n-                 cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&rs)));\n-          move rs }\n-    });\n-    \n-    debug!(\"x1 = %x, x1.r = %x\",\n-        cast::reinterpret_cast::<@t, uint>(&x1),\n-        cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&(x1.r))));\n+        let x1 = @t({\n+            mut next: None,\n+              r: {\n+              let rs = r(i1p);\n+              debug!(\"r = %x\",\n+                     cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&rs)));\n+              move rs }\n+        });\n+        \n+        debug!(\"x1 = %x, x1.r = %x\",\n+            cast::reinterpret_cast::<@t, uint>(&x1),\n+            cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&(x1.r))));\n \n-    let x2 = @t({\n-        mut next: None,\n-          r: {\n-          let rs = r(i2p);\n-          debug!(\"r2 = %x\",\n-                 cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&rs)));\n-          move rs\n-            }\n-    });\n-    \n-    debug!(\"x2 = %x, x2.r = %x\",\n-           cast::reinterpret_cast::<@t, uint>(&x2),\n-           cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&(x2.r))));\n+        let x2 = @t({\n+            mut next: None,\n+              r: {\n+              let rs = r(i2p);\n+              debug!(\"r2 = %x\",\n+                     cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&rs)));\n+              move rs\n+                }\n+        });\n+        \n+        debug!(\"x2 = %x, x2.r = %x\",\n+               cast::reinterpret_cast::<@t, uint>(&x2),\n+               cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&(x2.r))));\n \n-    x1.next = Some(x2);\n-    x2.next = Some(x1);\n+        x1.next = Some(x2);\n+        x2.next = Some(x1);\n+    }\n }"}, {"sha": "3a1f6d812a8e86a7360135edd80fdc474be9b05c", "filename": "src/test/run-pass/resource-cycle2.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -39,25 +39,27 @@ enum t = {\n     r: r\n };\n \n-fn main() unsafe {\n-    let i1 = ~0xA;\n-    let i1p = cast::reinterpret_cast(&i1);\n-    cast::forget(move i1);\n-    let i2 = ~0xA;\n-    let i2p = cast::reinterpret_cast(&i2);\n-    cast::forget(move i2);\n-\n-    let u1 = {a: 0xB, b: 0xC, c: i1p};\n-    let u2 = {a: 0xB, b: 0xC, c: i2p};\n-\n-    let x1 = @t({\n-        mut next: None,\n-        r: r(u1)\n-    });\n-    let x2 = @t({\n-        mut next: None,\n-        r: r(u2)\n-    });\n-    x1.next = Some(x2);\n-    x2.next = Some(x1);\n+fn main() {\n+    unsafe {\n+        let i1 = ~0xA;\n+        let i1p = cast::reinterpret_cast(&i1);\n+        cast::forget(move i1);\n+        let i2 = ~0xA;\n+        let i2p = cast::reinterpret_cast(&i2);\n+        cast::forget(move i2);\n+\n+        let u1 = {a: 0xB, b: 0xC, c: i1p};\n+        let u2 = {a: 0xB, b: 0xC, c: i2p};\n+\n+        let x1 = @t({\n+            mut next: None,\n+            r: r(u1)\n+        });\n+        let x2 = @t({\n+            mut next: None,\n+            r: r(u2)\n+        });\n+        x1.next = Some(x2);\n+        x2.next = Some(x1);\n+    }\n }"}, {"sha": "7a4e9e6faf529f6b4292300479ea98d0bcea8a9b", "filename": "src/test/run-pass/resource-cycle3.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -33,11 +33,13 @@ impl r : Drop {\n     }\n }\n \n-fn r(v: u, w: int, _x: *int) -> r unsafe {\n-    r {\n-        v: v,\n-        w: w,\n-        x: cast::reinterpret_cast(&0)\n+fn r(v: u, w: int, _x: *int) -> r {\n+    unsafe {\n+        r {\n+            v: v,\n+            w: w,\n+            x: cast::reinterpret_cast(&0)\n+        }\n     }\n }\n \n@@ -46,25 +48,27 @@ enum t = {\n     r: r\n };\n \n-fn main() unsafe {\n-    let i1 = ~0xA;\n-    let i1p = cast::reinterpret_cast(&i1);\n-    cast::forget(move i1);\n-    let i2 = ~0xA;\n-    let i2p = cast::reinterpret_cast(&i2);\n-    cast::forget(move i2);\n+fn main() { \n+    unsafe {\n+        let i1 = ~0xA;\n+        let i1p = cast::reinterpret_cast(&i1);\n+        cast::forget(move i1);\n+        let i2 = ~0xA;\n+        let i2p = cast::reinterpret_cast(&i2);\n+        cast::forget(move i2);\n \n-    let u1 = {a: 0xB, b: 0xC, c: i1p};\n-    let u2 = {a: 0xB, b: 0xC, c: i2p};\n+        let u1 = {a: 0xB, b: 0xC, c: i1p};\n+        let u2 = {a: 0xB, b: 0xC, c: i2p};\n \n-    let x1 = @t({\n-        mut next: None,\n-        r: r(u1, 42, i1p)\n-    });\n-    let x2 = @t({\n-        mut next: None,\n-        r: r(u2, 42, i2p)\n-    });\n-    x1.next = Some(x2);\n-    x2.next = Some(x1);\n+        let x1 = @t({\n+            mut next: None,\n+            r: r(u1, 42, i1p)\n+        });\n+        let x2 = @t({\n+            mut next: None,\n+            r: r(u2, 42, i2p)\n+        });\n+        x1.next = Some(x2);\n+        x2.next = Some(x1);\n+    }\n }"}, {"sha": "5435efd40e4f32055aceedc6f1fb3636364d5130", "filename": "src/test/run-pass/rt-sched-1.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-sched-1.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -24,25 +24,27 @@ extern mod rustrt {\n     fn start_task(id: task_id, f: closure);\n }\n \n-fn main() unsafe {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n-    let parent_sched_id = rustrt::rust_get_sched_id();\n-    error!(\"parent %?\", parent_sched_id);\n-    let num_threads = 1u;\n-    let new_sched_id = rustrt::rust_new_sched(num_threads);\n-    error!(\"new_sched_id %?\", new_sched_id);\n-    let new_task_id = rustrt::rust_new_task_in_sched(new_sched_id);\n-    assert !new_task_id.is_null();\n-    let f = fn~() {\n-        let child_sched_id = rustrt::rust_get_sched_id();\n-        error!(\"child_sched_id %?\", child_sched_id);\n-        assert child_sched_id != parent_sched_id;\n-        assert child_sched_id == new_sched_id;\n-        oldcomm::send(ch, ());\n-    };\n-    let fptr = cast::reinterpret_cast(&ptr::addr_of(&f));\n-    rustrt::start_task(new_task_id, fptr);\n-    cast::forget(move f);\n-    oldcomm::recv(po);\n+fn main() {\n+    unsafe {\n+        let po = oldcomm::Port();\n+        let ch = oldcomm::Chan(&po);\n+        let parent_sched_id = rustrt::rust_get_sched_id();\n+        error!(\"parent %?\", parent_sched_id);\n+        let num_threads = 1u;\n+        let new_sched_id = rustrt::rust_new_sched(num_threads);\n+        error!(\"new_sched_id %?\", new_sched_id);\n+        let new_task_id = rustrt::rust_new_task_in_sched(new_sched_id);\n+        assert !new_task_id.is_null();\n+        let f = fn~() {\n+            let child_sched_id = rustrt::rust_get_sched_id();\n+            error!(\"child_sched_id %?\", child_sched_id);\n+            assert child_sched_id != parent_sched_id;\n+            assert child_sched_id == new_sched_id;\n+            oldcomm::send(ch, ());\n+        };\n+        let fptr = cast::reinterpret_cast(&ptr::addr_of(&f));\n+        rustrt::start_task(new_task_id, fptr);\n+        cast::forget(move f);\n+        oldcomm::recv(po);\n+    }\n }"}, {"sha": "64eb50cf0ff03ebb3ad1205f3a4cdad98e6335fc", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -37,7 +37,7 @@ fn main() {\n     test_color(orange, 4, ~\"orange\");\n }\n \n-fn test_color(color: color, val: int, name: ~str) unsafe {\n+fn test_color(color: color, val: int, name: ~str) {\n     //assert unsafe::reinterpret_cast(color) == val;\n     assert color as int == val;\n     assert color as float == val as float;"}, {"sha": "3f925e344756d9dfaf2038c7b48d90416b5674b8", "filename": "src/test/run-pass/unify-return-ty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funify-return-ty.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -13,6 +13,10 @@\n // in that type gets resolved.\n extern mod std;\n \n-fn null<T>() -> *T unsafe { cast::reinterpret_cast(&0) }\n+fn null<T>() -> *T {\n+    unsafe {\n+        cast::reinterpret_cast(&0)\n+    }\n+}\n \n fn main() { null::<int>(); }"}, {"sha": "95d3703a28cbdf963ab51874b77876852226dd93", "filename": "src/test/run-pass/unique-copy-box.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Funique-copy-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Funique-copy-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-copy-box.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main() unsafe {\n-    let i = ~@1;\n-    let j = ~@2;\n-    let rc1 = sys::refcount(*i);\n-    let j = copy i;\n-    let rc2 = sys::refcount(*i);\n-    error!(\"rc1: %u rc2: %u\", rc1, rc2);\n-    assert rc1 + 1u == rc2;\n+fn main() {\n+    unsafe {\n+        let i = ~@1;\n+        let j = ~@2;\n+        let rc1 = sys::refcount(*i);\n+        let j = copy i;\n+        let rc2 = sys::refcount(*i);\n+        error!(\"rc1: %u rc2: %u\", rc1, rc2);\n+        assert rc1 + 1u == rc2;\n+    }\n }"}, {"sha": "5c6fb247497bd9b5d4c1d842b8a6e89076faea34", "filename": "src/test/run-pass/unsafe-fn-called-from-unsafe-blk.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Funsafe-fn-called-from-unsafe-blk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b2cad8b341434c7c0edb153a0fa662fb2981f1/src%2Ftest%2Frun-pass%2Funsafe-fn-called-from-unsafe-blk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsafe-fn-called-from-unsafe-blk.rs?ref=54b2cad8b341434c7c0edb153a0fa662fb2981f1", "patch": "@@ -20,9 +20,5 @@ fn g() {\n     }\n }\n \n-fn h() unsafe {\n-    f();\n-}\n-\n fn main() {\n }"}]}