{"sha": "1c966e7f15a46cc015e7acfde4650b45fee55168", "node_id": "C_kwDOAAsO6NoAKDFjOTY2ZTdmMTVhNDZjYzAxNWU3YWNmZGU0NjUwYjQ1ZmVlNTUxNjg", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-11-24T11:12:05Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-11-24T11:12:05Z"}, "message": "Extract the logic for `TrustedLen` to a named method that can be called directly", "tree": {"sha": "219c7234a58c1d219df1c3e980fad0ed3b3d4405", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/219c7234a58c1d219df1c3e980fad0ed3b3d4405"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c966e7f15a46cc015e7acfde4650b45fee55168", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c966e7f15a46cc015e7acfde4650b45fee55168", "html_url": "https://github.com/rust-lang/rust/commit/1c966e7f15a46cc015e7acfde4650b45fee55168", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c966e7f15a46cc015e7acfde4650b45fee55168/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "341d8b8a2c290b4535e965867e876b095461ff6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/341d8b8a2c290b4535e965867e876b095461ff6e", "html_url": "https://github.com/rust-lang/rust/commit/341d8b8a2c290b4535e965867e876b095461ff6e"}], "stats": {"total": 69, "additions": 37, "deletions": 32}, "files": [{"sha": "9da728b34c3f02537b5b2c198359db0d72c90119", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1c966e7f15a46cc015e7acfde4650b45fee55168/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c966e7f15a46cc015e7acfde4650b45fee55168/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=1c966e7f15a46cc015e7acfde4650b45fee55168", "patch": "@@ -2870,6 +2870,41 @@ impl<T, A: Allocator> Vec<T, A> {\n         }\n     }\n \n+    // specific extend for `TrustedLen` iterators, called both by the specializations\n+    // and internal places where resolving specialization makes compilation slower\n+    #[cfg(not(no_global_oom_handling))]\n+    fn extend_trusted(&mut self, iterator: impl iter::TrustedLen<Item = T>) {\n+        let (low, high) = iterator.size_hint();\n+        if let Some(additional) = high {\n+            debug_assert_eq!(\n+                low,\n+                additional,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n+            self.reserve(additional);\n+            unsafe {\n+                let mut ptr = self.as_mut_ptr().add(self.len());\n+                let mut local_len = SetLenOnDrop::new(&mut self.len);\n+                iterator.for_each(move |element| {\n+                    ptr::write(ptr, element);\n+                    ptr = ptr.add(1);\n+                    // Since the loop executes user code which can panic we have to bump the pointer\n+                    // after each step.\n+                    // NB can't overflow since we would have had to alloc the address space\n+                    local_len.increment_len(1);\n+                });\n+            }\n+        } else {\n+            // Per TrustedLen contract a `None` upper bound means that the iterator length\n+            // truly exceeds usize::MAX, which would eventually lead to a capacity overflow anyway.\n+            // Since the other branch already panics eagerly (via `reserve()`) we do the same here.\n+            // This avoids additional codegen for a fallback code path which would eventually\n+            // panic anyway.\n+            panic!(\"capacity overflow\");\n+        }\n+    }\n+\n     /// Creates a splicing iterator that replaces the specified range in the vector\n     /// with the given `replace_with` iterator and yields the removed items.\n     /// `replace_with` does not need to be the same length as `range`."}, {"sha": "56065ce565bfc492cf2724aa115a7f0f441e71a6", "filename": "library/alloc/src/vec/spec_extend.rs", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1c966e7f15a46cc015e7acfde4650b45fee55168/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c966e7f15a46cc015e7acfde4650b45fee55168/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs?ref=1c966e7f15a46cc015e7acfde4650b45fee55168", "patch": "@@ -1,9 +1,8 @@\n use crate::alloc::Allocator;\n use core::iter::TrustedLen;\n-use core::ptr::{self};\n use core::slice::{self};\n \n-use super::{IntoIter, SetLenOnDrop, Vec};\n+use super::{IntoIter, Vec};\n \n // Specialization trait used for Vec::extend\n pub(super) trait SpecExtend<T, I> {\n@@ -24,36 +23,7 @@ where\n     I: TrustedLen<Item = T>,\n {\n     default fn spec_extend(&mut self, iterator: I) {\n-        // This is the case for a TrustedLen iterator.\n-        let (low, high) = iterator.size_hint();\n-        if let Some(additional) = high {\n-            debug_assert_eq!(\n-                low,\n-                additional,\n-                \"TrustedLen iterator's size hint is not exact: {:?}\",\n-                (low, high)\n-            );\n-            self.reserve(additional);\n-            unsafe {\n-                let mut ptr = self.as_mut_ptr().add(self.len());\n-                let mut local_len = SetLenOnDrop::new(&mut self.len);\n-                iterator.for_each(move |element| {\n-                    ptr::write(ptr, element);\n-                    ptr = ptr.add(1);\n-                    // Since the loop executes user code which can panic we have to bump the pointer\n-                    // after each step.\n-                    // NB can't overflow since we would have had to alloc the address space\n-                    local_len.increment_len(1);\n-                });\n-            }\n-        } else {\n-            // Per TrustedLen contract a `None` upper bound means that the iterator length\n-            // truly exceeds usize::MAX, which would eventually lead to a capacity overflow anyway.\n-            // Since the other branch already panics eagerly (via `reserve()`) we do the same here.\n-            // This avoids additional codegen for a fallback code path which would eventually\n-            // panic anyway.\n-            panic!(\"capacity overflow\");\n-        }\n+        self.extend_trusted(iterator)\n     }\n }\n "}]}