{"sha": "6bc4b5051190940ea180fdf4ff8bd93aac473d9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYzRiNTA1MTE5MDk0MGVhMTgwZmRmNGZmOGJkOTNhYWM0NzNkOWI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-05T13:08:10Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-05T22:34:01Z"}, "message": "MIR borrowck: implement union-and-array-compatible semantics\n\nFixes #44831.\nFixes #44834.\nFixes #45537.\nFixes #45696 (by implementing DerefPure semantics, which is what we want\ngoing forward).", "tree": {"sha": "cb1c45460b2d12a243e9e3d4998fc0acfb0df00e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb1c45460b2d12a243e9e3d4998fc0acfb0df00e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bc4b5051190940ea180fdf4ff8bd93aac473d9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bc4b5051190940ea180fdf4ff8bd93aac473d9b", "html_url": "https://github.com/rust-lang/rust/commit/6bc4b5051190940ea180fdf4ff8bd93aac473d9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bc4b5051190940ea180fdf4ff8bd93aac473d9b/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abe85ab0b232e744b602d20a65fbe92aa71c6045", "url": "https://api.github.com/repos/rust-lang/rust/commits/abe85ab0b232e744b602d20a65fbe92aa71c6045", "html_url": "https://github.com/rust-lang/rust/commit/abe85ab0b232e744b602d20a65fbe92aa71c6045"}], "stats": {"total": 427, "additions": 368, "deletions": 59}, "files": [{"sha": "5d68b30df70194339ff37a6c48e0905069a49589", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 357, "deletions": 51, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/6bc4b5051190940ea180fdf4ff8bd93aac473d9b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc4b5051190940ea180fdf4ff8bd93aac473d9b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=6bc4b5051190940ea180fdf4ff8bd93aac473d9b", "patch": "@@ -36,6 +36,8 @@ use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MoveOutIndex, MovePathIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n+use std::iter;\n+\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n pub(crate) mod nll;\n@@ -710,7 +712,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context,\n             (sd, place_span.0),\n             flow_state,\n-            |this, _index, borrow, common_prefix| match (rw, borrow.kind) {\n+            |this, _index, borrow| match (rw, borrow.kind) {\n                 (Read(_), BorrowKind::Shared) => Control::Continue,\n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut) => {\n                     match kind {\n@@ -727,7 +729,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             error_reported = true;\n                             this.report_conflicting_borrow(\n                                 context,\n-                                common_prefix,\n                                 place_span,\n                                 bk,\n                                 &borrow,\n@@ -748,7 +749,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             error_reported = true;\n                             this.report_conflicting_borrow(\n                                 context,\n-                                common_prefix,\n                                 place_span,\n                                 bk,\n                                 &borrow,\n@@ -1478,15 +1478,364 @@ enum NoMovePathFound {\n     ReachedStatic,\n }\n \n+/// The degree of overlap between 2 places for borrow-checking.\n+enum Overlap {\n+    /// The places might partially overlap - in this case, we give\n+    /// up and say that they might conflict. This occurs when\n+    /// different fields of a union are borrowed. For example,\n+    /// if `u` is a union, we have no way of telling how disjoint\n+    /// `u.a.x` and `a.b.y` are.\n+    Arbitrary,\n+    /// The places are either completely disjoint or equal - this\n+    /// is the \"base case\" on which we recur for extensions of\n+    /// the place.\n+    EqualOrDisjoint,\n+    /// The places are disjoint, so we know all extensions of them\n+    /// will also be disjoint.\n+    Disjoint,\n+}\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    // Given that the bases of `elem1` and `elem2` are always either equal\n+    // or disjoint (and have the same type!), return the overlap situation\n+    // between `elem1` and `elem2`.\n+    fn place_element_conflict(&self,\n+                               elem1: &Place<'tcx>,\n+                               elem2: &Place<'tcx>)\n+                               -> Overlap\n+    {\n+        match (elem1, elem2) {\n+            (Place::Local(l1), Place::Local(l2)) => {\n+                if l1 == l2 {\n+                    // the same local - base case, equal\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n+                    Overlap::EqualOrDisjoint\n+                } else {\n+                    // different locals - base case, disjoint\n+                    debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n+                    Overlap::Disjoint\n+                }\n+            }\n+            (Place::Static(statik1), Place::Static(statik2)) => {\n+                // We ignore borrows of mutable statics elsewhere, but\n+                // we need to keep track of thread-locals so we can\n+                // complain if they live loner than the function.\n+                if statik1.def_id == statik2.def_id {\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                    Overlap::EqualOrDisjoint\n+                } else {\n+                    debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                    Overlap::Disjoint\n+                }\n+            }\n+            (Place::Local(_), Place::Static(_)) |\n+            (Place::Static(_), Place::Local(_)) => {\n+                debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n+                Overlap::Disjoint\n+            }\n+            (Place::Projection(pi1), Place::Projection(pi2)) => {\n+                match (&pi1.elem, &pi2.elem) {\n+                    (ProjectionElem::Deref, ProjectionElem::Deref) => {\n+                        // derefs (e.g. `*x` vs. `*x`) - recur.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n+                        Overlap::EqualOrDisjoint\n+                    }\n+                    (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n+                        if f1 == f2 {\n+                            // same field (e.g. `a.y` vs. `a.y`) - recur.\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                            Overlap::EqualOrDisjoint\n+                        } else {\n+                            let ty = pi1.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                            match ty.sty {\n+                                ty::TyAdt(def, _) if def.is_union() => {\n+                                    // Different fields of a union, we are basically stuck.\n+                                    debug!(\"place_element_conflict: STUCK-UNION\");\n+                                    Overlap::Arbitrary\n+                                }\n+                                _ => {\n+                                    // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n+                                    debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                                    Overlap::Disjoint\n+                                }\n+                            }\n+                        }\n+                    }\n+                    (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n+                        // different variants are treated as having disjoint fields,\n+                        // even if they occupy the same \"space\", because it's\n+                        // impossible for 2 variants of the same enum to exist\n+                        // (and therefore, to be borrowed) at the same time.\n+                        //\n+                        // Note that this is different from unions - we *do* allow\n+                        // this code to compile:\n+                        //\n+                        // ```\n+                        // fn foo(x: &mut Result<i32, i32>) {\n+                        //     let mut v = None;\n+                        //     if let Ok(ref mut a) = *x {\n+                        //         v = Some(a);\n+                        //     }\n+                        //     // here, you would *think* that the\n+                        //     // *entirety* of `x` would be borrowed,\n+                        //     // but in fact only the `Ok` variant is,\n+                        //     // so the `Err` variant is *entirely free*:\n+                        //     if let Err(ref mut a) = *x {\n+                        //         v = Some(a);\n+                        //     }\n+                        //     drop(v);\n+                        // }\n+                        // ```\n+                        if v1 == v2 {\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                            Overlap::EqualOrDisjoint\n+                        } else {\n+                            debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                            Overlap::Disjoint\n+                        }\n+                    }\n+                    (ProjectionElem::Index(..), ProjectionElem::Index(..)) |\n+                    (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. }) |\n+                    (ProjectionElem::Index(..), ProjectionElem::Subslice { .. }) |\n+                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..)) |\n+                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::ConstantIndex { .. }) |\n+                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. }) |\n+                    (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..)) |\n+                    (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. }) |\n+                    (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                        // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n+                        // (if the indexes differ) or equal (if they are the same), so this\n+                        // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n+                        //\n+                        // Note that by construction, MIR at borrowck can't subdivide\n+                        // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n+                        // are only present in slice patterns, and we \"merge together\" nested\n+                        // slice patterns. That means we don't have to think about these. It's\n+                        // probably a good idea to assert this somewhere, but I'm too lazy.\n+                        //\n+                        // FIXME(#8636) we might want to return Disjoint if\n+                        // both projections are constant and disjoint.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n+                        Overlap::EqualOrDisjoint\n+                    }\n+\n+                    (ProjectionElem::Deref, _) |\n+                    (ProjectionElem::Field(..), _) |\n+                    (ProjectionElem::Index(..), _) |\n+                    (ProjectionElem::ConstantIndex { .. }, _) |\n+                    (ProjectionElem::Subslice { .. }, _) |\n+                    (ProjectionElem::Downcast(..), _) => {\n+                        bug!(\"mismatched projections in place_element_conflict: {:?} and {:?}\",\n+\n+                             elem1, elem2)\n+                    }\n+                }\n+            }\n+            (Place::Projection(_), _) |\n+            (_, Place::Projection(_)) => {\n+                bug!(\"unexpected elements in place_element_conflict: {:?} and {:?}\",\n+                     elem1, elem2)\n+            }\n+        }\n+    }\n+    fn borrow_conflicts_with_place(&mut self,\n+                                    borrow: &BorrowData<'tcx>,\n+                                    place: &Place<'tcx>,\n+                                    access: ShallowOrDeep)\n+                                    -> bool\n+    {\n+        debug!(\"borrow_conflicts_with_place({:?},{:?},{:?})\", borrow, place, access);\n+\n+        // Return all the prefixes of `place` in reverse order, including\n+        // downcasts.\n+        fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>>\n+        {\n+            let mut result = vec![];\n+            let mut place = place;\n+            loop {\n+                result.push(place);\n+                match place {\n+                    Place::Projection(interior) => {\n+                        place = &interior.base;\n+                    }\n+                    _ => {\n+                        result.reverse();\n+                        return result;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let borrow_components = place_elements(&borrow.place);\n+        let access_components = place_elements(place);\n+        debug!(\"borrow_conflicts_with_place: components {:?} / {:?}\",\n+               borrow_components, access_components);\n+\n+        let borrow_components = borrow_components.into_iter()\n+             .map(Some).chain(iter::repeat(None));\n+        let access_components = access_components.into_iter()\n+             .map(Some).chain(iter::repeat(None));\n+        // The borrowck rules for proving disjointness are applied from the \"root\" of the\n+        // borrow forwards, iterating over \"similar\" projections in lockstep until\n+        // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n+        // a monoid and report a conflict if the product ends up not being `Disjoint`.\n+        //\n+        // At each step, if we didn't run out of borrow or place, we know that our elements\n+        // have the same type, and that they only overlap if they are the identical.\n+        //\n+        // For example, if we are comparing these:\n+        // BORROW:  (*x1[2].y).z.a\n+        // ACCESS:  (*x1[i].y).w.b\n+        //\n+        // Then our steps are:\n+        //       x1         |   x1          -- places are the same\n+        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+        //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n+        //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n+        //\n+        // Because `zip` does potentially bad things to the iterator inside, this loop\n+        // also handles the case where the access might be a *prefix* of the borrow, e.g.\n+        //\n+        // BORROW:  (*x1[2].y).z.a\n+        // ACCESS:  x1[i].y\n+        //\n+        // Then our steps are:\n+        //       x1         |   x1          -- places are the same\n+        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+        //\n+        // -- here we run out of access - the borrow can access a part of it. If this\n+        // is a full deep access, then we *know* the borrow conflicts with it. However,\n+        // if the access is shallow, then we can proceed:\n+        //\n+        //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n+        //                                     are disjoint\n+        //\n+        // Our invariant is, that at each step of the iteration:\n+        //  - If we didn't run out of access to match, our borrow and access are comparable\n+        //    and either equal or disjoint.\n+        //  - If we did run out of accesss, the borrow can access a part of it.\n+        for (borrow_c, access_c) in borrow_components.zip(access_components) {\n+            // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n+            debug!(\"borrow_conflicts_with_place: {:?} vs. {:?}\", borrow_c, access_c);\n+            match (borrow_c, access_c) {\n+                (None, _) => {\n+                    // If we didn't run out of access, the borrow can access all of our\n+                    // place (e.g. a borrow of `a.b` with an access to `a.b.c`),\n+                    // so we have a conflict.\n+                    //\n+                    // If we did, then we still know that the borrow can access a *part*\n+                    // of our place that our access cares about (a borrow of `a.b.c`\n+                    // with an access to `a.b`), so we still have a conflict.\n+                    //\n+                    // FIXME: Differs from AST-borrowck; includes drive-by fix\n+                    // to #38899. Will probably need back-compat mode flag.\n+                    debug!(\"borrow_conflict_with_place: full borrow, CONFLICT\");\n+                    return true;\n+                }\n+                (Some(borrow_c), None) => {\n+                    // We know that the borrow can access a part of our place. This\n+                    // is a conflict if that is a part our access cares about.\n+\n+                    let (base, elem) = match borrow_c {\n+                        Place::Projection(box Projection { base, elem }) => (base, elem),\n+                        _ => bug!(\"place has no base?\")\n+                    };\n+                    let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+\n+                    match (elem, &base_ty.sty, access) {\n+                        (_, _, Shallow(Some(ArtificialField::Discriminant))) |\n+                        (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                            // The discriminant and array length are like\n+                            // additional fields on the type; they do not\n+                            // overlap any existing data there. Furthermore,\n+                            // they cannot actually be a prefix of any\n+                            // borrowed place (at least in MIR as it is\n+                            // currently.)\n+                            //\n+                            // e.g. a (mutable) borrow of `a[5]` while we read the\n+                            // array length of `a`.\n+                            debug!(\"borrow_conflicts_with_place: implicit field\");\n+                            return false;\n+                        }\n+\n+                        (ProjectionElem::Deref, _, Shallow(None)) => {\n+                            // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n+                            // prefix thereof - the shallow access can't touch anything behind\n+                            // the pointer.\n+                            debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n+                            return false;\n+                        }\n+                        (ProjectionElem::Deref, ty::TyRef(_, ty::TypeAndMut {\n+                            ty: _, mutbl: hir::MutImmutable\n+                        }), _) => {\n+                            // the borrow goes through a dereference of a shared reference.\n+                            //\n+                            // I'm not sure why we are tracking these borrows - shared\n+                            // references can *always* be aliased, which means the\n+                            // permission check already account for this borrow.\n+                            debug!(\"borrow_conflicts_with_place: behind a shared ref\");\n+                            return false;\n+                        }\n+\n+                        (ProjectionElem::Deref, _, Deep) |\n+                        (ProjectionElem::Field { .. }, _, _) |\n+                        (ProjectionElem::Index { ..}, _, _) |\n+                        (ProjectionElem::ConstantIndex { .. }, _, _) |\n+                        (ProjectionElem::Subslice { .. }, _, _) |\n+                        (ProjectionElem::Downcast { .. }, _, _) => {\n+                            // Recursive case. This can still be disjoint on a\n+                            // further iteration if this a shallow access and\n+                            // there's a deref later on, e.g. a borrow\n+                            // of `*x.y` while accessing `x`.\n+                        }\n+                    }\n+                }\n+                (Some(borrow_c), Some(access_c)) => {\n+                    match self.place_element_conflict(&borrow_c, access_c) {\n+                        Overlap::Arbitrary => {\n+                            // We have encountered different fields of potentially\n+                            // the same union - the borrow now partially overlaps.\n+                            //\n+                            // There is no *easy* way of comparing the fields\n+                            // further on, because they might have different types\n+                            // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n+                            // `.y` come from different structs).\n+                            //\n+                            // We could try to do some things here - e.g. count\n+                            // dereferences - but that's probably not a good\n+                            // idea, at least for now, so just give up and\n+                            // report a conflict. This is unsafe code anyway so\n+                            // the user could always use raw pointers.\n+                            debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n+                            return true;\n+                        }\n+                        Overlap::EqualOrDisjoint => {\n+                            // This is the recursive case - proceed to the next element.\n+                        }\n+                        Overlap::Disjoint => {\n+                            // We have proven the borrow disjoint - further\n+                            // projections will remain disjoint.\n+                            debug!(\"borrow_conflicts_with_place: disjoint\");\n+                            return false;\n+                        }\n+                    }\n+\n+                }\n+            }\n+        }\n+        unreachable!(\"iter::repeat returned None\")\n+    }\n+\n     fn each_borrow_involving_path<F>(\n         &mut self,\n         _context: Context,\n         access_place: (ShallowOrDeep, &Place<'tcx>),\n         flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n         mut op: F,\n     ) where\n-        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Place<'tcx>) -> Control,\n+        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,\n     {\n         let (access, place) = access_place;\n \n@@ -1501,47 +1850,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         'next_borrow: for i in flow_state.borrows.elems_incoming() {\n             let borrowed = &data[i];\n \n-            // Is `place` (or a prefix of it) already borrowed? If\n-            // so, that's relevant.\n-            //\n-            // FIXME: Differs from AST-borrowck; includes drive-by fix\n-            // to #38899. Will probably need back-compat mode flag.\n-            for accessed_prefix in self.prefixes(place, PrefixSet::All) {\n-                if *accessed_prefix == borrowed.place {\n-                    // FIXME: pass in enum describing case we are in?\n-                    let ctrl = op(self, i, borrowed, accessed_prefix);\n-                    if ctrl == Control::Break {\n-                        return;\n-                    }\n-                }\n-            }\n-\n-            // Is `place` a prefix (modulo access type) of the\n-            // `borrowed.place`? If so, that's relevant.\n-\n-            let prefix_kind = match access {\n-                Shallow(Some(ArtificialField::Discriminant)) |\n-                Shallow(Some(ArtificialField::ArrayLength)) => {\n-                    // The discriminant and array length are like\n-                    // additional fields on the type; they do not\n-                    // overlap any existing data there. Furthermore,\n-                    // they cannot actually be a prefix of any\n-                    // borrowed place (at least in MIR as it is\n-                    // currently.)\n-                    continue 'next_borrow;\n-                }\n-                Shallow(None) => PrefixSet::Shallow,\n-                Deep => PrefixSet::Supporting,\n-            };\n-\n-            for borrowed_prefix in self.prefixes(&borrowed.place, prefix_kind) {\n-                if borrowed_prefix == place {\n-                    // FIXME: pass in enum describing case we are in?\n-                    let ctrl = op(self, i, borrowed, borrowed_prefix);\n-                    if ctrl == Control::Break {\n-                        return;\n-                    }\n-                }\n+            if self.borrow_conflicts_with_place(borrowed, place, access) {\n+                let ctrl = op(self, i, borrowed);\n+                if ctrl == Control::Break { return; }\n             }\n         }\n     }\n@@ -1595,6 +1906,7 @@ mod prefixes {\n     }\n \n     #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+    #[allow(dead_code)]\n     pub(super) enum PrefixSet {\n         /// Doesn't stop until it returns the base case (a Local or\n         /// Static prefix).\n@@ -1907,17 +2219,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_conflicting_borrow(\n         &mut self,\n         context: Context,\n-        common_prefix: &Place<'tcx>,\n         (place, span): (&Place<'tcx>, Span),\n         gen_borrow_kind: BorrowKind,\n         issued_borrow: &BorrowData,\n         end_issued_loan_span: Option<Span>,\n     ) {\n-        use self::prefixes::IsPrefixOf;\n-\n-        assert!(common_prefix.is_prefix_of(place));\n-        assert!(common_prefix.is_prefix_of(&issued_borrow.place));\n-\n         let issued_span = self.retrieve_borrow_span(issued_borrow);\n \n         let new_closure_span = self.find_closure_span(span, context.loc);"}, {"sha": "df0a05dfaee0e6a15ed1a864cf8c45c32335471b", "filename": "src/test/compile-fail/borrowck/borrowck-thread-local-static-borrow-outlives-fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bc4b5051190940ea180fdf4ff8bd93aac473d9b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc4b5051190940ea180fdf4ff8bd93aac473d9b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.rs?ref=6bc4b5051190940ea180fdf4ff8bd93aac473d9b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-test will be fixed later\n // revisions: ast mir\n //[mir]compile-flags: -Z borrowck=mir\n "}, {"sha": "0241b3870c7e64554f8a692b5c4bc8722dc60fc5", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6bc4b5051190940ea180fdf4ff8bd93aac473d9b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc4b5051190940ea180fdf4ff8bd93aac473d9b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs?ref=6bc4b5051190940ea180fdf4ff8bd93aac473d9b", "patch": "@@ -52,12 +52,12 @@ fn main() {\n         {\n             let ra = &u.a;\n             let rmb = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n-                                // FIXME Error for MIR (needs support for union)\n+                                //[mir]~^ ERROR cannot borrow `u.b` as mutable because it is also borrowed as immutable\n         }\n         {\n             let ra = &u.a;\n             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n-                     // FIXME Error for MIR (needs support for union)\n+                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n         }\n         // Mut borrow, same field\n         {\n@@ -84,22 +84,23 @@ fn main() {\n         {\n             let rma = &mut u.a;\n             let rb = &u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n-                           // FIXME Error for MIR (needs support for union)\n+                           //[mir]~^ ERROR cannot borrow `u.b` as immutable because it is also borrowed as mutable\n         }\n         {\n             let ra = &mut u.a;\n             let b = u.b; //[ast]~ ERROR cannot use `u.b` because it was mutably borrowed\n-                         // FIXME Error for MIR (needs support for union)\n+                         //[mir]~^ ERROR cannot use `u.b` because it was mutably borrowed\n+\n         }\n         {\n             let rma = &mut u.a;\n             let rmb2 = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n-                                 // FIXME Error for MIR (needs support for union)\n+                                 //[mir]~^ ERROR cannot borrow `u.b` as mutable more than once at a time\n         }\n         {\n             let rma = &mut u.a;\n             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n-                     // FIXME Error for MIR (needs support for union)\n+                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n         }\n     }\n }"}, {"sha": "94877b27d5888becd5ec91158c5f764e9da42aa8", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bc4b5051190940ea180fdf4ff8bd93aac473d9b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc4b5051190940ea180fdf4ff8bd93aac473d9b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs?ref=6bc4b5051190940ea180fdf4ff8bd93aac473d9b", "patch": "@@ -1,3 +1,4 @@\n+\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -22,7 +23,7 @@ fn main() {\n     println!(\"t[0]: {}\", t[0]);\n     a[2] = 0; //[ast]~ ERROR cannot assign to `a[..]` because it is borrowed\n               //[cmp]~^ ERROR cannot assign to `a[..]` because it is borrowed (Ast)\n-              // FIXME Error for MIR (error missed)\n+              //[cmp]~| ERROR cannot assign to `a[..]` because it is borrowed (Mir)\n     println!(\"t[0]: {}\", t[0]);\n     t[0];\n }"}, {"sha": "b4a5cd72d86de59bdac80f5d2f808ae421c08f49", "filename": "src/test/compile-fail/issue-25579.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bc4b5051190940ea180fdf4ff8bd93aac473d9b/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc4b5051190940ea180fdf4ff8bd93aac473d9b/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs?ref=6bc4b5051190940ea180fdf4ff8bd93aac473d9b", "patch": "@@ -24,8 +24,8 @@ fn causes_ice(mut l: &mut Sexpression) {\n                                                   //[mir]~| ERROR [E0499]\n             l = &mut **expr; //[ast]~ ERROR [E0506]\n                              //[mir]~^ ERROR [E0506]\n-                             //[mir]~| ERROR [E0506]\n                              //[mir]~| ERROR [E0499]\n+                             //[mir]~| ERROR [E0506]\n                              //[mir]~| ERROR [E0499]\n         }\n     }}"}]}