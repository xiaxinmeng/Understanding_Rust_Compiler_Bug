{"sha": "0e2a782463a3ec667e1a137d3743e46549538072", "node_id": "C_kwDOAAsO6NoAKDBlMmE3ODI0NjNhM2VjNjY3ZTFhMTM3ZDM3NDNlNDY1NDk1MzgwNzI", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-10-09T01:41:40Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-10-09T19:18:01Z"}, "message": "Move check_debugger_output to the debugger module", "tree": {"sha": "005da830478ea5600dd4b2a83dd026e26105368d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/005da830478ea5600dd4b2a83dd026e26105368d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e2a782463a3ec667e1a137d3743e46549538072", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2a782463a3ec667e1a137d3743e46549538072", "html_url": "https://github.com/rust-lang/rust/commit/0e2a782463a3ec667e1a137d3743e46549538072", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e2a782463a3ec667e1a137d3743e46549538072/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce185739fc07dd743043b6e3265ad7442846e837", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce185739fc07dd743043b6e3265ad7442846e837", "html_url": "https://github.com/rust-lang/rust/commit/ce185739fc07dd743043b6e3265ad7442846e837"}], "stats": {"total": 133, "additions": 69, "deletions": 64}, "files": [{"sha": "46799bc4c1506ab7e33435e7ffd2146756cea15e", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 10, "deletions": 64, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0e2a782463a3ec667e1a137d3743e46549538072/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2a782463a3ec667e1a137d3743e46549538072/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=0e2a782463a3ec667e1a137d3743e46549538072", "patch": "@@ -39,7 +39,7 @@ use crate::extract_gdb_version;\n use crate::is_android_gdb_target;\n \n mod debugger;\n-use debugger::DebuggerCommands;\n+use debugger::{check_debugger_output, DebuggerCommands};\n \n #[cfg(test)]\n mod tests;\n@@ -726,7 +726,9 @@ impl<'test> TestCx<'test> {\n             self.fatal_proc_rec(\"Error while running CDB\", &debugger_run_result);\n         }\n \n-        self.check_debugger_output(&debugger_run_result, &check_lines);\n+        if let Err(e) = check_debugger_output(&debugger_run_result, &check_lines) {\n+            self.fatal_proc_rec(&e, &debugger_run_result);\n+        }\n     }\n \n     fn run_debuginfo_gdb_test(&self) {\n@@ -963,7 +965,9 @@ impl<'test> TestCx<'test> {\n             self.fatal_proc_rec(\"gdb failed to execute\", &debugger_run_result);\n         }\n \n-        self.check_debugger_output(&debugger_run_result, &check_lines);\n+        if let Err(e) = check_debugger_output(&debugger_run_result, &check_lines) {\n+            self.fatal_proc_rec(&e, &debugger_run_result);\n+        }\n     }\n \n     fn run_debuginfo_lldb_test(&self) {\n@@ -1100,7 +1104,9 @@ impl<'test> TestCx<'test> {\n             self.fatal_proc_rec(\"Error while running LLDB\", &debugger_run_result);\n         }\n \n-        self.check_debugger_output(&debugger_run_result, &check_lines);\n+        if let Err(e) = check_debugger_output(&debugger_run_result, &check_lines) {\n+            self.fatal_proc_rec(&e, &debugger_run_result);\n+        }\n     }\n \n     fn run_lldb(\n@@ -1183,66 +1189,6 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    fn check_debugger_output(&self, debugger_run_result: &ProcRes, check_lines: &[String]) {\n-        let num_check_lines = check_lines.len();\n-\n-        let mut check_line_index = 0;\n-        for line in debugger_run_result.stdout.lines() {\n-            if check_line_index >= num_check_lines {\n-                break;\n-            }\n-\n-            if check_single_line(line, &(check_lines[check_line_index])[..]) {\n-                check_line_index += 1;\n-            }\n-        }\n-        if check_line_index != num_check_lines && num_check_lines > 0 {\n-            self.fatal_proc_rec(\n-                &format!(\"line not found in debugger output: {}\", check_lines[check_line_index]),\n-                debugger_run_result,\n-            );\n-        }\n-\n-        fn check_single_line(line: &str, check_line: &str) -> bool {\n-            // Allow check lines to leave parts unspecified (e.g., uninitialized\n-            // bits in the  wrong case of an enum) with the notation \"[...]\".\n-            let line = line.trim();\n-            let check_line = check_line.trim();\n-            let can_start_anywhere = check_line.starts_with(\"[...]\");\n-            let can_end_anywhere = check_line.ends_with(\"[...]\");\n-\n-            let check_fragments: Vec<&str> =\n-                check_line.split(\"[...]\").filter(|frag| !frag.is_empty()).collect();\n-            if check_fragments.is_empty() {\n-                return true;\n-            }\n-\n-            let (mut rest, first_fragment) = if can_start_anywhere {\n-                match line.find(check_fragments[0]) {\n-                    Some(pos) => (&line[pos + check_fragments[0].len()..], 1),\n-                    None => return false,\n-                }\n-            } else {\n-                (line, 0)\n-            };\n-\n-            for current_fragment in &check_fragments[first_fragment..] {\n-                match rest.find(current_fragment) {\n-                    Some(pos) => {\n-                        rest = &rest[pos + current_fragment.len()..];\n-                    }\n-                    None => return false,\n-                }\n-            }\n-\n-            if !can_end_anywhere && !rest.is_empty() {\n-                return false;\n-            }\n-\n-            true\n-        }\n-    }\n-\n     fn check_error_patterns(\n         &self,\n         output_to_check: &str,"}, {"sha": "cbd5e4c431f56365bb23a3a66881ccbfd3101b4a", "filename": "src/tools/compiletest/src/runtest/debugger.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0e2a782463a3ec667e1a137d3743e46549538072/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest%2Fdebugger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2a782463a3ec667e1a137d3743e46549538072/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest%2Fdebugger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest%2Fdebugger.rs?ref=0e2a782463a3ec667e1a137d3743e46549538072", "patch": "@@ -1,4 +1,5 @@\n use crate::common::Config;\n+use crate::runtest::ProcRes;\n \n use std::fs::File;\n use std::io::{BufRead, BufReader};\n@@ -54,3 +55,61 @@ impl DebuggerCommands {\n         Ok(Self { commands, check_lines, breakpoint_lines })\n     }\n }\n+\n+pub(super) fn check_debugger_output(\n+    debugger_run_result: &ProcRes,\n+    check_lines: &[String],\n+) -> Result<(), String> {\n+    let num_check_lines = check_lines.len();\n+\n+    let mut check_line_index = 0;\n+    for line in debugger_run_result.stdout.lines() {\n+        if check_line_index >= num_check_lines {\n+            break;\n+        }\n+\n+        if check_single_line(line, &(check_lines[check_line_index])[..]) {\n+            check_line_index += 1;\n+        }\n+    }\n+    if check_line_index != num_check_lines && num_check_lines > 0 {\n+        Err(format!(\"line not found in debugger output: {}\", check_lines[check_line_index]))\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+fn check_single_line(line: &str, check_line: &str) -> bool {\n+    // Allow check lines to leave parts unspecified (e.g., uninitialized\n+    // bits in the  wrong case of an enum) with the notation \"[...]\".\n+    let line = line.trim();\n+    let check_line = check_line.trim();\n+    let can_start_anywhere = check_line.starts_with(\"[...]\");\n+    let can_end_anywhere = check_line.ends_with(\"[...]\");\n+\n+    let check_fragments: Vec<&str> =\n+        check_line.split(\"[...]\").filter(|frag| !frag.is_empty()).collect();\n+    if check_fragments.is_empty() {\n+        return true;\n+    }\n+\n+    let (mut rest, first_fragment) = if can_start_anywhere {\n+        match line.find(check_fragments[0]) {\n+            Some(pos) => (&line[pos + check_fragments[0].len()..], 1),\n+            None => return false,\n+        }\n+    } else {\n+        (line, 0)\n+    };\n+\n+    for current_fragment in &check_fragments[first_fragment..] {\n+        match rest.find(current_fragment) {\n+            Some(pos) => {\n+                rest = &rest[pos + current_fragment.len()..];\n+            }\n+            None => return false,\n+        }\n+    }\n+\n+    if !can_end_anywhere && !rest.is_empty() { false } else { true }\n+}"}]}