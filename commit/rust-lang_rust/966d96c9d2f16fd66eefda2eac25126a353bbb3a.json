{"sha": "966d96c9d2f16fd66eefda2eac25126a353bbb3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NmQ5NmM5ZDJmMTZmZDY2ZWVmZGEyZWFjMjUxMjZhMzUzYmJiM2E=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-09-14T16:36:41Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-09-14T18:54:26Z"}, "message": "feature_gate: Remove dead code from attribute checking\n\nSame checks are performed during name resolution, and all attributes go through name resolution now", "tree": {"sha": "f9fe0437b7abcb848f136e1f1e67333aa88e5375", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9fe0437b7abcb848f136e1f1e67333aa88e5375"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/966d96c9d2f16fd66eefda2eac25126a353bbb3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/966d96c9d2f16fd66eefda2eac25126a353bbb3a", "html_url": "https://github.com/rust-lang/rust/commit/966d96c9d2f16fd66eefda2eac25126a353bbb3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/966d96c9d2f16fd66eefda2eac25126a353bbb3a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca3766e2e58f462a20922e42c821a37eaf0e13db", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca3766e2e58f462a20922e42c821a37eaf0e13db", "html_url": "https://github.com/rust-lang/rust/commit/ca3766e2e58f462a20922e42c821a37eaf0e13db"}], "stats": {"total": 61, "additions": 10, "deletions": 51}, "files": [{"sha": "e8e8da67334712948bda3faf34b092e95e151bf9", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/966d96c9d2f16fd66eefda2eac25126a353bbb3a/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966d96c9d2f16fd66eefda2eac25126a353bbb3a/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=966d96c9d2f16fd66eefda2eac25126a353bbb3a", "patch": "@@ -41,7 +41,6 @@ use syntax::mut_visit::MutVisitor;\n use syntax::parse::{self, PResult};\n use syntax::util::node_count::NodeCounter;\n use syntax::symbol::Symbol;\n-use syntax::feature_gate::AttributeType;\n use syntax_pos::FileName;\n use syntax_ext;\n \n@@ -219,7 +218,6 @@ impl BoxedResolver {\n \n pub struct PluginInfo {\n     syntax_exts: Vec<NamedSyntaxExtension>,\n-    attributes: Vec<(Symbol, AttributeType)>,\n }\n \n pub fn register_plugins<'a>(\n@@ -312,12 +310,9 @@ pub fn register_plugins<'a>(\n     }\n \n     *sess.plugin_llvm_passes.borrow_mut() = llvm_passes;\n-    *sess.plugin_attributes.borrow_mut() = attributes.clone();\n+    *sess.plugin_attributes.borrow_mut() = attributes;\n \n-    Ok((krate, PluginInfo {\n-        syntax_exts,\n-        attributes,\n-    }))\n+    Ok((krate, PluginInfo { syntax_exts }))\n }\n \n fn configure_and_expand_inner<'a>(\n@@ -329,7 +324,6 @@ fn configure_and_expand_inner<'a>(\n     crate_loader: &'a mut CrateLoader<'a>,\n     plugin_info: PluginInfo,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n-    let attributes = plugin_info.attributes;\n     time(sess, \"pre ast expansion lint checks\", || {\n         lint::check_ast_crate(\n             sess,\n@@ -522,7 +516,6 @@ fn configure_and_expand_inner<'a>(\n             &krate,\n             &sess.parse_sess,\n             &sess.features_untracked(),\n-            &attributes,\n             sess.opts.unstable_features,\n         );\n     });"}, {"sha": "ddf847ca3a34c5121c383918765a8ea616da0f1c", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 8, "deletions": 42, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/966d96c9d2f16fd66eefda2eac25126a353bbb3a/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966d96c9d2f16fd66eefda2eac25126a353bbb3a/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=966d96c9d2f16fd66eefda2eac25126a353bbb3a", "patch": "@@ -1,7 +1,7 @@\n use super::{active::{ACTIVE_FEATURES, Features}, Feature, State as FeatureState};\n use super::accepted::ACCEPTED_FEATURES;\n use super::removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};\n-use super::builtin_attrs::{AttributeGate, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n+use super::builtin_attrs::{AttributeGate, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n \n use crate::ast::{\n     self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n@@ -33,9 +33,8 @@ pub enum Stability {\n }\n \n struct Context<'a> {\n-    features: &'a Features,\n     parse_sess: &'a ParseSess,\n-    plugin_attributes: &'a [(Symbol, AttributeType)],\n+    features: &'a Features,\n }\n \n macro_rules! gate_feature_fn {\n@@ -67,7 +66,6 @@ impl<'a> Context<'a> {\n         &self,\n         attr: &ast::Attribute,\n         attr_info: Option<&BuiltinAttribute>,\n-        is_macro: bool\n     ) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n         if let Some(&(name, ty, _template, ref gateage)) = attr_info {\n@@ -87,42 +85,15 @@ impl<'a> Context<'a> {\n                 }\n             }\n             debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n-            return;\n-        } else {\n-            for segment in &attr.path.segments {\n-                if segment.ident.as_str().starts_with(\"rustc\") {\n-                    let msg = \"attributes starting with `rustc` are \\\n-                               reserved for use by the `rustc` compiler\";\n-                    gate_feature!(self, rustc_attrs, segment.ident.span, msg);\n-                }\n-            }\n-        }\n-        for &(n, ty) in self.plugin_attributes {\n-            if attr.path == n {\n-                // Plugins can't gate attributes, so we don't check for it\n-                // unlike the code above; we only use this loop to\n-                // short-circuit to avoid the checks below.\n-                debug!(\"check_attribute: {:?} is registered by a plugin, {:?}\", attr.path, ty);\n-                return;\n-            }\n-        }\n-        if !is_macro && !attr::is_known(attr) {\n-            // Only run the custom attribute lint during regular feature gate\n-            // checking. Macro gating runs before the plugin attributes are\n-            // registered, so we skip this in that case.\n-            let msg = format!(\"the attribute `{}` is currently unknown to the compiler and \\\n-                               may have meaning added to it in the future\", attr.path);\n-            gate_feature!(self, custom_attribute, attr.span, &msg);\n         }\n     }\n }\n \n pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n-    let cx = Context { features, parse_sess, plugin_attributes: &[] };\n+    let cx = Context { parse_sess, features };\n     cx.check_attribute(\n         attr,\n         attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name).map(|a| *a)),\n-        true\n     );\n }\n \n@@ -321,7 +292,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         });\n \n         // Check for gated attributes.\n-        self.context.check_attribute(attr, attr_info, false);\n+        self.context.check_attribute(attr, attr_info);\n \n         if attr.check_name(sym::doc) {\n             if let Some(content) = attr.meta_item_list() {\n@@ -872,21 +843,16 @@ fn active_features_up_to(edition: Edition) -> impl Iterator<Item=&'static Featur\n }\n \n pub fn check_crate(krate: &ast::Crate,\n-                   sess: &ParseSess,\n+                   parse_sess: &ParseSess,\n                    features: &Features,\n-                   plugin_attributes: &[(Symbol, AttributeType)],\n                    unstable: UnstableFeatures) {\n-    maybe_stage_features(&sess.span_diagnostic, krate, unstable);\n-    let ctx = Context {\n-        features,\n-        parse_sess: sess,\n-        plugin_attributes,\n-    };\n+    maybe_stage_features(&parse_sess.span_diagnostic, krate, unstable);\n+    let ctx = Context { parse_sess, features };\n \n     macro_rules! gate_all {\n         ($gate:ident, $msg:literal) => { gate_all!($gate, $gate, $msg); };\n         ($spans:ident, $gate:ident, $msg:literal) => {\n-            for span in &*sess.gated_spans.$spans.borrow() {\n+            for span in &*parse_sess.gated_spans.$spans.borrow() {\n                 gate_feature!(&ctx, $gate, *span, $msg);\n             }\n         }"}]}