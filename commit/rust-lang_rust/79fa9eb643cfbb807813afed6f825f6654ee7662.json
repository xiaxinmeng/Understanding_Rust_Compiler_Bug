{"sha": "79fa9eb643cfbb807813afed6f825f6654ee7662", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZmE5ZWI2NDNjZmJiODA3ODEzYWZlZDZmODI1ZjY2NTRlZTc2NjI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-01T06:44:54Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-05T04:53:32Z"}, "message": "Refactor `SyntaxEnv`.", "tree": {"sha": "297bc23e20e0ac3c43e9a7d921a584b26128a96f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/297bc23e20e0ac3c43e9a7d921a584b26128a96f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79fa9eb643cfbb807813afed6f825f6654ee7662", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79fa9eb643cfbb807813afed6f825f6654ee7662", "html_url": "https://github.com/rust-lang/rust/commit/79fa9eb643cfbb807813afed6f825f6654ee7662", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79fa9eb643cfbb807813afed6f825f6654ee7662/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ed2c0ea7cfc1cc952cc66e78e1b7117367de2c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ed2c0ea7cfc1cc952cc66e78e1b7117367de2c4", "html_url": "https://github.com/rust-lang/rust/commit/4ed2c0ea7cfc1cc952cc66e78e1b7117367de2c4"}], "stats": {"total": 245, "additions": 119, "deletions": 126}, "files": [{"sha": "fe2806891b85e4d6f7af504474deebe6b3e03b47", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 94, "deletions": 75, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/79fa9eb643cfbb807813afed6f825f6654ee7662/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fa9eb643cfbb807813afed6f825f6654ee7662/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=79fa9eb643cfbb807813afed6f825f6654ee7662", "patch": "@@ -24,6 +24,7 @@ use parse::parser;\n use parse::token;\n use parse::token::{InternedString, intern, str_to_ident};\n use ptr::P;\n+use std_inject;\n use util::small_vector::SmallVector;\n use util::lev_distance::find_best_match_for_name;\n use fold::Folder;\n@@ -463,19 +464,6 @@ pub enum SyntaxExtension {\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n-pub struct BlockInfo {\n-    /// Should macros escape from this scope?\n-    pub macros_escape: bool,\n-}\n-\n-impl BlockInfo {\n-    pub fn new() -> BlockInfo {\n-        BlockInfo {\n-            macros_escape: false,\n-        }\n-    }\n-}\n-\n /// The base map of methods for expanding syntax extension\n /// AST nodes into full ASTs\n fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n@@ -586,38 +574,29 @@ pub struct ExtCtxt<'a> {\n     pub crate_root: Option<&'static str>,\n     pub loader: &'a mut MacroLoader,\n \n-    pub mod_path: Vec<ast::Ident> ,\n     pub exported_macros: Vec<ast::MacroDef>,\n \n     pub syntax_env: SyntaxEnv,\n     pub derive_modes: HashMap<InternedString, Box<MultiItemModifier>>,\n     pub recursion_count: usize,\n-\n-    pub directory: PathBuf,\n-    pub in_block: bool,\n }\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n                ecfg: expand::ExpansionConfig<'a>,\n                loader: &'a mut MacroLoader)\n                -> ExtCtxt<'a> {\n-        let env = initial_syntax_expander_table(&ecfg);\n         ExtCtxt {\n+            syntax_env: initial_syntax_expander_table(&ecfg),\n             parse_sess: parse_sess,\n             cfg: cfg,\n             backtrace: NO_EXPANSION,\n-            mod_path: Vec::new(),\n             ecfg: ecfg,\n             crate_root: None,\n             exported_macros: Vec::new(),\n             loader: loader,\n-            syntax_env: env,\n             derive_modes: HashMap::new(),\n             recursion_count: 0,\n-\n-            directory: PathBuf::new(),\n-            in_block: false,\n         }\n     }\n \n@@ -666,14 +645,6 @@ impl<'a> ExtCtxt<'a> {\n         last_macro.expect(\"missing expansion backtrace\")\n     }\n \n-    pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n-    pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n-    pub fn mod_path(&self) -> Vec<ast::Ident> {\n-        let mut v = Vec::new();\n-        v.push(token::str_to_ident(&self.ecfg.crate_name));\n-        v.extend(self.mod_path.iter().cloned());\n-        return v;\n-    }\n     pub fn bt_push(&mut self, ei: ExpnInfo) {\n         self.recursion_count += 1;\n         if self.recursion_count > self.ecfg.recursion_limit {\n@@ -818,6 +789,30 @@ impl<'a> ExtCtxt<'a> {\n             }\n         }\n     }\n+\n+    pub fn initialize(&mut self, user_exts: Vec<NamedSyntaxExtension>, krate: &ast::Crate) {\n+        if std_inject::no_core(&krate) {\n+            self.crate_root = None;\n+        } else if std_inject::no_std(&krate) {\n+            self.crate_root = Some(\"core\");\n+        } else {\n+            self.crate_root = Some(\"std\");\n+        }\n+\n+        // User extensions must be added before expander.load_macros is called,\n+        // so that macros from external crates shadow user defined extensions.\n+        for (name, extension) in user_exts {\n+            self.syntax_env.insert(name, extension);\n+        }\n+\n+        self.syntax_env.current_module = Module(0);\n+        let mut paths = ModulePaths {\n+            mod_path: vec![token::str_to_ident(&self.ecfg.crate_name)],\n+            directory: PathBuf::from(self.parse_sess.codemap().span_to_filename(krate.span)),\n+        };\n+        paths.directory.pop();\n+        self.syntax_env.module_data[0].paths = Rc::new(paths);\n+    }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,\n@@ -904,79 +899,103 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n ///\n /// This environment maps Names to SyntaxExtensions.\n pub struct SyntaxEnv {\n-    chain: Vec<MapChainFrame>,\n+    module_data: Vec<ModuleData>,\n+    current_module: Module,\n+\n     /// All bang-style macro/extension names\n     /// encountered so far; to be used for diagnostics in resolve\n     pub names: HashSet<Name>,\n }\n \n-// impl question: how to implement it? Initially, the\n-// env will contain only macros, so it might be painful\n-// to add an empty frame for every context. Let's just\n-// get it working, first....\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub struct Module(u32);\n \n-// NB! the mutability of the underlying maps means that\n-// if expansion is out-of-order, a deeper scope may be\n-// able to refer to a macro that was added to an enclosing\n-// scope lexically later than the deeper scope.\n+struct ModuleData {\n+    parent: Module,\n+    paths: Rc<ModulePaths>,\n+    macros: HashMap<Name, Rc<SyntaxExtension>>,\n+    macros_escape: bool,\n+    in_block: bool,\n+}\n \n-struct MapChainFrame {\n-    info: BlockInfo,\n-    map: HashMap<Name, Rc<SyntaxExtension>>,\n+#[derive(Clone)]\n+pub struct ModulePaths {\n+    pub mod_path: Vec<ast::Ident>,\n+    pub directory: PathBuf,\n }\n \n impl SyntaxEnv {\n     fn new() -> SyntaxEnv {\n-        let mut map = SyntaxEnv { chain: Vec::new() , names: HashSet::new()};\n-        map.push_frame();\n-        map\n+        let mut env = SyntaxEnv {\n+            current_module: Module(0),\n+            module_data: Vec::new(),\n+            names: HashSet::new(),\n+        };\n+        let paths = Rc::new(ModulePaths { mod_path: Vec::new(), directory: PathBuf::new() });\n+        env.add_module(false, false, paths);\n+        env\n     }\n \n-    pub fn push_frame(&mut self) {\n-        self.chain.push(MapChainFrame {\n-            info: BlockInfo::new(),\n-            map: HashMap::new(),\n-        });\n+    fn data(&self, module: Module) -> &ModuleData {\n+        &self.module_data[module.0 as usize]\n     }\n \n-    pub fn pop_frame(&mut self) {\n-        assert!(self.chain.len() > 1, \"too many pops on MapChain!\");\n-        self.chain.pop();\n+    pub fn set_current_module(&mut self, module: Module) -> Module {\n+        ::std::mem::replace(&mut self.current_module, module)\n     }\n \n-    fn find_escape_frame(&mut self) -> &mut MapChainFrame {\n-        for (i, frame) in self.chain.iter_mut().enumerate().rev() {\n-            if !frame.info.macros_escape || i == 0 {\n-                return frame\n-            }\n-        }\n-        unreachable!()\n+    pub fn paths(&self) -> Rc<ModulePaths> {\n+        self.data(self.current_module).paths.clone()\n+    }\n+\n+    pub fn in_block(&self) -> bool {\n+        self.data(self.current_module).in_block\n     }\n \n-    pub fn find(&self, k: Name) -> Option<Rc<SyntaxExtension>> {\n-        for frame in self.chain.iter().rev() {\n-            if let Some(v) = frame.map.get(&k) {\n-                return Some(v.clone());\n+    pub fn add_module(&mut self, macros_escape: bool, in_block: bool, paths: Rc<ModulePaths>)\n+                      -> Module {\n+        let data = ModuleData {\n+            parent: self.current_module,\n+            paths: paths,\n+            macros: HashMap::new(),\n+            macros_escape: macros_escape,\n+            in_block: in_block,\n+        };\n+\n+        self.module_data.push(data);\n+        Module(self.module_data.len() as u32 - 1)\n+    }\n+\n+    pub fn find(&self, name: Name) -> Option<Rc<SyntaxExtension>> {\n+        let mut module = self.current_module;\n+        let mut module_data;\n+        loop {\n+            module_data = self.data(module);\n+            if let Some(ext) = module_data.macros.get(&name) {\n+                return Some(ext.clone());\n             }\n+            if module == module_data.parent {\n+                return None;\n+            }\n+            module = module_data.parent;\n         }\n-        None\n     }\n \n-    pub fn insert(&mut self, k: Name, v: SyntaxExtension) {\n-        if let NormalTT(..) = v {\n-            self.names.insert(k);\n+    pub fn insert(&mut self, name: Name, ext: SyntaxExtension) {\n+        if let NormalTT(..) = ext {\n+            self.names.insert(name);\n         }\n-        self.find_escape_frame().map.insert(k, Rc::new(v));\n-    }\n \n-    pub fn info(&mut self) -> &mut BlockInfo {\n-        let last_chain_index = self.chain.len() - 1;\n-        &mut self.chain[last_chain_index].info\n+        let mut module = self.current_module;\n+        while self.data(module).macros_escape {\n+            module = self.data(module).parent;\n+        }\n+        self.module_data[module.0 as usize].macros.insert(name, Rc::new(ext));\n     }\n \n     pub fn is_crate_root(&mut self) -> bool {\n         // The first frame is pushed in `SyntaxEnv::new()` and the second frame is\n         // pushed when folding the crate root pseudo-module (c.f. noop_fold_crate).\n-        self.chain.len() <= 2\n+        self.current_module.0 <= 1\n     }\n }"}, {"sha": "a713196032c8693b9f3414e162126ce772b2484b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 20, "deletions": 44, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/79fa9eb643cfbb807813afed6f825f6654ee7662/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fa9eb643cfbb807813afed6f825f6654ee7662/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=79fa9eb643cfbb807813afed6f825f6654ee7662", "patch": "@@ -26,9 +26,9 @@ use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n-use std_inject;\n \n use std::path::PathBuf;\n+use std::rc::Rc;\n \n macro_rules! expansions {\n     ($($kind:ident: $ty:ty, $kind_name:expr, .$make:ident,\n@@ -467,24 +467,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n         false\n     }\n-\n-    fn with_exts_frame<T, F: FnOnce(&mut Self) -> T>(&mut self, macros_escape: bool, f: F) -> T {\n-        self.cx.syntax_env.push_frame();\n-        self.cx.syntax_env.info().macros_escape = macros_escape;\n-        let result = f(self);\n-        self.cx.syntax_env.pop_frame();\n-        result\n-    }\n }\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n-    fn fold_crate(&mut self, c: Crate) -> Crate {\n-        let mut directory = PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(c.span));\n-        directory.pop();\n-        self.cx.directory = directory;\n-        noop_fold_crate(c, self)\n-    }\n-\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let expr = expr.unwrap();\n         if let ast::ExprKind::Mac(mac) = expr.node {\n@@ -542,9 +527,12 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        let was_in_block = ::std::mem::replace(&mut self.cx.in_block, true);\n-        let result = self.with_exts_frame(false, |this| noop_fold_block(block, this));\n-        self.cx.in_block = was_in_block;\n+        let paths = self.cx.syntax_env.paths();\n+        let module = self.cx.syntax_env.add_module(false, true, paths);\n+        let orig_module = self.cx.syntax_env.set_current_module(module);\n+\n+        let result = noop_fold_block(block, self);\n+        self.cx.syntax_env.set_current_module(orig_module);\n         result\n     }\n \n@@ -578,26 +566,27 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n                 })\n             }\n             ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n-                self.cx.mod_push(item.ident);\n-                let macro_use = self.contains_macro_use(&item.attrs);\n-\n-                let directory = self.cx.directory.clone();\n+                let mut paths = (*self.cx.syntax_env.paths()).clone();\n+                paths.mod_path.push(item.ident);\n                 if item.span.contains(inner) {\n-                    self.cx.directory.push(&*{\n+                    paths.directory.push(&*{\n                         ::attr::first_attr_value_str_by_name(&item.attrs, \"path\")\n                             .unwrap_or(item.ident.name.as_str())\n                     });\n                 } else {\n-                    self.cx.directory = match inner {\n+                    paths.directory = match inner {\n                         syntax_pos::DUMMY_SP => PathBuf::new(),\n                         _ => PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(inner)),\n                     };\n-                    self.cx.directory.pop();\n+                    paths.directory.pop();\n                 }\n-                let result = self.with_exts_frame(macro_use, |this| noop_fold_item(item, this));\n-                self.cx.directory = directory;\n \n-                self.cx.mod_pop();\n+                let macro_use = self.contains_macro_use(&item.attrs);\n+                let in_block = self.cx.syntax_env.in_block();\n+                let module = self.cx.syntax_env.add_module(macro_use, in_block, Rc::new(paths));\n+                let module = self.cx.syntax_env.set_current_module(module);\n+                let result = noop_fold_item(item, self);\n+                self.cx.syntax_env.set_current_module(module);\n                 result\n             },\n             _ => noop_fold_item(item, self),\n@@ -744,19 +733,7 @@ pub fn expand_crate(cx: &mut ExtCtxt,\n pub fn expand_crate_with_expander(expander: &mut MacroExpander,\n                                   user_exts: Vec<NamedSyntaxExtension>,\n                                   mut c: Crate) -> Crate {\n-    if std_inject::no_core(&c) {\n-        expander.cx.crate_root = None;\n-    } else if std_inject::no_std(&c) {\n-        expander.cx.crate_root = Some(\"core\");\n-    } else {\n-        expander.cx.crate_root = Some(\"std\");\n-    }\n-\n-    // User extensions must be added before expander.load_macros is called,\n-    // so that macros from external crates shadow user defined extensions.\n-    for (name, extension) in user_exts {\n-        expander.cx.syntax_env.insert(name, extension);\n-    }\n+    expander.cx.initialize(user_exts, &c);\n \n     let items = Expansion::Items(SmallVector::many(c.module.items));\n     let configured = items.fold_with(&mut expander.strip_unconfigured());\n@@ -765,12 +742,11 @@ pub fn expand_crate_with_expander(expander: &mut MacroExpander,\n \n     let err_count = expander.cx.parse_sess.span_diagnostic.err_count();\n     let mut ret = expander.fold_crate(c);\n-    ret.exported_macros = expander.cx.exported_macros.clone();\n-\n     if expander.cx.parse_sess.span_diagnostic.err_count() > err_count {\n         expander.cx.parse_sess.span_diagnostic.abort_if_errors();\n     }\n \n+    ret.exported_macros = expander.cx.exported_macros.clone();\n     ret\n }\n "}, {"sha": "105b2261117385bbaf258e771ccdb49df7d82903", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79fa9eb643cfbb807813afed6f825f6654ee7662/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fa9eb643cfbb807813afed6f825f6654ee7662/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=79fa9eb643cfbb807813afed6f825f6654ee7662", "patch": "@@ -74,11 +74,9 @@ pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTre\n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n-    let string = cx.mod_path()\n-                   .iter()\n-                   .map(|x| x.to_string())\n-                   .collect::<Vec<String>>()\n-                   .join(\"::\");\n+    let paths = cx.syntax_env.paths();\n+    let string = paths.mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n+\n     base::MacEager::expr(cx.expr_str(\n             sp,\n             token::intern_and_get_ident(&string[..])))"}, {"sha": "ed80ec9cbc49e1d5781ebfccf54e67f6420e41f7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79fa9eb643cfbb807813afed6f825f6654ee7662/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fa9eb643cfbb807813afed6f825f6654ee7662/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=79fa9eb643cfbb807813afed6f825f6654ee7662", "patch": "@@ -211,8 +211,8 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                                            imported_from,\n                                            rhs);\n                 let mut p = Parser::new(cx.parse_sess(), cx.cfg(), Box::new(trncbr));\n-                p.directory = cx.directory.clone();\n-                p.restrictions = match cx.in_block {\n+                p.directory = cx.syntax_env.paths().directory.clone();\n+                p.restrictions = match cx.syntax_env.in_block() {\n                     true => Restrictions::NO_NONINLINE_MOD,\n                     false => Restrictions::empty(),\n                 };"}]}